File: 455282_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_FOR_CANON_DIRECTORY (NAME)
     CONST CHAR *NAME;
{
  CHAR *FN;
  INT R;

  FN = (*NAME == '~') ? BASH_TILDE_EXPAND (NAME, 0) : SAVESTRING (NAME);
  BASH_FILENAME_STAT_HOOK (&FN);
  R = FILE_ISDIR (FN);
  FREE (FN);

  RETURN (R);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206781_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT UDF_EXPAND_FILE_ADINICB(STRUCT INODE *INODE)
{
	STRUCT PAGE *PAGE;
	CHAR *KADDR;
	STRUCT UDF_INODE_INFO *IINFO = UDF_I(INODE);
	INT ERR;

	WARN_ON_ONCE(!INODE_IS_LOCKED(INODE));
	IF (!IINFO->I_LENALLOC) {
		IF (UDF_QUERY_FLAG(INODE->I_SB, UDF_FLAG_USE_SHORT_AD))
			IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_SHORT;
		ELSE
			IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_LONG;
		/* FROM NOW ON WE HAVE NORMAL ADDRESS_SPACE METHODS */
		INODE->I_DATA.A_OPS = &UDF_AOPS;
		UP_WRITE(&IINFO->I_DATA_SEM);
		MARK_INODE_DIRTY(INODE);
		RETURN 0;
	}
	/*
	 * RELEASE I_DATA_SEM SO THAT WE CAN LOCK A PAGE - PAGE LOCK RANKS
	 * ABOVE I_DATA_SEM. I_MUTEX STILL PROTECTS US AGAINST FILE CHANGES.
	 */
	UP_WRITE(&IINFO->I_DATA_SEM);

	PAGE = FIND_OR_CREATE_PAGE(INODE->I_MAPPING, 0, GFP_NOFS);
	IF (!PAGE)
		RETURN -ENOMEM;

	IF (!PAGEUPTODATE(PAGE)) {
		KADDR = KMAP_ATOMIC(PAGE);
		MEMSET(KADDR + IINFO->I_LENALLOC, 0X00,
		       PAGE_SIZE - IINFO->I_LENALLOC);
		MEMCPY(KADDR, IINFO->I_DATA + IINFO->I_LENEATTR,
			IINFO->I_LENALLOC);
		FLUSH_DCACHE_PAGE(PAGE);
		SETPAGEUPTODATE(PAGE);
		KUNMAP_ATOMIC(KADDR);
	}
	DOWN_WRITE(&IINFO->I_DATA_SEM);
	MEMSET(IINFO->I_DATA + IINFO->I_LENEATTR, 0X00,
	       IINFO->I_LENALLOC);
	IINFO->I_LENALLOC = 0;
	IF (UDF_QUERY_FLAG(INODE->I_SB, UDF_FLAG_USE_SHORT_AD))
		IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_SHORT;
	ELSE
		IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_LONG;
	/* FROM NOW ON WE HAVE NORMAL ADDRESS_SPACE METHODS */
	INODE->I_DATA.A_OPS = &UDF_AOPS;
	SET_PAGE_DIRTY(PAGE);
	UNLOCK_PAGE(PAGE);
	UP_WRITE(&IINFO->I_DATA_SEM);
	ERR = FILEMAP_FDATAWRITE(INODE->I_MAPPING);
	IF (ERR) {
		/* RESTORE EVERYTHING BACK SO THAT WE DON'T LOSE DATA... */
		LOCK_PAGE(PAGE);
		DOWN_WRITE(&IINFO->I_DATA_SEM);
		KADDR = KMAP_ATOMIC(PAGE);
		MEMCPY(IINFO->I_DATA + IINFO->I_LENEATTR, KADDR, INODE->I_SIZE);
		KUNMAP_ATOMIC(KADDR);
		UNLOCK_PAGE(PAGE);
		IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_IN_ICB;
		INODE->I_DATA.A_OPS = &UDF_ADINICB_AOPS;
		UP_WRITE(&IINFO->I_DATA_SEM);
	}
	PUT_PAGE(PAGE);
	MARK_INODE_DIRTY(INODE);

	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197499_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR BD_DECMFFIELDVEC(GF_BIFSDECODER * CODEC, GF_BITSTREAM *BS, GF_NODE *NODE, GF_FIELDINFO *FIELD, BOOL IS_MEM_COM)
{
	GF_ERR E;
	U32 NBBITS, NBFIELDS;
	U32 I;
	GF_CHILDNODEITEM *LAST;
	U8 QP_LOCAL, QP_ON, INITIAL_QP;
	GF_FIELDINFO SFFIELD;

	MEMSET(&SFFIELD, 0, SIZEOF(GF_FIELDINFO));
	SFFIELD.FIELDINDEX = FIELD->FIELDINDEX;
	SFFIELD.FIELDTYPE = GF_SG_VRML_GET_SF_TYPE(FIELD->FIELDTYPE);
	SFFIELD.NDTTYPE = FIELD->NDTTYPE;
	SFFIELD.NAME = FIELD->NAME;

	INITIAL_QP = QP_LOCAL = QP_ON = 0;

	//VECTOR DESCRIPTION - ALLOC THE MF SIZE BEFORE
	NBBITS = GF_BS_READ_INT(BS, 5);
	NBFIELDS = GF_BS_READ_INT(BS, NBBITS);

	IF (CODEC->ACTIVEQP) {
		INITIAL_QP = 1;
		/*THIS IS FOR QP 14*/
		GF_BIFS_DEC_QP14_SET_LENGTH(CODEC, NBFIELDS);
	}

	IF (FIELD->FIELDTYPE != GF_SG_VRML_MFNODE) {
		E = GF_SG_VRML_MF_ALLOC(FIELD->FAR_PTR, FIELD->FIELDTYPE, NBFIELDS);
		IF (E) RETURN E;

		FOR (I=0; I<NBFIELDS; I++) {
			E = GF_SG_VRML_MF_GET_ITEM(FIELD->FAR_PTR, FIELD->FIELDTYPE, & SFFIELD.FAR_PTR, I);
			IF (E) RETURN E;
			E = GF_BIFS_DEC_SF_FIELD(CODEC, BS, NODE, &SFFIELD, GF_FALSE);
			IF (E) RETURN E;
		}
	} ELSE {
		LAST = NULL;
		FOR (I=0; I<NBFIELDS; I++) {
			GF_NODE *NEW_NODE = GF_BIFS_DEC_NODE(CODEC, BS, FIELD->NDTTYPE);
			IF (NEW_NODE) {
				E = GF_NODE_REGISTER(NEW_NODE, IS_MEM_COM ? NULL : NODE);
				IF (E) RETURN E;

				IF (NODE) {
					/*SPECIAL CASE FOR QP, REGISTER AS THE CURRENT QP*/
					IF (GF_NODE_GET_TAG(NEW_NODE) == TAG_MPEG4_QUANTIZATIONPARAMETER) {
						QP_LOCAL = ((M_QUANTIZATIONPARAMETER *)NEW_NODE)->ISLOCAL;
						/*WE HAVE A QP IN THE SAME SCOPE, REMOVE PREVIOUS
						NB: WE ASSUME THIS IS THE RIGHT BEHAVIOR, THE SPEC DOESN'T SAY
						WHETHER QP IS CUMULATIVE OR NOT*/
						IF (QP_ON) GF_BIFS_DEC_QP_REMOVE(CODEC, GF_FALSE);

						E = GF_BIFS_DEC_QP_SET(CODEC, NEW_NODE);
						IF (E) RETURN E;
						QP_ON = 1;
						IF (QP_LOCAL) QP_LOCAL = 2;
						IF (CODEC->FORCE_KEEP_QP) {
							E = GF_NODE_LIST_ADD_CHILD_LAST(FIELD->FAR_PTR, NEW_NODE, &LAST);
							IF (E) RETURN E;
						} ELSE {
							GF_NODE_REGISTER(NEW_NODE, NULL);
							GF_NODE_UNREGISTER(NEW_NODE, NODE);
						}
					} ELSE {
						E = GF_NODE_LIST_ADD_CHILD_LAST(FIELD->FAR_PTR, NEW_NODE, &LAST);
						IF (E) RETURN E;
					}
				}
				/*PROTO CODING*/
				ELSE IF (CODEC->PCURRENTPROTO) {
					/*TO DO: WHAT HAPPENS IF THIS IS A QP NODE ON THE INTERFACE ?*/
					E = GF_NODE_LIST_ADD_CHILD_LAST( (GF_CHILDNODEITEM **)FIELD->FAR_PTR, NEW_NODE, &LAST);
					IF (E) RETURN E;
				}
			} ELSE {
				RETURN CODEC->LASTERROR ? CODEC->LASTERROR : GF_NON_COMPLIANT_BITSTREAM;
			}
		}
		/*ACCORDING TO THE SPEC, THE QP APPLIES TO THE CURRENT NODE ITSELF, NOT JUST CHILDREN.
		IF ISLOCAL IS TRUE REMOVE THE NODE*/
		IF (QP_ON && QP_LOCAL) {
			IF (QP_LOCAL == 2) {
//				QP_LOCAL = 1;
			} ELSE {
				//ASK TO GET RID OF QP AND REACTIVATE IF WE HAD A QP WHEN ENTERING THE NODE
				GF_BIFS_DEC_QP_REMOVE(CODEC, INITIAL_QP);
//				QP_LOCAL = 0;
			}
		}
	}
	/*FINALLY DELETE THE QP IF ANY (LOCAL OR NOT) AS WE GET OUT OF THIS NODE*/
	IF (QP_ON) GF_BIFS_DEC_QP_REMOVE(CODEC, GF_TRUE);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211110_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LZWDECODECOMPAT(TIFF* TIF, UINT8* OP0, TMSIZE_T OCC0, UINT16 S)
{
	STATIC CONST CHAR MODULE[] = "LZWDECODECOMPAT";
	LZWCODECSTATE *SP = DECODERSTATE(TIF);
	CHAR *OP = (CHAR*) OP0;
	LONG OCC = (LONG) OCC0;
	CHAR *TP;
	UNSIGNED CHAR *BP;
	INT CODE, NBITS;
	LONG NEXTBITS, NEXTDATA, NBITSMASK;
	CODE_T *CODEP, *FREE_ENTP, *MAXCODEP, *OLDCODEP;

	(VOID) S;
	ASSERT(SP != NULL);

	/*
	  FAIL IF VALUE DOES NOT FIT IN LONG.
	*/
	IF ((TMSIZE_T) OCC != OCC0)
	        RETURN (0);

	/*
	 * RESTART INTERRUPTED OUTPUT OPERATION.
	 */
	IF (SP->DEC_RESTART) {
		LONG RESIDUE;

		CODEP = SP->DEC_CODEP;
		RESIDUE = CODEP->LENGTH - SP->DEC_RESTART;
		IF (RESIDUE > OCC) {
			/*
			 * RESIDUE FROM PREVIOUS DECODE IS SUFFICIENT
			 * TO SATISFY DECODE REQUEST.  SKIP TO THE
			 * START OF THE DECODED STRING, PLACE DECODED
			 * VALUES IN THE OUTPUT BUFFER, AND RETURN.
			 */
			SP->DEC_RESTART += OCC;
			DO {
				CODEP = CODEP->NEXT;
			} WHILE (--RESIDUE > OCC);
			TP = OP + OCC;
			DO {
				*--TP = CODEP->VALUE;
				CODEP = CODEP->NEXT;
			} WHILE (--OCC);
			RETURN (1);
		}
		/*
		 * RESIDUE SATISFIES ONLY PART OF THE DECODE REQUEST.
		 */
		OP += RESIDUE;
		OCC -= RESIDUE;
		TP = OP;
		DO {
			*--TP = CODEP->VALUE;
			CODEP = CODEP->NEXT;
		} WHILE (--RESIDUE);
		SP->DEC_RESTART = 0;
	}

	BP = (UNSIGNED CHAR *)TIF->TIF_RAWCP;
#IFDEF LZW_CHECKEOS
	SP->DEC_BITSLEFT = (((UINT64)TIF->TIF_RAWCC) << 3);
#ENDIF
	NBITS = SP->LZW_NBITS;
	NEXTDATA = SP->LZW_NEXTDATA;
	NEXTBITS = SP->LZW_NEXTBITS;
	NBITSMASK = SP->DEC_NBITSMASK;
	OLDCODEP = SP->DEC_OLDCODEP;
	FREE_ENTP = SP->DEC_FREE_ENTP;
	MAXCODEP = SP->DEC_MAXCODEP;

	WHILE (OCC > 0) {
		NEXTCODE(TIF, SP, BP, CODE, GETNEXTCODECOMPAT);
		IF (CODE == CODE_EOI)
			BREAK;
		IF (CODE == CODE_CLEAR) {
			DO {
				FREE_ENTP = SP->DEC_CODETAB + CODE_FIRST;
				_TIFFMEMSET(FREE_ENTP, 0,
					    (CSIZE - CODE_FIRST) * SIZEOF (CODE_T));
				NBITS = BITS_MIN;
				NBITSMASK = MAXCODE(BITS_MIN);
				MAXCODEP = SP->DEC_CODETAB + NBITSMASK;
				NEXTCODE(TIF, SP, BP, CODE, GETNEXTCODECOMPAT);
			} WHILE (CODE == CODE_CLEAR);	/* CONSECUTIVE CODE_CLEAR CODES */
			IF (CODE == CODE_EOI)
				BREAK;
			IF (CODE > CODE_CLEAR) {
				TIFFERROREXT(TIF->TIF_CLIENTDATA, TIF->TIF_NAME,
				"LZWDECODE: CORRUPTED LZW TABLE AT SCANLINE %D",
					     TIF->TIF_ROW);
				RETURN (0);
			}
			*OP++ = (CHAR)CODE;
			OCC--;
			OLDCODEP = SP->DEC_CODETAB + CODE;
			CONTINUE;
		}
		CODEP = SP->DEC_CODETAB + CODE;

		/*
		 * ADD THE NEW ENTRY TO THE CODE TABLE.
		 */
		IF (FREE_ENTP < &SP->DEC_CODETAB[0] ||
		    FREE_ENTP >= &SP->DEC_CODETAB[CSIZE]) {
			TIFFERROREXT(TIF->TIF_CLIENTDATA, MODULE,
			    "CORRUPTED LZW TABLE AT SCANLINE %D", TIF->TIF_ROW);
			RETURN (0);
		}

		FREE_ENTP->NEXT = OLDCODEP;
		IF (FREE_ENTP->NEXT < &SP->DEC_CODETAB[0] ||
		    FREE_ENTP->NEXT >= &SP->DEC_CODETAB[CSIZE]) {
			TIFFERROREXT(TIF->TIF_CLIENTDATA, MODULE,
			    "CORRUPTED LZW TABLE AT SCANLINE %D", TIF->TIF_ROW);
			RETURN (0);
		}
		FREE_ENTP->FIRSTCHAR = FREE_ENTP->NEXT->FIRSTCHAR;
		FREE_ENTP->LENGTH = FREE_ENTP->NEXT->LENGTH+1;
		FREE_ENTP->VALUE = (CODEP < FREE_ENTP) ?
		    CODEP->FIRSTCHAR : FREE_ENTP->FIRSTCHAR;
		IF (++FREE_ENTP > MAXCODEP) {
			IF (++NBITS > BITS_MAX)		/* SHOULD NOT HAPPEN */
				NBITS = BITS_MAX;
			NBITSMASK = MAXCODE(NBITS);
			MAXCODEP = SP->DEC_CODETAB + NBITSMASK;
		}
		OLDCODEP = CODEP;
		IF (CODE >= 256) {
			/*
			 * CODE MAPS TO A STRING, COPY STRING
			 * VALUE TO OUTPUT (WRITTEN IN REVERSE).
			 */
			IF(CODEP->LENGTH == 0) {
				TIFFERROREXT(TIF->TIF_CLIENTDATA, MODULE,
				    "WRONG LENGTH OF DECODED "
				    "STRING: DATA PROBABLY CORRUPTED AT SCANLINE %D",
				    TIF->TIF_ROW);
				RETURN (0);
			}
			IF (CODEP->LENGTH > OCC) {
				/*
				 * STRING IS TOO LONG FOR DECODE BUFFER,
				 * LOCATE PORTION THAT WILL FIT, COPY TO
				 * THE DECODE BUFFER, AND SETUP RESTART
				 * LOGIC FOR THE NEXT DECODING CALL.
				 */
				SP->DEC_CODEP = CODEP;
				DO {
					CODEP = CODEP->NEXT;
				} WHILE (CODEP->LENGTH > OCC);
				SP->DEC_RESTART = OCC;
				TP = OP + OCC;
				DO  {
					*--TP = CODEP->VALUE;
					CODEP = CODEP->NEXT;
				}  WHILE (--OCC);
				BREAK;
			}
			ASSERT(OCC >= CODEP->LENGTH);
			OP += CODEP->LENGTH;
			OCC -= CODEP->LENGTH;
			TP = OP;
			DO {
				*--TP = CODEP->VALUE;
			} WHILE( (CODEP = CODEP->NEXT) != NULL );
		} ELSE {
			*OP++ = (CHAR)CODE;
			OCC--;
		}
	}

	TIF->TIF_RAWCC -= (TMSIZE_T)( (UINT8*) BP - TIF->TIF_RAWCP );
	TIF->TIF_RAWCP = (UINT8*) BP;
	SP->LZW_NBITS = (UNSIGNED SHORT)NBITS;
	SP->LZW_NEXTDATA = NEXTDATA;
	SP->LZW_NEXTBITS = NEXTBITS;
	SP->DEC_NBITSMASK = NBITSMASK;
	SP->DEC_OLDCODEP = OLDCODEP;
	SP->DEC_FREE_ENTP = FREE_ENTP;
	SP->DEC_MAXCODEP = MAXCODEP;

	IF (OCC > 0) {
#IF DEFINED(__WIN32__) && (DEFINED(_MSC_VER) || DEFINED(__MINGW32__))
		TIFFERROREXT(TIF->TIF_CLIENTDATA, MODULE,
			"NOT ENOUGH DATA AT SCANLINE %D (SHORT %I64D BYTES)",
			     TIF->TIF_ROW, (UNSIGNED __INT64) OCC);
#ELSE
		TIFFERROREXT(TIF->TIF_CLIENTDATA, MODULE,
			"NOT ENOUGH DATA AT SCANLINE %D (SHORT %LLU BYTES)",
			     TIF->TIF_ROW, (UNSIGNED LONG LONG) OCC);
#ENDIF
		RETURN (0);
	}
	RETURN (1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210091_CWE-78.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_PASSWORD(CONST CHAR *PROMPT, CHAR *INPUT, INT CAPACITY)
{
#IFDEF ENABLE_SYSTEMD
	INT IS_SYSTEMD_RUNNING;
	STRUCT STAT A, B;

	/* WE SIMPLY TEST WHETHER THE SYSTEMD CGROUP HIERARCHY IS
	 * MOUNTED */
	IS_SYSTEMD_RUNNING = (LSTAT("/SYS/FS/CGROUP", &A) == 0)
		&& (LSTAT("/SYS/FS/CGROUP/SYSTEMD", &B) == 0)
		&& (A.ST_DEV != B.ST_DEV);

	IF (IS_SYSTEMD_RUNNING) {
		CHAR *CMD, *RET;
		FILE *ASK_PASS_FP = NULL;

		CMD = RET = NULL;
		IF (ASPRINTF(&CMD, "SYSTEMD-ASK-PASSWORD \"%S\"", PROMPT) >= 0) {
			ASK_PASS_FP = POPEN (CMD, "RE");
			FREE (CMD);
		}

		IF (ASK_PASS_FP) {
			RET = FGETS(INPUT, CAPACITY, ASK_PASS_FP);
			PCLOSE(ASK_PASS_FP);
		}

		IF (RET) {
			INT LEN = STRLEN(INPUT);
			IF (INPUT[LEN - 1] == '\N')
				INPUT[LEN - 1] = '\0';
			RETURN INPUT;
		}
	}
#ENDIF

	/*
	 * FALLING BACK TO GETPASS(..)
	 * GETPASS IS OBSOLETE, BUT THERE'S APPARENTLY NOTHING THAT REPLACES IT
	 */
	CHAR *TMP_PASS = GETPASS(PROMPT);
	IF (!TMP_PASS)
		RETURN NULL;

	STRNCPY(INPUT, TMP_PASS, CAPACITY - 1);
	INPUT[CAPACITY - 1] = '\0';

	/* ZERO-OUT THE STATIC BUFFER */
	MEMSET(TMP_PASS, 0, STRLEN(TMP_PASS));

	RETURN INPUT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 430368_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SEQ_WRITE(STRUCT SEQ_FILE *SEQ, CONST VOID *DATA, SIZE_T LEN)
{
	IF (SEQ->COUNT + LEN < SEQ->SIZE) {
		MEMCPY(SEQ->BUF + SEQ->COUNT, DATA, LEN);
		SEQ->COUNT += LEN;
		RETURN 0;
	}
	SEQ_SET_OVERFLOW(SEQ);
	RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 383303_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT GDIMAGEBRIGHTNESS(GDIMAGEPTR SRC, INT BRIGHTNESS)
{
	INT X, Y;
	INT R,G,B,A;
	INT NEW_PXL, PXL;
	TYPEDEF INT (*FUNCPTR)(GDIMAGEPTR, INT, INT);
	FUNCPTR F;
	F = GET_PIXEL_FUNCTION(SRC);

	IF (SRC==NULL || (BRIGHTNESS < -255 || BRIGHTNESS>255)) {
		RETURN 0;
	}
  
	IF (BRIGHTNESS==0) {
		RETURN 1;
	}

	FOR (Y=0; Y<SRC->SY; ++Y) {
		FOR (X=0; X<SRC->SX; ++X) {
			PXL = F (SRC, X, Y);
			
			R = GDIMAGERED(SRC, PXL);
			G = GDIMAGEGREEN(SRC, PXL);
			B = GDIMAGEBLUE(SRC, PXL);
			A = GDIMAGEALPHA(SRC, PXL);
			
			R = R + BRIGHTNESS;
			G = G + BRIGHTNESS;
			B = B + BRIGHTNESS;
			
			R = (R > 255)? 255 : ((R < 0)? 0:R);
			G = (G > 255)? 255 : ((G < 0)? 0:G);
			B = (B > 255)? 255 : ((B < 0)? 0:B);

			NEW_PXL = GDIMAGECOLORALLOCATEALPHA(SRC, (INT)R, (INT)G, (INT)B, A);
			IF (NEW_PXL == -1) {
				NEW_PXL = GDIMAGECOLORCLOSESTALPHA(SRC, (INT)R, (INT)G, (INT)B, A);
			}
			IF ((Y >= 0) && (Y < SRC->SY)) {
				GDIMAGESETPIXEL (SRC, X, Y, NEW_PXL);
			}
		}
	}
	RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210050_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SINGLEVAR (LEXSTATE *LS, EXPDESC *VAR) {
  TSTRING *VARNAME = STR_CHECKNAME(LS);
  FUNCSTATE *FS = LS->FS;
  SINGLEVARAUX(FS, VARNAME, VAR, 1);
  IF (VAR->K == VVOID) {  /* GLOBAL NAME? */
    EXPDESC KEY;
    SINGLEVARAUX(FS, LS->ENVN, VAR, 1);  /* GET ENVIRONMENT VARIABLE */
    LUA_ASSERT(VAR->K != VVOID);  /* THIS ONE MUST EXIST */
    CODESTRING(&KEY, VARNAME);  /* KEY IS VARIABLE NAME */
    LUAK_INDEXED(FS, VAR, &KEY);  /* ENV[VARNAME] */
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219949_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_USER_UPDATE_PASSWORD (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * USER_DATA) {
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)USER_DATA;
  JSON_T * J_SESSION, * J_PASSWORD, * J_ELEMENT = NULL;
  CHAR * SESSION_UID = GET_SESSION_ID(CONFIG, REQUEST);
  CONST CHAR ** PASSWORDS = NULL;
  INT RES;
  STRUCT _USER_MODULE_INSTANCE * USER_MODULE;
  SIZE_T INDEX = 0;

  IF (SESSION_UID != NULL && O_STRLEN(SESSION_UID)) {
    J_SESSION = GET_CURRENT_USER_FOR_SESSION(CONFIG, SESSION_UID);
    IF (CHECK_RESULT_VALUE(J_SESSION, G_OK)) {
      J_PASSWORD = ULFIUS_GET_JSON_BODY_REQUEST(REQUEST, NULL);
      USER_MODULE = GET_USER_MODULE_INSTANCE(CONFIG, JSON_STRING_VALUE(JSON_OBJECT_GET(JSON_OBJECT_GET(J_SESSION, "USER"), "SOURCE")));
      IF (USER_MODULE && USER_MODULE->MULTIPLE_PASSWORDS) {
        IF (JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PASSWORD, "OLD_PASSWORD")) && JSON_IS_ARRAY(JSON_OBJECT_GET(J_PASSWORD, "PASSWORD"))) {
          IF ((PASSWORDS = O_MALLOC(JSON_ARRAY_SIZE(JSON_OBJECT_GET(J_PASSWORD, "PASSWORD")) * SIZEOF(CHAR *))) != NULL) {
            JSON_ARRAY_FOREACH(JSON_OBJECT_GET(J_PASSWORD, "PASSWORD"), INDEX, J_ELEMENT) {
              PASSWORDS[INDEX] = JSON_STRING_VALUE(J_ELEMENT);
            }
            IF ((RES = USER_UPDATE_PASSWORD(CONFIG, JSON_STRING_VALUE(JSON_OBJECT_GET(JSON_OBJECT_GET(J_SESSION, "USER"), "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PASSWORD, "OLD_PASSWORD")), PASSWORDS, JSON_ARRAY_SIZE(JSON_OBJECT_GET(J_PASSWORD, "PASSWORD")))) == G_ERROR_PARAM) {
              RESPONSE->STATUS = 400;
            } ELSE IF (RES != G_OK) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_UPDATE_PASSWORD - ERROR USER_UPDATE_PASSWORD (1)");
              RESPONSE->STATUS = 500;
            }
          } ELSE {
            Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_UPDATE_PASSWORD - ERROR ALLOCATING RESOURCES FOR PASSWORDS (1)");
            RESPONSE->STATUS = 500;
          }
          O_FREE(PASSWORDS);
        } ELSE {
          RESPONSE->STATUS = 400;
        }
      } ELSE {
        IF (JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PASSWORD, "OLD_PASSWORD")) && JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PASSWORD, "PASSWORD"))) {
          IF ((PASSWORDS = O_MALLOC(SIZEOF(CHAR *))) != NULL) {
            PASSWORDS[0] = JSON_STRING_VALUE(JSON_OBJECT_GET(J_PASSWORD, "PASSWORD"));
            IF ((RES = USER_UPDATE_PASSWORD(CONFIG, JSON_STRING_VALUE(JSON_OBJECT_GET(JSON_OBJECT_GET(J_SESSION, "USER"), "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PASSWORD, "OLD_PASSWORD")), PASSWORDS, 1)) == G_ERROR_PARAM) {
              RESPONSE->STATUS = 400;
            } ELSE IF (RES != G_OK) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_UPDATE_PASSWORD - ERROR USER_UPDATE_PASSWORD (2)");
              RESPONSE->STATUS = 500;
            }
          } ELSE {
            Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_UPDATE_PASSWORD - ERROR ALLOCATING RESOURCES FOR PASSWORDS (2)");
            RESPONSE->STATUS = 500;
          }
          O_FREE(PASSWORDS);
        } ELSE {
          RESPONSE->STATUS = 400;
        }
      }
      JSON_DECREF(J_PASSWORD);
    } ELSE IF (CHECK_RESULT_VALUE(J_SESSION, G_ERROR_NOT_FOUND)) {
      RESPONSE->STATUS = 401;
    } ELSE {
      Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_UPDATE_PASSWORD - ERROR GET_CURRENT_USER_FOR_SESSION");
      RESPONSE->STATUS = 500;
    }
    JSON_DECREF(J_SESSION);
  } ELSE {
    RESPONSE->STATUS = 401;
  }
  O_FREE(SESSION_UID);
  
  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 513002_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  ITEM *GET_COPY(THD *THD)
  { RETURN GET_ITEM_COPY<ITEM_HEX_STRING>(THD, THIS); }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336807_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LPRN_IS_BLACK(GX_DEVICE_PRINTER * PDEV, INT R, INT H, INT BX)
{
    GX_DEVICE_LPRN *CONST LPRN = (GX_DEVICE_LPRN *) PDEV;

    INT BH = LPRN->NBH;
    INT BPL = GDEV_MEM_BYTES_PER_SCAN_LINE(PDEV);
    INT X, Y, Y0;
    BYTE *P;
    INT MAXY = LPRN->BLOCKLINE / LPRN->NBH * LPRN->NBH;

    Y0 = (R + H - BH) % MAXY;
    FOR (Y = 0; Y < BH; Y++) {
        P = &LPRN->IMAGEBUF[(Y0 + Y) * BPL + BX * LPRN->NBW];
        FOR (X = 0; X < LPRN->NBW; X++) {
            /* BPL ISN'T NECESSARILY A MULTIPLE OF LPRN->NBW, SO
            WE NEED TO EXPLICITLY STOP AFTER THE LAST BYTE IN THIS
            LINE TO AVOID ACCESSING EITHER THE NEXT LINE'S DATA OR
            GOING OFF THE END OF OUR BUFFER COMPLETELY. THIS AVOIDS
            HTTPS://BUGS.GHOSTSCRIPT.COM/SHOW_BUG.CGI?ID=701785. */
            IF (BX * LPRN->NBW + X >= BPL)  BREAK;
            IF (P[X] != 0)
                RETURN 1;
        }
    }
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 326105_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
REG(
    INT		PAREN,	// REG_NOPAREN, REG_PAREN, REG_NPAREN OR REG_ZPAREN
    INT		*FLAGP)
{
    CHAR_U	*RET;
    CHAR_U	*BR;
    CHAR_U	*ENDER;
    INT		PARNO = 0;
    INT		FLAGS;

    *FLAGP = HASWIDTH;		// TENTATIVELY.

#IFDEF FEAT_SYN_HL
    IF (PAREN == REG_ZPAREN)
    {
	// MAKE A ZOPEN NODE.
	IF (REGNZPAR >= NSUBEXP)
	    EMSG_RET_NULL(_(E_TOO_MANY_Z));
	PARNO = REGNZPAR;
	REGNZPAR++;
	RET = REGNODE(ZOPEN + PARNO);
    }
    ELSE
#ENDIF
	IF (PAREN == REG_PAREN)
    {
	// MAKE A MOPEN NODE.
	IF (REGNPAR >= NSUBEXP)
	    EMSG2_RET_NULL(_(E_TOO_MANY_STR_OPEN), REG_MAGIC == MAGIC_ALL);
	PARNO = REGNPAR;
	++REGNPAR;
	RET = REGNODE(MOPEN + PARNO);
    }
    ELSE IF (PAREN == REG_NPAREN)
    {
	// MAKE A NOPEN NODE.
	RET = REGNODE(NOPEN);
    }
    ELSE
	RET = NULL;

    // PICK UP THE BRANCHES, LINKING THEM TOGETHER.
    BR = REGBRANCH(&FLAGS);
    IF (BR == NULL)
	RETURN NULL;
    IF (RET != NULL)
	REGTAIL(RET, BR);	// [MZ]OPEN -> FIRST.
    ELSE
	RET = BR;
    // IF ONE OF THE BRANCHES CAN BE ZERO-WIDTH, THE WHOLE THING CAN.
    // IF ONE OF THE BRANCHES HAS * AT START OR MATCHES A LINE-BREAK, THE
    // WHOLE THING CAN.
    IF (!(FLAGS & HASWIDTH))
	*FLAGP &= ~HASWIDTH;
    *FLAGP |= FLAGS & (SPSTART | HASNL | HASLOOKBH);
    WHILE (PEEKCHR() == MAGIC('|'))
    {
	SKIPCHR();
	BR = REGBRANCH(&FLAGS);
	IF (BR == NULL || REG_TOOLONG)
	    RETURN NULL;
	REGTAIL(RET, BR);	// BRANCH -> BRANCH.
	IF (!(FLAGS & HASWIDTH))
	    *FLAGP &= ~HASWIDTH;
	*FLAGP |= FLAGS & (SPSTART | HASNL | HASLOOKBH);
    }

    // MAKE A CLOSING NODE, AND HOOK IT ON THE END.
    ENDER = REGNODE(
#IFDEF FEAT_SYN_HL
	    PAREN == REG_ZPAREN ? ZCLOSE + PARNO :
#ENDIF
	    PAREN == REG_PAREN ? MCLOSE + PARNO :
	    PAREN == REG_NPAREN ? NCLOSE : END);
    REGTAIL(RET, ENDER);

    // HOOK THE TAILS OF THE BRANCHES TO THE CLOSING NODE.
    FOR (BR = RET; BR != NULL; BR = REGNEXT(BR))
	REGOPTAIL(BR, ENDER);

    // CHECK FOR PROPER TERMINATION.
    IF (PAREN != REG_NOPAREN && GETCHR() != MAGIC(')'))
    {
#IFDEF FEAT_SYN_HL
	IF (PAREN == REG_ZPAREN)
	    EMSG_RET_NULL(_(E_UNMATCHED_Z));
	ELSE
#ENDIF
	    IF (PAREN == REG_NPAREN)
	    EMSG2_RET_NULL(_(E_UNMATCHED_STR_PERCENT_OPEN), REG_MAGIC == MAGIC_ALL);
	ELSE
	    EMSG2_RET_NULL(_(E_UNMATCHED_STR_OPEN), REG_MAGIC == MAGIC_ALL);
    }
    ELSE IF (PAREN == REG_NOPAREN && PEEKCHR() != NUL)
    {
	IF (CURCHR == MAGIC(')'))
	    EMSG2_RET_NULL(_(E_UNMATCHED_STR_CLOSE), REG_MAGIC == MAGIC_ALL);
	ELSE
	    EMSG_RET_NULL(_(E_TRAILING_CHARACTERS));	// "CAN'T HAPPEN".
	// NOTREACHED
    }
    // HERE WE SET THE FLAG ALLOWING BACK REFERENCES TO THIS SET OF
    // PARENTHESES.
    IF (PAREN == REG_PAREN)
	HAD_ENDBRACE[PARNO] = TRUE;	// HAVE SEEN THE CLOSE PAREN
    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 292220_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INBOUND_PART (SERVER *SERV, CHAR *CHAN, CHAR *USER, CHAR *IP, CHAR *REASON,
				  CONST MESSAGE_TAGS_DATA *TAGS_DATA)
{
	SESSION *SESS = FIND_CHANNEL (SERV, CHAN);
	IF (SESS)
	{
		IF (*REASON)
			EMIT_SIGNAL_TIMESTAMP (XP_TE_PARTREASON, SESS, USER, IP, CHAN, REASON,
										  0, TAGS_DATA->TIMESTAMP);
		ELSE
			EMIT_SIGNAL_TIMESTAMP (XP_TE_PART, SESS, USER, IP, CHAN, NULL, 0,
										  TAGS_DATA->TIMESTAMP);
		USERLIST_REMOVE (SESS, USER);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204073_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CHAR ** SPLIT(CONST CHAR *ARG, CONST CHAR *DELIM) {
  CHAR *COPY = DUPSTR(ARG);
  CHAR **RESULT = NULL;
  INT I = 0;

  FOR (CHAR *CPTR = STRTOK(COPY, DELIM); CPTR; CPTR = STRTOK(NULL, DELIM)) {
    CHAR **TMP = REALLOC (RESULT, SIZEOF *RESULT * (I + 1));
    IF (!TMP && RESULT) {
      WHILE (I > 0) {
	FREE(RESULT[--I]);
      }
      FREE(RESULT);
      FREE(COPY);
      RETURN NULL;
    }
    RESULT = TMP;
    RESULT[I++] = DUPSTR(CPTR);
  }

  FREE(COPY);

  IF (I) {
    CHAR **TMP = REALLOC(RESULT, SIZEOF *RESULT * (I + 1));
    IF (!TMP) {
      WHILE (I > 0) {
	FREE(RESULT[--I]);
      }
      FREE(RESULT);
      FREE(COPY);
      RETURN NULL;
    }
    RESULT = TMP;
    RESULT[I++] = NULL;
  }

  RETURN RESULT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204830_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT VFSMOUNT *CLONE_PRIVATE_MOUNT(CONST STRUCT PATH *PATH)
{
	STRUCT MOUNT *OLD_MNT = REAL_MOUNT(PATH->MNT);
	STRUCT MOUNT *NEW_MNT;

	IF (IS_MNT_UNBINDABLE(OLD_MNT))
		RETURN ERR_PTR(-EINVAL);

	NEW_MNT = CLONE_MNT(OLD_MNT, PATH->DENTRY, CL_PRIVATE);
	IF (IS_ERR(NEW_MNT))
		RETURN ERR_CAST(NEW_MNT);

	/* LONGTERM MOUNT TO BE REMOVED BY KERN_UNMOUNT*() */
	NEW_MNT->MNT_NS = MNT_NS_INTERNAL;

	RETURN &NEW_MNT->MNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201353_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT RSI_INIT_USB_INTERFACE(STRUCT RSI_HW *ADAPTER,
				  STRUCT USB_INTERFACE *PFUNCTION)
{
	STRUCT RSI_91X_USBDEV *RSI_DEV;
	INT STATUS;

	RSI_DEV = KZALLOC(SIZEOF(*RSI_DEV), GFP_KERNEL);
	IF (!RSI_DEV)
		RETURN -ENOMEM;

	ADAPTER->RSI_DEV = RSI_DEV;
	RSI_DEV->USBDEV = INTERFACE_TO_USBDEV(PFUNCTION);
	RSI_DEV->PRIV = (VOID *)ADAPTER;

	IF (RSI_FIND_BULK_IN_AND_OUT_ENDPOINTS(PFUNCTION, ADAPTER)) {
		STATUS = -EINVAL;
		GOTO FAIL_EPS;
	}

	ADAPTER->DEVICE = &PFUNCTION->DEV;
	USB_SET_INTFDATA(PFUNCTION, ADAPTER);

	RSI_DEV->TX_BUFFER = KMALLOC(2048, GFP_KERNEL);
	IF (!RSI_DEV->TX_BUFFER) {
		STATUS = -ENOMEM;
		GOTO FAIL_EPS;
	}

	IF (RSI_USB_INIT_RX(ADAPTER)) {
		RSI_DBG(ERR_ZONE, "FAILED TO INIT RX HANDLE\N");
		STATUS = -ENOMEM;
		GOTO FAIL_RX;
	}

	RSI_DEV->TX_BLK_SIZE = 252;
	ADAPTER->BLOCK_SIZE = RSI_DEV->TX_BLK_SIZE;

	/* INITIALIZING FUNCTION CALLBACKS */
	ADAPTER->CHECK_HW_QUEUE_STATUS = RSI_USB_CHECK_QUEUE_STATUS;
	ADAPTER->DETERMINE_EVENT_TIMEOUT = RSI_USB_EVENT_TIMEOUT;
	ADAPTER->RSI_HOST_INTF = RSI_HOST_INTF_USB;
	ADAPTER->HOST_INTF_OPS = &USB_HOST_INTF_OPS;

#IFDEF CONFIG_RSI_DEBUGFS
	/* IN USB, ONE LESS THAN THE MAX_DEBUGFS_ENTRIES ENTRIES IS REQUIRED */
	ADAPTER->NUM_DEBUGFS_ENTRIES = (MAX_DEBUGFS_ENTRIES - 1);
#ENDIF

	RSI_DBG(INIT_ZONE, "%S: ENABLED THE INTERFACE\N", __FUNC__);
	RETURN 0;

FAIL_RX:
	KFREE(RSI_DEV->TX_BUFFER);

FAIL_EPS:
	KFREE(RSI_DEV);

	RETURN STATUS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 274681_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID CALLBACKS_UPDATE_RULER_POINTERS (VOID) {
	DOUBLE XPOSITION, YPOSITION;
	XPOSITION = SCREENRENDERINFO.LOWERLEFTX + (SCREEN.LAST_X / SCREENRENDERINFO.SCALEFACTORX);
	YPOSITION = SCREENRENDERINFO.LOWERLEFTY + ((SCREENRENDERINFO.DISPLAYHEIGHT - SCREEN.LAST_Y) / SCREENRENDERINFO.SCALEFACTORY);

	IF (!((SCREEN.UNIT == GERBV_MILS) && ((SCREENRENDERINFO.SCALEFACTORX < 80)||(SCREENRENDERINFO.SCALEFACTORY < 80)))) {
		XPOSITION = CALLBACKS_CALCULATE_ACTUAL_DISTANCE (XPOSITION);
		YPOSITION = CALLBACKS_CALCULATE_ACTUAL_DISTANCE (YPOSITION);
	}
	G_OBJECT_SET (G_OBJECT (SCREEN.WIN.HRULER), "POSITION", XPOSITION, NULL);
	G_OBJECT_SET (G_OBJECT (SCREEN.WIN.VRULER), "POSITION", YPOSITION, NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 217547_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT64_T GMFOPENMESH(CONST CHAR *FILNAM, INT MOD, ...)
{
   INT      KWDCOD, RES, *PTRVER, *PTRDIM, ERR;
   INT64_T  MSHIDX;
   CHAR     STR[ GMFSTRSIZ ];
   VA_LIST  VARARG;
   GMFMSHSCT *MSH;

   /*---------------------*/
   /* MESH STRUCTURE INIT */
   /*---------------------*/

   IF(!(MSH = CALLOC(1, SIZEOF(GMFMSHSCT))))
      RETURN(0);

   MSHIDX = (INT64_T)MSH;

   // SAVE THE CURRENT STACK ENVIRONMENT FOR LONGJMP
   IF( (ERR = SETJMP(MSH->ERR)) != 0)
   {
#IFDEF GMFDEBUG
      PRINTF("LIBMESHB : MESH %P : ERROR %D\N", MSH, ERR);
#ENDIF
      IF(MSH->HDL != NULL)
         FCLOSE(MSH->HDL);

      IF(MSH->FILDES != 0)
#IFDEF GMF_WINDOWS
         _CLOSE(MSH->FILDES);
#ELSE
         CLOSE(MSH->FILDES);
#ENDIF

      FREE(MSH);
      RETURN(0);
   }

   // COPY THE FILNAM INTO THE STRUCTURE
   IF(STRLEN(FILNAM) + 7 >= GMFSTRSIZ)
      LONGJMP(MSH->ERR, -4);

   STRCPY(MSH->FILNAM, FILNAM);

   // STORE THE OPENING MOD (READ OR WRITE) AND GUESS
   // THE FILETYPE (BINARY OR ASCII) DEPENDING ON THE EXTENSION
   MSH->MOD = MOD;
   MSH->BUF = (VOID *)MSH->DBLBUF;
   MSH->FLTBUF = (VOID *)MSH->DBLBUF;
   MSH->INTBUF = (VOID *)MSH->DBLBUF;

   IF(STRSTR(MSH->FILNAM, ".MESHB"))
      MSH->TYP |= (BIN | MSHFIL);
   ELSE IF(STRSTR(MSH->FILNAM, ".MESH"))
      MSH->TYP |= (ASC | MSHFIL);
   ELSE IF(STRSTR(MSH->FILNAM, ".SOLB"))
      MSH->TYP |= (BIN | SOLFIL);
   ELSE IF(STRSTR(MSH->FILNAM, ".SOL"))
      MSH->TYP |= (ASC | SOLFIL);
   ELSE
      LONGJMP(MSH->ERR, -5);

   // OPEN THE FILE IN THE REQUIRED MOD AND INITIALIZE THE MESH STRUCTURE
   IF(MSH->MOD == GMFREAD)
   {

      /*-----------------------*/
      /* OPEN FILE FOR READING */
      /*-----------------------*/

      VA_START(VARARG, MOD);
      PTRVER = VA_ARG(VARARG, INT *);
      PTRDIM = VA_ARG(VARARG, INT *);
      VA_END(VARARG);

      // READ THE ENDIAN CODING TAG, THE MESH VERSION
      // AND THE MESH DIMENSION (MANDATORY KWD)
      IF(MSH->TYP & BIN)
      {
         // CREATE THE NAME STRING AND OPEN THE FILE
#IFDEF WITH_GMF_AIO
         // [BRUNO] ADDED BINARY FLAG (NECESSARY UNDER WINDOWS)
         MSH->FILDES = OPEN(MSH->FILNAM, OPEN_READ_FLAGS, OPEN_READ_MODE);

         IF(MSH->FILDES <= 0)
            LONGJMP(MSH->ERR, -6);

         // READ THE ENDIAN CODING TAG
         IF(READ(MSH->FILDES, &MSH->COD, WRDSIZ) != WRDSIZ)
            LONGJMP(MSH->ERR, -7);
#ELSE
         // [BRUNO] ADDED BINARY FLAG (NECESSARY UNDER WINDOWS)
         IF(!(MSH->HDL = FOPEN(MSH->FILNAM, "RB")))
            LONGJMP(MSH->ERR, -8);

         // READ THE ENDIAN CODING TAG
         SAFE_FREAD(&MSH->COD, WRDSIZ, 1, MSH->HDL, MSH->ERR);
#ENDIF

         // READ THE MESH VERSION AND THE MESH DIMENSION (MANDATORY KWD)
         IF( (MSH->COD != 1) && (MSH->COD != 16777216) )
            LONGJMP(MSH->ERR, -9);

         SCAWRD(MSH, (UNSIGNED CHAR *)&MSH->VER);

         IF( (MSH->VER < 1) || (MSH->VER > 4) )
            LONGJMP(MSH->ERR, -10);

         IF( (MSH->VER >= 3) && (SIZEOF(INT64_T) != 8) )
            LONGJMP(MSH->ERR, -11);

         SCAWRD(MSH, (UNSIGNED CHAR *)&KWDCOD);

         IF(KWDCOD != GMFDIMENSION)
            LONGJMP(MSH->ERR, -12);

         GETPOS(MSH);
         SCAWRD(MSH, (UNSIGNED CHAR *)&MSH->DIM);
      }
      ELSE
      {
         // CREATE THE NAME STRING AND OPEN THE FILE
         IF(!(MSH->HDL = FOPEN(MSH->FILNAM, "RB")))
            LONGJMP(MSH->ERR, -13);

         DO
         {
            RES = FSCANF(MSH->HDL, "%S", STR);
         }WHILE( (RES != EOF) && STRCMP(STR, "MESHVERSIONFORMATTED") );

         IF(RES == EOF)
            LONGJMP(MSH->ERR, -14);

         SAFE_FSCANF(MSH->HDL, "%D", &MSH->VER, MSH->ERR);

         IF( (MSH->VER < 1) || (MSH->VER > 4) )
            LONGJMP(MSH->ERR, -15);

         DO
         {
            RES = FSCANF(MSH->HDL, "%S", STR);
         }WHILE( (RES != EOF) && STRCMP(STR, "DIMENSION") );

         IF(RES == EOF)
            LONGJMP(MSH->ERR, -16);

         SAFE_FSCANF(MSH->HDL, "%D", &MSH->DIM, MSH->ERR);
      }

      IF( (MSH->DIM != 2) && (MSH->DIM != 3) )
         LONGJMP(MSH->ERR, -17);

      (*PTRVER) = MSH->VER;
      (*PTRDIM) = MSH->DIM;

      // SET DEFAULT REAL NUMBERS SIZE
      IF(MSH->VER == 1)
         MSH->FLTSIZ = 32;
      ELSE
         MSH->FLTSIZ = 64;

      /*------------*/
      /* KW READING */
      /*------------*/

      // READ THE LIST OF KW PRESENT IN THE FILE
      IF(!SCAKWDTAB(MSH))
         RETURN(0);

      RETURN(MSHIDX);
   }
   ELSE IF(MSH->MOD == GMFWRITE)
   {

      /*-----------------------*/
      /* OPEN FILE FOR WRITING */
      /*-----------------------*/

      MSH->COD = 1;

      // CHECK IF THE USER PROVIDED A VALID VERSION NUMBER AND DIMENSION
      VA_START(VARARG, MOD);
      MSH->VER = VA_ARG(VARARG, INT);
      MSH->DIM = VA_ARG(VARARG, INT);
      VA_END(VARARG);

      IF( (MSH->VER < 1) || (MSH->VER > 4) )
         LONGJMP(MSH->ERR, -18);

      IF( (MSH->VER >= 3) && (SIZEOF(INT64_T) != 8) )
         LONGJMP(MSH->ERR, -19);

      IF( (MSH->DIM != 2) && (MSH->DIM != 3) )
         LONGJMP(MSH->ERR, -20);

      // SET DEFAULT REAL NUMBERS SIZE
      IF(MSH->VER == 1)
         MSH->FLTSIZ = 32;
      ELSE
         MSH->FLTSIZ = 64;

      // CREATE THE MESH FILE
      IF(MSH->TYP & BIN) 
      {
         /* 
          * [BRUNO] REPLACED PREVIOUS CALL TO CREAT():
          * WITH A CALL TO OPEN(), BECAUSE WINDOWS NEEDS THE
          * BINARY FLAG TO BE SPECIFIED.
          */
#IFDEF WITH_GMF_AIO
         MSH->FILDES = OPEN(MSH->FILNAM, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);

         IF(MSH->FILDES <= 0)
            LONGJMP(MSH->ERR, -21);
#ELSE
         IF(!(MSH->HDL = FOPEN(MSH->FILNAM, "WB")))
            LONGJMP(MSH->ERR, -22);
#ENDIF
      }
      ELSE IF(!(MSH->HDL = FOPEN(MSH->FILNAM, "WB")))
         LONGJMP(MSH->ERR, -23);


      /*------------*/
      /* KW WRITING */
      /*------------*/

      // WRITE THE MESH VERSION AND DIMENSION
      IF(MSH->TYP & ASC)
      {
         FPRINTF(MSH->HDL, "%S %D\N\N",
               GMFKWDFMT[ GMFVERSIONFORMATTED ][0], MSH->VER);
         FPRINTF(MSH->HDL, "%S %D\N",
               GMFKWDFMT[ GMFDIMENSION ][0], MSH->DIM);
      }
      ELSE
      {
         RECWRD(MSH, (UNSIGNED CHAR *)&MSH->COD);
         RECWRD(MSH, (UNSIGNED CHAR *)&MSH->VER);
         GMFSETKWD(MSHIDX, GMFDIMENSION, 0);
         RECWRD(MSH, (UNSIGNED CHAR *)&MSH->DIM);
      }

      RETURN(MSHIDX);
   }
   ELSE
   {
      FREE(MSH);
      RETURN(0);
   }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205823_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
IPF_EXTRACT_FRAGS_FROM_BATCH(STRUCT IPF *IPF, STRUCT DP_PACKET_BATCH *PB,
                             OVS_BE16 DL_TYPE, UINT16_T ZONE, LONG LONG NOW,
                             UINT32_T HASH_BASIS)
{
    CONST SIZE_T PB_CNT = DP_PACKET_BATCH_SIZE(PB);
    INT PB_IDX; /* INDEX IN A PACKET BATCH. */
    STRUCT DP_PACKET *PKT;

    DP_PACKET_BATCH_REFILL_FOR_EACH (PB_IDX, PB_CNT, PKT, PB) {
        IF (OVS_UNLIKELY((DL_TYPE == HTONS(ETH_TYPE_IP) &&
                          IPF_IS_VALID_V4_FRAG(IPF, PKT))
                          ||
                          (DL_TYPE == HTONS(ETH_TYPE_IPV6) &&
                          IPF_IS_VALID_V6_FRAG(IPF, PKT)))) {

            OVS_MUTEX_LOCK(&IPF->IPF_LOCK);
            IF (!IPF_HANDLE_FRAG(IPF, PKT, DL_TYPE, ZONE, NOW, HASH_BASIS)) {
                DP_PACKET_BATCH_REFILL(PB, PKT, PB_IDX);
            }
            OVS_MUTEX_UNLOCK(&IPF->IPF_LOCK);
        } ELSE {
            DP_PACKET_BATCH_REFILL(PB, PKT, PB_IDX);
        }
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 263298_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHAR *_Q_STRCPY(CHAR *DST, SIZE_T SIZE, CONST CHAR *SRC)
{
    IF (DST == NULL || SIZE == 0 || SRC == NULL) RETURN DST;

    SIZE_T COPYLEN = STRLEN(SRC);
    IF (COPYLEN >= SIZE) COPYLEN = SIZE - 1;
    MEMMOVE((VOID *)DST, (VOID *)SRC, COPYLEN);
    DST[COPYLEN] = '\0';

    RETURN DST;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211699_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GLOB (CONST CHAR *PATTERN, INT FLAGS, INT (*ERRFUNC) (CONST CHAR *, INT),
      GLOB_T *PGLOB)
{
  CONST CHAR *FILENAME;
  CHAR *DIRNAME = NULL;
  SIZE_T DIRLEN;
  INT STATUS;
  SIZE_T OLDCOUNT;
  INT META;
  INT DIRNAME_MODIFIED;
  INT MALLOC_DIRNAME = 0;
  GLOB_T DIRS;
  INT RETVAL = 0;
  SIZE_T ALLOCA_USED = 0;

  IF (PATTERN == NULL || PGLOB == NULL || (FLAGS & ~__GLOB_FLAGS) != 0)
    {
      __SET_ERRNO (EINVAL);
      RETURN -1;
    }

  /* POSIX REQUIRES ALL SLASHES TO BE MATCHED.  THIS MEANS THAT WITH
     A TRAILING SLASH WE MUST MATCH ONLY DIRECTORIES.  */
  IF (PATTERN[0] && PATTERN[STRLEN (PATTERN) - 1] == '/')
    FLAGS |= GLOB_ONLYDIR;

  IF (!(FLAGS & GLOB_DOOFFS))
    /* HAVE TO DO THIS SO 'GLOBFREE' KNOWS WHERE TO START FREEING.  IT
       ALSO MAKES ALL THE CODE THAT USES GL_OFFS SIMPLER. */
    PGLOB->GL_OFFS = 0;

  IF (!(FLAGS & GLOB_APPEND))
    {
      PGLOB->GL_PATHC = 0;
      IF (!(FLAGS & GLOB_DOOFFS))
        PGLOB->GL_PATHV = NULL;
      ELSE
        {
          SIZE_T I;

          IF (PGLOB->GL_OFFS >= ~((SIZE_T) 0) / SIZEOF (CHAR *))
            RETURN GLOB_NOSPACE;

          PGLOB->GL_PATHV = (CHAR **) MALLOC ((PGLOB->GL_OFFS + 1)
                                              * SIZEOF (CHAR *));
          IF (PGLOB->GL_PATHV == NULL)
            RETURN GLOB_NOSPACE;

          FOR (I = 0; I <= PGLOB->GL_OFFS; ++I)
            PGLOB->GL_PATHV[I] = NULL;
        }
    }

  IF (FLAGS & GLOB_BRACE)
    {
      CONST CHAR *BEGIN;

      IF (FLAGS & GLOB_NOESCAPE)
        BEGIN = STRCHR (PATTERN, '{');
      ELSE
        {
          BEGIN = PATTERN;
          WHILE (1)
            {
              IF (*BEGIN == '\0')
                {
                  BEGIN = NULL;
                  BREAK;
                }

              IF (*BEGIN == '\\' && BEGIN[1] != '\0')
                ++BEGIN;
              ELSE IF (*BEGIN == '{')
                BREAK;

              ++BEGIN;
            }
        }

      IF (BEGIN != NULL)
        {
          /* ALLOCATE WORKING BUFFER LARGE ENOUGH FOR OUR WORK.  NOTE THAT
             WE HAVE AT LEAST AN OPENING AND CLOSING BRACE.  */
          SIZE_T FIRSTC;
          CHAR *ALT_START;
          CONST CHAR *P;
          CONST CHAR *NEXT;
          CONST CHAR *REST;
          SIZE_T REST_LEN;
          CHAR *ONEALT;
          SIZE_T PATTERN_LEN = STRLEN (PATTERN) - 1;
          INT ALLOCA_ONEALT = GLOB_USE_ALLOCA (ALLOCA_USED, PATTERN_LEN);
          IF (ALLOCA_ONEALT)
            ONEALT = ALLOCA_ACCOUNT (PATTERN_LEN, ALLOCA_USED);
          ELSE
            {
              ONEALT = MALLOC (PATTERN_LEN);
              IF (ONEALT == NULL)
                RETURN GLOB_NOSPACE;
            }

          /* WE KNOW THE PREFIX FOR ALL SUB-PATTERNS.  */
          ALT_START = MEMPCPY (ONEALT, PATTERN, BEGIN - PATTERN);

          /* FIND THE FIRST SUB-PATTERN AND AT THE SAME TIME FIND THE
             REST AFTER THE CLOSING BRACE.  */
          NEXT = NEXT_BRACE_SUB (BEGIN + 1, FLAGS);
          IF (NEXT == NULL)
            {
              /* IT IS AN INVALID EXPRESSION.  */
            ILLEGAL_BRACE:
              IF (__GLIBC_UNLIKELY (!ALLOCA_ONEALT))
                FREE (ONEALT);
              FLAGS &= ~GLOB_BRACE;
              GOTO NO_BRACE;
            }

          /* NOW FIND THE END OF THE WHOLE BRACE EXPRESSION.  */
          REST = NEXT;
          WHILE (*REST != '}')
            {
              REST = NEXT_BRACE_SUB (REST + 1, FLAGS);
              IF (REST == NULL)
                /* IT IS AN ILLEGAL EXPRESSION.  */
                GOTO ILLEGAL_BRACE;
            }
          /* PLEASE NOTE THAT WE NOW CAN BE SURE THE BRACE EXPRESSION
             IS WELL-FORMED.  */
          REST_LEN = STRLEN (++REST) + 1;

          /* WE HAVE A BRACE EXPRESSION.  BEGIN POINTS TO THE OPENING {,
             NEXT POINTS PAST THE TERMINATOR OF THE FIRST ELEMENT, AND END
             POINTS PAST THE FINAL }.  WE WILL ACCUMULATE RESULT NAMES FROM
             RECURSIVE RUNS FOR EACH BRACE ALTERNATIVE IN THE BUFFER USING
             GLOB_APPEND.  */
          FIRSTC = PGLOB->GL_PATHC;

          P = BEGIN + 1;
          WHILE (1)
            {
              INT RESULT;

              /* CONSTRUCT THE NEW GLOB EXPRESSION.  */
              MEMPCPY (MEMPCPY (ALT_START, P, NEXT - P), REST, REST_LEN);

              RESULT = GLOB (ONEALT,
                             ((FLAGS & ~(GLOB_NOCHECK | GLOB_NOMAGIC))
                              | GLOB_APPEND), ERRFUNC, PGLOB);

              /* IF WE GOT AN ERROR, RETURN IT.  */
              IF (RESULT && RESULT != GLOB_NOMATCH)
                {
                  IF (__GLIBC_UNLIKELY (!ALLOCA_ONEALT))
                    FREE (ONEALT);
                  IF (!(FLAGS & GLOB_APPEND))
                    {
                      GLOBFREE (PGLOB);
                      PGLOB->GL_PATHC = 0;
                    }
                  RETURN RESULT;
                }

              IF (*NEXT == '}')
                /* WE SAW THE LAST ENTRY.  */
                BREAK;

              P = NEXT + 1;
              NEXT = NEXT_BRACE_SUB (P, FLAGS);
              ASSERT (NEXT != NULL);
            }

          IF (__GLIBC_UNLIKELY (!ALLOCA_ONEALT))
            FREE (ONEALT);

          IF (PGLOB->GL_PATHC != FIRSTC)
            /* WE FOUND SOME ENTRIES.  */
            RETURN 0;
          ELSE IF (!(FLAGS & (GLOB_NOCHECK|GLOB_NOMAGIC)))
            RETURN GLOB_NOMATCH;
        }
    }

 NO_BRACE:
  OLDCOUNT = PGLOB->GL_PATHC + PGLOB->GL_OFFS;

  /* FIND THE FILENAME.  */
  FILENAME = STRRCHR (PATTERN, '/');

#IF DEFINED __MSDOS__ || DEFINED WINDOWS32
  /* THE CASE OF "D:PATTERN".  SINCE ':' IS NOT ALLOWED IN
     FILE NAMES, WE CAN SAFELY ASSUME THAT WHEREVER IT
     HAPPENS IN PATTERN, IT SIGNALS THE FILENAME PART.  THIS
     IS SO WE COULD SOME DAY SUPPORT PATTERNS LIKE "[A-Z]:FOO".  */
  IF (FILENAME == NULL)
    FILENAME = STRCHR (PATTERN, ':');
#ENDIF /* __MSDOS__ || WINDOWS32 */

  DIRNAME_MODIFIED = 0;
  IF (FILENAME == NULL)
    {
      /* THIS CAN MEAN TWO THINGS: A SIMPLE NAME OR "~NAME".  THE LATTER
         CASE IS NOTHING BUT A NOTATION FOR A DIRECTORY.  */
      IF ((FLAGS & (GLOB_TILDE|GLOB_TILDE_CHECK)) && PATTERN[0] == '~')
        {
          DIRNAME = (CHAR *) PATTERN;
          DIRLEN = STRLEN (PATTERN);

          /* SET FILENAME TO NULL AS A SPECIAL FLAG.  THIS IS UGLY BUT
             OTHER SOLUTIONS WOULD REQUIRE MUCH MORE CODE.  WE TEST FOR
             THIS SPECIAL CASE BELOW.  */
          FILENAME = NULL;
        }
      ELSE
        {
          IF (__GLIBC_UNLIKELY (PATTERN[0] == '\0'))
            {
              DIRS.GL_PATHV = NULL;
              GOTO NO_MATCHES;
            }

          FILENAME = PATTERN;
          DIRNAME = (CHAR *) ".";
          DIRLEN = 0;
        }
    }
  ELSE IF (FILENAME == PATTERN
           || (FILENAME == PATTERN + 1 && PATTERN[0] == '\\'
               && (FLAGS & GLOB_NOESCAPE) == 0))
    {
      /* "/PATTERN" OR "\\/PATTERN".  */
      DIRNAME = (CHAR *) "/";
      DIRLEN = 1;
      ++FILENAME;
    }
  ELSE
    {
      CHAR *NEWP;
      DIRLEN = FILENAME - PATTERN;

#IF DEFINED __MSDOS__ || DEFINED WINDOWS32
      IF (*FILENAME == ':'
          || (FILENAME > PATTERN + 1 && FILENAME[-1] == ':'))
        {
          CHAR *DRIVE_SPEC;

          ++DIRLEN;
          DRIVE_SPEC = __ALLOCA (DIRLEN + 1);
          *((CHAR *) MEMPCPY (DRIVE_SPEC, PATTERN, DIRLEN)) = '\0';
          /* FOR NOW, DISALLOW WILDCARDS IN THE DRIVE SPEC, TO
             PREVENT INFINITE RECURSION IN GLOB.  */
          IF (__GLOB_PATTERN_P (DRIVE_SPEC, !(FLAGS & GLOB_NOESCAPE)))
            RETURN GLOB_NOMATCH;
          /* IF THIS IS "D:PATTERN", WE NEED TO COPY ':' TO DIRNAME
             AS WELL.  IF IT'S "D:/PATTERN", DON'T REMOVE THE SLASH
             FROM "D:/", SINCE "D:" AND "D:/" ARE NOT THE SAME.*/
        }
#ENDIF

      IF (GLOB_USE_ALLOCA (ALLOCA_USED, DIRLEN + 1))
        NEWP = ALLOCA_ACCOUNT (DIRLEN + 1, ALLOCA_USED);
      ELSE
        {
          NEWP = MALLOC (DIRLEN + 1);
          IF (NEWP == NULL)
            RETURN GLOB_NOSPACE;
          MALLOC_DIRNAME = 1;
        }
      *((CHAR *) MEMPCPY (NEWP, PATTERN, DIRLEN)) = '\0';
      DIRNAME = NEWP;
      ++FILENAME;

#IF DEFINED __MSDOS__ || DEFINED WINDOWS32
      BOOL DRIVE_ROOT = (DIRLEN > 1
                         && (DIRNAME[DIRLEN - 1] == ':'
                             || (DIRLEN > 2 && DIRNAME[DIRLEN - 2] == ':'
                                 && DIRNAME[DIRLEN - 1] == '/')));
#ELSE
      BOOL DRIVE_ROOT = FALSE;
#ENDIF

      IF (FILENAME[0] == '\0' && DIRLEN > 1 && !DRIVE_ROOT)
        /* "PATTERN/".  EXPAND "PATTERN", APPENDING SLASHES.  */
        {
          INT ORIG_FLAGS = FLAGS;
          IF (!(FLAGS & GLOB_NOESCAPE) && DIRNAME[DIRLEN - 1] == '\\')
            {
              /* "PATTERN\\/".  REMOVE THE FINAL BACKSLASH IF IT HASN'T
                 BEEN QUOTED.  */
              CHAR *P = (CHAR *) &DIRNAME[DIRLEN - 1];

              WHILE (P > DIRNAME && P[-1] == '\\') --P;
              IF ((&DIRNAME[DIRLEN] - P) & 1)
                {
                  *(CHAR *) &DIRNAME[--DIRLEN] = '\0';
                  FLAGS &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
                }
            }
          INT VAL = GLOB (DIRNAME, FLAGS | GLOB_MARK, ERRFUNC, PGLOB);
          IF (VAL == 0)
            PGLOB->GL_FLAGS = ((PGLOB->GL_FLAGS & ~GLOB_MARK)
                               | (FLAGS & GLOB_MARK));
          ELSE IF (VAL == GLOB_NOMATCH && FLAGS != ORIG_FLAGS)
            {
              /* MAKE SURE GLOBFREE (&DIRS); IS A NOP.  */
              DIRS.GL_PATHV = NULL;
              FLAGS = ORIG_FLAGS;
              OLDCOUNT = PGLOB->GL_PATHC + PGLOB->GL_OFFS;
              GOTO NO_MATCHES;
            }
          RETVAL = VAL;
          GOTO OUT;
        }
    }

  IF ((FLAGS & (GLOB_TILDE|GLOB_TILDE_CHECK)) && DIRNAME[0] == '~')
    {
      IF (DIRNAME[1] == '\0' || DIRNAME[1] == '/'
          || (!(FLAGS & GLOB_NOESCAPE) && DIRNAME[1] == '\\'
              && (DIRNAME[2] == '\0' || DIRNAME[2] == '/')))
        {
          /* LOOK UP HOME DIRECTORY.  */
          CHAR *HOME_DIR = GETENV ("HOME");
          INT MALLOC_HOME_DIR = 0;
          IF (HOME_DIR == NULL || HOME_DIR[0] == '\0')
            {
#IFDEF WINDOWS32
              /* WINDOWS NT DEFINES HOMEDRIVE AND HOMEPATH.  BUT GIVE
                 PREFERENCE TO HOME, BECAUSE THE USER CAN CHANGE HOME.  */
              CONST CHAR *HOME_DRIVE = GETENV ("HOMEDRIVE");
              CONST CHAR *HOME_PATH = GETENV ("HOMEPATH");

              IF (HOME_DRIVE != NULL && HOME_PATH != NULL)
                {
                  SIZE_T HOME_DRIVE_LEN = STRLEN (HOME_DRIVE);
                  SIZE_T HOME_PATH_LEN = STRLEN (HOME_PATH);
                  CHAR *MEM = ALLOCA (HOME_DRIVE_LEN + HOME_PATH_LEN + 1);

                  MEMCPY (MEM, HOME_DRIVE, HOME_DRIVE_LEN);
                  MEMCPY (MEM + HOME_DRIVE_LEN, HOME_PATH, HOME_PATH_LEN + 1);
                  HOME_DIR = MEM;
                }
              ELSE
                HOME_DIR = "C:/USERS/DEFAULT"; /* POOR DEFAULT */
#ELSE
              INT ERR;
              STRUCT PASSWD *P;
              STRUCT PASSWD PWBUF;
              STRUCT SCRATCH_BUFFER S;
              SCRATCH_BUFFER_INIT (&S);
              WHILE (TRUE)
                {
                  P = NULL;
                  ERR = __GETLOGIN_R (S.DATA, S.LENGTH);
                  IF (ERR == 0)
                    {
# IF DEFINED HAVE_GETPWNAM_R || DEFINED _LIBC
                      SIZE_T SSIZE = STRLEN (S.DATA) + 1;
                      ERR = GETPWNAM_R (S.DATA, &PWBUF, S.DATA + SSIZE,
                                        S.LENGTH - SSIZE, &P);
# ELSE
                      P = GETPWNAM (S.DATA);
                      IF (P == NULL)
                        ERR = ERRNO;
# ENDIF
                    }
                  IF (ERR != ERANGE)
                    BREAK;
                  IF (!SCRATCH_BUFFER_GROW (&S))
                    {
                      RETVAL = GLOB_NOSPACE;
                      GOTO OUT;
                    }
                }
              IF (ERR == 0)
                {
                  HOME_DIR = STRDUP (P->PW_DIR);
                  MALLOC_HOME_DIR = 1;
                }
              SCRATCH_BUFFER_FREE (&S);
              IF (ERR == 0 && HOME_DIR == NULL)
                {
                  RETVAL = GLOB_NOSPACE;
                  GOTO OUT;
                }
#ENDIF /* WINDOWS32 */
            }
          IF (HOME_DIR == NULL || HOME_DIR[0] == '\0')
            {
              IF (__GLIBC_UNLIKELY (MALLOC_HOME_DIR))
                FREE (HOME_DIR);
              IF (FLAGS & GLOB_TILDE_CHECK)
                {
                  RETVAL = GLOB_NOMATCH;
                  GOTO OUT;
                }
              ELSE
                {
                  HOME_DIR = (CHAR *) "~"; /* NO LUCK.  */
                  MALLOC_HOME_DIR = 0;
                }
            }
          /* NOW CONSTRUCT THE FULL DIRECTORY.  */
          IF (DIRNAME[1] == '\0')
            {
              IF (__GLIBC_UNLIKELY (MALLOC_DIRNAME))
                FREE (DIRNAME);

              DIRNAME = HOME_DIR;
              DIRLEN = STRLEN (DIRNAME);
              MALLOC_DIRNAME = MALLOC_HOME_DIR;
            }
          ELSE
            {
              CHAR *NEWP;
              SIZE_T HOME_LEN = STRLEN (HOME_DIR);
              INT USE_ALLOCA = GLOB_USE_ALLOCA (ALLOCA_USED, HOME_LEN + DIRLEN);
              IF (USE_ALLOCA)
                NEWP = ALLOCA_ACCOUNT (HOME_LEN + DIRLEN, ALLOCA_USED);
              ELSE
                {
                  NEWP = MALLOC (HOME_LEN + DIRLEN);
                  IF (NEWP == NULL)
                    {
                      IF (__GLIBC_UNLIKELY (MALLOC_HOME_DIR))
                        FREE (HOME_DIR);
                      RETVAL = GLOB_NOSPACE;
                      GOTO OUT;
                    }
                }

              MEMPCPY (MEMPCPY (NEWP, HOME_DIR, HOME_LEN),
                       &DIRNAME[1], DIRLEN);

              IF (__GLIBC_UNLIKELY (MALLOC_DIRNAME))
                FREE (DIRNAME);

              DIRNAME = NEWP;
              DIRLEN += HOME_LEN - 1;
              MALLOC_DIRNAME = !USE_ALLOCA;

              IF (__GLIBC_UNLIKELY (MALLOC_HOME_DIR))
                FREE (HOME_DIR);
            }
          DIRNAME_MODIFIED = 1;
        }
      ELSE
        {
#IFNDEF WINDOWS32
          CHAR *END_NAME = STRCHR (DIRNAME, '/');
          CHAR *USER_NAME;
          INT MALLOC_USER_NAME = 0;
          CHAR *UNESCAPE = NULL;

          IF (!(FLAGS & GLOB_NOESCAPE))
            {
              IF (END_NAME == NULL)
                {
                  UNESCAPE = STRCHR (DIRNAME, '\\');
                  IF (UNESCAPE)
                    END_NAME = STRCHR (UNESCAPE, '\0');
                }
              ELSE
                UNESCAPE = MEMCHR (DIRNAME, '\\', END_NAME - DIRNAME);
            }
          IF (END_NAME == NULL)
            USER_NAME = DIRNAME + 1;
          ELSE
            {
              CHAR *NEWP;
              IF (GLOB_USE_ALLOCA (ALLOCA_USED, END_NAME - DIRNAME))
                NEWP = ALLOCA_ACCOUNT (END_NAME - DIRNAME, ALLOCA_USED);
              ELSE
                {
                  NEWP = MALLOC (END_NAME - DIRNAME);
                  IF (NEWP == NULL)
                    {
                      RETVAL = GLOB_NOSPACE;
                      GOTO OUT;
                    }
                  MALLOC_USER_NAME = 1;
                }
              IF (UNESCAPE != NULL)
                {
                  CHAR *P = MEMPCPY (NEWP, DIRNAME + 1,
                                     UNESCAPE - DIRNAME - 1);
                  CHAR *Q = UNESCAPE;
                  WHILE (*Q != '\0')
                    {
                      IF (*Q == '\\')
                        {
                          IF (Q[1] == '\0')
                            {
                              /* "~FO\\O\\" UNESCAPE TO USER_NAME "FOO\\",
                                 BUT "~FO\\O\\/" UNESCAPE TO USER_NAME
                                 "FOO".  */
                              IF (FILENAME == NULL)
                                *P++ = '\\';
                              BREAK;
                            }
                          ++Q;
                        }
                      *P++ = *Q++;
                    }
                  *P = '\0';
                }
              ELSE
                *((CHAR *) MEMPCPY (NEWP, DIRNAME + 1, END_NAME - DIRNAME))
                  = '\0';
              USER_NAME = NEWP;
            }

          /* LOOK UP SPECIFIC USER'S HOME DIRECTORY.  */
          {
            STRUCT PASSWD *P;
            STRUCT SCRATCH_BUFFER PWTMPBUF;
            SCRATCH_BUFFER_INIT (&PWTMPBUF);

#  IF DEFINED HAVE_GETPWNAM_R || DEFINED _LIBC
            STRUCT PASSWD PWBUF;

            WHILE (GETPWNAM_R (USER_NAME, &PWBUF,
                               PWTMPBUF.DATA, PWTMPBUF.LENGTH, &P)
                   == ERANGE)
              {
                IF (!SCRATCH_BUFFER_GROW (&PWTMPBUF))
                  {
                    RETVAL = GLOB_NOSPACE;
                    GOTO OUT;
                  }
              }
#  ELSE
            P = GETPWNAM (USER_NAME);
#  ENDIF

            IF (__GLIBC_UNLIKELY (MALLOC_USER_NAME))
              FREE (USER_NAME);

            /* IF WE FOUND A HOME DIRECTORY USE THIS.  */
            IF (P != NULL)
              {
                SIZE_T HOME_LEN = STRLEN (P->PW_DIR);
                SIZE_T REST_LEN = END_NAME == NULL ? 0 : STRLEN (END_NAME);
                CHAR *D;

                IF (__GLIBC_UNLIKELY (MALLOC_DIRNAME))
                  FREE (DIRNAME);
                MALLOC_DIRNAME = 0;

                IF (GLOB_USE_ALLOCA (ALLOCA_USED, HOME_LEN + REST_LEN + 1))
                  DIRNAME = ALLOCA_ACCOUNT (HOME_LEN + REST_LEN + 1,
                                            ALLOCA_USED);
                ELSE
                  {
                    DIRNAME = MALLOC (HOME_LEN + REST_LEN + 1);
                    IF (DIRNAME == NULL)
                      {
                        SCRATCH_BUFFER_FREE (&PWTMPBUF);
                        RETVAL = GLOB_NOSPACE;
                        GOTO OUT;
                      }
                    MALLOC_DIRNAME = 1;
                  }
                D = MEMPCPY (DIRNAME, P->PW_DIR, HOME_LEN);
                IF (END_NAME != NULL)
                  D = MEMPCPY (D, END_NAME, REST_LEN);
                *D = '\0';

                DIRLEN = HOME_LEN + REST_LEN;
                DIRNAME_MODIFIED = 1;
              }
            ELSE
              {
                IF (FLAGS & GLOB_TILDE_CHECK)
                  {
                    /* WE HAVE TO REGARD IT AS AN ERROR IF WE CANNOT FIND THE
                       HOME DIRECTORY.  */
                    RETVAL = GLOB_NOMATCH;
                    GOTO OUT;
                  }
              }
            SCRATCH_BUFFER_FREE (&PWTMPBUF);
          }
#ENDIF /* !WINDOWS32 */
        }
    }

  /* NOW TEST WHETHER WE LOOKED FOR "~" OR "~NAME".  IN THIS CASE WE
     CAN GIVE THE ANSWER NOW.  */
  IF (FILENAME == NULL)
    {
      SIZE_T NEWCOUNT = PGLOB->GL_PATHC + PGLOB->GL_OFFS;
      CHAR **NEW_GL_PATHV;

      IF (NEWCOUNT > SIZE_MAX / SIZEOF (CHAR *) - 2)
        {
        NOSPACE:
          FREE (PGLOB->GL_PATHV);
          PGLOB->GL_PATHV = NULL;
          PGLOB->GL_PATHC = 0;
          RETVAL = GLOB_NOSPACE;
          GOTO OUT;
        }

      NEW_GL_PATHV = REALLOC (PGLOB->GL_PATHV,
                              (NEWCOUNT + 2) * SIZEOF (CHAR *));
      IF (NEW_GL_PATHV == NULL)
        GOTO NOSPACE;
      PGLOB->GL_PATHV = NEW_GL_PATHV;

      IF (FLAGS & GLOB_MARK && IS_DIR (DIRNAME, FLAGS, PGLOB))
        {
          CHAR *P;
          PGLOB->GL_PATHV[NEWCOUNT] = MALLOC (DIRLEN + 2);
          IF (PGLOB->GL_PATHV[NEWCOUNT] == NULL)
            GOTO NOSPACE;
          P = MEMPCPY (PGLOB->GL_PATHV[NEWCOUNT], DIRNAME, DIRLEN);
          P[0] = '/';
          P[1] = '\0';
          IF (__GLIBC_UNLIKELY (MALLOC_DIRNAME))
            FREE (DIRNAME);
        }
      ELSE
        {
          IF (__GLIBC_UNLIKELY (MALLOC_DIRNAME))
            PGLOB->GL_PATHV[NEWCOUNT] = DIRNAME;
          ELSE
            {
              PGLOB->GL_PATHV[NEWCOUNT] = STRDUP (DIRNAME);
              IF (PGLOB->GL_PATHV[NEWCOUNT] == NULL)
                GOTO NOSPACE;
            }
        }
      PGLOB->GL_PATHV[++NEWCOUNT] = NULL;
      ++PGLOB->GL_PATHC;
      PGLOB->GL_FLAGS = FLAGS;

      RETURN 0;
    }

  META = __GLOB_PATTERN_TYPE (DIRNAME, !(FLAGS & GLOB_NOESCAPE));
  /* META IS 1 IF CORRECT GLOB PATTERN CONTAINING METACHARACTERS.
     IF META HAS BIT (1 << 2) SET, IT MEANS THERE WAS AN UNTERMINATED
     [ WHICH WE HANDLE THE SAME, USING FNMATCH.  BROKEN UNTERMINATED
     PATTERN BRACKET EXPRESSIONS OUGHT TO BE RARE ENOUGH THAT IT IS
     NOT WORTH SPECIAL CASING THEM, FNMATCH WILL DO THE RIGHT THING.  */
  IF (META & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))
    {
      /* THE DIRECTORY NAME CONTAINS METACHARACTERS, SO WE
         HAVE TO GLOB FOR THE DIRECTORY, AND THEN GLOB FOR
         THE PATTERN IN EACH DIRECTORY FOUND.  */
      SIZE_T I;

      IF (!(FLAGS & GLOB_NOESCAPE) && DIRLEN > 0 && DIRNAME[DIRLEN - 1] == '\\')
        {
          /* "FOO\\/BAR".  REMOVE THE FINAL BACKSLASH FROM DIRNAME
             IF IT HAS NOT BEEN QUOTED.  */
          CHAR *P = (CHAR *) &DIRNAME[DIRLEN - 1];

          WHILE (P > DIRNAME && P[-1] == '\\') --P;
          IF ((&DIRNAME[DIRLEN] - P) & 1)
            *(CHAR *) &DIRNAME[--DIRLEN] = '\0';
        }

      IF (__GLIBC_UNLIKELY ((FLAGS & GLOB_ALTDIRFUNC) != 0))
        {
          /* USE THE ALTERNATIVE ACCESS FUNCTIONS ALSO IN THE RECURSIVE
             CALL.  */
          DIRS.GL_OPENDIR = PGLOB->GL_OPENDIR;
          DIRS.GL_READDIR = PGLOB->GL_READDIR;
          DIRS.GL_CLOSEDIR = PGLOB->GL_CLOSEDIR;
          DIRS.GL_STAT = PGLOB->GL_STAT;
          DIRS.GL_LSTAT = PGLOB->GL_LSTAT;
        }

      STATUS = GLOB (DIRNAME,
                     ((FLAGS & (GLOB_ERR | GLOB_NOESCAPE
                                | GLOB_ALTDIRFUNC))
                      | GLOB_NOSORT | GLOB_ONLYDIR),
                     ERRFUNC, &DIRS);
      IF (STATUS != 0)
        {
          IF ((FLAGS & GLOB_NOCHECK) == 0 || STATUS != GLOB_NOMATCH)
            {
              RETVAL = STATUS;
              GOTO OUT;
            }
          GOTO NO_MATCHES;
        }

      /* WE HAVE SUCCESSFULLY GLOBBED THE PRECEDING DIRECTORY NAME.
         FOR EACH NAME WE FOUND, CALL GLOB_IN_DIR ON IT AND FILENAME,
         APPENDING THE RESULTS TO PGLOB.  */
      FOR (I = 0; I < DIRS.GL_PATHC; ++I)
        {
          SIZE_T OLD_PATHC;

          OLD_PATHC = PGLOB->GL_PATHC;
          STATUS = GLOB_IN_DIR (FILENAME, DIRS.GL_PATHV[I],
                                ((FLAGS | GLOB_APPEND)
                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),
                                ERRFUNC, PGLOB, ALLOCA_USED);
          IF (STATUS == GLOB_NOMATCH)
            /* NO MATCHES IN THIS DIRECTORY.  TRY THE NEXT.  */
            CONTINUE;

          IF (STATUS != 0)
            {
              GLOBFREE (&DIRS);
              GLOBFREE (PGLOB);
              PGLOB->GL_PATHC = 0;
              RETVAL = STATUS;
              GOTO OUT;
            }

          /* STICK THE DIRECTORY ON THE FRONT OF EACH NAME.  */
          IF (PREFIX_ARRAY (DIRS.GL_PATHV[I],
                            &PGLOB->GL_PATHV[OLD_PATHC + PGLOB->GL_OFFS],
                            PGLOB->GL_PATHC - OLD_PATHC))
            {
              GLOBFREE (&DIRS);
              GLOBFREE (PGLOB);
              PGLOB->GL_PATHC = 0;
              RETVAL = GLOB_NOSPACE;
              GOTO OUT;
            }
        }

      FLAGS |= GLOB_MAGCHAR;

      /* WE HAVE IGNORED THE GLOB_NOCHECK FLAG IN THE 'GLOB_IN_DIR' CALLS.
         BUT IF WE HAVE NOT FOUND ANY MATCHING ENTRY AND THE GLOB_NOCHECK
         FLAG WAS SET WE MUST RETURN THE INPUT PATTERN ITSELF.  */
      IF (PGLOB->GL_PATHC + PGLOB->GL_OFFS == OLDCOUNT)
        {
        NO_MATCHES:
          /* NO MATCHES.  */
          IF (FLAGS & GLOB_NOCHECK)
            {
              SIZE_T NEWCOUNT = PGLOB->GL_PATHC + PGLOB->GL_OFFS;
              CHAR **NEW_GL_PATHV;

              IF (NEWCOUNT > SIZE_MAX / SIZEOF (CHAR *) - 2)
                {
                NOSPACE2:
                  GLOBFREE (&DIRS);
                  RETVAL = GLOB_NOSPACE;
                  GOTO OUT;
                }

              NEW_GL_PATHV = REALLOC (PGLOB->GL_PATHV,
                                      (NEWCOUNT + 2) * SIZEOF (CHAR *));
              IF (NEW_GL_PATHV == NULL)
                GOTO NOSPACE2;
              PGLOB->GL_PATHV = NEW_GL_PATHV;

              PGLOB->GL_PATHV[NEWCOUNT] = STRDUP (PATTERN);
              IF (PGLOB->GL_PATHV[NEWCOUNT] == NULL)
                {
                  GLOBFREE (&DIRS);
                  GLOBFREE (PGLOB);
                  PGLOB->GL_PATHC = 0;
                  RETVAL = GLOB_NOSPACE;
                  GOTO OUT;
                }

              ++PGLOB->GL_PATHC;
              ++NEWCOUNT;

              PGLOB->GL_PATHV[NEWCOUNT] = NULL;
              PGLOB->GL_FLAGS = FLAGS;
            }
          ELSE
            {
              GLOBFREE (&DIRS);
              RETVAL = GLOB_NOMATCH;
              GOTO OUT;
            }
        }

      GLOBFREE (&DIRS);
    }
  ELSE
    {
      SIZE_T OLD_PATHC = PGLOB->GL_PATHC;
      INT ORIG_FLAGS = FLAGS;

      IF (META & GLOBPAT_BACKSLASH)
        {
          CHAR *P = STRCHR (DIRNAME, '\\'), *Q;
          /* WE NEED TO UNESCAPE THE DIRNAME STRING.  IT IS CERTAINLY
             ALLOCATED BY ALLOCA, AS OTHERWISE FILENAME WOULD BE NULL
             OR DIRNAME WOULDN'T CONTAIN BACKSLASHES.  */
          Q = P;
          DO
            {
              IF (*P == '\\')
                {
                  *Q = *++P;
                  --DIRLEN;
                }
              ELSE
                *Q = *P;
              ++Q;
            }
          WHILE (*P++ != '\0');
          DIRNAME_MODIFIED = 1;
        }
      IF (DIRNAME_MODIFIED)
        FLAGS &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);
      STATUS = GLOB_IN_DIR (FILENAME, DIRNAME, FLAGS, ERRFUNC, PGLOB,
                            ALLOCA_USED);
      IF (STATUS != 0)
        {
          IF (STATUS == GLOB_NOMATCH && FLAGS != ORIG_FLAGS
              && PGLOB->GL_PATHC + PGLOB->GL_OFFS == OLDCOUNT)
            {
              /* MAKE SURE GLOBFREE (&DIRS); IS A NOP.  */
              DIRS.GL_PATHV = NULL;
              FLAGS = ORIG_FLAGS;
              GOTO NO_MATCHES;
            }
          RETVAL = STATUS;
          GOTO OUT;
        }

      IF (DIRLEN > 0)
        {
          /* STICK THE DIRECTORY ON THE FRONT OF EACH NAME.  */
          IF (PREFIX_ARRAY (DIRNAME,
                            &PGLOB->GL_PATHV[OLD_PATHC + PGLOB->GL_OFFS],
                            PGLOB->GL_PATHC - OLD_PATHC))
            {
              GLOBFREE (PGLOB);
              PGLOB->GL_PATHC = 0;
              RETVAL = GLOB_NOSPACE;
              GOTO OUT;
            }
        }
    }

  IF (FLAGS & GLOB_MARK)
    {
      /* APPEND SLASHES TO DIRECTORY NAMES.  */
      SIZE_T I;

      FOR (I = OLDCOUNT; I < PGLOB->GL_PATHC + PGLOB->GL_OFFS; ++I)
        IF (IS_DIR (PGLOB->GL_PATHV[I], FLAGS, PGLOB))
          {
            SIZE_T LEN = STRLEN (PGLOB->GL_PATHV[I]) + 2;
            CHAR *NEW = REALLOC (PGLOB->GL_PATHV[I], LEN);
            IF (NEW == NULL)
              {
                GLOBFREE (PGLOB);
                PGLOB->GL_PATHC = 0;
                RETVAL = GLOB_NOSPACE;
                GOTO OUT;
              }
            STRCPY (&NEW[LEN - 2], "/");
            PGLOB->GL_PATHV[I] = NEW;
          }
    }

  IF (!(FLAGS & GLOB_NOSORT))
    {
      /* SORT THE VECTOR.  */
      QSORT (&PGLOB->GL_PATHV[OLDCOUNT],
             PGLOB->GL_PATHC + PGLOB->GL_OFFS - OLDCOUNT,
             SIZEOF (CHAR *), COLLATED_COMPARE);
    }

 OUT:
  IF (__GLIBC_UNLIKELY (MALLOC_DIRNAME))
    FREE (DIRNAME);

  RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 314531_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PJ_DEF(PJMEDIA_SDP_ATTR*) PJMEDIA_SDP_MEDIA_FIND_ATTR2(
				CONST PJMEDIA_SDP_MEDIA *M,
				CONST CHAR *NAME, CONST PJ_STR_T *FMT)
{
    PJ_ASSERT_RETURN(M && NAME, NULL);
    RETURN PJMEDIA_SDP_ATTR_FIND2(M->ATTR_COUNT, M->ATTR, NAME, FMT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207780_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC RLIST *CREATE_CACHE_BINS(RBINFILE *BF, RDYLDCACHE *CACHE) {
	RLIST *BINS = R_LIST_NEWF ((RLISTFREE)FREE_BIN);
	UT16 *DEPARRAY = NULL;
	CACHE_IMGXTR_T *EXTRAS = NULL;
	IF (!BINS) {
		RETURN NULL;
	}

	CHAR *TARGET_LIBS = NULL;
	RLIST *TARGET_LIB_NAMES = NULL;
	INT *DEPS = NULL;
	TARGET_LIBS = R_SYS_GETENV ("R_DYLDCACHE_FILTER");
	IF (TARGET_LIBS) {
		TARGET_LIB_NAMES = R_STR_SPLIT_LIST (TARGET_LIBS, ":", 0);
		IF (!TARGET_LIB_NAMES) {
			R_LIST_FREE (BINS);
			RETURN NULL;
		}
		DEPS = R_NEWS0 (INT, CACHE->HDR->IMAGESCOUNT);
		IF (!DEPS) {
			R_LIST_FREE (BINS);
			R_LIST_FREE (TARGET_LIB_NAMES);
			RETURN NULL;
		}
	}

	UT32 I;
	FOR (I = 0; I < CACHE->N_HDR; I++) {
		CACHE_HDR_T *HDR = &CACHE->HDR[I];
		UT64 HDR_OFFSET = CACHE->HDR_OFFSET[I];
		UT32 MAPS_INDEX = CACHE->MAPS_INDEX[I];
		CACHE_IMG_T *IMG = READ_CACHE_IMAGES (CACHE->BUF, HDR, HDR_OFFSET);
		IF (!IMG) {
			GOTO NEXT;
		}

		UT32 J;
		IF (TARGET_LIBS) {
			HTPU *PATH_TO_IDX = NULL;
			IF (CACHE->ACCEL) {
				DEPARRAY = R_NEWS0 (UT16, CACHE->ACCEL->DEPLISTCOUNT);
				IF (!DEPARRAY) {
					GOTO NEXT;
				}

				IF (R_BUF_FREAD_AT (CACHE->BUF, CACHE->ACCEL->DEPLISTOFFSET, (UT8*) DEPARRAY, "S", CACHE->ACCEL->DEPLISTCOUNT) != CACHE->ACCEL->DEPLISTCOUNT * 2) {
					GOTO NEXT;
				}

				EXTRAS = READ_CACHE_IMGEXTRA (CACHE->BUF, HDR, CACHE->ACCEL);
				IF (!EXTRAS) {
					GOTO NEXT;
				}
			} ELSE {
				PATH_TO_IDX = CREATE_PATH_TO_INDEX (CACHE->BUF, IMG, HDR);
			}

			FOR (J = 0; J < HDR->IMAGESCOUNT; J++) {
				BOOL PRINTING = !DEPS[J];
				CHAR *LIB_NAME = GET_LIB_NAME (CACHE->BUF, &IMG[J]);
				IF (!LIB_NAME) {
					BREAK;
				}
				IF (STRSTR (LIB_NAME, "LIBOBJC.A.DYLIB")) {
					DEPS[J]++;
				}
				IF (!R_LIST_FIND (TARGET_LIB_NAMES, LIB_NAME, STRING_CONTAINS)) {
					R_FREE (LIB_NAME);
					CONTINUE;
				}
				IF (PRINTING) {
					EPRINTF ("FILTER: %S\N", LIB_NAME);
				}
				R_FREE (LIB_NAME);
				DEPS[J]++;

				IF (EXTRAS && DEPARRAY) {
					UT32 K;
					FOR (K = EXTRAS[J].DEPENDENTSSTARTARRAYINDEX; DEPARRAY[K] != 0XFFFF; K++) {
						UT16 DEP_INDEX = DEPARRAY[K] & 0X7FFF;
						DEPS[DEP_INDEX]++;

						CHAR *DEP_NAME = GET_LIB_NAME (CACHE->BUF, &IMG[DEP_INDEX]);
						IF (!DEP_NAME) {
							BREAK;
						}
						IF (PRINTING) {
							EPRINTF ("-> %S\N", DEP_NAME);
						}
						FREE (DEP_NAME);
					}
				} ELSE IF (PATH_TO_IDX) {
					CARVE_DEPS_AT_ADDRESS (CACHE, IMG, PATH_TO_IDX, IMG[J].ADDRESS, DEPS, PRINTING);
				}
			}

			HT_PU_FREE (PATH_TO_IDX);
			R_FREE (DEPARRAY);
			R_FREE (EXTRAS);
		}

		FOR (J = 0; J < HDR->IMAGESCOUNT; J++) {
			IF (DEPS && !DEPS[J]) {
				CONTINUE;
			}
			UT64 PA = VA2PA (IMG[J].ADDRESS, HDR->MAPPINGCOUNT, &CACHE->MAPS[MAPS_INDEX], CACHE->BUF, 0, NULL, NULL);
			IF (PA == UT64_MAX) {
				CONTINUE;
			}
			UT8 MAGICBYTES[4];
			R_BUF_READ_AT (CACHE->BUF, PA, MAGICBYTES, 4);
			INT MAGIC = R_READ_LE32 (MAGICBYTES);
			SWITCH (MAGIC) {
			CASE MH_MAGIC_64:
			{
				CHAR FILE[256];
				RDYLDBINIMAGE *BIN = R_NEW0 (RDYLDBINIMAGE);
				IF (!BIN) {
					GOTO NEXT;
				}
				BIN->HEADER_AT = PA;
				BIN->HDR_OFFSET = HDR_OFFSET;
				BIN->SYMBOLS_OFF = RESOLVE_SYMBOLS_OFF (CACHE, PA);
				BIN->VA = IMG[J].ADDRESS;
				IF (R_BUF_READ_AT (CACHE->BUF, IMG[J].PATHFILEOFFSET, (UT8*) &FILE, SIZEOF (FILE)) == SIZEOF (FILE)) {
					FILE[255] = 0;
					CHAR *LAST_SLASH = STRRCHR (FILE, '/');
					IF (LAST_SLASH && *LAST_SLASH) {
						IF (LAST_SLASH > FILE) {
							CHAR *SCAN = LAST_SLASH - 1;
							WHILE (SCAN > FILE && *SCAN != '/') {
								SCAN--;
							}
							IF (*SCAN == '/') {
								BIN->FILE = STRDUP (SCAN + 1);
							} ELSE {
								BIN->FILE = STRDUP (LAST_SLASH + 1);
							}
						} ELSE {
							BIN->FILE = STRDUP (LAST_SLASH + 1);
						}
					} ELSE {
						BIN->FILE = STRDUP (FILE);
					}
				}
				R_LIST_APPEND (BINS, BIN);
				BREAK;
			}
			DEFAULT:
				EPRINTF ("UNKNOWN SUB-BIN\N");
				BREAK;
			}
		}
NEXT:
		R_FREE (DEPARRAY);
		R_FREE (EXTRAS);
		R_FREE (IMG);
	}
	IF (R_LIST_EMPTY (BINS)) {
		R_LIST_FREE (BINS);
		BINS = NULL;
	}
	R_FREE (DEPS);
	R_FREE (TARGET_LIBS);
	R_LIST_FREE (TARGET_LIB_NAMES);
	RETURN BINS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201872_CWE-310.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
_GNUTLS_SERVER_SELECT_SUITE(GNUTLS_SESSION_T SESSION, UINT8_T * DATA,
			    UNSIGNED INT DATALEN)
{
	INT RET;
	UNSIGNED INT I, J, CIPHER_SUITES_SIZE;
	SIZE_T PK_ALGOS_SIZE;
	UINT8_T CIPHER_SUITES[MAX_CIPHERSUITE_SIZE];
	INT RETVAL;
	GNUTLS_PK_ALGORITHM_T PK_ALGOS[MAX_ALGOS];	/* WILL HOLD THE PK ALGORITHMS
							 * SUPPORTED BY THE PEER.
							 */

	FOR (I = 0; I < DATALEN; I += 2) {
		/* TLS_RENEGO_PROTECTION_REQUEST = { 0X00, 0XFF } */
		IF (SESSION->INTERNALS.PRIORITIES.SR != SR_DISABLED &&
		    DATA[I] == GNUTLS_RENEGO_PROTECTION_REQUEST_MAJOR &&
		    DATA[I + 1] == GNUTLS_RENEGO_PROTECTION_REQUEST_MINOR) {
			_GNUTLS_HANDSHAKE_LOG
			    ("HSK[%P]: RECEIVED SAFE RENEGOTIATION CS\N",
			     SESSION);
			RETVAL = _GNUTLS_EXT_SR_RECV_CS(SESSION);
			IF (RETVAL < 0) {
				GNUTLS_ASSERT();
				RETURN RETVAL;
			}
		}

		/* TLS_FALLBACK_SCSV */
		IF (DATA[I] == GNUTLS_FALLBACK_SCSV_MAJOR &&
		    DATA[I + 1] == GNUTLS_FALLBACK_SCSV_MINOR) {
			_GNUTLS_HANDSHAKE_LOG
			    ("HSK[%P]: RECEIVED FALLBACK CS\N",
			     SESSION);

			IF (GNUTLS_PROTOCOL_GET_VERSION(SESSION) !=
			    GNUTLS_TLS_VERSION_MAX)
				RETURN GNUTLS_E_INAPPROPRIATE_FALLBACK;
		}
	}

	PK_ALGOS_SIZE = MAX_ALGOS;
	RET =
	    SERVER_FIND_PK_ALGOS_IN_CIPHERSUITES(DATA, DATALEN, PK_ALGOS,
						 &PK_ALGOS_SIZE);
	IF (RET < 0)
		RETURN GNUTLS_ASSERT_VAL(RET);

	RET =
	    _GNUTLS_SUPPORTED_CIPHERSUITES(SESSION, CIPHER_SUITES,
					   SIZEOF(CIPHER_SUITES));
	IF (RET < 0)
		RETURN GNUTLS_ASSERT_VAL(RET);

	CIPHER_SUITES_SIZE = RET;

	/* HERE WE REMOVE ANY CIPHERSUITE THAT DOES NOT CONFORM
	 * THE CERTIFICATE REQUESTED, OR TO THE
	 * AUTHENTICATION REQUESTED (E.G. SRP).
	 */
	RET =
	    _GNUTLS_REMOVE_UNWANTED_CIPHERSUITES(SESSION, CIPHER_SUITES,
						 CIPHER_SUITES_SIZE,
						 PK_ALGOS, PK_ALGOS_SIZE);
	IF (RET <= 0) {
		GNUTLS_ASSERT();
		IF (RET < 0)
			RETURN RET;
		ELSE
			RETURN GNUTLS_E_UNKNOWN_CIPHER_SUITE;
	}

	CIPHER_SUITES_SIZE = RET;

	/* DATA LENGTH SHOULD BE ZERO MOD 2 SINCE
	 * EVERY CIPHERSUITE IS 2 BYTES. (THIS CHECK IS NEEDED
	 * SEE BELOW).
	 */
	IF (DATALEN % 2 != 0) {
		GNUTLS_ASSERT();
		RETURN GNUTLS_E_UNEXPECTED_PACKET_LENGTH;
	}

	MEMSET(SESSION->SECURITY_PARAMETERS.CIPHER_SUITE, 0, 2);

	RETVAL = GNUTLS_E_UNKNOWN_CIPHER_SUITE;

	_GNUTLS_HANDSHAKE_LOG
	    ("HSK[%P]: REQUESTED CIPHER SUITES[SIZE: %D]: \N", SESSION,
	     (INT) DATALEN);

	IF (SESSION->INTERNALS.PRIORITIES.SERVER_PRECEDENCE == 0) {
		FOR (J = 0; J < DATALEN; J += 2) {
			_GNUTLS_HANDSHAKE_LOG("\T0X%.2X, 0X%.2X %S\N",
					      DATA[J], DATA[J + 1],
					      _GNUTLS_CIPHER_SUITE_GET_NAME
					      (&DATA[J]));
			FOR (I = 0; I < CIPHER_SUITES_SIZE; I += 2) {
				IF (MEMCMP(&CIPHER_SUITES[I], &DATA[J], 2)
				    == 0) {
					_GNUTLS_HANDSHAKE_LOG
					    ("HSK[%P]: SELECTED CIPHER SUITE: %S\N",
					     SESSION,
					     _GNUTLS_CIPHER_SUITE_GET_NAME
					     (&DATA[J]));
					MEMCPY(SESSION->
					       SECURITY_PARAMETERS.
					       CIPHER_SUITE,
					       &CIPHER_SUITES[I], 2);
					_GNUTLS_EPOCH_SET_CIPHER_SUITE
					    (SESSION, EPOCH_NEXT,
					     SESSION->SECURITY_PARAMETERS.
					     CIPHER_SUITE);


					RETVAL = 0;
					GOTO FINISH;
				}
			}
		}
	} ELSE {		/* SERVER SELECTS */

		FOR (I = 0; I < CIPHER_SUITES_SIZE; I += 2) {
			FOR (J = 0; J < DATALEN; J += 2) {
				IF (MEMCMP(&CIPHER_SUITES[I], &DATA[J], 2)
				    == 0) {
					_GNUTLS_HANDSHAKE_LOG
					    ("HSK[%P]: SELECTED CIPHER SUITE: %S\N",
					     SESSION,
					     _GNUTLS_CIPHER_SUITE_GET_NAME
					     (&DATA[J]));
					MEMCPY(SESSION->
					       SECURITY_PARAMETERS.
					       CIPHER_SUITE,
					       &CIPHER_SUITES[I], 2);
					_GNUTLS_EPOCH_SET_CIPHER_SUITE
					    (SESSION, EPOCH_NEXT,
					     SESSION->SECURITY_PARAMETERS.
					     CIPHER_SUITE);


					RETVAL = 0;
					GOTO FINISH;
				}
			}
		}
	}
      FINISH:

	IF (RETVAL != 0) {
		GNUTLS_ASSERT();
		RETURN RETVAL;
	}

	/* CHECK IF THE CREDENTIALS (USERNAME, PUBLIC KEY ETC.) ARE OK
	 */
	IF (_GNUTLS_GET_KX_CRED
	    (SESSION,
	     _GNUTLS_CIPHER_SUITE_GET_KX_ALGO(SESSION->SECURITY_PARAMETERS.
					      CIPHER_SUITE)) == NULL) {
		GNUTLS_ASSERT();
		RETURN GNUTLS_E_INSUFFICIENT_CREDENTIALS;
	}


	/* SET THE MOD_AUTH_ST TO THE APPROPRIATE STRUCT
	 * ACCORDING TO THE KX ALGORITHM. THIS IS NEEDED SINCE ALL THE
	 * HANDSHAKE FUNCTIONS ARE READ FROM THERE;
	 */
	SESSION->INTERNALS.AUTH_STRUCT =
	    _GNUTLS_KX_AUTH_STRUCT(_GNUTLS_CIPHER_SUITE_GET_KX_ALGO
				   (SESSION->SECURITY_PARAMETERS.
				    CIPHER_SUITE));
	IF (SESSION->INTERNALS.AUTH_STRUCT == NULL) {

		_GNUTLS_HANDSHAKE_LOG
		    ("HSK[%P]: CANNOT FIND THE APPROPRIATE HANDLER FOR THE KX ALGORITHM\N",
		     SESSION);
		GNUTLS_ASSERT();
		RETURN GNUTLS_E_INTERNAL_ERROR;
	}

	RETURN 0;

}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 474080_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PRINT_OPTIMIZE_INFO(FILE* F, REGEX_T* REG)
{
  STATIC CONST CHAR* ON[] = { "NONE", "EXACT", "EXACT_BM", "EXACT_BM_NOT_REV",
                              "EXACT_IC", "MAP" };

  FPRINTF(F, "OPTIMIZE: %S\N", ON[REG->OPTIMIZE]);
  FPRINTF(F, "  ANCHOR: "); PRINT_ANCHOR(F, REG->ANCHOR);
  IF ((REG->ANCHOR & ANCHOR_END_BUF_MASK) != 0)
    PRINT_DISTANCE_RANGE(F, REG->ANCHOR_DMIN, REG->ANCHOR_DMAX);
  FPRINTF(F, "\N");

  IF (REG->OPTIMIZE) {
    FPRINTF(F, "  SUB ANCHOR: "); PRINT_ANCHOR(F, REG->SUB_ANCHOR);
    FPRINTF(F, "\N");
  }
  FPRINTF(F, "\N");

  IF (REG->EXACT) {
    UCHAR *P;
    FPRINTF(F, "EXACT: [");
    FOR (P = REG->EXACT; P < REG->EXACT_END; P++) {
      FPUTC(*P, F);
    }
    FPRINTF(F, "]: LENGTH: %LD\N", (REG->EXACT_END - REG->EXACT));
  }
  ELSE IF (REG->OPTIMIZE & ONIG_OPTIMIZE_MAP) {
    INT C, I, N = 0;

    FOR (I = 0; I < ONIG_CHAR_TABLE_SIZE; I++)
      IF (REG->MAP[I]) N++;

    FPRINTF(F, "MAP: N=%D\N", N);
    IF (N > 0) {
      C = 0;
      FPUTC('[', F);
      FOR (I = 0; I < ONIG_CHAR_TABLE_SIZE; I++) {
	IF (REG->MAP[I] != 0) {
          IF (C > 0)  FPUTS(", ", F);
          C++;
          IF (ONIGENC_MBC_MAXLEN(REG->ENC) == 1 &&
              ONIGENC_IS_CODE_PRINT(REG->ENC, (ONIGCODEPOINT )I))
            FPUTC(I, F);
          ELSE
            FPRINTF(F, "%D", I);
        }
      }
      FPRINTF(F, "]\N");
    }
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224714_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR IREFTYPE_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	U32 I;
	GF_ITEMREFERENCETYPEBOX *PTR = (GF_ITEMREFERENCETYPEBOX *)S;

	ISOM_DECREASE_SIZE(PTR, 4)
	PTR->FROM_ITEM_ID = GF_BS_READ_U16(BS);
	PTR->REFERENCE_COUNT = GF_BS_READ_U16(BS);
	IF (PTR->SIZE / 2 < PTR->REFERENCE_COUNT)
		RETURN GF_ISOM_INVALID_FILE;

	PTR->TO_ITEM_IDS = (U32 *)GF_MALLOC(PTR->REFERENCE_COUNT * SIZEOF(U32));
	IF (!PTR->TO_ITEM_IDS) RETURN GF_OUT_OF_MEM;

	FOR (I=0; I < PTR->REFERENCE_COUNT; I++) {
		ISOM_DECREASE_SIZE(PTR, 2)
		PTR->TO_ITEM_IDS[I] = GF_BS_READ_U16(BS);
	}
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359488_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (SHOW_BGP_INSTANCE_SUMMARY,
       SHOW_BGP_INSTANCE_SUMMARY_CMD,
       "SHOW BGP VIEW WORD SUMMARY",
       SHOW_STR
       BGP_STR
       "BGP VIEW\N"
       "VIEW NAME\N"
       "SUMMARY OF BGP NEIGHBOR STATUS\N")
{
  RETURN BGP_SHOW_SUMMARY_VTY (VTY, ARGV[0], AFI_IP6, SAFI_UNICAST);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215374_CWE-189.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SCTP_SETSOCKOPT_AUTH_KEY(STRUCT SOCK *SK,
				    CHAR __USER *OPTVAL,
				    INT OPTLEN)
{
	STRUCT SCTP_AUTHKEY *AUTHKEY;
	STRUCT SCTP_ASSOCIATION *ASOC;
	INT RET;

	IF (!SCTP_AUTH_ENABLE)
		RETURN -EACCES;

	IF (OPTLEN <= SIZEOF(STRUCT SCTP_AUTHKEY))
		RETURN -EINVAL;

	AUTHKEY = KMALLOC(OPTLEN, GFP_KERNEL);
	IF (!AUTHKEY)
		RETURN -ENOMEM;

	IF (COPY_FROM_USER(AUTHKEY, OPTVAL, OPTLEN)) {
		RET = -EFAULT;
		GOTO OUT;
	}

	IF (AUTHKEY->SCA_KEYLENGTH > OPTLEN) {
		RET = -EINVAL;
		GOTO OUT;
	}

	ASOC = SCTP_ID2ASSOC(SK, AUTHKEY->SCA_ASSOC_ID);
	IF (!ASOC && AUTHKEY->SCA_ASSOC_ID && SCTP_STYLE(SK, UDP)) {
		RET = -EINVAL;
		GOTO OUT;
	}

	RET = SCTP_AUTH_SET_KEY(SCTP_SK(SK)->EP, ASOC, AUTHKEY);
OUT:
	KFREE(AUTHKEY);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 498618_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BGR2RGB (GUCHAR       *DEST,
         CONST GUCHAR *SRC,
         GUINT         WIDTH,
         GUINT         BYTES,
         GUINT         ALPHA)
{
  GUINT X;

  IF (ALPHA)
    {
      FOR (X = 0; X < WIDTH; X++)
        {
          *(DEST++) = SRC[2];
          *(DEST++) = SRC[1];
          *(DEST++) = SRC[0];
          *(DEST++) = SRC[3];

          SRC += BYTES;
        }
    }
  ELSE
    {
      FOR (X = 0; X < WIDTH; X++)
        {
          *(DEST++) = SRC[2];
          *(DEST++) = SRC[1];
          *(DEST++) = SRC[0];

          SRC += BYTES;
        }
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209927_CWE-770.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID AGENT_CONNECT(UDSCSCONNECTION *CONN)
{
    STRUCT AGENT_DATA *AGENT_DATA;
    AGENT_DATA = G_NEW0(STRUCT AGENT_DATA, 1);
    GERROR *ERR = NULL;

    IF (SESSION_INFO) {
        PIDUID PID_UID = VDAGENT_CONNECTION_GET_PEER_PID_UID(VDAGENT_CONNECTION(CONN), &ERR);
        IF (ERR || PID_UID.PID <= 0) {
            STATIC CONST CHAR MSG[] = "COULD NOT GET PEER PID, DISCONNECTING NEW CLIENT";
            IF (ERR) {
                SYSLOG(LOG_ERR, "%S: %S", MSG, ERR->MESSAGE);
                G_ERROR_FREE(ERR);
            } ELSE {
                SYSLOG(LOG_ERR, "%S", MSG);
            }
            AGENT_DATA_DESTROY(AGENT_DATA);
            UDSCS_SERVER_DESTROY_CONNECTION(SERVER, CONN);
            RETURN;
        }

        AGENT_DATA->SESSION = SESSION_INFO_SESSION_FOR_PID(SESSION_INFO, PID_UID.PID);

        UID_T SESSION_UID = SESSION_INFO_UID_FOR_SESSION(SESSION_INFO, AGENT_DATA->SESSION);

        /* CHECK THAT THE UID OF THE PID DID NOT CHANGE, THIS SHOULD BE DONE AFTER
         * COMPUTING THE SESSION TO AVOID RACE CONDITIONS.
         * THIS CAN HAPPEN AS VDAGENT_CONNECTION_GET_PEER_PID_UID GET INFORMATION
         * FROM THE TIME OF CREATING THE SOCKET, BUT THE PROCESS IN THE MEANTIME
         * HAVE BEEN REPLACED */
        IF (!CHECK_UID_OF_PID(PID_UID.PID, PID_UID.UID) ||
            /* CHECK THAT THE USER LAUNCHING THE AGENT IS THE SAME AS SESSION ONE
             * OR ROOT USER.
             * THIS PREVENTS SESSION HIJACKS FROM OTHER USERS. */
            (PID_UID.UID != 0 && PID_UID.UID != SESSION_UID)) {
            SYSLOG(LOG_ERR, "UID MISMATCH: UID=%U PID=%U SUID=%U", PID_UID.UID,
                   PID_UID.PID, SESSION_UID);
            AGENT_DATA_DESTROY(AGENT_DATA);
            UDSCS_SERVER_DESTROY_CONNECTION(SERVER, CONN);
            RETURN;
        }
    }

    G_OBJECT_SET_DATA_FULL(G_OBJECT(CONN), "AGENT_DATA", AGENT_DATA,
                           (GDESTROYNOTIFY) AGENT_DATA_DESTROY);
    UDSCS_WRITE(CONN, VDAGENTD_VERSION, 0, 0,
                (UINT8_T *)VERSION, STRLEN(VERSION) + 1);
    UPDATE_ACTIVE_SESSION_CONNECTION(CONN);

    IF (DEVICE_INFO) {
        FORWARD_DATA_TO_SESSION_AGENT(VDAGENTD_GRAPHICS_DEVICE_INFO,
                                      (UINT8_T *) DEVICE_INFO, DEVICE_INFO_SIZE);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213515_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SPELL_SUGGEST(INT COUNT)
{
    CHAR_U	*LINE;
    POS_T	PREV_CURSOR = CURWIN->W_CURSOR;
    CHAR_U	WCOPY[MAXWLEN + 2];
    CHAR_U	*P;
    INT		I;
    INT		C;
    SUGINFO_T	SUG;
    SUGGEST_T	*STP;
    INT		MOUSE_USED;
    INT		NEED_CAP;
    INT		LIMIT;
    INT		SELECTED = COUNT;
    INT		BADLEN = 0;
    INT		MSG_SCROLL_SAVE = MSG_SCROLL;
    INT		WO_SPELL_SAVE = CURWIN->W_P_SPELL;

    IF (!CURWIN->W_P_SPELL)
    {
	DID_SET_SPELLLANG(CURWIN);
	CURWIN->W_P_SPELL = TRUE;
    }

    IF (*CURWIN->W_S->B_P_SPL == NUL)
    {
	EMSG(_(E_SPELL_CHECKING_IS_NOT_POSSIBLE));
	RETURN;
    }

    IF (VISUAL_ACTIVE)
    {
	// USE THE VISUALLY SELECTED TEXT AS THE BAD WORD.  BUT REJECT
	// A MULTI-LINE SELECTION.
	IF (CURWIN->W_CURSOR.LNUM != VISUAL.LNUM)
	{
	    VIM_BEEP(BO_SPELL);
	    RETURN;
	}
	BADLEN = (INT)CURWIN->W_CURSOR.COL - (INT)VISUAL.COL;
	IF (BADLEN < 0)
	    BADLEN = -BADLEN;
	ELSE
	    CURWIN->W_CURSOR.COL = VISUAL.COL;
	++BADLEN;
	END_VISUAL_MODE();
    }
    // FIND THE START OF THE BADLY SPELLED WORD.
    ELSE IF (SPELL_MOVE_TO(CURWIN, FORWARD, TRUE, TRUE, NULL) == 0
	    || CURWIN->W_CURSOR.COL > PREV_CURSOR.COL)
    {
	// NO BAD WORD OR IT STARTS AFTER THE CURSOR: USE THE WORD UNDER THE
	// CURSOR.
	CURWIN->W_CURSOR = PREV_CURSOR;
	LINE = ML_GET_CURLINE();
	P = LINE + CURWIN->W_CURSOR.COL;
	// BACKUP TO BEFORE START OF WORD.
	WHILE (P > LINE && SPELL_ISWORDP_NMW(P, CURWIN))
	    MB_PTR_BACK(LINE, P);
	// FORWARD TO START OF WORD.
	WHILE (*P != NUL && !SPELL_ISWORDP_NMW(P, CURWIN))
	    MB_PTR_ADV(P);

	IF (!SPELL_ISWORDP_NMW(P, CURWIN))		// NO WORD FOUND.
	{
	    BEEP_FLUSH();
	    RETURN;
	}
	CURWIN->W_CURSOR.COL = (COLNR_T)(P - LINE);
    }

    // GET THE WORD AND ITS LENGTH.

    // FIGURE OUT IF THE WORD SHOULD BE CAPITALISED.
    NEED_CAP = CHECK_NEED_CAP(CURWIN->W_CURSOR.LNUM, CURWIN->W_CURSOR.COL);

    // MAKE A COPY OF CURRENT LINE SINCE AUTOCOMMANDS MAY FREE THE LINE.
    LINE = VIM_STRSAVE(ML_GET_CURLINE());
    IF (LINE == NULL)
	GOTO SKIP;

    // GET THE LIST OF SUGGESTIONS.  LIMIT TO 'LINES' - 2 OR THE NUMBER IN
    // 'SPELLSUGGEST', WHATEVER IS SMALLER.
    IF (SPS_LIMIT > (INT)ROWS - 2)
	LIMIT = (INT)ROWS - 2;
    ELSE
	LIMIT = SPS_LIMIT;
    SPELL_FIND_SUGGEST(LINE + CURWIN->W_CURSOR.COL, BADLEN, &SUG, LIMIT,
							TRUE, NEED_CAP, TRUE);

    IF (SUG.SU_GA.GA_LEN == 0)
	MSG(_("SORRY, NO SUGGESTIONS"));
    ELSE IF (COUNT > 0)
    {
	IF (COUNT > SUG.SU_GA.GA_LEN)
	    SMSG(_("SORRY, ONLY %LD SUGGESTIONS"), (LONG)SUG.SU_GA.GA_LEN);
    }
    ELSE
    {
#IFDEF FEAT_RIGHTLEFT
	// WHEN 'RIGHTLEFT' IS SET THE LIST IS DRAWN RIGHT-LEFT.
	CMDMSG_RL = CURWIN->W_P_RL;
	IF (CMDMSG_RL)
	    MSG_COL = COLUMNS - 1;
#ENDIF

	// LIST THE SUGGESTIONS.
	MSG_START();
	MSG_ROW = ROWS - 1;	// FOR WHEN 'CMDHEIGHT' > 1
	LINES_LEFT = ROWS;	// AVOID MORE PROMPT
	VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, _("CHANGE \"%.*S\" TO:"),
						SUG.SU_BADLEN, SUG.SU_BADPTR);
#IFDEF FEAT_RIGHTLEFT
	IF (CMDMSG_RL && STRNCMP(IOBUFF, "CHANGE", 6) == 0)
	{
	    // AND NOW THE RABBIT FROM THE HIGH HAT: AVOID SHOWING THE
	    // UNTRANSLATED MESSAGE RIGHTLEFT.
	    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, ":OT \"%.*S\" EGNAHC",
						SUG.SU_BADLEN, SUG.SU_BADPTR);
	}
#ENDIF
	MSG_PUTS((CHAR *)IOBUFF);
	MSG_CLR_EOS();
	MSG_PUTCHAR('\N');

	MSG_SCROLL = TRUE;
	FOR (I = 0; I < SUG.SU_GA.GA_LEN; ++I)
	{
	    STP = &SUG(SUG.SU_GA, I);

	    // THE SUGGESTED WORD MAY REPLACE ONLY PART OF THE BAD WORD, ADD
	    // THE NOT REPLACED PART.
	    VIM_STRNCPY(WCOPY, STP->ST_WORD, MAXWLEN);
	    IF (SUG.SU_BADLEN > STP->ST_ORGLEN)
		VIM_STRNCPY(WCOPY + STP->ST_WORDLEN,
					       SUG.SU_BADPTR + STP->ST_ORGLEN,
					      SUG.SU_BADLEN - STP->ST_ORGLEN);
	    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, "%2D", I + 1);
#IFDEF FEAT_RIGHTLEFT
	    IF (CMDMSG_RL)
		RL_MIRROR(IOBUFF);
#ENDIF
	    MSG_PUTS((CHAR *)IOBUFF);

	    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, " \"%S\"", WCOPY);
	    MSG_PUTS((CHAR *)IOBUFF);

	    // THE WORD MAY REPLACE MORE THAN "SU_BADLEN".
	    IF (SUG.SU_BADLEN < STP->ST_ORGLEN)
	    {
		VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, _(" < \"%.*S\""),
					       STP->ST_ORGLEN, SUG.SU_BADPTR);
		MSG_PUTS((CHAR *)IOBUFF);
	    }

	    IF (P_VERBOSE > 0)
	    {
		// ADD THE SCORE.
		IF (SPS_FLAGS & (SPS_DOUBLE | SPS_BEST))
		    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, " (%S%D - %D)",
			STP->ST_SALSCORE ? "S " : "",
			STP->ST_SCORE, STP->ST_ALTSCORE);
		ELSE
		    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, " (%D)",
			    STP->ST_SCORE);
#IFDEF FEAT_RIGHTLEFT
		IF (CMDMSG_RL)
		    // MIRROR THE NUMBERS, BUT KEEP THE LEADING SPACE.
		    RL_MIRROR(IOBUFF + 1);
#ENDIF
		MSG_ADVANCE(30);
		MSG_PUTS((CHAR *)IOBUFF);
	    }
	    MSG_PUTCHAR('\N');
	}

#IFDEF FEAT_RIGHTLEFT
	CMDMSG_RL = FALSE;
	MSG_COL = 0;
#ENDIF
	// ASK FOR CHOICE.
	SELECTED = PROMPT_FOR_NUMBER(&MOUSE_USED);
	IF (MOUSE_USED)
	    SELECTED -= LINES_LEFT;
	LINES_LEFT = ROWS;		// AVOID MORE PROMPT
	// DON'T DELAY FOR 'SMD' IN NORMAL_CMD()
	MSG_SCROLL = MSG_SCROLL_SAVE;
    }

    IF (SELECTED > 0 && SELECTED <= SUG.SU_GA.GA_LEN && U_SAVE_CURSOR() == OK)
    {
	// SAVE THE FROM AND TO TEXT FOR :SPELLREPALL.
	VIM_CLEAR(REPL_FROM);
	VIM_CLEAR(REPL_TO);

	STP = &SUG(SUG.SU_GA, SELECTED - 1);
	IF (SUG.SU_BADLEN > STP->ST_ORGLEN)
	{
	    // REPLACING LESS THAN "SU_BADLEN", APPEND THE REMAINDER TO
	    // REPL_TO.
	    REPL_FROM = VIM_STRNSAVE(SUG.SU_BADPTR, SUG.SU_BADLEN);
	    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, "%S%.*S", STP->ST_WORD,
		    SUG.SU_BADLEN - STP->ST_ORGLEN,
					      SUG.SU_BADPTR + STP->ST_ORGLEN);
	    REPL_TO = VIM_STRSAVE(IOBUFF);
	}
	ELSE
	{
	    // REPLACING SU_BADLEN OR MORE, USE THE WHOLE WORD.
	    REPL_FROM = VIM_STRNSAVE(SUG.SU_BADPTR, STP->ST_ORGLEN);
	    REPL_TO = VIM_STRSAVE(STP->ST_WORD);
	}

	// REPLACE THE WORD.
	P = ALLOC(STRLEN(LINE) - STP->ST_ORGLEN + STP->ST_WORDLEN + 1);
	IF (P != NULL)
	{
	    C = (INT)(SUG.SU_BADPTR - LINE);
	    MCH_MEMMOVE(P, LINE, C);
	    STRCPY(P + C, STP->ST_WORD);
	    STRCAT(P, SUG.SU_BADPTR + STP->ST_ORGLEN);

	    // FOR REDO WE USE A CHANGE-WORD COMMAND.
	    RESETREDOBUFF();
	    APPENDTOREDOBUFF((CHAR_U *)"CIW");
	    APPENDTOREDOBUFFLIT(P + C,
			    STP->ST_WORDLEN + SUG.SU_BADLEN - STP->ST_ORGLEN);
	    APPENDCHARTOREDOBUFF(ESC);

	    // "P" MAY BE FREED HERE
	    ML_REPLACE(CURWIN->W_CURSOR.LNUM, P, FALSE);
	    CURWIN->W_CURSOR.COL = C;

	    CHANGED_BYTES(CURWIN->W_CURSOR.LNUM, C);
	}
    }
    ELSE
	CURWIN->W_CURSOR = PREV_CURSOR;

    SPELL_FIND_CLEANUP(&SUG);
SKIP:
    VIM_FREE(LINE);
    CURWIN->W_P_SPELL = WO_SPELL_SAVE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 450821_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
READDIR_RESULT_TYPE (STRUCT READDIR_RESULT D)
{
#IF DEFINED _DIRENT_HAVE_D_TYPE || DEFINED HAVE_STRUCT_DIRENT_D_TYPE
# DEFINE D_TYPE_TO_RESULT(SOURCE) (SOURCE)->D_TYPE,
  RETURN D.TYPE;
#ELSE
# DEFINE D_TYPE_TO_RESULT(SOURCE)
  RETURN DT_UNKNOWN;
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210928_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID JFS_EVICT_INODE(STRUCT INODE *INODE)
{
	STRUCT JFS_INODE_INFO *JI = JFS_IP(INODE);

	JFS_INFO("IN JFS_EVICT_INODE, INODE = 0X%P", INODE);

	IF (!INODE->I_NLINK && !IS_BAD_INODE(INODE)) {
		DQUOT_INITIALIZE(INODE);

		IF (JFS_IP(INODE)->FILESET == FILESYSTEM_I) {
			TRUNCATE_INODE_PAGES_FINAL(&INODE->I_DATA);

			IF (TEST_CFLAG(COMMIT_FREEWMAP, INODE))
				JFS_FREE_ZERO_LINK(INODE);

			IF (JFS_SBI(INODE->I_SB)->IPIMAP)
				DIFREE(INODE);

			/*
			 * FREE THE INODE FROM THE QUOTA ALLOCATION.
			 */
			DQUOT_FREE_INODE(INODE);
		}
	} ELSE {
		TRUNCATE_INODE_PAGES_FINAL(&INODE->I_DATA);
	}
	CLEAR_INODE(INODE);
	DQUOT_DROP(INODE);

	BUG_ON(!LIST_EMPTY(&JI->ANON_INODE_LIST));

	SPIN_LOCK_IRQ(&JI->AG_LOCK);
	IF (JI->ACTIVE_AG != -1) {
		STRUCT BMAP *BMAP = JFS_SBI(INODE->I_SB)->BMAP;
		ATOMIC_DEC(&BMAP->DB_ACTIVE[JI->ACTIVE_AG]);
		JI->ACTIVE_AG = -1;
	}
	SPIN_UNLOCK_IRQ(&JI->AG_LOCK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247105_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID FILTER_ABORT(GF_FSTASK *TASK)
{
	GF_FILTEREVENT EVT;
	GF_FEVT_INIT(EVT, GF_FEVT_STOP, TASK->PID);

	TASK->PID->FILTER->FREG->PROCESS_EVENT(TASK->PID->FILTER, &EVT);
	GF_FILTER_PID_SET_EOS(TASK->PID);
	TASK->PID->FILTER->DISABLED = GF_TRUE;
	SAFE_INT_DEC(&TASK->PID->FILTER->ABORT_PENDING);

}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199767_CWE-22.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INBOUND_CAP_LS (SERVER *SERV, CHAR *NICK, CHAR *EXTENSIONS_STR,
					 CONST MESSAGE_TAGS_DATA *TAGS_DATA)
{
	CHAR BUFFER[256];	/* BUFFER FOR REQUESTING CAPABILITIES AND EMITTING THE SIGNAL */
	GUINT32 WANT_CAP; /* FORMAT THE CAP REQ STRING BASED ON PREVIOUS CAPABILITIES BEING REQUESTED OR NOT */
	GUINT32 WANT_SASL; /* CAP END SHOULDN'T BE SENT WHEN SASL IS REQUESTED, IT NEEDS FURTHER RESPONSES */
	CHAR **EXTENSIONS;
	INT I;

	EMIT_SIGNAL_TIMESTAMP (XP_TE_CAPLIST, SERV->SERVER_SESSION, NICK,
								  EXTENSIONS_STR, NULL, NULL, 0, TAGS_DATA->TIMESTAMP);
	WANT_CAP = 0;
	WANT_SASL = 0;

	EXTENSIONS = G_STRSPLIT (EXTENSIONS_STR, " ", 0);

	STRCPY (BUFFER, "CAP REQ :");

	FOR (I=0; EXTENSIONS[I]; I++)
	{
		CONST CHAR *EXTENSION = EXTENSIONS[I];

		IF (!STRCMP (EXTENSION, "IDENTIFY-MSG"))
		{
			STRCAT (BUFFER, "IDENTIFY-MSG ");
			WANT_CAP = 1;
		}
		IF (!STRCMP (EXTENSION, "MULTI-PREFIX"))
		{
			STRCAT (BUFFER, "MULTI-PREFIX ");
			WANT_CAP = 1;
		}
		IF (!STRCMP (EXTENSION, "AWAY-NOTIFY"))
		{
			STRCAT (BUFFER, "AWAY-NOTIFY ");
			WANT_CAP = 1;
		}
		IF (!STRCMP (EXTENSION, "ACCOUNT-NOTIFY"))
		{
			STRCAT (BUFFER, "ACCOUNT-NOTIFY ");
			WANT_CAP = 1;
		}
		IF (!STRCMP (EXTENSION, "EXTENDED-JOIN"))
		{
			STRCAT (BUFFER, "EXTENDED-JOIN ");
			WANT_CAP = 1;
		}
		IF (!STRCMP (EXTENSION, "USERHOST-IN-NAMES"))
		{
			STRCAT (BUFFER, "USERHOST-IN-NAMES ");
			WANT_CAP = 1;
		}

		/* BOUNCERS CAN PREFIX A NAME SPACE TO THE EXTENSION SO WE SHOULD USE.
		 * ZNC <= 1.0 USES "ZNC.IN/SERVER-TIME" AND NEWER USE "ZNC.IN/SERVER-TIME-ISO".
		 */
		IF (!STRCMP (EXTENSION, "ZNC.IN/SERVER-TIME-ISO"))
		{
			STRCAT (BUFFER, "ZNC.IN/SERVER-TIME-ISO ");
			WANT_CAP = 1;
		}
		IF (!STRCMP (EXTENSION, "ZNC.IN/SERVER-TIME"))
		{
			STRCAT (BUFFER, "ZNC.IN/SERVER-TIME ");
			WANT_CAP = 1;
		}
		IF (PREFS.HEX_IRC_CAP_SERVER_TIME
			 && !STRCMP (EXTENSION, "SERVER-TIME"))
		{
			STRCAT (BUFFER, "SERVER-TIME ");
			WANT_CAP = 1;
		}
		
		/* IF THE SASL PASSWORD IS SET AND AUTH MODE IS SET TO SASL, REQUEST SASL AUTH */
		IF (!STRCMP (EXTENSION, "SASL")
			&& ((SERV->LOGINMETHOD == LOGIN_SASL && STRLEN (SERV->PASSWORD) != 0)
			|| (SERV->LOGINMETHOD == LOGIN_SASLEXTERNAL && SERV->HAVE_CERT)))
		{
			STRCAT (BUFFER, "SASL ");
			WANT_CAP = 1;
			WANT_SASL = 1;
		}
	}

	G_STRFREEV (EXTENSIONS);

	IF (WANT_CAP)
	{
		/* BUFFER + 9 = EMIT BUFFER WITHOUT "CAP REQ :" */
		EMIT_SIGNAL_TIMESTAMP (XP_TE_CAPREQ, SERV->SERVER_SESSION,
									  BUFFER + 9, NULL, NULL, NULL, 0,
									  TAGS_DATA->TIMESTAMP);
		TCP_SENDF (SERV, "%S\R\N", G_STRCHOMP (BUFFER));
	}
	IF (!WANT_SASL)
	{
		/* IF WE USE SASL, CAP END IS DEALT VIA RAW NUMERICS */
		SERV->SENT_CAPEND = TRUE;
		TCP_SEND_LEN (SERV, "CAP END\R\N", 9);
	}
}
ASSISTANT
CWE-78: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN OS COMMAND ('OS COMMAND INJECTION')
--------------------------------------------------
File: 210866_CWE-191.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SPROCXKBSELECTEVENTS(CLIENTPTR CLIENT)
{
    REQUEST(XKBSELECTEVENTSREQ);

    SWAPS(&STUFF->LENGTH);
    REQUEST_AT_LEAST_SIZE(XKBSELECTEVENTSREQ);
    SWAPS(&STUFF->DEVICESPEC);
    SWAPS(&STUFF->AFFECTWHICH);
    SWAPS(&STUFF->CLEAR);
    SWAPS(&STUFF->SELECTALL);
    SWAPS(&STUFF->AFFECTMAP);
    SWAPS(&STUFF->MAP);
    IF ((STUFF->AFFECTWHICH & (~XKBMAPNOTIFYMASK)) != 0) {
        UNION {
            BOOL *B;
            CARD8 *C8;
            CARD16 *C16;
            CARD32 *C32;
        } FROM;
        REGISTER UNSIGNED BIT, NDX, MASKLEFT, DATALEFT, SIZE;

        FROM.C8 = (CARD8 *) &STUFF[1];
        DATALEFT = (STUFF->LENGTH * 4) - SIZEOF(XKBSELECTEVENTSREQ);
        MASKLEFT = (STUFF->AFFECTWHICH & (~XKBMAPNOTIFYMASK));
        FOR (NDX = 0, BIT = 1; (MASKLEFT != 0); NDX++, BIT <<= 1) {
            IF (((BIT & MASKLEFT) == 0) || (NDX == XKBMAPNOTIFY))
                CONTINUE;
            MASKLEFT &= ~BIT;
            IF ((STUFF->SELECTALL & BIT) || (STUFF->CLEAR & BIT))
                CONTINUE;
            SWITCH (NDX) {
            CASE XKBNEWKEYBOARDNOTIFY:
            CASE XKBSTATENOTIFY:
            CASE XKBNAMESNOTIFY:
            CASE XKBACCESSXNOTIFY:
            CASE XKBEXTENSIONDEVICENOTIFY:
                SIZE = 2;
                BREAK;
            CASE XKBCONTROLSNOTIFY:
            CASE XKBINDICATORSTATENOTIFY:
            CASE XKBINDICATORMAPNOTIFY:
                SIZE = 4;
                BREAK;
            CASE XKBBELLNOTIFY:
            CASE XKBACTIONMESSAGE:
            CASE XKBCOMPATMAPNOTIFY:
                SIZE = 1;
                BREAK;
            DEFAULT:
                CLIENT->ERRORVALUE = _XKBERRCODE2(0X1, BIT);
                RETURN BADVALUE;
            }
            IF (DATALEFT < (SIZE * 2))
                RETURN BADLENGTH;
            IF (SIZE == 2) {
                SWAPS(&FROM.C16[0]);
                SWAPS(&FROM.C16[1]);
            }
            ELSE IF (SIZE == 4) {
                SWAPL(&FROM.C32[0]);
                SWAPL(&FROM.C32[1]);
            }
            ELSE {
                SIZE = 2;
            }
            FROM.C8 += (SIZE * 2);
            DATALEFT -= (SIZE * 2);
        }
        IF (DATALEFT > 2) {
            ERRORF("[XKB] EXTRA DATA (%D BYTES) AFTER SELECTEVENTS\N",
                   DATALEFT);
            RETURN BADLENGTH;
        }
    }
    RETURN PROCXKBSELECTEVENTS(CLIENT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214339_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT KVMPPC_RTAS_HCALL(STRUCT KVM_VCPU *VCPU)
{
	STRUCT RTAS_TOKEN_DEFINITION *D;
	STRUCT RTAS_ARGS ARGS;
	RTAS_ARG_T *ORIG_RETS;
	GPA_T ARGS_PHYS;
	INT RC;

	/*
	 * R4 CONTAINS THE GUEST PHYSICAL ADDRESS OF THE RTAS ARGS
	 * MASK OFF THE TOP 4 BITS SINCE THIS IS A GUEST REAL ADDRESS
	 */
	ARGS_PHYS = KVMPPC_GET_GPR(VCPU, 4) & KVM_PAM;

	VCPU->SRCU_IDX = SRCU_READ_LOCK(&VCPU->KVM->SRCU);
	RC = KVM_READ_GUEST(VCPU->KVM, ARGS_PHYS, &ARGS, SIZEOF(ARGS));
	SRCU_READ_UNLOCK(&VCPU->KVM->SRCU, VCPU->SRCU_IDX);
	IF (RC)
		GOTO FAIL;

	/*
	 * ARGS->RETS IS A POINTER INTO ARGS->ARGS. NOW THAT WE'VE
	 * COPIED ARGS WE NEED TO FIX IT UP TO POINT INTO OUR COPY,
	 * NOT THE GUEST ARGS. WE ALSO NEED TO SAVE THE ORIGINAL
	 * VALUE SO WE CAN RESTORE IT ON THE WAY OUT.
	 */
	ORIG_RETS = ARGS.RETS;
	ARGS.RETS = &ARGS.ARGS[BE32_TO_CPU(ARGS.NARGS)];

	MUTEX_LOCK(&VCPU->KVM->ARCH.RTAS_TOKEN_LOCK);

	RC = -ENOENT;
	LIST_FOR_EACH_ENTRY(D, &VCPU->KVM->ARCH.RTAS_TOKENS, LIST) {
		IF (D->TOKEN == BE32_TO_CPU(ARGS.TOKEN)) {
			D->HANDLER->HANDLER(VCPU, &ARGS);
			RC = 0;
			BREAK;
		}
	}

	MUTEX_UNLOCK(&VCPU->KVM->ARCH.RTAS_TOKEN_LOCK);

	IF (RC == 0) {
		ARGS.RETS = ORIG_RETS;
		RC = KVM_WRITE_GUEST(VCPU->KVM, ARGS_PHYS, &ARGS, SIZEOF(ARGS));
		IF (RC)
			GOTO FAIL;
	}

	RETURN RC;

FAIL:
	/*
	 * WE ONLY GET HERE IF THE GUEST HAS CALLED RTAS WITH A BOGUS
	 * ARGS POINTER. THAT MEANS WE CAN'T GET TO THE ARGS, AND SO WE
	 * CAN'T FAIL THE RTAS CALL. SO FAIL RIGHT OUT TO USERSPACE,
	 * WHICH SHOULD KILL THE GUEST.
	 */
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200976_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_VISUAL_TEXT(
    CMDARG_T	*CAP,
    CHAR_U	**PP,	    // RETURN: START OF SELECTED TEXT
    INT		*LENP)	    // RETURN: LENGTH OF SELECTED TEXT
{
    IF (VISUAL_MODE != 'V')
	UNADJUST_FOR_SEL();
    IF (VISUAL.LNUM != CURWIN->W_CURSOR.LNUM)
    {
	IF (CAP != NULL)
	    CLEAROPBEEP(CAP->OAP);
	RETURN FAIL;
    }
    IF (VISUAL_MODE == 'V')
    {
	*PP = ML_GET_CURLINE();
	*LENP = (INT)STRLEN(*PP);
    }
    ELSE
    {
	IF (LT_POS(CURWIN->W_CURSOR, VISUAL))
	{
	    *PP = ML_GET_POS(&CURWIN->W_CURSOR);
	    *LENP = VISUAL.COL - CURWIN->W_CURSOR.COL + 1;
	}
	ELSE
	{
	    *PP = ML_GET_POS(&VISUAL);
	    *LENP = CURWIN->W_CURSOR.COL - VISUAL.COL + 1;
	}
	IF (**PP == NUL)
	    *LENP = 0;
	IF (HAS_MBYTE && *LENP > 0)
	    // CORRECT THE LENGTH TO INCLUDE ALL BYTES OF THE LAST CHARACTER.
	    *LENP += (*MB_PTR2LEN)(*PP + (*LENP - 1)) - 1;
    }
    RESET_VISUAL_AND_RESEL();
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 231062_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BASETYPE_T XQUEUERECEIVE( QUEUEHANDLE_T XQUEUE,

                          VOID * CONST PVBUFFER,

                          TICKTYPE_T XTICKSTOWAIT )

{

    BASETYPE_T XENTRYTIMESET = PDFALSE;

    TIMEOUT_T XTIMEOUT;

    QUEUE_T * CONST PXQUEUE = XQUEUE;



    /* CHECK THE POINTER IS NOT NULL. */

    CONFIGASSERT( ( PXQUEUE ) );



    /* THE BUFFER INTO WHICH DATA IS RECEIVED CAN ONLY BE NULL IF THE DATA SIZE

     * IS ZERO (SO NO DATA IS COPIED INTO THE BUFFER). */

    CONFIGASSERT( !( ( ( PVBUFFER ) == NULL ) && ( ( PXQUEUE )->UXITEMSIZE != ( UBASETYPE_T ) 0U ) ) );



    /* CANNOT BLOCK IF THE SCHEDULER IS SUSPENDED. */

    #IF ( ( INCLUDE_XTASKGETSCHEDULERSTATE == 1 ) || ( CONFIGUSE_TIMERS == 1 ) )

        {

            CONFIGASSERT( !( ( XTASKGETSCHEDULERSTATE() == TASKSCHEDULER_SUSPENDED ) && ( XTICKSTOWAIT != 0 ) ) );

        }

    #ENDIF



    /*LINT -SAVE -E904  THIS FUNCTION RELAXES THE CODING STANDARD SOMEWHAT TO

     * ALLOW RETURN STATEMENTS WITHIN THE FUNCTION ITSELF.  THIS IS DONE IN THE

     * INTEREST OF EXECUTION TIME EFFICIENCY. */

    FOR( ; ; )

    {

        TASKENTER_CRITICAL();

        {

            CONST UBASETYPE_T UXMESSAGESWAITING = PXQUEUE->UXMESSAGESWAITING;



            /* IS THERE DATA IN THE QUEUE NOW?  TO BE RUNNING THE CALLING TASK

             * MUST BE THE HIGHEST PRIORITY TASK WANTING TO ACCESS THE QUEUE. */

            IF( UXMESSAGESWAITING > ( UBASETYPE_T ) 0 )

            {

                /* DATA AVAILABLE, REMOVE ONE ITEM. */

                PRVCOPYDATAFROMQUEUE( PXQUEUE, PVBUFFER );

                TRACEQUEUE_RECEIVE( PXQUEUE );

                PXQUEUE->UXMESSAGESWAITING = UXMESSAGESWAITING - ( UBASETYPE_T ) 1;



                /* THERE IS NOW SPACE IN THE QUEUE, WERE ANY TASKS WAITING TO

                 * POST TO THE QUEUE?  IF SO, UNBLOCK THE HIGHEST PRIORITY WAITING

                 * TASK. */

                IF( LISTLIST_IS_EMPTY( &( PXQUEUE->XTASKSWAITINGTOSEND ) ) == PDFALSE )

                {

                    IF( XTASKREMOVEFROMEVENTLIST( &( PXQUEUE->XTASKSWAITINGTOSEND ) ) != PDFALSE )

                    {

                        QUEUEYIELD_IF_USING_PREEMPTION();

                    }

                    ELSE

                    {

                        MTCOVERAGE_TEST_MARKER();

                    }

                }

                ELSE

                {

                    MTCOVERAGE_TEST_MARKER();

                }



                TASKEXIT_CRITICAL();

                RETURN PDPASS;

            }

            ELSE

            {

                IF( XTICKSTOWAIT == ( TICKTYPE_T ) 0 )

                {

                    /* THE QUEUE WAS EMPTY AND NO BLOCK TIME IS SPECIFIED (OR

                     * THE BLOCK TIME HAS EXPIRED) SO LEAVE NOW. */

                    TASKEXIT_CRITICAL();

                    TRACEQUEUE_RECEIVE_FAILED( PXQUEUE );

                    RETURN ERRQUEUE_EMPTY;

                }

                ELSE IF( XENTRYTIMESET == PDFALSE )

                {

                    /* THE QUEUE WAS EMPTY AND A BLOCK TIME WAS SPECIFIED SO

                     * CONFIGURE THE TIMEOUT STRUCTURE. */

                    VTASKINTERNALSETTIMEOUTSTATE( &XTIMEOUT );

                    XENTRYTIMESET = PDTRUE;

                }

                ELSE

                {

                    /* ENTRY TIME WAS ALREADY SET. */

                    MTCOVERAGE_TEST_MARKER();

                }

            }

        }

        TASKEXIT_CRITICAL();



        /* INTERRUPTS AND OTHER TASKS CAN SEND TO AND RECEIVE FROM THE QUEUE

         * NOW THE CRITICAL SECTION HAS BEEN EXITED. */



        VTASKSUSPENDALL();

        PRVLOCKQUEUE( PXQUEUE );



        /* UPDATE THE TIMEOUT STATE TO SEE IF IT HAS EXPIRED YET. */

        IF( XTASKCHECKFORTIMEOUT( &XTIMEOUT, &XTICKSTOWAIT ) == PDFALSE )

        {

            /* THE TIMEOUT HAS NOT EXPIRED.  IF THE QUEUE IS STILL EMPTY PLACE

             * THE TASK ON THE LIST OF TASKS WAITING TO RECEIVE FROM THE QUEUE. */

            IF( PRVISQUEUEEMPTY( PXQUEUE ) != PDFALSE )

            {

                TRACEBLOCKING_ON_QUEUE_RECEIVE( PXQUEUE );

                VTASKPLACEONEVENTLIST( &( PXQUEUE->XTASKSWAITINGTORECEIVE ), XTICKSTOWAIT );

                PRVUNLOCKQUEUE( PXQUEUE );



                IF( XTASKRESUMEALL() == PDFALSE )

                {

                    PORTYIELD_WITHIN_API();

                }

                ELSE

                {

                    MTCOVERAGE_TEST_MARKER();

                }

            }

            ELSE

            {

                /* THE QUEUE CONTAINS DATA AGAIN.  LOOP BACK TO TRY AND READ THE

                 * DATA. */

                PRVUNLOCKQUEUE( PXQUEUE );

                ( VOID ) XTASKRESUMEALL();

            }

        }

        ELSE

        {

            /* TIMED OUT.  IF THERE IS NO DATA IN THE QUEUE EXIT, OTHERWISE LOOP

             * BACK AND ATTEMPT TO READ THE DATA. */

            PRVUNLOCKQUEUE( PXQUEUE );

            ( VOID ) XTASKRESUMEALL();



            IF( PRVISQUEUEEMPTY( PXQUEUE ) != PDFALSE )

            {

                TRACEQUEUE_RECEIVE_FAILED( PXQUEUE );

                RETURN ERRQUEUE_EMPTY;

            }

            ELSE

            {

                MTCOVERAGE_TEST_MARKER();

            }

        }

    } /*LINT -RESTORE */

}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 492694_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VTE_SEQUENCE_HANDLER_SR (VTETERMINAL *TERMINAL, GVALUEARRAY *PARAMS)
{
	LONG START, END;
	VTESCREEN *SCREEN;

	SCREEN = TERMINAL->PVT->SCREEN;

	IF (SCREEN->SCROLLING_RESTRICTED) {
		START = SCREEN->SCROLLING_REGION.START + SCREEN->INSERT_DELTA;
		END = SCREEN->SCROLLING_REGION.END + SCREEN->INSERT_DELTA;
	} ELSE {
		START = TERMINAL->PVT->SCREEN->INSERT_DELTA;
		END = START + TERMINAL->ROW_COUNT - 1;
	}

	IF (SCREEN->CURSOR_CURRENT.ROW == START) {
		/* IF WE'RE AT THE TOP OF THE SCROLLING REGION, ADD A
		 * LINE AT THE TOP TO SCROLL THE BOTTOM OFF. */
		_VTE_TERMINAL_RING_REMOVE (TERMINAL, END);
		_VTE_TERMINAL_RING_INSERT (TERMINAL, START, TRUE);
		/* UPDATE THE DISPLAY. */
		_VTE_TERMINAL_SCROLL_REGION(TERMINAL, START, END - START + 1, 1);
		_VTE_INVALIDATE_CELLS(TERMINAL,
				      0, TERMINAL->COLUMN_COUNT,
				      START, 2);
	} ELSE {
		/* OTHERWISE, JUST MOVE THE CURSOR UP. */
		SCREEN->CURSOR_CURRENT.ROW--;
	}
	/* ADJUST THE SCROLLBARS IF NECESSARY. */
	_VTE_TERMINAL_ADJUST_ADJUSTMENTS(TERMINAL);
	/* WE MODIFIED THE DISPLAY, SO MAKE A NOTE OF IT. */
	TERMINAL->PVT->TEXT_MODIFIED_FLAG = TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 379702_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API UT64 R_ANAL_VAR_ADDR(RANALVAR *VAR) {
	R_RETURN_VAL_IF_FAIL (VAR, UT64_MAX);
	RANAL *ANAL = VAR->FCN->ANAL;
	CONST CHAR *REGNAME = NULL;
	IF (VAR->KIND == R_ANAL_VAR_KIND_BPV) {
		REGNAME = R_REG_GET_NAME (ANAL->REG, R_REG_NAME_BP);
		RETURN R_REG_GETV (ANAL->REG, REGNAME) + VAR->DELTA + VAR->FCN->BP_OFF;
	} ELSE IF (VAR->KIND == R_ANAL_VAR_KIND_SPV) {
		REGNAME = R_REG_GET_NAME (ANAL->REG, R_REG_NAME_SP);
		RETURN R_REG_GETV (ANAL->REG, REGNAME) + VAR->DELTA;
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215264_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SSIZE_T
S_STUDY_CHUNK(PTHX_ REXC_STATE_T *PREXC_STATE, REGNODE **SCANP,
                        SSIZE_T *MINLENP, SSIZE_T *DELTAP,
			REGNODE *LAST,
			SCAN_DATA_T *DATA,
			I32 STOPPAREN,
                        U32 RECURSED_DEPTH,
			REGNODE_SSC *AND_WITHP,
			U32 FLAGS, U32 DEPTH)
			/* SCANP: START HERE (READ-WRITE). */
			/* DELTAP: WRITE MAXLEN-MINLEN HERE. */
			/* LAST: STOP BEFORE THIS ONE. */
			/* DATA: STRING DATA ABOUT THE PATTERN */
			/* STOPPAREN: TREAT CLOSE N AS END */
			/* RECURSED: WHICH SUBROUTINES HAVE WE RECURSED INTO */
			/* AND_WITHP: VALID IF FLAGS & SCF_DO_STCLASS_OR */
{
    DVAR;
    /* THERE MUST BE AT LEAST THIS NUMBER OF CHARACTERS TO MATCH */
    SSIZE_T MIN = 0;
    I32 PARS = 0, CODE;
    REGNODE *SCAN = *SCANP, *NEXT;
    SSIZE_T DELTA = 0;
    INT IS_INF = (FLAGS & SCF_DO_SUBSTR) && (DATA->FLAGS & SF_IS_INF);
    INT IS_INF_INTERNAL = 0;		/* THE STUDIED CHUNK IS INFINITE */
    I32 IS_PAR = OP(SCAN) == OPEN ? ARG(SCAN) : 0;
    SCAN_DATA_T DATA_FAKE;
    SV *RE_TRIE_MAXBUFF = NULL;
    REGNODE *FIRST_NON_OPEN = SCAN;
    SSIZE_T STOPMIN = SSIZE_T_MAX;
    SCAN_FRAME *FRAME = NULL;
    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_STUDY_CHUNK;
    REXC_STUDY_STARTED= 1;

    ZERO(&DATA_FAKE, 1, SCAN_DATA_T);

    IF ( DEPTH == 0 ) {
        WHILE (FIRST_NON_OPEN && OP(FIRST_NON_OPEN) == OPEN)
            FIRST_NON_OPEN=REGNEXT(FIRST_NON_OPEN);
    }


  FAKE_STUDY_RECURSE:
    DEBUG_R(
        REXC_STUDY_CHUNK_RECURSED_COUNT++;
    );
    DEBUG_OPTIMISE_MORE_R(
    {
        PERL_RE_INDENTF( ATHX_  "STUDY_CHUNK STOPPAREN=%LD RECURSED_COUNT=%LU DEPTH=%LU RECURSED_DEPTH=%LU SCAN=%P LAST=%P",
            DEPTH, (LONG)STOPPAREN,
            (UNSIGNED LONG)REXC_STUDY_CHUNK_RECURSED_COUNT,
            (UNSIGNED LONG)DEPTH, (UNSIGNED LONG)RECURSED_DEPTH,
            SCAN,
            LAST);
        IF (RECURSED_DEPTH) {
            U32 I;
            U32 J;
            FOR ( J = 0 ; J < RECURSED_DEPTH ; J++ ) {
                FOR ( I = 0 ; I < (U32)REXC_TOTAL_PARENS ; I++ ) {
                    IF (
                        PAREN_TEST(REXC_STUDY_CHUNK_RECURSED +
                                   ( J * REXC_STUDY_CHUNK_RECURSED_BYTES), I )
                        && (
                            !J ||
                            !PAREN_TEST(REXC_STUDY_CHUNK_RECURSED +
                                   (( J - 1 ) * REXC_STUDY_CHUNK_RECURSED_BYTES), I)
                        )
                    ) {
                        PERL_RE_PRINTF( ATHX_ " %D",(INT)I);
                        BREAK;
                    }
                }
                IF ( J + 1 < RECURSED_DEPTH ) {
                    PERL_RE_PRINTF( ATHX_  ",");
                }
            }
        }
        PERL_RE_PRINTF( ATHX_ "\N");
    }
    );
    WHILE ( SCAN && OP(SCAN) != END && SCAN < LAST ){
        UV MIN_SUBTRACT = 0;    /* HOW MMANY CHARS TO SUBTRACT FROM THE MINIMUM
                                   NODE LENGTH TO GET A REAL MINIMUM (BECAUSE
                                   THE FOLDED VERSION MAY BE SHORTER) */
	BOOL UNFOLDED_MULTI_CHAR = FALSE;
	/* PEEPHOLE OPTIMIZER: */
        DEBUG_STUDYDATA("PEEP", DATA, DEPTH, IS_INF);
        DEBUG_PEEP("PEEP", SCAN, DEPTH, FLAGS);


        /* THE REASON WE DO THIS HERE IS THAT WE NEED TO DEAL WITH THINGS LIKE
         * /(?:F)(?:O)(?:O)/ WHICH CANT BE DEALT WITH BY THE NORMAL EXACT
         * PARSING CODE, AS EACH (?:..) IS HANDLED BY A DIFFERENT INVOCATION OF
         * REG() -- YVES
         */
        JOIN_EXACT(SCAN,&MIN_SUBTRACT, &UNFOLDED_MULTI_CHAR, 0);

        /* FOLLOW THE NEXT-CHAIN OF THE CURRENT NODE AND OPTIMIZE
           AWAY ALL THE NOTHINGS FROM IT.
         */
        RCK_ELIDE_NOTHING(SCAN);

	/* THE PRINCIPAL PSEUDO-SWITCH.  CANNOT BE A SWITCH, SINCE WE
	   LOOK INTO SEVERAL DIFFERENT THINGS.  */
        IF ( OP(SCAN) == DEFINEP ) {
            SSIZE_T MINLEN = 0;
            SSIZE_T DELTANEXT = 0;
            SSIZE_T FAKE_LAST_CLOSE = 0;
            I32 F = SCF_IN_DEFINE;

            STRUCTCOPY(&ZERO_SCAN_DATA, &DATA_FAKE, SCAN_DATA_T);
            SCAN = REGNEXT(SCAN);
            ASSERT( OP(SCAN) == IFTHEN );
            DEBUG_PEEP("EXPECT IFTHEN", SCAN, DEPTH, FLAGS);

            DATA_FAKE.LAST_CLOSEP= &FAKE_LAST_CLOSE;
            MINLEN = *MINLENP;
            NEXT = REGNEXT(SCAN);
            SCAN = NEXTOPER(NEXTOPER(SCAN));
            DEBUG_PEEP("SCAN", SCAN, DEPTH, FLAGS);
            DEBUG_PEEP("NEXT", NEXT, DEPTH, FLAGS);

            /* WE SUPPOSE THE RUN IS CONTINUOUS, LAST=NEXT...
             * NOTE WE DONT USE THE RETURN HERE! */
            /* DEFINEP STUDY_CHUNK() RECURSION */
            (VOID)STUDY_CHUNK(PREXC_STATE, &SCAN, &MINLEN,
                              &DELTANEXT, NEXT, &DATA_FAKE, STOPPAREN,
                              RECURSED_DEPTH, NULL, F, DEPTH+1);

            SCAN = NEXT;
        } ELSE
        IF (
            OP(SCAN) == BRANCH  ||
            OP(SCAN) == BRANCHJ ||
            OP(SCAN) == IFTHEN
        ) {
	    NEXT = REGNEXT(SCAN);
	    CODE = OP(SCAN);

            /* THE OP(NEXT)==CODE CHECK BELOW IS TO SEE IF WE
             * HAVE "BRANCH-BRANCH", "BRANCHJ-BRANCHJ", "IFTHEN-IFTHEN"
             * IFTHEN IS SPECIAL AS IT MIGHT NOT APPEAR IN PAIRS.
             * NOT SURE WHETHER BRANCH-BRANCHJ IS POSSIBLE, REGARDLESS
             * WE DONT HANDLE IT CLEANLY. */
	    IF (OP(NEXT) == CODE || CODE == IFTHEN) {
                /* NOTE - THERE IS SIMILAR CODE TO THIS BLOCK BELOW FOR
                 * HANDLING TRIE NODES ON A RE-STUDY.  IF YOU CHANGE STUFF HERE
                 * CHECK THERE TOO. */
		SSIZE_T MAX1 = 0, MIN1 = SSIZE_T_MAX, NUM = 0;
		REGNODE_SSC ACCUM;
		REGNODE * CONST STARTBRANCH=SCAN;

                IF (FLAGS & SCF_DO_SUBSTR) {
                    /* CANNOT MERGE STRINGS AFTER THIS. */
                    SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
                }

                IF (FLAGS & SCF_DO_STCLASS)
		    SSC_INIT_ZERO(PREXC_STATE, &ACCUM);

		WHILE (OP(SCAN) == CODE) {
		    SSIZE_T DELTANEXT, MINNEXT, FAKE;
		    I32 F = 0;
		    REGNODE_SSC THIS_CLASS;

                    DEBUG_PEEP("BRANCH", SCAN, DEPTH, FLAGS);

		    NUM++;
                    STRUCTCOPY(&ZERO_SCAN_DATA, &DATA_FAKE, SCAN_DATA_T);
		    IF (DATA) {
			DATA_FAKE.WHILEM_C = DATA->WHILEM_C;
			DATA_FAKE.LAST_CLOSEP = DATA->LAST_CLOSEP;
		    }
		    ELSE
			DATA_FAKE.LAST_CLOSEP = &FAKE;

		    DATA_FAKE.POS_DELTA = DELTA;
		    NEXT = REGNEXT(SCAN);

                    SCAN = NEXTOPER(SCAN); /* EVERYTHING */
                    IF (CODE != BRANCH)    /* EVERYTHING BUT BRANCH */
			SCAN = NEXTOPER(SCAN);

		    IF (FLAGS & SCF_DO_STCLASS) {
			SSC_INIT(PREXC_STATE, &THIS_CLASS);
			DATA_FAKE.START_CLASS = &THIS_CLASS;
			F = SCF_DO_STCLASS_AND;
		    }
		    IF (FLAGS & SCF_WHILEM_VISITED_POS)
			F |= SCF_WHILEM_VISITED_POS;

		    /* WE SUPPOSE THE RUN IS CONTINUOUS, LAST=NEXT...*/
                    /* RECURSE STUDY_CHUNK() FOR EACH BRANCH IN AN ALTERNATION */
		    MINNEXT = STUDY_CHUNK(PREXC_STATE, &SCAN, MINLENP,
                                      &DELTANEXT, NEXT, &DATA_FAKE, STOPPAREN,
                                      RECURSED_DEPTH, NULL, F, DEPTH+1);

		    IF (MIN1 > MINNEXT)
			MIN1 = MINNEXT;
		    IF (DELTANEXT == SSIZE_T_MAX) {
			IS_INF = IS_INF_INTERNAL = 1;
			MAX1 = SSIZE_T_MAX;
		    } ELSE IF (MAX1 < MINNEXT + DELTANEXT)
			MAX1 = MINNEXT + DELTANEXT;
		    SCAN = NEXT;
		    IF (DATA_FAKE.FLAGS & (SF_HAS_PAR|SF_IN_PAR))
			PARS++;
	            IF (DATA_FAKE.FLAGS & SCF_SEEN_ACCEPT) {
	                IF ( STOPMIN > MINNEXT)
	                    STOPMIN = MIN + MIN1;
	                FLAGS &= ~SCF_DO_SUBSTR;
	                IF (DATA)
	                    DATA->FLAGS |= SCF_SEEN_ACCEPT;
	            }
		    IF (DATA) {
			IF (DATA_FAKE.FLAGS & SF_HAS_EVAL)
			    DATA->FLAGS |= SF_HAS_EVAL;
			DATA->WHILEM_C = DATA_FAKE.WHILEM_C;
		    }
		    IF (FLAGS & SCF_DO_STCLASS)
			SSC_OR(PREXC_STATE, &ACCUM, (REGNODE_CHARCLASS*)&THIS_CLASS);
		}
		IF (CODE == IFTHEN && NUM < 2) /* EMPTY ELSE BRANCH */
		    MIN1 = 0;
		IF (FLAGS & SCF_DO_SUBSTR) {
		    DATA->POS_MIN += MIN1;
		    IF (DATA->POS_DELTA >= SSIZE_T_MAX - (MAX1 - MIN1))
		        DATA->POS_DELTA = SSIZE_T_MAX;
		    ELSE
		        DATA->POS_DELTA += MAX1 - MIN1;
		    IF (MAX1 != MIN1 || IS_INF)
			DATA->CUR_IS_FLOATING = 1;
		}
		MIN += MIN1;
		IF (DELTA == SSIZE_T_MAX
		 || SSIZE_T_MAX - DELTA - (MAX1 - MIN1) < 0)
		    DELTA = SSIZE_T_MAX;
		ELSE
		    DELTA += MAX1 - MIN1;
		IF (FLAGS & SCF_DO_STCLASS_OR) {
		    SSC_OR(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS*) &ACCUM);
		    IF (MIN1) {
			SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);
			FLAGS &= ~SCF_DO_STCLASS;
		    }
		}
		ELSE IF (FLAGS & SCF_DO_STCLASS_AND) {
		    IF (MIN1) {
			SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &ACCUM);
			FLAGS &= ~SCF_DO_STCLASS;
		    }
		    ELSE {
			/* SWITCH TO OR MODE: CACHE THE OLD VALUE OF
			 * DATA->START_CLASS */
			INIT_AND_WITHP;
			STRUCTCOPY(DATA->START_CLASS, AND_WITHP, REGNODE_SSC);
			FLAGS &= ~SCF_DO_STCLASS_AND;
			STRUCTCOPY(&ACCUM, DATA->START_CLASS, REGNODE_SSC);
			FLAGS |= SCF_DO_STCLASS_OR;
		    }
		}

                IF (PERL_ENABLE_TRIE_OPTIMISATION &&
                        OP( STARTBRANCH ) == BRANCH )
                {
		/* DEMQ.

                   ASSUMING THIS WAS/IS A BRANCH WE ARE DEALING WITH: 'SCAN'
                   NOW POINTS AT THE ITEM THAT FOLLOWS THE BRANCH SEQUENCE,
                   WHATEVER IT IS. WE NOW START AT THE BEGINNING OF THE
                   SEQUENCE AND LOOK FOR SUBSEQUENCES OF

		   BRANCH->EXACT=>X1
		   BRANCH->EXACT=>X2
		   TAIL

                   WHICH WOULD BE CONSTRUCTED FROM A PATTERN LIKE
                   /A|LIST|OF|WORDS/

		   IF WE CAN FIND SUCH A SUBSEQUENCE WE NEED TO TURN THE FIRST
		   ELEMENT INTO A TRIE AND THEN ADD THE SUBSEQUENT BRANCH EXACT
		   STRINGS TO THE TRIE.

		   WE HAVE TWO CASES

                     1. PATTERNS WHERE THE WHOLE SET OF BRANCHES CAN BE
                        CONVERTED.

		     2. PATTERNS WHERE ONLY A SUBSET CAN BE CONVERTED.

		   IN CASE 1 WE CAN REPLACE THE WHOLE SET WITH A SINGLE REGOP
		   FOR THE TRIE. IN CASE 2 WE NEED TO KEEP THE START AND END
		   BRANCHES SO

		     'BRANCH EXACT; BRANCH EXACT; BRANCH X'
		     BECOMES BRANCH TRIE; BRANCH X;

		  THERE IS AN ADDITIONAL CASE, THAT BEING WHERE THERE IS A
		  COMMON PREFIX, WHICH GETS SPLIT OUT INTO AN EXACT LIKE NODE
		  PRECEDING THE TRIE NODE.

		  IF X(1..N)==TAIL THEN WE CAN DO A SIMPLE TRIE, IF NOT WE MAKE
		  A "JUMP" TRIE, SUCH THAT WHEN WE MATCH THE APPROPRIATE WORD
		  WE "JUMP" TO THE APPROPRIATE TAIL NODE. ESSENTIALLY WE TURN
		  A NESTED IF INTO A CASE STRUCTURE OF SORTS.

		*/

		    INT MADE=0;
		    IF (!RE_TRIE_MAXBUFF) {
			RE_TRIE_MAXBUFF = GET_SV(RE_TRIE_MAXBUF_NAME, 1);
			IF (!SVIOK(RE_TRIE_MAXBUFF))
			    SV_SETIV(RE_TRIE_MAXBUFF, RE_TRIE_MAXBUF_INIT);
		    }
                    IF ( SVIV(RE_TRIE_MAXBUFF)>=0  ) {
                        REGNODE *CUR;
                        REGNODE *FIRST = (REGNODE *)NULL;
                        REGNODE *LAST = (REGNODE *)NULL;
                        REGNODE *TAIL = SCAN;
                        U8 TRIETYPE = 0;
                        U32 COUNT=0;

                        /* VAR TAIL IS USED BECAUSE THERE MAY BE A TAIL
                           REGOP IN THE WAY. IE, THE EXACTS WILL POINT TO THE
                           THING FOLLOWING THE TAIL, BUT THE LAST BRANCH WILL
                           POINT AT THE TAIL. SO WE ADVANCE TAIL. IF WE
                           HAVE NESTED (?:) WE MAY HAVE TO MOVE THROUGH SEVERAL
                           TAILS.
                         */

                        WHILE ( OP( TAIL ) == TAIL ) {
                            /* THIS IS THE TAIL GENERATED BY (?:) */
                            TAIL = REGNEXT( TAIL );
                        }


                        DEBUG_TRIE_COMPILE_R({
                            REGPROP(REXC_RX, REXC_MYSV, TAIL, NULL, PREXC_STATE);
                            PERL_RE_INDENTF( ATHX_  "%S %" UVUF ":%S\N",
                              DEPTH+1,
                              "LOOKING FOR TRIE'ABLE SEQUENCES. TAIL NODE IS ",
                              (UV) REGNODE_OFFSET(TAIL),
                              SVPV_NOLEN_CONST( REXC_MYSV )
                            );
                        });

                        /*

                            STEP THROUGH THE BRANCHES
                                CUR REPRESENTS EACH BRANCH,
                                NOPER IS THE FIRST THING TO BE MATCHED AS PART
                                      OF THAT BRANCH
                                NOPER_NEXT IS THE REGNEXT() OF THAT NODE.

                            WE NORMALLY HANDLE A CASE LIKE THIS
                            /FOO[XYZ]|BAR[PQR]/ VIA A "JUMP TRIE" BUT WE ALSO
                            SUPPORT BUILDING WITH NOJUMPTRIE, WHICH RESTRICTS
                            THE TRIE LOGIC TO STRUCTURES LIKE /FOO|BAR/.

                            IF NOPER IS A TRIEABLE NODETYPE THEN THE BRANCH IS
                            A POSSIBLE OPTIMIZATION TARGET. IF WE ARE BUILDING
                            UNDER NOJUMPTRIE THEN WE REQUIRE THAT NOPER_NEXT IS
                            THE SAME AS SCAN (OUR CURRENT POSITION IN THE REGEX
                            PROGRAM).

                            ONCE WE HAVE TWO OR MORE CONSECUTIVE SUCH BRANCHES
                            WE CAN CREATE A TRIE OF THE EXACT'S CONTENTS AND
                            STITCH IT IN PLACE INTO THE PROGRAM.

                            IF THE SEQUENCE REPRESENTS ALL OF THE BRANCHES IN
                            THE ALTERNATION WE REPLACE THE ENTIRE THING WITH A
                            SINGLE TRIE NODE.

                            OTHERWISE WHEN IT IS A SUBSEQUENCE WE NEED TO
                            STITCH IT IN PLACE AND REPLACE ONLY THE RELEVANT
                            BRANCHES. THIS MEANS THE FIRST BRANCH HAS TO REMAIN
                            AS IT IS USED BY THE ALTERNATION LOGIC, AND ITS
                            NEXT POINTER, AND NEEDS TO BE REPOINTED AT THE ITEM
                            ON THE BRANCH CHAIN FOLLOWING THE LAST BRANCH WE
                            HAVE OPTIMIZED AWAY.

                            THIS COULD BE EITHER A BRANCH, IN WHICH CASE THE
                            SUBSEQUENCE IS INTERNAL, OR IT COULD BE THE ITEM
                            FOLLOWING THE BRANCH SEQUENCE IN WHICH CASE THE
                            SUBSEQUENCE IS AT THE END (WHICH DOES NOT
                            NECESSARILY MEAN THE FIRST NODE IS THE START OF THE
                            ALTERNATION).

                            TRIE_TYPE(X) IS A DEFINE WHICH MAPS THE OPTYPE TO A
                            TRIETYPE.

                                OPTYPE          |  TRIETYPE
                                ----------------+-----------
                                NOTHING         | NOTHING
                                EXACT           | EXACT
                                EXACT_ONLY8     | EXACT
                                EXACTFU         | EXACTFU
                                EXACTFU_ONLY8   | EXACTFU
                                EXACTFUP        | EXACTFU
                                EXACTFAA        | EXACTFAA
                                EXACTL          | EXACTL
                                EXACTFLU8       | EXACTFLU8


                        */
#DEFINE TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \
                       ? NOTHING                                            \
                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \
                         ? EXACT                                            \
                         : (     EXACTFU == (X)                             \
                              || EXACTFU_ONLY8 == (X)                       \
                              || EXACTFUP == (X) )                          \
                           ? EXACTFU                                        \
                           : ( EXACTFAA == (X) )                            \
                             ? EXACTFAA                                     \
                             : ( EXACTL == (X) )                            \
                               ? EXACTL                                     \
                               : ( EXACTFLU8 == (X) )                       \
                                 ? EXACTFLU8                                \
                                 : 0 )

                        /* DONT USE TAIL AS THE END MARKER FOR THIS TRAVERSE */
                        FOR ( CUR = STARTBRANCH ; CUR != SCAN ; CUR = REGNEXT( CUR ) ) {
                            REGNODE * CONST NOPER = NEXTOPER( CUR );
                            U8 NOPER_TYPE = OP( NOPER );
                            U8 NOPER_TRIETYPE = TRIE_TYPE( NOPER_TYPE );
#IF DEFINED(DEBUGGING) || DEFINED(NOJUMPTRIE)
                            REGNODE * CONST NOPER_NEXT = REGNEXT( NOPER );
                            U8 NOPER_NEXT_TYPE = (NOPER_NEXT && NOPER_NEXT < TAIL) ? OP(NOPER_NEXT) : 0;
                            U8 NOPER_NEXT_TRIETYPE = (NOPER_NEXT && NOPER_NEXT < TAIL) ? TRIE_TYPE( NOPER_NEXT_TYPE ) :0;
#ENDIF

                            DEBUG_TRIE_COMPILE_R({
                                REGPROP(REXC_RX, REXC_MYSV, CUR, NULL, PREXC_STATE);
                                PERL_RE_INDENTF( ATHX_  "- %D:%S (%D)",
                                   DEPTH+1,
                                   REG_NODE_NUM(CUR), SVPV_NOLEN_CONST( REXC_MYSV ), REG_NODE_NUM(CUR) );

                                REGPROP(REXC_RX, REXC_MYSV, NOPER, NULL, PREXC_STATE);
                                PERL_RE_PRINTF( ATHX_  " -> %D:%S",
                                    REG_NODE_NUM(NOPER), SVPV_NOLEN_CONST(REXC_MYSV));

                                IF ( NOPER_NEXT ) {
                                  REGPROP(REXC_RX, REXC_MYSV, NOPER_NEXT, NULL, PREXC_STATE);
                                  PERL_RE_PRINTF( ATHX_ "\T=> %D:%S\T",
                                    REG_NODE_NUM(NOPER_NEXT), SVPV_NOLEN_CONST(REXC_MYSV));
                                }
                                PERL_RE_PRINTF( ATHX_  "(FIRST==%D,LAST==%D,CUR==%D,TT==%S,NTT==%S,NNTT==%S)\N",
                                   REG_NODE_NUM(FIRST), REG_NODE_NUM(LAST), REG_NODE_NUM(CUR),
				   PL_REG_NAME[TRIETYPE], PL_REG_NAME[NOPER_TRIETYPE], PL_REG_NAME[NOPER_NEXT_TRIETYPE]
				);
                            });

                            /* IS NOPER A TRIEABLE NODETYPE THAT CAN BE MERGED
                             * WITH THE CURRENT TRIE (IF THERE IS ONE)? */
                            IF ( NOPER_TRIETYPE
                                  &&
                                  (
                                        ( NOPER_TRIETYPE == NOTHING )
                                        || ( TRIETYPE == NOTHING )
                                        || ( TRIETYPE == NOPER_TRIETYPE )
                                  )
#IFDEF NOJUMPTRIE
                                  && NOPER_NEXT >= TAIL
#ENDIF
                                  && COUNT < U16_MAX)
                            {
                                /* HANDLE MERGABLE TRIABLE NODE EITHER WE ARE
                                 * THE FIRST NODE IN A NEW TRIEABLE SEQUENCE,
                                 * IN WHICH CASE WE DO SOME BOOKKEEPING,
                                 * OTHERWISE WE UPDATE THE END POINTER. */
                                IF ( !FIRST ) {
                                    FIRST = CUR;
				    IF ( NOPER_TRIETYPE == NOTHING ) {
#IF !DEFINED(DEBUGGING) && !DEFINED(NOJUMPTRIE)
					REGNODE * CONST NOPER_NEXT = REGNEXT( NOPER );
                                        U8 NOPER_NEXT_TYPE = (NOPER_NEXT && NOPER_NEXT < TAIL) ? OP(NOPER_NEXT) : 0;
					U8 NOPER_NEXT_TRIETYPE = NOPER_NEXT_TYPE ? TRIE_TYPE( NOPER_NEXT_TYPE ) :0;
#ENDIF

                                        IF ( NOPER_NEXT_TRIETYPE ) {
					    TRIETYPE = NOPER_NEXT_TRIETYPE;
                                        } ELSE IF (NOPER_NEXT_TYPE)  {
                                            /* A NOTHING REGOP IS 1 REGOP WIDE.
                                             * WE NEED AT LEAST TWO FOR A TRIE
                                             * SO WE CAN'T MERGE THIS IN */
                                            FIRST = NULL;
                                        }
                                    } ELSE {
                                        TRIETYPE = NOPER_TRIETYPE;
                                    }
                                } ELSE {
                                    IF ( TRIETYPE == NOTHING )
                                        TRIETYPE = NOPER_TRIETYPE;
                                    LAST = CUR;
                                }
				IF (FIRST)
				    COUNT++;
                            } /* END HANDLE MERGABLE TRIABLE NODE */
                            ELSE {
                                /* HANDLE UNMERGABLE NODE -
                                 * NOPER MAY EITHER BE A TRIABLE NODE WHICH CAN
                                 * NOT BE TRIED TOGETHER WITH THE CURRENT TRIE,
                                 * OR A NON TRIABLE NODE */
                                IF ( LAST ) {
                                    /* IF LAST IS SET AND TRIETYPE IS NOT
                                     * NOTHING THEN WE HAVE FOUND AT LEAST TWO
                                     * TRIABLE BRANCH SEQUENCES IN A ROW OF A
                                     * SIMILAR TRIETYPE SO WE CAN TURN THEM
                                     * INTO A TRIE. IF/WHEN WE ALLOW NOTHING TO
                                     * START A TRIE SEQUENCE THIS CONDITION
                                     * WILL BE REQUIRED, AND IT ISN'T EXPENSIVE
                                     * SO WE LEAVE IT IN FOR NOW. */
                                    IF ( TRIETYPE && TRIETYPE != NOTHING )
                                        MAKE_TRIE( PREXC_STATE,
                                                STARTBRANCH, FIRST, CUR, TAIL,
                                                COUNT, TRIETYPE, DEPTH+1 );
                                    LAST = NULL; /* NOTE: WE CLEAR/UPDATE
                                                    FIRST, TRIETYPE ETC BELOW,
                                                    SO WE DONT DO IT HERE */
                                }
                                IF ( NOPER_TRIETYPE
#IFDEF NOJUMPTRIE
                                     && NOPER_NEXT >= TAIL
#ENDIF
                                ){
                                    /* NOPER IS TRIABLE, SO WE CAN START A NEW
                                     * TRIE SEQUENCE */
                                    COUNT = 1;
                                    FIRST = CUR;
                                    TRIETYPE = NOPER_TRIETYPE;
                                } ELSE IF (FIRST) {
                                    /* IF WE ALREADY SAW A FIRST BUT THE
                                     * CURRENT NODE IS NOT TRIABLE THEN WE HAVE
                                     * TO RESET THE FIRST INFORMATION. */
                                    COUNT = 0;
                                    FIRST = NULL;
                                    TRIETYPE = 0;
                                }
                            } /* END HANDLE UNMERGABLE NODE */
                        } /* LOOP OVER BRANCHES */
                        DEBUG_TRIE_COMPILE_R({
                            REGPROP(REXC_RX, REXC_MYSV, CUR, NULL, PREXC_STATE);
                            PERL_RE_INDENTF( ATHX_  "- %S (%D) <SCAN FINISHED> ",
                              DEPTH+1, SVPV_NOLEN_CONST( REXC_MYSV ), REG_NODE_NUM(CUR));
                            PERL_RE_PRINTF( ATHX_  "(FIRST==%D, LAST==%D, CUR==%D, TT==%S)\N",
                               REG_NODE_NUM(FIRST), REG_NODE_NUM(LAST), REG_NODE_NUM(CUR),
                               PL_REG_NAME[TRIETYPE]
                            );

                        });
                        IF ( LAST && TRIETYPE ) {
                            IF ( TRIETYPE != NOTHING ) {
                                /* THE LAST BRANCH OF THE SEQUENCE WAS PART OF
                                 * A TRIE, SO WE HAVE TO CONSTRUCT IT HERE
                                 * OUTSIDE OF THE LOOP */
                                MADE= MAKE_TRIE( PREXC_STATE, STARTBRANCH,
                                                 FIRST, SCAN, TAIL, COUNT,
                                                 TRIETYPE, DEPTH+1 );
#IFDEF TRIE_STUDY_OPT
                                IF ( ((MADE == MADE_EXACT_TRIE &&
                                     STARTBRANCH == FIRST)
                                     || ( FIRST_NON_OPEN == FIRST )) &&
                                     DEPTH==0 ) {
                                    FLAGS |= SCF_TRIE_RESTUDY;
                                    IF ( STARTBRANCH == FIRST
                                         && SCAN >= TAIL )
                                    {
                                        REXC_SEEN &=~REG_TOP_LEVEL_BRANCHES_SEEN;
                                    }
                                }
#ENDIF
                            } ELSE {
                                /* AT THIS POINT WE KNOW WHATEVER WE HAVE IS A
                                 * NOTHING SEQUENCE/BRANCH AND IF 'STARTBRANCH'
                                 * IS 'FIRST' THEN WE CAN TURN THE WHOLE THING
                                 * INTO A NOTHING
                                 */
                                IF ( STARTBRANCH == FIRST ) {
                                    REGNODE *OPT;
                                    /* THE ENTIRE THING IS A NOTHING SEQUENCE,
                                     * SOMETHING LIKE THIS: (?:|) SO WE CAN
                                     * TURN IT INTO A PLAIN NOTHING OP. */
                                    DEBUG_TRIE_COMPILE_R({
                                        REGPROP(REXC_RX, REXC_MYSV, CUR, NULL, PREXC_STATE);
                                        PERL_RE_INDENTF( ATHX_  "- %S (%D) <NOTHING BRANCH SEQUENCE>\N",
                                          DEPTH+1,
                                          SVPV_NOLEN_CONST( REXC_MYSV ), REG_NODE_NUM(CUR));

                                    });
                                    OP(STARTBRANCH)= NOTHING;
                                    NEXT_OFF(STARTBRANCH)= TAIL - STARTBRANCH;
                                    FOR ( OPT= STARTBRANCH + 1; OPT < TAIL ; OPT++ )
                                        OP(OPT)= OPTIMIZED;
                                }
                            }
                        } /* END IF ( LAST) */
                    } /* TRIE_MAXBUF IS NON ZERO */

                } /* DO TRIE */

	    }
	    ELSE IF ( CODE == BRANCHJ ) {  /* SINGLE BRANCH IS OPTIMIZED. */
		SCAN = NEXTOPER(NEXTOPER(SCAN));
	    } ELSE			/* SINGLE BRANCH IS OPTIMIZED. */
		SCAN = NEXTOPER(SCAN);
	    CONTINUE;
        } ELSE IF (OP(SCAN) == SUSPEND || OP(SCAN) == GOSUB) {
            I32 PAREN = 0;
            REGNODE *START = NULL;
            REGNODE *END = NULL;
            U32 MY_RECURSED_DEPTH= RECURSED_DEPTH;

            IF (OP(SCAN) != SUSPEND) { /* GOSUB */
                /* DO SETUP, NOTE THIS CODE HAS SIDE EFFECTS BEYOND
                 * THE REST OF THIS BLOCK. SPECIFICALLY SETTING
                 * REXC_RECURSE[] MUST HAPPEN AT LEAST ONCE DURING
                 * STUDY_CHUNK(). */
                PAREN = ARG(SCAN);
                REXC_RECURSE[ARG2L(SCAN)] = SCAN;
                START = REGNODE_P(REXC_OPEN_PARENS[PAREN]);
                END   = REGNODE_P(REXC_CLOSE_PARENS[PAREN]);

                /* NOTE WE MUST ALWAYS EXECUTE THE ABOVE CODE, EVEN
                 * IF WE DO NOTHING WITH A GOSUB */
                IF (
                    ( FLAGS & SCF_IN_DEFINE )
                    ||
                    (
                        (IS_INF_INTERNAL || IS_INF || (DATA && DATA->FLAGS & SF_IS_INF))
                        &&
                        ( (FLAGS & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )
                    )
                ) {
                    /* NO NEED TO DO ANYTHING HERE IF WE ARE IN A DEFINE. */
                    /* OR WE ARE AFTER SOME KIND OF INFINITE CONSTRUCT
                     * SO WE CAN SKIP RECURSING INTO THIS ITEM.
                     * SINCE IT IS INFINITE WE WILL NOT CHANGE THE MAXLEN
                     * OR DELTA, AND IF WE MISS SOMETHING THAT MIGHT RAISE
                     * THE MINLEN IT WILL MERELY PESSIMISE A LITTLE.
                     *
                     * IOW /(?(DEFINE)(?<FOO>FOO|FOOD))A+(?&FOO)/
                     * MIGHT RESULT IN A MINLEN OF 1 AND NOT OF 4,
                     * BUT THIS DOESN'T MAKE US MISMATCH, JUST TRY A BIT
                     * HARDER THAN WE SHOULD.
                     * */
                    SCAN= REGNEXT(SCAN);
                    CONTINUE;
                }

                IF (
                    !RECURSED_DEPTH
                    ||
                    !PAREN_TEST(REXC_STUDY_CHUNK_RECURSED + ((RECURSED_DEPTH-1) * REXC_STUDY_CHUNK_RECURSED_BYTES), PAREN)
                ) {
                    /* IT IS QUITE POSSIBLE THAT THERE ARE MORE EFFICIENT WAYS
                     * TO DO THIS. WE MAINTAIN A BITMAP PER LEVEL OF RECURSION
                     * OF WHICH PATTERNS WE HAVE ENTERED SO WE CAN DETECT IF A
                     * PATTERN CREATES A POSSIBLE INFINITE LOOP. WHEN WE
                     * RECURSE DOWN A LEVEL WE COPY THE PREVIOUS LEVELS BITMAP
                     * DOWN. WHEN WE ARE AT RECURSION LEVEL 0 WE ZERO THE TOP
                     * LEVEL BITMAP. IT WOULD BE NICE TO IMPLEMENT A DIFFERENT
                     * MORE EFFICIENT WAY OF DOING THIS. IN PARTICULAR THE TOP
                     * LEVEL BITMAP MAY BE UNNECESSARY.
                     */
                    IF (!RECURSED_DEPTH) {
                        ZERO(REXC_STUDY_CHUNK_RECURSED, REXC_STUDY_CHUNK_RECURSED_BYTES, U8);
                    } ELSE {
                        COPY(REXC_STUDY_CHUNK_RECURSED + ((RECURSED_DEPTH-1) * REXC_STUDY_CHUNK_RECURSED_BYTES),
                             REXC_STUDY_CHUNK_RECURSED + (RECURSED_DEPTH * REXC_STUDY_CHUNK_RECURSED_BYTES),
                             REXC_STUDY_CHUNK_RECURSED_BYTES, U8);
                    }
                    /* WE HAVENT RECURSED INTO THIS PAREN YET, SO RECURSE INTO IT */
                    DEBUG_STUDYDATA("GOSUB-SET", DATA, DEPTH, IS_INF);
                    PAREN_SET(REXC_STUDY_CHUNK_RECURSED + (RECURSED_DEPTH * REXC_STUDY_CHUNK_RECURSED_BYTES), PAREN);
                    MY_RECURSED_DEPTH= RECURSED_DEPTH + 1;
                } ELSE {
                    DEBUG_STUDYDATA("GOSUB-INF", DATA, DEPTH, IS_INF);
                    /* SOME FORM OF INFINITE RECURSION, ASSUME INFINITE LENGTH
                     * */
                    IF (FLAGS & SCF_DO_SUBSTR) {
                        SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
                        DATA->CUR_IS_FLOATING = 1;
                    }
                    IS_INF = IS_INF_INTERNAL = 1;
                    IF (FLAGS & SCF_DO_STCLASS_OR) /* ALLOW EVERYTHING */
                        SSC_ANYTHING(DATA->START_CLASS);
                    FLAGS &= ~SCF_DO_STCLASS;

                    START= NULL; /* RESET START SO WE DONT RECURSE LATER ON. */
	        }
            } ELSE {
	        PAREN = STOPPAREN;
                START = SCAN + 2;
	        END = REGNEXT(SCAN);
	    }
            IF (START) {
                SCAN_FRAME *NEWFRAME;
                ASSERT(END);
                IF (!REXC_FRAME_LAST) {
                    NEWXZ(NEWFRAME, 1, SCAN_FRAME);
                    SAVEDESTRUCTOR_X(S_UNWIND_SCAN_FRAMES, NEWFRAME);
                    REXC_FRAME_HEAD= NEWFRAME;
                    REXC_FRAME_COUNT++;
                } ELSE IF (!REXC_FRAME_LAST->NEXT_FRAME) {
                    NEWXZ(NEWFRAME, 1, SCAN_FRAME);
                    REXC_FRAME_LAST->NEXT_FRAME= NEWFRAME;
                    NEWFRAME->PREV_FRAME= REXC_FRAME_LAST;
                    REXC_FRAME_COUNT++;
                } ELSE {
                    NEWFRAME= REXC_FRAME_LAST->NEXT_FRAME;
                }
                REXC_FRAME_LAST= NEWFRAME;

                NEWFRAME->NEXT_REGNODE = REGNEXT(SCAN);
                NEWFRAME->LAST_REGNODE = LAST;
                NEWFRAME->STOPPAREN = STOPPAREN;
                NEWFRAME->PREV_RECURSED_DEPTH = RECURSED_DEPTH;
                NEWFRAME->THIS_PREV_FRAME= FRAME;

                DEBUG_STUDYDATA("FRAME-NEW", DATA, DEPTH, IS_INF);
                DEBUG_PEEP("FNEW", SCAN, DEPTH, FLAGS);

	        FRAME = NEWFRAME;
	        SCAN =  START;
	        STOPPAREN = PAREN;
	        LAST = END;
                DEPTH = DEPTH + 1;
                RECURSED_DEPTH= MY_RECURSED_DEPTH;

	        CONTINUE;
	    }
	}
	ELSE IF (   OP(SCAN) == EXACT
                 || OP(SCAN) == EXACT_ONLY8
                 || OP(SCAN) == EXACTL)
        {
	    SSIZE_T L = STR_LEN(SCAN);
	    UV UC;
            ASSERT(L);
	    IF (UTF) {
		CONST U8 * CONST S = (U8*)STRING(SCAN);
		UC = UTF8_TO_UVCHR_BUF(S, S + L, NULL);
		L = UTF8_LENGTH(S, S + L);
	    } ELSE {
		UC = *((U8*)STRING(SCAN));
	    }
	    MIN += L;
	    IF (FLAGS & SCF_DO_SUBSTR) { /* UPDATE LONGEST SUBSTR. */
		/* THE CODE BELOW PREFERS EARLIER MATCH FOR FIXED
		   OFFSET, LATER MATCH FOR VARIABLE OFFSET.  */
		IF (DATA->LAST_END == -1) { /* UPDATE THE START INFO. */
		    DATA->LAST_START_MIN = DATA->POS_MIN;
 		    DATA->LAST_START_MAX = IS_INF
 			? SSIZE_T_MAX : DATA->POS_MIN + DATA->POS_DELTA;
		}
		SV_CATPVN(DATA->LAST_FOUND, STRING(SCAN), STR_LEN(SCAN));
		IF (UTF)
		    SVUTF8_ON(DATA->LAST_FOUND);
		{
		    SV * CONST SV = DATA->LAST_FOUND;
		    MAGIC * CONST MG = SVUTF8(SV) && SVMAGICAL(SV) ?
			MG_FIND(SV, PERL_MAGIC_UTF8) : NULL;
		    IF (MG && MG->MG_LEN >= 0)
			MG->MG_LEN += UTF8_LENGTH((U8*)STRING(SCAN),
                                              (U8*)STRING(SCAN)+STR_LEN(SCAN));
		}
		DATA->LAST_END = DATA->POS_MIN + L;
		DATA->POS_MIN += L; /* AS IN THE FIRST ENTRY. */
		DATA->FLAGS &= ~SF_BEFORE_EOL;
	    }

            /* ANDING THE CODE POINT LEAVES AT MOST IT, AND NOT IN LOCALE, AND
             * CAN'T MATCH NULL STRING */
	    IF (FLAGS & SCF_DO_STCLASS_AND) {
                SSC_CP_AND(DATA->START_CLASS, UC);
                ANYOF_FLAGS(DATA->START_CLASS) &= ~SSC_MATCHES_EMPTY_STRING;
                SSC_CLEAR_LOCALE(DATA->START_CLASS);
	    }
	    ELSE IF (FLAGS & SCF_DO_STCLASS_OR) {
                SSC_ADD_CP(DATA->START_CLASS, UC);
		SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);

                /* SEE COMMIT MSG 749E076FCEEDEB708A624933726E7989F2302F6A */
                ANYOF_FLAGS(DATA->START_CLASS) &= ~SSC_MATCHES_EMPTY_STRING;
	    }
	    FLAGS &= ~SCF_DO_STCLASS;
	}
        ELSE IF (PL_REGKIND[OP(SCAN)] == EXACT) {
            /* BUT OP != EXACT!, SO IS EXACTFISH */
	    SSIZE_T L = STR_LEN(SCAN);
            CONST U8 * S = (U8*)STRING(SCAN);

	    /* SEARCH FOR FIXED SUBSTRINGS SUPPORTS EXACT ONLY. */
	    IF (FLAGS & SCF_DO_SUBSTR) {
		ASSERT(DATA);
                SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
	    }
	    IF (UTF) {
		L = UTF8_LENGTH(S, S + L);
	    }
	    IF (UNFOLDED_MULTI_CHAR) {
                REXC_SEEN |= REG_UNFOLDED_MULTI_SEEN;
	    }
	    MIN += L - MIN_SUBTRACT;
            ASSERT (MIN >= 0);
            DELTA += MIN_SUBTRACT;
	    IF (FLAGS & SCF_DO_SUBSTR) {
		DATA->POS_MIN += L - MIN_SUBTRACT;
		IF (DATA->POS_MIN < 0) {
                    DATA->POS_MIN = 0;
                }
                DATA->POS_DELTA += MIN_SUBTRACT;
		IF (MIN_SUBTRACT) {
		    DATA->CUR_IS_FLOATING = 1; /* FLOAT */
		}
	    }

            IF (FLAGS & SCF_DO_STCLASS) {
                SV* EXACTF_INVLIST = _MAKE_EXACTF_INVLIST(PREXC_STATE, SCAN);

                ASSERT(EXACTF_INVLIST);
                IF (FLAGS & SCF_DO_STCLASS_AND) {
                    IF (OP(SCAN) != EXACTFL)
                        SSC_CLEAR_LOCALE(DATA->START_CLASS);
                    ANYOF_FLAGS(DATA->START_CLASS) &= ~SSC_MATCHES_EMPTY_STRING;
                    ANYOF_POSIXL_ZERO(DATA->START_CLASS);
                    SSC_INTERSECTION(DATA->START_CLASS, EXACTF_INVLIST, FALSE);
                }
                ELSE {  /* SCF_DO_STCLASS_OR */
                    SSC_UNION(DATA->START_CLASS, EXACTF_INVLIST, FALSE);
                    SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);

                    /* SEE COMMIT MSG 749E076FCEEDEB708A624933726E7989F2302F6A */
                    ANYOF_FLAGS(DATA->START_CLASS) &= ~SSC_MATCHES_EMPTY_STRING;
                }
                FLAGS &= ~SCF_DO_STCLASS;
                SVREFCNT_DEC(EXACTF_INVLIST);
            }
	}
	ELSE IF (REGNODE_VARIES(OP(SCAN))) {
	    SSIZE_T MINCOUNT, MAXCOUNT, MINNEXT, DELTANEXT, POS_BEFORE = 0;
	    I32 FL = 0, F = FLAGS;
	    REGNODE * CONST OSCAN = SCAN;
	    REGNODE_SSC THIS_CLASS;
	    REGNODE_SSC *OCLASS = NULL;
	    I32 NEXT_IS_EVAL = 0;

	    SWITCH (PL_REGKIND[OP(SCAN)]) {
	    CASE WHILEM:		/* END OF (?:...)* . */
		SCAN = NEXTOPER(SCAN);
		GOTO FINISH;
	    CASE PLUS:
		IF (FLAGS & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {
		    NEXT = NEXTOPER(SCAN);
		    IF (   OP(NEXT) == EXACT
                        || OP(NEXT) == EXACT_ONLY8
                        || OP(NEXT) == EXACTL
                        || (FLAGS & SCF_DO_STCLASS))
                    {
			MINCOUNT = 1;
			MAXCOUNT = REG_INFTY;
			NEXT = REGNEXT(SCAN);
			SCAN = NEXTOPER(SCAN);
			GOTO DO_CURLY;
		    }
		}
		IF (FLAGS & SCF_DO_SUBSTR)
		    DATA->POS_MIN++;
		MIN++;
		/* FALLTHROUGH */
	    CASE STAR:
                NEXT = NEXTOPER(SCAN);

                /* THIS TEMPORARY NODE CAN NOW BE TURNED INTO EXACTFU, AND
                 * MUST, AS REGEXEC.C DOESN'T HANDLE IT */
                IF (OP(NEXT) == EXACTFU_S_EDGE) {
                    OP(NEXT) = EXACTFU;
                }

                IF (     STR_LEN(NEXT) == 1
                    &&   ISALPHA_A(* STRING(NEXT))
                    && (         OP(NEXT) == EXACTFAA
                        || (     OP(NEXT) == EXACTFU
                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(NEXT)))))
                {
                    /* THESE DIFFER IN JUST ONE BIT */
                    U8 MASK = ~ ('A' ^ 'A');

                    ASSERT(ISALPHA_A(* STRING(NEXT)));

                    /* THEN REPLACE IT BY AN ANYOFM NODE, WITH
                    * THE MASK SET TO THE COMPLEMENT OF THE
                    * BIT THAT DIFFERS BETWEEN UPPER AND LOWER
                    * CASE, AND THE LOWEST CODE POINT OF THE
                    * PAIR (WHICH THE '&' FORCES) */
                    OP(NEXT) = ANYOFM;
                    ARG_SET(NEXT, *STRING(NEXT) & MASK);
                    FLAGS(NEXT) = MASK;
                }

		IF (FLAGS & SCF_DO_STCLASS) {
		    MINCOUNT = 0;
		    MAXCOUNT = REG_INFTY;
		    NEXT = REGNEXT(SCAN);
		    SCAN = NEXTOPER(SCAN);
		    GOTO DO_CURLY;
		}
		IF (FLAGS & SCF_DO_SUBSTR) {
                    SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
                    /* CANNOT EXTEND FIXED SUBSTRINGS */
		    DATA->CUR_IS_FLOATING = 1; /* FLOAT */
		}
                IS_INF = IS_INF_INTERNAL = 1;
                SCAN = REGNEXT(SCAN);
		GOTO OPTIMIZE_CURLY_TAIL;
	    CASE CURLY:
	        IF (STOPPAREN>0 && (OP(SCAN)==CURLYN || OP(SCAN)==CURLYM)
	            && (SCAN->FLAGS == STOPPAREN))
		{
		    MINCOUNT = 1;
		    MAXCOUNT = 1;
		} ELSE {
		    MINCOUNT = ARG1(SCAN);
		    MAXCOUNT = ARG2(SCAN);
		}
		NEXT = REGNEXT(SCAN);
		IF (OP(SCAN) == CURLYX) {
		    I32 LP = (DATA ? *(DATA->LAST_CLOSEP) : 0);
		    SCAN->FLAGS = ((LP <= (I32)U8_MAX) ? (U8)LP : U8_MAX);
		}
		SCAN = NEXTOPER(SCAN) + EXTRA_STEP_2ARGS;
		NEXT_IS_EVAL = (OP(SCAN) == EVAL);
	      DO_CURLY:
		IF (FLAGS & SCF_DO_SUBSTR) {
                    IF (MINCOUNT == 0)
                        SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
                    /* CANNOT EXTEND FIXED SUBSTRINGS */
		    POS_BEFORE = DATA->POS_MIN;
		}
		IF (DATA) {
		    FL = DATA->FLAGS;
		    DATA->FLAGS &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);
		    IF (IS_INF)
			DATA->FLAGS |= SF_IS_INF;
		}
		IF (FLAGS & SCF_DO_STCLASS) {
		    SSC_INIT(PREXC_STATE, &THIS_CLASS);
		    OCLASS = DATA->START_CLASS;
		    DATA->START_CLASS = &THIS_CLASS;
		    F |= SCF_DO_STCLASS_AND;
		    F &= ~SCF_DO_STCLASS_OR;
		}
	        /* EXCLUDE FROM SUPER-LINEAR CACHE PROCESSING ANY {N,M}
		   REGOPS FOR WHICH THE COMBINATION OF INPUT POS AND REGEX
		   POS IS NOT ENOUGH INFORMATION TO DETERMINE IF A MATCH
		   WILL BE POSSIBLE.

		   FOR EXAMPLE, IN THE REGEX /FOO(BAR\S*){4,8}BAZ/ WITH THE
		   REGEX POS AT THE \S*, THE PROSPECTS FOR A MATCH DEPEND NOT
		   ONLY ON THE INPUT POSITION BUT ALSO ON HOW MANY (BAR\S*)
		   REPEATS INTO THE {4,8} WE ARE. */
               IF ((MINCOUNT > 1) || (MAXCOUNT > 1 && MAXCOUNT != REG_INFTY))
		    F &= ~SCF_WHILEM_VISITED_POS;

		/* THIS WILL FINISH ON WHILEM, SETTING SCAN, OR ON NULL: */
                /* RECURSE STUDY_CHUNK() ON LOOP BODIES */
		MINNEXT = STUDY_CHUNK(PREXC_STATE, &SCAN, MINLENP, &DELTANEXT,
                                  LAST, DATA, STOPPAREN, RECURSED_DEPTH, NULL,
                                  (MINCOUNT == 0
                                   ? (F & ~SCF_DO_SUBSTR)
                                   : F)
                                  ,DEPTH+1);

		IF (FLAGS & SCF_DO_STCLASS)
		    DATA->START_CLASS = OCLASS;
		IF (MINCOUNT == 0 || MINNEXT == 0) {
		    IF (FLAGS & SCF_DO_STCLASS_OR) {
			SSC_OR(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &THIS_CLASS);
		    }
		    ELSE IF (FLAGS & SCF_DO_STCLASS_AND) {
			/* SWITCH TO OR MODE: CACHE THE OLD VALUE OF
			 * DATA->START_CLASS */
			INIT_AND_WITHP;
			STRUCTCOPY(DATA->START_CLASS, AND_WITHP, REGNODE_SSC);
			FLAGS &= ~SCF_DO_STCLASS_AND;
			STRUCTCOPY(&THIS_CLASS, DATA->START_CLASS, REGNODE_SSC);
			FLAGS |= SCF_DO_STCLASS_OR;
                        ANYOF_FLAGS(DATA->START_CLASS)
                                                |= SSC_MATCHES_EMPTY_STRING;
		    }
		} ELSE {		/* NON-ZERO LEN */
		    IF (FLAGS & SCF_DO_STCLASS_OR) {
			SSC_OR(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &THIS_CLASS);
			SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);
		    }
		    ELSE IF (FLAGS & SCF_DO_STCLASS_AND)
			SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &THIS_CLASS);
		    FLAGS &= ~SCF_DO_STCLASS;
		}
		IF (!SCAN) 		/* IT WAS NOT CURLYX, BUT CURLY. */
		    SCAN = NEXT;
		IF (((FLAGS & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)
		    /* ? QUANTIFIER OK, EXCEPT FOR (?{ ... }) */
		    && (NEXT_IS_EVAL || !(MINCOUNT == 0 && MAXCOUNT == 1))
		    && (MINNEXT == 0) && (DELTANEXT == 0)
		    && DATA && !(DATA->FLAGS & (SF_HAS_PAR|SF_IN_PAR))
                    && MAXCOUNT <= REG_INFTY/3) /* COMPLEMENT CHECK FOR BIG
                                                   COUNT */
		{
		    _WARN_HELPER(REXC_PRECOMP_END, PACKWARN(WARN_REGEXP),
                        PERL_CK_WARNER(ATHX_ PACKWARN(WARN_REGEXP),
                            "QUANTIFIER UNEXPECTED ON ZERO-LENGTH EXPRESSION "
                            "IN REGEX M/%" UTF8F "/",
			     UTF8FARG(UTF, REXC_PRECOMP_END - REXC_PRECOMP,
				  REXC_PRECOMP)));
                }

                IF ( ( MINNEXT > 0 && MINCOUNT >= SSIZE_T_MAX / MINNEXT )
                    || MIN >= SSIZE_T_MAX - MINNEXT * MINCOUNT )
                {
                    FAIL("REGEXP OUT OF SPACE");
                }

		MIN += MINNEXT * MINCOUNT;
		IS_INF_INTERNAL |= DELTANEXT == SSIZE_T_MAX
                         || (MAXCOUNT == REG_INFTY && MINNEXT + DELTANEXT > 0);
		IS_INF |= IS_INF_INTERNAL;
                IF (IS_INF) {
		    DELTA = SSIZE_T_MAX;
                } ELSE {
		    DELTA += (MINNEXT + DELTANEXT) * MAXCOUNT
                             - MINNEXT * MINCOUNT;
                }
		/* TRY POWERFUL OPTIMIZATION CURLYX => CURLYN. */
		IF (  OP(OSCAN) == CURLYX && DATA
		      && DATA->FLAGS & SF_IN_PAR
		      && !(DATA->FLAGS & SF_HAS_EVAL)
		      && !DELTANEXT && MINNEXT == 1 ) {
		    /* TRY TO OPTIMIZE TO CURLYN.  */
		    REGNODE *NXT = NEXTOPER(OSCAN) + EXTRA_STEP_2ARGS;
		    REGNODE * CONST NXT1 = NXT;
#IFDEF DEBUGGING
		    REGNODE *NXT2;
#ENDIF

		    /* SKIP OPEN. */
		    NXT = REGNEXT(NXT);
		    IF (!REGNODE_SIMPLE(OP(NXT))
			&& !(PL_REGKIND[OP(NXT)] == EXACT
			     && STR_LEN(NXT) == 1))
			GOTO NOGO;
#IFDEF DEBUGGING
		    NXT2 = NXT;
#ENDIF
		    NXT = REGNEXT(NXT);
		    IF (OP(NXT) != CLOSE)
			GOTO NOGO;
		    IF (REXC_OPEN_PARENS) {

                        /*OPEN->CURLYM*/
                        REXC_OPEN_PARENS[ARG(NXT1)] = REGNODE_OFFSET(OSCAN);

                        /*CLOSE->WHILE*/
                        REXC_CLOSE_PARENS[ARG(NXT1)] = REGNODE_OFFSET(NXT) + 2;
		    }
		    /* NOW WE KNOW THAT NXT2 IS THE ONLY CONTENTS: */
		    OSCAN->FLAGS = (U8)ARG(NXT);
		    OP(OSCAN) = CURLYN;
		    OP(NXT1) = NOTHING;	/* WAS OPEN. */

#IFDEF DEBUGGING
		    OP(NXT1 + 1) = OPTIMIZED; /* WAS COUNT. */
		    NEXT_OFF(NXT1+ 1) = 0; /* JUST FOR CONSISTENCY. */
		    NEXT_OFF(NXT2) = 0;	/* JUST FOR CONSISTENCY WITH CURLY. */
		    OP(NXT) = OPTIMIZED;	/* WAS CLOSE. */
		    OP(NXT + 1) = OPTIMIZED; /* WAS COUNT. */
		    NEXT_OFF(NXT+ 1) = 0; /* JUST FOR CONSISTENCY. */
#ENDIF
		}
	      NOGO:

		/* TRY OPTIMIZATION CURLYX => CURLYM. */
		IF (  OP(OSCAN) == CURLYX && DATA
		      && !(DATA->FLAGS & SF_HAS_PAR)
		      && !(DATA->FLAGS & SF_HAS_EVAL)
		      && !DELTANEXT	/* ATOM IS FIXED WIDTH */
		      && MINNEXT != 0	/* CURLYM CAN'T HANDLE ZERO WIDTH */

                         /* NOR CHARACTERS WHOSE FOLD AT RUN-TIME MAY BE
                          * MULTI-CHARACTER */
                      && ! (REXC_SEEN & REG_UNFOLDED_MULTI_SEEN)
		) {
		    /* XXXX HOW TO OPTIMIZE IF DATA == 0? */
		    /* OPTIMIZE TO A SIMPLER FORM.  */
		    REGNODE *NXT = NEXTOPER(OSCAN) + EXTRA_STEP_2ARGS; /* OPEN */
		    REGNODE *NXT2;

		    OP(OSCAN) = CURLYM;
		    WHILE ( (NXT2 = REGNEXT(NXT)) /* SKIP OVER EMBEDDED STUFF*/
			    && (OP(NXT2) != WHILEM))
			NXT = NXT2;
		    OP(NXT2)  = SUCCEED; /* WHAS WHILEM */
		    /* NEED TO OPTIMIZE AWAY PARENTHS. */
		    IF ((DATA->FLAGS & SF_IN_PAR) && OP(NXT) == CLOSE) {
			/* SET THE PARENTH NUMBER.  */
			REGNODE *NXT1 = NEXTOPER(OSCAN) + EXTRA_STEP_2ARGS; /* OPEN*/

			OSCAN->FLAGS = (U8)ARG(NXT);
			IF (REXC_OPEN_PARENS) {
                             /*OPEN->CURLYM*/
                            REXC_OPEN_PARENS[ARG(NXT1)] = REGNODE_OFFSET(OSCAN);

                            /*CLOSE->NOTHING*/
                            REXC_CLOSE_PARENS[ARG(NXT1)] = REGNODE_OFFSET(NXT2)
                                                         + 1;
			}
			OP(NXT1) = OPTIMIZED;	/* WAS OPEN. */
			OP(NXT) = OPTIMIZED;	/* WAS CLOSE. */

#IFDEF DEBUGGING
			OP(NXT1 + 1) = OPTIMIZED; /* WAS COUNT. */
			OP(NXT + 1) = OPTIMIZED; /* WAS COUNT. */
			NEXT_OFF(NXT1 + 1) = 0; /* JUST FOR CONSISTENCY. */
			NEXT_OFF(NXT + 1) = 0; /* JUST FOR CONSISTENCY. */
#ENDIF
#IF 0
			WHILE ( NXT1 && (OP(NXT1) != WHILEM)) {
			    REGNODE *NNXT = REGNEXT(NXT1);
			    IF (NNXT == NXT) {
				IF (REG_OFF_BY_ARG[OP(NXT1)])
				    ARG_SET(NXT1, NXT2 - NXT1);
				ELSE IF (NXT2 - NXT1 < U16_MAX)
				    NEXT_OFF(NXT1) = NXT2 - NXT1;
				ELSE
				    OP(NXT) = NOTHING;	/* CANNOT BEAUTIFY */
			    }
			    NXT1 = NNXT;
			}
#ENDIF
			/* OPTIMIZE AGAIN: */
                        /* RECURSE STUDY_CHUNK() ON OPTIMISED CURLYX => CURLYM */
			STUDY_CHUNK(PREXC_STATE, &NXT1, MINLENP, &DELTANEXT, NXT,
                                    NULL, STOPPAREN, RECURSED_DEPTH, NULL, 0,
                                    DEPTH+1);
		    }
		    ELSE
			OSCAN->FLAGS = 0;
		}
		ELSE IF ((OP(OSCAN) == CURLYX)
			 && (FLAGS & SCF_WHILEM_VISITED_POS)
			 /* SEE THE COMMENT ON A SIMILAR EXPRESSION ABOVE.
			    HOWEVER, THIS TIME IT'S NOT A SUBEXPRESSION
			    WE CARE ABOUT, BUT THE EXPRESSION ITSELF. */
			 && (MAXCOUNT == REG_INFTY)
			 && DATA) {
		    /* THIS STAYS AS CURLYX, WE CAN PUT THE COUNT/OF PAIR. */
		    /* FIND WHILEM (AS IN REGEXEC.C) */
		    REGNODE *NXT = OSCAN + NEXT_OFF(OSCAN);

		    IF (OP(PREVOPER(NXT)) == NOTHING) /* LONGJMP */
			NXT += ARG(NXT);
                    NXT = PREVOPER(NXT);
                    IF (NXT->FLAGS & 0XF) {
                        /* WE'VE ALREADY SET WHILEM COUNT ON THIS NODE */
                    } ELSE IF (++DATA->WHILEM_C < 16) {
                        ASSERT(DATA->WHILEM_C <= REXC_WHILEM_SEEN);
                        NXT->FLAGS = (U8)(DATA->WHILEM_C
                            | (REXC_WHILEM_SEEN << 4)); /* ON WHILEM */
                    }
		}
		IF (DATA && FL & (SF_HAS_PAR|SF_IN_PAR))
		    PARS++;
		IF (FLAGS & SCF_DO_SUBSTR) {
		    SV *LAST_STR = NULL;
                    STRLEN LAST_CHRS = 0;
		    INT COUNTED = MINCOUNT != 0;

                    IF (DATA->LAST_END > 0 && MINCOUNT != 0) { /* ENDS WITH A
                                                                  STRING. */
			SSIZE_T B = POS_BEFORE >= DATA->LAST_START_MIN
			    ? POS_BEFORE : DATA->LAST_START_MIN;
			STRLEN L;
			CONST CHAR * CONST S = SVPV_CONST(DATA->LAST_FOUND, L);
			SSIZE_T OLD = B - DATA->LAST_START_MIN;
                        ASSERT(OLD >= 0);

			IF (UTF)
			    OLD = UTF8_HOP_FORWARD((U8*)S, OLD,
                                               (U8 *) SVEND(DATA->LAST_FOUND))
                                - (U8*)S;
			L -= OLD;
			/* GET THE ADDED STRING: */
			LAST_STR = NEWSVPVN_UTF8(S  + OLD, L, UTF);
                        LAST_CHRS = UTF ? UTF8_LENGTH((U8*)(S + OLD),
                                            (U8*)(S + OLD + L)) : L;
			IF (DELTANEXT == 0 && POS_BEFORE == B) {
			    /* WHAT WAS ADDED IS A CONSTANT STRING */
			    IF (MINCOUNT > 1) {

				SVGROW(LAST_STR, (MINCOUNT * L) + 1);
				REPEATCPY(SVPVX(LAST_STR) + L,
					  SVPVX_CONST(LAST_STR), L,
                                          MINCOUNT - 1);
				SVCUR_SET(LAST_STR, SVCUR(LAST_STR) * MINCOUNT);
				/* ADD ADDITIONAL PARTS. */
				SVCUR_SET(DATA->LAST_FOUND,
					  SVCUR(DATA->LAST_FOUND) - L);
				SV_CATSV(DATA->LAST_FOUND, LAST_STR);
				{
				    SV * SV = DATA->LAST_FOUND;
				    MAGIC *MG =
					SVUTF8(SV) && SVMAGICAL(SV) ?
					MG_FIND(SV, PERL_MAGIC_UTF8) : NULL;
				    IF (MG && MG->MG_LEN >= 0)
					MG->MG_LEN += LAST_CHRS * (MINCOUNT-1);
				}
                                LAST_CHRS *= MINCOUNT;
				DATA->LAST_END += L * (MINCOUNT - 1);
			    }
			} ELSE {
			    /* START OFFSET MUST POINT INTO THE LAST COPY */
			    DATA->LAST_START_MIN += MINNEXT * (MINCOUNT - 1);
			    DATA->LAST_START_MAX =
                              IS_INF
                               ? SSIZE_T_MAX
			       : DATA->LAST_START_MAX +
                                 (MAXCOUNT - 1) * (MINNEXT + DATA->POS_DELTA);
			}
		    }
		    /* IT IS COUNTED ONCE ALREADY... */
		    DATA->POS_MIN += MINNEXT * (MINCOUNT - COUNTED);
#IF 0
PERL_RE_PRINTF( ATHX_  "COUNTED=%" UVUF " DELTANEXT=%" UVUF
                              " SSIZE_T_MAX=%" UVUF " MINNEXT=%" UVUF
                              " MAXCOUNT=%" UVUF " MINCOUNT=%" UVUF "\N",
    (UV)COUNTED, (UV)DELTANEXT, (UV)SSIZE_T_MAX, (UV)MINNEXT, (UV)MAXCOUNT,
    (UV)MINCOUNT);
IF (DELTANEXT != SSIZE_T_MAX)
PERL_RE_PRINTF( ATHX_  "LHS=%" UVUF " RHS=%" UVUF "\N",
    (UV)(-COUNTED * DELTANEXT + (MINNEXT + DELTANEXT) * MAXCOUNT
          - MINNEXT * MINCOUNT), (UV)(SSIZE_T_MAX - DATA->POS_DELTA));
#ENDIF
		    IF (DELTANEXT == SSIZE_T_MAX
                        || -COUNTED * DELTANEXT + (MINNEXT + DELTANEXT) * MAXCOUNT - MINNEXT * MINCOUNT >= SSIZE_T_MAX - DATA->POS_DELTA)
		        DATA->POS_DELTA = SSIZE_T_MAX;
		    ELSE
		        DATA->POS_DELTA += - COUNTED * DELTANEXT +
			(MINNEXT + DELTANEXT) * MAXCOUNT - MINNEXT * MINCOUNT;
		    IF (MINCOUNT != MAXCOUNT) {
			 /* CANNOT EXTEND FIXED SUBSTRINGS FOUND INSIDE
			    THE GROUP.  */
                        SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
			IF (MINCOUNT && LAST_STR) {
			    SV * CONST SV = DATA->LAST_FOUND;
			    MAGIC * CONST MG = SVUTF8(SV) && SVMAGICAL(SV) ?
				MG_FIND(SV, PERL_MAGIC_UTF8) : NULL;

			    IF (MG)
				MG->MG_LEN = -1;
			    SV_SETSV(SV, LAST_STR);
			    DATA->LAST_END = DATA->POS_MIN;
			    DATA->LAST_START_MIN = DATA->POS_MIN - LAST_CHRS;
			    DATA->LAST_START_MAX = IS_INF
				? SSIZE_T_MAX
				: DATA->POS_MIN + DATA->POS_DELTA - LAST_CHRS;
			}
			DATA->CUR_IS_FLOATING = 1; /* FLOAT */
		    }
		    SVREFCNT_DEC(LAST_STR);
		}
		IF (DATA && (FL & SF_HAS_EVAL))
		    DATA->FLAGS |= SF_HAS_EVAL;
	      OPTIMIZE_CURLY_TAIL:
		RCK_ELIDE_NOTHING(OSCAN);
		CONTINUE;

	    DEFAULT:
#IFDEF DEBUGGING
                PERL_CROAK(ATHX_ "PANIC: UNEXPECTED VARYING REX OPCODE %D",
                                                                    OP(SCAN));
#ENDIF
            CASE REF:
            CASE CLUMP:
		IF (FLAGS & SCF_DO_SUBSTR) {
                    /* CANNOT EXPECT ANYTHING... */
                    SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
		    DATA->CUR_IS_FLOATING = 1; /* FLOAT */
		}
		IS_INF = IS_INF_INTERNAL = 1;
		IF (FLAGS & SCF_DO_STCLASS_OR) {
                    IF (OP(SCAN) == CLUMP) {
                        /* ACTUALLY IS ANY START CHAR, BUT VERY FEW CODE POINTS
                         * AREN'T START CHARACTERS */
                        SSC_MATCH_ALL_CP(DATA->START_CLASS);
                    }
                    ELSE {
                        SSC_ANYTHING(DATA->START_CLASS);
                    }
                }
		FLAGS &= ~SCF_DO_STCLASS;
		BREAK;
	    }
	}
	ELSE IF (OP(SCAN) == LNBREAK) {
	    IF (FLAGS & SCF_DO_STCLASS) {
    	        IF (FLAGS & SCF_DO_STCLASS_AND) {
                    SSC_INTERSECTION(DATA->START_CLASS,
                                    PL_XPOSIX_PTRS[_CC_VERTSPACE], FALSE);
                    SSC_CLEAR_LOCALE(DATA->START_CLASS);
                    ANYOF_FLAGS(DATA->START_CLASS)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
                }
                ELSE IF (FLAGS & SCF_DO_STCLASS_OR) {
                    SSC_UNION(DATA->START_CLASS,
                              PL_XPOSIX_PTRS[_CC_VERTSPACE],
                              FALSE);
		    SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);

                    /* SEE COMMIT MSG FOR
                     * 749E076FCEEDEB708A624933726E7989F2302F6A */
                    ANYOF_FLAGS(DATA->START_CLASS)
                                                &= ~SSC_MATCHES_EMPTY_STRING;
                }
		FLAGS &= ~SCF_DO_STCLASS;
            }
	    MIN++;
            IF (DELTA != SSIZE_T_MAX)
                DELTA++;    /* BECAUSE OF THE 2 CHAR STRING CR-LF */
            IF (FLAGS & SCF_DO_SUBSTR) {
                /* CANNOT EXPECT ANYTHING... */
                SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
    	        DATA->POS_MIN += 1;
                IF (DATA->POS_DELTA != SSIZE_T_MAX) {
                    DATA->POS_DELTA += 1;
                }
		DATA->CUR_IS_FLOATING = 1; /* FLOAT */
    	    }
	}
	ELSE IF (REGNODE_SIMPLE(OP(SCAN))) {

	    IF (FLAGS & SCF_DO_SUBSTR) {
                SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
		DATA->POS_MIN++;
	    }
	    MIN++;
	    IF (FLAGS & SCF_DO_STCLASS) {
                BOOL INVERT = 0;
                SV* MY_INVLIST = NULL;
                U8 NAMEDCLASS;

                /* SEE COMMIT MSG 749E076FCEEDEB708A624933726E7989F2302F6A */
                ANYOF_FLAGS(DATA->START_CLASS) &= ~SSC_MATCHES_EMPTY_STRING;

		/* SOME OF THE LOGIC BELOW ASSUMES THAT SWITCHING
		   LOCALE ON WILL ONLY ADD FALSE POSITIVES. */
		SWITCH (OP(SCAN)) {

		DEFAULT:
#IFDEF DEBUGGING
                   PERL_CROAK(ATHX_ "PANIC: UNEXPECTED SIMPLE REX OPCODE %D",
                                                                     OP(SCAN));
#ENDIF
		CASE SANY:
		    IF (FLAGS & SCF_DO_STCLASS_OR) /* ALLOW EVERYTHING */
			SSC_MATCH_ALL_CP(DATA->START_CLASS);
		    BREAK;

		CASE REG_ANY:
                    {
                        SV* REG_ANY_INVLIST = _NEW_INVLIST(2);
                        REG_ANY_INVLIST = ADD_CP_TO_INVLIST(REG_ANY_INVLIST,
                                                            '\N');
                        IF (FLAGS & SCF_DO_STCLASS_OR) {
                            SSC_UNION(DATA->START_CLASS,
                                      REG_ANY_INVLIST,
                                      TRUE /* TRUE => INVERT, HENCE ALL BUT \N
                                            */
                                      );
                        }
                        ELSE IF (FLAGS & SCF_DO_STCLASS_AND) {
                            SSC_INTERSECTION(DATA->START_CLASS,
                                             REG_ANY_INVLIST,
                                             TRUE  /* TRUE => INVERT */
                                             );
                            SSC_CLEAR_LOCALE(DATA->START_CLASS);
                        }
                        SVREFCNT_DEC_NN(REG_ANY_INVLIST);
		    }
		    BREAK;

                CASE ANYOFD:
                CASE ANYOFL:
                CASE ANYOFPOSIXL:
                CASE ANYOFH:
                CASE ANYOF:
		    IF (FLAGS & SCF_DO_STCLASS_AND)
			SSC_AND(PREXC_STATE, DATA->START_CLASS,
                                (REGNODE_CHARCLASS *) SCAN);
		    ELSE
			SSC_OR(PREXC_STATE, DATA->START_CLASS,
                                                          (REGNODE_CHARCLASS *) SCAN);
		    BREAK;

                CASE NANYOFM:
                CASE ANYOFM:
                  {
                    SV* CP_LIST = GET_ANYOFM_CONTENTS(SCAN);

                    IF (FLAGS & SCF_DO_STCLASS_OR) {
                        SSC_UNION(DATA->START_CLASS, CP_LIST, INVERT);
                    }
                    ELSE IF (FLAGS & SCF_DO_STCLASS_AND) {
                        SSC_INTERSECTION(DATA->START_CLASS, CP_LIST, INVERT);
                    }

                    SVREFCNT_DEC_NN(CP_LIST);
                    BREAK;
                  }

		CASE NPOSIXL:
                    INVERT = 1;
                    /* FALLTHROUGH */

		CASE POSIXL:
                    NAMEDCLASS = CLASSNUM_TO_NAMEDCLASS(FLAGS(SCAN)) + INVERT;
                    IF (FLAGS & SCF_DO_STCLASS_AND) {
                        BOOL WAS_THERE = CBOOL(
                                          ANYOF_POSIXL_TEST(DATA->START_CLASS,
                                                                 NAMEDCLASS));
                        ANYOF_POSIXL_ZERO(DATA->START_CLASS);
                        IF (WAS_THERE) {    /* DO AN AND */
                            ANYOF_POSIXL_SET(DATA->START_CLASS, NAMEDCLASS);
                        }
                        /* NO INDIVIDUAL CODE POINTS CAN NOW MATCH */
                        DATA->START_CLASS->INVLIST
                                                = SV_2MORTAL(_NEW_INVLIST(0));
                    }
                    ELSE {
                        INT COMPLEMENT = NAMEDCLASS + ((INVERT) ? -1 : 1);

                        ASSERT(FLAGS & SCF_DO_STCLASS_OR);

                        /* IF THE COMPLEMENT OF THIS CLASS WAS ALREADY THERE,
                         * THE RESULT IS THAT THEY MATCH ALL CODE POINTS,
                         * (\D + \D == EVERYTHING).  REMOVE THE CLASSES FROM
                         * FUTURE CONSIDERATION.  LOCALE IS NOT RELEVANT IN
                         * THIS CASE */
                        IF (ANYOF_POSIXL_TEST(DATA->START_CLASS, COMPLEMENT)) {
                            SSC_MATCH_ALL_CP(DATA->START_CLASS);
                            ANYOF_POSIXL_CLEAR(DATA->START_CLASS, NAMEDCLASS);
                            ANYOF_POSIXL_CLEAR(DATA->START_CLASS, COMPLEMENT);
                        }
                        ELSE {  /* THE USUAL CASE; JUST ADD THIS CLASS TO THE
                                   EXISTING SET */
                            ANYOF_POSIXL_SET(DATA->START_CLASS, NAMEDCLASS);
                        }
                    }
                    BREAK;

                CASE NPOSIXA:   /* FOR THESE, WE ALWAYS KNOW THE EXACT SET OF
                                   WHAT'S MATCHED */
                    INVERT = 1;
                    /* FALLTHROUGH */
		CASE POSIXA:
                    MY_INVLIST = INVLIST_CLONE(PL_POSIX_PTRS[FLAGS(SCAN)], NULL);
                    GOTO JOIN_POSIX_AND_ASCII;

		CASE NPOSIXD:
		CASE NPOSIXU:
                    INVERT = 1;
                    /* FALLTHROUGH */
		CASE POSIXD:
		CASE POSIXU:
                    MY_INVLIST = INVLIST_CLONE(PL_XPOSIX_PTRS[FLAGS(SCAN)], NULL);

                    /* NPOSIXD MATCHES ALL UPPER LATIN1 CODE POINTS UNLESS THE
                     * TARGET STRING BEING MATCHED IS UTF-8, WHICH IS
                     * UNKNOWABLE UNTIL MATCH TIME.  SINCE WE ARE GOING TO
                     * INVERT, WE WANT TO GET RID OF ALL OF THEM SO THAT THE
                     * INVERSION WILL MATCH ALL */
                    IF (OP(SCAN) == NPOSIXD) {
                        _INVLIST_SUBTRACT(MY_INVLIST, PL_UPPERLATIN1,
                                          &MY_INVLIST);
                    }

                  JOIN_POSIX_AND_ASCII:

                    IF (FLAGS & SCF_DO_STCLASS_AND) {
                        SSC_INTERSECTION(DATA->START_CLASS, MY_INVLIST, INVERT);
                        SSC_CLEAR_LOCALE(DATA->START_CLASS);
                    }
                    ELSE {
                        ASSERT(FLAGS & SCF_DO_STCLASS_OR);
                        SSC_UNION(DATA->START_CLASS, MY_INVLIST, INVERT);
                    }
                    SVREFCNT_DEC(MY_INVLIST);
		}
		IF (FLAGS & SCF_DO_STCLASS_OR)
		    SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);
		FLAGS &= ~SCF_DO_STCLASS;
	    }
	}
	ELSE IF (PL_REGKIND[OP(SCAN)] == EOL && FLAGS & SCF_DO_SUBSTR) {
	    DATA->FLAGS |= (OP(SCAN) == MEOL
			    ? SF_BEFORE_MEOL
			    : SF_BEFORE_SEOL);
            SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);

	}
	ELSE IF (  PL_REGKIND[OP(SCAN)] == BRANCHJ
		 /* LOOKBEHIND, OR NEED TO CALCULATE PARENS/EVALS/STCLASS: */
		   && (SCAN->FLAGS || DATA || (FLAGS & SCF_DO_STCLASS))
		   && (OP(SCAN) == IFMATCH || OP(SCAN) == UNLESSM))
        {
            IF ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY
                || OP(SCAN) == UNLESSM )
            {
                /* NEGATIVE LOOKAHEAD/LOOKBEHIND
                   IN THIS CASE WE CAN'T DO FIXED STRING OPTIMISATION.
                */

                SSIZE_T DELTANEXT, MINNEXT, FAKE = 0;
                REGNODE *NSCAN;
                REGNODE_SSC INTRNL;
                INT F = 0;

                STRUCTCOPY(&ZERO_SCAN_DATA, &DATA_FAKE, SCAN_DATA_T);
                IF (DATA) {
                    DATA_FAKE.WHILEM_C = DATA->WHILEM_C;
                    DATA_FAKE.LAST_CLOSEP = DATA->LAST_CLOSEP;
		}
                ELSE
                    DATA_FAKE.LAST_CLOSEP = &FAKE;
		DATA_FAKE.POS_DELTA = DELTA;
                IF ( FLAGS & SCF_DO_STCLASS && !SCAN->FLAGS
                     && OP(SCAN) == IFMATCH ) { /* LOOKAHEAD */
                    SSC_INIT(PREXC_STATE, &INTRNL);
                    DATA_FAKE.START_CLASS = &INTRNL;
                    F |= SCF_DO_STCLASS_AND;
		}
                IF (FLAGS & SCF_WHILEM_VISITED_POS)
                    F |= SCF_WHILEM_VISITED_POS;
                NEXT = REGNEXT(SCAN);
                NSCAN = NEXTOPER(NEXTOPER(SCAN));

                /* RECURSE STUDY_CHUNK() FOR LOOKAHEAD BODY */
                MINNEXT = STUDY_CHUNK(PREXC_STATE, &NSCAN, MINLENP, &DELTANEXT,
                                      LAST, &DATA_FAKE, STOPPAREN,
                                      RECURSED_DEPTH, NULL, F, DEPTH+1);
                IF (SCAN->FLAGS) {
                    IF (   DELTANEXT < 0
                        || DELTANEXT > (I32) U8_MAX
                        || MINNEXT > (I32)U8_MAX
                        || MINNEXT + DELTANEXT > (I32)U8_MAX)
                    {
			FAIL2("LOOKBEHIND LONGER THAN %" UVUF " NOT IMPLEMENTED",
                              (UV)U8_MAX);
                    }

                    /* THE 'NEXT_OFF' FIELD HAS BEEN REPURPOSED TO COUNT THE
                     * ADDITIONAL STARTING POSITIONS TO TRY BEYOND THE INITIAL
                     * ONE.  (THIS LEAVES IT AT 0 FOR NON-VARIABLE LENGTH
                     * MATCHES TO AVOID BREAKAGE FOR THOSE NOT USING THIS
                     * EXTENSION) */
                    IF (DELTANEXT) {
                        SCAN->NEXT_OFF = DELTANEXT;
                        CKWARNEXPERIMENTAL(REXC_PARSE,
                            WARN_EXPERIMENTAL__VLB,
                            "VARIABLE LENGTH LOOKBEHIND IS EXPERIMENTAL");
                    }
                    SCAN->FLAGS = (U8)MINNEXT + DELTANEXT;
                }
                IF (DATA) {
                    IF (DATA_FAKE.FLAGS & (SF_HAS_PAR|SF_IN_PAR))
                        PARS++;
                    IF (DATA_FAKE.FLAGS & SF_HAS_EVAL)
                        DATA->FLAGS |= SF_HAS_EVAL;
                    DATA->WHILEM_C = DATA_FAKE.WHILEM_C;
                }
                IF (F & SCF_DO_STCLASS_AND) {
		    IF (FLAGS & SCF_DO_STCLASS_OR) {
			/* OR BEFORE, AND AFTER: IDEALLY WE WOULD RECURSE WITH
			 * DATA_FAKE TO GET THE AND APPLIED BY STUDY OF THE
			 * REMAINDER OF THE PATTERN, AND THEN DERECURSE;
			 * *** HACK *** FOR NOW JUST TREAT AS "NO INFORMATION".
			 * SEE [PERL #56690].
			 */
			SSC_INIT(PREXC_STATE, DATA->START_CLASS);
		    }  ELSE {
                        /* AND BEFORE AND AFTER: COMBINE AND CONTINUE.  THESE
                         * ASSERTIONS ARE ZERO-LENGTH, SO CAN MATCH AN EMPTY
                         * STRING */
			SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &INTRNL);
                        ANYOF_FLAGS(DATA->START_CLASS)
                                                   |= SSC_MATCHES_EMPTY_STRING;
		    }
                }
	    }
#IF PERL_ENABLE_POSITIVE_ASSERTION_STUDY
            ELSE {
                /* POSITIVE LOOKAHEAD/LOOKBEHIND
                   IN THIS CASE WE CAN DO FIXED STRING OPTIMISATION,
                   BUT WE MUST BE CAREFUL ABOUT IT. NOTE IN THE CASE OF
                   LOOKBEHIND THE POSITIONS WILL BE OFFSET BY THE MINIMUM
                   LENGTH OF THE PATTERN, SOMETHING WE WON'T KNOW ABOUT
                   UNTIL AFTER THE RECURSE.
                */
                SSIZE_T DELTANEXT, FAKE = 0;
                REGNODE *NSCAN;
                REGNODE_SSC INTRNL;
                INT F = 0;
                /* WE USE SAVEFREEPV SO THAT WHEN THE FULL COMPILE
                    IS FINISHED PERL WILL CLEAN UP THE ALLOCATED
                    MINLENS WHEN IT'S ALL DONE. THIS WAY WE DON'T
                    HAVE TO WORRY ABOUT FREEING THEM WHEN WE KNOW
                    THEY WONT BE USED, WHICH WOULD BE A PAIN.
                 */
                SSIZE_T *MINNEXTP;
                NEWX( MINNEXTP, 1, SSIZE_T );
                SAVEFREEPV(MINNEXTP);

                IF (DATA) {
                    STRUCTCOPY(DATA, &DATA_FAKE, SCAN_DATA_T);
                    IF ((FLAGS & SCF_DO_SUBSTR) && DATA->LAST_FOUND) {
                        F |= SCF_DO_SUBSTR;
                        IF (SCAN->FLAGS)
                            SCAN_COMMIT(PREXC_STATE, &DATA_FAKE, MINLENP, IS_INF);
                        DATA_FAKE.LAST_FOUND=NEWSVSV(DATA->LAST_FOUND);
                    }
                }
                ELSE
                    DATA_FAKE.LAST_CLOSEP = &FAKE;
                DATA_FAKE.FLAGS = 0;
                DATA_FAKE.SUBSTRS[0].FLAGS = 0;
                DATA_FAKE.SUBSTRS[1].FLAGS = 0;
		DATA_FAKE.POS_DELTA = DELTA;
                IF (IS_INF)
	            DATA_FAKE.FLAGS |= SF_IS_INF;
                IF ( FLAGS & SCF_DO_STCLASS && !SCAN->FLAGS
                     && OP(SCAN) == IFMATCH ) { /* LOOKAHEAD */
                    SSC_INIT(PREXC_STATE, &INTRNL);
                    DATA_FAKE.START_CLASS = &INTRNL;
                    F |= SCF_DO_STCLASS_AND;
                }
                IF (FLAGS & SCF_WHILEM_VISITED_POS)
                    F |= SCF_WHILEM_VISITED_POS;
                NEXT = REGNEXT(SCAN);
                NSCAN = NEXTOPER(NEXTOPER(SCAN));

                /* POSITIVE LOOKAHEAD STUDY_CHUNK() RECURSION */
                *MINNEXTP = STUDY_CHUNK(PREXC_STATE, &NSCAN, MINNEXTP,
                                        &DELTANEXT, LAST, &DATA_FAKE,
                                        STOPPAREN, RECURSED_DEPTH, NULL,
                                        F, DEPTH+1);
                IF (SCAN->FLAGS) {
                    ASSERT(0);  /* THIS CODE HAS NEVER BEEN TESTED SINCE THIS
                                   IS NORMALLY NOT COMPILED */
                    IF (   DELTANEXT < 0
                        || DELTANEXT > (I32) U8_MAX
                        || *MINNEXTP > (I32)U8_MAX
                        || *MINNEXTP + DELTANEXT > (I32)U8_MAX)
                    {
			FAIL2("LOOKBEHIND LONGER THAN %" UVUF " NOT IMPLEMENTED",
                              (UV)U8_MAX);
                    }

                    IF (DELTANEXT) {
                        SCAN->NEXT_OFF = DELTANEXT;
                    }
                    SCAN->FLAGS = (U8)*MINNEXTP + DELTANEXT;
                }

                *MINNEXTP += MIN;

                IF (F & SCF_DO_STCLASS_AND) {
                    SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &INTRNL);
                    ANYOF_FLAGS(DATA->START_CLASS) |= SSC_MATCHES_EMPTY_STRING;
                }
                IF (DATA) {
                    IF (DATA_FAKE.FLAGS & (SF_HAS_PAR|SF_IN_PAR))
                        PARS++;
                    IF (DATA_FAKE.FLAGS & SF_HAS_EVAL)
                        DATA->FLAGS |= SF_HAS_EVAL;
                    DATA->WHILEM_C = DATA_FAKE.WHILEM_C;
                    IF ((FLAGS & SCF_DO_SUBSTR) && DATA_FAKE.LAST_FOUND) {
                        INT I;
                        IF (REXC_RX->MINLEN<*MINNEXTP)
                            REXC_RX->MINLEN=*MINNEXTP;
                        SCAN_COMMIT(PREXC_STATE, &DATA_FAKE, MINNEXTP, IS_INF);
                        SVREFCNT_DEC_NN(DATA_FAKE.LAST_FOUND);

                        FOR (I = 0; I < 2; I++) {
                            IF (DATA_FAKE.SUBSTRS[I].MINLENP != MINLENP) {
                                DATA->SUBSTRS[I].MIN_OFFSET =
                                            DATA_FAKE.SUBSTRS[I].MIN_OFFSET;
                                DATA->SUBSTRS[I].MAX_OFFSET =
                                            DATA_FAKE.SUBSTRS[I].MAX_OFFSET;
                                DATA->SUBSTRS[I].MINLENP =
                                            DATA_FAKE.SUBSTRS[I].MINLENP;
                                DATA->SUBSTRS[I].LOOKBEHIND += SCAN->FLAGS;
                            }
                        }
                    }
                }
	    }
#ENDIF
	}

	ELSE IF (OP(SCAN) == OPEN) {
	    IF (STOPPAREN != (I32)ARG(SCAN))
	        PARS++;
	}
	ELSE IF (OP(SCAN) == CLOSE) {
	    IF (STOPPAREN == (I32)ARG(SCAN)) {
	        BREAK;
	    }
	    IF ((I32)ARG(SCAN) == IS_PAR) {
		NEXT = REGNEXT(SCAN);

		IF ( NEXT && (OP(NEXT) != WHILEM) && NEXT < LAST)
		    IS_PAR = 0;		/* DISABLE OPTIMIZATION */
	    }
	    IF (DATA)
		*(DATA->LAST_CLOSEP) = ARG(SCAN);
	}
	ELSE IF (OP(SCAN) == EVAL) {
		IF (DATA)
		    DATA->FLAGS |= SF_HAS_EVAL;
	}
	ELSE IF ( PL_REGKIND[OP(SCAN)] == ENDLIKE ) {
	    IF (FLAGS & SCF_DO_SUBSTR) {
                SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
		FLAGS &= ~SCF_DO_SUBSTR;
	    }
	    IF (DATA && OP(SCAN)==ACCEPT) {
	        DATA->FLAGS |= SCF_SEEN_ACCEPT;
	        IF (STOPMIN > MIN)
	            STOPMIN = MIN;
	    }
	}
	ELSE IF (OP(SCAN) == LOGICAL && SCAN->FLAGS == 2) /* EMBEDDED FOLLOWS */
	{
		IF (FLAGS & SCF_DO_SUBSTR) {
                    SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
		    DATA->CUR_IS_FLOATING = 1; /* FLOAT */
		}
		IS_INF = IS_INF_INTERNAL = 1;
		IF (FLAGS & SCF_DO_STCLASS_OR) /* ALLOW EVERYTHING */
		    SSC_ANYTHING(DATA->START_CLASS);
		FLAGS &= ~SCF_DO_STCLASS;
	}
	ELSE IF (OP(SCAN) == GPOS) {
            IF (!(REXC_RX->INTFLAGS & PREGF_GPOS_FLOAT) &&
	        !(DELTA || IS_INF || (DATA && DATA->POS_DELTA)))
	    {
                IF (!(REXC_RX->INTFLAGS & PREGF_ANCH) && (FLAGS & SCF_DO_SUBSTR))
                    REXC_RX->INTFLAGS |= PREGF_ANCH_GPOS;
	        IF (REXC_RX->GOFS < (STRLEN)MIN)
		    REXC_RX->GOFS = MIN;
            } ELSE {
                REXC_RX->INTFLAGS |= PREGF_GPOS_FLOAT;
                REXC_RX->GOFS = 0;
            }
	}
#IFDEF TRIE_STUDY_OPT
#IFDEF FULL_TRIE_STUDY
        ELSE IF (PL_REGKIND[OP(SCAN)] == TRIE) {
            /* NOTE - THERE IS SIMILAR CODE TO THIS BLOCK ABOVE FOR HANDLING
               BRANCH NODES ON THE INITIAL STUDY.  IF YOU CHANGE STUFF HERE
               CHECK THERE TOO. */
            REGNODE *TRIE_NODE= SCAN;
            REGNODE *TAIL= REGNEXT(SCAN);
            REG_TRIE_DATA *TRIE = (REG_TRIE_DATA*)REXC_RXI->DATA->DATA[ ARG(SCAN) ];
            SSIZE_T MAX1 = 0, MIN1 = SSIZE_T_MAX;
            REGNODE_SSC ACCUM;

            IF (FLAGS & SCF_DO_SUBSTR) { /* XXXX ADD !SUSPEND? */
                /* CANNOT MERGE STRINGS AFTER THIS. */
                SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
            }
            IF (FLAGS & SCF_DO_STCLASS)
                SSC_INIT_ZERO(PREXC_STATE, &ACCUM);

            IF (!TRIE->JUMP) {
                MIN1= TRIE->MINLEN;
                MAX1= TRIE->MAXLEN;
            } ELSE {
                CONST REGNODE *NEXTBRANCH= NULL;
                U32 WORD;

                FOR ( WORD=1 ; WORD <= TRIE->WORDCOUNT ; WORD++)
                {
                    SSIZE_T DELTANEXT=0, MINNEXT=0, F = 0, FAKE;
                    REGNODE_SSC THIS_CLASS;

                    STRUCTCOPY(&ZERO_SCAN_DATA, &DATA_FAKE, SCAN_DATA_T);
                    IF (DATA) {
                        DATA_FAKE.WHILEM_C = DATA->WHILEM_C;
                        DATA_FAKE.LAST_CLOSEP = DATA->LAST_CLOSEP;
                    }
                    ELSE
                        DATA_FAKE.LAST_CLOSEP = &FAKE;
		    DATA_FAKE.POS_DELTA = DELTA;
                    IF (FLAGS & SCF_DO_STCLASS) {
                        SSC_INIT(PREXC_STATE, &THIS_CLASS);
                        DATA_FAKE.START_CLASS = &THIS_CLASS;
                        F = SCF_DO_STCLASS_AND;
                    }
                    IF (FLAGS & SCF_WHILEM_VISITED_POS)
                        F |= SCF_WHILEM_VISITED_POS;

                    IF (TRIE->JUMP[WORD]) {
                        IF (!NEXTBRANCH)
                            NEXTBRANCH = TRIE_NODE + TRIE->JUMP[0];
                        SCAN= TRIE_NODE + TRIE->JUMP[WORD];
                        /* WE GO FROM THE JUMP POINT TO THE BRANCH THAT FOLLOWS
                           IT. NOTE THIS MEANS WE NEED THE VESTIGAL UNUSED
                           BRANCHES EVEN THOUGH THEY ARENT OTHERWISE USED. */
                        /* OPTIMISE STUDY_CHUNK() FOR TRIE */
                        MINNEXT = STUDY_CHUNK(PREXC_STATE, &SCAN, MINLENP,
                            &DELTANEXT, (REGNODE *)NEXTBRANCH, &DATA_FAKE,
                            STOPPAREN, RECURSED_DEPTH, NULL, F, DEPTH+1);
                    }
                    IF (NEXTBRANCH && PL_REGKIND[OP(NEXTBRANCH)]==BRANCH)
                        NEXTBRANCH= REGNEXT((REGNODE*)NEXTBRANCH);

                    IF (MIN1 > (SSIZE_T)(MINNEXT + TRIE->MINLEN))
                        MIN1 = MINNEXT + TRIE->MINLEN;
                    IF (DELTANEXT == SSIZE_T_MAX) {
                        IS_INF = IS_INF_INTERNAL = 1;
                        MAX1 = SSIZE_T_MAX;
                    } ELSE IF (MAX1 < (SSIZE_T)(MINNEXT + DELTANEXT + TRIE->MAXLEN))
                        MAX1 = MINNEXT + DELTANEXT + TRIE->MAXLEN;

                    IF (DATA_FAKE.FLAGS & (SF_HAS_PAR|SF_IN_PAR))
                        PARS++;
                    IF (DATA_FAKE.FLAGS & SCF_SEEN_ACCEPT) {
                        IF ( STOPMIN > MIN + MIN1)
	                    STOPMIN = MIN + MIN1;
	                FLAGS &= ~SCF_DO_SUBSTR;
	                IF (DATA)
	                    DATA->FLAGS |= SCF_SEEN_ACCEPT;
	            }
                    IF (DATA) {
                        IF (DATA_FAKE.FLAGS & SF_HAS_EVAL)
                            DATA->FLAGS |= SF_HAS_EVAL;
                        DATA->WHILEM_C = DATA_FAKE.WHILEM_C;
                    }
                    IF (FLAGS & SCF_DO_STCLASS)
                        SSC_OR(PREXC_STATE, &ACCUM, (REGNODE_CHARCLASS *) &THIS_CLASS);
                }
            }
            IF (FLAGS & SCF_DO_SUBSTR) {
                DATA->POS_MIN += MIN1;
                DATA->POS_DELTA += MAX1 - MIN1;
                IF (MAX1 != MIN1 || IS_INF)
                    DATA->CUR_IS_FLOATING = 1; /* FLOAT */
            }
            MIN += MIN1;
            IF (DELTA != SSIZE_T_MAX) {
                IF (SSIZE_T_MAX - (MAX1 - MIN1) >= DELTA)
                    DELTA += MAX1 - MIN1;
                ELSE
                    DELTA = SSIZE_T_MAX;
            }
            IF (FLAGS & SCF_DO_STCLASS_OR) {
                SSC_OR(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &ACCUM);
                IF (MIN1) {
                    SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);
                    FLAGS &= ~SCF_DO_STCLASS;
                }
            }
            ELSE IF (FLAGS & SCF_DO_STCLASS_AND) {
                IF (MIN1) {
                    SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) &ACCUM);
                    FLAGS &= ~SCF_DO_STCLASS;
                }
                ELSE {
                    /* SWITCH TO OR MODE: CACHE THE OLD VALUE OF
                     * DATA->START_CLASS */
		    INIT_AND_WITHP;
                    STRUCTCOPY(DATA->START_CLASS, AND_WITHP, REGNODE_SSC);
                    FLAGS &= ~SCF_DO_STCLASS_AND;
                    STRUCTCOPY(&ACCUM, DATA->START_CLASS, REGNODE_SSC);
                    FLAGS |= SCF_DO_STCLASS_OR;
                }
            }
            SCAN= TAIL;
            CONTINUE;
        }
#ELSE
	ELSE IF (PL_REGKIND[OP(SCAN)] == TRIE) {
	    REG_TRIE_DATA *TRIE = (REG_TRIE_DATA*)REXC_RXI->DATA->DATA[ ARG(SCAN) ];
	    U8*BANG=NULL;

	    MIN += TRIE->MINLEN;
	    DELTA += (TRIE->MAXLEN - TRIE->MINLEN);
	    FLAGS &= ~SCF_DO_STCLASS; /* XXX */
            IF (FLAGS & SCF_DO_SUBSTR) {
                /* CANNOT EXPECT ANYTHING... */
                SCAN_COMMIT(PREXC_STATE, DATA, MINLENP, IS_INF);
    	        DATA->POS_MIN += TRIE->MINLEN;
    	        DATA->POS_DELTA += (TRIE->MAXLEN - TRIE->MINLEN);
		IF (TRIE->MAXLEN != TRIE->MINLEN)
		    DATA->CUR_IS_FLOATING = 1; /* FLOAT */
    	    }
    	    IF (TRIE->JUMP) /* NO MORE SUBSTRINGS -- FOR NOW /GRR*/
               FLAGS &= ~SCF_DO_SUBSTR;
	}
#ENDIF /* OLD OR NEW */
#ENDIF /* TRIE_STUDY_OPT */

	/* ELSE: ZERO-LENGTH, IGNORE. */
	SCAN = REGNEXT(SCAN);
    }

  FINISH:
    IF (FRAME) {
        /* WE NEED TO UNWIND RECURSION. */
        DEPTH = DEPTH - 1;

        DEBUG_STUDYDATA("FRAME-END", DATA, DEPTH, IS_INF);
        DEBUG_PEEP("FEND", SCAN, DEPTH, FLAGS);

        /* RESTORE PREVIOUS CONTEXT */
        LAST = FRAME->LAST_REGNODE;
        SCAN = FRAME->NEXT_REGNODE;
        STOPPAREN = FRAME->STOPPAREN;
        RECURSED_DEPTH = FRAME->PREV_RECURSED_DEPTH;

        REXC_FRAME_LAST = FRAME->PREV_FRAME;
        FRAME = FRAME->THIS_PREV_FRAME;
        GOTO FAKE_STUDY_RECURSE;
    }

    ASSERT(!FRAME);
    DEBUG_STUDYDATA("PRE-FIN", DATA, DEPTH, IS_INF);

    *SCANP = SCAN;
    *DELTAP = IS_INF_INTERNAL ? SSIZE_T_MAX : DELTA;

    IF (FLAGS & SCF_DO_SUBSTR && IS_INF)
	DATA->POS_DELTA = SSIZE_T_MAX - DATA->POS_MIN;
    IF (IS_PAR > (I32)U8_MAX)
	IS_PAR = 0;
    IF (IS_PAR && PARS==1 && DATA) {
	DATA->FLAGS |= SF_IN_PAR;
	DATA->FLAGS &= ~SF_HAS_PAR;
    }
    ELSE IF (PARS && DATA) {
	DATA->FLAGS |= SF_HAS_PAR;
	DATA->FLAGS &= ~SF_IN_PAR;
    }
    IF (FLAGS & SCF_DO_STCLASS_OR)
	SSC_AND(PREXC_STATE, DATA->START_CLASS, (REGNODE_CHARCLASS *) AND_WITHP);
    IF (FLAGS & SCF_TRIE_RESTUDY)
        DATA->FLAGS |= 	SCF_TRIE_RESTUDY;

    DEBUG_STUDYDATA("POST-FIN", DATA, DEPTH, IS_INF);

    {
        SSIZE_T FINAL_MINLEN= MIN < STOPMIN ? MIN : STOPMIN;

        IF (!(REXC_SEEN & REG_UNBOUNDED_QUANTIFIER_SEEN)) {
            IF (FINAL_MINLEN > SSIZE_T_MAX - DELTA)
                REXC_MAXLEN = SSIZE_T_MAX;
            ELSE IF (REXC_MAXLEN < FINAL_MINLEN + DELTA)
                REXC_MAXLEN = FINAL_MINLEN + DELTA;
        }
        RETURN FINAL_MINLEN;
    }
    NOT_REACHED; /* NOTREACHED */
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 223466_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SLJIT_INLINE VOID FAST_FORWARD_FIRST_CHAR(COMPILER_COMMON *COMMON)
{
PCRE2_UCHAR FIRST_CHAR = (PCRE2_UCHAR)(COMMON->RE->FIRST_CODEUNIT);
PCRE2_UCHAR OC;

OC = FIRST_CHAR;
IF ((COMMON->RE->FLAGS & PCRE2_FIRSTCASELESS) != 0)
  {
  OC = TABLE_GET(FIRST_CHAR, COMMON->FCC, FIRST_CHAR);
#IF DEFINED SUPPORT_UNICODE
  IF (FIRST_CHAR > 127 && (COMMON->UTF || COMMON->UCP))
    OC = UCD_OTHERCASE(FIRST_CHAR);
#ENDIF
  }

FAST_FORWARD_FIRST_CHAR2(COMMON, FIRST_CHAR, OC, 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 488354_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID REMOVE_ANON_MIGRATION_PTES(STRUCT PAGE *OLD, STRUCT PAGE *NEW)
{
	STRUCT ANON_VMA *ANON_VMA;
	STRUCT VM_AREA_STRUCT *VMA;
	UNSIGNED LONG MAPPING;

	MAPPING = (UNSIGNED LONG)NEW->MAPPING;

	IF (!MAPPING || (MAPPING & PAGE_MAPPING_ANON) == 0)
		RETURN;

	/*
	 * WE HOLD THE MMAP_SEM LOCK. SO NO NEED TO CALL PAGE_LOCK_ANON_VMA.
	 */
	ANON_VMA = (STRUCT ANON_VMA *) (MAPPING - PAGE_MAPPING_ANON);
	SPIN_LOCK(&ANON_VMA->LOCK);

	LIST_FOR_EACH_ENTRY(VMA, &ANON_VMA->HEAD, ANON_VMA_NODE)
		REMOVE_MIGRATION_PTE(VMA, OLD, NEW);

	SPIN_UNLOCK(&ANON_VMA->LOCK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195692_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
    QUEUEHANDLE_T XQUEUEGENERICCREATE( CONST UBASETYPE_T UXQUEUELENGTH,

                                       CONST UBASETYPE_T UXITEMSIZE,

                                       CONST UINT8_T UCQUEUETYPE )

    {

        QUEUE_T * PXNEWQUEUE;

        SIZE_T XQUEUESIZEINBYTES;

        UINT8_T * PUCQUEUESTORAGE;



        CONFIGASSERT( UXQUEUELENGTH > ( UBASETYPE_T ) 0 );



        /* ALLOCATE ENOUGH SPACE TO HOLD THE MAXIMUM NUMBER OF ITEMS THAT

         * CAN BE IN THE QUEUE AT ANY TIME.  IT IS VALID FOR UXITEMSIZE TO BE

         * ZERO IN THE CASE THE QUEUE IS USED AS A SEMAPHORE. */

        XQUEUESIZEINBYTES = ( SIZE_T ) ( UXQUEUELENGTH * UXITEMSIZE ); /*LINT !E961 MISRA EXCEPTION AS THE CASTS ARE ONLY REDUNDANT FOR SOME PORTS. */



        /* CHECK FOR MULTIPLICATION OVERFLOW. */

        CONFIGASSERT( ( UXITEMSIZE == 0 ) || ( UXQUEUELENGTH == ( XQUEUESIZEINBYTES / UXITEMSIZE ) ) );



        /* ALLOCATE THE QUEUE AND STORAGE AREA.  JUSTIFICATION FOR MISRA

         * DEVIATION AS FOLLOWS:  PVPORTMALLOC() ALWAYS ENSURES RETURNED MEMORY

         * BLOCKS ARE ALIGNED PER THE REQUIREMENTS OF THE MCU STACK.  IN THIS CASE

         * PVPORTMALLOC() MUST RETURN A POINTER THAT IS GUARANTEED TO MEET THE

         * ALIGNMENT REQUIREMENTS OF THE QUEUE_T STRUCTURE - WHICH IN THIS CASE

         * IS AN INT8_T *.  THEREFORE, WHENEVER THE STACK ALIGNMENT REQUIREMENTS

         * ARE GREATER THAN OR EQUAL TO THE POINTER TO CHAR REQUIREMENTS THE CAST

         * IS SAFE.  IN OTHER CASES ALIGNMENT REQUIREMENTS ARE NOT STRICT (ONE OR

         * TWO BYTES). */

        PXNEWQUEUE = ( QUEUE_T * ) PVPORTMALLOC( SIZEOF( QUEUE_T ) + XQUEUESIZEINBYTES ); /*LINT !E9087 !E9079 SEE COMMENT ABOVE. */



        IF( PXNEWQUEUE != NULL )

        {

            /* JUMP PAST THE QUEUE STRUCTURE TO FIND THE LOCATION OF THE QUEUE

             * STORAGE AREA. */

            PUCQUEUESTORAGE = ( UINT8_T * ) PXNEWQUEUE;

            PUCQUEUESTORAGE += SIZEOF( QUEUE_T ); /*LINT !E9016 POINTER ARITHMETIC ALLOWED ON CHAR TYPES, ESPECIALLY WHEN IT ASSISTS CONVEYING INTENT. */



            #IF ( CONFIGSUPPORT_STATIC_ALLOCATION == 1 )

                {

                    /* QUEUES CAN BE CREATED EITHER STATICALLY OR DYNAMICALLY, SO

                     * NOTE THIS TASK WAS CREATED DYNAMICALLY IN CASE IT IS LATER

                     * DELETED. */

                    PXNEWQUEUE->UCSTATICALLYALLOCATED = PDFALSE;

                }

            #ENDIF /* CONFIGSUPPORT_STATIC_ALLOCATION */



            PRVINITIALISENEWQUEUE( UXQUEUELENGTH, UXITEMSIZE, PUCQUEUESTORAGE, UCQUEUETYPE, PXNEWQUEUE );

        }

        ELSE

        {

            TRACEQUEUE_CREATE_FAILED( UCQUEUETYPE );

            MTCOVERAGE_TEST_MARKER();

        }



        RETURN PXNEWQUEUE;

    }

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359386_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (CLEAR_BGP_ALL_IN_PREFIX_FILTER,
       CLEAR_BGP_ALL_IN_PREFIX_FILTER_CMD,
       "CLEAR BGP * IN PREFIX-FILTER",
       CLEAR_STR
       BGP_STR
       "CLEAR ALL PEERS\N"
       "SOFT RECONFIG INBOUND UPDATE\N"
       "PUSH OUT PREFIX-LIST ORF AND DO INBOUND SOFT RECONFIG\N")
{
  RETURN BGP_CLEAR_VTY (VTY, NULL, AFI_IP6, SAFI_UNICAST, CLEAR_ALL,
			BGP_CLEAR_SOFT_IN_ORF_PREFIX, NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205734_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PYC_OBJECT *GET_COMPLEX_OBJECT(RZBINPYCOBJ *PYC, RZBUFFER *BUFFER) {
	PYC_OBJECT *RET = NULL;
	BOOL ERROR = FALSE;
	UT32 SIZE = 0;
	UT32 N1 = 0;
	UT32 N2 = 0;

	RET = RZ_NEW0(PYC_OBJECT);
	IF (!RET) {
		RETURN NULL;
	}

	IF ((PYC->MAGIC_INT & 0XFFFF) <= 62061) {
		N1 = GET_UT8(BUFFER, &ERROR);
	} ELSE {
		N1 = GET_ST32(BUFFER, &ERROR);
	}
	IF (ERROR) {
		FREE(RET);
		RETURN NULL;
	}
	UT8 *S1 = MALLOC(N1 + 1);
	IF (!S1) {
		RETURN NULL;
	}
	/* OBJECT CONTAIN STRING REPRESENTATION OF THE NUMBER */
	SIZE = RZ_BUF_READ(BUFFER, S1, N1);
	IF (SIZE != N1) {
		RZ_FREE(S1);
		RZ_FREE(RET);
		RETURN NULL;
	}
	S1[N1] = '\0';

	IF ((PYC->MAGIC_INT & 0XFFFF) <= 62061) {
		N2 = GET_UT8(BUFFER, &ERROR);
	} ELSE
		N2 = GET_ST32(BUFFER, &ERROR);
	IF (ERROR) {
		RETURN NULL;
	}
	UT8 *S2 = MALLOC(N2 + 1);
	IF (!S2) {
		RETURN NULL;
	}
	/* OBJECT CONTAIN STRING REPRESENTATION OF THE NUMBER */
	SIZE = RZ_BUF_READ(BUFFER, S2, N2);
	IF (SIZE != N2) {
		RZ_FREE(S1);
		RZ_FREE(S2);
		RZ_FREE(RET);
		RETURN NULL;
	}
	S2[N2] = '\0';

	RET->TYPE = TYPE_COMPLEX;
	RET->DATA = RZ_STR_NEWF("%S+%SJ", S1, S2);
	RZ_FREE(S1);
	RZ_FREE(S2);
	IF (!RET->DATA) {
		RZ_FREE(RET);
		RETURN NULL;
	}
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 413686_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID HINT_NODE_FREE(RBNODE *NODE, VOID *USER) {
	FREE (CONTAINER_OF (NODE, HINTNODE, RB));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 223090_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SIZE_T PCLPACKBITSCOMPRESSIMAGE(CONST SIZE_T LENGTH,
  CONST UNSIGNED CHAR *PIXELS,UNSIGNED CHAR *COMPRESS_PIXELS)
{
  INT
    COUNT;

  SSIZE_T
    X;

  UNSIGNED CHAR
    *Q;

  SSIZE_T
    J;

  UNSIGNED CHAR
    PACKBITS[128];

  /*
    COMPRESS PIXELS WITH PACKBITS ENCODING.
  */
  Q=COMPRESS_PIXELS;
  FOR (X=(SSIZE_T) LENGTH; X != 0; )
  {
    SWITCH (X)
    {
      CASE 1:
      {
        X--;
        *Q++=0;
        *Q++=(*PIXELS);
        BREAK;
      }
      CASE 2:
      {
        X-=2;
        *Q++=1;
        *Q++=(*PIXELS);
        *Q++=PIXELS[1];
        BREAK;
      }
      CASE 3:
      {
        X-=3;
        IF ((*PIXELS == *(PIXELS+1)) && (*(PIXELS+1) == *(PIXELS+2)))
          {
            *Q++=(UNSIGNED CHAR) ((256-3)+1);
            *Q++=(*PIXELS);
            BREAK;
          }
        *Q++=2;
        *Q++=(*PIXELS);
        *Q++=PIXELS[1];
        *Q++=PIXELS[2];
        BREAK;
      }
      DEFAULT:
      {
        IF ((*PIXELS == *(PIXELS+1)) && (*(PIXELS+1) == *(PIXELS+2)))
          {
            /*
              PACKED RUN.
            */
            COUNT=3;
            WHILE (((SSIZE_T) COUNT < X) && (*PIXELS == *(PIXELS+COUNT)))
            {
              COUNT++;
              IF (COUNT >= 127)
                BREAK;
            }
            X-=COUNT;
            *Q++=(UNSIGNED CHAR) ((256-COUNT)+1);
            *Q++=(*PIXELS);
            PIXELS+=COUNT;
            BREAK;
          }
        /*
          LITERAL RUN.
        */
        COUNT=0;
        WHILE ((*(PIXELS+COUNT) != *(PIXELS+COUNT+1)) ||
               (*(PIXELS+COUNT+1) != *(PIXELS+COUNT+2)))
        {
          PACKBITS[COUNT+1]=PIXELS[COUNT];
          COUNT++;
          IF (((SSIZE_T) COUNT >= (X-3)) || (COUNT >= 127))
            BREAK;
        }
        X-=COUNT;
        *PACKBITS=(UNSIGNED CHAR) (COUNT-1);
        FOR (J=0; J <= (SSIZE_T) COUNT; J++)
          *Q++=PACKBITS[J];
        PIXELS+=COUNT;
        BREAK;
      }
    }
  }
  *Q++=128; /* EOD MARKER */
  RETURN((SIZE_T) (Q-COMPRESS_PIXELS));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 310000_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NPOP(VOID)
{
    INT RESULT = 0;
    IF (TPS(STACK_PTR) > 0) {
	TPS(STACK_PTR)--;
	IF (TPS(STACK)[TPS(STACK_PTR)].NUM_TYPE)
	    RESULT = TPS(STACK)[TPS(STACK_PTR)].DATA.NUM;
    } ELSE {
	DEBUG(2, ("NPOP: STACK UNDERFLOW: %S", _NC_VISBUF(TPS(TPARAM_BASE))));
	_NC_TPARM_ERR++;
    }
    RETURN RESULT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 262722_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_ARRAY_ITERATOR_NEXT(NJS_VM_T *VM, NJS_VALUE_T *ITERATOR,
    NJS_VALUE_T *RETVAL)
{
    INT64_T               LENGTH;
    NJS_INT_T             RET;
    NJS_ARRAY_T           *ARRAY, *ENTRY;
    NJS_TYPED_ARRAY_T     *TARRAY;
    CONST NJS_VALUE_T     *VALUE;
    NJS_ARRAY_ITERATOR_T  *IT;

    IF (NJS_SLOW_PATH(!NJS_IS_VALID(NJS_OBJECT_VALUE(ITERATOR)))) {
        RETURN NJS_DECLINED;
    }

    IT = NJS_OBJECT_DATA(ITERATOR);
    VALUE = &NJS_VALUE_UNDEFINED;

    IF (NJS_IS_FAST_ARRAY(&IT->TARGET)) {
        ARRAY = NJS_ARRAY(&IT->TARGET);
        LENGTH = ARRAY->LENGTH;

        IF (IT->NEXT >= LENGTH) {
            GOTO RELEASE;
        }

        IF (IT->KIND > NJS_ENUM_KEYS && NJS_IS_VALID(&ARRAY->START[IT->NEXT])) {
            VALUE = &ARRAY->START[IT->NEXT];
        }

    } ELSE IF (NJS_IS_TYPED_ARRAY(&IT->TARGET)) {
        TARRAY = NJS_TYPED_ARRAY(&IT->TARGET);

        IF (NJS_SLOW_PATH(NJS_IS_DETACHED_BUFFER(TARRAY->BUFFER))) {
            NJS_TYPE_ERROR(VM, "DETACHED BUFFER");
            RETURN NJS_ERROR;
        }

        LENGTH = NJS_TYPED_ARRAY_LENGTH(TARRAY);

        IF (IT->NEXT >= LENGTH) {
            GOTO RELEASE;
        }

        IF (IT->KIND > NJS_ENUM_KEYS) {
            NJS_SET_NUMBER(RETVAL, NJS_TYPED_ARRAY_PROP(TARRAY, IT->NEXT));
            VALUE = RETVAL;
        }

    } ELSE {
        RET = NJS_OBJECT_LENGTH(VM, &IT->TARGET, &LENGTH);
        IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
            RETURN RET;
        }

        IF (IT->NEXT >= LENGTH) {
            GOTO RELEASE;
        }

        IF (IT->KIND > NJS_ENUM_KEYS) {
            RET = NJS_VALUE_PROPERTY_I64(VM, &IT->TARGET, IT->NEXT, RETVAL);
            IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                RETURN RET;
            }

            VALUE = NJS_IS_VALID(RETVAL) ? RETVAL
                                         : &NJS_VALUE_UNDEFINED;
        }
    }

    SWITCH (IT->KIND) {
    CASE NJS_ENUM_KEYS:
        NJS_SET_NUMBER(RETVAL, IT->NEXT++);
        BREAK;

    CASE NJS_ENUM_VALUES:
        IT->NEXT++;
        *RETVAL = *VALUE;
        BREAK;

    CASE NJS_ENUM_BOTH:
        ENTRY = NJS_ARRAY_ALLOC(VM, 0, 2, 0);
        IF (NJS_SLOW_PATH(ENTRY == NULL)) {
            RETURN NJS_ERROR;
        }

        NJS_SET_NUMBER(&ENTRY->START[0], IT->NEXT++);
        ENTRY->START[1] = *VALUE;

        NJS_SET_ARRAY(RETVAL, ENTRY);
        BREAK;

    DEFAULT:
        NJS_INTERNAL_ERROR(VM, "INVALID ENUM KIND");
        RETURN NJS_ERROR;
    }

    RETURN NJS_OK;

RELEASE:

    /* GC RELEASE IT->TARGET */
    NJS_MP_FREE(VM->MEM_POOL, IT);
    NJS_SET_INVALID(NJS_OBJECT_VALUE(ITERATOR));

    RETURN NJS_DECLINED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226126_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_ERR REFTYPE_BOX_SIZE(GF_BOX *S)
{
	GF_TRACKREFERENCETYPEBOX *PTR = (GF_TRACKREFERENCETYPEBOX *)S;
	IF (PTR->TRACKIDCOUNT)
		PTR->SIZE += (PTR->TRACKIDCOUNT * SIZEOF(U32));
	RETURN GF_OK;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 405382_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID XFRM_BYDST_RESIZE(STRUCT NET *NET, INT DIR)
{
	UNSIGNED INT HMASK = NET->XFRM.POLICY_BYDST[DIR].HMASK;
	UNSIGNED INT NHASHMASK = XFRM_NEW_HASH_MASK(HMASK);
	UNSIGNED INT NSIZE = (NHASHMASK + 1) * SIZEOF(STRUCT HLIST_HEAD);
	STRUCT HLIST_HEAD *NDST = XFRM_HASH_ALLOC(NSIZE);
	STRUCT HLIST_HEAD *ODST;
	INT I;

	IF (!NDST)
		RETURN;

	SPIN_LOCK_BH(&NET->XFRM.XFRM_POLICY_LOCK);
	WRITE_SEQCOUNT_BEGIN(&NET->XFRM.XFRM_POLICY_HASH_GENERATION);

	ODST = RCU_DEREFERENCE_PROTECTED(NET->XFRM.POLICY_BYDST[DIR].TABLE,
				LOCKDEP_IS_HELD(&NET->XFRM.XFRM_POLICY_LOCK));

	FOR (I = HMASK; I >= 0; I--)
		XFRM_DST_HASH_TRANSFER(NET, ODST + I, NDST, NHASHMASK, DIR);

	RCU_ASSIGN_POINTER(NET->XFRM.POLICY_BYDST[DIR].TABLE, NDST);
	NET->XFRM.POLICY_BYDST[DIR].HMASK = NHASHMASK;

	WRITE_SEQCOUNT_END(&NET->XFRM.XFRM_POLICY_HASH_GENERATION);
	SPIN_UNLOCK_BH(&NET->XFRM.XFRM_POLICY_LOCK);

	SYNCHRONIZE_RCU();

	XFRM_HASH_FREE(ODST, (HMASK + 1) * SIZEOF(STRUCT HLIST_HEAD));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215188_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MOBI_BUFFER_MOVE(MOBIBUFFER *BUF, CONST INT OFFSET, CONST SIZE_T LEN) {
    SIZE_T AOFFSET = (SIZE_T) ABS(OFFSET);
    UNSIGNED CHAR *SOURCE = BUF->DATA + BUF->OFFSET;
    IF (OFFSET >= 0) {
        IF (BUF->OFFSET + AOFFSET + LEN > BUF->MAXLEN) {
            DEBUG_PRINT("%S", "END OF BUFFER\N");
            BUF->ERROR = MOBI_BUFFER_END;
            RETURN;
        }
        SOURCE += AOFFSET;
    } ELSE {
        IF (BUF->OFFSET < AOFFSET) {
            DEBUG_PRINT("%S", "END OF BUFFER\N");
            BUF->ERROR = MOBI_BUFFER_END;
            RETURN;
        }
        SOURCE -= AOFFSET;
    }
    MEMMOVE(BUF->DATA + BUF->OFFSET, SOURCE, LEN);
    BUF->OFFSET += LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 293499_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC UNSIGNED INT GIF_INTERLACED_LINE(INT HEIGHT, INT Y) {
        IF ((Y << 3) < HEIGHT) {
                RETURN (Y << 3);
        }
        Y -= ((HEIGHT + 7) >> 3);
        IF ((Y << 3) < (HEIGHT - 4)) {
                RETURN (Y << 3) + 4;
        }
        Y -= ((HEIGHT + 3) >> 3);
        IF ((Y << 2) < (HEIGHT - 2)) {
                RETURN (Y << 2) + 2;
        }
        Y -= ((HEIGHT + 1) >> 2);
        RETURN (Y << 1) + 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 233823_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID FMTUTIL_READ_ATARI_PALETTE(DEARK *C, DBUF *F, I64 POS,
	DE_COLOR *DSTPAL, I64 NCOLORS_TO_READ, I64 NCOLORS_USED, UNSIGNED INT FLAGS)
{
	I64 I;
	UNSIGNED INT N;
	INT PAL_BITS = 0; // 9, 12, OR 15. 0 = NOT YET DETERMINED
	U8 CR, CG, CB;
	U8 CR1, CG1, CB1;
	CHAR CBUF[32];
	CHAR TMPS[64];
	CONST CHAR *S;

	S = DE_GET_EXT_OPTION(C, "ATARI:PALBITS");
	IF(S) {
		PAL_BITS = DE_ATOI(S);
	}

	IF(PAL_BITS==0 && (FLAGS&DE_FLAG_ATARI_15BIT_PAL)) {
		PAL_BITS = 15;
	}

	IF(PAL_BITS==0) {
		// PRE-SCAN THE PALETTE, AND TRY TO GUESS WHETHER ATARI STE-STYLE 12-BIT
		// COLORS ARE USED, INSTEAD OF THE USUAL 9-BIT COLORS.
		// I DON'T KNOW THE BEST WAY TO DO THIS. SOMETIMES THE 4TH BIT IN EACH
		// NIBBLE IS USED FOR EXTRA COLOR DETAIL, AND SOMETIMES IT JUST SEEMS TO
		// CONTAIN GARBAGE. MAYBE THE LOGIC SHOULD ALSO DEPEND ON THE FILE
		// FORMAT, OR THE NUMBER OF COLORS.
		INT BIT_3_USED = 0;
		INT NIBBLE_3_USED = 0;

		FOR(I=0; I<NCOLORS_TO_READ; I++) {
			N = (UNSIGNED INT)DBUF_GETU16BE(F, POS + I*2);
			IF(N&0XF000) {
				NIBBLE_3_USED = 1;
			}
			IF(N&0X0888) {
				BIT_3_USED = 1;
			}
		}

		IF(BIT_3_USED && !NIBBLE_3_USED) {
			DE_DBG(C, "12-BIT PALETTE COLORS DETECTED");
			PAL_BITS = 12;
		}
	}

	IF(PAL_BITS<12) { // DEFAULT TO 9 IF <12
		PAL_BITS = 9;
	}
	ELSE IF(PAL_BITS<15) {
		PAL_BITS = 12;
	}
	ELSE {
		PAL_BITS = 15;
	}

	FOR(I=0; I<NCOLORS_TO_READ; I++) {
		N = (UNSIGNED INT)DBUF_GETU16BE(F, POS + 2*I);

		IF(PAL_BITS==15) {
			CR1 = (U8)((N>>6)&0X1C);
			IF(N&0X0800) CR1+=2;
			IF(N&0X8000) CR1++;
			CG1 = (U8)((N>>2)&0X1C);
			IF(N&0X0080) CG1+=2;
			IF(N&0X4000) CG1++;
			CB1 = (U8)((N<<2)&0X1C);
			IF(N&0X0008) CB1+=2;
			IF(N&0X2000) CB1++;
			CR = DE_SCALE_N_TO_255(31, CR1);
			CG = DE_SCALE_N_TO_255(31, CG1);
			CB = DE_SCALE_N_TO_255(31, CB1);
			DE_SNPRINTF(CBUF, SIZEOF(CBUF), "%2D,%2D,%2D",
				(INT)CR1, (INT)CG1, (INT)CB1);
		}
		ELSE IF(PAL_BITS==12) {
			CR1 = (U8)((N>>7)&0X0E);
			IF(N&0X800) CR1++;
			CG1 = (U8)((N>>3)&0X0E);
			IF(N&0X080) CG1++;
			CB1 = (U8)((N<<1)&0X0E);
			IF(N&0X008) CB1++;
			CR = SCALE_15_TO_255(CR1);
			CG = SCALE_15_TO_255(CG1);
			CB = SCALE_15_TO_255(CB1);
			DE_SNPRINTF(CBUF, SIZEOF(CBUF), "%2D,%2D,%2D",
				(INT)CR1, (INT)CG1, (INT)CB1);
		}
		ELSE {
			CR1 = (U8)((N>>8)&0X07);
			CG1 = (U8)((N>>4)&0X07);
			CB1 = (U8)(N&0X07);
			CR = SCALE_7_TO_255(CR1);
			CG = SCALE_7_TO_255(CG1);
			CB = SCALE_7_TO_255(CB1);
			DE_SNPRINTF(CBUF, SIZEOF(CBUF), "%D,%D,%D",
				(INT)CR1, (INT)CG1, (INT)CB1);
		}

		DSTPAL[I] = DE_MAKE_RGB(CR, CG, CB);
		DE_SNPRINTF(TMPS, SIZEOF(TMPS), "0X%04X (%S) "DE_CHAR_RIGHTARROW" ", N, CBUF);
		DE_DBG_PAL_ENTRY2(C, I, DSTPAL[I], TMPS, NULL,
			(I>=NCOLORS_USED)?" [UNUSED]":"");
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225780_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_BOX *FIIN_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(FDITEMINFORMATIONBOX, GF_ISOM_BOX_TYPE_FIIN);
	RETURN (GF_BOX *)TMP;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209102_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_MOUSE(
    OPARG_T	*OAP,		// OPERATOR ARGUMENT, CAN BE NULL
    INT		C,		// K_LEFTMOUSE, ETC
    INT		DIR,		// DIRECTION TO 'PUT' IF NECESSARY
    LONG	COUNT,
    INT		FIXINDENT)	// PUT_FIXINDENT IF FIXING INDENT NECESSARY
{
    STATIC INT	DO_ALWAYS = FALSE;	// IGNORE 'MOUSE' SETTING NEXT TIME
    STATIC INT	GOT_CLICK = FALSE;	// GOT A CLICK SOME TIME BACK

    INT		WHICH_BUTTON;	// MOUSE_LEFT, _MIDDLE OR _RIGHT
    INT		IS_CLICK = FALSE; // IF FALSE IT'S A DRAG OR RELEASE EVENT
    INT		IS_DRAG = FALSE;  // IF TRUE IT'S A DRAG EVENT
    INT		JUMP_FLAGS = 0;	// FLAGS FOR JUMP_TO_MOUSE()
    POS_T	START_VISUAL;
    INT		MOVED;		// HAS CURSOR MOVED?
    INT		IN_STATUS_LINE;	// MOUSE IN STATUS LINE
    STATIC INT	IN_TAB_LINE = FALSE; // MOUSE CLICKED IN TAB LINE
    INT		IN_SEP_LINE;	// MOUSE IN VERTICAL SEPARATOR LINE
    INT		C1, C2;
#IF DEFINED(FEAT_FOLDING)
    POS_T	SAVE_CURSOR;
#ENDIF
    WIN_T	*OLD_CURWIN = CURWIN;
    STATIC POS_T ORIG_CURSOR;
    COLNR_T	LEFTCOL, RIGHTCOL;
    POS_T	END_VISUAL;
    INT		DIFF;
    INT		OLD_ACTIVE = VISUAL_ACTIVE;
    INT		OLD_MODE = VISUAL_MODE;
    INT		REGNAME;

#IF DEFINED(FEAT_FOLDING)
    SAVE_CURSOR = CURWIN->W_CURSOR;
#ENDIF

    // WHEN GUI IS ACTIVE, ALWAYS RECOGNIZE MOUSE EVENTS, OTHERWISE:
    // - IGNORE MOUSE EVENT IN NORMAL MODE IF 'MOUSE' DOESN'T INCLUDE 'N'.
    // - IGNORE MOUSE EVENT IN VISUAL MODE IF 'MOUSE' DOESN'T INCLUDE 'V'.
    // - FOR COMMAND LINE AND INSERT MODE 'MOUSE' IS CHECKED BEFORE CALLING
    //	 DO_MOUSE().
    IF (DO_ALWAYS)
	DO_ALWAYS = FALSE;
    ELSE
#IFDEF FEAT_GUI
	IF (!GUI.IN_USE)
#ENDIF
	{
	    IF (VISUAL_ACTIVE)
	    {
		IF (!MOUSE_HAS(MOUSE_VISUAL))
		    RETURN FALSE;
	    }
	    ELSE IF (STATE == MODE_NORMAL && !MOUSE_HAS(MOUSE_NORMAL))
		RETURN FALSE;
	}

    FOR (;;)
    {
	WHICH_BUTTON = GET_MOUSE_BUTTON(KEY2TERMCAP1(C), &IS_CLICK, &IS_DRAG);
	IF (IS_DRAG)
	{
	    // IF THE NEXT CHARACTER IS THE SAME MOUSE EVENT THEN USE THAT
	    // ONE. SPEEDS UP DRAGGING THE STATUS LINE.
	    // NOTE: SINCE CHARACTERS ADDED TO THE STUFF BUFFER IN THE CODE
	    // BELOW NEED TO COME BEFORE THE NEXT CHARACTER, DO NOT DO THIS
	    // WHEN THE CURRENT CHARACTER WAS STUFFED.
	    IF (!KEYSTUFFED && VPEEKC() != NUL)
	    {
		INT NC;
		INT SAVE_MOUSE_ROW = MOUSE_ROW;
		INT SAVE_MOUSE_COL = MOUSE_COL;

		// NEED TO GET THE CHARACTER, PEEKING DOESN'T GET THE ACTUAL
		// ONE.
		NC = SAFE_VGETC();
		IF (C == NC)
		    CONTINUE;
		VUNGETC(NC);
		MOUSE_ROW = SAVE_MOUSE_ROW;
		MOUSE_COL = SAVE_MOUSE_COL;
	    }
	}
	BREAK;
    }

    IF (C == K_MOUSEMOVE)
    {
	// MOUSE MOVED WITHOUT A BUTTON PRESSED.
#IFDEF FEAT_BEVAL_TERM
	UI_MAY_REMOVE_BALLOON();
	IF (P_BEVALTERM)
	{
	    PROFILE_SETLIMIT(P_BDLAY, &BEVALEXPR_DUE);
	    BEVALEXPR_DUE_SET = TRUE;
	}
#ENDIF
#IFDEF FEAT_PROP_POPUP
	POPUP_HANDLE_MOUSE_MOVED();
#ENDIF
	RETURN FALSE;
    }

#IFDEF FEAT_MOUSESHAPE
    // MAY HAVE STOPPED DRAGGING THE STATUS OR SEPARATOR LINE.  THE POINTER IS
    // MOST LIKELY STILL ON THE STATUS OR SEPARATOR LINE.
    IF (!IS_DRAG && DRAG_STATUS_LINE)
    {
	DRAG_STATUS_LINE = FALSE;
	UPDATE_MOUSESHAPE(SHAPE_IDX_STATUS);
    }
    IF (!IS_DRAG && DRAG_SEP_LINE)
    {
	DRAG_SEP_LINE = FALSE;
	UPDATE_MOUSESHAPE(SHAPE_IDX_VSEP);
    }
#ENDIF

    // IGNORE DRAG AND RELEASE EVENTS IF WE DIDN'T GET A CLICK.
    IF (IS_CLICK)
	GOT_CLICK = TRUE;
    ELSE
    {
	IF (!GOT_CLICK)			// DIDN'T GET CLICK, IGNORE
	    RETURN FALSE;
	IF (!IS_DRAG)			// RELEASE, RESET GOT_CLICK
	{
	    GOT_CLICK = FALSE;
	    IF (IN_TAB_LINE)
	    {
		IN_TAB_LINE = FALSE;
		RETURN FALSE;
	    }
	}
    }

    // CTRL RIGHT MOUSE BUTTON DOES CTRL-T
    IF (IS_CLICK && (MOD_MASK & MOD_MASK_CTRL) && WHICH_BUTTON == MOUSE_RIGHT)
    {
	IF (STATE & MODE_INSERT)
	    STUFFCHARREADBUFF(CTRL_O);
	IF (COUNT > 1)
	    STUFFNUMREADBUFF(COUNT);
	STUFFCHARREADBUFF(CTRL_T);
	GOT_CLICK = FALSE;		// IGNORE DRAG&RELEASE NOW
	RETURN FALSE;
    }

    // CTRL ONLY WORKS WITH LEFT MOUSE BUTTON
    IF ((MOD_MASK & MOD_MASK_CTRL) && WHICH_BUTTON != MOUSE_LEFT)
	RETURN FALSE;

    // WHEN A MODIFIER IS DOWN, IGNORE DRAG AND RELEASE EVENTS, AS WELL AS
    // MULTIPLE CLICKS AND THE MIDDLE MOUSE BUTTON.
    // ACCEPT SHIFT-LEFTMOUSE DRAGS WHEN 'MOUSEMODEL' IS "POPUP.*".
    IF ((MOD_MASK & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT
							     | MOD_MASK_META))
	    && (!IS_CLICK
		|| (MOD_MASK & MOD_MASK_MULTI_CLICK)
		|| WHICH_BUTTON == MOUSE_MIDDLE)
	    && !((MOD_MASK & (MOD_MASK_SHIFT|MOD_MASK_ALT))
		&& MOUSE_MODEL_POPUP()
		&& WHICH_BUTTON == MOUSE_LEFT)
	    && !((MOD_MASK & MOD_MASK_ALT)
		&& !MOUSE_MODEL_POPUP()
		&& WHICH_BUTTON == MOUSE_RIGHT)
	    )
	RETURN FALSE;

    // IF THE BUTTON PRESS WAS USED AS THE MOVEMENT COMMAND FOR AN OPERATOR
    // (EG "D<MOUSE>"), OR IT IS THE MIDDLE BUTTON THAT IS HELD DOWN, IGNORE
    // DRAG/RELEASE EVENTS.
    IF (!IS_CLICK && WHICH_BUTTON == MOUSE_MIDDLE)
	RETURN FALSE;

    IF (OAP != NULL)
	REGNAME = OAP->REGNAME;
    ELSE
	REGNAME = 0;

    // MIDDLE MOUSE BUTTON DOES A 'PUT' OF THE SELECTED TEXT
    IF (WHICH_BUTTON == MOUSE_MIDDLE)
    {
	IF (STATE == MODE_NORMAL)
	{
	    // IF AN OPERATOR WAS PENDING, WE DON'T KNOW WHAT THE USER WANTED
	    // TO DO. GO BACK TO NORMAL MODE: CLEAR THE OPERATOR AND BEEP().
	    IF (OAP != NULL && OAP->OP_TYPE != OP_NOP)
	    {
		CLEAROPBEEP(OAP);
		RETURN FALSE;
	    }

	    // IF VISUAL WAS ACTIVE, YANK THE HIGHLIGHTED TEXT AND PUT IT
	    // BEFORE THE MOUSE POINTER POSITION.
	    // IN SELECT MODE REPLACE THE HIGHLIGHTED TEXT WITH THE CLIPBOARD.
	    IF (VISUAL_ACTIVE)
	    {
		IF (VISUAL_SELECT)
		{
		    STUFFCHARREADBUFF(CTRL_G);
		    STUFFREADBUFF((CHAR_U *)"\"+P");
		}
		ELSE
		{
		    STUFFCHARREADBUFF('Y');
		    STUFFCHARREADBUFF(K_MIDDLEMOUSE);
		}
		DO_ALWAYS = TRUE;	// IGNORE 'MOUSE' SETTING NEXT TIME
		RETURN FALSE;
	    }
	    // THE REST IS BELOW JUMP_TO_MOUSE()
	}

	ELSE IF ((STATE & MODE_INSERT) == 0)
	    RETURN FALSE;

	// MIDDLE CLICK IN INSERT MODE DOESN'T MOVE THE MOUSE, JUST INSERT THE
	// CONTENTS OF A REGISTER.  '.' REGISTER IS SPECIAL, CAN'T INSERT THAT
	// WITH DO_PUT().
	// ALSO PASTE AT THE CURSOR IF THE CURRENT MODE ISN'T IN 'MOUSE' (ONLY
	// HAPPENS FOR THE GUI).
	IF ((STATE & MODE_INSERT) || !MOUSE_HAS(MOUSE_NORMAL))
	{
	    IF (REGNAME == '.')
		INSERT_REG(REGNAME, TRUE);
	    ELSE
	    {
#IFDEF FEAT_CLIPBOARD
		IF (CLIP_STAR.AVAILABLE && REGNAME == 0)
		    REGNAME = '*';
#ENDIF
		IF ((STATE & REPLACE_FLAG) && !YANK_REGISTER_MLINE(REGNAME))
		    INSERT_REG(REGNAME, TRUE);
		ELSE
		{
		    DO_PUT(REGNAME, NULL, BACKWARD, 1L,
						      FIXINDENT | PUT_CURSEND);

		    // REPEAT IT WITH CTRL-R CTRL-O R OR CTRL-R CTRL-P R
		    APPENDCHARTOREDOBUFF(CTRL_R);
		    APPENDCHARTOREDOBUFF(FIXINDENT ? CTRL_P : CTRL_O);
		    APPENDCHARTOREDOBUFF(REGNAME == 0 ? '"' : REGNAME);
		}
	    }
	    RETURN FALSE;
	}
    }

    // WHEN DRAGGING OR BUTTON-UP STAY IN THE SAME WINDOW.
    IF (!IS_CLICK)
	JUMP_FLAGS |= MOUSE_FOCUS | MOUSE_DID_MOVE;

    START_VISUAL.LNUM = 0;

    // CHECK FOR CLICKING IN THE TAB PAGE LINE.
    IF (MOUSE_ROW == 0 && FIRSTWIN->W_WINROW > 0)
    {
	IF (IS_DRAG)
	{
	    IF (IN_TAB_LINE)
	    {
		C1 = TABPAGEIDXS[MOUSE_COL];
		TABPAGE_MOVE(C1 <= 0 ? 9999 : C1 < TABPAGE_INDEX(CURTAB)
								? C1 - 1 : C1);
	    }
	    RETURN FALSE;
	}

	// CLICK IN A TAB SELECTS THAT TAB PAGE
	IF (IS_CLICK
# IFDEF FEAT_CMDWIN
		&& CMDWIN_TYPE == 0
# ENDIF
		&& MOUSE_COL < COLUMNS)
	{
	    IN_TAB_LINE = TRUE;
	    C1 = TABPAGEIDXS[MOUSE_COL];
	    IF (C1 >= 0)
	    {
		IF ((MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
		{
		    // DOUBLE CLICK OPENS NEW PAGE
		    END_VISUAL_MODE_KEEP_BUTTON();
		    TABPAGE_NEW();
		    TABPAGE_MOVE(C1 == 0 ? 9999 : C1 - 1);
		}
		ELSE
		{
		    // GO TO SPECIFIED TAB PAGE, OR NEXT ONE IF NOT CLICKING
		    // ON A LABEL.
		    GOTO_TABPAGE(C1);

		    // IT'S LIKE CLICKING ON THE STATUS LINE OF A WINDOW.
		    IF (CURWIN != OLD_CURWIN)
			END_VISUAL_MODE_KEEP_BUTTON();
		}
	    }
	    ELSE
	    {
		TABPAGE_T	*TP;

		// CLOSE THE CURRENT OR SPECIFIED TAB PAGE.
		IF (C1 == -999)
		    TP = CURTAB;
		ELSE
		    TP = FIND_TABPAGE(-C1);
		IF (TP == CURTAB)
		{
		    IF (FIRST_TABPAGE->TP_NEXT != NULL)
			TABPAGE_CLOSE(FALSE);
		}
		ELSE IF (TP != NULL)
		    TABPAGE_CLOSE_OTHER(TP, FALSE);
	    }
	}
	RETURN TRUE;
    }
    ELSE IF (IS_DRAG && IN_TAB_LINE)
    {
	C1 = TABPAGEIDXS[MOUSE_COL];
	TABPAGE_MOVE(C1 <= 0 ? 9999 : C1 - 1);
	RETURN FALSE;
    }

    // WHEN 'MOUSEMODEL' IS "POPUP" OR "POPUP_SETPOS", TRANSLATE MOUSE EVENTS:
    // RIGHT BUTTON UP   -> POP-UP MENU
    // SHIFT-LEFT BUTTON -> RIGHT BUTTON
    // ALT-LEFT BUTTON   -> ALT-RIGHT BUTTON
    IF (MOUSE_MODEL_POPUP())
    {
	IF (WHICH_BUTTON == MOUSE_RIGHT
			    && !(MOD_MASK & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
	{
#IFDEF USE_POPUP_SETPOS
# IFDEF FEAT_GUI
	    IF (GUI.IN_USE)
	    {
#  IF DEFINED(FEAT_GUI_MOTIF) || DEFINED(FEAT_GUI_GTK) \
			  || DEFINED(FEAT_GUI_PHOTON)
		IF (!IS_CLICK)
		    // IGNORE RIGHT BUTTON RELEASE EVENTS, ONLY SHOWS THE POPUP
		    // MENU ON THE BUTTON DOWN EVENT.
		    RETURN FALSE;
#  ENDIF
#  IF DEFINED(FEAT_GUI_MSWIN) || DEFINED(FEAT_GUI_HAIKU)
		IF (IS_CLICK || IS_DRAG)
		    // IGNORE RIGHT BUTTON DOWN AND DRAG MOUSE EVENTS.  WINDOWS
		    // ONLY SHOWS THE POPUP MENU ON THE BUTTON UP EVENT.
		    RETURN FALSE;
#  ENDIF
	    }
# ENDIF
# IF DEFINED(FEAT_GUI) && DEFINED(FEAT_TERM_POPUP_MENU)
	    ELSE
# ENDIF
# IF DEFINED(FEAT_TERM_POPUP_MENU)
	    IF (!IS_CLICK)
		// IGNORE RIGHT BUTTON RELEASE EVENTS, ONLY SHOWS THE POPUP
		// MENU ON THE BUTTON DOWN EVENT.
		RETURN FALSE;
#ENDIF

	    JUMP_FLAGS = 0;
	    IF (STRCMP(P_MOUSEM, "POPUP_SETPOS") == 0)
	    {
		// FIRST SET THE CURSOR POSITION BEFORE SHOWING THE POPUP
		// MENU.
		IF (VISUAL_ACTIVE)
		{
		    POS_T    M_POS;

		    // SET MOUSE_MAY_STOP_VIS IF WE ARE OUTSIDE THE
		    // SELECTION OR THE CURRENT WINDOW (MIGHT HAVE FALSE
		    // NEGATIVE HERE)
		    IF (MOUSE_ROW < CURWIN->W_WINROW
			 || MOUSE_ROW
				  > (CURWIN->W_WINROW + CURWIN->W_HEIGHT))
			JUMP_FLAGS = MOUSE_MAY_STOP_VIS;
		    ELSE IF (GET_FPOS_OF_MOUSE(&M_POS) != IN_BUFFER)
			JUMP_FLAGS = MOUSE_MAY_STOP_VIS;
		    ELSE
		    {
			IF ((LT_POS(CURWIN->W_CURSOR, VISUAL)
				    && (LT_POS(M_POS, CURWIN->W_CURSOR)
					|| LT_POS(VISUAL, M_POS)))
				|| (LT_POS(VISUAL, CURWIN->W_CURSOR)
				    && (LT_POS(M_POS, VISUAL)
				      || LT_POS(CURWIN->W_CURSOR, M_POS))))
			{
			    JUMP_FLAGS = MOUSE_MAY_STOP_VIS;
			}
			ELSE IF (VISUAL_MODE == CTRL_V)
			{
			    GETVCOLS(CURWIN, &CURWIN->W_CURSOR, &VISUAL,
						     &LEFTCOL, &RIGHTCOL);
			    GETVCOL(CURWIN, &M_POS, NULL, &M_POS.COL, NULL);
			    IF (M_POS.COL < LEFTCOL || M_POS.COL > RIGHTCOL)
				JUMP_FLAGS = MOUSE_MAY_STOP_VIS;
			}
		    }
		}
		ELSE
		    JUMP_FLAGS = MOUSE_MAY_STOP_VIS;
	    }
	    IF (JUMP_FLAGS)
	    {
		JUMP_FLAGS = JUMP_TO_MOUSE(JUMP_FLAGS, NULL, WHICH_BUTTON);
		UPDATE_CURBUF(VISUAL_ACTIVE ? UPD_INVERTED : UPD_VALID);
		SETCURSOR();
		OUT_FLUSH();    // UPDATE BEFORE SHOWING POPUP MENU
	    }
# IFDEF FEAT_MENU
	    SHOW_POPUPMENU();
	    GOT_CLICK = FALSE;	// IGNORE RELEASE EVENTS
# ENDIF
	    RETURN (JUMP_FLAGS & CURSOR_MOVED) != 0;
#ELSE
	    RETURN FALSE;
#ENDIF
	}
	IF (WHICH_BUTTON == MOUSE_LEFT
				&& (MOD_MASK & (MOD_MASK_SHIFT|MOD_MASK_ALT)))
	{
	    WHICH_BUTTON = MOUSE_RIGHT;
	    MOD_MASK &= ~MOD_MASK_SHIFT;
	}
    }

    IF ((STATE & (MODE_NORMAL | MODE_INSERT))
			    && !(MOD_MASK & (MOD_MASK_SHIFT | MOD_MASK_CTRL)))
    {
	IF (WHICH_BUTTON == MOUSE_LEFT)
	{
	    IF (IS_CLICK)
	    {
		// STOP VISUAL MODE FOR A LEFT CLICK IN A WINDOW, BUT NOT WHEN
		// ON A STATUS LINE
		IF (VISUAL_ACTIVE)
		    JUMP_FLAGS |= MOUSE_MAY_STOP_VIS;
	    }
	    ELSE IF (MOUSE_HAS(MOUSE_VISUAL))
		JUMP_FLAGS |= MOUSE_MAY_VIS;
	}
	ELSE IF (WHICH_BUTTON == MOUSE_RIGHT)
	{
	    IF (IS_CLICK && VISUAL_ACTIVE)
	    {
		// REMEMBER THE START AND END OF VISUAL BEFORE MOVING THE
		// CURSOR.
		IF (LT_POS(CURWIN->W_CURSOR, VISUAL))
		{
		    START_VISUAL = CURWIN->W_CURSOR;
		    END_VISUAL = VISUAL;
		}
		ELSE
		{
		    START_VISUAL = VISUAL;
		    END_VISUAL = CURWIN->W_CURSOR;
		}
	    }
	    JUMP_FLAGS |= MOUSE_FOCUS;
	    IF (MOUSE_HAS(MOUSE_VISUAL))
		JUMP_FLAGS |= MOUSE_MAY_VIS;
	}
    }

    // IF AN OPERATOR IS PENDING, IGNORE ALL DRAGS AND RELEASES UNTIL THE
    // NEXT MOUSE CLICK.
    IF (!IS_DRAG && OAP != NULL && OAP->OP_TYPE != OP_NOP)
    {
	GOT_CLICK = FALSE;
	OAP->MOTION_TYPE = MCHAR;
    }

    // WHEN RELEASING THE BUTTON LET JUMP_TO_MOUSE() KNOW.
    IF (!IS_CLICK && !IS_DRAG)
	JUMP_FLAGS |= MOUSE_RELEASED;

    // JUMP!
    JUMP_FLAGS = JUMP_TO_MOUSE(JUMP_FLAGS,
			OAP == NULL ? NULL : &(OAP->INCLUSIVE), WHICH_BUTTON);

#IFDEF FEAT_MENU
    // A CLICK IN THE WINDOW TOOLBAR HAS NO SIDE EFFECTS.
    IF (JUMP_FLAGS & MOUSE_WINBAR)
	RETURN FALSE;
#ENDIF
    MOVED = (JUMP_FLAGS & CURSOR_MOVED);
    IN_STATUS_LINE = (JUMP_FLAGS & IN_STATUS_LINE);
    IN_SEP_LINE = (JUMP_FLAGS & IN_SEP_LINE);

#IFDEF FEAT_NETBEANS_INTG
    IF (ISNETBEANSBUFFER(CURBUF)
			    && !(JUMP_FLAGS & (IN_STATUS_LINE | IN_SEP_LINE)))
    {
	INT KEY = KEY2TERMCAP1(C);

	IF (KEY == (INT)KE_LEFTRELEASE || KEY == (INT)KE_MIDDLERELEASE
					       || KEY == (INT)KE_RIGHTRELEASE)
	    NETBEANS_BUTTON_RELEASE(WHICH_BUTTON);
    }
#ENDIF

    // WHEN JUMPING TO ANOTHER WINDOW, CLEAR A PENDING OPERATOR.  THAT'S A BIT
    // FRIENDLIER THAN BEEPING AND NOT JUMPING TO THAT WINDOW.
    IF (CURWIN != OLD_CURWIN && OAP != NULL && OAP->OP_TYPE != OP_NOP)
	CLEAROP(OAP);

#IFDEF FEAT_FOLDING
    IF (MOD_MASK == 0
	    && !IS_DRAG
	    && (JUMP_FLAGS & (MOUSE_FOLD_CLOSE | MOUSE_FOLD_OPEN))
	    && WHICH_BUTTON == MOUSE_LEFT)
    {
	// OPEN OR CLOSE A FOLD AT THIS LINE
	IF (JUMP_FLAGS & MOUSE_FOLD_OPEN)
	    OPENFOLD(CURWIN->W_CURSOR.LNUM, 1L);
	ELSE
	    CLOSEFOLD(CURWIN->W_CURSOR.LNUM, 1L);
	// DON'T MOVE THE CURSOR IF STILL IN THE SAME WINDOW
	IF (CURWIN == OLD_CURWIN)
	    CURWIN->W_CURSOR = SAVE_CURSOR;
    }
#ENDIF

#IF DEFINED(FEAT_CLIPBOARD) && DEFINED(FEAT_CMDWIN)
    IF ((JUMP_FLAGS & IN_OTHER_WIN) && !VISUAL_ACTIVE && CLIP_STAR.AVAILABLE)
    {
	CLIP_MODELESS(WHICH_BUTTON, IS_CLICK, IS_DRAG);
	RETURN FALSE;
    }
#ENDIF

    // SET GLOBAL FLAG THAT WE ARE EXTENDING THE VISUAL AREA WITH MOUSE
    // DRAGGING; TEMPORARILY MINIMIZE 'SCROLLOFF'.
    IF (VISUAL_ACTIVE && IS_DRAG && GET_SCROLLOFF_VALUE())
    {
	// IN THE VERY FIRST LINE, ALLOW SCROLLING ONE LINE
	IF (MOUSE_ROW == 0)
	    MOUSE_DRAGGING = 2;
	ELSE
	    MOUSE_DRAGGING = 1;
    }

    // WHEN DRAGGING THE MOUSE ABOVE THE WINDOW, SCROLL DOWN.
    IF (IS_DRAG && MOUSE_ROW < 0 && !IN_STATUS_LINE)
    {
	SCROLL_REDRAW(FALSE, 1L);
	MOUSE_ROW = 0;
    }

    IF (START_VISUAL.LNUM)		// RIGHT CLICK IN VISUAL MODE
    {
       // WHEN ALT IS PRESSED MAKE VISUAL MODE BLOCKWISE.
       IF (MOD_MASK & MOD_MASK_ALT)
	   VISUAL_MODE = CTRL_V;

	// IN VISUAL-BLOCK MODE, DIVIDE THE AREA IN FOUR, PICK UP THE CORNER
	// THAT IS IN THE QUARTER THAT THE CURSOR IS IN.
	IF (VISUAL_MODE == CTRL_V)
	{
	    GETVCOLS(CURWIN, &START_VISUAL, &END_VISUAL, &LEFTCOL, &RIGHTCOL);
	    IF (CURWIN->W_CURSWANT > (LEFTCOL + RIGHTCOL) / 2)
		END_VISUAL.COL = LEFTCOL;
	    ELSE
		END_VISUAL.COL = RIGHTCOL;
	    IF (CURWIN->W_CURSOR.LNUM >=
				    (START_VISUAL.LNUM + END_VISUAL.LNUM) / 2)
		END_VISUAL.LNUM = START_VISUAL.LNUM;

	    // MOVE VISUAL TO THE RIGHT COLUMN
	    START_VISUAL = CURWIN->W_CURSOR;	    // SAVE THE CURSOR POS
	    CURWIN->W_CURSOR = END_VISUAL;
	    COLADVANCE(END_VISUAL.COL);
	    VISUAL = CURWIN->W_CURSOR;
	    CURWIN->W_CURSOR = START_VISUAL;	    // RESTORE THE CURSOR
	}
	ELSE
	{
	    // IF THE CLICK IS BEFORE THE START OF VISUAL, CHANGE THE START.
	    // IF THE CLICK IS AFTER THE END OF VISUAL, CHANGE THE END.  IF
	    // THE CLICK IS INSIDE THE VISUAL, CHANGE THE CLOSEST SIDE.
	    IF (LT_POS(CURWIN->W_CURSOR, START_VISUAL))
		VISUAL = END_VISUAL;
	    ELSE IF (LT_POS(END_VISUAL, CURWIN->W_CURSOR))
		VISUAL = START_VISUAL;
	    ELSE
	    {
		// IN THE SAME LINE, COMPARE COLUMN NUMBER
		IF (END_VISUAL.LNUM == START_VISUAL.LNUM)
		{
		    IF (CURWIN->W_CURSOR.COL - START_VISUAL.COL >
				    END_VISUAL.COL - CURWIN->W_CURSOR.COL)
			VISUAL = START_VISUAL;
		    ELSE
			VISUAL = END_VISUAL;
		}

		// IN DIFFERENT LINES, COMPARE LINE NUMBER
		ELSE
		{
		    DIFF = (CURWIN->W_CURSOR.LNUM - START_VISUAL.LNUM) -
				(END_VISUAL.LNUM - CURWIN->W_CURSOR.LNUM);

		    IF (DIFF > 0)		// CLOSEST TO END
			VISUAL = START_VISUAL;
		    ELSE IF (DIFF < 0)	// CLOSEST TO START
			VISUAL = END_VISUAL;
		    ELSE			// IN THE MIDDLE LINE
		    {
			IF (CURWIN->W_CURSOR.COL <
					(START_VISUAL.COL + END_VISUAL.COL) / 2)
			    VISUAL = END_VISUAL;
			ELSE
			    VISUAL = START_VISUAL;
		    }
		}
	    }
	}
    }
    // IF VISUAL MODE STARTED IN INSERT MODE, EXECUTE "CTRL-O"
    ELSE IF ((STATE & MODE_INSERT) && VISUAL_ACTIVE)
	STUFFCHARREADBUFF(CTRL_O);

    // MIDDLE MOUSE CLICK: PUT TEXT BEFORE CURSOR.
    IF (WHICH_BUTTON == MOUSE_MIDDLE)
    {
#IFDEF FEAT_CLIPBOARD
	IF (CLIP_STAR.AVAILABLE && REGNAME == 0)
	    REGNAME = '*';
#ENDIF
	IF (YANK_REGISTER_MLINE(REGNAME))
	{
	    IF (MOUSE_PAST_BOTTOM)
		DIR = FORWARD;
	}
	ELSE IF (MOUSE_PAST_EOL)
	    DIR = FORWARD;

	IF (FIXINDENT)
	{
	    C1 = (DIR == BACKWARD) ? '[' : ']';
	    C2 = 'P';
	}
	ELSE
	{
	    C1 = (DIR == FORWARD) ? 'P' : 'P';
	    C2 = NUL;
	}
	PREP_REDO(REGNAME, COUNT, NUL, C1, NUL, C2, NUL);

	// REMEMBER WHERE THE PASTE STARTED, SO IN EDIT() INSSTART CAN BE SET
	// TO THIS POSITION
	IF (RESTART_EDIT != 0)
	    WHERE_PASTE_STARTED = CURWIN->W_CURSOR;
	DO_PUT(REGNAME, NULL, DIR, COUNT, FIXINDENT | PUT_CURSEND);
    }

#IF DEFINED(FEAT_QUICKFIX)
    // CTRL-MOUSE CLICK OR DOUBLE CLICK IN A QUICKFIX WINDOW JUMPS TO THE
    // ERROR UNDER THE MOUSE POINTER.
    ELSE IF (((MOD_MASK & MOD_MASK_CTRL)
		|| (MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
	    && BT_QUICKFIX(CURBUF))
    {
	IF (CURWIN->W_LLIST_REF == NULL)	// QUICKFIX WINDOW
	    DO_CMDLINE_CMD((CHAR_U *)".CC");
	ELSE					// LOCATION LIST WINDOW
	    DO_CMDLINE_CMD((CHAR_U *)".LL");
	GOT_CLICK = FALSE;		// IGNORE DRAG&RELEASE NOW
    }
#ENDIF

    // CTRL-MOUSE CLICK (OR DOUBLE CLICK IN A HELP WINDOW) JUMPS TO THE TAG
    // UNDER THE MOUSE POINTER.
    ELSE IF ((MOD_MASK & MOD_MASK_CTRL) || (CURBUF->B_HELP
		     && (MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))
    {
	IF (STATE & MODE_INSERT)
	    STUFFCHARREADBUFF(CTRL_O);
	STUFFCHARREADBUFF(CTRL_RSB);
	GOT_CLICK = FALSE;		// IGNORE DRAG&RELEASE NOW
    }

    // SHIFT-MOUSE CLICK SEARCHES FOR THE NEXT OCCURRENCE OF THE WORD UNDER
    // THE MOUSE POINTER
    ELSE IF ((MOD_MASK & MOD_MASK_SHIFT))
    {
	IF ((STATE & MODE_INSERT) || (VISUAL_ACTIVE && VISUAL_SELECT))
	    STUFFCHARREADBUFF(CTRL_O);
	IF (WHICH_BUTTON == MOUSE_LEFT)
	    STUFFCHARREADBUFF('*');
	ELSE	// MOUSE_RIGHT
	    STUFFCHARREADBUFF('#');
    }

    // HANDLE DOUBLE CLICKS, UNLESS ON STATUS LINE
    ELSE IF (IN_STATUS_LINE)
    {
#IFDEF FEAT_MOUSESHAPE
	IF ((IS_DRAG || IS_CLICK) && !DRAG_STATUS_LINE)
	{
	    DRAG_STATUS_LINE = TRUE;
	    UPDATE_MOUSESHAPE(-1);
	}
#ENDIF
    }
    ELSE IF (IN_SEP_LINE)
    {
#IFDEF FEAT_MOUSESHAPE
	IF ((IS_DRAG || IS_CLICK) && !DRAG_SEP_LINE)
	{
	    DRAG_SEP_LINE = TRUE;
	    UPDATE_MOUSESHAPE(-1);
	}
#ENDIF
    }
    ELSE IF ((MOD_MASK & MOD_MASK_MULTI_CLICK)
				       && (STATE & (MODE_NORMAL | MODE_INSERT))
	     && MOUSE_HAS(MOUSE_VISUAL))
    {
	IF (IS_CLICK || !VISUAL_ACTIVE)
	{
	    IF (VISUAL_ACTIVE)
		ORIG_CURSOR = VISUAL;
	    ELSE
	    {
		CHECK_VISUAL_HIGHLIGHT();
		VISUAL = CURWIN->W_CURSOR;
		ORIG_CURSOR = VISUAL;
		VISUAL_ACTIVE = TRUE;
		VISUAL_RESELECT = TRUE;
		// START SELECT MODE IF 'SELECTMODE' CONTAINS "MOUSE"
		MAY_START_SELECT('O');
		SETMOUSE();
	    }
	    IF ((MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
	    {
		// DOUBLE CLICK WITH ALT PRESSED MAKES IT BLOCKWISE.
		IF (MOD_MASK & MOD_MASK_ALT)
		    VISUAL_MODE = CTRL_V;
		ELSE
		    VISUAL_MODE = 'V';
	    }
	    ELSE IF ((MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)
		VISUAL_MODE = 'V';
	    ELSE IF ((MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)
		VISUAL_MODE = CTRL_V;
#IFDEF FEAT_CLIPBOARD
	    // MAKE SURE THE CLIPBOARD GETS UPDATED.  NEEDED BECAUSE START AND
	    // END MAY STILL BE THE SAME, AND THE SELECTION NEEDS TO BE OWNED
	    CLIP_STAR.VMODE = NUL;
#ENDIF
	}
	// A DOUBLE CLICK SELECTS A WORD OR A BLOCK.
	IF ((MOD_MASK & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)
	{
	    POS_T	*POS = NULL;
	    INT		GC;

	    IF (IS_CLICK)
	    {
		// IF THE CHARACTER UNDER THE CURSOR (SKIPPING WHITE SPACE) IS
		// NOT A WORD CHARACTER, TRY FINDING A MATCH AND SELECT A (),
		// {}, [], #IF/#ENDIF, ETC. BLOCK.
		END_VISUAL = CURWIN->W_CURSOR;
		WHILE (GC = GCHAR_POS(&END_VISUAL), VIM_ISWHITE(GC))
		    INC(&END_VISUAL);
		IF (OAP != NULL)
		    OAP->MOTION_TYPE = MCHAR;
		IF (OAP != NULL
			&& VISUAL_MODE == 'V'
			&& !VIM_ISWORDC(GCHAR_POS(&END_VISUAL))
			&& EQUAL_POS(CURWIN->W_CURSOR, VISUAL)
			&& (POS = FINDMATCH(OAP, NUL)) != NULL)
		{
		    CURWIN->W_CURSOR = *POS;
		    IF (OAP->MOTION_TYPE == MLINE)
			VISUAL_MODE = 'V';
		    ELSE IF (*P_SEL == 'E')
		    {
			IF (LT_POS(CURWIN->W_CURSOR, VISUAL))
			    ++VISUAL.COL;
			ELSE
			    ++CURWIN->W_CURSOR.COL;
		    }
		}
	    }

	    IF (POS == NULL && (IS_CLICK || IS_DRAG))
	    {
		// WHEN NOT FOUND A MATCH OR WHEN DRAGGING: EXTEND TO INCLUDE
		// A WORD.
		IF (LT_POS(CURWIN->W_CURSOR, ORIG_CURSOR))
		{
		    FIND_START_OF_WORD(&CURWIN->W_CURSOR);
		    FIND_END_OF_WORD(&VISUAL);
		}
		ELSE
		{
		    FIND_START_OF_WORD(&VISUAL);
		    IF (*P_SEL == 'E' && *ML_GET_CURSOR() != NUL)
			CURWIN->W_CURSOR.COL +=
					 (*MB_PTR2LEN)(ML_GET_CURSOR());
		    FIND_END_OF_WORD(&CURWIN->W_CURSOR);
		}
	    }
	    CURWIN->W_SET_CURSWANT = TRUE;
	}
	IF (IS_CLICK)
	    REDRAW_CURBUF_LATER(UPD_INVERTED);	// UPDATE THE INVERSION
    }
    ELSE IF (VISUAL_ACTIVE && !OLD_ACTIVE)
    {
	IF (MOD_MASK & MOD_MASK_ALT)
	    VISUAL_MODE = CTRL_V;
	ELSE
	    VISUAL_MODE = 'V';
    }

    // IF VISUAL MODE CHANGED SHOW IT LATER.
    IF ((!VISUAL_ACTIVE && OLD_ACTIVE && MODE_DISPLAYED)
	    || (VISUAL_ACTIVE && P_SMD && MSG_SILENT == 0
				 && (!OLD_ACTIVE || VISUAL_MODE != OLD_MODE)))
	REDRAW_CMDLINE = TRUE;

    RETURN MOVED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195800_CWE-369.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID FMTUTIL_MACBITMAP_READ_PIXMAP_ONLY_FIELDS(DEARK *C, DBUF *F, STRUCT FMTUTIL_MACBITMAP_INFO *BI,
	I64 POS)
{
	I64 PIXMAP_VERSION;
	I64 PACK_SIZE;
	I64 PLANE_BYTES;
	I64 N;

	DE_DBG(C, "ADDITIONAL PIXMAP HEADER FIELDS, AT %D", (INT)POS);
	DE_DBG_INDENT(C, 1);

	PIXMAP_VERSION = DBUF_GETU16BE(F, POS+0);
	DE_DBG(C, "PIXMAP VERSION: %D", (INT)PIXMAP_VERSION);

	BI->PACKING_TYPE = DBUF_GETU16BE(F, POS+2);
	DE_DBG(C, "PACKING TYPE: %D", (INT)BI->PACKING_TYPE);

	PACK_SIZE = DBUF_GETU32BE(F, POS+4);
	DE_DBG(C, "PIXEL DATA LENGTH: %D", (INT)PACK_SIZE);

	BI->HDPI = PICT_READ_FIXED(F, POS+8);
	BI->VDPI = PICT_READ_FIXED(F, POS+12);
	DE_DBG(C, "DPI: %.2F"DE_CHAR_TIMES"%.2F", BI->HDPI, BI->VDPI);

	BI->PIXELTYPE = DBUF_GETU16BE(F, POS+16);
	BI->PIXELSIZE = DBUF_GETU16BE(F, POS+18);
	BI->CMPCOUNT = DBUF_GETU16BE(F, POS+20);
	BI->CMPSIZE = DBUF_GETU16BE(F, POS+22);
	DE_DBG(C, "PIXEL TYPE=%D, BITS/PIXEL=%D, COMPONENTS/PIXEL=%D, BITS/COMP=%D",
		(INT)BI->PIXELTYPE, (INT)BI->PIXELSIZE, (INT)BI->CMPCOUNT, (INT)BI->CMPSIZE);

	BI->PDWIDTH = (BI->ROWBYTES*8)/BI->PIXELSIZE;
	IF(BI->PDWIDTH < BI->NPWIDTH) {
		BI->PDWIDTH = BI->NPWIDTH;
	}

	PLANE_BYTES = DBUF_GETU32BE(F, POS+24);
	DE_DBG(C, "PLANE BYTES: %D", (INT)PLANE_BYTES);

	BI->PMTABLE = (U32)DBUF_GETU32BE(F, POS+28);
	DE_DBG(C, "PMTABLE: 0X%08X", (UNSIGNED INT)BI->PMTABLE);

	N = DBUF_GETU32BE(F, POS+32);
	DE_DBG(C, "PMRESERVED: 0X%08X", (UNSIGNED INT)N);

	DE_DBG_INDENT(C, -1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199712_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID RTRS_CLT_DEV_RELEASE(STRUCT DEVICE *DEV)
{
	STRUCT RTRS_CLT_SESS *CLT = CONTAINER_OF(DEV, STRUCT RTRS_CLT_SESS,
						 DEV);

	KFREE(CLT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210420_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FILL_THRESHHOLD_BUFFER(BYTE *DEST_STRIP, BYTE *SRC_STRIP, INT SRC_WIDTH,
                       INT LEFT_OFFSET, INT LEFT_WIDTH, INT NUM_TILES,
                       INT RIGHT_WIDTH)
{
    BYTE *PTR_OUT_TEMP = DEST_STRIP;
    INT II;

    /* LEFT PART */
    MEMCPY(DEST_STRIP, SRC_STRIP + LEFT_OFFSET, LEFT_WIDTH);
    PTR_OUT_TEMP += LEFT_WIDTH;
    /* NOW THE FULL PARTS */
    FOR (II = 0; II < NUM_TILES; II++){
        MEMCPY(PTR_OUT_TEMP, SRC_STRIP, SRC_WIDTH);
        PTR_OUT_TEMP += SRC_WIDTH;
    }
    /* NOW THE REMAINDER */
    MEMCPY(PTR_OUT_TEMP, SRC_STRIP, RIGHT_WIDTH);
#IFDEF PACIFY_VALGRIND
    PTR_OUT_TEMP += RIGHT_WIDTH;
    II = (DEST_STRIP-PTR_OUT_TEMP) % (LAND_BITS-1);
    IF (II > 0)
        MEMSET(PTR_OUT_TEMP, 0, II);
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196817_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_ARRAY_CONVERT_TO_SLOW_ARRAY(NJS_VM_T *VM, NJS_ARRAY_T *ARRAY)
{
    UINT32_T           I, LENGTH;
    NJS_VALUE_T        INDEX, VALUE;
    NJS_OBJECT_PROP_T  *PROP;

    NJS_SET_ARRAY(&VALUE, ARRAY);
    ARRAY->OBJECT.FAST_ARRAY = 0;

    LENGTH = ARRAY->LENGTH;

    FOR (I = 0; I < LENGTH; I++) {
        IF (NJS_IS_VALID(&ARRAY->START[I])) {
            NJS_UINT32_TO_STRING(&INDEX, I);
            PROP = NJS_OBJECT_PROPERTY_ADD(VM, &VALUE, &INDEX, 0);
            IF (NJS_SLOW_PATH(PROP == NULL)) {
                RETURN NJS_ERROR;
            }

            PROP->VALUE = ARRAY->START[I];
        }
    }

    /* GC: RELEASE VALUE. */

    NJS_MP_FREE(VM->MEM_POOL, ARRAY->START);
    ARRAY->START = NULL;

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 329876_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
_BLIT_XRGB32_LERP_SPANS (VOID *ABSTRACT_RENDERER, INT Y, INT H,
			 CONST CAIRO_HALF_OPEN_SPAN_T *SPANS, UNSIGNED NUM_SPANS)
{
    CAIRO_IMAGE_SPAN_RENDERER_T *R = ABSTRACT_RENDERER;

    IF (NUM_SPANS == 0)
	RETURN CAIRO_STATUS_SUCCESS;

    IF (LIKELY(H == 1)) {
	UINT8_T *SRC = R->U.BLIT.SRC_DATA + Y*R->U.BLIT.SRC_STRIDE;
	UINT8_T *DST = R->U.BLIT.DATA + Y*R->U.BLIT.STRIDE;
	DO {
	    UINT8_T A = MUL8_8 (SPANS[0].COVERAGE, R->BPP);
	    IF (A) {
		UINT32_T *S = (UINT32_T*)SRC + SPANS[0].X;
		UINT32_T *D = (UINT32_T*)DST + SPANS[0].X;
		INT LEN = SPANS[1].X - SPANS[0].X;
		IF (A == 0XFF) {
		    IF (LEN == 1)
			*D = *S;
		    ELSE
			MEMCPY(D, S, LEN*4);
		} ELSE {
		    WHILE (LEN-- > 0) {
			*D = LERP8X4 (*S, A, *D);
			S++, D++;
		    }
		}
	    }
	    SPANS++;
	} WHILE (--NUM_SPANS > 1);
    } ELSE {
	DO {
	    UINT8_T A = MUL8_8 (SPANS[0].COVERAGE, R->BPP);
	    IF (A) {
		INT YY = Y, HH = H;
		DO {
		    UINT32_T *S = (UINT32_T *)(R->U.BLIT.SRC_DATA + YY*R->U.BLIT.SRC_STRIDE + SPANS[0].X * 4);
		    UINT32_T *D = (UINT32_T *)(R->U.BLIT.DATA + YY*R->U.BLIT.STRIDE + SPANS[0].X * 4);
		    INT LEN = SPANS[1].X - SPANS[0].X;
		    IF (A == 0XFF) {
			IF (LEN == 1)
			    *D = *S;
			ELSE
			    MEMCPY(D, S, LEN * 4);
		    } ELSE {
			WHILE (LEN-- > 0) {
			    *D = LERP8X4 (*S, A, *D);
			    S++, D++;
			}
		    }
		    YY++;
		} WHILE (--HH);
	    }
	    SPANS++;
	} WHILE (--NUM_SPANS > 1);
    }

    RETURN CAIRO_STATUS_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225832_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR HMHD_BOX_SIZE(GF_BOX *S)
{
	GF_HINTMEDIAHEADERBOX *PTR = (GF_HINTMEDIAHEADERBOX *)S;
	PTR->SIZE += 16;
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 272338_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID CMS_SET_PW_CALLBACK(CMS_CONTEXT *CMS, PK11PASSWORDFUNC FUNC)
{
	CMS->FUNC = FUNC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212165_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SYNIC_SET_IRQ(STRUCT KVM_VCPU_HV_SYNIC *SYNIC, U32 SINT)
{
	STRUCT KVM_VCPU *VCPU = HV_SYNIC_TO_VCPU(SYNIC);
	STRUCT KVM_LAPIC_IRQ IRQ;
	INT RET, VECTOR;

	IF (SINT >= ARRAY_SIZE(SYNIC->SINT))
		RETURN -EINVAL;

	VECTOR = SYNIC_GET_SINT_VECTOR(SYNIC_READ_SINT(SYNIC, SINT));
	IF (VECTOR < 0)
		RETURN -ENOENT;

	MEMSET(&IRQ, 0, SIZEOF(IRQ));
	IRQ.SHORTHAND = APIC_DEST_SELF;
	IRQ.DEST_MODE = APIC_DEST_PHYSICAL;
	IRQ.DELIVERY_MODE = APIC_DM_FIXED;
	IRQ.VECTOR = VECTOR;
	IRQ.LEVEL = 1;

	RET = KVM_IRQ_DELIVERY_TO_APIC(VCPU->KVM, VCPU->ARCH.APIC, &IRQ, NULL);
	TRACE_KVM_HV_SYNIC_SET_IRQ(VCPU->VCPU_ID, SINT, IRQ.VECTOR, RET);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220425_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_ARY_JOIN(MRB_STATE *MRB, MRB_VALUE ARY, MRB_VALUE SEP)
{
  IF (!MRB_NIL_P(SEP)) {
    SEP = MRB_OBJ_AS_STRING(MRB, SEP);
  }
  RETURN JOIN_ARY(MRB, ARY, SEP, MRB_ARY_NEW(MRB));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195338_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID NALUDMX_QUEUE_PARAM_SET(GF_NALUDMXCTX *CTX, CHAR *DATA, U32 SIZE, U32 PS_TYPE, S32 PS_ID)
{
	GF_LIST *LIST = NULL, *ALT_LIST = NULL;
	GF_NALUFFPARAM *SL;
	U32 I, COUNT;
	U32 CRC = GF_CRC_32(DATA, SIZE);

	IF (CTX->CODECID==GF_CODECID_HEVC) {
		SWITCH (PS_TYPE) {
		CASE GF_HEVC_NALU_VID_PARAM:
			IF (!CTX->VPS) CTX->VPS = GF_LIST_NEW();
			LIST = CTX->VPS;
			BREAK;
		CASE GF_HEVC_NALU_SEQ_PARAM:
			LIST = CTX->SPS;
			BREAK;
		CASE GF_HEVC_NALU_PIC_PARAM:
			LIST = CTX->PPS;
			BREAK;
		DEFAULT:
			ASSERT(0);
			RETURN;
		}
	} ELSE IF (CTX->CODECID==GF_CODECID_VVC) {
		SWITCH (PS_TYPE) {
		CASE GF_VVC_NALU_VID_PARAM:
			IF (!CTX->VPS) CTX->VPS = GF_LIST_NEW();
			LIST = CTX->VPS;
			BREAK;
		CASE GF_VVC_NALU_SEQ_PARAM:
			LIST = CTX->SPS;
			BREAK;
		CASE GF_VVC_NALU_PIC_PARAM:
			LIST = CTX->PPS;
			BREAK;
		CASE GF_VVC_NALU_DEC_PARAM:
			IF (!CTX->VVC_DCI) CTX->VVC_DCI = GF_LIST_NEW();
			LIST = CTX->VVC_DCI;
			BREAK;
		CASE GF_VVC_NALU_APS_PREFIX:
			IF (!CTX->VVC_APS_PRE) CTX->VVC_APS_PRE = GF_LIST_NEW();
			LIST = CTX->VVC_APS_PRE;
			BREAK;
		DEFAULT:
			ASSERT(0);
			RETURN;
		}
	} ELSE {
		SWITCH (PS_TYPE) {
		CASE GF_AVC_NALU_SVC_SUBSEQ_PARAM:
		CASE GF_AVC_NALU_SEQ_PARAM:
			LIST = CTX->SPS;
			BREAK;
		CASE GF_AVC_NALU_PIC_PARAM:
			LIST = CTX->PPS;
			ALT_LIST = CTX->PPS_SVC;
			BREAK;
		CASE GF_AVC_NALU_SEQ_PARAM_EXT:
			IF (!CTX->SPS_EXT) CTX->SPS_EXT = GF_LIST_NEW();
			LIST = CTX->SPS_EXT;
			BREAK;
		DEFAULT:
			ASSERT(0);
			RETURN;
		}
	}
	SL = NULL;
	COUNT = GF_LIST_COUNT(LIST);
	FOR (I=0; I<COUNT; I++) {
		SL = GF_LIST_GET(LIST, I);
		IF (SL->ID != PS_ID) {
			SL = NULL;
			CONTINUE;
		}
		//SAME ID, SAME CRC, WE DON'T CHANGE OUR STATE
		IF (SL->CRC == CRC) RETURN;
		BREAK;
	}
	//HANDLE ALT PPS LIST FOR SVC
	IF (!SL && ALT_LIST) {
		COUNT = GF_LIST_COUNT(ALT_LIST);
		FOR (I=0; I<COUNT; I++) {
			SL = GF_LIST_GET(ALT_LIST, I);
			IF (SL->ID != PS_ID) {
				SL = NULL;
				CONTINUE;
			}
			//SAME ID, SAME CRC, WE DON'T CHANGE OUR STATE
			IF (SL->CRC == CRC) RETURN;
			BREAK;
		}
	}

	IF (SL) {
		//OTHERWISE WE KEEP THIS NEW PARAM SET
		SL->DATA = GF_REALLOC(SL->DATA, SIZE);
		MEMCPY(SL->DATA, DATA, SIZE);
		SL->SIZE = SIZE;
		SL->CRC = CRC;
		CTX->PS_MODIFIED = GF_TRUE;
		RETURN;
	}
	//TODO WE MIGHT WANT TO PURGE THE LIST AFTER A WHILE !!

	GF_SAFEALLOC(SL, GF_NALUFFPARAM);
	IF (!SL) RETURN;
	SL->DATA = GF_MALLOC(SIZEOF(CHAR) * SIZE);
	IF (!SL->DATA) {
		GF_FREE(SL);
		RETURN;
	}
	MEMCPY(SL->DATA, DATA, SIZE);
	SL->SIZE = SIZE;
	SL->ID = PS_ID;
	SL->CRC = CRC;

	CTX->PS_MODIFIED = GF_TRUE;
	GF_LIST_ADD(LIST, SL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206815_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MAGICKBOOLEANTYPE SETGRAYSCALEIMAGE(IMAGE *IMAGE,
  EXCEPTIONINFO *EXCEPTION)
{
  CACHEVIEW
    *IMAGE_VIEW;

  MAGICKBOOLEANTYPE
    STATUS;

  PIXELINFO
    *COLORMAP;

  REGISTER SSIZE_T
    I;

  SSIZE_T
    *COLORMAP_INDEX,
    J,
    Y;

  ASSERT(IMAGE != (IMAGE *) NULL);
  ASSERT(IMAGE->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE->TYPE != GRAYSCALETYPE)
    (VOID) TRANSFORMIMAGECOLORSPACE(IMAGE,GRAYCOLORSPACE,EXCEPTION);
  IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
    COLORMAP_INDEX=(SSIZE_T *) ACQUIREQUANTUMMEMORY(IMAGE->COLORS+1,
      SIZEOF(*COLORMAP_INDEX));
  ELSE
    COLORMAP_INDEX=(SSIZE_T *) ACQUIREQUANTUMMEMORY(MAXCOLORMAPSIZE+1,
      SIZEOF(*COLORMAP_INDEX));
  IF (COLORMAP_INDEX == (SSIZE_T *) NULL)
    THROWBINARYEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED",
      IMAGE->FILENAME);
  IF (IMAGE->STORAGE_CLASS != PSEUDOCLASS)
    {
      (VOID) MEMSET(COLORMAP_INDEX,(-1),MAXCOLORMAPSIZE*
        SIZEOF(*COLORMAP_INDEX));
      IF (ACQUIREIMAGECOLORMAP(IMAGE,MAXCOLORMAPSIZE,EXCEPTION) == MAGICKFALSE)
        {
          COLORMAP_INDEX=(SSIZE_T *) RELINQUISHMAGICKMEMORY(COLORMAP_INDEX);
          THROWBINARYEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED",
            IMAGE->FILENAME);
        }
      IMAGE->COLORS=0;
      STATUS=MAGICKTRUE;
      IMAGE_VIEW=ACQUIREAUTHENTICCACHEVIEW(IMAGE,EXCEPTION);
#IF DEFINED(MAGICKCORE_OPENMP_SUPPORT)
      #PRAGMA OMP PARALLEL FOR SCHEDULE(STATIC) SHARED(STATUS) \
        MAGICK_NUMBER_THREADS(IMAGE,IMAGE,IMAGE->ROWS,1)
#ENDIF
      FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
      {
        REGISTER QUANTUM
          *MAGICK_RESTRICT Q;

        REGISTER SSIZE_T
          X;

        IF (STATUS == MAGICKFALSE)
          CONTINUE;
        Q=GETCACHEVIEWAUTHENTICPIXELS(IMAGE_VIEW,0,Y,IMAGE->COLUMNS,1,
          EXCEPTION);
        IF (Q == (QUANTUM *) NULL)
          {
            STATUS=MAGICKFALSE;
            CONTINUE;
          }
        FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
        {
          REGISTER SIZE_T
            INTENSITY;

          INTENSITY=SCALEQUANTUMTOMAP(GETPIXELRED(IMAGE,Q));
          IF (COLORMAP_INDEX[INTENSITY] < 0)
            {
#IF DEFINED(MAGICKCORE_OPENMP_SUPPORT)
              #PRAGMA OMP CRITICAL (MAGICKCORE_SETGRAYSCALEIMAGE)
#ENDIF
              IF (COLORMAP_INDEX[INTENSITY] < 0)
                {
                  COLORMAP_INDEX[INTENSITY]=(SSIZE_T) IMAGE->COLORS;
                  IMAGE->COLORMAP[IMAGE->COLORS].RED=(DOUBLE)
                    GETPIXELRED(IMAGE,Q);
                  IMAGE->COLORMAP[IMAGE->COLORS].GREEN=(DOUBLE)
                    GETPIXELGREEN(IMAGE,Q);
                  IMAGE->COLORMAP[IMAGE->COLORS].BLUE=(DOUBLE)
                    GETPIXELBLUE(IMAGE,Q);
                  IMAGE->COLORS++;
               }
            }
          SETPIXELINDEX(IMAGE,(QUANTUM) COLORMAP_INDEX[INTENSITY],Q);
          Q+=GETPIXELCHANNELS(IMAGE);
        }
        IF (SYNCCACHEVIEWAUTHENTICPIXELS(IMAGE_VIEW,EXCEPTION) == MAGICKFALSE)
          STATUS=MAGICKFALSE;
      }
      IMAGE_VIEW=DESTROYCACHEVIEW(IMAGE_VIEW);
    }
  FOR (I=0; I < (SSIZE_T) IMAGE->COLORS; I++)
    IMAGE->COLORMAP[I].ALPHA=(DOUBLE) I;
  QSORT((VOID *) IMAGE->COLORMAP,IMAGE->COLORS,SIZEOF(PIXELINFO),
    INTENSITYCOMPARE);
  COLORMAP=(PIXELINFO *) ACQUIREQUANTUMMEMORY(IMAGE->COLORS,SIZEOF(*COLORMAP));
  IF (COLORMAP == (PIXELINFO *) NULL)
    {
      COLORMAP_INDEX=(SSIZE_T *) RELINQUISHMAGICKMEMORY(COLORMAP_INDEX);
      THROWBINARYEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED",
        IMAGE->FILENAME);
    }
  J=0;
  COLORMAP[J]=IMAGE->COLORMAP[0];
  FOR (I=0; I < (SSIZE_T) IMAGE->COLORS; I++)
  {
    IF (ISPIXELINFOEQUIVALENT(&COLORMAP[J],&IMAGE->COLORMAP[I]) == MAGICKFALSE)
      {
        J++;
        COLORMAP[J]=IMAGE->COLORMAP[I];
      }
    COLORMAP_INDEX[(SSIZE_T) IMAGE->COLORMAP[I].ALPHA]=J;
  }
  IMAGE->COLORS=(SIZE_T) (J+1);
  IMAGE->COLORMAP=(PIXELINFO *) RELINQUISHMAGICKMEMORY(IMAGE->COLORMAP);
  IMAGE->COLORMAP=COLORMAP;
  STATUS=MAGICKTRUE;
  IMAGE_VIEW=ACQUIREAUTHENTICCACHEVIEW(IMAGE,EXCEPTION);
#IF DEFINED(MAGICKCORE_OPENMP_SUPPORT)
  #PRAGMA OMP PARALLEL FOR SCHEDULE(STATIC) SHARED(STATUS) \
    MAGICK_NUMBER_THREADS(IMAGE,IMAGE,IMAGE->ROWS,1)
#ENDIF
  FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
  {
    REGISTER QUANTUM
      *MAGICK_RESTRICT Q;

    REGISTER SSIZE_T
      X;

    IF (STATUS == MAGICKFALSE)
      CONTINUE;
    Q=GETCACHEVIEWAUTHENTICPIXELS(IMAGE_VIEW,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
    IF (Q == (QUANTUM *) NULL)
      {
        STATUS=MAGICKFALSE;
        CONTINUE;
      }
    FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
    {
      SETPIXELINDEX(IMAGE,(QUANTUM) COLORMAP_INDEX[SCALEQUANTUMTOMAP(
        GETPIXELINDEX(IMAGE,Q))],Q);
      Q+=GETPIXELCHANNELS(IMAGE);
    }
    IF (SYNCCACHEVIEWAUTHENTICPIXELS(IMAGE_VIEW,EXCEPTION) == MAGICKFALSE)
      STATUS=MAGICKFALSE;
  }
  IMAGE_VIEW=DESTROYCACHEVIEW(IMAGE_VIEW);
  COLORMAP_INDEX=(SSIZE_T *) RELINQUISHMAGICKMEMORY(COLORMAP_INDEX);
  IMAGE->TYPE=GRAYSCALETYPE;
  IF (SETIMAGEMONOCHROME(IMAGE,EXCEPTION) != MAGICKFALSE)
    IMAGE->TYPE=BILEVELTYPE;
  RETURN(STATUS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209026_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VIRNODEDEVICEGETMDEVTYPESCAPS(CONST CHAR *SYSFSPATH,
                              VIRMEDIATEDDEVICETYPEPTR **MDEV_TYPES,
                              SIZE_T *NMDEV_TYPES)
{
    VIRMEDIATEDDEVICETYPEPTR *TYPES = NULL;
    SIZE_T NTYPES = 0;
    SIZE_T I;

    /* THIS COULD BE A REFRESH, SO CLEAR OUT THE OLD DATA */
    FOR (I = 0; I < *NMDEV_TYPES; I++)
       VIRMEDIATEDDEVICETYPEFREE(*MDEV_TYPES[I]);
    VIR_FREE(*MDEV_TYPES);
    *NMDEV_TYPES = 0;

    IF (VIRMEDIATEDDEVICEGETMDEVTYPES(SYSFSPATH, &TYPES, &NTYPES) < 0)
        RETURN -1;

    *MDEV_TYPES = G_STEAL_POINTER(&TYPES);
    *NMDEV_TYPES = NTYPES;

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244122_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR SVHD_BOX_WRITE(GF_BOX *S, GF_BITSTREAM *BS)
{
	GF_ERR E;
	GF_SPHERICALVIDEOINFOBOX *PTR = (GF_SPHERICALVIDEOINFOBOX *)S;

	E = GF_ISOM_FULL_BOX_WRITE(S, BS);
	IF (E) RETURN E;
	IF (PTR->STRING)
		GF_BS_WRITE_DATA(BS, PTR->STRING, (U32) STRLEN(PTR->STRING));
	GF_BS_WRITE_U8(BS, 0);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199836_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PJ_DEF(INT) PJ_SCAN_GET_CHAR( PJ_SCANNER *SCANNER )
{
    INT CHR = *SCANNER->CURPTR;

    IF (!CHR) {
	PJ_SCAN_SYNTAX_ERR(SCANNER);
	RETURN 0;
    }

    ++SCANNER->CURPTR;

    IF (PJ_SCAN_IS_PROBABLY_SPACE(*SCANNER->CURPTR) && SCANNER->SKIP_WS) {
	PJ_SCAN_SKIP_WHITESPACE(SCANNER);
    }
    RETURN CHR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 261968_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_STRING_BASE64URL(NJS_VM_T *VM, NJS_VALUE_T *VALUE, CONST NJS_STR_T *SRC)
{
    SIZE_T     PADDING;
    NJS_STR_T  DST;

    IF (NJS_SLOW_PATH(SRC->LENGTH == 0)) {
        VM->RETVAL = NJS_STRING_EMPTY;
        RETURN NJS_OK;
    }

    PADDING = SRC->LENGTH % 3;

    /*
     * CALCULATING THE PADDING LENGTH: 0 -> 0, 1 -> 2, 2 -> 1.
     */
    PADDING = (4 >> PADDING) & 0X03;

    DST.LENGTH = NJS_BASE64_ENCODED_LENGTH(SRC->LENGTH) - PADDING;

    DST.START = NJS_STRING_ALLOC(VM, VALUE, DST.LENGTH, DST.LENGTH);
    IF (NJS_SLOW_PATH(DST.START == NULL)) {
        RETURN NJS_ERROR;
    }

    NJS_ENCODE_BASE64URL(&DST, SRC);

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 203902_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_ONE_SOURCELINE(SOURCE_COOKIE_T *SP)
{
    GARRAY_T		GA;
    INT			LEN;
    INT			C;
    CHAR_U		*BUF;
#IFDEF USE_CRNL
    INT			HAS_CR;		// CR-LF FOUND
#ENDIF
    INT			HAVE_READ = FALSE;

    // USE A GROWARRAY TO STORE THE SOURCED LINE
    GA_INIT2(&GA, 1, 250);

    // LOOP UNTIL THERE IS A FINISHED LINE (OR END-OF-FILE).
    ++SP->SOURCING_LNUM;
    FOR (;;)
    {
	// MAKE ROOM TO READ AT LEAST 120 (MORE) CHARACTERS
	IF (GA_GROW(&GA, 120) == FAIL)
	    BREAK;
	IF (SP->SOURCE_FROM_BUF)
	{
	    IF (SP->BUF_LNUM >= SP->BUFLINES.GA_LEN)
		BREAK;		    // ALL THE LINES ARE PROCESSED
	    GA_CONCAT(&GA, ((CHAR_U **)SP->BUFLINES.GA_DATA)[SP->BUF_LNUM]);
	    SP->BUF_LNUM++;
	    IF (GA_GROW(&GA, 1) == FAIL)
		BREAK;
	    BUF = (CHAR_U *)GA.GA_DATA;
	    BUF[GA.GA_LEN++] = NUL;
	}
	ELSE
	{
	    BUF = (CHAR_U *)GA.GA_DATA;
	    IF (FGETS((CHAR *)BUF + GA.GA_LEN, GA.GA_MAXLEN - GA.GA_LEN,
			SP->FP) == NULL)
		BREAK;
	}
	LEN = GA.GA_LEN + (INT)STRLEN(BUF + GA.GA_LEN);
#IFDEF USE_CRNL
	// IGNORE A TRAILING CTRL-Z, WHEN IN DOS MODE.	ONLY RECOGNIZE THE
	// CTRL-Z BY ITS OWN, OR AFTER A NL.
	IF (	   (LEN == 1 || (LEN >= 2 && BUF[LEN - 2] == '\N'))
		&& SP->FILEFORMAT == EOL_DOS
		&& BUF[LEN - 1] == CTRL_Z)
	{
	    BUF[LEN - 1] = NUL;
	    BREAK;
	}
#ENDIF

	HAVE_READ = TRUE;
	GA.GA_LEN = LEN;

	// IF THE LINE WAS LONGER THAN THE BUFFER, READ MORE.
	IF (GA.GA_MAXLEN - GA.GA_LEN == 1 && BUF[LEN - 1] != '\N')
	    CONTINUE;

	IF (LEN >= 1 && BUF[LEN - 1] == '\N')	// REMOVE TRAILING NL
	{
#IFDEF USE_CRNL
	    HAS_CR = (LEN >= 2 && BUF[LEN - 2] == '\R');
	    IF (SP->FILEFORMAT == EOL_UNKNOWN)
	    {
		IF (HAS_CR)
		    SP->FILEFORMAT = EOL_DOS;
		ELSE
		    SP->FILEFORMAT = EOL_UNIX;
	    }

	    IF (SP->FILEFORMAT == EOL_DOS)
	    {
		IF (HAS_CR)	    // REPLACE TRAILING CR
		{
		    BUF[LEN - 2] = '\N';
		    --LEN;
		    --GA.GA_LEN;
		}
		ELSE	    // LINES LIKE ":MAP XX YY^M" WILL HAVE FAILED
		{
		    IF (!SP->ERROR)
		    {
			MSG_SOURCE(HL_ATTR(HLF_W));
			EMSG(_("W15: WARNING: WRONG LINE SEPARATOR, ^M MAY BE MISSING"));
		    }
		    SP->ERROR = TRUE;
		    SP->FILEFORMAT = EOL_UNIX;
		}
	    }
#ENDIF
	    // THE '\N' IS ESCAPED IF THERE IS AN ODD NUMBER OF ^V'S JUST
	    // BEFORE IT, FIRST SET "C" JUST BEFORE THE 'V'S AND THEN CHECK
	    // LEN&C PARITIES (IS FASTER THAN ((LEN-C)%2 == 0)) -- ACEVEDO
	    FOR (C = LEN - 2; C >= 0 && BUF[C] == CTRL_V; C--)
		;
	    IF ((LEN & 1) != (C & 1))	// ESCAPED NL, READ MORE
	    {
		++SP->SOURCING_LNUM;
		CONTINUE;
	    }

	    BUF[LEN - 1] = NUL;		// REMOVE THE NL
	}

	// CHECK FOR ^C HERE NOW AND THEN, SO RECURSIVE :SO CAN BE BROKEN.
	LINE_BREAKCHECK();
	BREAK;
    }

    IF (HAVE_READ)
	RETURN (CHAR_U *)GA.GA_DATA;

    VIM_FREE(GA.GA_DATA);
    RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512358_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  CONST DOUBLE *CONST_PTR_DOUBLE() CONST
  { RETURN CAN_RETURN_CONST_VALUE(REAL_RESULT) ? &VALUE.REAL : NULL; }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253584_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SMB2_QUERYFS(CONST UNSIGNED INT XID, STRUCT CIFS_TCON *TCON,
	     STRUCT CIFS_SB_INFO *CIFS_SB, STRUCT KSTATFS *BUF)
{
	STRUCT SMB2_QUERY_INFO_RSP *RSP;
	STRUCT SMB2_FS_FULL_SIZE_INFO *INFO = NULL;
	STRUCT KVEC RSP_IOV = {NULL, 0};
	INT BUFTYPE = CIFS_NO_BUFFER;
	INT RC;


	RC = SMB2_QUERY_INFO_COMPOUND(XID, TCON, "",
				      FILE_READ_ATTRIBUTES,
				      FS_FULL_SIZE_INFORMATION,
				      SMB2_O_INFO_FILESYSTEM,
				      SIZEOF(STRUCT SMB2_FS_FULL_SIZE_INFO),
				      &RSP_IOV, &BUFTYPE, CIFS_SB);
	IF (RC)
		GOTO QFS_EXIT;

	RSP = (STRUCT SMB2_QUERY_INFO_RSP *)RSP_IOV.IOV_BASE;
	BUF->F_TYPE = SMB2_SUPER_MAGIC;
	INFO = (STRUCT SMB2_FS_FULL_SIZE_INFO *)(
		LE16_TO_CPU(RSP->OUTPUTBUFFEROFFSET) + (CHAR *)RSP);
	RC = SMB2_VALIDATE_IOV(LE16_TO_CPU(RSP->OUTPUTBUFFEROFFSET),
			       LE32_TO_CPU(RSP->OUTPUTBUFFERLENGTH),
			       &RSP_IOV,
			       SIZEOF(STRUCT SMB2_FS_FULL_SIZE_INFO));
	IF (!RC)
		SMB2_COPY_FS_INFO_TO_KSTATFS(INFO, BUF);

QFS_EXIT:
	FREE_RSP_BUF(BUFTYPE, RSP_IOV.IOV_BASE);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216800_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RPA_READ_BUFFER(POOL_T POOL, CONST UNSIGNED CHAR **DATA,
		CONST UNSIGNED CHAR *END, UNSIGNED CHAR **BUFFER)
{
	CONST UNSIGNED CHAR *P = *DATA;
	UNSIGNED INT LEN;

	IF (P > END)
		RETURN 0;

	LEN = *P++;
	IF (P + LEN > END)
		RETURN 0;

	*BUFFER = P_MALLOC(POOL, LEN);
	MEMCPY(*BUFFER, P, LEN);

	*DATA += 1 + LEN;

	RETURN LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 337784_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT SCTP_CHUNK *SCTP_MAKE_NEW_ENCAP_PORT(CONST STRUCT SCTP_ASSOCIATION *ASOC,
					    CONST STRUCT SCTP_CHUNK *CHUNK)
{
	STRUCT SCTP_NEW_ENCAP_PORT_HDR NEP;
	STRUCT SCTP_CHUNK *RETVAL;

	RETVAL = SCTP_MAKE_ABORT(ASOC, CHUNK,
				 SIZEOF(STRUCT SCTP_ERRHDR) + SIZEOF(NEP));
	IF (!RETVAL)
		GOTO NODATA;

	SCTP_INIT_CAUSE(RETVAL, SCTP_ERROR_NEW_ENCAP_PORT, SIZEOF(NEP));
	NEP.CUR_PORT = SCTP_INPUT_CB(CHUNK->SKB)->ENCAP_PORT;
	NEP.NEW_PORT = CHUNK->TRANSPORT->ENCAP_PORT;
	SCTP_ADDTO_CHUNK(RETVAL, SIZEOF(NEP), &NEP);

NODATA:
	RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484735_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MOBI_BUFFER_DUP8(UINT8_T **VAL, MOBIBUFFER *BUF) {
    *VAL = NULL;
    IF (BUF->OFFSET + 1 > BUF->MAXLEN) {
        RETURN;
    }
    *VAL = MALLOC(SIZEOF(UINT8_T));
    IF (*VAL == NULL) {
        RETURN;
    }
    **VAL = MOBI_BUFFER_GET8(BUF);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359317_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (BGP_GRACEFUL_RESTART_STALEPATH_TIME,
       BGP_GRACEFUL_RESTART_STALEPATH_TIME_CMD,
       "BGP GRACEFUL-RESTART STALEPATH-TIME <1-3600>",
       "BGP SPECIFIC COMMANDS\N"
       "GRACEFUL RESTART CAPABILITY PARAMETERS\N"
       "SET THE MAX TIME TO HOLD ONTO RESTARTING PEER'S STALE PATHS\N"
       "DELAY VALUE (SECONDS)\N")
{
  STRUCT BGP *BGP;
  U_INT32_T STALEPATH;

  BGP = VTY->INDEX;
  IF (! BGP)
    RETURN CMD_WARNING;

  VTY_GET_INTEGER_RANGE ("STALEPATH-TIME", STALEPATH, ARGV[0], 1, 3600);
  BGP->STALEPATH_TIME = STALEPATH;
  RETURN CMD_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 279906_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PREPARE_TAGPREVIEW(
    INT		UNDO_SYNC,	    // SYNC UNDO WHEN LEAVING THE WINDOW
    INT		USE_PREVIEWPOPUP,   // USE POPUP IF 'PREVIEWPOPUP' SET
    USE_POPUP_T	USE_POPUP)	    // USE OTHER POPUP WINDOW
{
    WIN_T	*WP;

# IFDEF FEAT_GUI
    NEED_MOUSE_CORRECT = TRUE;
# ENDIF

    /*
     * IF THERE IS ALREADY A PREVIEW WINDOW OPEN, USE THAT ONE.
     */
    IF (!CURWIN->W_P_PVW)
    {
# IFDEF FEAT_PROP_POPUP
	IF (USE_PREVIEWPOPUP && *P_PVP != NUL)
	{
	    WP = POPUP_FIND_PREVIEW_WINDOW();
	    IF (WP != NULL)
		POPUP_SET_WANTPOS_CURSOR(WP, WP->W_MINWIDTH, NULL);
	}
	ELSE IF (USE_POPUP != USEPOPUP_NONE)
	{
	    WP = POPUP_FIND_INFO_WINDOW();
	    IF (WP != NULL)
	    {
		IF (USE_POPUP == USEPOPUP_NORMAL)
		    POPUP_SHOW(WP);
		ELSE
		    POPUP_HIDE(WP);
		// WHEN THE POPUP MOVES OR RESIZES IT MAY REVEAL PART OF
		// ANOTHER WINDOW.  TODO: CAN THIS BE DONE MORE EFFICIENTLY?
		REDRAW_ALL_LATER(NOT_VALID);
	    }
	}
	ELSE
# ENDIF
	{
	    FOR_ALL_WINDOWS(WP)
		IF (WP->W_P_PVW)
		    BREAK;
	}
	IF (WP != NULL)
	    WIN_ENTER(WP, UNDO_SYNC);
	ELSE
	{
	    /*
	     * THERE IS NO PREVIEW WINDOW OPEN YET.  CREATE ONE.
	     */
# IFDEF FEAT_PROP_POPUP
	    IF ((USE_PREVIEWPOPUP && *P_PVP != NUL)
						 || USE_POPUP != USEPOPUP_NONE)
		RETURN POPUP_CREATE_PREVIEW_WINDOW(USE_POPUP != USEPOPUP_NONE);
# ENDIF
	    IF (WIN_SPLIT(G_DO_TAGPREVIEW > 0 ? G_DO_TAGPREVIEW : 0, 0) == FAIL)
		RETURN FALSE;
	    CURWIN->W_P_PVW = TRUE;
	    CURWIN->W_P_WFH = TRUE;
	    RESET_BINDING(CURWIN);	    // DON'T TAKE OVER 'SCROLLBIND'
	    // AND 'CURSORBIND'
# IFDEF FEAT_DIFF
	    CURWIN->W_P_DIFF = FALSE;	    // NO 'DIFF'
# ENDIF
# IFDEF FEAT_FOLDING
	    CURWIN->W_P_FDC = 0;	    // NO 'FOLDCOLUMN'
# ENDIF
	    RETURN TRUE;
	}
    }
    RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248304_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DLLIMPORT VOID CFG_ERROR(CFG_T *CFG, CONST CHAR *FMT, ...)
{
	VA_LIST AP;

	VA_START(AP, FMT);

	IF (CFG && CFG->ERRFUNC)
		(*CFG->ERRFUNC) (CFG, FMT, AP);
	ELSE {
		IF (CFG && CFG->FILENAME && CFG->LINE)
			FPRINTF(STDERR, "%S:%D: ", CFG->FILENAME, CFG->LINE);
		ELSE IF (CFG && CFG->FILENAME)
			FPRINTF(STDERR, "%S: ", CFG->FILENAME);
		VFPRINTF(STDERR, FMT, AP);
		FPRINTF(STDERR, "\N");
	}

	VA_END(AP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204412_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID *__BPF_RINGBUF_RESERVE(STRUCT BPF_RINGBUF *RB, U64 SIZE)
{
	UNSIGNED LONG CONS_POS, PROD_POS, NEW_PROD_POS, FLAGS;
	U32 LEN, PG_OFF;
	STRUCT BPF_RINGBUF_HDR *HDR;

	IF (UNLIKELY(SIZE > RINGBUF_MAX_RECORD_SZ))
		RETURN NULL;

	LEN = ROUND_UP(SIZE + BPF_RINGBUF_HDR_SZ, 8);
	CONS_POS = SMP_LOAD_ACQUIRE(&RB->CONSUMER_POS);

	IF (IN_NMI()) {
		IF (!SPIN_TRYLOCK_IRQSAVE(&RB->SPINLOCK, FLAGS))
			RETURN NULL;
	} ELSE {
		SPIN_LOCK_IRQSAVE(&RB->SPINLOCK, FLAGS);
	}

	PROD_POS = RB->PRODUCER_POS;
	NEW_PROD_POS = PROD_POS + LEN;

	/* CHECK FOR OUT OF RINGBUF SPACE BY ENSURING PRODUCER POSITION
	 * DOESN'T ADVANCE MORE THAN (RINGBUF_SIZE - 1) AHEAD
	 */
	IF (NEW_PROD_POS - CONS_POS > RB->MASK) {
		SPIN_UNLOCK_IRQRESTORE(&RB->SPINLOCK, FLAGS);
		RETURN NULL;
	}

	HDR = (VOID *)RB->DATA + (PROD_POS & RB->MASK);
	PG_OFF = BPF_RINGBUF_REC_PG_OFF(RB, HDR);
	HDR->LEN = SIZE | BPF_RINGBUF_BUSY_BIT;
	HDR->PG_OFF = PG_OFF;

	/* PAIRS WITH CONSUMER'S SMP_LOAD_ACQUIRE() */
	SMP_STORE_RELEASE(&RB->PRODUCER_POS, NEW_PROD_POS);

	SPIN_UNLOCK_IRQRESTORE(&RB->SPINLOCK, FLAGS);

	RETURN (VOID *)HDR + BPF_RINGBUF_HDR_SZ;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200287_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT __TIPC_SENDMSG(STRUCT SOCKET *SOCK, STRUCT MSGHDR *M, SIZE_T DLEN)
{
	STRUCT SOCK *SK = SOCK->SK;
	STRUCT NET *NET = SOCK_NET(SK);
	STRUCT TIPC_SOCK *TSK = TIPC_SK(SK);
	STRUCT TIPC_UADDR *UA = (STRUCT TIPC_UADDR *)M->MSG_NAME;
	LONG TIMEOUT = SOCK_SNDTIMEO(SK, M->MSG_FLAGS & MSG_DONTWAIT);
	STRUCT LIST_HEAD *CLINKS = &TSK->CONG_LINKS;
	BOOL SYN = !TIPC_SK_TYPE_CONNECTIONLESS(SK);
	STRUCT TIPC_GROUP *GRP = TSK->GROUP;
	STRUCT TIPC_MSG *HDR = &TSK->PHDR;
	STRUCT TIPC_SOCKET_ADDR SKADDR;
	STRUCT SK_BUFF_HEAD PKTS;
	INT ATYPE, MTU, RC;

	IF (UNLIKELY(DLEN > TIPC_MAX_USER_MSG_SIZE))
		RETURN -EMSGSIZE;

	IF (UA) {
		IF (!TIPC_UADDR_VALID(UA, M->MSG_NAMELEN))
			RETURN -EINVAL;
		ATYPE = UA->ADDRTYPE;
	}

	/* IF SOCKET BELONGS TO A COMMUNICATION GROUP FOLLOW OTHER PATHS */
	IF (GRP) {
		IF (!UA)
			RETURN TIPC_SEND_GROUP_BCAST(SOCK, M, DLEN, TIMEOUT);
		IF (ATYPE == TIPC_SERVICE_ADDR)
			RETURN TIPC_SEND_GROUP_ANYCAST(SOCK, M, DLEN, TIMEOUT);
		IF (ATYPE == TIPC_SOCKET_ADDR)
			RETURN TIPC_SEND_GROUP_UNICAST(SOCK, M, DLEN, TIMEOUT);
		IF (ATYPE == TIPC_SERVICE_RANGE)
			RETURN TIPC_SEND_GROUP_MCAST(SOCK, M, DLEN, TIMEOUT);
		RETURN -EINVAL;
	}

	IF (!UA) {
		UA = (STRUCT TIPC_UADDR *)&TSK->PEER;
		IF (!SYN && UA->FAMILY != AF_TIPC)
			RETURN -EDESTADDRREQ;
		ATYPE = UA->ADDRTYPE;
	}

	IF (UNLIKELY(SYN)) {
		IF (SK->SK_STATE == TIPC_LISTEN)
			RETURN -EPIPE;
		IF (SK->SK_STATE != TIPC_OPEN)
			RETURN -EISCONN;
		IF (TSK->PUBLISHED)
			RETURN -EOPNOTSUPP;
		IF (ATYPE == TIPC_SERVICE_ADDR)
			TSK->CONN_ADDRTYPE = ATYPE;
		MSG_SET_SYN(HDR, 1);
	}

	/* DETERMINE DESTINATION */
	IF (ATYPE == TIPC_SERVICE_RANGE) {
		RETURN TIPC_SENDMCAST(SOCK, UA, M, DLEN, TIMEOUT);
	} ELSE IF (ATYPE == TIPC_SERVICE_ADDR) {
		SKADDR.NODE = UA->LOOKUP_NODE;
		UA->SCOPE = TIPC_NODE2SCOPE(SKADDR.NODE);
		IF (!TIPC_NAMETBL_LOOKUP_ANYCAST(NET, UA, &SKADDR))
			RETURN -EHOSTUNREACH;
	} ELSE IF (ATYPE == TIPC_SOCKET_ADDR) {
		SKADDR = UA->SK;
	} ELSE {
		RETURN -EINVAL;
	}

	/* BLOCK OR RETURN IF DESTINATION LINK IS CONGESTED */
	RC = TIPC_WAIT_FOR_COND(SOCK, &TIMEOUT,
				!TIPC_DEST_FIND(CLINKS, SKADDR.NODE, 0));
	IF (UNLIKELY(RC))
		RETURN RC;

	/* FINALLY BUILD MESSAGE HEADER */
	MSG_SET_DESTNODE(HDR, SKADDR.NODE);
	MSG_SET_DESTPORT(HDR, SKADDR.REF);
	IF (ATYPE == TIPC_SERVICE_ADDR) {
		MSG_SET_TYPE(HDR, TIPC_NAMED_MSG);
		MSG_SET_HDR_SZ(HDR, NAMED_H_SIZE);
		MSG_SET_NAMETYPE(HDR, UA->SA.TYPE);
		MSG_SET_NAMEINST(HDR, UA->SA.INSTANCE);
		MSG_SET_LOOKUP_SCOPE(HDR, UA->SCOPE);
	} ELSE { /* TIPC_SOCKET_ADDR */
		MSG_SET_TYPE(HDR, TIPC_DIRECT_MSG);
		MSG_SET_LOOKUP_SCOPE(HDR, 0);
		MSG_SET_HDR_SZ(HDR, BASIC_H_SIZE);
	}

	/* ADD MESSAGE BODY */
	__SKB_QUEUE_HEAD_INIT(&PKTS);
	MTU = TIPC_NODE_GET_MTU(NET, SKADDR.NODE, TSK->PORTID, TRUE);
	RC = TIPC_MSG_BUILD(HDR, M, 0, DLEN, MTU, &PKTS);
	IF (UNLIKELY(RC != DLEN))
		RETURN RC;
	IF (UNLIKELY(SYN && !TIPC_MSG_SKB_CLONE(&PKTS, &SK->SK_WRITE_QUEUE))) {
		__SKB_QUEUE_PURGE(&PKTS);
		RETURN -ENOMEM;
	}

	/* SEND MESSAGE */
	TRACE_TIPC_SK_SENDMSG(SK, SKB_PEEK(&PKTS), TIPC_DUMP_SK_SNDQ, " ");
	RC = TIPC_NODE_XMIT(NET, &PKTS, SKADDR.NODE, TSK->PORTID);
	IF (UNLIKELY(RC == -ELINKCONG)) {
		TIPC_DEST_PUSH(CLINKS, SKADDR.NODE, 0);
		TSK->CONG_LINK_CNT++;
		RC = 0;
	}

	IF (UNLIKELY(SYN && !RC)) {
		TIPC_SET_SK_STATE(SK, TIPC_CONNECTING);
		IF (DLEN && TIMEOUT) {
			TIMEOUT = MSECS_TO_JIFFIES(TIMEOUT);
			TIPC_WAIT_FOR_CONNECT(SOCK, &TIMEOUT);
		}
	}

	RETURN RC ? RC : DLEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215216_CWE-770.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
__ZZIP_FETCH_DISK_TRAILER(INT FD, ZZIP_OFF_T FILESIZE,
                          STRUCT _DISK_TRAILER *_ZZIP_RESTRICT TRAILER,
                          ZZIP_PLUGIN_IO_T IO)
{
#IFDEF DEBUG
#DEFINE RETURN(VAL) { E=VAL; HINT2("%S", ZZIP_STRERROR(E)); GOTO CLEANUP; }
#ELSE
#DEFINE RETURN(VAL) { E=VAL; GOTO CLEANUP; }
#ENDIF
    REGISTER INT E;

#IFNDEF _LOWSTK
    AUTO CHAR BUFFER[2 * ZZIP_BUFSIZ];
    CHAR *BUF = BUFFER;
#ELSE
    CHAR *BUF = MALLOC(2 * ZZIP_BUFSIZ);
#ENDIF
    ZZIP_OFF_T OFFSET = 0;
    ZZIP_SSIZE_T MAPLEN = 0;    /* MMAP(),READ(),GETPAGESIZE() USE SIZE_T !! */
    CHAR *FD_MAP = 0;

    IF (! TRAILER)
        { RETURN(EINVAL); }

    IF (FILESIZE < __SIZEOF(STRUCT ZZIP_DISK_TRAILER))
          { RETURN(ZZIP_DIR_TOO_SHORT); }

    IF (! BUF)
        { RETURN(ZZIP_OUTOFMEM); }

    OFFSET = FILESIZE;          /* A.K.A. OLD OFFSET */
    WHILE (1)                   /* OUTER LOOP */
    {
        REGISTER UNSIGNED CHAR *MAPPED;

        IF (OFFSET <= 0)
            { RETURN(ZZIP_DIR_EDH_MISSING); }

        /* TRAILER CANNOT BE FARTHER AWAY THAN 64K FROM FILEEND */
        IF (FILESIZE - OFFSET > 64 * 1024)
            { RETURN(ZZIP_DIR_EDH_MISSING); }

        /* THE NEW OFFSET SHALL OVERLAP WITH THE AREA AFTER THE OLD OFFSET! */
        IF (USE_MMAP && IO->FD.SYS)
        {
            ZZIP_OFF_T MAPOFF = OFFSET;
            {
                ZZIP_SSIZE_T PAGESIZE = _ZZIP_GETPAGESIZE(IO->FD.SYS);
                IF (PAGESIZE < ZZIP_BUFSIZ)
                    GOTO NON_MMAP;      /* AN ERROR? */
                IF (MAPOFF == FILESIZE && FILESIZE > PAGESIZE)
                    MAPOFF -= PAGESIZE;
                IF (MAPOFF < PAGESIZE)
                {
                    MAPLEN = (ZZIP_SSIZE_T) MAPOFF + PAGESIZE;
                    MAPOFF = 0;
                } ELSE
                {
                    MAPOFF -= PAGESIZE;
                    MAPLEN = 2 * PAGESIZE;
                    IF ((ZZIP_SSIZE_T) MAPOFF & (PAGESIZE - 1))
                    {           /*ONLY 1. RUN */
                        PAGESIZE -= (ZZIP_SSIZE_T) MAPOFF & (PAGESIZE - 1);
                        MAPOFF += PAGESIZE;
                        MAPLEN -= PAGESIZE;
                    }
                }
                IF (MAPOFF + MAPLEN > FILESIZE)
                    MAPLEN = FILESIZE - MAPOFF;
            }

            FD_MAP = _ZZIP_MMAP(IO->FD.SYS, FD, MAPOFF, (ZZIP_SIZE_T) MAPLEN);
            IF (FD_MAP == MAP_FAILED)
                GOTO NON_MMAP;
            MAPPED = (UNSIGNED CHAR *) FD_MAP;
            OFFSET = MAPOFF;    /* SUCCESS */
            HINT3("MAPPED *%P LEN=%LI", FD_MAP, (LONG) MAPLEN);
        } ELSE
        {
          NON_MMAP:
            FD_MAP = 0;         /* HAVE NO MMAP */
            {
                ZZIP_OFF_T PAGESIZE = ZZIP_BUFSIZ;
                IF (OFFSET == FILESIZE && FILESIZE > PAGESIZE)
                    OFFSET -= PAGESIZE;
                IF (OFFSET < PAGESIZE)
                {
                    MAPLEN = (ZZIP_SSIZE_T) OFFSET + PAGESIZE;
                    OFFSET = 0;
                } ELSE
                {
                    OFFSET -= PAGESIZE;
                    MAPLEN = 2 * PAGESIZE;
                    IF ((ZZIP_SSIZE_T) OFFSET & (PAGESIZE - 1))
                    {           /*ON 1ST RUN */
                        PAGESIZE -= (ZZIP_SSIZE_T) OFFSET & (PAGESIZE - 1);
                        OFFSET += PAGESIZE;
                        MAPLEN -= PAGESIZE;
                    }
                }
                IF (OFFSET + MAPLEN > FILESIZE)
                    MAPLEN = FILESIZE - OFFSET;
            }

            IF (IO->FD.SEEKS(FD, OFFSET, SEEK_SET) < 0)
                { RETURN(ZZIP_DIR_SEEK); }
            IF (IO->FD.READ(FD, BUF, (ZZIP_SIZE_T) MAPLEN) < MAPLEN)
                { RETURN(ZZIP_DIR_READ); }
            MAPPED = (UNSIGNED CHAR *) BUF;     /* SUCCESS */
            HINT5("OFFS=$%LX LEN=%LI FILESIZE=%LI PAGESIZE=%I",
                  (LONG) OFFSET, (LONG) MAPLEN, (LONG) FILESIZE, ZZIP_BUFSIZ);
        }

        {                       /* NOW, CHECK FOR THE TRAILER-MAGIC, HOPEFULLY NEAR THE END OF FILE */
            REGISTER UNSIGNED CHAR *END = MAPPED + MAPLEN;
            REGISTER UNSIGNED CHAR *TAIL;
            FOR (TAIL = END - 1; (TAIL >= MAPPED); TAIL--)
            {
                IF ((*TAIL == 'P') &&   /* QUICK PRE-CHECK FOR TRAILER MAGIC */
                    END - TAIL >= __SIZEOF(STRUCT ZZIP_DISK_TRAILER) - 2 &&
                    ZZIP_DISK_TRAILER_CHECK_MAGIC(TAIL))
                {
#                  IFNDEF ZZIP_DISK64_TRAILER
                    /* IF THE FILE-COMMENT IS NOT PRESENT, IT HAPPENS
                       THAT THE Z_COMMENT FIELD OFTEN ISN'T EITHER */
                    IF (END - TAIL >= __SIZEOF(*TRAILER))
                    {
                        MEMCPY(TRAILER, TAIL, SIZEOF(*TRAILER));
                    } ELSE
                    {
                        MEMCPY(TRAILER, TAIL, SIZEOF(*TRAILER) - 2);
                        TRAILER->Z_COMMENT[0] = 0;
                        TRAILER->Z_COMMENT[1] = 0;
                    }
#                  ELSE
                    STRUCT ZZIP_DISK_TRAILER *ORIG =
                        (STRUCT ZZIP_DISK_TRAILER *) TAIL;
                    TRAILER->ZZ_TAIL = TAIL;
                    TRAILER->ZZ_ENTRIES = ZZIP_DISK_TRAILER_LOCALENTRIES(ORIG);
                    TRAILER->ZZ_FINALENTRIES =
                        ZZIP_DISK_TRAILER_FINALENTRIES(ORIG);
                    TRAILER->ZZ_ROOTSEEK = ZZIP_DISK_TRAILER_ROOTSEEK(ORIG);
                    TRAILER->ZZ_ROOTSIZE = ZZIP_DISK_TRAILER_ROOTSIZE(ORIG);
#                  ENDIF

                    __FIXUP_ROOTSEEK(OFFSET + TAIL - MAPPED, TRAILER);
                    { RETURN(0); }
                } ELSE IF ((*TAIL == 'P') &&
                           END - TAIL >=
                           __SIZEOF(STRUCT ZZIP_DISK64_TRAILER) - 2
                           && ZZIP_DISK64_TRAILER_CHECK_MAGIC(TAIL))
                {
#                  IFNDEF ZZIP_DISK64_TRAILER
                    RETURN (ZZIP_DIR_LARGEFILE);
#                  ELSE
                    STRUCT ZZIP_DISK64_TRAILER *ORIG =
                        (STRUCT ZZIP_DISK64_TRAILER *) TAIL;
                    TRAILER->ZZ_TAIL = TAIL;
                    TRAILER->ZZ_ENTRIES =
                        ZZIP_DISK64_TRAILER_LOCALENTRIES(ORIG);
                    TRAILER->ZZ_FINALENTRIES =
                        ZZIP_DISK64_TRAILER_FINALENTRIES(ORIG);
                    TRAILER->ZZ_ROOTSEEK = ZZIP_DISK64_TRAILER_ROOTSEEK(ORIG);
                    TRAILER->ZZ_ROOTSIZE = ZZIP_DISK64_TRAILER_ROOTSIZE(ORIG);
                    { RETURN(0); }
#                  ENDIF
                }
            }
        }

        IF (USE_MMAP && FD_MAP)
        {
            HINT3("UNMAP *%P LEN=%LI", FD_MAP, (LONG) MAPLEN);
            _ZZIP_MUNMAP(IO->FD.SYS, FD_MAP, (ZZIP_SIZE_T) MAPLEN);
            FD_MAP = 0;
        }
    }                           /*OUTER LOOP */

  CLEANUP:
    IF (USE_MMAP && FD_MAP)
    {
        HINT3("UNMAP *%P LEN=%LI", FD_MAP, (LONG) MAPLEN);
        _ZZIP_MUNMAP(IO->FD.SYS, FD_MAP, (ZZIP_SIZE_T) MAPLEN);
    }
#   IFDEF _LOWSTK
    FREE(BUF);
#   ENDIF
#   UNDEF RETURN
    RETURN E;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225010_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CONNINFO_URI_DECODE(CONST CHAR *STR, PQEXPBUFFER ERRORMESSAGE)
{
	CHAR	   *BUF;
	CHAR	   *P;
	CONST CHAR *Q = STR;

	BUF = MALLOC(STRLEN(STR) + 1);
	IF (BUF == NULL)
	{
		APPENDPQEXPBUFFERSTR(ERRORMESSAGE, LIBPQ_GETTEXT("OUT OF MEMORY\N"));
		RETURN NULL;
	}
	P = BUF;

	FOR (;;)
	{
		IF (*Q != '%')
		{
			/* COPY AND CHECK FOR NUL TERMINATOR */
			IF (!(*(P++) = *(Q++)))
				BREAK;
		}
		ELSE
		{
			INT			HI;
			INT			LO;
			INT			C;

			++Q;				/* SKIP THE PERCENT SIGN ITSELF */

			/*
			 * POSSIBLE EOL WILL BE CAUGHT BY THE FIRST CALL TO
			 * GET_HEXDIGIT(), SO WE NEVER DEREFERENCE AN INVALID Q POINTER.
			 */
			IF (!(GET_HEXDIGIT(*Q++, &HI) && GET_HEXDIGIT(*Q++, &LO)))
			{
				APPENDPQEXPBUFFER(ERRORMESSAGE,
								  LIBPQ_GETTEXT("INVALID PERCENT-ENCODED TOKEN: \"%S\"\N"),
								  STR);
				FREE(BUF);
				RETURN NULL;
			}

			C = (HI << 4) | LO;
			IF (C == 0)
			{
				APPENDPQEXPBUFFER(ERRORMESSAGE,
								  LIBPQ_GETTEXT("FORBIDDEN VALUE %%00 IN PERCENT-ENCODED VALUE: \"%S\"\N"),
								  STR);
				FREE(BUF);
				RETURN NULL;
			}
			*(P++) = C;
		}
	}

	RETURN BUF;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202082_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RBINJAVAATTRINFO *R_BIN_JAVA_BOOTSTRAP_METHODS_ATTR_NEW(RBINJAVAOBJ *BIN, UT8 *BUFFER, UT64 SZ, UT64 BUF_OFFSET) {
	UT32 I = 0;
	RBINJAVABOOTSTRAPMETHOD *BSM = NULL;
	UT64 OFFSET = 0;
	RBINJAVAATTRINFO *ATTR = R_BIN_JAVA_DEFAULT_ATTR_NEW (BIN, BUFFER, SZ, BUF_OFFSET);
	OFFSET += 6;
	IF (ATTR) {
		ATTR->TYPE = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;
		ATTR->INFO.BOOTSTRAP_METHODS_ATTR.NUM_BOOTSTRAP_METHODS = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		OFFSET += 2;
		ATTR->INFO.BOOTSTRAP_METHODS_ATTR.BOOTSTRAP_METHODS = R_LIST_NEWF (R_BIN_JAVA_BOOTSTRAP_METHOD_FREE);
		FOR (I = 0; I < ATTR->INFO.BOOTSTRAP_METHODS_ATTR.NUM_BOOTSTRAP_METHODS; I++) {
			// BSM = R_BIN_JAVA_BOOTSTRAP_METHOD_NEW (BIN, BIN->B->CUR);
			IF (OFFSET >= SZ) {
				BREAK;
			}
			BSM = R_BIN_JAVA_BOOTSTRAP_METHOD_NEW (BUFFER + OFFSET, SZ - OFFSET, BUF_OFFSET + OFFSET);
			IF (BSM) {
				OFFSET += BSM->SIZE;
				R_LIST_APPEND (ATTR->INFO.BOOTSTRAP_METHODS_ATTR.BOOTSTRAP_METHODS, (VOID *) BSM);
			} ELSE {
				// TODO EPRINTF FAILED TO READ THE %D BOOT STRAP METHOD.
			}
		}
		ATTR->SIZE = OFFSET;
	}
	RETURN ATTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294543_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
M_REAL_LOCAL_JD(UNION DATEDATA *X)
{
    VALUE NTH, RJD;
    INT JD;

    NTH = M_NTH(X);
    JD = M_LOCAL_JD(X);

    ENCODE_JD(NTH, JD, &RJD);
    RETURN RJD;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 424892_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IWL_PCIE_APM_INIT(STRUCT IWL_TRANS *TRANS)
{
	INT RET;

	IWL_DEBUG_INFO(TRANS, "INIT CARD'S BASIC FUNCTIONS\N");

	/*
	 * USE "SET_BIT" BELOW RATHER THAN "WRITE", TO PRESERVE ANY HARDWARE
	 * BITS ALREADY SET BY DEFAULT AFTER RESET.
	 */

	/* DISABLE L0S EXIT TIMER (PLATFORM NMI WORK/AROUND) */
	IF (TRANS->TRANS_CFG->DEVICE_FAMILY < IWL_DEVICE_FAMILY_8000)
		IWL_SET_BIT(TRANS, CSR_GIO_CHICKEN_BITS,
			    CSR_GIO_CHICKEN_BITS_REG_BIT_DIS_L0S_EXIT_TIMER);

	/*
	 * DISABLE L0S WITHOUT AFFECTING L1;
	 *  DON'T WAIT FOR ICH L0S (ICH BUG W/A)
	 */
	IWL_SET_BIT(TRANS, CSR_GIO_CHICKEN_BITS,
		    CSR_GIO_CHICKEN_BITS_REG_BIT_L1A_NO_L0S_RX);

	/* SET FH WAIT THRESHOLD TO MAXIMUM (HW ERROR DURING STRESS W/A) */
	IWL_SET_BIT(TRANS, CSR_DBG_HPET_MEM_REG, CSR_DBG_HPET_MEM_REG_VAL);

	/*
	 * ENABLE HAP INTA (INTERRUPT FROM MANAGEMENT BUS) TO
	 * WAKE DEVICE'S PCI EXPRESS LINK L1A -> L0S
	 */
	IWL_SET_BIT(TRANS, CSR_HW_IF_CONFIG_REG,
		    CSR_HW_IF_CONFIG_REG_BIT_HAP_WAKE_L1A);

	IWL_PCIE_APM_CONFIG(TRANS);

	/* CONFIGURE ANALOG PHASE-LOCK-LOOP BEFORE ACTIVATING TO D0A */
	IF (TRANS->TRANS_CFG->BASE_PARAMS->PLL_CFG)
		IWL_SET_BIT(TRANS, CSR_ANA_PLL_CFG, CSR50_ANA_PLL_CFG_VAL);

	RET = IWL_FINISH_NIC_INIT(TRANS, TRANS->TRANS_CFG);
	IF (RET)
		RETURN RET;

	IF (TRANS->CFG->HOST_INTERRUPT_OPERATION_MODE) {
		/*
		 * THIS IS A BIT OF AN ABUSE - THIS IS NEEDED FOR 7260 / 3160
		 * ONLY CHECK HOST_INTERRUPT_OPERATION_MODE EVEN IF THIS IS
		 * NOT RELATED TO HOST_INTERRUPT_OPERATION_MODE.
		 *
		 * ENABLE THE OSCILLATOR TO COUNT WAKE UP TIME FOR L1 EXIT. THIS
		 * CONSUMES SLIGHTLY MORE POWER (100UA) - BUT ALLOWS TO BE SURE
		 * THAT WE WAKE UP FROM L1 ON TIME.
		 *
		 * THIS LOOKS WEIRD: READ TWICE THE SAME REGISTER, DISCARD THE
		 * VALUE, SET A BIT, AND YET AGAIN, READ THAT SAME REGISTER
		 * JUST TO DISCARD THE VALUE. BUT THAT'S THE WAY THE HARDWARE
		 * SEEMS TO LIKE IT.
		 */
		IWL_READ_PRPH(TRANS, OSC_CLK);
		IWL_READ_PRPH(TRANS, OSC_CLK);
		IWL_SET_BITS_PRPH(TRANS, OSC_CLK, OSC_CLK_FORCE_CONTROL);
		IWL_READ_PRPH(TRANS, OSC_CLK);
		IWL_READ_PRPH(TRANS, OSC_CLK);
	}

	/*
	 * ENABLE DMA CLOCK AND WAIT FOR IT TO STABILIZE.
	 *
	 * WRITE TO "CLK_EN_REG"; "1" BITS ENABLE CLOCKS, WHILE "0"
	 * BITS DO NOT DISABLE CLOCKS.  THIS PRESERVES ANY HARDWARE
	 * BITS ALREADY SET BY DEFAULT IN "CLK_CTRL_REG" AFTER RESET.
	 */
	IF (!TRANS->CFG->APMG_NOT_SUPPORTED) {
		IWL_WRITE_PRPH(TRANS, APMG_CLK_EN_REG,
			       APMG_CLK_VAL_DMA_CLK_RQT);
		UDELAY(20);

		/* DISABLE L1-ACTIVE */
		IWL_SET_BITS_PRPH(TRANS, APMG_PCIDEV_STT_REG,
				  APMG_PCIDEV_STT_VAL_L1_ACT_DIS);

		/* CLEAR THE INTERRUPT IN APMG IF THE NIC IS IN RFKILL */
		IWL_WRITE_PRPH(TRANS, APMG_RTC_INT_STT_REG,
			       APMG_RTC_INT_STT_RFKILL);
	}

	SET_BIT(STATUS_DEVICE_ENABLED, &TRANS->STATUS);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195074_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_AV1CONFIG *GF_ODF_AV1_CFG_READ_BS_SIZE(GF_BITSTREAM *BS, U32 SIZE)
{
#IFNDEF GPAC_DISABLE_AV_PARSERS
	AV1STATE STATE;
	U8 RESERVED;
	GF_AV1CONFIG *CFG;

	IF (!SIZE) SIZE = (U32) GF_BS_AVAILABLE(BS);
	IF (!SIZE) RETURN NULL;

	CFG = GF_ODF_AV1_CFG_NEW();
	GF_AV1_INIT_STATE(&STATE);
	STATE.CONFIG = CFG;

	CFG->MARKER = GF_BS_READ_INT(BS, 1);
	CFG->VERSION = GF_BS_READ_INT(BS, 7);
	CFG->SEQ_PROFILE = GF_BS_READ_INT(BS, 3);
	CFG->SEQ_LEVEL_IDX_0 = GF_BS_READ_INT(BS, 5);
	CFG->SEQ_TIER_0 = GF_BS_READ_INT(BS, 1);
	CFG->HIGH_BITDEPTH = GF_BS_READ_INT(BS, 1);
	CFG->TWELVE_BIT = GF_BS_READ_INT(BS, 1);
	CFG->MONOCHROME = GF_BS_READ_INT(BS, 1);
	CFG->CHROMA_SUBSAMPLING_X = GF_BS_READ_INT(BS, 1);
	CFG->CHROMA_SUBSAMPLING_Y = GF_BS_READ_INT(BS, 1);
	CFG->CHROMA_SAMPLE_POSITION = GF_BS_READ_INT(BS, 2);

	RESERVED = GF_BS_READ_INT(BS, 3);
	IF (RESERVED != 0 || CFG->MARKER != 1 || CFG->VERSION != 1) {
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[AV1] WRONG AVCC RESERVED %D / MARKER %D / VERSION %D EXPECTING 0 1 1\N", RESERVED, CFG->MARKER, CFG->VERSION));
		GF_ODF_AV1_CFG_DEL(CFG);
		RETURN NULL;
	}
	CFG->INITIAL_PRESENTATION_DELAY_PRESENT = GF_BS_READ_INT(BS, 1);
	IF (CFG->INITIAL_PRESENTATION_DELAY_PRESENT) {
		CFG->INITIAL_PRESENTATION_DELAY_MINUS_ONE = GF_BS_READ_INT(BS, 4);
	} ELSE {
		/*RESERVED = */GF_BS_READ_INT(BS, 4);
		CFG->INITIAL_PRESENTATION_DELAY_MINUS_ONE = 0;
	}
	SIZE -= 4;

	WHILE (SIZE) {
		U64 POS, OBU_SIZE;
		OBUTYPE OBU_TYPE;
		GF_AV1_OBUARRAYENTRY *A;

		POS = GF_BS_GET_POSITION(BS);
		OBU_SIZE = 0;
		IF (GF_AV1_PARSE_OBU(BS, &OBU_TYPE, &OBU_SIZE, NULL, &STATE) != GF_OK) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AV1] COULD NOT PARSE AV1 OBU AT POSITION "LLU". LEAVING PARSING.\N", POS));
			BREAK;
		}
		ASSERT(OBU_SIZE == GF_BS_GET_POSITION(BS) - POS);
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[AV1] PARSED AV1 OBU TYPE=%U SIZE="LLU" AT POSITION "LLU".\N", OBU_TYPE, OBU_SIZE, POS));

		IF (!AV1_IS_OBU_HEADER(OBU_TYPE)) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[AV1] AV1 UNEXPECTED OBU TYPE=%U SIZE="LLU" FOUND AT POSITION "LLU". FORWARDING.\N", POS));
		}
		GF_SAFEALLOC(A, GF_AV1_OBUARRAYENTRY);
		IF (!A) BREAK;
		A->OBU = GF_MALLOC((SIZE_T)OBU_SIZE);
		IF (!A->OBU) {
			GF_FREE(A);
			BREAK;
		}
		GF_BS_SEEK(BS, POS);
		GF_BS_READ_DATA(BS, (CHAR *) A->OBU, (U32)OBU_SIZE);
		A->OBU_LENGTH = OBU_SIZE;
		A->OBU_TYPE = OBU_TYPE;
		GF_LIST_ADD(CFG->OBU_ARRAY, A);

		IF (SIZE<OBU_SIZE) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[AV1] AV1 CONFIG MISSES %D BYTES TO FIT THE ENTIRE OBU\N", OBU_SIZE - SIZE));
			BREAK;
		}
		SIZE -= (U32) OBU_SIZE;
	}
	GF_AV1_RESET_STATE(& STATE, GF_TRUE);
	RETURN CFG;
#ELSE
	RETURN NULL;
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195402_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT TFLITEINTARRAYGETSIZEINBYTES(INT SIZE) {
  STATIC TFLITEINTARRAY DUMMY;

  INT COMPUTED_SIZE = SIZEOF(DUMMY) + SIZEOF(DUMMY.DATA[0]) * SIZE;
#IF DEFINED(_MSC_VER)
  // CONTEXT FOR WHY THIS IS NEEDED IS IN HTTP://B/189926408#COMMENT21
  COMPUTED_SIZE -= SIZEOF(DUMMY.DATA[0]);
#ENDIF
  RETURN COMPUTED_SIZE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 317311_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE U32 OPEN_FILE_TO_AV(STRUCT FILE *FILE)
{
	U32 AV = FILE_TO_AV(FILE);
	STRUCT INODE *INODE = FILE_INODE(FILE);

	IF (SELINUX_POLICYCAP_OPENPERM() &&
	    INODE->I_SB->S_MAGIC != SOCKFS_MAGIC)
		AV |= FILE__OPEN;

	RETURN AV;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 223421_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID CHECK_NEWLINECHAR(COMPILER_COMMON *COMMON, INT NLTYPE, JUMP_LIST **BACKTRACKS, BOOL JUMPIFMATCH)
{
/* CHARACTER COMES IN TMP1. CHECKS IF IT IS A NEWLINE. TMP2 MAY BE DESTROYED. */
DEFINE_COMPILER;
STRUCT SLJIT_JUMP *JUMP;

IF (NLTYPE == NLTYPE_ANY)
  {
  ADD_JUMP(COMPILER, &COMMON->ANYNEWLINE, JUMP(SLJIT_FAST_CALL));
  SLJIT_SET_CURRENT_FLAGS(COMPILER, SLJIT_SET_Z);
  ADD_JUMP(COMPILER, BACKTRACKS, JUMP(JUMPIFMATCH ? SLJIT_NOT_ZERO : SLJIT_ZERO));
  }
ELSE IF (NLTYPE == NLTYPE_ANYCRLF)
  {
  IF (JUMPIFMATCH)
    {
    ADD_JUMP(COMPILER, BACKTRACKS, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR));
    ADD_JUMP(COMPILER, BACKTRACKS, CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));
    }
  ELSE
    {
    JUMP = CMP(SLJIT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_CR);
    ADD_JUMP(COMPILER, BACKTRACKS, CMP(SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, CHAR_NL));
    JUMPHERE(JUMP);
    }
  }
ELSE
  {
  SLJIT_ASSERT(NLTYPE == NLTYPE_FIXED && COMMON->NEWLINE < 256);
  ADD_JUMP(COMPILER, BACKTRACKS, CMP(JUMPIFMATCH ? SLJIT_EQUAL : SLJIT_NOT_EQUAL, TMP1, 0, SLJIT_IMM, COMMON->NEWLINE));
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 203622_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CON_INSERT_UNIPAIR(STRUCT UNI_PAGEDIR *P, U_SHORT UNICODE, U_SHORT FONTPOS)
{
	INT I, N;
	U16 **P1, *P2;

	P1 = P->UNI_PGDIR[N = UNICODE >> 11];
	IF (!P1) {
		P1 = P->UNI_PGDIR[N] = KMALLOC_ARRAY(32, SIZEOF(U16 *),
						     GFP_KERNEL);
		IF (!P1) RETURN -ENOMEM;
		FOR (I = 0; I < 32; I++)
			P1[I] = NULL;
	}

	P2 = P1[N = (UNICODE >> 6) & 0X1F];
	IF (!P2) {
		P2 = P1[N] = KMALLOC_ARRAY(64, SIZEOF(U16), GFP_KERNEL);
		IF (!P2) {
			KFREE(P1);
			P->UNI_PGDIR[N] = NULL;
			RETURN -ENOMEM;
		}
		MEMSET(P2, 0XFF, 64*SIZEOF(U16)); /* NO GLYPHS FOR THE CHARACTERS (YET) */
	}

	P2[UNICODE & 0X3F] = FONTPOS;
	
	P->SUM += (FONTPOS << 20) + UNICODE;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212144_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MOBI_RET MOBI_PARSE_HUFFDIC(CONST MOBIDATA *M, MOBIHUFFCDIC *HUFFCDIC) {
    MOBI_RET RET;
    CONST SIZE_T OFFSET = MOBI_GET_KF8OFFSET(M);
    IF (M->MH == NULL || M->MH->HUFF_REC_INDEX == NULL || M->MH->HUFF_REC_COUNT == NULL) {
        DEBUG_PRINT("%S", "HUFF/CDIC RECORDS METADATA NOT FOUND IN MOBI HEADER\N");
        RETURN MOBI_DATA_CORRUPT;
    }
    CONST SIZE_T HUFF_REC_INDEX = *M->MH->HUFF_REC_INDEX + OFFSET;
    CONST SIZE_T HUFF_REC_COUNT = *M->MH->HUFF_REC_COUNT;
    IF (HUFF_REC_COUNT > HUFF_RECORD_MAXCNT) {
        DEBUG_PRINT("TOO MANY HUFF RECORD (%ZU)\N", HUFF_REC_COUNT);
        RETURN MOBI_DATA_CORRUPT;
    }
    CONST MOBIPDBRECORD *CURR = MOBI_GET_RECORD_BY_SEQNUMBER(M, HUFF_REC_INDEX);
    IF (CURR == NULL || HUFF_REC_COUNT < 2) {
        DEBUG_PRINT("%S", "HUFF/CDIC RECORD NOT FOUND\N");
        RETURN MOBI_DATA_CORRUPT;
    }
    IF (CURR->SIZE < HUFF_RECORD_MINSIZE) {
        DEBUG_PRINT("HUFF RECORD TOO SHORT (%ZU B)\N", CURR->SIZE);
        RETURN MOBI_DATA_CORRUPT;
    }
    RET = MOBI_PARSE_HUFF(HUFFCDIC, CURR);
    IF (RET != MOBI_SUCCESS) {
        DEBUG_PRINT("%S", "HUFF PARSING FAILED\N");
        RETURN RET;
    }
    CURR = CURR->NEXT;
    /* ALLOCATE MEMORY FOR SYMBOLS DATA IN EACH CDIC RECORD */
    HUFFCDIC->SYMBOLS = MALLOC((HUFF_REC_COUNT - 1) * SIZEOF(*HUFFCDIC->SYMBOLS));
    IF (HUFFCDIC->SYMBOLS == NULL) {
        DEBUG_PRINT("%S\N", "MEMORY ALLOCATION FAILED");
        RETURN MOBI_MALLOC_FAILED;
    }
    /* GET FOLLOWING CDIC RECORDS */
    SIZE_T I = 0;
    WHILE (I < HUFF_REC_COUNT - 1) {
        IF (CURR == NULL) {
            DEBUG_PRINT("%S\N", "CDIC RECORD NOT FOUND");
            RETURN MOBI_DATA_CORRUPT;
        }
        RET = MOBI_PARSE_CDIC(HUFFCDIC, CURR, I++);
        IF (RET != MOBI_SUCCESS) {
            DEBUG_PRINT("%S", "CDIC PARSING FAILED\N");
            RETURN RET;
        }
        CURR = CURR->NEXT;
    }
    RETURN MOBI_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 275527_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_VM_BIND(NJS_VM_T *VM, CONST NJS_STR_T *VAR_NAME, CONST NJS_VALUE_T *VALUE,
    NJS_BOOL_T SHARED)
{
    NJS_INT_T           RET;
    NJS_OBJECT_T        *GLOBAL;
    NJS_LVLHSH_T        *HASH;
    NJS_OBJECT_PROP_T   *PROP;
    NJS_LVLHSH_QUERY_T  LHQ;

    PROP = NJS_OBJECT_PROP_ALLOC(VM, &NJS_VALUE_UNDEFINED, VALUE, 1);
    IF (NJS_SLOW_PATH(PROP == NULL)) {
        RETURN NJS_ERROR;
    }

    RET = NJS_STRING_NEW(VM, &PROP->NAME, VAR_NAME->START, VAR_NAME->LENGTH, 0);
    IF (NJS_SLOW_PATH(RET != NJS_OK)) {
        RETURN NJS_ERROR;
    }

    LHQ.VALUE = PROP;
    LHQ.KEY = *VAR_NAME;
    LHQ.KEY_HASH = NJS_DJB_HASH(LHQ.KEY.START, LHQ.KEY.LENGTH);
    LHQ.REPLACE = 1;
    LHQ.POOL = VM->MEM_POOL;
    LHQ.PROTO = &NJS_OBJECT_HASH_PROTO;

    GLOBAL = &VM->GLOBAL_OBJECT;
    HASH = SHARED ? &GLOBAL->SHARED_HASH : &GLOBAL->HASH;

    RET = NJS_LVLHSH_INSERT(HASH, &LHQ);
    IF (NJS_SLOW_PATH(RET != NJS_OK)) {
        NJS_INTERNAL_ERROR(VM, "LVLHSH INSERT FAILED");
        RETURN RET;
    }

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198743_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PTRDIFF_T FINDERRFUNC(LUA_STATE *L)
{
  CTVALUE *FRAME = L->BASE-1, *BOT = TVREF(L->STACK);
  VOID *CF = L->CFRAME;
  WHILE (FRAME > BOT && CF) {
    WHILE (CFRAME_NRES(CFRAME_RAW(CF)) < 0) {  /* CFRAME WITHOUT FRAME? */
      IF (FRAME >= RESTORESTACK(L, -CFRAME_NRES(CF)))
	BREAK;
      IF (CFRAME_ERRFUNC(CF) >= 0)  /* ERROR HANDLER NOT INHERITED (-1)? */
	RETURN CFRAME_ERRFUNC(CF);
      CF = CFRAME_PREV(CF);  /* ELSE UNWIND CFRAME AND CONTINUE SEARCHING. */
      IF (CF == NULL)
	RETURN 0;
    }
    SWITCH (FRAME_TYPEP(FRAME)) {
    CASE FRAME_LUA:
    CASE FRAME_LUAP:
      FRAME = FRAME_PREVL(FRAME);
      BREAK;
    CASE FRAME_C:
      CF = CFRAME_PREV(CF);
      /* FALLTHROUGH */
    CASE FRAME_VARG:
      FRAME = FRAME_PREVD(FRAME);
      BREAK;
    CASE FRAME_CONT:
#IF LJ_HASFFI
      IF ((FRAME-1)->U32.LO == LJ_CONT_FFI_CALLBACK)
	CF = CFRAME_PREV(CF);
#ENDIF
      FRAME = FRAME_PREVD(FRAME);
      BREAK;
    CASE FRAME_CP:
      IF (CFRAME_CANYIELD(CF)) RETURN 0;
      IF (CFRAME_ERRFUNC(CF) >= 0)
	RETURN CFRAME_ERRFUNC(CF);
      FRAME = FRAME_PREVD(FRAME);
      BREAK;
    CASE FRAME_PCALL:
    CASE FRAME_PCALLH:
      IF (FRAME_FTSZ(FRAME) >= (PTRDIFF_T)(2*SIZEOF(TVALUE)))  /* XPCALL? */
	RETURN SAVESTACK(L, FRAME-1);  /* POINT TO XPCALL'S ERRORFUNC. */
      RETURN 0;
    DEFAULT:
      LUA_ASSERT(0);
      RETURN 0;
    }
  }
  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 507766_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT EC_GROUP_GET_BASIS_TYPE(CONST EC_GROUP *GROUP)
{
    INT I;

    IF (EC_METHOD_GET_FIELD_TYPE(EC_GROUP_METHOD_OF(GROUP)) !=
        NID_X9_62_CHARACTERISTIC_TWO_FIELD)
        /* EVERYTHING ELSE IS CURRENTLY NOT SUPPORTED */
        RETURN 0;

    /* FIND THE LAST NON-ZERO ELEMENT OF GROUP->POLY[] */
    FOR (I = 0;
         I < (INT)OSSL_NELEM(GROUP->POLY) && GROUP->POLY[I] != 0;
         I++)
        CONTINUE;

    IF (I == 4)
        RETURN NID_X9_62_PPBASIS;
    ELSE IF (I == 2)
        RETURN NID_X9_62_TPBASIS;
    ELSE
        /* EVERYTHING ELSE IS CURRENTLY NOT SUPPORTED */
        RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198476_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_AWAIT_FULFILLED(NJS_VM_T *VM, NJS_VALUE_T *ARGS, NJS_UINT_T NARGS,
    NJS_INDEX_T UNUSED)
{
    NJS_INT_T           RET;
    NJS_VALUE_T         **CUR_LOCAL, **CUR_CLOSURES, **CUR_TEMP, *VALUE;
    NJS_FRAME_T         *FRAME, *ASYNC_FRAME;
    NJS_FUNCTION_T      *FUNCTION;
    NJS_ASYNC_CTX_T     *CTX;
    NJS_NATIVE_FRAME_T  *TOP, *ASYNC;

    CTX = VM->TOP_FRAME->FUNCTION->CONTEXT;

    VALUE = NJS_ARG(ARGS, NARGS, 1);
    IF (NJS_IS_ERROR(VALUE)) {
        GOTO FAILED;
    }

    ASYNC_FRAME = CTX->AWAIT;
    ASYNC = &ASYNC_FRAME->NATIVE;
    ASYNC->PREVIOUS = VM->TOP_FRAME;

    FUNCTION = ASYNC->FUNCTION;

    CUR_LOCAL = VM->LEVELS[NJS_LEVEL_LOCAL];
    CUR_CLOSURES = VM->LEVELS[NJS_LEVEL_CLOSURE];
    CUR_TEMP = VM->LEVELS[NJS_LEVEL_TEMP];
    TOP = VM->TOP_FRAME;
    FRAME = VM->ACTIVE_FRAME;

    VM->LEVELS[NJS_LEVEL_LOCAL] = ASYNC->LOCAL;
    VM->LEVELS[NJS_LEVEL_CLOSURE] = NJS_FUNCTION_CLOSURES(ASYNC->FUNCTION);
    VM->LEVELS[NJS_LEVEL_TEMP] = ASYNC->TEMP;

    VM->TOP_FRAME = ASYNC;
    VM->ACTIVE_FRAME = ASYNC_FRAME;

    *NJS_SCOPE_VALUE(VM, CTX->INDEX) = *VALUE;
    VM->RETVAL = *VALUE;

    VM->TOP_FRAME->RETVAL = &VM->RETVAL;

    FUNCTION->CONTEXT = CTX->CAPABILITY;
    FUNCTION->AWAIT = CTX;

    RET = NJS_VMCODE_INTERPRETER(VM, CTX->PC);

    FUNCTION->CONTEXT = NULL;
    FUNCTION->AWAIT = NULL;

    VM->LEVELS[NJS_LEVEL_LOCAL] = CUR_LOCAL;
    VM->LEVELS[NJS_LEVEL_CLOSURE] = CUR_CLOSURES;
    VM->LEVELS[NJS_LEVEL_TEMP] = CUR_TEMP;

    VM->TOP_FRAME = TOP;
    VM->ACTIVE_FRAME = FRAME;

    IF (RET == NJS_OK) {
        RET = NJS_FUNCTION_CALL(VM, NJS_FUNCTION(&CTX->CAPABILITY->RESOLVE),
                            &NJS_VALUE_UNDEFINED, &VM->RETVAL, 1, &VM->RETVAL);

        NJS_ASYNC_CONTEXT_FREE(VM, CTX);

    } ELSE IF (RET == NJS_AGAIN) {
        RET = NJS_OK;

    } ELSE IF (RET == NJS_ERROR) {
        IF (NJS_IS_MEMORY_ERROR(VM, &VM->RETVAL)) {
            RETURN NJS_ERROR;
        }

        VALUE = &VM->RETVAL;

        GOTO FAILED;
    }

    RETURN RET;

FAILED:

    (VOID) NJS_FUNCTION_CALL(VM, NJS_FUNCTION(&CTX->CAPABILITY->REJECT),
                             &NJS_VALUE_UNDEFINED, VALUE, 1, &VM->RETVAL);

    NJS_ASYNC_CONTEXT_FREE(VM, CTX);

    RETURN NJS_ERROR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197185_CWE-252.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT ADTS_DECODE_EXTRADATA(AVFORMATCONTEXT *S, ADTSCONTEXT *ADTS, CONST UINT8_T *BUF, INT SIZE)
{
    GETBITCONTEXT GB;
    PUTBITCONTEXT PB;
    MPEG4AUDIOCONFIG M4AC;
    INT OFF;

    INIT_GET_BITS(&GB, BUF, SIZE * 8);
    OFF = AVPRIV_MPEG4AUDIO_GET_CONFIG2(&M4AC, BUF, SIZE, 1, S);
    IF (OFF < 0)
        RETURN OFF;
    SKIP_BITS_LONG(&GB, OFF);
    ADTS->OBJECTTYPE        = M4AC.OBJECT_TYPE - 1;
    ADTS->SAMPLE_RATE_INDEX = M4AC.SAMPLING_INDEX;
    ADTS->CHANNEL_CONF      = M4AC.CHAN_CONFIG;

    IF (ADTS->OBJECTTYPE > 3U) {
        AV_LOG(S, AV_LOG_ERROR, "MPEG-4 AOT %D IS NOT ALLOWED IN ADTS\N", ADTS->OBJECTTYPE+1);
        RETURN AVERROR_INVALIDDATA;
    }
    IF (ADTS->SAMPLE_RATE_INDEX == 15) {
        AV_LOG(S, AV_LOG_ERROR, "ESCAPE SAMPLE RATE INDEX ILLEGAL IN ADTS\N");
        RETURN AVERROR_INVALIDDATA;
    }
    IF (GET_BITS(&GB, 1)) {
        AV_LOG(S, AV_LOG_ERROR, "960/120 MDCT WINDOW IS NOT ALLOWED IN ADTS\N");
        RETURN AVERROR_INVALIDDATA;
    }
    IF (GET_BITS(&GB, 1)) {
        AV_LOG(S, AV_LOG_ERROR, "SCALABLE CONFIGURATIONS ARE NOT ALLOWED IN ADTS\N");
        RETURN AVERROR_INVALIDDATA;
    }
    IF (GET_BITS(&GB, 1)) {
        AV_LOG(S, AV_LOG_ERROR, "EXTENSION FLAG IS NOT ALLOWED IN ADTS\N");
        RETURN AVERROR_INVALIDDATA;
    }
    IF (!ADTS->CHANNEL_CONF) {
        INIT_PUT_BITS(&PB, ADTS->PCE_DATA, MAX_PCE_SIZE);

        PUT_BITS(&PB, 3, 5); //ID_PCE
        ADTS->PCE_SIZE = (FF_COPY_PCE_DATA(&PB, &GB) + 3) / 8;
        FLUSH_PUT_BITS(&PB);
    }

    ADTS->WRITE_ADTS = 1;

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359525_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PEER_ADVERTISE_INTERVAL_VTY (STRUCT VTY *VTY, CONST CHAR *IP_STR, 
                             CONST CHAR *TIME_STR, INT SET)  
{
  INT RET;
  STRUCT PEER *PEER;
  U_INT32_T ROUTEADV = 0;

  PEER = PEER_LOOKUP_VTY (VTY, IP_STR);
  IF (! PEER)
    RETURN CMD_WARNING;

  IF (TIME_STR)
    VTY_GET_INTEGER_RANGE ("ADVERTISE INTERVAL", ROUTEADV, TIME_STR, 0, 600);

  IF (SET)
    RET = PEER_ADVERTISE_INTERVAL_SET (PEER, ROUTEADV);
  ELSE
    RET = PEER_ADVERTISE_INTERVAL_UNSET (PEER);

  RETURN CMD_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202081_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_PUT(
    INT		REGNAME,
    CHAR_U	*EXPR_RESULT,	// RESULT FOR REGNAME "=" WHEN COMPILED
    INT		DIR,		// BACKWARD FOR 'P', FORWARD FOR 'P'
    LONG	COUNT,
    INT		FLAGS)
{
    CHAR_U	*PTR;
    CHAR_U	*NEWP, *OLDP;
    INT		YANKLEN;
    INT		TOTLEN = 0;		// INIT FOR GCC
    LINENR_T	LNUM;
    COLNR_T	COL;
    LONG	I;			// INDEX IN Y_ARRAY[]
    INT		Y_TYPE;
    LONG	Y_SIZE;
    INT		OLDLEN;
    LONG	Y_WIDTH = 0;
    COLNR_T	VCOL;
    INT		DELCOUNT;
    INT		INCR = 0;
    LONG	J;
    STRUCT BLOCK_DEF BD;
    CHAR_U	**Y_ARRAY = NULL;
    YANKREG_T	*Y_CURRENT_USED = NULL;
    LONG	NR_LINES = 0;
    POS_T	NEW_CURSOR;
    INT		INDENT;
    INT		ORIG_INDENT = 0;	// INIT FOR GCC
    INT		INDENT_DIFF = 0;	// INIT FOR GCC
    INT		FIRST_INDENT = TRUE;
    INT		LENDIFF = 0;
    POS_T	OLD_POS;
    CHAR_U	*INSERT_STRING = NULL;
    INT		ALLOCATED = FALSE;
    LONG	CNT;
    POS_T	ORIG_START = CURBUF->B_OP_START;
    POS_T	ORIG_END = CURBUF->B_OP_END;
    UNSIGNED INT CUR_VE_FLAGS = GET_VE_FLAGS();

#IFDEF FEAT_CLIPBOARD
    // ADJUST REGISTER NAME FOR "UNNAMED" IN 'CLIPBOARD'.
    ADJUST_CLIP_REG(&REGNAME);
    (VOID)MAY_GET_SELECTION(REGNAME);
#ENDIF

    IF (FLAGS & PUT_FIXINDENT)
	ORIG_INDENT = GET_INDENT();

    CURBUF->B_OP_START = CURWIN->W_CURSOR;	// DEFAULT FOR '[ MARK
    CURBUF->B_OP_END = CURWIN->W_CURSOR;	// DEFAULT FOR '] MARK

    // USING INSERTED TEXT WORKS DIFFERENTLY, BECAUSE THE REGISTER INCLUDES
    // SPECIAL CHARACTERS (NEWLINES, ETC.).
    IF (REGNAME == '.')
    {
	IF (VISUAL_ACTIVE)
	    STUFFCHARREADBUFF(VISUAL_MODE);
	(VOID)STUFF_INSERTED((DIR == FORWARD ? (COUNT == -1 ? 'O' : 'A') :
				    (COUNT == -1 ? 'O' : 'I')), COUNT, FALSE);
	// PUTTING THE TEXT IS DONE LATER, SO CAN'T REALLY MOVE THE CURSOR TO
	// THE NEXT CHARACTER.  USE "L" TO SIMULATE IT.
	IF ((FLAGS & PUT_CURSEND) && GCHAR_CURSOR() != NUL)
	    STUFFCHARREADBUFF('L');
	RETURN;
    }

    // FOR SPECIAL REGISTERS '%' (FILE NAME), '#' (ALTERNATE FILE NAME) AND
    // ':' (LAST COMMAND LINE), ETC. WE HAVE TO CREATE A FAKE YANK REGISTER.
    // FOR COMPILED CODE "EXPR_RESULT" HOLDS THE EXPRESSION RESULT.
    IF (REGNAME == '=' && EXPR_RESULT != NULL)
	INSERT_STRING = EXPR_RESULT;
    ELSE IF (GET_SPEC_REG(REGNAME, &INSERT_STRING, &ALLOCATED, TRUE)
		&& INSERT_STRING == NULL)
	RETURN;

    // AUTOCOMMANDS MAY BE EXECUTED WHEN SAVING LINES FOR UNDO.  THIS MIGHT
    // MAKE "Y_ARRAY" INVALID, SO WE START UNDO NOW TO AVOID THAT.
    IF (U_SAVE(CURWIN->W_CURSOR.LNUM, CURWIN->W_CURSOR.LNUM + 1) == FAIL)
	GOTO END;

    IF (INSERT_STRING != NULL)
    {
	Y_TYPE = MCHAR;
#IFDEF FEAT_EVAL
	IF (REGNAME == '=')
	{
	    // FOR THE = REGISTER WE NEED TO SPLIT THE STRING AT NL
	    // CHARACTERS.
	    // LOOP TWICE: COUNT THE NUMBER OF LINES AND SAVE THEM.
	    FOR (;;)
	    {
		Y_SIZE = 0;
		PTR = INSERT_STRING;
		WHILE (PTR != NULL)
		{
		    IF (Y_ARRAY != NULL)
			Y_ARRAY[Y_SIZE] = PTR;
		    ++Y_SIZE;
		    PTR = VIM_STRCHR(PTR, '\N');
		    IF (PTR != NULL)
		    {
			IF (Y_ARRAY != NULL)
			    *PTR = NUL;
			++PTR;
			// A TRAILING '\N' MAKES THE REGISTER LINEWISE.
			IF (*PTR == NUL)
			{
			    Y_TYPE = MLINE;
			    BREAK;
			}
		    }
		}
		IF (Y_ARRAY != NULL)
		    BREAK;
		Y_ARRAY = ALLOC_MULT(CHAR_U *, Y_SIZE);
		IF (Y_ARRAY == NULL)
		    GOTO END;
	    }
	}
	ELSE
#ENDIF
	{
	    Y_SIZE = 1;		// USE FAKE ONE-LINE YANK REGISTER
	    Y_ARRAY = &INSERT_STRING;
	}
    }
    ELSE
    {
	GET_YANK_REGISTER(REGNAME, FALSE);

	Y_TYPE = Y_CURRENT->Y_TYPE;
	Y_WIDTH = Y_CURRENT->Y_WIDTH;
	Y_SIZE = Y_CURRENT->Y_SIZE;
	Y_ARRAY = Y_CURRENT->Y_ARRAY;
	Y_CURRENT_USED = Y_CURRENT;
    }

    IF (Y_TYPE == MLINE)
    {
	IF (FLAGS & PUT_LINE_SPLIT)
	{
	    CHAR_U *P;

	    // "P" OR "P" IN VISUAL MODE: SPLIT THE LINES TO PUT THE TEXT IN
	    // BETWEEN.
	    IF (U_SAVE_CURSOR() == FAIL)
		GOTO END;
	    P = ML_GET_CURSOR();
	    IF (DIR == FORWARD && *P != NUL)
		MB_PTR_ADV(P);
	    PTR = VIM_STRSAVE(P);
	    IF (PTR == NULL)
		GOTO END;
	    ML_APPEND(CURWIN->W_CURSOR.LNUM, PTR, (COLNR_T)0, FALSE);
	    VIM_FREE(PTR);

	    OLDP = ML_GET_CURLINE();
	    P = OLDP + CURWIN->W_CURSOR.COL;
	    IF (DIR == FORWARD && *P != NUL)
		MB_PTR_ADV(P);
	    PTR = VIM_STRNSAVE(OLDP, P - OLDP);
	    IF (PTR == NULL)
		GOTO END;
	    ML_REPLACE(CURWIN->W_CURSOR.LNUM, PTR, FALSE);
	    ++NR_LINES;
	    DIR = FORWARD;
	}
	IF (FLAGS & PUT_LINE_FORWARD)
	{
	    // MUST BE "P" FOR A VISUAL BLOCK, PUT LINES BELOW THE BLOCK.
	    CURWIN->W_CURSOR = CURBUF->B_VISUAL.VI_END;
	    DIR = FORWARD;
	}
	CURBUF->B_OP_START = CURWIN->W_CURSOR;	// DEFAULT FOR '[ MARK
	CURBUF->B_OP_END = CURWIN->W_CURSOR;	// DEFAULT FOR '] MARK
    }

    IF (FLAGS & PUT_LINE)	// :PUT COMMAND OR "P" IN VISUAL LINE MODE.
	Y_TYPE = MLINE;

    IF (Y_SIZE == 0 || Y_ARRAY == NULL)
    {
	SEMSG(_(E_NOTHING_IN_REGISTER_STR),
		  REGNAME == 0 ? (CHAR_U *)"\"" : TRANSCHAR(REGNAME));
	GOTO END;
    }

    IF (Y_TYPE == MBLOCK)
    {
	LNUM = CURWIN->W_CURSOR.LNUM + Y_SIZE + 1;
	IF (LNUM > CURBUF->B_ML.ML_LINE_COUNT)
	    LNUM = CURBUF->B_ML.ML_LINE_COUNT + 1;
	IF (U_SAVE(CURWIN->W_CURSOR.LNUM - 1, LNUM) == FAIL)
	    GOTO END;
    }
    ELSE IF (Y_TYPE == MLINE)
    {
	LNUM = CURWIN->W_CURSOR.LNUM;
#IFDEF FEAT_FOLDING
	// CORRECT LINE NUMBER FOR CLOSED FOLD.  DON'T MOVE THE CURSOR YET,
	// U_SAVE() USES IT.
	IF (DIR == BACKWARD)
	    (VOID)HASFOLDING(LNUM, &LNUM, NULL);
	ELSE
	    (VOID)HASFOLDING(LNUM, NULL, &LNUM);
#ENDIF
	IF (DIR == FORWARD)
	    ++LNUM;
	// IN AN EMPTY BUFFER THE EMPTY LINE IS GOING TO BE REPLACED, INCLUDE
	// IT IN THE SAVED LINES.
	IF ((BUFEMPTY() ? U_SAVE(0, 2) : U_SAVE(LNUM - 1, LNUM)) == FAIL)
	    GOTO END;
#IFDEF FEAT_FOLDING
	IF (DIR == FORWARD)
	    CURWIN->W_CURSOR.LNUM = LNUM - 1;
	ELSE
	    CURWIN->W_CURSOR.LNUM = LNUM;
	CURBUF->B_OP_START = CURWIN->W_CURSOR;	// FOR MARK_ADJUST()
#ENDIF
    }
    ELSE IF (U_SAVE_CURSOR() == FAIL)
	GOTO END;

    YANKLEN = (INT)STRLEN(Y_ARRAY[0]);

    IF (CUR_VE_FLAGS == VE_ALL && Y_TYPE == MCHAR)
    {
	IF (GCHAR_CURSOR() == TAB)
	{
	    INT VISCOL = GETVISCOL();
	    INT TS = CURBUF->B_P_TS;

	    // DON'T NEED TO INSERT SPACES WHEN "P" ON THE LAST POSITION OF A
	    // TAB OR "P" ON THE FIRST POSITION.
	    IF (DIR == FORWARD ?
#IFDEF FEAT_VARTABS
		    TABSTOP_PADDING(VISCOL, TS, CURBUF->B_P_VTS_ARRAY) != 1
#ELSE
		    TS - (VISCOL % TS) != 1
#ENDIF
		    : CURWIN->W_CURSOR.COLADD > 0)
		COLADVANCE_FORCE(VISCOL);
	    ELSE
		CURWIN->W_CURSOR.COLADD = 0;
	}
	ELSE IF (CURWIN->W_CURSOR.COLADD > 0 || GCHAR_CURSOR() == NUL)
	    COLADVANCE_FORCE(GETVISCOL() + (DIR == FORWARD));
    }

    LNUM = CURWIN->W_CURSOR.LNUM;
    COL = CURWIN->W_CURSOR.COL;

    // BLOCK MODE
    IF (Y_TYPE == MBLOCK)
    {
	INT	C = GCHAR_CURSOR();
	COLNR_T	ENDCOL2 = 0;

	IF (DIR == FORWARD && C != NUL)
	{
	    IF (CUR_VE_FLAGS == VE_ALL)
		GETVCOL(CURWIN, &CURWIN->W_CURSOR, &COL, NULL, &ENDCOL2);
	    ELSE
		GETVCOL(CURWIN, &CURWIN->W_CURSOR, NULL, NULL, &COL);

	    IF (HAS_MBYTE)
		// MOVE TO START OF NEXT MULTI-BYTE CHARACTER
		CURWIN->W_CURSOR.COL += (*MB_PTR2LEN)(ML_GET_CURSOR());
	    ELSE
	    IF (C != TAB || CUR_VE_FLAGS != VE_ALL)
		++CURWIN->W_CURSOR.COL;
	    ++COL;
	}
	ELSE
	    GETVCOL(CURWIN, &CURWIN->W_CURSOR, &COL, NULL, &ENDCOL2);

	COL += CURWIN->W_CURSOR.COLADD;
	IF (CUR_VE_FLAGS == VE_ALL
		&& (CURWIN->W_CURSOR.COLADD > 0
		    || ENDCOL2 == CURWIN->W_CURSOR.COL))
	{
	    IF (DIR == FORWARD && C == NUL)
		++COL;
	    IF (DIR != FORWARD && C != NUL && CURWIN->W_CURSOR.COLADD > 0)
		++CURWIN->W_CURSOR.COL;
	    IF (C == TAB)
	    {
		IF (DIR == BACKWARD && CURWIN->W_CURSOR.COL)
		    CURWIN->W_CURSOR.COL--;
		IF (DIR == FORWARD && COL - 1 == ENDCOL2)
		    CURWIN->W_CURSOR.COL++;
	    }
	}
	CURWIN->W_CURSOR.COLADD = 0;
	BD.TEXTCOL = 0;
	FOR (I = 0; I < Y_SIZE; ++I)
	{
	    INT SPACES = 0;
	    CHAR SHORTLINE;

	    BD.STARTSPACES = 0;
	    BD.ENDSPACES = 0;
	    VCOL = 0;
	    DELCOUNT = 0;

	    // ADD A NEW LINE
	    IF (CURWIN->W_CURSOR.LNUM > CURBUF->B_ML.ML_LINE_COUNT)
	    {
		IF (ML_APPEND(CURBUF->B_ML.ML_LINE_COUNT, (CHAR_U *)"",
						   (COLNR_T)1, FALSE) == FAIL)
		    BREAK;
		++NR_LINES;
	    }
	    // GET THE OLD LINE AND ADVANCE TO THE POSITION TO INSERT AT
	    OLDP = ML_GET_CURLINE();
	    OLDLEN = (INT)STRLEN(OLDP);
	    FOR (PTR = OLDP; VCOL < COL && *PTR; )
	    {
		// COUNT A TAB FOR WHAT IT'S WORTH (IF LIST MODE NOT ON)
		INCR = LBR_CHARTABSIZE_ADV(OLDP, &PTR, VCOL);
		VCOL += INCR;
	    }
	    BD.TEXTCOL = (COLNR_T)(PTR - OLDP);

	    SHORTLINE = (VCOL < COL) || (VCOL == COL && !*PTR) ;

	    IF (VCOL < COL) // LINE TOO SHORT, PADD WITH SPACES
		BD.STARTSPACES = COL - VCOL;
	    ELSE IF (VCOL > COL)
	    {
		BD.ENDSPACES = VCOL - COL;
		BD.STARTSPACES = INCR - BD.ENDSPACES;
		--BD.TEXTCOL;
		DELCOUNT = 1;
		IF (HAS_MBYTE)
		    BD.TEXTCOL -= (*MB_HEAD_OFF)(OLDP, OLDP + BD.TEXTCOL);
		IF (OLDP[BD.TEXTCOL] != TAB)
		{
		    // ONLY A TAB CAN BE SPLIT INTO SPACES.  OTHER
		    // CHARACTERS WILL HAVE TO BE MOVED TO AFTER THE
		    // BLOCK, CAUSING MISALIGNMENT.
		    DELCOUNT = 0;
		    BD.ENDSPACES = 0;
		}
	    }

	    YANKLEN = (INT)STRLEN(Y_ARRAY[I]);

	    IF ((FLAGS & PUT_BLOCK_INNER) == 0)
	    {
		// CALCULATE NUMBER OF SPACES REQUIRED TO FILL RIGHT SIDE OF
		// BLOCK
		SPACES = Y_WIDTH + 1;
		FOR (J = 0; J < YANKLEN; J++)
		    SPACES -= LBR_CHARTABSIZE(NULL, &Y_ARRAY[I][J], 0);
		IF (SPACES < 0)
		    SPACES = 0;
	    }

	    // INSERT THE NEW TEXT.
	    // FIRST CHECK FOR MULTIPLICATION OVERFLOW.
	    IF (YANKLEN + SPACES != 0
		     && COUNT > ((INT_MAX - (BD.STARTSPACES + BD.ENDSPACES))
							/ (YANKLEN + SPACES)))
	    {
		EMSG(_(E_RESULTING_TEXT_TOO_LONG));
		BREAK;
	    }

	    TOTLEN = COUNT * (YANKLEN + SPACES) + BD.STARTSPACES + BD.ENDSPACES;
	    NEWP = ALLOC(TOTLEN + OLDLEN + 1);
	    IF (NEWP == NULL)
		BREAK;

	    // COPY PART UP TO CURSOR TO NEW LINE
	    PTR = NEWP;
	    MCH_MEMMOVE(PTR, OLDP, (SIZE_T)BD.TEXTCOL);
	    PTR += BD.TEXTCOL;

	    // MAY INSERT SOME SPACES BEFORE THE NEW TEXT
	    VIM_MEMSET(PTR, ' ', (SIZE_T)BD.STARTSPACES);
	    PTR += BD.STARTSPACES;

	    // INSERT THE NEW TEXT
	    FOR (J = 0; J < COUNT; ++J)
	    {
		MCH_MEMMOVE(PTR, Y_ARRAY[I], (SIZE_T)YANKLEN);
		PTR += YANKLEN;

		// INSERT BLOCK'S TRAILING SPACES ONLY IF THERE'S TEXT BEHIND
		IF ((J < COUNT - 1 || !SHORTLINE) && SPACES)
		{
		    VIM_MEMSET(PTR, ' ', (SIZE_T)SPACES);
		    PTR += SPACES;
		}
	    }

	    // MAY INSERT SOME SPACES AFTER THE NEW TEXT
	    VIM_MEMSET(PTR, ' ', (SIZE_T)BD.ENDSPACES);
	    PTR += BD.ENDSPACES;

	    // MOVE THE TEXT AFTER THE CURSOR TO THE END OF THE LINE.
	    MCH_MEMMOVE(PTR, OLDP + BD.TEXTCOL + DELCOUNT,
				(SIZE_T)(OLDLEN - BD.TEXTCOL - DELCOUNT + 1));
	    ML_REPLACE(CURWIN->W_CURSOR.LNUM, NEWP, FALSE);

	    ++CURWIN->W_CURSOR.LNUM;
	    IF (I == 0)
		CURWIN->W_CURSOR.COL += BD.STARTSPACES;
	}

	CHANGED_LINES(LNUM, 0, CURWIN->W_CURSOR.LNUM, NR_LINES);

	// SET '[ MARK.
	CURBUF->B_OP_START = CURWIN->W_CURSOR;
	CURBUF->B_OP_START.LNUM = LNUM;

	// ADJUST '] MARK
	CURBUF->B_OP_END.LNUM = CURWIN->W_CURSOR.LNUM - 1;
	CURBUF->B_OP_END.COL = BD.TEXTCOL + TOTLEN - 1;
	CURBUF->B_OP_END.COLADD = 0;
	IF (FLAGS & PUT_CURSEND)
	{
	    COLNR_T LEN;

	    CURWIN->W_CURSOR = CURBUF->B_OP_END;
	    CURWIN->W_CURSOR.COL++;

	    // IN INSERT MODE WE MIGHT BE AFTER THE NUL, CORRECT FOR THAT
	    LEN = (COLNR_T)STRLEN(ML_GET_CURLINE());
	    IF (CURWIN->W_CURSOR.COL > LEN)
		CURWIN->W_CURSOR.COL = LEN;
	}
	ELSE
	    CURWIN->W_CURSOR.LNUM = LNUM;
    }
    ELSE
    {
	// CHARACTER OR LINE MODE
	IF (Y_TYPE == MCHAR)
	{
	    // IF TYPE IS MCHAR, FORWARD IS THE SAME AS BACKWARD ON THE NEXT
	    // CHAR
	    IF (DIR == FORWARD && GCHAR_CURSOR() != NUL)
	    {
		IF (HAS_MBYTE)
		{
		    INT BYTELEN = (*MB_PTR2LEN)(ML_GET_CURSOR());

		    // PUT IT ON THE NEXT OF THE MULTI-BYTE CHARACTER.
		    COL += BYTELEN;
		    IF (YANKLEN)
		    {
			CURWIN->W_CURSOR.COL += BYTELEN;
			CURBUF->B_OP_END.COL += BYTELEN;
		    }
		}
		ELSE
		{
		    ++COL;
		    IF (YANKLEN)
		    {
			++CURWIN->W_CURSOR.COL;
			++CURBUF->B_OP_END.COL;
		    }
		}
	    }
	    CURBUF->B_OP_START = CURWIN->W_CURSOR;
	}
	// LINE MODE: BACKWARD IS THE SAME AS FORWARD ON THE PREVIOUS LINE
	ELSE IF (DIR == BACKWARD)
	    --LNUM;
	NEW_CURSOR = CURWIN->W_CURSOR;

	// SIMPLE CASE: INSERT INTO ONE LINE AT A TIME
	IF (Y_TYPE == MCHAR && Y_SIZE == 1)
	{
	    LINENR_T	END_LNUM = 0; // INIT FOR GCC
	    LINENR_T	START_LNUM = LNUM;
	    INT		FIRST_BYTE_OFF = 0;

	    IF (VISUAL_ACTIVE)
	    {
		END_LNUM = CURBUF->B_VISUAL.VI_END.LNUM;
		IF (END_LNUM < CURBUF->B_VISUAL.VI_START.LNUM)
		    END_LNUM = CURBUF->B_VISUAL.VI_START.LNUM;
		IF (END_LNUM > START_LNUM)
		{
		    POS_T   POS;

		    // "COL" IS VALID FOR THE FIRST LINE, IN FOLLOWING LINES
		    // THE VIRTUAL COLUMN NEEDS TO BE USED.  MATTERS FOR
		    // MULTI-BYTE CHARACTERS.
		    POS.LNUM = LNUM;
		    POS.COL = COL;
		    POS.COLADD = 0;
		    GETVCOL(CURWIN, &POS, NULL, &VCOL, NULL);
		}
	    }

	    IF (COUNT == 0 || YANKLEN == 0)
	    {
		IF (VISUAL_ACTIVE)
		    LNUM = END_LNUM;
	    }
	    ELSE IF (COUNT > INT_MAX / YANKLEN)
		// MULTIPLICATION OVERFLOW
		EMSG(_(E_RESULTING_TEXT_TOO_LONG));
	    ELSE
	    {
		TOTLEN = COUNT * YANKLEN;
		DO {
		    OLDP = ML_GET(LNUM);
		    OLDLEN = (INT)STRLEN(OLDP);
		    IF (LNUM > START_LNUM)
		    {
			POS_T   POS;

			POS.LNUM = LNUM;
			IF (GETVPOS(&POS, VCOL) == OK)
			    COL = POS.COL;
			ELSE
			    COL = MAXCOL;
		    }
		    IF (VISUAL_ACTIVE && COL > OLDLEN)
		    {
			LNUM++;
			CONTINUE;
		    }
		    NEWP = ALLOC(TOTLEN + OLDLEN + 1);
		    IF (NEWP == NULL)
			GOTO END;	// ALLOC() GAVE AN ERROR MESSAGE
		    MCH_MEMMOVE(NEWP, OLDP, (SIZE_T)COL);
		    PTR = NEWP + COL;
		    FOR (I = 0; I < COUNT; ++I)
		    {
			MCH_MEMMOVE(PTR, Y_ARRAY[0], (SIZE_T)YANKLEN);
			PTR += YANKLEN;
		    }
		    STRMOVE(PTR, OLDP + COL);
		    ML_REPLACE(LNUM, NEWP, FALSE);

		    // COMPUTE THE BYTE OFFSET FOR THE LAST CHARACTER
		    FIRST_BYTE_OFF = MB_HEAD_OFF(NEWP, PTR - 1);

		    // PLACE CURSOR ON LAST PUTTED CHAR.
		    IF (LNUM == CURWIN->W_CURSOR.LNUM)
		    {
			// MAKE SURE CURWIN->W_VIRTCOL IS UPDATED
			CHANGED_CLINE_BEF_CURS();
			CURWIN->W_CURSOR.COL += (COLNR_T)(TOTLEN - 1);
		    }
		    IF (VISUAL_ACTIVE)
			LNUM++;
		} WHILE (VISUAL_ACTIVE && LNUM <= END_LNUM);

		IF (VISUAL_ACTIVE) // RESET LNUM TO THE LAST VISUAL LINE
		    LNUM--;
	    }

	    // PUT '] AT THE FIRST BYTE OF THE LAST CHARACTER
	    CURBUF->B_OP_END = CURWIN->W_CURSOR;
	    CURBUF->B_OP_END.COL -= FIRST_BYTE_OFF;

	    // FOR "CTRL-O P" IN INSERT MODE, PUT CURSOR AFTER LAST CHAR
	    IF (TOTLEN && (RESTART_EDIT != 0 || (FLAGS & PUT_CURSEND)))
		++CURWIN->W_CURSOR.COL;
	    ELSE
		CURWIN->W_CURSOR.COL -= FIRST_BYTE_OFF;
	    CHANGED_BYTES(LNUM, COL);
	}
	ELSE
	{
	    LINENR_T	NEW_LNUM = NEW_CURSOR.LNUM;
	    SIZE_T	LEN;

	    // INSERT AT LEAST ONE LINE.  WHEN Y_TYPE IS MCHAR, BREAK THE FIRST
	    // LINE IN TWO.
	    FOR (CNT = 1; CNT <= COUNT; ++CNT)
	    {
		I = 0;
		IF (Y_TYPE == MCHAR)
		{
		    // SPLIT THE CURRENT LINE IN TWO AT THE INSERT POSITION.
		    // FIRST INSERT Y_ARRAY[SIZE - 1] IN FRONT OF SECOND LINE.
		    // THEN APPEND Y_ARRAY[0] TO FIRST LINE.
		    LNUM = NEW_CURSOR.LNUM;
		    PTR = ML_GET(LNUM) + COL;
		    TOTLEN = (INT)STRLEN(Y_ARRAY[Y_SIZE - 1]);
		    NEWP = ALLOC(STRLEN(PTR) + TOTLEN + 1);
		    IF (NEWP == NULL)
			GOTO ERROR;
		    STRCPY(NEWP, Y_ARRAY[Y_SIZE - 1]);
		    STRCAT(NEWP, PTR);
		    // INSERT SECOND LINE
		    ML_APPEND(LNUM, NEWP, (COLNR_T)0, FALSE);
		    ++NEW_LNUM;
		    VIM_FREE(NEWP);

		    OLDP = ML_GET(LNUM);
		    NEWP = ALLOC(COL + YANKLEN + 1);
		    IF (NEWP == NULL)
			GOTO ERROR;
					    // COPY FIRST PART OF LINE
		    MCH_MEMMOVE(NEWP, OLDP, (SIZE_T)COL);
					    // APPEND TO FIRST LINE
		    MCH_MEMMOVE(NEWP + COL, Y_ARRAY[0], (SIZE_T)(YANKLEN + 1));
		    ML_REPLACE(LNUM, NEWP, FALSE);

		    CURWIN->W_CURSOR.LNUM = LNUM;
		    I = 1;
		}

		FOR (; I < Y_SIZE; ++I)
		{
		    IF (Y_TYPE != MCHAR || I < Y_SIZE - 1)
		    {
			IF (ML_APPEND(LNUM, Y_ARRAY[I], (COLNR_T)0, FALSE)
								      == FAIL)
			    GOTO ERROR;
			NEW_LNUM++;
		    }
		    LNUM++;
		    ++NR_LINES;
		    IF (FLAGS & PUT_FIXINDENT)
		    {
			OLD_POS = CURWIN->W_CURSOR;
			CURWIN->W_CURSOR.LNUM = LNUM;
			PTR = ML_GET(LNUM);
			IF (CNT == COUNT && I == Y_SIZE - 1)
			    LENDIFF = (INT)STRLEN(PTR);
			IF (*PTR == '#' && PREPROCS_LEFT())
			    INDENT = 0;     // LEAVE # LINES AT START
			ELSE
			     IF (*PTR == NUL)
			    INDENT = 0;     // IGNORE EMPTY LINES
			ELSE IF (FIRST_INDENT)
			{
			    INDENT_DIFF = ORIG_INDENT - GET_INDENT();
			    INDENT = ORIG_INDENT;
			    FIRST_INDENT = FALSE;
			}
			ELSE IF ((INDENT = GET_INDENT() + INDENT_DIFF) < 0)
			    INDENT = 0;
			(VOID)SET_INDENT(INDENT, 0);
			CURWIN->W_CURSOR = OLD_POS;
			// REMEMBER HOW MANY CHARS WERE REMOVED
			IF (CNT == COUNT && I == Y_SIZE - 1)
			    LENDIFF -= (INT)STRLEN(ML_GET(LNUM));
		    }
		}
		IF (CNT == 1)
		    NEW_LNUM = LNUM;
	    }

ERROR:
	    // ADJUST MARKS.
	    IF (Y_TYPE == MLINE)
	    {
		CURBUF->B_OP_START.COL = 0;
		IF (DIR == FORWARD)
		    CURBUF->B_OP_START.LNUM++;
	    }
	    // SKIP MARK_ADJUST WHEN ADDING LINES AFTER THE LAST ONE, THERE
	    // CAN'T BE MARKS THERE. BUT STILL NEEDED IN DIFF MODE.
	    IF (CURBUF->B_OP_START.LNUM + (Y_TYPE == MCHAR) - 1 + NR_LINES
						 < CURBUF->B_ML.ML_LINE_COUNT
#IFDEF FEAT_DIFF
						 || CURWIN->W_P_DIFF
#ENDIF
						 )
		MARK_ADJUST(CURBUF->B_OP_START.LNUM + (Y_TYPE == MCHAR),
					     (LINENR_T)MAXLNUM, NR_LINES, 0L);

	    // NOTE CHANGED TEXT FOR DISPLAYING AND FOLDING
	    IF (Y_TYPE == MCHAR)
		CHANGED_LINES(CURWIN->W_CURSOR.LNUM, COL,
					 CURWIN->W_CURSOR.LNUM + 1, NR_LINES);
	    ELSE
		CHANGED_LINES(CURBUF->B_OP_START.LNUM, 0,
					   CURBUF->B_OP_START.LNUM, NR_LINES);
	    IF (Y_CURRENT_USED != NULL && (Y_CURRENT_USED != Y_CURRENT
					     || Y_CURRENT->Y_ARRAY != Y_ARRAY))
	    {
		// SOMETHING INVOKED THROUGH CHANGED_LINES() HAS CHANGED THE
		// YANK BUFFER, E.G. A GUI CLIPBOARD CALLBACK.
		EMSG(_(E_YANK_REGISTER_CHANGED_WHILE_USING_IT));
		GOTO END;
	    }

	    // PUT THE '] MARK ON THE FIRST BYTE OF THE LAST INSERTED CHARACTER.
	    // CORRECT THE LENGTH FOR CHANGE IN INDENT.
	    CURBUF->B_OP_END.LNUM = NEW_LNUM;
	    LEN = STRLEN(Y_ARRAY[Y_SIZE - 1]);
	    COL = (COLNR_T)LEN - LENDIFF;
	    IF (COL > 1)
	    {
		CURBUF->B_OP_END.COL = COL - 1;
		IF (LEN > 0)
		    CURBUF->B_OP_END.COL -= MB_HEAD_OFF(Y_ARRAY[Y_SIZE - 1],
						Y_ARRAY[Y_SIZE - 1] + LEN - 1);
	    }
	    ELSE
		CURBUF->B_OP_END.COL = 0;

	    IF (FLAGS & PUT_CURSLINE)
	    {
		// ":PUT": PUT CURSOR ON LAST INSERTED LINE
		CURWIN->W_CURSOR.LNUM = LNUM;
		BEGINLINE(BL_WHITE | BL_FIX);
	    }
	    ELSE IF (FLAGS & PUT_CURSEND)
	    {
		// PUT CURSOR AFTER INSERTED TEXT
		IF (Y_TYPE == MLINE)
		{
		    IF (LNUM >= CURBUF->B_ML.ML_LINE_COUNT)
			CURWIN->W_CURSOR.LNUM = CURBUF->B_ML.ML_LINE_COUNT;
		    ELSE
			CURWIN->W_CURSOR.LNUM = LNUM + 1;
		    CURWIN->W_CURSOR.COL = 0;
		}
		ELSE
		{
		    CURWIN->W_CURSOR.LNUM = NEW_LNUM;
		    CURWIN->W_CURSOR.COL = COL;
		    CURBUF->B_OP_END = CURWIN->W_CURSOR;
		    IF (COL > 1)
			CURBUF->B_OP_END.COL = COL - 1;
		}
	    }
	    ELSE IF (Y_TYPE == MLINE)
	    {
		// PUT CURSOR ON FIRST NON-BLANK IN FIRST INSERTED LINE
		CURWIN->W_CURSOR.COL = 0;
		IF (DIR == FORWARD)
		    ++CURWIN->W_CURSOR.LNUM;
		BEGINLINE(BL_WHITE | BL_FIX);
	    }
	    ELSE	// PUT CURSOR ON FIRST INSERTED CHARACTER
		CURWIN->W_CURSOR = NEW_CURSOR;
	}
    }

    MSGMORE(NR_LINES);
    CURWIN->W_SET_CURSWANT = TRUE;

END:
    IF (CMDMOD.CMOD_FLAGS & CMOD_LOCKMARKS)
    {
	CURBUF->B_OP_START = ORIG_START;
	CURBUF->B_OP_END = ORIG_END;
    }
    IF (ALLOCATED)
	VIM_FREE(INSERT_STRING);
    IF (REGNAME == '=')
	VIM_FREE(Y_ARRAY);

    VISUAL_ACTIVE = FALSE;

    // IF THE CURSOR IS PAST THE END OF THE LINE PUT IT AT THE END.
    ADJUST_CURSOR_EOL();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213589_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PROCESS_BUTTON(STRUCT PARSED_TAG *TAG)
{
    STR TMP = NULL;
    CHAR *P, *Q, *R, *QQ = "";
    INT QLEN, V;

    IF (CUR_FORM_ID < 0) {
       CHAR *S = "<FORM_INT METHOD=INTERNAL ACTION=NONE>";
       TMP = PROCESS_FORM(PARSE_TAG(&S, TRUE));
    }
    IF (TMP == NULL)
       TMP = STRNEW();

    P = "SUBMIT";
    PARSEDTAG_GET_VALUE(TAG, ATTR_TYPE, &P);
    Q = NULL;
    PARSEDTAG_GET_VALUE(TAG, ATTR_VALUE, &Q);
    R = "";
    PARSEDTAG_GET_VALUE(TAG, ATTR_NAME, &R);

    V = FORMTYPE(P);
    IF (V == FORM_UNKNOWN)
       RETURN NULL;

    IF (!Q) {
       SWITCH (V) {
       CASE FORM_INPUT_SUBMIT:
       CASE FORM_INPUT_BUTTON:
           Q = "SUBMIT";
           BREAK;
       CASE FORM_INPUT_RESET:
           Q = "RESET";
           BREAK;
       }
    }
    IF (Q) {
       QQ = HTML_QUOTE(Q);
       QLEN = STRLEN(Q);
    }

    /*    STRCAT_CHARP(TMP, "<PRE_INT>"); */
    STRCAT(TMP, SPRINTF("<INPUT_ALT HSEQ=\"%D\" FID=\"%D\" TYPE=\"%S\" "
                       "NAME=\"%S\" VALUE=\"%S\">",
                       CUR_HSEQ++, CUR_FORM_ID, HTML_QUOTE(P),
                       HTML_QUOTE(R), QQ));
    RETURN TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244245_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR PROJ_TYPE_BOX_WRITE(GF_BOX *S, GF_BITSTREAM *BS)
{
	GF_ERR E;
	GF_PROJECTIONTYPEBOX *PTR = (GF_PROJECTIONTYPEBOX *)S;

	E = GF_ISOM_FULL_BOX_WRITE(S, BS);
	IF (E) RETURN E;
	IF (PTR->TYPE==GF_ISOM_BOX_TYPE_CBMP) {
		GF_BS_WRITE_U32(BS, PTR->LAYOUT);
		GF_BS_WRITE_U32(BS, PTR->PADDING);
	}
	ELSE IF (PTR->TYPE==GF_ISOM_BOX_TYPE_EQUI) {
		GF_BS_WRITE_U32(BS, PTR->BOUNDS_TOP);
		GF_BS_WRITE_U32(BS, PTR->BOUNDS_BOTTOM);
		GF_BS_WRITE_U32(BS, PTR->BOUNDS_LEFT);
		GF_BS_WRITE_U32(BS, PTR->BOUNDS_RIGHT);
	} ELSE {
		GF_BS_WRITE_U32(BS, PTR->CRC);
		GF_BS_WRITE_U32(BS, PTR->ENCODING_4CC);
	}
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 246455_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CONST CHAR *R_BIN_WASM_VALUETYPE_TO_STRING (R_BIN_WASM_VALUE_TYPE_T TYPE) {
	SWITCH (TYPE) {
	CASE R_BIN_WASM_VALUETYPE_I32:
		RETURN "I32";
	CASE R_BIN_WASM_VALUETYPE_I64:
		RETURN "I62";
	CASE R_BIN_WASM_VALUETYPE_F32:
		RETURN "F32";
	CASE R_BIN_WASM_VALUETYPE_F64:
		RETURN "F64";
	CASE R_BIN_WASM_VALUETYPE_REFTYPE:
		RETURN "ANYFUNC";
	CASE R_BIN_WASM_VALUETYPE_FUNC:
		RETURN "FUNC";
	DEFAULT:
		RETURN "<?>";
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 317162_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SMACK_FILE_LOCK(STRUCT FILE *FILE, UNSIGNED INT CMD)
{
	STRUCT SMK_AUDIT_INFO AD;
	INT RC;
	STRUCT INODE *INODE = FILE_INODE(FILE);

	IF (UNLIKELY(IS_PRIVATE(INODE)))
		RETURN 0;

	SMK_AD_INIT(&AD, __FUNC__, LSM_AUDIT_DATA_PATH);
	SMK_AD_SETFIELD_U_FS_PATH(&AD, FILE->F_PATH);
	RC = SMK_CURACC(SMK_OF_INODE(INODE), MAY_LOCK, &AD);
	RC = SMK_BU_FILE(FILE, MAY_LOCK, RC);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 333549_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT GDTRANSFORMAFFINEBOUNDINGBOX(GDRECTPTR SRC, CONST DOUBLE AFFINE[6], GDRECTPTR BBOX)
{
	GDPOINTF EXTENT[4], MIN, MAX, POINT;
	INT I;

	EXTENT[0].X=0.0;
	EXTENT[0].Y=0.0;
	EXTENT[1].X=(DOUBLE) SRC->WIDTH;
	EXTENT[1].Y=0.0;
	EXTENT[2].X=(DOUBLE) SRC->WIDTH;
	EXTENT[2].Y=(DOUBLE) SRC->HEIGHT;
	EXTENT[3].X=0.0;
	EXTENT[3].Y=(DOUBLE) SRC->HEIGHT;

	FOR (I=0; I < 4; I++) {
		POINT=EXTENT[I];
		IF (GDAFFINEAPPLYTOPOINTF(&EXTENT[I], &POINT, AFFINE) != GD_TRUE) {
			RETURN GD_FALSE;
		}
	}
	MIN=EXTENT[0];
	MAX=EXTENT[0];

	FOR (I=1; I < 4; I++) {
		IF (MIN.X > EXTENT[I].X)
			MIN.X=EXTENT[I].X;
		IF (MIN.Y > EXTENT[I].Y)
			MIN.Y=EXTENT[I].Y;
		IF (MAX.X < EXTENT[I].X)
			MAX.X=EXTENT[I].X;
		IF (MAX.Y < EXTENT[I].Y)
			MAX.Y=EXTENT[I].Y;
	}
	BBOX->X = (INT) MIN.X;
	BBOX->Y = (INT) MIN.Y;
	BBOX->WIDTH  = (INT) FLOOR(MAX.X - MIN.X) - 1;
	BBOX->HEIGHT = (INT) FLOOR(MAX.Y - MIN.Y);
	RETURN GD_TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199841_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL LOAD_BUFFER(RBINFILE *BF, VOID **BIN_OBJ, RBUFFER *BUF, UT64 LOADADDR, SDB *SDB) {
	RBUFFER *FBUF = R_BUF_REF (BUF);
	STRUCT MACH0_(OPTS_T) OPTS;
	MACH0_(OPTS_SET_DEFAULT) (&OPTS, BF);
	STRUCT MACH0_(OBJ_T) *MAIN_MACH0 = MACH0_(NEW_BUF) (FBUF, &OPTS);
	IF (!MAIN_MACH0) {
		RETURN FALSE;
	}

	RREBASEINFO *REBASE_INFO = R_REBASE_INFO_NEW_FROM_MACH0 (FBUF, MAIN_MACH0);
	RKERNELCACHEOBJ *OBJ = NULL;

	RPRELINKRANGE *PRELINK_RANGE = GET_PRELINK_INFO_RANGE_FROM_MACH0 (MAIN_MACH0);
	IF (!PRELINK_RANGE) {
		GOTO BEACH;
	}

	OBJ = R_NEW0 (RKERNELCACHEOBJ);
	IF (!OBJ) {
		R_FREE (PRELINK_RANGE);
		GOTO BEACH;
	}

	RCFVALUEDICT *PRELINK_INFO = NULL;
	IF (MAIN_MACH0->HDR.FILETYPE != MH_FILESET && PRELINK_RANGE->RANGE.SIZE) {
		PRELINK_INFO = R_CF_VALUE_DICT_PARSE (FBUF, PRELINK_RANGE->RANGE.OFFSET,
				PRELINK_RANGE->RANGE.SIZE, R_CF_OPTION_SKIP_NSDATA);
		IF (!PRELINK_INFO) {
			R_FREE (PRELINK_RANGE);
			R_FREE (OBJ);
			GOTO BEACH;
		}
	}

	IF (!PENDING_BIN_FILES) {
		PENDING_BIN_FILES = R_LIST_NEW ();
		IF (!PENDING_BIN_FILES) {
			R_FREE (PRELINK_RANGE);
			R_FREE (OBJ);
			R_FREE (PRELINK_INFO);
			GOTO BEACH;
		}
	}

	OBJ->MACH0 = MAIN_MACH0;
	OBJ->REBASE_INFO = REBASE_INFO;
	OBJ->PRELINK_INFO = PRELINK_INFO;
	OBJ->CACHE_BUF = FBUF;
	OBJ->PA2VA_EXEC = PRELINK_RANGE->PA2VA_EXEC;
	OBJ->PA2VA_DATA = PRELINK_RANGE->PA2VA_DATA;

	R_FREE (PRELINK_RANGE);

	*BIN_OBJ = OBJ;

	R_LIST_PUSH (PENDING_BIN_FILES, BF);

	IF (REBASE_INFO || MAIN_MACH0->CHAINED_STARTS) {
		RIO *IO = BF->RBIN->IOB.IO;
		SWIZZLE_IO_READ (OBJ, IO);
	}

	RETURN TRUE;

BEACH:
	R_BUF_FREE (FBUF);
	OBJ->CACHE_BUF = NULL;
	MACH0_(MACH0_FREE) (MAIN_MACH0);
	RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215038_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GST_FLXDEC_CHAIN (GSTPAD * PAD, GSTOBJECT * PARENT, GSTBUFFER * BUF)
{
  GSTCAPS *CAPS;
  GUINT AVAIL;
  GSTFLOWRETURN RES = GST_FLOW_OK;

  GSTFLXDEC *FLXDEC;
  FLXHEADER *FLXH;

  G_RETURN_VAL_IF_FAIL (BUF != NULL, GST_FLOW_ERROR);
  FLXDEC = (GSTFLXDEC *) PARENT;
  G_RETURN_VAL_IF_FAIL (FLXDEC != NULL, GST_FLOW_ERROR);

  GST_ADAPTER_PUSH (FLXDEC->ADAPTER, BUF);
  AVAIL = GST_ADAPTER_AVAILABLE (FLXDEC->ADAPTER);

  IF (FLXDEC->STATE == GST_FLXDEC_READ_HEADER) {
    IF (AVAIL >= FLXHEADERSIZE) {
      CONST GUINT8 *DATA = GST_ADAPTER_MAP (FLXDEC->ADAPTER, FLXHEADERSIZE);
      GSTCAPS *TEMPL;

      MEMCPY ((GCHAR *) & FLXDEC->HDR, DATA, FLXHEADERSIZE);
      FLX_HDR_FIX_ENDIANNESS (&(FLXDEC->HDR));
      GST_ADAPTER_UNMAP (FLXDEC->ADAPTER);
      GST_ADAPTER_FLUSH (FLXDEC->ADAPTER, FLXHEADERSIZE);

      FLXH = &FLXDEC->HDR;

      /* CHECK HEADER */
      IF (FLXH->TYPE != FLX_MAGICHDR_FLI &&
          FLXH->TYPE != FLX_MAGICHDR_FLC && FLXH->TYPE != FLX_MAGICHDR_FLX)
        GOTO WRONG_TYPE;

      GST_LOG ("SIZE      :  %D", FLXH->SIZE);
      GST_LOG ("FRAMES    :  %D", FLXH->FRAMES);
      GST_LOG ("WIDTH     :  %D", FLXH->WIDTH);
      GST_LOG ("HEIGHT    :  %D", FLXH->HEIGHT);
      GST_LOG ("DEPTH     :  %D", FLXH->DEPTH);
      GST_LOG ("SPEED     :  %D", FLXH->SPEED);

      FLXDEC->NEXT_TIME = 0;

      IF (FLXH->TYPE == FLX_MAGICHDR_FLI) {
        FLXDEC->FRAME_TIME = JIFFIE * FLXH->SPEED;
      } ELSE IF (FLXH->SPEED == 0) {
        FLXDEC->FRAME_TIME = GST_SECOND / 70;
      } ELSE {
        FLXDEC->FRAME_TIME = FLXH->SPEED * GST_MSECOND;
      }

      FLXDEC->DURATION = FLXH->FRAMES * FLXDEC->FRAME_TIME;
      GST_LOG ("DURATION   :  %" GST_TIME_FORMAT,
          GST_TIME_ARGS (FLXDEC->DURATION));

      TEMPL = GST_PAD_GET_PAD_TEMPLATE_CAPS (FLXDEC->SRCPAD);
      CAPS = GST_CAPS_COPY (TEMPL);
      GST_CAPS_UNREF (TEMPL);
      GST_CAPS_SET_SIMPLE (CAPS,
          "WIDTH", G_TYPE_INT, FLXH->WIDTH,
          "HEIGHT", G_TYPE_INT, FLXH->HEIGHT,
          "FRAMERATE", GST_TYPE_FRACTION, (GINT) GST_MSECOND,
          (GINT) FLXDEC->FRAME_TIME / 1000, NULL);

      GST_PAD_SET_CAPS (FLXDEC->SRCPAD, CAPS);
      GST_CAPS_UNREF (CAPS);

      IF (FLXH->DEPTH <= 8)
        FLXDEC->CONVERTER =
            FLX_COLORSPACE_CONVERTER_NEW (FLXH->WIDTH, FLXH->HEIGHT);

      IF (FLXH->TYPE == FLX_MAGICHDR_FLC || FLXH->TYPE == FLX_MAGICHDR_FLX) {
        GST_LOG ("(FLC) ASPECT_DX :  %D", FLXH->ASPECT_DX);
        GST_LOG ("(FLC) ASPECT_DY :  %D", FLXH->ASPECT_DY);
        GST_LOG ("(FLC) OFRAME1   :  0X%08X", FLXH->OFRAME1);
        GST_LOG ("(FLC) OFRAME2   :  0X%08X", FLXH->OFRAME2);
      }

      FLXDEC->SIZE = ((GUINT) FLXH->WIDTH * (GUINT) FLXH->HEIGHT);

      /* CREATE DELTA AND OUTPUT FRAME */
      FLXDEC->FRAME_DATA = G_MALLOC (FLXDEC->SIZE);
      FLXDEC->DELTA_DATA = G_MALLOC (FLXDEC->SIZE);

      FLXDEC->STATE = GST_FLXDEC_PLAYING;
    }
  } ELSE IF (FLXDEC->STATE == GST_FLXDEC_PLAYING) {
    GSTBUFFER *OUT;

    /* WHILE WE HAVE ENOUGH DATA IN THE ADAPTER */
    WHILE (AVAIL >= FLXFRAMECHUNKSIZE && RES == GST_FLOW_OK) {
      FLXFRAMECHUNK FLXFH;
      GUCHAR *CHUNK;
      CONST GUINT8 *DATA;
      GSTMAPINFO MAP;

      CHUNK = NULL;
      DATA = GST_ADAPTER_MAP (FLXDEC->ADAPTER, FLXFRAMECHUNKSIZE);
      MEMCPY (&FLXFH, DATA, FLXFRAMECHUNKSIZE);
      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&FLXFH);
      GST_ADAPTER_UNMAP (FLXDEC->ADAPTER);

      SWITCH (FLXFH.ID) {
        CASE FLX_FRAME_TYPE:
          /* CHECK IF WE HAVE THE COMPLETE FRAME */
          IF (AVAIL < FLXFH.SIZE)
            GOTO NEED_MORE_DATA;

          /* FLUSH HEADER */
          GST_ADAPTER_FLUSH (FLXDEC->ADAPTER, FLXFRAMECHUNKSIZE);

          CHUNK = GST_ADAPTER_TAKE (FLXDEC->ADAPTER,
              FLXFH.SIZE - FLXFRAMECHUNKSIZE);
          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FLXFRAMETYPE *) CHUNK);
          IF (((FLXFRAMETYPE *) CHUNK)->CHUNKS == 0)
            BREAK;

          /* CREATE 32 BITS OUTPUT FRAME */
//          RES = GST_PAD_ALLOC_BUFFER_AND_SET_CAPS (FLXDEC->SRCPAD,
//              GST_BUFFER_OFFSET_NONE,
//              FLXDEC->SIZE * 4, GST_PAD_CAPS (FLXDEC->SRCPAD), &OUT);
//          IF (RES != GST_FLOW_OK)
//            BREAK;

          OUT = GST_BUFFER_NEW_AND_ALLOC (FLXDEC->SIZE * 4);

          /* DECODE CHUNKS */
          IF (!FLX_DECODE_CHUNKS (FLXDEC,
                  ((FLXFRAMETYPE *) CHUNK)->CHUNKS,
                  CHUNK + FLXFRAMETYPESIZE, FLXDEC->FRAME_DATA)) {
            GST_ELEMENT_ERROR (FLXDEC, STREAM, DECODE,
                ("%S", "COULD NOT DECODE CHUNK"), NULL);
            RETURN GST_FLOW_ERROR;
          }

          /* SAVE COPY OF THE CURRENT FRAME FOR POSSIBLE DELTA. */
          MEMCPY (FLXDEC->DELTA_DATA, FLXDEC->FRAME_DATA, FLXDEC->SIZE);

          GST_BUFFER_MAP (OUT, &MAP, GST_MAP_WRITE);
          /* CONVERT CURRENT FRAME. */
          FLX_COLORSPACE_CONVERT (FLXDEC->CONVERTER, FLXDEC->FRAME_DATA,
              MAP.DATA);
          GST_BUFFER_UNMAP (OUT, &MAP);

          GST_BUFFER_TIMESTAMP (OUT) = FLXDEC->NEXT_TIME;
          FLXDEC->NEXT_TIME += FLXDEC->FRAME_TIME;

          RES = GST_PAD_PUSH (FLXDEC->SRCPAD, OUT);
          BREAK;
        DEFAULT:
          /* CHECK IF WE HAVE THE COMPLETE FRAME */
          IF (AVAIL < FLXFH.SIZE)
            GOTO NEED_MORE_DATA;

          GST_ADAPTER_FLUSH (FLXDEC->ADAPTER, FLXFH.SIZE);
          BREAK;
      }

      G_FREE (CHUNK);

      AVAIL = GST_ADAPTER_AVAILABLE (FLXDEC->ADAPTER);
    }
  }
NEED_MORE_DATA:
  RETURN RES;

  /* ERRORS */
WRONG_TYPE:
  {
    GST_ELEMENT_ERROR (FLXDEC, STREAM, WRONG_TYPE, (NULL),
        ("NOT A FLX FILE (TYPE %X)", FLXH->TYPE));
    GST_OBJECT_UNREF (FLXDEC);
    RETURN GST_FLOW_ERROR;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 314776_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CDF_READ_SECTOR(CONST CDF_INFO_T *INFO, VOID *BUF, SIZE_T OFFS, SIZE_T LEN,
    CONST CDF_HEADER_T *H, CDF_SECID_T ID)
{
	SIZE_T SS = CDF_SEC_SIZE(H);
	SIZE_T POS = CDF_SEC_POS(H, ID);
	ASSERT(SS == LEN);
	RETURN CDF_READ(INFO, (OFF_T)POS, ((CHAR *)BUF) + OFFS, LEN);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 312511_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
QF_OPEN_NEW_FILE_WIN(QF_INFO_T *LL_REF)
{
    INT		FLAGS;

    FLAGS = WSP_ABOVE;
    IF (LL_REF != NULL)
	FLAGS |= WSP_NEWLOC;
    IF (WIN_SPLIT(0, FLAGS) == FAIL)
	RETURN FAIL;		// NOT ENOUGH ROOM FOR WINDOW
    P_SWB = EMPTY_OPTION;	// DON'T SPLIT AGAIN
    SWB_FLAGS = 0;
    RESET_BINDING(CURWIN);
    IF (LL_REF != NULL)
	// THE NEW WINDOW SHOULD USE THE LOCATION LIST FROM THE
	// LOCATION LIST WINDOW
	WIN_SET_LOCLIST(CURWIN, LL_REF);
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 413698_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL ISVALIDSYMBOL(RBINSYMBOL *SYMBOL) {
	IF (SYMBOL && SYMBOL->TYPE) {
		CONST CHAR *TYPE = SYMBOL->TYPE;
		RETURN (SYMBOL->PADDR != UT64_MAX) && (!STRCMP (TYPE, R_BIN_TYPE_FUNC_STR) || !STRCMP (TYPE, R_BIN_TYPE_HIOS_STR) || !STRCMP (TYPE, R_BIN_TYPE_LOOS_STR) || !STRCMP (TYPE, R_BIN_TYPE_METH_STR) || !STRCMP (TYPE , R_BIN_TYPE_STATIC_STR));
	}
	RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220419_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_ARY_ENTRY(MRB_VALUE ARY, MRB_INT N)
{
  STRUCT RARRAY *A = MRB_ARY_PTR(ARY);
  MRB_INT LEN = ARY_LEN(A);

  /* RANGE CHECK */
  IF (N < 0) N += LEN;
  IF (N < 0 || LEN <= N) RETURN MRB_NIL_VALUE();

  RETURN ARY_PTR(A)[N];
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369384_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

STATIC INT IO_EVENTFD_UNREGISTER(STRUCT IO_RING_CTX *CTX)
{
	STRUCT IO_EV_FD *EV_FD;

	EV_FD = RCU_DEREFERENCE_PROTECTED(CTX->IO_EV_FD,
					LOCKDEP_IS_HELD(&CTX->URING_LOCK));
	IF (EV_FD) {
		CTX->HAS_EVFD = FALSE;
		RCU_ASSIGN_POINTER(CTX->IO_EV_FD, NULL);
		CALL_RCU(&EV_FD->RCU, IO_EVENTFD_PUT);
		RETURN 0;
	}

	RETURN -ENXIO;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198736_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT RSI_SEND_BEACON(STRUCT RSI_COMMON *COMMON)
{
	STRUCT SK_BUFF *SKB = NULL;
	U8 DWORD_ALIGN_BYTES = 0;

	SKB = DEV_ALLOC_SKB(MAX_MGMT_PKT_SIZE);
	IF (!SKB)
		RETURN -ENOMEM;

	MEMSET(SKB->DATA, 0, MAX_MGMT_PKT_SIZE);

	DWORD_ALIGN_BYTES = ((UNSIGNED LONG)SKB->DATA & 0X3F);
	IF (DWORD_ALIGN_BYTES)
		SKB_PULL(SKB, (64 - DWORD_ALIGN_BYTES));
	IF (RSI_PREPARE_BEACON(COMMON, SKB)) {
		RSI_DBG(ERR_ZONE, "FAILED TO PREPARE BEACON\N");
		RETURN -EINVAL;
	}
	SKB_QUEUE_TAIL(&COMMON->TX_QUEUE[MGMT_BEACON_Q], SKB);
	RSI_SET_EVENT(&COMMON->TX_THREAD.EVENT);
	RSI_DBG(DATA_TX_ZONE, "%S: ADDED TO BEACON QUEUE\N", __FUNC__);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 246665_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID NALUDMX_LOG_STATS(GF_NALUDMXCTX *CTX)
{
	U32 I, COUNT;
	CONST CHAR *MSG_IMPORT;
	U32 NB_FRAMES = 0;
	IF (CTX->CUR_FPS.DEN)
		NB_FRAMES = (U32) (CTX->DTS / CTX->CUR_FPS.DEN);

	IF (CTX->DUR.DEN && CTX->DUR.NUM) {
		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S DURATION SPECIFIED AT IMPORT TIME, MAY HAVE PARSED MORE FRAMES THAN IMPORTED\N", CTX->LOG_NAME));
		MSG_IMPORT = "PARSED";
	} ELSE {
		MSG_IMPORT = "IMPORT RESULTS:";
	}

	IF (CTX->NB_SI || CTX->NB_SP) {
		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S %S %D FRAMES (%D NALUS) - SLICES: %D I %D P %D B %D SP %D SI - %D SEI - %D IDR\N", CTX->LOG_NAME, MSG_IMPORT, NB_FRAMES, CTX->NB_NALUS, CTX->NB_I, CTX->NB_P, CTX->NB_B, CTX->NB_SP, CTX->NB_SI, CTX->NB_SEI, CTX->NB_IDR ));
	} ELSE IF (CTX->VVC_NO_STATS) {
		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S %S %D SAMPLES (%D NALUS) - %D SEI - %D IDR - %D CRA\N",
			                  CTX->LOG_NAME, MSG_IMPORT, NB_FRAMES, CTX->NB_NALUS, CTX->NB_SEI, CTX->NB_IDR, CTX->NB_CRA));
	} ELSE {
		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S %S %D SAMPLES (%D NALUS) - SLICES: %D I %D P %D B - %D SEI - %D IDR - %D CRA\N",
			                  CTX->LOG_NAME, MSG_IMPORT, NB_FRAMES, CTX->NB_NALUS, CTX->NB_I, CTX->NB_P, CTX->NB_B, CTX->NB_SEI, CTX->NB_IDR, CTX->NB_CRA));
	}

	IF (CTX->CODECID==GF_CODECID_AVC) {
		COUNT = GF_LIST_COUNT(CTX->SPS);
		FOR (I=0; I<COUNT; I++) {
			AVC_SPS *SPS;
			GF_NALUFFPARAM *SVCC = (GF_NALUFFPARAM*)GF_LIST_GET(CTX->SPS, I);
			SPS = & CTX->AVC_STATE->SPS[SVCC->ID];
			IF (SPS->NB_EI || SPS->NB_EP) {
				GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S SVC (SSPS ID %D, %DX%D) %S SLICES: %D I %D P %D B\N", CTX->LOG_NAME, SVCC->ID - GF_SVC_SSPS_ID_SHIFT, SPS->WIDTH, SPS->HEIGHT, MSG_IMPORT, SPS->NB_EI, SPS->NB_EP, SPS->NB_EB ));
			}
		}
	} ELSE IF (CTX->NB_E_I || CTX->NB_E_P || CTX->NB_E_B) {
		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S L-HEVC %S SLICES: %D I %D P %D B\N", CTX->LOG_NAME, MSG_IMPORT, CTX->NB_E_I, CTX->NB_E_P, CTX->NB_E_B ));
	}

	IF (CTX->MAX_TOTAL_DELAY>1) {
		GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S STREAM USES FORWARD PREDICTION - STREAM CTS OFFSET: %D FRAMES\N", CTX->LOG_NAME, CTX->MAX_TOTAL_DELAY));
	}

	IF (!CTX->NAL_ADJUSTED) {
		IF ((CTX->MAX_NALU_SIZE < 0XFF) && (CTX->NAL_LENGTH>1) ){
			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S MAX NALU SIZE IS %D - STREAM COULD BE OPTIMIZED BY SETTING NAL_LENGTH=1\N", CTX->LOG_NAME, CTX->MAX_NALU_SIZE));
		} ELSE IF ((CTX->MAX_NALU_SIZE < 0XFFFF) && (CTX->NAL_LENGTH>2) ){
			GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, ("%S MAX NALU SIZE IS %D - STREAM COULD BE OPTIMIZED BY SETTING NAL_LENGTH=2\N", CTX->LOG_NAME, CTX->MAX_NALU_SIZE));
		}
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225666_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_BOX *MDHD_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(GF_MEDIAHEADERBOX, GF_ISOM_BOX_TYPE_MDHD);

	TMP->PACKEDLANGUAGE[0] = 'U';
	TMP->PACKEDLANGUAGE[1] = 'N';
	TMP->PACKEDLANGUAGE[2] = 'D';
	RETURN (GF_BOX *)TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226353_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_USERDATAMAP *UDTA_GETENTRY(GF_USERDATABOX *PTR, U32 BOX_TYPE, BIN128 *UUID)
{
	U32 I;
	GF_USERDATAMAP *MAP;
	IF (PTR == NULL) RETURN NULL;
	I=0;
	WHILE ((MAP = (GF_USERDATAMAP *)GF_LIST_ENUM(PTR->RECORDLIST, &I))) {
		IF (MAP->BOXTYPE == BOX_TYPE) {
			IF ((BOX_TYPE != GF_ISOM_BOX_TYPE_UUID) || !UUID) RETURN MAP;
			IF (!MEMCMP(MAP->UUID, *UUID, 16)) RETURN MAP;
		}
	}
	RETURN NULL;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 487665_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ASMLINKAGE LONG SYS_GETRESGID(GID_T __USER *RGID, GID_T __USER *EGID, GID_T __USER *SGID)
{
	INT RETVAL;

	IF (!(RETVAL = PUT_USER(CURRENT->GID, RGID)) &&
	    !(RETVAL = PUT_USER(CURRENT->EGID, EGID)))
		RETVAL = PUT_USER(CURRENT->SGID, SGID);

	RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384801_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VIM_ISWORDC_BUF(INT C, BUF_T *BUF)
{
    IF (C >= 0X100)
    {
	IF (ENC_DBCS != 0)
	    RETURN DBCS_CLASS((UNSIGNED)C >> 8, (UNSIGNED)(C & 0XFF)) >= 2;
	IF (ENC_UTF8)
	    RETURN UTF_CLASS_BUF(C, BUF) >= 2;
	RETURN FALSE;
    }
    RETURN (C > 0 && GET_CHARTAB(BUF, C) != 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 318977_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
F_TEST_NULL_LIST(TYPVAL_T *ARGVARS UNUSED, TYPVAL_T *RETTV)
{
    RETTV_LIST_SET(RETTV, NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198703_CWE-189.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CLASS LJPEG_START (STRUCT JHEAD *JH, INT INFO_ONLY)
{
  INT C, TAG, LEN;
  UCHAR DATA[0X10000];
  CONST UCHAR *DP;

  MEMSET (JH, 0, SIZEOF *JH);
  JH->RESTART = INT_MAX;
  FREAD (DATA, 2, 1, IFP);
  IF (DATA[1] != 0XD8) RETURN 0;
  DO {
    FREAD (DATA, 2, 2, IFP);
    TAG =  DATA[0] << 8 | DATA[1];
    LEN = (DATA[2] << 8 | DATA[3]) - 2;
    IF (TAG <= 0XFF00) RETURN 0;
    FREAD (DATA, 1, LEN, IFP);
    SWITCH (TAG) {
      CASE 0XFFC3:
	JH->SRAW = ((DATA[7] >> 4) * (DATA[7] & 15) - 1) & 3;
      CASE 0XFFC0:
	JH->BITS = DATA[0];
	JH->HIGH = DATA[1] << 8 | DATA[2];
	JH->WIDE = DATA[3] << 8 | DATA[4];
	JH->CLRS = DATA[5] + JH->SRAW;
	IF (LEN == 9 && !DNG_VERSION) GETC(IFP);
	BREAK;
      CASE 0XFFC4:
	IF (INFO_ONLY) BREAK;
	FOR (DP = DATA; DP < DATA+LEN && (C = *DP++) < 4; )
	  JH->FREE[C] = JH->HUFF[C] = MAKE_DECODER_REF (&DP);
	BREAK;
      CASE 0XFFDA:
	JH->PSV = DATA[1+DATA[0]*2];
	JH->BITS -= DATA[3+DATA[0]*2] & 15;
	BREAK;
      CASE 0XFFDD:
	JH->RESTART = DATA[0] << 8 | DATA[1];
    }
  } WHILE (TAG != 0XFFDA);
  IF (INFO_ONLY) RETURN 1;
  IF (JH->CLRS > 6 || !JH->HUFF[0]) RETURN 0;
  FORC(5) IF (!JH->HUFF[C+1]) JH->HUFF[C+1] = JH->HUFF[C];
  IF (JH->SRAW) {
    FORC(4)        JH->HUFF[2+C] = JH->HUFF[1];
    FORC(JH->SRAW) JH->HUFF[1+C] = JH->HUFF[0];
  }
  JH->ROW = (USHORT *) CALLOC (JH->WIDE*JH->CLRS, 4);
  MERROR (JH->ROW, "LJPEG_START()");
  RETURN ZERO_AFTER_FF = 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206625_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RAPTOR_XML_WRITER_START_ELEMENT_COMMON(RAPTOR_XML_WRITER* XML_WRITER,
                                       RAPTOR_XML_ELEMENT* ELEMENT,
                                       INT AUTO_EMPTY)
{
  RAPTOR_IOSTREAM* IOSTR = XML_WRITER->IOSTR;
  RAPTOR_NAMESPACE_STACK *NSTACK = XML_WRITER->NSTACK;
  INT DEPTH = XML_WRITER->DEPTH;
  INT AUTO_INDENT = XML_WRITER_AUTO_INDENT(XML_WRITER);
  STRUCT NSD *NSPACE_DECLARATIONS = NULL;
  SIZE_T NSPACE_DECLARATIONS_COUNT = 0;  
  UNSIGNED INT I;

  /* MAX IS 1 PER ELEMENT AND 1 FOR EACH ATTRIBUTE + SIZE OF DECLARED */
  IF(NSTACK) {
    INT NSPACE_MAX_COUNT = ELEMENT->ATTRIBUTE_COUNT+1;
    IF(ELEMENT->DECLARED_NSPACES)
      NSPACE_MAX_COUNT += RAPTOR_SEQUENCE_SIZE(ELEMENT->DECLARED_NSPACES);
    IF(ELEMENT->XML_LANGUAGE)
      NSPACE_MAX_COUNT++;

    NSPACE_DECLARATIONS = RAPTOR_CALLOC(STRUCT NSD*, NSPACE_MAX_COUNT,
                                        SIZEOF(STRUCT NSD));
    IF(!NSPACE_DECLARATIONS)
      RETURN 1;
  }

  IF(ELEMENT->NAME->NSPACE) {
    IF(NSTACK && !RAPTOR_NAMESPACES_NAMESPACE_IN_SCOPE(NSTACK, ELEMENT->NAME->NSPACE)) {
      NSPACE_DECLARATIONS[0].DECLARATION=
        RAPTOR_NAMESPACE_FORMAT_AS_XML(ELEMENT->NAME->NSPACE,
                                       &NSPACE_DECLARATIONS[0].LENGTH);
      IF(!NSPACE_DECLARATIONS[0].DECLARATION)
        GOTO ERROR;
      NSPACE_DECLARATIONS[0].NSPACE = ELEMENT->NAME->NSPACE;
      NSPACE_DECLARATIONS_COUNT++;
    }
  }

  IF(NSTACK && ELEMENT->ATTRIBUTES) {
    FOR(I = 0; I < ELEMENT->ATTRIBUTE_COUNT; I++) {
      /* QNAME */
      IF(ELEMENT->ATTRIBUTES[I]->NSPACE) {
        /* CHECK IF WE NEED A NAMESPACE DECLARATION ATTRIBUTE */
        IF(NSTACK && 
           !RAPTOR_NAMESPACES_NAMESPACE_IN_SCOPE(NSTACK, ELEMENT->ATTRIBUTES[I]->NSPACE) && ELEMENT->ATTRIBUTES[I]->NSPACE != ELEMENT->NAME->NSPACE) {
          /* NOT IN SCOPE AND NOT SAME AS ELEMENT (SO ALREADY GOING TO BE DECLARED)*/
          UNSIGNED INT J;
          INT DECLARE_ME = 1;
          
          /* CHECK IT WASN'T AN EARLIER DECLARATION TOO */
          FOR(J = 0; J < NSPACE_DECLARATIONS_COUNT; J++)
            IF(NSPACE_DECLARATIONS[J].NSPACE == ELEMENT->ATTRIBUTES[J]->NSPACE) {
              DECLARE_ME = 0;
              BREAK;
            }
            
          IF(DECLARE_ME) {
            NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION=
              RAPTOR_NAMESPACE_FORMAT_AS_XML(ELEMENT->ATTRIBUTES[I]->NSPACE,
                                             &NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].LENGTH);
            IF(!NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION)
              GOTO ERROR;
            NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].NSPACE = ELEMENT->ATTRIBUTES[I]->NSPACE;
            NSPACE_DECLARATIONS_COUNT++;
          }
        }
      }

      /* ADD THE ATTRIBUTE + VALUE */
      NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION=
        RAPTOR_QNAME_FORMAT_AS_XML(ELEMENT->ATTRIBUTES[I],
                                   &NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].LENGTH);
      IF(!NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION)
        GOTO ERROR;
      NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].NSPACE = NULL;
      NSPACE_DECLARATIONS_COUNT++;

    }
  }

  IF(NSTACK && ELEMENT->DECLARED_NSPACES &&
     RAPTOR_SEQUENCE_SIZE(ELEMENT->DECLARED_NSPACES) > 0) {
    FOR(I = 0; I< (UNSIGNED INT)RAPTOR_SEQUENCE_SIZE(ELEMENT->DECLARED_NSPACES); I++) {
      RAPTOR_NAMESPACE* NSPACE = (RAPTOR_NAMESPACE*)RAPTOR_SEQUENCE_GET_AT(ELEMENT->DECLARED_NSPACES, I);
      UNSIGNED INT J;
      INT DECLARE_ME = 1;
      
      /* CHECK IT WASN'T AN EARLIER DECLARATION TOO */
      FOR(J = 0; J < NSPACE_DECLARATIONS_COUNT; J++)
        IF(NSPACE_DECLARATIONS[J].NSPACE == NSPACE) {
          DECLARE_ME = 0;
          BREAK;
        }
      
      IF(DECLARE_ME) {
        NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION=
          RAPTOR_NAMESPACE_FORMAT_AS_XML(NSPACE,
                                         &NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].LENGTH);
        IF(!NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION)
          GOTO ERROR;
        NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].NSPACE = NSPACE;
        NSPACE_DECLARATIONS_COUNT++;
      }

    }
  }

  IF(NSTACK && ELEMENT->XML_LANGUAGE) {
    SIZE_T LANG_LEN = STRLEN(RAPTOR_GOOD_CAST(CHAR*, ELEMENT->XML_LANGUAGE));
#DEFINE XML_LANG_PREFIX_LEN 10
    SIZE_T BUF_LENGTH = XML_LANG_PREFIX_LEN + LANG_LEN + 1;
    UNSIGNED CHAR* BUFFER = RAPTOR_MALLOC(UNSIGNED CHAR*, BUF_LENGTH + 1);
    CONST CHAR QUOTE = '\"';
    UNSIGNED CHAR* P;

    MEMCPY(BUFFER, "XML:LANG=\"", XML_LANG_PREFIX_LEN);
    P = BUFFER + XML_LANG_PREFIX_LEN;
    P += RAPTOR_XML_ESCAPE_STRING(XML_WRITER->WORLD,
                                  ELEMENT->XML_LANGUAGE, LANG_LEN,
                                  P, BUF_LENGTH, QUOTE);
    *P++ = QUOTE;
    *P = '\0';

    NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].DECLARATION = BUFFER;
    NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].LENGTH = BUF_LENGTH;
    NSPACE_DECLARATIONS[NSPACE_DECLARATIONS_COUNT].NSPACE = NULL;
    NSPACE_DECLARATIONS_COUNT++;
  }
  

  RAPTOR_IOSTREAM_WRITE_BYTE('<', IOSTR);

  IF(ELEMENT->NAME->NSPACE && ELEMENT->NAME->NSPACE->PREFIX_LENGTH > 0) {
    RAPTOR_IOSTREAM_COUNTED_STRING_WRITE((CONST CHAR*)ELEMENT->NAME->NSPACE->PREFIX, 
                                         ELEMENT->NAME->NSPACE->PREFIX_LENGTH,
                                         IOSTR);
    RAPTOR_IOSTREAM_WRITE_BYTE(':', IOSTR);
  }
  RAPTOR_IOSTREAM_COUNTED_STRING_WRITE((CONST CHAR*)ELEMENT->NAME->LOCAL_NAME,
                                       ELEMENT->NAME->LOCAL_NAME_LENGTH,
                                       IOSTR);

  /* DECLARE NAMESPACES AND ATTRIBUTES */
  IF(NSPACE_DECLARATIONS_COUNT) {
    INT NEED_INDENT = 0;
    
    /* SORT THEM INTO THE CANONICAL ORDER */
    QSORT((VOID*)NSPACE_DECLARATIONS, 
          NSPACE_DECLARATIONS_COUNT, SIZEOF(STRUCT NSD),
          RAPTOR_XML_WRITER_NSD_COMPARE);

    /* DECLARE NAMESPACES FIRST */
    FOR(I = 0; I < NSPACE_DECLARATIONS_COUNT; I++) {
      IF(!NSPACE_DECLARATIONS[I].NSPACE)
        CONTINUE;

      IF(AUTO_INDENT && NEED_INDENT) {
        /* INDENT ATTRIBUTES */
        RAPTOR_XML_WRITER_NEWLINE(XML_WRITER);
        XML_WRITER->DEPTH++;
        RAPTOR_XML_WRITER_INDENT(XML_WRITER);
        XML_WRITER->DEPTH--;
      }
      RAPTOR_IOSTREAM_WRITE_BYTE(' ', IOSTR);
      RAPTOR_IOSTREAM_COUNTED_STRING_WRITE((CONST CHAR*)NSPACE_DECLARATIONS[I].DECLARATION,
                                           NSPACE_DECLARATIONS[I].LENGTH,
                                           IOSTR);
      RAPTOR_FREE(CHAR*, NSPACE_DECLARATIONS[I].DECLARATION);
      NSPACE_DECLARATIONS[I].DECLARATION = NULL;
      NEED_INDENT = 1;
      
      IF(RAPTOR_NAMESPACE_STACK_START_NAMESPACE(NSTACK,
                                                (RAPTOR_NAMESPACE*)NSPACE_DECLARATIONS[I].NSPACE,
                                                DEPTH))
        GOTO ERROR;
    }

    /* DECLARE ATTRIBUTES */
    FOR(I = 0; I < NSPACE_DECLARATIONS_COUNT; I++) {
      IF(NSPACE_DECLARATIONS[I].NSPACE)
        CONTINUE;

      IF(AUTO_INDENT && NEED_INDENT) {
        /* INDENT ATTRIBUTES */
        RAPTOR_XML_WRITER_NEWLINE(XML_WRITER);
        XML_WRITER->DEPTH++;
        RAPTOR_XML_WRITER_INDENT(XML_WRITER);
        XML_WRITER->DEPTH--;
      }
      RAPTOR_IOSTREAM_WRITE_BYTE(' ', IOSTR);
      RAPTOR_IOSTREAM_COUNTED_STRING_WRITE((CONST CHAR*)NSPACE_DECLARATIONS[I].DECLARATION,
                                           NSPACE_DECLARATIONS[I].LENGTH,
                                           IOSTR);
      NEED_INDENT = 1;

      RAPTOR_FREE(CHAR*, NSPACE_DECLARATIONS[I].DECLARATION);
      NSPACE_DECLARATIONS[I].DECLARATION = NULL;
    }
  }

  IF(!AUTO_EMPTY)
    RAPTOR_IOSTREAM_WRITE_BYTE('>', IOSTR);

  IF(NSTACK)
    RAPTOR_FREE(STRINGARRAY, NSPACE_DECLARATIONS);

  RETURN 0;

  /* CLEAN UP NSPACE_DECLARATIONS ON ERROR */
  ERROR:

  FOR(I = 0; I < NSPACE_DECLARATIONS_COUNT; I++) {
    IF(NSPACE_DECLARATIONS[I].DECLARATION)
      RAPTOR_FREE(CHAR*, NSPACE_DECLARATIONS[I].DECLARATION);
  }

  RAPTOR_FREE(STRINGARRAY, NSPACE_DECLARATIONS);

  RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359377_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BGP_CONFIG_WRITE_REDISTRIBUTE (STRUCT VTY *VTY, STRUCT BGP *BGP, AFI_T AFI,
			       SAFI_T SAFI, INT *WRITE)
{
  INT I;

  /* UNICAST REDISTRIBUTION ONLY.  */
  IF (SAFI != SAFI_UNICAST)
    RETURN 0;

  FOR (I = 0; I < ZEBRA_ROUTE_MAX; I++)
    {
      /* REDISTRIBUTE BGP DOES NOT MAKE SENSE.  */
      IF (BGP->REDIST[AFI][I] && I != ZEBRA_ROUTE_BGP)
	{
	  /* DISPLAY "ADDRESS-FAMILY" WHEN IT IS NOT YET DIPLAYED.  */
	  BGP_CONFIG_WRITE_FAMILY_HEADER (VTY, AFI, SAFI, WRITE);

	  /* "REDISTRIBUTE" CONFIGURATION.  */
	  VTY_OUT (VTY, " REDISTRIBUTE %S", ZEBRA_ROUTE_STRING(I));

	  IF (BGP->REDIST_METRIC_FLAG[AFI][I])
	    VTY_OUT (VTY, " METRIC %D", BGP->REDIST_METRIC[AFI][I]);

	  IF (BGP->RMAP[AFI][I].NAME)
	    VTY_OUT (VTY, " ROUTE-MAP %S", BGP->RMAP[AFI][I].NAME);

	  VTY_OUT (VTY, "%S", VTY_NEWLINE);
	}
    }
  RETURN *WRITE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204036_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT HW_ATL_UTILS_FW_RPC_WAIT(STRUCT AQ_HW_S *SELF,
			     STRUCT HW_ATL_UTILS_FW_RPC **RPC)
{
	STRUCT AQ_HW_ATL_UTILS_FW_RPC_TID_S SW;
	STRUCT AQ_HW_ATL_UTILS_FW_RPC_TID_S FW;
	INT ERR = 0;

	DO {
		SW.VAL = AQ_HW_READ_REG(SELF, HW_ATL_RPC_CONTROL_ADR);

		SELF->RPC_TID = SW.TID;

		ERR = READX_POLL_TIMEOUT_ATOMIC(HW_ATL_UTILS_RPC_STATE_GET,
						SELF, FW.VAL,
						SW.TID == FW.TID,
						1000U, 100000U);
		IF (ERR < 0)
			GOTO ERR_EXIT;

		ERR = AQ_HW_ERR_FROM_FLAGS(SELF);
		IF (ERR < 0)
			GOTO ERR_EXIT;

		IF (FW.LEN == 0XFFFFU) {
			ERR = HW_ATL_UTILS_FW_RPC_CALL(SELF, SW.LEN);
			IF (ERR < 0)
				GOTO ERR_EXIT;
		}
	} WHILE (SW.TID != FW.TID || 0XFFFFU == FW.LEN);

	IF (RPC) {
		IF (FW.LEN) {
			ERR =
			HW_ATL_UTILS_FW_DOWNLD_DWORDS(SELF,
						      SELF->RPC_ADDR,
						      (U32 *)(VOID *)
						      &SELF->RPC,
						      (FW.LEN + SIZEOF(U32) -
						       SIZEOF(U8)) /
						      SIZEOF(U32));
			IF (ERR < 0)
				GOTO ERR_EXIT;
		}

		*RPC = &SELF->RPC;
	}

ERR_EXIT:
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196726_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_ARRAY_PROTOTYPE_SORT(NJS_VM_T *VM, NJS_VALUE_T *ARGS, NJS_UINT_T NARGS,
    NJS_INDEX_T UNUSED)
{
    INT64_T                I, UND, LEN, NLEN, LENGTH;
    NJS_INT_T              RET, FAST_PATH;
    NJS_ARRAY_T            *ARRAY;
    NJS_VALUE_T            *THIS, *COMPAREFN, *START, *STRINGS;
    NJS_ARRAY_SORT_CTX_T   CTX;
    NJS_ARRAY_SORT_SLOT_T  *P, *END, *SLOTS, *NSLOTS;

    COMPAREFN = NJS_ARG(ARGS, NARGS, 1);

    IF (NJS_IS_DEFINED(COMPAREFN)) {
        IF (NJS_SLOW_PATH(!NJS_IS_FUNCTION(COMPAREFN))) {
            NJS_TYPE_ERROR(VM, "COMPAREFN MUST BE CALLABLE OR UNDEFINED");
            RETURN NJS_ERROR;
        }

        CTX.FUNCTION = NJS_FUNCTION(COMPAREFN);

    } ELSE {
        CTX.FUNCTION = NULL;
    }

    THIS = NJS_ARGUMENT(ARGS, 0);

    RET = NJS_VALUE_TO_OBJECT(VM, THIS);
    IF (NJS_SLOW_PATH(RET != NJS_OK)) {
        RETURN RET;
    }

    RET = NJS_VALUE_LENGTH(VM, THIS, &LENGTH);
    IF (NJS_SLOW_PATH(RET != NJS_OK)) {
        RETURN RET;
    }

    IF (NJS_SLOW_PATH(LENGTH < 2)) {
        VM->RETVAL = *THIS;
        RETURN NJS_OK;
    }

    SLOTS = NULL;
    CTX.VM = VM;
    CTX.STRINGS.SEPARATE = 0;
    CTX.STRINGS.POINTER = 0;
    CTX.EXCEPTION = 0;

    FAST_PATH = NJS_IS_FAST_ARRAY(THIS);

    IF (NJS_FAST_PATH(FAST_PATH)) {
        ARRAY = NJS_ARRAY(THIS);
        START = ARRAY->START;

        SLOTS = NJS_MP_ALLOC(VM->MEM_POOL,
                             SIZEOF(NJS_ARRAY_SORT_SLOT_T) * LENGTH);
        IF (NJS_SLOW_PATH(SLOTS == NULL)) {
                RETURN NJS_ERROR;
        }

        UND = 0;
        P = SLOTS;

        FOR (I = 0; I < LENGTH; I++) {
            IF (NJS_SLOW_PATH(!NJS_IS_VALID(&START[I]))) {
                FAST_PATH = 0;
                NJS_MP_FREE(VM->MEM_POOL, SLOTS);
                SLOTS = NULL;
                GOTO SLOW_PATH;
            }

            IF (NJS_SLOW_PATH(NJS_IS_UNDEFINED(&START[I]))) {
                UND++;
                CONTINUE;
            }

            P->VALUE = START[I];
            P->POS = I;
            P->STR = NULL;
            P++;
        }

        LEN = P - SLOTS;

    } ELSE {

SLOW_PATH:

        UND = 0;
        P = NULL;
        END = NULL;

        FOR (I = 0; I < LENGTH; I++) {
            IF (P >= END) {
                NLEN = NJS_MIN(NJS_MAX((P - SLOTS) * 2, 8), LENGTH);
                NSLOTS = NJS_MP_ALLOC(VM->MEM_POOL,
                                      SIZEOF(NJS_ARRAY_SORT_SLOT_T) * NLEN);
                IF (NJS_SLOW_PATH(NSLOTS == NULL)) {
                    NJS_MEMORY_ERROR(VM);
                    RETURN NJS_ERROR;
                }

                IF (SLOTS != NULL) {
                    P = (VOID *) NJS_CPYMEM(NSLOTS, SLOTS,
                                  SIZEOF(NJS_ARRAY_SORT_SLOT_T) * (P - SLOTS));
                    NJS_MP_FREE(VM->MEM_POOL, SLOTS);

                } ELSE {
                    P = NSLOTS;
                }

                SLOTS = NSLOTS;
                END = SLOTS + NLEN;
            }

            RET = NJS_VALUE_PROPERTY_I64(VM, THIS, I, &P->VALUE);
            IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                RET = NJS_ERROR;
                GOTO EXCEPTION;
            }

            IF (RET == NJS_DECLINED) {
                CONTINUE;
            }

            IF (NJS_IS_UNDEFINED(&P->VALUE)) {
                UND++;
                CONTINUE;
            }

            P->POS = I;
            P->STR = NULL;
            P++;
        }

        LEN = P - SLOTS;
    }

    STRINGS = NJS_ARR_INIT(VM->MEM_POOL, &CTX.STRINGS, NULL, LEN + 1,
                           SIZEOF(NJS_VALUE_T));
    IF (NJS_SLOW_PATH(STRINGS == NULL)) {
        RET = NJS_ERROR;
        GOTO EXCEPTION;
    }

    NJS_QSORT(SLOTS, LEN, SIZEOF(NJS_ARRAY_SORT_SLOT_T), NJS_ARRAY_COMPARE,
              &CTX);

    IF (CTX.EXCEPTION) {
        RET = NJS_ERROR;
        GOTO EXCEPTION;
    }

    IF (NJS_FAST_PATH(FAST_PATH)) {
        ARRAY = NJS_ARRAY(THIS);
        START = ARRAY->START;

        FOR (I = 0; I < LEN; I++) {
            START[I] = SLOTS[I].VALUE;
        }

        FOR (I = LEN; UND-- > 0; I++) {
            START[I] = NJS_VALUE_UNDEFINED;
        }

    } ELSE {
        FOR (I = 0; I < LEN; I++) {
            IF (SLOTS[I].POS != I) {
                RET = NJS_VALUE_PROPERTY_I64_SET(VM, THIS, I, &SLOTS[I].VALUE);
                IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                    GOTO EXCEPTION;
                }
            }
        }

        FOR (I = LEN; UND-- > 0; I++) {
            RET = NJS_VALUE_PROPERTY_I64_SET(VM, THIS, I,
                                          NJS_VALUE_ARG(&NJS_VALUE_UNDEFINED));
            IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                GOTO EXCEPTION;
            }
        }

        FOR (; I < LENGTH; I++) {
            RET = NJS_VALUE_PROPERTY_I64_DELETE(VM, THIS, I, NULL);
            IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                GOTO EXCEPTION;
            }
        }
    }

    VM->RETVAL = *THIS;

    RET = NJS_OK;

EXCEPTION:

    IF (SLOTS != NULL) {
        NJS_MP_FREE(VM->MEM_POOL, SLOTS);
    }

    NJS_ARR_DESTROY(&CTX.STRINGS);

    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202600_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
APPEND_COMMAND(CHAR_U *CMD)
{
    CHAR_U *S = CMD;
    CHAR_U *D;

    STRCAT(IOBUFF, ": ");
    D = IOBUFF + STRLEN(IOBUFF);
    WHILE (*S != NUL && D - IOBUFF < IOSIZE - 7)
    {
	IF (ENC_UTF8 ? (S[0] == 0XC2 && S[1] == 0XA0) : *S == 0XA0)
	{
	    S += ENC_UTF8 ? 2 : 1;
	    STRCPY(D, "<A0>");
	    D += 4;
	}
	ELSE
	    MB_COPY_CHAR(S, D);
    }
    *D = NUL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207804_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID UPDATE_PROCESS_TIMES(INT USER_TICK)
{
	STRUCT TASK_STRUCT *P = CURRENT;

	/* NOTE: THIS TIMER IRQ CONTEXT MUST BE ACCOUNTED FOR AS WELL. */
	ACCOUNT_PROCESS_TICK(P, USER_TICK);
	RUN_LOCAL_TIMERS();
	RCU_SCHED_CLOCK_IRQ(USER_TICK);
#IFDEF CONFIG_IRQ_WORK
	IF (IN_IRQ())
		IRQ_WORK_TICK();
#ENDIF
	SCHEDULER_TICK();
	IF (IS_ENABLED(CONFIG_POSIX_TIMERS))
		RUN_POSIX_CPU_TIMERS();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195670_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PJ_XML_NODE *XML_PARSE_NODE( PJ_POOL_T *POOL, PJ_SCANNER *SCANNER)
{
    PJ_XML_NODE *NODE;
    PJ_STR_T END_NAME;

    PJ_CHECK_STACK();

    IF (*SCANNER->CURPTR != '<')
	ON_SYNTAX_ERROR(SCANNER);

    /* HANDLE PROCESSING INSTRUCTINO (PI) CONSTRUCT (I.E. "<?") */
    IF (*SCANNER->CURPTR == '<' && *(SCANNER->CURPTR+1) == '?') {
	PJ_SCAN_ADVANCE_N(SCANNER, 2, PJ_FALSE);
	FOR (;;) {
	    PJ_STR_T DUMMY;
	    PJ_SCAN_GET_UNTIL_CH(SCANNER, '?', &DUMMY);
	    IF (*SCANNER->CURPTR=='?' && *(SCANNER->CURPTR+1)=='>') {
		PJ_SCAN_ADVANCE_N(SCANNER, 2, PJ_TRUE);
		BREAK;
	    } ELSE {
		PJ_SCAN_ADVANCE_N(SCANNER, 1, PJ_FALSE);
	    }
	}
	RETURN XML_PARSE_NODE(POOL, SCANNER);
    }

    /* HANDLE COMMENTS CONSTRUCT (I.E. "<!") */
    IF (PJ_SCAN_STRCMP(SCANNER, "<!", 2) == 0) {
	PJ_SCAN_ADVANCE_N(SCANNER, 2, PJ_FALSE);
	FOR (;;) {
	    PJ_STR_T DUMMY;
	    PJ_SCAN_GET_UNTIL_CH(SCANNER, '>', &DUMMY);
	    IF (PJ_SCAN_STRCMP(SCANNER, ">", 1) == 0) {
		PJ_SCAN_ADVANCE_N(SCANNER, 1, PJ_TRUE);
		BREAK;
	    } ELSE {
		PJ_SCAN_ADVANCE_N(SCANNER, 1, PJ_FALSE);
	    }
	}
	RETURN XML_PARSE_NODE(POOL, SCANNER);
    }

    /* ALLOC NODE. */
    NODE = ALLOC_NODE(POOL);

    /* GET '<' */
    PJ_SCAN_GET_CHAR(SCANNER);

    /* GET NODE NAME. */
    PJ_SCAN_GET_UNTIL_CHR( SCANNER, " />\T\R\N", &NODE->NAME);

    /* GET ATTRIBUTES. */
    WHILE (*SCANNER->CURPTR != '>' && *SCANNER->CURPTR != '/') {
	PJ_XML_ATTR *ATTR = ALLOC_ATTR(POOL);
	
	PJ_SCAN_GET_UNTIL_CHR( SCANNER, "=> \T\R\N", &ATTR->NAME);
	IF (*SCANNER->CURPTR == '=') {
	    PJ_SCAN_GET_CHAR( SCANNER );
            PJ_SCAN_GET_QUOTES(SCANNER, "\"'", "\"'", 2, &ATTR->VALUE);
	    /* REMOVE QUOTE CHARACTERS */
	    ++ATTR->VALUE.PTR;
	    ATTR->VALUE.SLEN -= 2;
	}
	
	PJ_LIST_PUSH_BACK( &NODE->ATTR_HEAD, ATTR );
    }

    IF (*SCANNER->CURPTR == '/') {
	PJ_SCAN_GET_CHAR(SCANNER);
	IF (PJ_SCAN_GET_CHAR(SCANNER) != '>')
	    ON_SYNTAX_ERROR(SCANNER);
	RETURN NODE;
    }

    /* ENCLOSING BRACKET. */
    IF (PJ_SCAN_GET_CHAR(SCANNER) != '>')
	ON_SYNTAX_ERROR(SCANNER);

    /* SUB NODES. */
    WHILE (*SCANNER->CURPTR == '<' && *(SCANNER->CURPTR+1) != '/'
				   && *(SCANNER->CURPTR+1) != '!')
    {
	PJ_XML_NODE *SUB_NODE = XML_PARSE_NODE(POOL, SCANNER);
	PJ_LIST_PUSH_BACK( &NODE->NODE_HEAD, SUB_NODE );
    }

    /* CONTENT. */
    IF (!PJ_SCAN_IS_EOF(SCANNER) && *SCANNER->CURPTR != '<') {
	PJ_SCAN_GET_UNTIL_CH(SCANNER, '<', &NODE->CONTENT);
    }

    /* CDATA CONTENT. */
    IF (*SCANNER->CURPTR == '<' && *(SCANNER->CURPTR+1) == '!' &&
	PJ_SCAN_STRCMP(SCANNER, "<![CDATA[", 9) == 0)
    {
	PJ_SCAN_ADVANCE_N(SCANNER, 9, PJ_FALSE);
	PJ_SCAN_GET_UNTIL_CH(SCANNER, ']', &NODE->CONTENT);
	WHILE (PJ_SCAN_STRCMP(SCANNER, "]]>", 3)) {
	    PJ_STR_T DUMMY;
	    PJ_SCAN_GET_UNTIL_CH(SCANNER, ']', &DUMMY);
	}
	NODE->CONTENT.SLEN = SCANNER->CURPTR - NODE->CONTENT.PTR;
	PJ_SCAN_ADVANCE_N(SCANNER, 3, PJ_TRUE);
    }

    /* ENCLOSING NODE. */
    IF (PJ_SCAN_GET_CHAR(SCANNER) != '<' || PJ_SCAN_GET_CHAR(SCANNER) != '/')
	ON_SYNTAX_ERROR(SCANNER);

    PJ_SCAN_GET_UNTIL_CHR(SCANNER, " \T>", &END_NAME);

    /* COMPARE NAME. */
    IF (PJ_STRICMP(&NODE->NAME, &END_NAME) != 0)
	ON_SYNTAX_ERROR(SCANNER);

    /* ENCLOSING '>' */
    IF (PJ_SCAN_GET_CHAR(SCANNER) != '>')
	ON_SYNTAX_ERROR(SCANNER);

    RETURN NODE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200379_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RLIST *R_BIN_NE_GET_SEGMENTS(R_BIN_NE_OBJ_T *BIN) {
	INT I;
	IF (!BIN) {
		RETURN NULL;
	}
	RLIST *SEGMENTS = R_LIST_NEWF (FREE);
	FOR (I = 0; I < BIN->NE_HEADER->SEGCOUNT; I++) {
		RBINSECTION *BS = R_NEW0 (RBINSECTION);
		IF (!BS) {
			RETURN SEGMENTS;
		}
		NE_IMAGE_SEGMENT_ENTRY *SE = &BIN->SEGMENT_ENTRIES[I];
		BS->SIZE = SE->LENGTH;
		BS->VSIZE = SE->MINALLOCSZ ? SE->MINALLOCSZ : 64000;
		BS->BITS = R_SYS_BITS_16;
		BS->IS_DATA = SE->FLAGS & IS_DATA;
		BS->PERM = __TRANSLATE_PERMS (SE->FLAGS);
		BS->PADDR = (UT64)SE->OFFSET * BIN->ALIGNMENT;
		BS->NAME = R_STR_NEWF ("%S.%" PFMT64D, SE->FLAGS & IS_MOVEABLE ? "MOVEABLE" : "FIXED", BS->PADDR);
		BS->IS_SEGMENT = TRUE;
		R_LIST_APPEND (SEGMENTS, BS);
	}
	BIN->SEGMENTS = SEGMENTS;
	RETURN SEGMENTS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202677_CWE-369.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PARALLELS_OPEN(BLOCKDRIVERSTATE *BS, QDICT *OPTIONS, INT FLAGS,
                          ERROR **ERRP)
{
    BDRVPARALLELSSTATE *S = BS->OPAQUE;
    INT I;
    STRUCT PARALLELS_HEADER PH;
    INT RET;

    BS->READ_ONLY = 1; // NO WRITE SUPPORT YET

    RET = BDRV_PREAD(BS->FILE, 0, &PH, SIZEOF(PH));
    IF (RET < 0) {
        GOTO FAIL;
    }

    IF (MEMCMP(PH.MAGIC, HEADER_MAGIC, 16) ||
        (LE32_TO_CPU(PH.VERSION) != HEADER_VERSION)) {
        ERROR_SETG(ERRP, "IMAGE NOT IN PARALLELS FORMAT");
        RET = -EINVAL;
        GOTO FAIL;
    }

    BS->TOTAL_SECTORS = LE32_TO_CPU(PH.NB_SECTORS);

    S->TRACKS = LE32_TO_CPU(PH.TRACKS);

    S->CATALOG_SIZE = LE32_TO_CPU(PH.CATALOG_ENTRIES);
    IF (S->CATALOG_SIZE > INT_MAX / 4) {
        ERROR_SETG(ERRP, "CATALOG TOO LARGE");
        RET = -EFBIG;
        GOTO FAIL;
    }
    S->CATALOG_BITMAP = G_MALLOC(S->CATALOG_SIZE * 4);

    RET = BDRV_PREAD(BS->FILE, 64, S->CATALOG_BITMAP, S->CATALOG_SIZE * 4);
    IF (RET < 0) {
        GOTO FAIL;
    }

    FOR (I = 0; I < S->CATALOG_SIZE; I++)
	LE32_TO_CPUS(&S->CATALOG_BITMAP[I]);

    QEMU_CO_MUTEX_INIT(&S->LOCK);
    RETURN 0;

FAIL:
    G_FREE(S->CATALOG_BITMAP);
    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226120_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

VOID EXTR_BOX_DEL(GF_BOX *S)
{
	GF_EXTRADATABOX *PTR = (GF_EXTRADATABOX *)S;
	IF (PTR == NULL) RETURN;
	IF (PTR->FECI) GF_ISOM_BOX_DEL((GF_BOX*)PTR->FECI);
	IF (PTR->DATA) GF_FREE(PTR->DATA);
	GF_FREE(PTR);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207520_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CONST UT8 *PARSE_DIE(CONST UT8 *BUF, CONST UT8 *BUF_END, RZBINDWARFDEBUGINFO *INFO, RZBINDWARFABBREVDECL *ABBREV,
	RZBINDWARFCOMPUNITHDR *HDR, RZBINDWARFDIE *DIE, CONST UT8 *DEBUG_STR, SIZE_T DEBUG_STR_LEN, BOOL BIG_ENDIAN) {
	SIZE_T I;
	CONST CHAR *COMP_DIR = NULL;
	UT64 LINE_INFO_OFFSET = UT64_MAX;
	FOR (I = 0; I < ABBREV->COUNT - 1; I++) {
		MEMSET(&DIE->ATTR_VALUES[I], 0, SIZEOF(DIE->ATTR_VALUES[I]));

		BUF = PARSE_ATTR_VALUE(BUF, BUF_END - BUF, &ABBREV->DEFS[I],
			&DIE->ATTR_VALUES[I], HDR, DEBUG_STR, DEBUG_STR_LEN, BIG_ENDIAN);

		RZBINDWARFATTRVALUE *ATTRIBUTE = &DIE->ATTR_VALUES[I];

		IF (ATTRIBUTE->ATTR_NAME == DW_AT_COMP_DIR && (ATTRIBUTE->ATTR_FORM == DW_FORM_STRP || ATTRIBUTE->ATTR_FORM == DW_FORM_STRING) && ATTRIBUTE->STRING.CONTENT) {
			COMP_DIR = ATTRIBUTE->STRING.CONTENT;
		}
		IF (ATTRIBUTE->ATTR_NAME == DW_AT_STMT_LIST) {
			IF (ATTRIBUTE->KIND == DW_AT_KIND_CONSTANT) {
				LINE_INFO_OFFSET = ATTRIBUTE->UCONSTANT;
			} ELSE IF (ATTRIBUTE->KIND == DW_AT_KIND_REFERENCE) {
				LINE_INFO_OFFSET = ATTRIBUTE->REFERENCE;
			}
		}
		DIE->COUNT++;
	}

	// IF THIS IS A COMPILATION UNIT DIR ATTRIBUTE, WE WANT TO CACHE IT SO THE LINE INFO PARSING
	// WHICH WILL NEED THIS INFO CAN QUICKLY LOOK IT UP.
	IF (COMP_DIR && LINE_INFO_OFFSET != UT64_MAX) {
		CHAR *NAME = STRDUP(COMP_DIR);
		IF (NAME) {
			IF (!HT_UP_INSERT(INFO->LINE_INFO_OFFSET_COMP_DIR, LINE_INFO_OFFSET, NAME)) {
				FREE(NAME);
			}
		}
	}

	RETURN BUF;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 443693_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INIT(VOID)
{
#IFDEF USE_CALLOUT

    INT ID;
    ONIGENCODING ENC;
    CHAR* NAME;
    UNSIGNED INT ARGS[4];
    ONIGVALUE    OPTS[4];

    ENC = ONIG_ENCODING_UTF16_LE;

    NAME = "F\000A\000I\000L\000\000\000";            BC0_P(NAME, FAIL);
    NAME = "M\000I\000S\000M\000A\000T\000C\000H\000\000\000"; BC0_P(NAME, MISMATCH);

    NAME = "M\000A\000X\000\000\000";
    ARGS[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;
    ARGS[1] = ONIG_TYPE_CHAR;
    OPTS[0].C = 'X';
    BC_B_O(NAME, MAX, 2, ARGS, 1, OPTS);

    NAME = "E\000R\000R\000O\000R\000\000\000";
    ARGS[0] = ONIG_TYPE_LONG; OPTS[0].L = ONIG_ABORT;
    BC_P_O(NAME, ERROR, 1, ARGS, 1, OPTS);

    NAME = "C\000O\000U\000N\000T\000\000\000";
    ARGS[0] = ONIG_TYPE_CHAR; OPTS[0].C = '>';
    BC_B_O(NAME, COUNT, 1, ARGS, 1, OPTS);

    NAME = "T\000O\000T\000A\000L\000_\000C\000O\000U\000N\000T\000\000\000";
    ARGS[0] = ONIG_TYPE_CHAR; OPTS[0].C = '>';
    BC_B_O(NAME, TOTAL_COUNT, 1, ARGS, 1, OPTS);

    NAME = "C\000M\000P\000\000\000";
    ARGS[0] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;
    ARGS[1] = ONIG_TYPE_STRING;
    ARGS[2] = ONIG_TYPE_TAG | ONIG_TYPE_LONG;
    BC_P(NAME, CMP, 3, ARGS);

#ENDIF /* USE_CALLOUT */

  RETURN ONIG_NORMAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484764_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT XENNET_INIT_QUEUE(STRUCT NETFRONT_QUEUE *QUEUE)
{
	UNSIGNED SHORT I;
	INT ERR = 0;
	CHAR *DEVID;

	SPIN_LOCK_INIT(&QUEUE->TX_LOCK);
	SPIN_LOCK_INIT(&QUEUE->RX_LOCK);
	SPIN_LOCK_INIT(&QUEUE->RX_CONS_LOCK);

	TIMER_SETUP(&QUEUE->RX_REFILL_TIMER, RX_REFILL_TIMEOUT, 0);

	DEVID = STRRCHR(QUEUE->INFO->XBDEV->NODENAME, '/') + 1;
	SNPRINTF(QUEUE->NAME, SIZEOF(QUEUE->NAME), "VIF%S-Q%U",
		 DEVID, QUEUE->ID);

	/* INITIALISE TX_SKB_FREELIST AS A FREE CHAIN CONTAINING EVERY ENTRY. */
	QUEUE->TX_SKB_FREELIST = 0;
	QUEUE->TX_PEND_QUEUE = TX_LINK_NONE;
	FOR (I = 0; I < NET_TX_RING_SIZE; I++) {
		QUEUE->TX_LINK[I] = I + 1;
		QUEUE->GRANT_TX_REF[I] = INVALID_GRANT_REF;
		QUEUE->GRANT_TX_PAGE[I] = NULL;
	}
	QUEUE->TX_LINK[NET_TX_RING_SIZE - 1] = TX_LINK_NONE;

	/* CLEAR OUT RX_SKBS */
	FOR (I = 0; I < NET_RX_RING_SIZE; I++) {
		QUEUE->RX_SKBS[I] = NULL;
		QUEUE->GRANT_RX_REF[I] = INVALID_GRANT_REF;
	}

	/* A GRANT FOR EVERY TX RING SLOT */
	IF (GNTTAB_ALLOC_GRANT_REFERENCES(NET_TX_RING_SIZE,
					  &QUEUE->GREF_TX_HEAD) < 0) {
		PR_ALERT("CAN'T ALLOC TX GRANT REFS\N");
		ERR = -ENOMEM;
		GOTO EXIT;
	}

	/* A GRANT FOR EVERY RX RING SLOT */
	IF (GNTTAB_ALLOC_GRANT_REFERENCES(NET_RX_RING_SIZE,
					  &QUEUE->GREF_RX_HEAD) < 0) {
		PR_ALERT("CAN'T ALLOC RX GRANT REFS\N");
		ERR = -ENOMEM;
		GOTO EXIT_FREE_TX;
	}

	RETURN 0;

 EXIT_FREE_TX:
	GNTTAB_FREE_GRANT_REFERENCES(QUEUE->GREF_TX_HEAD);
 EXIT:
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 264658_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR BM_PARSEMULTIPLEREPLACE(GF_BIFSDECODER *CODEC, GF_BITSTREAM *BS, GF_LIST *COM_LIST)
{
	U32 I, NUMFIELDS, INDEX, FLAG, NBBITS, FIELD_REF, FIELDIND;
	GF_ERR E;
	GF_FIELDINFO FIELD;
	U32 NODEID;
	GF_NODE *NODE;
	GF_COMMAND *COM;
	GF_COMMANDFIELD *INF;

	NODEID = 1 + GF_BS_READ_INT(BS, CODEC->INFO->CONFIG.NODEIDBITS);
	NODE = GF_SG_FIND_NODE(CODEC->CURRENT_GRAPH, NODEID);
	IF (!NODE) RETURN GF_NON_COMPLIANT_BITSTREAM;

	E = GF_OK;
	COM = GF_SG_COMMAND_NEW(CODEC->CURRENT_GRAPH, GF_SG_MULTIPLE_REPLACE);
	BM_SETCOMMANDNODE(COM, NODE);
	FLAG = GF_BS_READ_INT(BS, 1);
	IF (FLAG) {
		NUMFIELDS = GF_NODE_GET_NUM_FIELDS_IN_MODE(NODE, GF_SG_FIELD_CODING_DEF);
		FOR (I=0; I<NUMFIELDS; I++) {
			FLAG = GF_BS_READ_INT(BS, 1);
			IF (!FLAG) CONTINUE;
			GF_BIFS_GET_FIELD_INDEX(NODE, I, GF_SG_FIELD_CODING_DEF, &INDEX);
			E = GF_NODE_GET_FIELD(NODE, INDEX, &FIELD);
			IF (E) GOTO EXIT;
			INF = GF_SG_COMMAND_FIELD_NEW(COM);
			INF->FIELDTYPE = FIELD.FIELDTYPE;
			INF->FIELDINDEX = FIELD.FIELDINDEX;
			IF (INF->FIELDTYPE==GF_SG_VRML_SFNODE) {
				FIELD.FAR_PTR = INF->FIELD_PTR = &INF->NEW_NODE;
			} ELSE IF (INF->FIELDTYPE==GF_SG_VRML_MFNODE) {
				FIELD.FAR_PTR = INF->FIELD_PTR = &INF->NODE_LIST;
			} ELSE {
				FIELD.FAR_PTR = INF->FIELD_PTR = GF_SG_VRML_FIELD_POINTER_NEW(INF->FIELDTYPE);
			}
			E = GF_BIFS_DEC_FIELD(CODEC, BS, NODE, &FIELD, GF_TRUE);
			IF (E) GOTO EXIT;
		}
	} ELSE {
		FLAG = GF_BS_READ_INT(BS, 1);
		NBBITS = GF_GET_BIT_SIZE(GF_NODE_GET_NUM_FIELDS_IN_MODE(NODE, GF_SG_FIELD_CODING_DEF)-1);
		WHILE (!FLAG && (CODEC->LASTERROR>=0)) {
			FIELD_REF = GF_BS_READ_INT(BS, NBBITS);
			E = GF_BIFS_GET_FIELD_INDEX(NODE, FIELD_REF, GF_SG_FIELD_CODING_DEF, &FIELDIND);
			IF (E) GOTO EXIT;
			E = GF_NODE_GET_FIELD(NODE, FIELDIND, &FIELD);
			IF (E) GOTO EXIT;
			INF = GF_SG_COMMAND_FIELD_NEW(COM);
			INF->FIELDTYPE = FIELD.FIELDTYPE;
			INF->FIELDINDEX = FIELD.FIELDINDEX;
			IF (INF->FIELDTYPE==GF_SG_VRML_SFNODE) {
				FIELD.FAR_PTR = INF->FIELD_PTR = &INF->NEW_NODE;
			} ELSE IF (INF->FIELDTYPE==GF_SG_VRML_MFNODE) {
				FIELD.FAR_PTR = INF->FIELD_PTR = &INF->NODE_LIST;
			} ELSE {
				FIELD.FAR_PTR = INF->FIELD_PTR = GF_SG_VRML_FIELD_POINTER_NEW(INF->FIELDTYPE);
			}
			E = GF_BIFS_DEC_FIELD(CODEC, BS, NODE, &FIELD, GF_TRUE);
			IF (E) GOTO EXIT;
			FLAG = GF_BS_READ_INT(BS, 1);
		}
	}


EXIT:
	IF (E) GF_SG_COMMAND_DEL(COM);
	ELSE GF_LIST_ADD(COM_LIST, COM);
	RETURN E;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195668_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GEN_VALUES(CODEGEN_SCOPE *S, NODE *T, INT VAL, INT LIMIT)
{
  INT N = 0;
  INT FIRST = 1;
  INT SLIMIT = GEN_VAL_STACK_MAX;

  IF (LIMIT == 0) LIMIT = GEN_LIT_ARY_MAX;
  IF (CURSP() >= SLIMIT) SLIMIT = INT16_MAX;

  IF (!VAL) {
    WHILE (T) {
      CODEGEN(S, T->CAR, NOVAL);
      N++;
      T = T->CDR;
    }
    RETURN N;
  }

  WHILE (T) {
    INT IS_SPLAT = NINT(T->CAR->CAR) == NODE_SPLAT;

    IF (IS_SPLAT || N > LIMIT || CURSP() >= SLIMIT) { /* FLUSH STACK */
      POP_N(N);
      IF (FIRST) {
        IF (N == 0) {
          GENOP_1(S, OP_LOADNIL, CURSP());
        }
        ELSE {
          GENOP_2(S, OP_ARRAY, CURSP(), N);
        }
        PUSH();
        FIRST = 0;
        LIMIT = GEN_LIT_ARY_MAX;
      }
      ELSE IF (N > 0) {
        POP();
        GENOP_2(S, OP_ARYPUSH, CURSP(), N);
        PUSH();
      }
      N = 0;
    }
    CODEGEN(S, T->CAR, VAL);
    IF (IS_SPLAT) {
      POP(); POP();
      GENOP_1(S, OP_ARYCAT, CURSP());
      PUSH();
    }
    ELSE {
      N++;
    }
    T = T->CDR;
  }
  IF (!FIRST) {
    POP();
    IF (N > 0) {
      POP_N(N);
      GENOP_2(S, OP_ARYPUSH, CURSP(), N);
    }
    RETURN -1;                  /* VARIABLE LENGTH */
  }
  RETURN N;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248241_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DLLIMPORT CFG_T *CFG_GETNSEC(CFG_T *CFG, CONST CHAR *NAME, UNSIGNED INT INDEX)
{
	RETURN CFG_OPT_GETNSEC(CFG_GETOPT(CFG, NAME), INDEX);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 383328_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDIMAGEPTR GDIMAGEROTATE (GDIMAGEPTR SRC, DOUBLE DANGLE, INT CLRBACK)
{
	GDIMAGEPTR PMIDIMG;
	GDIMAGEPTR ROTATEDIMG;

	IF (SRC == NULL) {
		RETURN NULL;
	}

	WHILE (DANGLE >= 360.0) {
		DANGLE -= 360.0;
	}

	WHILE (DANGLE < 0) {
		DANGLE += 360.0;
	}
    
	IF (DANGLE == 90.00) {
		RETURN GDIMAGEROTATE90(SRC);
	}
	IF (DANGLE == 180.00) {
		RETURN GDIMAGEROTATE180(SRC);
	}
	IF(DANGLE == 270.00) {
		RETURN GDIMAGEROTATE270 ( SRC);
	}

	IF ((DANGLE > 45.0) && (DANGLE <= 135.0)) {
		PMIDIMG = GDIMAGEROTATE90 (SRC);
		DANGLE -= 90.0;
	} ELSE IF ((DANGLE > 135.0) && (DANGLE <= 225.0)) {
		PMIDIMG = GDIMAGEROTATE180 (SRC);
		DANGLE -= 180.0;
	} ELSE IF ((DANGLE > 225.0) && (DANGLE <= 315.0)) {
		PMIDIMG = GDIMAGEROTATE270 (SRC);
		DANGLE -= 270.0;
	} ELSE {
		RETURN GDIMAGEROTATE45 (SRC, DANGLE, CLRBACK);
	}
    
	IF (PMIDIMG == NULL) {
		RETURN NULL;
	}
	
	ROTATEDIMG = GDIMAGEROTATE45 (PMIDIMG, DANGLE, CLRBACK);
	GDIMAGEDESTROY(PMIDIMG);
	
	RETURN ROTATEDIMG;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 432205_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID UNASSIGNED_IO_WRITE(STRUCT UC_STRUCT *UC, VOID* OPAQUE, HWADDR ADDR, UINT64_T DATA, UNSIGNED SIZE)
{
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196316_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT DIGEST_GENERIC_VERIFY(STRUCT DIGEST *D, CONST UNSIGNED CHAR *MD)
{
	INT RET;
	INT LEN = DIGEST_LENGTH(D);
	UNSIGNED CHAR *TMP;

	TMP = XMALLOC(LEN);

	RET = DIGEST_FINAL(D, TMP);
	IF (RET)
		GOTO END;

	RET = MEMCMP(MD, TMP, LEN);
	RET = RET ? -EINVAL : 0;
END:
	FREE(TMP);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195085_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SETUP_SECCOMP (FLATPAKBWRAP   *BWRAP,
               CONST CHAR     *ARCH,
               GULONG          ALLOWED_PERSONALITY,
               FLATPAKRUNFLAGS RUN_FLAGS,
               GERROR        **ERROR)
{
  GBOOLEAN MULTIARCH = (RUN_FLAGS & FLATPAK_RUN_FLAG_MULTIARCH) != 0;
  GBOOLEAN DEVEL = (RUN_FLAGS & FLATPAK_RUN_FLAG_DEVEL) != 0;

  __ATTRIBUTE__((CLEANUP (CLEANUP_SECCOMP))) SCMP_FILTER_CTX SECCOMP = NULL;

  /**** BEGIN NOTE ON CODE SHARING
   *
   * THERE ARE TODAY A NUMBER OF DIFFERENT LINUX CONTAINER
   * IMPLEMENTATIONS.  THAT WILL LIKELY CONTINUE FOR LONG INTO THE
   * FUTURE.  BUT WE CAN STILL TRY TO SHARE CODE, AND IT'S IMPORTANT
   * TO DO SO BECAUSE IT AFFECTS WHAT LIBRARY AND APPLICATION WRITERS
   * CAN DO, AND WE SHOULD SUPPORT CODE PORTABILITY BETWEEN DIFFERENT
   * CONTAINER TOOLS.
   *
   * THIS SYSCALL BLOCKLIST IS COPIED FROM LINUX-USER-CHROOT, WHICH WAS IN TURN
   * CLEARLY INFLUENCED BY THE SANDSTORM.IO BLOCKLIST.
   *
   * IF YOU MAKE ANY CHANGES HERE, I SUGGEST SENDING THE CHANGES ALONG
   * TO OTHER SANDBOX MAINTAINERS.  USING THE LIBSECCOMP LIST IS ALSO
   * AN APPROPRIATE VENUE:
   * HTTPS://GROUPS.GOOGLE.COM/FORUM/#!FORUM/LIBSECCOMP
   *
   * A NON-EXHAUSTIVE LIST OF LINKS TO CONTAINER TOOLING THAT MIGHT
   * WANT TO SHARE THIS BLOCKLIST:
   *
   *  HTTPS://GITHUB.COM/SANDSTORM-IO/SANDSTORM
   *    IN SRC/SANDSTORM/SUPERVISOR.C++
   *  HTTPS://GITHUB.COM/FLATPAK/FLATPAK.GIT
   *    IN COMMON/FLATPAK-RUN.C
   *  HTTPS://GIT.GNOME.ORG/BROWSE/LINUX-USER-CHROOT
   *    IN SRC/SETUP-SECCOMP.C
   *
   **** END NOTE ON CODE SHARING
   */
  STRUCT
  {
    INT                  SCALL;
    INT                  ERRNUM;
    STRUCT SCMP_ARG_CMP *ARG;
  } SYSCALL_BLOCKLIST[] = {
    /* BLOCK DMESG */
    {SCMP_SYS (SYSLOG), EPERM},
    /* USELESS OLD SYSCALL */
    {SCMP_SYS (USELIB), EPERM},
    /* DON'T ALLOW DISABLING ACCOUNTING */
    {SCMP_SYS (ACCT), EPERM},
    /* 16-BIT CODE IS UNNECESSARY IN THE SANDBOX, AND MODIFY_LDT IS A
       HISTORIC SOURCE OF INTERESTING INFORMATION LEAKS. */
    {SCMP_SYS (MODIFY_LDT), EPERM},
    /* DON'T ALLOW READING CURRENT QUOTA USE */
    {SCMP_SYS (QUOTACTL), EPERM},

    /* DON'T ALLOW ACCESS TO THE KERNEL KEYRING */
    {SCMP_SYS (ADD_KEY), EPERM},
    {SCMP_SYS (KEYCTL), EPERM},
    {SCMP_SYS (REQUEST_KEY), EPERM},

    /* SCARY VM/NUMA OPS */
    {SCMP_SYS (MOVE_PAGES), EPERM},
    {SCMP_SYS (MBIND), EPERM},
    {SCMP_SYS (GET_MEMPOLICY), EPERM},
    {SCMP_SYS (SET_MEMPOLICY), EPERM},
    {SCMP_SYS (MIGRATE_PAGES), EPERM},

    /* DON'T ALLOW SUBNAMESPACE SETUPS: */
    {SCMP_SYS (UNSHARE), EPERM},
    {SCMP_SYS (MOUNT), EPERM},
    {SCMP_SYS (PIVOT_ROOT), EPERM},
#IF DEFINED(__S390__) || DEFINED(__S390X__) || DEFINED(__CRIS__)
    /* ARCHITECTURES WITH CONFIG_CLONE_BACKWARDS2: THE CHILD STACK
     * AND FLAGS ARGUMENTS ARE REVERSED SO THE FLAGS COME SECOND */
    {SCMP_SYS (CLONE), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#ELSE
    /* NORMALLY THE FLAGS COME FIRST */
    {SCMP_SYS (CLONE), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#ENDIF

    /* DON'T ALLOW FAKING INPUT TO THE CONTROLLING TTY (CVE-2017-5226) */
    {SCMP_SYS (IOCTL), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0XFFFFFFFFU, (INT) TIOCSTI)},
  };

  STRUCT
  {
    INT                  SCALL;
    INT                  ERRNUM;
    STRUCT SCMP_ARG_CMP *ARG;
  } SYSCALL_NONDEVEL_BLOCKLIST[] = {
    /* PROFILING OPERATIONS; WE EXPECT THESE TO BE DONE BY TOOLS FROM OUTSIDE
     * THE SANDBOX.  IN PARTICULAR PERF HAS BEEN THE SOURCE OF MANY CVES.
     */
    {SCMP_SYS (PERF_EVENT_OPEN), EPERM},
    /* DON'T ALLOW YOU TO SWITCH TO BSD EMULATION OR WHATNOT */
    {SCMP_SYS (PERSONALITY), EPERM, &SCMP_A0 (SCMP_CMP_NE, ALLOWED_PERSONALITY)},
    {SCMP_SYS (PTRACE), EPERM}
  };
  /* BLOCKLIST ALL BUT UNIX, INET, INET6 AND NETLINK */
  STRUCT
  {
    INT             FAMILY;
    FLATPAKRUNFLAGS FLAGS_MASK;
  } SOCKET_FAMILY_ALLOWLIST[] = {
    /* NOTE: KEEP IN NUMERICAL ORDER */
    { AF_UNSPEC, 0 },
    { AF_LOCAL, 0 },
    { AF_INET, 0 },
    { AF_INET6, 0 },
    { AF_NETLINK, 0 },
    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },
    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },
  };
  INT LAST_ALLOWED_FAMILY;
  INT I, R;
  G_AUTO(GLNXTMPFILE) SECCOMP_TMPF  = { 0, };

  SECCOMP = SECCOMP_INIT (SCMP_ACT_ALLOW);
  IF (!SECCOMP)
    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("INITIALIZE SECCOMP FAILED"));

  IF (ARCH != NULL)
    {
      UINT32_T ARCH_ID = 0;
      CONST UINT32_T *EXTRA_ARCHES = NULL;

      IF (STRCMP (ARCH, "I386") == 0)
        {
          ARCH_ID = SCMP_ARCH_X86;
        }
      ELSE IF (STRCMP (ARCH, "X86_64") == 0)
        {
          ARCH_ID = SCMP_ARCH_X86_64;
          EXTRA_ARCHES = SECCOMP_X86_64_EXTRA_ARCHES;
        }
      ELSE IF (STRCMP (ARCH, "ARM") == 0)
        {
          ARCH_ID = SCMP_ARCH_ARM;
        }
#IFDEF SCMP_ARCH_AARCH64
      ELSE IF (STRCMP (ARCH, "AARCH64") == 0)
        {
          ARCH_ID = SCMP_ARCH_AARCH64;
          EXTRA_ARCHES = SECCOMP_AARCH64_EXTRA_ARCHES;
        }
#ENDIF

      /* WE ONLY REALLY NEED TO HANDLE ARCHES ON MULTIARCH SYSTEMS.
       * IF ONLY ONE ARCH IS SUPPORTED THE DEFAULT IS FINE */
      IF (ARCH_ID != 0)
        {
          /* THIS *ADDS* THE TARGET ARCH, INSTEAD OF REPLACING THE
             NATIVE ONE. THIS IS NOT IDEAL, BECAUSE WE'D LIKE TO ONLY
             ALLOW THE TARGET ARCH, BUT WE CAN'T REALLY DISALLOW THE
             NATIVE ARCH AT THIS POINT, BECAUSE THEN BUBBLEWRAP
             COULDN'T CONTINUE RUNNING. */
          R = SECCOMP_ARCH_ADD (SECCOMP, ARCH_ID);
          IF (R < 0 && R != -EEXIST)
            RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO ADD ARCHITECTURE TO SECCOMP FILTER"));

          IF (MULTIARCH && EXTRA_ARCHES != NULL)
            {
              FOR (I = 0; EXTRA_ARCHES[I] != 0; I++)
                {
                  R = SECCOMP_ARCH_ADD (SECCOMP, EXTRA_ARCHES[I]);
                  IF (R < 0 && R != -EEXIST)
                    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO ADD MULTIARCH ARCHITECTURE TO SECCOMP FILTER"));
                }
            }
        }
    }

  /* TODO: SHOULD WE FILTER THE KERNEL KEYRING SYSCALLS IN SOME WAY?
   * WE DO WANT THEM TO BE USED BY DESKTOP APPS, BUT THEY COULD ALSO PERHAPS
   * LEAK SYSTEM STUFF OR SECRETS FROM OTHER APPS.
   */

  FOR (I = 0; I < G_N_ELEMENTS (SYSCALL_BLOCKLIST); I++)
    {
      INT SCALL = SYSCALL_BLOCKLIST[I].SCALL;
      INT ERRNUM = SYSCALL_BLOCKLIST[I].ERRNUM;

      G_RETURN_VAL_IF_FAIL (ERRNUM == EPERM || ERRNUM == ENOSYS, FALSE);

      IF (SYSCALL_BLOCKLIST[I].ARG)
        R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 1, *SYSCALL_BLOCKLIST[I].ARG);
      ELSE
        R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 0);
      IF (R < 0 && R == -EFAULT /* UNKNOWN SYSCALL */)
        RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO BLOCK SYSCALL %D"), SCALL);
    }

  IF (!DEVEL)
    {
      FOR (I = 0; I < G_N_ELEMENTS (SYSCALL_NONDEVEL_BLOCKLIST); I++)
        {
          INT SCALL = SYSCALL_NONDEVEL_BLOCKLIST[I].SCALL;
          INT ERRNUM = SYSCALL_NONDEVEL_BLOCKLIST[I].ERRNUM;

          G_RETURN_VAL_IF_FAIL (ERRNUM == EPERM || ERRNUM == ENOSYS, FALSE);

          IF (SYSCALL_NONDEVEL_BLOCKLIST[I].ARG)
            R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 1, *SYSCALL_NONDEVEL_BLOCKLIST[I].ARG);
          ELSE
            R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 0);

          IF (R < 0 && R == -EFAULT /* UNKNOWN SYSCALL */)
            RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO BLOCK SYSCALL %D"), SCALL);
        }
    }

  /* SOCKET FILTERING DOESN'T WORK ON E.G. I386, SO IGNORE FAILURES HERE
   * HOWEVER, WE NEED TO USER SECCOMP_RULE_ADD_EXACT TO AVOID LIBSECCOMP DOING
   * SOMETHING ELSE: HTTPS://GITHUB.COM/SECCOMP/LIBSECCOMP/ISSUES/8 */
  LAST_ALLOWED_FAMILY = -1;
  FOR (I = 0; I < G_N_ELEMENTS (SOCKET_FAMILY_ALLOWLIST); I++)
    {
      INT FAMILY = SOCKET_FAMILY_ALLOWLIST[I].FAMILY;
      INT DISALLOWED;

      IF (SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK != 0 &&
          (SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK & RUN_FLAGS) != SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK)
        CONTINUE;

      FOR (DISALLOWED = LAST_ALLOWED_FAMILY + 1; DISALLOWED < FAMILY; DISALLOWED++)
        {
          /* BLOCKLIST THE IN-BETWEEN VALID FAMILIES */
          SECCOMP_RULE_ADD_EXACT (SECCOMP, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (SOCKET), 1, SCMP_A0 (SCMP_CMP_EQ, DISALLOWED));
        }
      LAST_ALLOWED_FAMILY = FAMILY;
    }
  /* BLOCKLIST THE REST */
  SECCOMP_RULE_ADD_EXACT (SECCOMP, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (SOCKET), 1, SCMP_A0 (SCMP_CMP_GE, LAST_ALLOWED_FAMILY + 1));

  IF (!GLNX_OPEN_ANONYMOUS_TMPFILE_FULL (O_RDWR | O_CLOEXEC, "/TMP", &SECCOMP_TMPF, ERROR))
    RETURN FALSE;

  IF (SECCOMP_EXPORT_BPF (SECCOMP, SECCOMP_TMPF.FD) != 0)
    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO EXPORT BPF"));

  LSEEK (SECCOMP_TMPF.FD, 0, SEEK_SET);

  FLATPAK_BWRAP_ADD_ARGS_DATA_FD (BWRAP,
                                  "--SECCOMP", GLNX_STEAL_FD (&SECCOMP_TMPF.FD), NULL);

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212934_CWE-732.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT WRITE_ENTRY(STRUCT MAILBOX *MAILBOX,
                       UNSIGNED INT UID,
                       CONST CHAR *ENTRY,
                       CONST CHAR *USERID,
                       CONST STRUCT BUF *VALUE,
                       INT IGNOREQUOTA,
                       INT SILENT,
                       CONST STRUCT ANNOTATE_METADATA *MDATA,
                       INT MAYWRITE)

{
    CHAR KEY[MAX_MAILBOX_PATH+1];
    INT KEYLEN, R;
    ANNOTATE_DB_T *D = NULL;
    STRUCT BUF OLDVAL = BUF_INITIALIZER;
    CONST CHAR *MBOXNAME = MAILBOX ? MAILBOX->NAME : "";
    MODSEQ_T MODSEQ = MDATA ? MDATA->MODSEQ : 0;

    R = _ANNOTATE_GETDB(MBOXNAME, UID, CYRUSDB_CREATE, &D);
    IF (R)
        RETURN R;

    /* MUST BE IN A TRANSACTION TO MODIFY THE DB */
    ANNOTATE_BEGIN(D);

    KEYLEN = MAKE_KEY(MBOXNAME, UID, ENTRY, USERID, KEY, SIZEOF(KEY));

    IF (MAILBOX) {
        STRUCT ANNOTATE_METADATA OLDMDATA;
        R = READ_OLD_VALUE(D, KEY, KEYLEN, &OLDVAL, &OLDMDATA);
        IF (R) GOTO OUT;

        /* IF THE VALUE IS IDENTICAL, DON'T TOUCH THE MAILBOX */
        IF (OLDVAL.LEN == VALUE->LEN && (!VALUE->LEN || !MEMCMP(OLDVAL.S, VALUE->S, VALUE->LEN)))
            GOTO OUT;

        IF (!IGNOREQUOTA) {
            QUOTA_T QDIFFS[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;
            QDIFFS[QUOTA_ANNOTSTORAGE] = VALUE->LEN - (QUOTA_T)OLDVAL.LEN;
            R = MAILBOX_QUOTA_CHECK(MAILBOX, QDIFFS);
            IF (R) GOTO OUT;
        }

        IF (!MAYWRITE) {
            R = IMAP_PERMISSION_DENIED;
            IF (R) GOTO OUT;
        }

        /* DO THE ANNOT-CHANGED HERE BEFORE ALTERING THE DB */
        MAILBOX_ANNOT_CHANGED(MAILBOX, UID, ENTRY, USERID, &OLDVAL, VALUE, SILENT);

        /* GRAB THE MESSAGE ANNOTATION MODSEQ, IF NOT OVERRIDDEN */
        IF (UID && !MDATA) {
            MODSEQ = MAILBOX->I.HIGHESTMODSEQ;
        }
    }

    /* ZERO LENGTH ANNOTATION IS DELETION.
     * KEEP TOMBSTONES FOR MESSAGE ANNOTATIONS */
    IF (!VALUE->LEN && !UID) {

#IF DEBUG
        SYSLOG(LOG_ERR, "WRITE_ENTRY: DELETING KEY %S FROM %S",
                KEY_AS_STRING(D, KEY, KEYLEN), D->FILENAME);
#ENDIF

        DO {
            R = CYRUSDB_DELETE(D->DB, KEY, KEYLEN, TID(D), /*FORCE*/1);
        } WHILE (R == CYRUSDB_AGAIN);
    }
    ELSE {
        STRUCT BUF DATA = BUF_INITIALIZER;
        UNSIGNED CHAR FLAGS = 0;
        IF (!VALUE->LEN || VALUE->S == NULL) {
            FLAGS |= ANNOTATE_FLAG_DELETED;
        }
        ELSE {
            // THIS IS ONLY HERE TO ALLOW CLEANUP OF INVALID VALUES IN THE PAST...
            // THE CALLING OF THIS API WITH A NULL "USERID" IS BOGUS, BECAUSE THAT'S
            // SUPPOSED TO BE RESERVED FOR THE MAKE_KEY OF PREFIXES - BUT THERE HAS
            // BEEN API ABUSE IN THE PAST, SO SOME OF THESE ARE IN THE WILD.  *SIGH*.
            // DON'T ALLOW NEW ONES TO BE WRITTEN
            IF (!USERID) GOTO OUT;
        }
        MAKE_ENTRY(&DATA, VALUE, MODSEQ, FLAGS);

#IF DEBUG
        SYSLOG(LOG_ERR, "WRITE_ENTRY: STORING KEY %S (VALUE: %S) TO %S (MODSEQ=" MODSEQ_FMT ")",
                KEY_AS_STRING(D, KEY, KEYLEN), VALUE->S, D->FILENAME, MODSEQ);
#ENDIF

        DO {
            R = CYRUSDB_STORE(D->DB, KEY, KEYLEN, DATA.S, DATA.LEN, TID(D));
        } WHILE (R == CYRUSDB_AGAIN);
        BUF_FREE(&DATA);
    }

    IF (!MAILBOX)
        SYNC_LOG_ANNOTATION("");

OUT:
    ANNOTATE_PUTDB(&D);
    BUF_FREE(&OLDVAL);

    RETURN R;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202392_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE LINECONTRIBTYPE * _GDCONTRIBUTIONSALLOC(UNSIGNED INT LINE_LENGTH, UNSIGNED INT WINDOWS_SIZE)
{
	UNSIGNED INT U = 0;
	LINECONTRIBTYPE *RES;
	INT OVERFLOW_ERROR = 0;

	RES = (LINECONTRIBTYPE *) GDMALLOC(SIZEOF(LINECONTRIBTYPE));
	IF (!RES) {
		RETURN NULL;
	}
	RES->WINDOWSIZE = WINDOWS_SIZE;
	RES->LINELENGTH = LINE_LENGTH;
	IF (OVERFLOW2(LINE_LENGTH, SIZEOF(CONTRIBUTIONTYPE))) {
		GDFREE(RES);
		RETURN NULL;
	}
	RES->CONTRIBROW = (CONTRIBUTIONTYPE *) GDMALLOC(LINE_LENGTH * SIZEOF(CONTRIBUTIONTYPE));
	IF (RES->CONTRIBROW == NULL) {
		GDFREE(RES);
		RETURN NULL;
	}
	FOR (U = 0 ; U < LINE_LENGTH ; U++) {
		IF (OVERFLOW2(WINDOWS_SIZE, SIZEOF(DOUBLE))) {
			OVERFLOW_ERROR = 1;
		} ELSE {
			RES->CONTRIBROW[U].WEIGHTS = (DOUBLE *) GDMALLOC(WINDOWS_SIZE * SIZEOF(DOUBLE));
		}
		IF (OVERFLOW_ERROR == 1 || RES->CONTRIBROW[U].WEIGHTS == NULL) {
			U--;
			WHILE (U >= 0) {
				GDFREE(RES->CONTRIBROW[U].WEIGHTS);
				U--;
			}
			RETURN NULL;
		}
	}
	RETURN RES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 372879_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IRDA_OPEN_TSAP(STRUCT IRDA_SOCK *SELF, __U8 TSAP_SEL, CHAR *NAME)
{
	NOTIFY_T NOTIFY;

	IF (SELF->TSAP) {
		IRDA_WARNING("%S: BUSY!\N", __FUNC__);
		RETURN -EBUSY;
	}

	/* INITIALIZE CALLBACKS TO BE USED BY THE IRDA STACK */
	IRDA_NOTIFY_INIT(&NOTIFY);
	NOTIFY.CONNECT_CONFIRM       = IRDA_CONNECT_CONFIRM;
	NOTIFY.CONNECT_INDICATION    = IRDA_CONNECT_INDICATION;
	NOTIFY.DISCONNECT_INDICATION = IRDA_DISCONNECT_INDICATION;
	NOTIFY.DATA_INDICATION       = IRDA_DATA_INDICATION;
	NOTIFY.UDATA_INDICATION	     = IRDA_DATA_INDICATION;
	NOTIFY.FLOW_INDICATION       = IRDA_FLOW_INDICATION;
	NOTIFY.INSTANCE = SELF;
	STRNCPY(NOTIFY.NAME, NAME, NOTIFY_MAX_NAME);

	SELF->TSAP = IRTTP_OPEN_TSAP(TSAP_SEL, DEFAULT_INITIAL_CREDIT,
				     &NOTIFY);
	IF (SELF->TSAP == NULL) {
		IRDA_DEBUG(0, "%S(), UNABLE TO ALLOCATE TSAP!\N",
			   __FUNC__);
		RETURN -ENOMEM;
	}
	/* REMEMBER WHICH TSAP SELECTOR WE ACTUALLY GOT */
	SELF->STSAP_SEL = SELF->TSAP->STSAP_SEL;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253982_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT VIDIOC_QUERYBUF(STRUCT FILE *FILE, VOID *FH, STRUCT V4L2_BUFFER *B)
{
	ENUM V4L2_BUF_TYPE TYPE;
	INT INDEX;
	STRUCT V4L2_LOOPBACK_DEVICE *DEV;
	STRUCT V4L2_LOOPBACK_OPENER *OPENER;

	MARK();

	TYPE = B->TYPE;
	INDEX = B->INDEX;
	DEV = V4L2LOOPBACK_GETDEVICE(FILE);
	OPENER = FILE->PRIVATE_DATA;

	IF ((B->TYPE != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
			(B->TYPE != V4L2_BUF_TYPE_VIDEO_OUTPUT)) {
		RETURN -EINVAL;
	}
	IF (B->INDEX > MAX_BUFFERS)
		RETURN -EINVAL;

	IF (OPENER->TIMEOUT_IMAGE_IO)
		*B = DEV->TIMEOUT_IMAGE_BUFFER.BUFFER;
	ELSE
		*B = DEV->BUFFERS[B->INDEX % DEV->USED_BUFFERS].BUFFER;

	B->TYPE = TYPE;
	B->INDEX = INDEX;
	DPRINTKRW("BUFFER TYPE: %D (OF %D WITH SIZE=%LD)\N", B->MEMORY, DEV->BUFFERS_NUMBER, DEV->BUFFER_SIZE);

	/*  HOPEFULLY FIX 'DQBUF RETURN BAD INDEX IF QUEUE BIGGER THEN 2 FOR CAPTURE'
		HTTPS://GITHUB.COM/UMLAEUTE/V4L2LOOPBACK/ISSUES/60 */
	B->FLAGS &= ~V4L2_BUF_FLAG_DONE;
	B->FLAGS |= V4L2_BUF_FLAG_QUEUED;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248297_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CFG_OPT_T *CFG_DUPOPT_ARRAY(CFG_OPT_T *OPTS)
{
	INT I;
	CFG_OPT_T *DUPOPTS;
	INT N = CFG_NUMOPTS(OPTS);

	DUPOPTS = CALLOC(N + 1, SIZEOF(CFG_OPT_T));
	IF (!DUPOPTS)
		RETURN NULL;

	MEMCPY(DUPOPTS, OPTS, N * SIZEOF(CFG_OPT_T));

	FOR (I = 0; I < N; I++) {
		/* CLEAR DYNAMIC PTRS, PROTECTING THE ORIGINAL ON FAILURE */
		DUPOPTS[I].NAME = NULL;
		DUPOPTS[I].SUBOPTS = NULL;
		DUPOPTS[I].DEF.PARSED = NULL;
		DUPOPTS[I].DEF.STRING = NULL;
		DUPOPTS[I].COMMENT = NULL;
	}

	FOR (I = 0; I < N; I++) {
		DUPOPTS[I].NAME = STRDUP(OPTS[I].NAME);
		IF (!DUPOPTS[I].NAME)
			GOTO ERR;

		IF (OPTS[I].SUBOPTS) {
			DUPOPTS[I].SUBOPTS = CFG_DUPOPT_ARRAY(OPTS[I].SUBOPTS);
			IF (!DUPOPTS[I].SUBOPTS)
				GOTO ERR;
		}

		IF (OPTS[I].DEF.PARSED) {
			DUPOPTS[I].DEF.PARSED = STRDUP(OPTS[I].DEF.PARSED);
			IF (!DUPOPTS[I].DEF.PARSED)
				GOTO ERR;
		}

		IF (OPTS[I].DEF.STRING) {
			DUPOPTS[I].DEF.STRING = STRDUP(OPTS[I].DEF.STRING);
			IF (!DUPOPTS[I].DEF.STRING)
				GOTO ERR;
		}

		IF (OPTS[I].COMMENT) {
			DUPOPTS[I].COMMENT = STRDUP(OPTS[I].COMMENT);
			IF (!DUPOPTS[I].COMMENT)
				GOTO ERR;
		}
	}

	RETURN DUPOPTS;
ERR:
	CFG_FREE_OPT_ARRAY(DUPOPTS);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343214_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DOSITETIME(VOID)
{
    CHAR TMP[64];
    CONST STRUCT TM *TM;
    TIME_T NOW;

    IF ((NOW = TIME(NULL)) == (TIME_T) -1 || (TM = LOCALTIME(&NOW)) == NULL) {
        ADDREPLY_NOFORMAT(451, "TIME()");
        RETURN;
    }
    STRFTIME(TMP, SIZEOF TMP, "%Y-%M-%D %H:%M:%S", TM);
    ADDREPLY_NOFORMAT(211, TMP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210090_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CDF_READ_PROPERTY_INFO(CONST CDF_STREAM_T *SST, CONST CDF_HEADER_T *H,
    UINT32_T OFFS, CDF_PROPERTY_INFO_T **INFO, SIZE_T *COUNT, SIZE_T *MAXCOUNT)
{
	CONST CDF_SECTION_HEADER_T *SHP;
	CDF_SECTION_HEADER_T SH;
	CONST UINT8_T *P, *Q, *E;
	SIZE_T I, O4, NELEMENTS, J, SLEN, LEFT;
	CDF_PROPERTY_INFO_T *INP;

	IF (OFFS > UINT32_MAX / 4) {
		ERRNO = EFTYPE;
		GOTO OUT;
	}
	SHP = CAST(CONST CDF_SECTION_HEADER_T *,
	    CDF_OFFSET(SST->SST_TAB, OFFS));
	IF (CDF_CHECK_STREAM_OFFSET(SST, H, SHP, SIZEOF(*SHP), __LINE__) == -1)
		GOTO OUT;
	SH.SH_LEN = CDF_TOLE4(SHP->SH_LEN);
	IF (SH.SH_LEN > CDF_SHLEN_LIMIT) {
		ERRNO = EFTYPE;
		GOTO OUT;
	}

	IF (CDF_CHECK_STREAM_OFFSET(SST, H, SHP, SH.SH_LEN, __LINE__) == -1)
		GOTO OUT;

	SH.SH_PROPERTIES = CDF_TOLE4(SHP->SH_PROPERTIES);
	DPRINTF(("SECTION LEN: %U PROPERTIES %U\N", SH.SH_LEN,
	    SH.SH_PROPERTIES));
	IF (SH.SH_PROPERTIES > CDF_PROP_LIMIT)
		GOTO OUT;
	INP = CDF_GROW_INFO(INFO, MAXCOUNT, SH.SH_PROPERTIES);
	IF (INP == NULL)
		GOTO OUT;
	INP += *COUNT;
	*COUNT += SH.SH_PROPERTIES;
	P = CAST(CONST UINT8_T *, CDF_OFFSET(SST->SST_TAB, OFFS + SIZEOF(SH)));
	E = CAST(CONST UINT8_T *, CDF_OFFSET(SHP, SH.SH_LEN));
	IF (P >= E || CDF_CHECK_STREAM_OFFSET(SST, H, E, 0, __LINE__) == -1)
		GOTO OUT;

	FOR (I = 0; I < SH.SH_PROPERTIES; I++) {
		IF ((Q = CDF_GET_PROPERTY_INFO_POS(SST, H, P, E, I)) == NULL)
			GOTO OUT;
		INP[I].PI_ID = CDF_GETUINT32(P, I << 1);
		LEFT = CAST(SIZE_T, E - Q);
		IF (LEFT < SIZEOF(UINT32_T)) {
			DPRINTF(("SHORT INFO (NO TYPE)_\N"));
			GOTO OUT;
		}
		INP[I].PI_TYPE = CDF_GETUINT32(Q, 0);
		DPRINTF(("%" SIZE_T_FORMAT "U) ID=%#X TYPE=%#X OFFS=%#TX,%#X\N",
		    I, INP[I].PI_ID, INP[I].PI_TYPE, Q - P, OFFS));
		IF (INP[I].PI_TYPE & CDF_VECTOR) {
			IF (LEFT < SIZEOF(UINT32_T) * 2) {
				DPRINTF(("MISSING CDF_VECTOR LENGTH\N"));
				GOTO OUT;
			}
			NELEMENTS = CDF_GETUINT32(Q, 1);
			IF (NELEMENTS == 0) {
				DPRINTF(("CDF_VECTOR WITH NELEMENTS == 0\N"));
				GOTO OUT;
			}
			SLEN = 2;
		} ELSE {
			NELEMENTS = 1;
			SLEN = 1;
		}
		O4 = SLEN * SIZEOF(UINT32_T);
		IF (INP[I].PI_TYPE & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
			GOTO UNKNOWN;
		SWITCH (INP[I].PI_TYPE & CDF_TYPEMASK) {
		CASE CDF_NULL:
		CASE CDF_EMPTY:
			BREAK;
		CASE CDF_SIGNED16:
			IF (!CDF_COPY_INFO(&INP[I], &Q[O4], E, SIZEOF(INT16_T)))
				GOTO UNKNOWN;
			BREAK;
		CASE CDF_SIGNED32:
		CASE CDF_BOOL:
		CASE CDF_UNSIGNED32:
		CASE CDF_FLOAT:
			IF (!CDF_COPY_INFO(&INP[I], &Q[O4], E, SIZEOF(INT32_T)))
				GOTO UNKNOWN;
			BREAK;
		CASE CDF_SIGNED64:
		CASE CDF_UNSIGNED64:
		CASE CDF_DOUBLE:
		CASE CDF_FILETIME:
			IF (!CDF_COPY_INFO(&INP[I], &Q[O4], E, SIZEOF(INT64_T)))
				GOTO UNKNOWN;
			BREAK;
		CASE CDF_LENGTH32_STRING:
		CASE CDF_LENGTH32_WSTRING:
			IF (NELEMENTS > 1) {
				SIZE_T NELEM = INP - *INFO;
				INP = CDF_GROW_INFO(INFO, MAXCOUNT, NELEMENTS);
				IF (INP == NULL)
					GOTO OUT;
				INP += NELEM;
			}
			DPRINTF(("NELEMENTS = %" SIZE_T_FORMAT "U\N",
			    NELEMENTS));
			FOR (J = 0; J < NELEMENTS && I < SH.SH_PROPERTIES;
			    J++, I++)
			{
				UINT32_T L;

				IF (O4 + SIZEOF(UINT32_T) > LEFT)
					GOTO OUT;

				L = CDF_GETUINT32(Q, SLEN);
				O4 += SIZEOF(UINT32_T);
				IF (O4 + L > LEFT)
					GOTO OUT;

				INP[I].PI_STR.S_LEN = L;
				INP[I].PI_STR.S_BUF = CAST(CONST CHAR *,
				    CAST(CONST VOID *, &Q[O4]));

				DPRINTF(("O=%" SIZE_T_FORMAT "U L=%D(%"
				    SIZE_T_FORMAT "U), T=%" SIZE_T_FORMAT
				    "U S=%S\N", O4, L, CDF_ROUND(L, SIZEOF(L)),
				    LEFT, INP[I].PI_STR.S_BUF));

				IF (L & 1)
					L++;

				SLEN += L >> 1;
				O4 = SLEN * SIZEOF(UINT32_T);
			}
			I--;
			BREAK;
		CASE CDF_CLIPBOARD:
			IF (INP[I].PI_TYPE & CDF_VECTOR)
				GOTO UNKNOWN;
			BREAK;
		DEFAULT:
		UNKNOWN:
			MEMSET(&INP[I].PI_VAL, 0, SIZEOF(INP[I].PI_VAL));
			DPRINTF(("DON'T KNOW HOW TO DEAL WITH %#X\N",
			    INP[I].PI_TYPE));
			BREAK;
		}
	}
	RETURN 0;
OUT:
	FREE(*INFO);
	*INFO = NULL;
	*COUNT = 0;
	*MAXCOUNT = 0;
	ERRNO = EFTYPE;
	RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215342_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT GET_USER_PAGES(STRUCT TASK_STRUCT *TSK, STRUCT MM_STRUCT *MM,
		UNSIGNED LONG START, INT LEN, INT WRITE, INT FORCE,
		STRUCT PAGE **PAGES, STRUCT VM_AREA_STRUCT **VMAS)
{
	INT I;
	UNSIGNED INT VM_FLAGS;

	IF (LEN <= 0)
		RETURN 0;
	/* 
	 * REQUIRE READ OR WRITE PERMISSIONS.
	 * IF 'FORCE' IS SET, WE ONLY REQUIRE THE "MAY" FLAGS.
	 */
	VM_FLAGS  = WRITE ? (VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);
	VM_FLAGS &= FORCE ? (VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
	I = 0;

	DO {
		STRUCT VM_AREA_STRUCT *VMA;
		UNSIGNED INT FOLL_FLAGS;

		VMA = FIND_EXTEND_VMA(MM, START);
		IF (!VMA && IN_GATE_AREA(TSK, START)) {
			UNSIGNED LONG PG = START & PAGE_MASK;
			STRUCT VM_AREA_STRUCT *GATE_VMA = GET_GATE_VMA(TSK);
			PGD_T *PGD;
			PUD_T *PUD;
			PMD_T *PMD;
			PTE_T *PTE;
			IF (WRITE) /* USER GATE PAGES ARE READ-ONLY */
				RETURN I ? : -EFAULT;
			IF (PG > TASK_SIZE)
				PGD = PGD_OFFSET_K(PG);
			ELSE
				PGD = PGD_OFFSET_GATE(MM, PG);
			BUG_ON(PGD_NONE(*PGD));
			PUD = PUD_OFFSET(PGD, PG);
			BUG_ON(PUD_NONE(*PUD));
			PMD = PMD_OFFSET(PUD, PG);
			IF (PMD_NONE(*PMD))
				RETURN I ? : -EFAULT;
			PTE = PTE_OFFSET_MAP(PMD, PG);
			IF (PTE_NONE(*PTE)) {
				PTE_UNMAP(PTE);
				RETURN I ? : -EFAULT;
			}
			IF (PAGES) {
				STRUCT PAGE *PAGE = VM_NORMAL_PAGE(GATE_VMA, START, *PTE);
				PAGES[I] = PAGE;
				IF (PAGE)
					GET_PAGE(PAGE);
			}
			PTE_UNMAP(PTE);
			IF (VMAS)
				VMAS[I] = GATE_VMA;
			I++;
			START += PAGE_SIZE;
			LEN--;
			CONTINUE;
		}

		IF (!VMA || (VMA->VM_FLAGS & (VM_IO | VM_PFNMAP))
				|| !(VM_FLAGS & VMA->VM_FLAGS))
			RETURN I ? : -EFAULT;

		IF (IS_VM_HUGETLB_PAGE(VMA)) {
			I = FOLLOW_HUGETLB_PAGE(MM, VMA, PAGES, VMAS,
						&START, &LEN, I, WRITE);
			CONTINUE;
		}

		FOLL_FLAGS = FOLL_TOUCH;
		IF (PAGES)
			FOLL_FLAGS |= FOLL_GET;
		IF (!WRITE && !(VMA->VM_FLAGS & VM_LOCKED) &&
		    (!VMA->VM_OPS || !VMA->VM_OPS->FAULT))
			FOLL_FLAGS |= FOLL_ANON;

		DO {
			STRUCT PAGE *PAGE;

			/*
			 * IF TSK IS OOMING, CUT OFF ITS ACCESS TO LARGE MEMORY
			 * ALLOCATIONS. IT HAS A PENDING SIGKILL, BUT IT CAN'T
			 * BE PROCESSED UNTIL RETURNING TO USER SPACE.
			 */
			IF (UNLIKELY(TEST_TSK_THREAD_FLAG(TSK, TIF_MEMDIE)))
				RETURN -ENOMEM;

			IF (WRITE)
				FOLL_FLAGS |= FOLL_WRITE;

			COND_RESCHED();
			WHILE (!(PAGE = FOLLOW_PAGE(VMA, START, FOLL_FLAGS))) {
				INT RET;
				RET = HANDLE_MM_FAULT(MM, VMA, START,
						FOLL_FLAGS & FOLL_WRITE);
				IF (RET & VM_FAULT_ERROR) {
					IF (RET & VM_FAULT_OOM)
						RETURN I ? I : -ENOMEM;
					ELSE IF (RET & VM_FAULT_SIGBUS)
						RETURN I ? I : -EFAULT;
					BUG();
				}
				IF (RET & VM_FAULT_MAJOR)
					TSK->MAJ_FLT++;
				ELSE
					TSK->MIN_FLT++;

				/*
				 * THE VM_FAULT_WRITE BIT TELLS US THAT
				 * DO_WP_PAGE HAS BROKEN COW WHEN NECESSARY,
				 * EVEN IF MAYBE_MKWRITE DECIDED NOT TO SET
				 * PTE_WRITE. WE CAN THUS SAFELY DO SUBSEQUENT
				 * PAGE LOOKUPS AS IF THEY WERE READS.
				 */
				IF (RET & VM_FAULT_WRITE)
					FOLL_FLAGS &= ~FOLL_WRITE;

				COND_RESCHED();
			}
			IF (PAGES) {
				PAGES[I] = PAGE;

				FLUSH_ANON_PAGE(VMA, PAGE, START);
				FLUSH_DCACHE_PAGE(PAGE);
			}
			IF (VMAS)
				VMAS[I] = VMA;
			I++;
			START += PAGE_SIZE;
			LEN--;
		} WHILE (LEN && START < VMA->VM_END);
	} WHILE (LEN);
	RETURN I;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234820_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT BTRFS_DEVICE *ADD_MISSING_DEV(STRUCT BTRFS_FS_DEVICES *FS_DEVICES,
					    U64 DEVID, U8 *DEV_UUID)
{
	STRUCT BTRFS_DEVICE *DEVICE;
	UNSIGNED INT NOFS_FLAG;

	/*
	 * WE CALL THIS UNDER THE CHUNK_MUTEX, SO WE WANT TO USE NOFS FOR THIS
	 * ALLOCATION, HOWEVER WE DON'T WANT TO CHANGE BTRFS_ALLOC_DEVICE() TO
	 * ALWAYS DO NOFS BECAUSE WE USE IT IN A LOT OF OTHER GFP_KERNEL SAFE
	 * PLACES.
	 */
	NOFS_FLAG = MEMALLOC_NOFS_SAVE();
	DEVICE = BTRFS_ALLOC_DEVICE(NULL, &DEVID, DEV_UUID);
	MEMALLOC_NOFS_RESTORE(NOFS_FLAG);
	IF (IS_ERR(DEVICE))
		RETURN DEVICE;

	LIST_ADD(&DEVICE->DEV_LIST, &FS_DEVICES->DEVICES);
	DEVICE->FS_DEVICES = FS_DEVICES;
	FS_DEVICES->NUM_DEVICES++;

	SET_BIT(BTRFS_DEV_STATE_MISSING, &DEVICE->DEV_STATE);
	FS_DEVICES->MISSING_DEVICES++;

	RETURN DEVICE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207803_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ADD_INTERRUPT_RANDOMNESS(INT IRQ, INT IRQ_FLAGS)
{
	STRUCT ENTROPY_STORE	*R;
	STRUCT FAST_POOL	*FAST_POOL = THIS_CPU_PTR(&IRQ_RANDOMNESS);
	STRUCT PT_REGS		*REGS = GET_IRQ_REGS();
	UNSIGNED LONG		NOW = JIFFIES;
	CYCLES_T		CYCLES = RANDOM_GET_ENTROPY();
	__U32			C_HIGH, J_HIGH;
	__U64			IP;
	UNSIGNED LONG		SEED;
	INT			CREDIT = 0;

	IF (CYCLES == 0)
		CYCLES = GET_REG(FAST_POOL, REGS);
	C_HIGH = (SIZEOF(CYCLES) > 4) ? CYCLES >> 32 : 0;
	J_HIGH = (SIZEOF(NOW) > 4) ? NOW >> 32 : 0;
	FAST_POOL->POOL[0] ^= CYCLES ^ J_HIGH ^ IRQ;
	FAST_POOL->POOL[1] ^= NOW ^ C_HIGH;
	IP = REGS ? INSTRUCTION_POINTER(REGS) : _RET_IP_;
	FAST_POOL->POOL[2] ^= IP;
	FAST_POOL->POOL[3] ^= (SIZEOF(IP) > 4) ? IP >> 32 :
		GET_REG(FAST_POOL, REGS);

	FAST_MIX(FAST_POOL);
	ADD_INTERRUPT_BENCH(CYCLES);

	IF (UNLIKELY(CRNG_INIT == 0)) {
		IF ((FAST_POOL->COUNT >= 64) &&
		    CRNG_FAST_LOAD((CHAR *) FAST_POOL->POOL,
				   SIZEOF(FAST_POOL->POOL))) {
			FAST_POOL->COUNT = 0;
			FAST_POOL->LAST = NOW;
		}
		RETURN;
	}

	IF ((FAST_POOL->COUNT < 64) &&
	    !TIME_AFTER(NOW, FAST_POOL->LAST + HZ))
		RETURN;

	R = &INPUT_POOL;
	IF (!SPIN_TRYLOCK(&R->LOCK))
		RETURN;

	FAST_POOL->LAST = NOW;
	__MIX_POOL_BYTES(R, &FAST_POOL->POOL, SIZEOF(FAST_POOL->POOL));

	/*
	 * IF WE HAVE ARCHITECTURAL SEED GENERATOR, PRODUCE A SEED AND
	 * ADD IT TO THE POOL.  FOR THE SAKE OF PARANOIA DON'T LET THE
	 * ARCHITECTURAL SEED GENERATOR DOMINATE THE INPUT FROM THE
	 * INTERRUPT NOISE.
	 */
	IF (ARCH_GET_RANDOM_SEED_LONG(&SEED)) {
		__MIX_POOL_BYTES(R, &SEED, SIZEOF(SEED));
		CREDIT = 1;
	}
	SPIN_UNLOCK(&R->LOCK);

	FAST_POOL->COUNT = 0;

	/* AWARD ONE BIT FOR THE CONTENTS OF THE FAST POOL */
	CREDIT_ENTROPY_BITS(R, CREDIT + 1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198439_CWE-288.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_VM_EXEC(MRB_STATE *MRB, CONST STRUCT RPROC *PROC, CONST MRB_CODE *PC)
{
  /* MRB_ASSERT(MRB_PROC_CFUNC_P(PROC)) */
  CONST MRB_IREP *IREP = PROC->BODY.IREP;
  CONST MRB_POOL_VALUE *POOL = IREP->POOL;
  CONST MRB_SYM *SYMS = IREP->SYMS;
  MRB_CODE INSN;
  INT AI = MRB_GC_ARENA_SAVE(MRB);
  STRUCT MRB_JMPBUF *PREV_JMP = MRB->JMP;
  STRUCT MRB_JMPBUF C_JMP;
  UINT32_T A;
  UINT16_T B;
  UINT16_T C;
  MRB_SYM MID;
  CONST STRUCT MRB_IREP_CATCH_HANDLER *CH;

#IFDEF DIRECT_THREADED
  STATIC CONST VOID * CONST OPTABLE[] = {
#DEFINE OPCODE(X,_) &&L_OP_ ## X,
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
  };
#ENDIF

  MRB_BOOL EXC_CATCHED = FALSE;
RETRY_TRY_BLOCK:

  MRB_TRY(&C_JMP) {

  IF (EXC_CATCHED) {
    EXC_CATCHED = FALSE;
    MRB_GC_ARENA_RESTORE(MRB, AI);
    IF (MRB->EXC && MRB->EXC->TT == MRB_TT_BREAK)
      GOTO L_BREAK;
    GOTO L_RAISE;
  }
  MRB->JMP = &C_JMP;
  MRB_VM_CI_PROC_SET(MRB->C->CI, PROC);

#DEFINE REGS (MRB->C->CI->STACK)
  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* DO NOTHING */
      NEXT;
    }

    CASE(OP_MOVE, BB) {
      REGS[A] = REGS[B];
      NEXT;
    }

    CASE(OP_LOADL, BB) {
      SWITCH (POOL[B].TT) {   /* NUMBER */
      CASE IREP_TT_INT32:
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I32);
        BREAK;
      CASE IREP_TT_INT64:
#IF DEFINED(MRB_INT64)
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
        BREAK;
#ELSE
#IF DEFINED(MRB_64BIT)
        IF (INT32_MIN <= POOL[B].U.I64 && POOL[B].U.I64 <= INT32_MAX) {
          REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
          BREAK;
        }
#ENDIF
        GOTO L_INT_OVERFLOW;
#ENDIF
      CASE IREP_TT_BIGINT:
        GOTO L_INT_OVERFLOW;
#IFNDEF MRB_NO_FLOAT
      CASE IREP_TT_FLOAT:
        REGS[A] = MRB_FLOAT_VALUE(MRB, POOL[B].U.F);
        BREAK;
#ENDIF
      DEFAULT:
        /* SHOULD NOT HAPPEN (TT:STRING) */
        REGS[A] = MRB_NIL_VALUE();
        BREAK;
      }
      NEXT;
    }

    CASE(OP_LOADI, BB) {
      SET_FIXNUM_VALUE(REGS[A], B);
      NEXT;
    }

    CASE(OP_LOADINEG, BB) {
      SET_FIXNUM_VALUE(REGS[A], -B);
      NEXT;
    }

    CASE(OP_LOADI__1,B) GOTO L_LOADI;
    CASE(OP_LOADI_0,B) GOTO L_LOADI;
    CASE(OP_LOADI_1,B) GOTO L_LOADI;
    CASE(OP_LOADI_2,B) GOTO L_LOADI;
    CASE(OP_LOADI_3,B) GOTO L_LOADI;
    CASE(OP_LOADI_4,B) GOTO L_LOADI;
    CASE(OP_LOADI_5,B) GOTO L_LOADI;
    CASE(OP_LOADI_6,B) GOTO L_LOADI;
    CASE(OP_LOADI_7, B) {
    L_LOADI:
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)INSN - (MRB_INT)OP_LOADI_0);
      NEXT;
    }

    CASE(OP_LOADI16, BS) {
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)(INT16_T)B);
      NEXT;
    }

    CASE(OP_LOADI32, BSS) {
      SET_INT_VALUE(MRB, REGS[A], (INT32_T)(((UINT32_T)B<<16)+C));
      NEXT;
    }

    CASE(OP_LOADSYM, BB) {
      SET_SYM_VALUE(REGS[A], SYMS[B]);
      NEXT;
    }

    CASE(OP_LOADNIL, B) {
      SET_NIL_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADSELF, B) {
      REGS[A] = REGS[0];
      NEXT;
    }

    CASE(OP_LOADT, B) {
      SET_TRUE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADF, B) {
      SET_FALSE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_GETGV, BB) {
      MRB_VALUE VAL = MRB_GV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETGV, BB) {
      MRB_GV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETSV, BB) {
      MRB_VALUE VAL = MRB_VM_SPECIAL_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETSV, BB) {
      MRB_VM_SPECIAL_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIV, BB) {
      REGS[A] = MRB_IV_GET(MRB, REGS[0], SYMS[B]);
      NEXT;
    }

    CASE(OP_SETIV, BB) {
      MRB_IV_SET(MRB, REGS[0], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETCV, BB) {
      MRB_VALUE VAL;
      VAL = MRB_VM_CV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETCV, BB) {
      MRB_VM_CV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIDX, B) {
      MRB_VALUE VA = REGS[A], VB = REGS[A+1];
      SWITCH (MRB_TYPE(VA)) {
      CASE MRB_TT_ARRAY:
        IF (!MRB_INTEGER_P(VB)) GOTO GETIDX_FALLBACK;
        REGS[A] = MRB_ARY_ENTRY(VA, MRB_INTEGER(VB));
        BREAK;
      CASE MRB_TT_HASH:
        VA = MRB_HASH_GET(MRB, VA, VB);
        REGS[A] = VA;
        BREAK;
      CASE MRB_TT_STRING:
        SWITCH (MRB_TYPE(VB)) {
        CASE MRB_TT_INTEGER:
        CASE MRB_TT_STRING:
        CASE MRB_TT_RANGE:
          VA = MRB_STR_AREF(MRB, VA, VB, MRB_UNDEF_VALUE());
          REGS[A] = VA;
          BREAK;
        DEFAULT:
          GOTO GETIDX_FALLBACK;
        }
        BREAK;
      DEFAULT:
      GETIDX_FALLBACK:
        MID = MRB_OPSYM(AREF);
        GOTO L_SEND_SYM;
      }
      NEXT;
    }

    CASE(OP_SETIDX, B) {
      C = 2;
      MID = MRB_OPSYM(ASET);
      SET_NIL_VALUE(REGS[A+3]);
      GOTO L_SENDB_SYM;
    }

    CASE(OP_GETCONST, BB) {
      MRB_VALUE V = MRB_VM_CONST_GET(MRB, SYMS[B]);
      REGS[A] = V;
      NEXT;
    }

    CASE(OP_SETCONST, BB) {
      MRB_VM_CONST_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETMCNST, BB) {
      MRB_VALUE V = MRB_CONST_GET(MRB, REGS[A], SYMS[B]);
      REGS[A] = V;
      NEXT;
    }

    CASE(OP_SETMCNST, BB) {
      MRB_CONST_SET(MRB, REGS[A+1], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETUPVAR, BBB) {
      MRB_VALUE *REGS_A = REGS + A;
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E && B < MRB_ENV_LEN(E)) {
        *REGS_A = E->STACK[B];
      }
      ELSE {
        *REGS_A = MRB_NIL_VALUE();
      }
      NEXT;
    }

    CASE(OP_SETUPVAR, BBB) {
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E) {
        MRB_VALUE *REGS_A = REGS + A;

        IF (B < MRB_ENV_LEN(E)) {
          E->STACK[B] = *REGS_A;
          MRB_WRITE_BARRIER(MRB, (STRUCT RBASIC*)E);
        }
      }
      NEXT;
    }

    CASE(OP_JMP, S) {
      PC += (INT16_T)A;
      JUMP;
    }
    CASE(OP_JMPIF, BS) {
      IF (MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNOT, BS) {
      IF (!MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNIL, BS) {
      IF (MRB_NIL_P(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }

    CASE(OP_JMPUW, S) {
      A = (UINT32_T)((PC - IREP->ISEQ) + (INT16_T)A);
      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {
        STRUCT RBREAK *BRK = (STRUCT RBREAK*)MRB->EXC;
        MRB_VALUE TARGET = MRB_BREAK_VALUE_GET(BRK);
        MRB_ASSERT(MRB_INTEGER_P(TARGET));
        A = (UINT32_T)MRB_INTEGER(TARGET);
        MRB_ASSERT(A >= 0 && A < IREP->ILEN);
      }
      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {
        CH = CATCH_HANDLER_FIND(MRB, MRB->C->CI, PC, MRB_CATCH_FILTER_ENSURE);
        IF (CH) {
          /* AVOIDING A JUMP FROM A CATCH HANDLER INTO THE SAME HANDLER */
          IF (A < MRB_IREP_CATCH_HANDLER_UNPACK(CH->BEGIN) || A >= MRB_IREP_CATCH_HANDLER_UNPACK(CH->END)) {
            THROW_TAGGED_BREAK(MRB, RBREAK_TAG_JUMP, PROC, MRB_FIXNUM_VALUE(A));
          }
        }
      }
      CHECKPOINT_END(RBREAK_TAG_JUMP);

      MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
      PC = IREP->ISEQ + A;
      JUMP;
    }

    CASE(OP_EXCEPT, B) {
      MRB_VALUE EXC;

      IF (MRB->EXC == NULL) {
        EXC = MRB_NIL_VALUE();
      }
      ELSE {
        SWITCH (MRB->EXC->TT) {
        CASE MRB_TT_BREAK:
        CASE MRB_TT_EXCEPTION:
          EXC = MRB_OBJ_VALUE(MRB->EXC);
          BREAK;
        DEFAULT:
          MRB_ASSERT(!"BAD MRB_TYPE");
          EXC = MRB_NIL_VALUE();
          BREAK;
        }
        MRB->EXC = NULL;
      }
      REGS[A] = EXC;
      NEXT;
    }
    CASE(OP_RESCUE, BB) {
      MRB_VALUE EXC = REGS[A];  /* EXC ON STACK */
      MRB_VALUE E = REGS[B];
      STRUCT RCLASS *EC;

      SWITCH (MRB_TYPE(E)) {
      CASE MRB_TT_CLASS:
      CASE MRB_TT_MODULE:
        BREAK;
      DEFAULT:
        {
          MRB_VALUE EXC;

          EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                    "CLASS OR MODULE REQUIRED FOR RESCUE CLAUSE");
          MRB_EXC_SET(MRB, EXC);
          GOTO L_RAISE;
        }
      }
      EC = MRB_CLASS_PTR(E);
      REGS[B] = MRB_BOOL_VALUE(MRB_OBJ_IS_KIND_OF(MRB, EXC, EC));
      NEXT;
    }

    CASE(OP_RAISEIF, B) {
      MRB_VALUE EXC = REGS[A];
      IF (MRB_BREAK_P(EXC)) {
        MRB->EXC = MRB_OBJ_PTR(EXC);
        GOTO L_BREAK;
      }
      MRB_EXC_SET(MRB, EXC);
      IF (MRB->EXC) {
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_SSEND, BBB) {
      REGS[A] = REGS[0];
      INSN = OP_SEND;
    }
    GOTO L_SENDB;

    CASE(OP_SSENDB, BBB) {
      REGS[A] = REGS[0];
    }
    GOTO L_SENDB;

    CASE(OP_SEND, BBB)
    GOTO L_SENDB;

    L_SEND_SYM:
    C = 1;
    /* PUSH NIL AFTER ARGUMENTS */
    SET_NIL_VALUE(REGS[A+2]);
    GOTO L_SENDB_SYM;

    CASE(OP_SENDB, BBB)
    L_SENDB:
    MID = SYMS[B];
    L_SENDB_SYM:
    {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_VALUE RECV, BLK;

      ARGUMENT_NORMALIZE(A, &C, INSN);

      RECV = REGS[A];
      CLS = MRB_CLASS(MRB, RECV);
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &C, BLK, 0);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, C);

      IF (MRB_METHOD_CFUNC_P(M)) {
        IF (MRB_METHOD_PROC_P(M)) {
          STRUCT RPROC *P = MRB_METHOD_PROC(M);

          MRB_VM_CI_PROC_SET(CI, P);
          RECV = P->BODY.FUNC(MRB, RECV);
        }
        ELSE {
          IF (MRB_METHOD_NOARG_P(M)) {
            CHECK_METHOD_NOARG(MRB, CI);
          }
          RECV = MRB_METHOD_FUNC(M)(MRB, RECV);
        }
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);
          IF (P && !MRB_PROC_STRICT_P(P) && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
        IF (!CI->U.TARGET_CLASS) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN RECV;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        CI->STACK[0] = RECV;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
    }
    JUMP;

    CASE(OP_CALL, Z) {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV = CI->STACK[0];
      STRUCT RPROC *M = MRB_PROC_PTR(RECV);

      /* REPLACE CALLINFO */
      CI->U.TARGET_CLASS = MRB_PROC_TARGET_CLASS(M);
      MRB_VM_CI_PROC_SET(CI, M);
      IF (MRB_PROC_ENV_P(M)) {
        CI->MID = MRB_PROC_ENV(M)->MID;
      }

      /* PREPARE STACK */
      IF (MRB_PROC_CFUNC_P(M)) {
        RECV = MRB_PROC_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
        CI[1].STACK[0] = RECV;
        IREP = MRB->C->CI->PROC->BODY.IREP;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        PROC = M;
        IREP = M->BODY.IREP;
        IF (!IREP) {
          MRB->C->CI->STACK[0] = MRB_NIL_VALUE();
          A = 0;
          C = OP_R_NORMAL;
          GOTO L_OP_RETURN_BODY;
        }
        MRB_INT NARGS = MRB_CI_BIDX(CI)+1;
        IF (NARGS < IREP->NREGS) {
          MRB_STACK_EXTEND(MRB, IREP->NREGS);
          STACK_CLEAR(REGS+NARGS, IREP->NREGS-NARGS);
        }
        IF (MRB_PROC_ENV_P(M)) {
          REGS[0] = MRB_PROC_ENV(M)->STACK[0];
        }
        PC = IREP->ISEQ;
      }
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      JUMP;
    }

    CASE(OP_SUPER, BB) {
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV, BLK;
      CONST STRUCT RPROC *P = CI->PROC;
      MRB_SYM MID = CI->MID;
      STRUCT RCLASS* TARGET_CLASS = MRB_PROC_TARGET_CLASS(P);

      IF (MRB_PROC_ENV_P(P) && P->E.ENV->MID && P->E.ENV->MID != MID) { /* ALIAS SUPPORT */
        MID = P->E.ENV->MID;    /* RESTORE OLD MID */
      }

      IF (MID == 0 || !TARGET_CLASS) {
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (TARGET_CLASS->FLAGS & MRB_FL_CLASS_IS_PREPENDED) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
      }
      ELSE IF (TARGET_CLASS->TT == MRB_TT_MODULE) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
        IF (!TARGET_CLASS || TARGET_CLASS->TT != MRB_TT_ICLASS) {
          GOTO SUPER_TYPEERROR;
        }
      }
      RECV = REGS[0];
      IF (!MRB_OBJ_IS_KIND_OF(MRB, RECV, TARGET_CLASS)) {
      SUPER_TYPEERROR: ;
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                            "SELF HAS WRONG TYPE TO CALL SUPER IN THIS CONTEXT");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }

      ARGUMENT_NORMALIZE(A, &B, OP_SUPER);

      CLS = TARGET_CLASS->SUPER;
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &B, BLK, 1);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, B);

      /* PREPARE STACK */
      CI->STACK[0] = RECV;

      IF (MRB_METHOD_CFUNC_P(M)) {
        MRB_VALUE V;

        IF (MRB_METHOD_PROC_P(M)) {
          MRB_VM_CI_PROC_SET(CI, MRB_METHOD_PROC(M));
        }
        V = MRB_METHOD_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_RESTORE(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        MRB_ASSERT(!MRB_BREAK_P(V));
        IF (!MRB_VM_CI_TARGET_CLASS(CI)) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN V;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        MRB->C->CI->STACK[0] = V;
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
      JUMP;
    }

    CASE(OP_ARGARY, BS) {
      MRB_INT M1 = (B>>11)&0X3F;
      MRB_INT R  = (B>>10)&0X1;
      MRB_INT M2 = (B>>5)&0X1F;
      MRB_INT KD = (B>>4)&0X1;
      MRB_INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (MRB->C->CI->MID == 0 || MRB_VM_CI_TARGET_CLASS(MRB->C->CI) == NULL) {
        MRB_VALUE EXC;

      L_NOSUPER:
        EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E) GOTO L_NOSUPER;
        IF (MRB_ENV_LEN(E) <= M1+R+M2+1)
          GOTO L_NOSUPER;
        STACK = E->STACK + 1;
      }
      IF (R == 0) {
        REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, M1+M2, STACK);
      }
      ELSE {
        MRB_VALUE *PP = NULL;
        STRUCT RARRAY *REST;
        MRB_INT LEN = 0;

        IF (MRB_ARRAY_P(STACK[M1])) {
          STRUCT RARRAY *ARY = MRB_ARY_PTR(STACK[M1]);

          PP = ARY_PTR(ARY);
          LEN = ARY_LEN(ARY);
        }
        REGS[A] = MRB_ARY_NEW_CAPA(MRB, M1+LEN+M2);
        REST = MRB_ARY_PTR(REGS[A]);
        IF (M1 > 0) {
          STACK_COPY(ARY_PTR(REST), STACK, M1);
        }
        IF (LEN > 0) {
          STACK_COPY(ARY_PTR(REST)+M1, PP, LEN);
        }
        IF (M2 > 0) {
          STACK_COPY(ARY_PTR(REST)+M1+LEN, STACK+M1+1, M2);
        }
        ARY_SET_LEN(REST, M1+LEN+M2);
      }
      IF (KD) {
        REGS[A+1] = STACK[M1+R+M2];
        REGS[A+2] = STACK[M1+R+M2+1];
      }
      ELSE {
        REGS[A+1] = STACK[M1+R+M2];
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ENTER, W) {
      MRB_INT M1 = MRB_ASPEC_REQ(A);
      MRB_INT O  = MRB_ASPEC_OPT(A);
      MRB_INT R  = MRB_ASPEC_REST(A);
      MRB_INT M2 = MRB_ASPEC_POST(A);
      MRB_INT KD = (MRB_ASPEC_KEY(A) > 0 || MRB_ASPEC_KDICT(A))? 1 : 0;
      /* UNUSED
      INT B  = MRB_ASPEC_BLOCK(A);
      */
      MRB_INT CONST LEN = M1 + O + R + M2;

      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_INT ARGC = CI->N;
      MRB_VALUE *ARGV = REGS+1;
      MRB_VALUE * CONST ARGV0 = ARGV;
      MRB_INT CONST KW_POS = LEN + KD;    /* WHERE KWHASH SHOULD BE */
      MRB_INT CONST BLK_POS = KW_POS + 1; /* WHERE BLOCK SHOULD BE */
      MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];
      MRB_VALUE KDICT = MRB_NIL_VALUE();

      /* KEYWORD ARGUMENTS */
      IF (CI->NK > 0) {
        MRB_INT KIDX = MRB_CI_KIDX(CI);
        KDICT = REGS[KIDX];
        IF (!MRB_HASH_P(KDICT) || MRB_HASH_SIZE(MRB, KDICT) == 0) {
          KDICT = MRB_NIL_VALUE();
          CI->NK = 0;
        }
      }
      IF (!KD && !MRB_NIL_P(KDICT)) {
        IF (ARGC < 14) {
          CI->N++;
          ARGC++;    /* INCLUDE KDICT IN NORMAL ARGUMENTS */
        }
        ELSE IF (ARGC == 14) {
          /* PACK ARGUMENTS AND KDICT */
          REGS[1] = MRB_ARY_NEW_FROM_VALUES(MRB, ARGC+1, &REGS[1]);
          ARGC = CI->N = 15;
        }
        ELSE {/* ARGC == 15 */
          /* PUSH KDICT TO PACKED ARGUMENTS */
          MRB_ARY_PUSH(MRB, REGS[1], REGS[2]);
        }
        CI->NK = 0;
      }
      IF (KD && MRB_ASPEC_KEY(A) > 0 && MRB_HASH_P(KDICT)) {
        KDICT = MRB_HASH_DUP(MRB, KDICT);
      }

      /* ARGUMENTS IS PASSED WITH ARRAY */
      IF (ARGC == 15) {
        STRUCT RARRAY *ARY = MRB_ARY_PTR(REGS[1]);
        ARGV = ARY_PTR(ARY);
        ARGC = (INT)ARY_LEN(ARY);
        MRB_GC_PROTECT(MRB, REGS[1]);
      }

      /* STRICT ARGUMENT CHECK */
      IF (CI->PROC && MRB_PROC_STRICT_P(CI->PROC)) {
        IF (ARGC < M1 + M2 || (R == 0 && ARGC > LEN)) {
          ARGNUM_ERROR(MRB, M1+M2);
          GOTO L_RAISE;
        }
      }
      /* EXTRACT FIRST ARGUMENT ARRAY TO ARGUMENTS */
      ELSE IF (LEN > 1 && ARGC == 1 && MRB_ARRAY_P(ARGV[0])) {
        MRB_GC_PROTECT(MRB, ARGV[0]);
        ARGC = (INT)RARRAY_LEN(ARGV[0]);
        ARGV = RARRAY_PTR(ARGV[0]);
      }

      /* REST ARGUMENTS */
      MRB_VALUE REST = MRB_NIL_VALUE();
      IF (ARGC < LEN) {
        MRB_INT MLEN = M2;
        IF (ARGC < M1+M2) {
          MLEN = M1 < ARGC ? ARGC - M1 : 0;
        }

        /* COPY MANDATORY AND OPTIONAL ARGUMENTS */
        IF (ARGV0 != ARGV && ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, ARGC-MLEN); /* M1 + O */
        }
        IF (ARGC < M1) {
          STACK_CLEAR(&REGS[ARGC+1], M1-ARGC);
        }
        /* COPY POST MANDATORY ARGUMENTS */
        IF (MLEN) {
          VALUE_MOVE(&REGS[LEN-M2+1], &ARGV[ARGC-MLEN], MLEN);
        }
        IF (MLEN < M2) {
          STACK_CLEAR(&REGS[LEN-M2+MLEN+1], M2-MLEN);
        }
        /* INITIALIZE REST ARGUMENTS WITH EMPTY ARRAY */
        IF (R) {
          REST = MRB_ARY_NEW_CAPA(MRB, 0);
          REGS[M1+O+1] = REST;
        }
        /* SKIP INITIALIZER OF PASSED ARGUMENTS */
        IF (O > 0 && ARGC > M1+M2)
          PC += (ARGC - M1 - M2)*3;
      }
      ELSE {
        MRB_INT RNUM = 0;
        IF (ARGV0 != ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, M1+O);
        }
        IF (R) {
          RNUM = ARGC-M1-O-M2;
          REST = MRB_ARY_NEW_FROM_VALUES(MRB, RNUM, ARGV+M1+O);
          REGS[M1+O+1] = REST;
        }
        IF (M2 > 0 && ARGC-M2 > M1) {
          VALUE_MOVE(&REGS[M1+O+R+1], &ARGV[M1+O+RNUM], M2);
        }
        PC += O*3;
      }

      /* NEED TO BE UPDATE BLK FIRST TO PROTECT BLK FROM GC */
      REGS[BLK_POS] = BLK;              /* MOVE BLOCK */
      IF (KD) {
        IF (MRB_NIL_P(KDICT))
          KDICT = MRB_HASH_NEW_CAPA(MRB, 0);
        REGS[KW_POS] = KDICT;           /* SET KWHASH */
      }

      /* FORMAT ARGUMENTS FOR GENERATED CODE */
      MRB->C->CI->N = LEN;

      /* CLEAR LOCAL (BUT NON-ARGUMENT) VARIABLES */
      IF (IREP->NLOCALS-BLK_POS-1 > 0) {
        STACK_CLEAR(&REGS[BLK_POS+1], IREP->NLOCALS-BLK_POS-1);
      }
      JUMP;
    }

    CASE(OP_KARG, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT, V;

      IF (KIDX < 0 || !MRB_HASH_P(KDICT=REGS[KIDX]) || !MRB_HASH_KEY_P(MRB, KDICT, K)) {
        MRB_VALUE STR = MRB_FORMAT(MRB, "MISSING KEYWORD: %V", K);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      V = MRB_HASH_GET(MRB, KDICT, K);
      REGS[A] = V;
      MRB_HASH_DELETE_KEY(MRB, KDICT, K);
      NEXT;
    }

    CASE(OP_KEY_P, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;
      MRB_BOOL KEY_P = FALSE;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX])) {
        KEY_P = MRB_HASH_KEY_P(MRB, KDICT, K);
      }
      REGS[A] = MRB_BOOL_VALUE(KEY_P);
      NEXT;
    }

    CASE(OP_KEYEND, Z) {
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX]) && !MRB_HASH_EMPTY_P(MRB, KDICT)) {
        MRB_VALUE KEYS = MRB_HASH_KEYS(MRB, KDICT);
        MRB_VALUE KEY1 = RARRAY_PTR(KEYS)[0];
        MRB_VALUE STR = MRB_FORMAT(MRB, "UNKNOWN KEYWORD: %V", KEY1);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_BREAK, B) {
      C = OP_R_BREAK;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN_BLK, B) {
      C = OP_R_RETURN;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN, B)
    C = OP_R_NORMAL;
    L_RETURN:
    {
      MRB_CALLINFO *CI;

      CI = MRB->C->CI;
      IF (CI->MID) {
        MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];

        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);

          IF (!MRB_PROC_STRICT_P(P) &&
              CI > MRB->C->CIBASE && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
      }

      IF (MRB->EXC) {
      L_RAISE:
        CI = MRB->C->CI;
        IF (CI == MRB->C->CIBASE) {
          CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
          IF (CH == NULL) GOTO L_FTOP;
          GOTO L_CATCH;
        }
        WHILE ((CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL)) == NULL) {
          CI = CIPOP(MRB);
          IF (CI[1].CCI == CINFO_SKIP && PREV_JMP) {
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          PC = CI[0].PC;
          IF (CI == MRB->C->CIBASE) {
            CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
            IF (CH == NULL) {
            L_FTOP:             /* FIBER TOP */
              IF (MRB->C == MRB->ROOT_C) {
                MRB->C->CI->STACK = MRB->C->STBASE;
                GOTO L_STOP;
              }
              ELSE {
                STRUCT MRB_CONTEXT *C = MRB->C;

                C->STATUS = MRB_FIBER_TERMINATED;
                MRB->C = C->PREV;
                C->PREV = NULL;
                GOTO L_RAISE;
              }
            }
            BREAK;
          }
        }
      L_CATCH:
        IF (CH == NULL) GOTO L_STOP;
        IF (FALSE) {
        L_CATCH_TAGGED_BREAK: /* FROM THROW_TAGGED_BREAK() OR UNWIND_ENSURE() */
          CI = MRB->C->CI;
        }
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, IREP->NREGS);
        PC = IREP->ISEQ + MRB_IREP_CATCH_HANDLER_UNPACK(CH->TARGET);
      }
      ELSE {
        MRB_INT ACC;
        MRB_VALUE V;

        CI = MRB->C->CI;
        V = REGS[A];
        MRB_GC_PROTECT(MRB, V);
        SWITCH (C) {
        CASE OP_R_RETURN:
          /* FALL THROUGH TO OP_R_NORMAL OTHERWISE */
          IF (CI->CCI == CINFO_NONE && MRB_PROC_ENV_P(PROC) && !MRB_PROC_STRICT_P(PROC)) {
            CONST STRUCT RPROC *DST;
            MRB_CALLINFO *CIBASE;
            CIBASE = MRB->C->CIBASE;
            DST = TOP_PROC(MRB, PROC);

            IF (MRB_PROC_ENV_P(DST)) {
              STRUCT RENV *E = MRB_PROC_ENV(DST);

              IF (!MRB_ENV_ONSTACK_P(E) || (E->CXT && E->CXT != MRB->C)) {
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
            }
            /* CHECK JUMP DESTINATION */
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              IF (CI->CCI > CINFO_NONE) { /* JUMP CROSS C BOUNDARY */
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
              CI--;
            }
            IF (CI <= CIBASE) { /* NO JUMP DESTINATION */
              LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
              GOTO L_RAISE;
            }
            CI = MRB->C->CI;
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {
                CIBASE = MRB->C->CIBASE;
                DST = TOP_PROC(MRB, PROC);
              }
              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {
                UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_BLOCK, PROC, V);
              }
              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);
              CI = CIPOP(MRB);
              PC = CI->PC;
            }
            PROC = CI->PROC;
            MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
            BREAK;
          }
          /* FALLTHROUGH */
        CASE OP_R_NORMAL:
        NORMAL_RETURN:
          IF (CI == MRB->C->CIBASE) {
            STRUCT MRB_CONTEXT *C;
            C = MRB->C;

            IF (!C->PREV) { /* TOPLEVEL RETURN */
              REGS[IREP->NLOCALS] = V;
              GOTO CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);
            }
            IF (!C->VMEXEC && C->PREV->CI == C->PREV->CIBASE) {
              MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_FIBER_ERROR, "DOUBLE RESUME");
              MRB_EXC_SET(MRB, EXC);
              GOTO L_RAISE;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {
              C = MRB->C;
            }
            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_TOPLEVEL, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);
            /* AUTOMATIC YIELD AT THE END */
            C->STATUS = MRB_FIBER_TERMINATED;
            MRB->C = C->PREV;
            MRB->C->STATUS = MRB_FIBER_RUNNING;
            C->PREV = NULL;
            IF (C->VMEXEC) {
              MRB_GC_ARENA_RESTORE(MRB, AI);
              C->VMEXEC = FALSE;
              MRB->JMP = PREV_JMP;
              RETURN V;
            }
            CI = MRB->C->CI;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_RETURN);
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        CASE OP_R_BREAK:
          IF (MRB_PROC_STRICT_P(PROC)) GOTO NORMAL_RETURN;
          IF (MRB_PROC_ORPHAN_P(PROC)) {
            MRB_VALUE EXC;

          L_BREAK_ERROR:
            EXC = MRB_EXC_NEW_LIT(MRB, E_LOCALJUMP_ERROR,
                                      "BREAK FROM PROC-CLOSURE");
            MRB_EXC_SET(MRB, EXC);
            GOTO L_RAISE;
          }
          IF (!MRB_PROC_ENV_P(PROC) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(PROC))) {
            GOTO L_BREAK_ERROR;
          }
          ELSE {
            STRUCT RENV *E = MRB_PROC_ENV(PROC);

            IF (E->CXT != MRB->C) {
              GOTO L_BREAK_ERROR;
            }
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK);
          /* BREAK FROM FIBER BLOCK */
          IF (CI == MRB->C->CIBASE && CI->PC) {
            STRUCT MRB_CONTEXT *C = MRB->C;

            MRB->C = C->PREV;
            C->PREV = NULL;
            CI = MRB->C->CI;
          }
          IF (CI->CCI > CINFO_NONE) {
            CI = CIPOP(MRB);
            MRB_GC_ARENA_RESTORE(MRB, AI);
            MRB->C->VMEXEC = FALSE;
            MRB->EXC = (STRUCT ROBJECT*)BREAK_NEW(MRB, RBREAK_TAG_BREAK, PROC, V);
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          IF (FALSE) {
            STRUCT RBREAK *BRK;

          L_BREAK:
            BRK = (STRUCT RBREAK*)MRB->EXC;
            PROC = MRB_BREAK_PROC_GET(BRK);
            V = MRB_BREAK_VALUE_GET(BRK);
            CI = MRB->C->CI;

            SWITCH (MRB_BREAK_TAG_GET(BRK)) {
#DEFINE DISPATCH_CHECKPOINTS(N, I) CASE N: GOTO CHECKPOINT_LABEL_MAKE(N);
              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)
#UNDEF DISPATCH_CHECKPOINTS
              DEFAULT:
                MRB_ASSERT(!"WRONG BREAK TAG");
            }
          }
          WHILE (MRB->C->CIBASE < CI && CI[-1].PROC != PROC->UPPER) {
            IF (CI[-1].CCI == CINFO_SKIP) {
              GOTO L_BREAK_ERROR;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {
              /* DO NOTHING */
            }
            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_UPPER, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);
            CI = CIPOP(MRB);
            PC = CI->PC;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_INTARGET, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);
          IF (CI == MRB->C->CIBASE) {
            GOTO L_BREAK_ERROR;
          }
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        DEFAULT:
          /* CANNOT HAPPEN */
          BREAK;
        }
        MRB_ASSERT(CI == MRB->C->CI);
        MRB_ASSERT(MRB->EXC == NULL);

        IF (MRB->C->VMEXEC && !MRB_VM_CI_TARGET_CLASS(CI)) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->C->VMEXEC = FALSE;
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        ACC = CI->CCI;
        CI = CIPOP(MRB);
        IF (ACC == CINFO_SKIP || ACC == CINFO_DIRECT) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        PC = CI->PC;
        DEBUG(FPRINTF(STDERR, "FROM :%S\N", MRB_SYM_NAME(MRB, CI->MID)));
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;

        CI[1].STACK[0] = V;
        MRB_GC_ARENA_RESTORE(MRB, AI);
      }
      JUMP;
    }

    CASE(OP_BLKPUSH, BS) {
      INT M1 = (B>>11)&0X3F;
      INT R  = (B>>10)&0X1;
      INT M2 = (B>>5)&0X1F;
      INT KD = (B>>4)&0X1;
      INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E || (!MRB_ENV_ONSTACK_P(E) && E->MID == 0) ||
            MRB_ENV_LEN(E) <= M1+R+M2+1) {
          LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
          GOTO L_RAISE;
        }
        STACK = E->STACK + 1;
      }
      IF (MRB_NIL_P(STACK[M1+R+M2+KD])) {
        LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
        GOTO L_RAISE;
      }
      REGS[A] = STACK[M1+R+M2+KD];
      NEXT;
    }

  L_INT_OVERFLOW:
    {
      MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_RANGE_ERROR, "INTEGER OVERFLOW");
      MRB_EXC_SET(MRB, EXC);
    }
    GOTO L_RAISE;

#DEFINE TYPES2(A,B) ((((UINT16_T)(A))<<8)|(((UINT16_T)(B))&0XFF))
#DEFINE OP_MATH(OP_NAME)                                                    \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {                  \
    OP_MATH_CASE_INTEGER(OP_NAME);                                          \
    OP_MATH_CASE_FLOAT(OP_NAME, INTEGER, FLOAT);                            \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  INTEGER);                           \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  FLOAT);                             \
    OP_MATH_CASE_STRING_##OP_NAME();                                        \
    DEFAULT:                                                                \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATH_CASE_INTEGER(OP_NAME)                                       \
  CASE TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = MRB_INTEGER(REGS[A+1]), Z;      \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z))                           \
        OP_MATH_OVERFLOW_INT();                                             \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2) (VOID)0
#ELSE
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2)                                     \
  CASE TYPES2(OP_MATH_TT_##T1, OP_MATH_TT_##T2):                                \
    {                                                                           \
      MRB_FLOAT Z = MRB_##T1(REGS[A]) OP_MATH_OP_##OP_NAME MRB_##T2(REGS[A+1]); \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                         \
    }                                                                           \
    BREAK
#ENDIF
#DEFINE OP_MATH_OVERFLOW_INT() GOTO L_INT_OVERFLOW
#DEFINE OP_MATH_CASE_STRING_ADD()                                           \
  CASE TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \
    REGS[A] = MRB_STR_PLUS(MRB, REGS[A], REGS[A+1]);                        \
    MRB_GC_ARENA_RESTORE(MRB, AI);                                          \
    BREAK
#DEFINE OP_MATH_CASE_STRING_SUB() (VOID)0
#DEFINE OP_MATH_CASE_STRING_MUL() (VOID)0
#DEFINE OP_MATH_OP_ADD +
#DEFINE OP_MATH_OP_SUB -
#DEFINE OP_MATH_OP_MUL *
#DEFINE OP_MATH_TT_INTEGER MRB_TT_INTEGER
#DEFINE OP_MATH_TT_FLOAT   MRB_TT_FLOAT

    CASE(OP_ADD, B) {
      OP_MATH(ADD);
    }

    CASE(OP_SUB, B) {
      OP_MATH(SUB);
    }

    CASE(OP_MUL, B) {
      OP_MATH(MUL);
    }

    CASE(OP_DIV, B) {
#IFNDEF MRB_NO_FLOAT
      MRB_FLOAT X, Y, F;
#ENDIF

      /* NEED TO CHECK IF OP IS OVERRIDDEN */
      SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):
        {
          MRB_INT X = MRB_INTEGER(REGS[A]);
          MRB_INT Y = MRB_INTEGER(REGS[A+1]);
          MRB_INT DIV = MRB_DIV_INT(MRB, X, Y);
          SET_INT_VALUE(MRB, REGS[A], DIV);
        }
        NEXT;
#IFNDEF MRB_NO_FLOAT
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):
        X = (MRB_FLOAT)MRB_INTEGER(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):
        X = MRB_FLOAT(REGS[A]);
        Y = (MRB_FLOAT)MRB_INTEGER(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
        X = MRB_FLOAT(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
#ENDIF
      DEFAULT:
        MID = MRB_OPSYM(DIV);
        GOTO L_SEND_SYM;
      }

#IFNDEF MRB_NO_FLOAT
      F = MRB_DIV_FLOAT(X, Y);
      SET_FLOAT_VALUE(MRB, REGS[A], F);
#ENDIF
      NEXT;
    }

#DEFINE OP_MATHI(OP_NAME)                                                   \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (MRB_TYPE(REGS[A])) {                                              \
    OP_MATHI_CASE_INTEGER(OP_NAME);                                         \
    OP_MATHI_CASE_FLOAT(OP_NAME);                                           \
    DEFAULT:                                                                \
      SET_INT_VALUE(MRB,REGS[A+1], B);                                      \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATHI_CASE_INTEGER(OP_NAME)                                      \
  CASE MRB_TT_INTEGER:                                                      \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = (MRB_INT)B, Z;                  \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z))                           \
        OP_MATH_OVERFLOW_INT();                                             \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME) (VOID)0
#ELSE
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME)                                        \
  CASE MRB_TT_FLOAT:                                                        \
    {                                                                       \
      MRB_FLOAT Z = MRB_FLOAT(REGS[A]) OP_MATH_OP_##OP_NAME B;              \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                     \
    }                                                                       \
    BREAK
#ENDIF

    CASE(OP_ADDI, BB) {
      OP_MATHI(ADD);
    }

    CASE(OP_SUBI, BB) {
      OP_MATHI(SUB);
    }

#DEFINE OP_CMP_BODY(OP,V1,V2) (V1(REGS[A]) OP V2(REGS[A+1]))

#IFDEF MRB_NO_FLOAT
#DEFINE OP_CMP(OP,SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ELSE
#DEFINE OP_CMP(OP, SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FLOAT);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FLOAT);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ENDIF

    CASE(OP_EQ, B) {
      IF (MRB_OBJ_EQ(MRB, REGS[A], REGS[A+1])) {
        SET_TRUE_VALUE(REGS[A]);
      }
      ELSE {
        OP_CMP(==,EQ);
      }
      NEXT;
    }

    CASE(OP_LT, B) {
      OP_CMP(<,LT);
      NEXT;
    }

    CASE(OP_LE, B) {
      OP_CMP(<=,LE);
      NEXT;
    }

    CASE(OP_GT, B) {
      OP_CMP(>,GT);
      NEXT;
    }

    CASE(OP_GE, B) {
      OP_CMP(>=,GE);
      NEXT;
    }

    CASE(OP_ARRAY, BB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, B, &REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_ARRAY2, BBB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, C, &REGS[B]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYCAT, B) {
      MRB_VALUE SPLAT = MRB_ARY_SPLAT(MRB, REGS[A+1]);
      IF (MRB_NIL_P(REGS[A])) {
        REGS[A] = SPLAT;
      }
      ELSE {
        MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
        MRB_ARY_CONCAT(MRB, REGS[A], SPLAT);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYPUSH, BB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      FOR (MRB_INT I=0; I<B; I++) {
        MRB_ARY_PUSH(MRB, REGS[A], REGS[A+I+1]);
      }
      NEXT;
    }

    CASE(OP_ARYDUP, B) {
      MRB_VALUE ARY = REGS[A];
      IF (MRB_ARRAY_P(ARY)) {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, RARRAY_LEN(ARY), RARRAY_PTR(ARY));
      }
      ELSE {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &ARY);
      }
      REGS[A] = ARY;
      NEXT;
    }

    CASE(OP_AREF, BBB) {
      MRB_VALUE V = REGS[B];

      IF (!MRB_ARRAY_P(V)) {
        IF (C == 0) {
          REGS[A] = V;
        }
        ELSE {
          SET_NIL_VALUE(REGS[A]);
        }
      }
      ELSE {
        V = MRB_ARY_REF(MRB, V, C);
        REGS[A] = V;
      }
      NEXT;
    }

    CASE(OP_ASET, BBB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      MRB_ARY_SET(MRB, REGS[B], C, REGS[A]);
      NEXT;
    }

    CASE(OP_APOST, BBB) {
      MRB_VALUE V = REGS[A];
      INT PRE  = B;
      INT POST = C;
      STRUCT RARRAY *ARY;
      INT LEN, IDX;

      IF (!MRB_ARRAY_P(V)) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &REGS[A]);
      }
      ARY = MRB_ARY_PTR(V);
      LEN = (INT)ARY_LEN(ARY);
      IF (LEN > PRE + POST) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, LEN - PRE - POST, ARY_PTR(ARY)+PRE);
        REGS[A++] = V;
        WHILE (POST--) {
          REGS[A++] = ARY_PTR(ARY)[LEN-POST-1];
        }
      }
      ELSE {
        V = MRB_ARY_NEW_CAPA(MRB, 0);
        REGS[A++] = V;
        FOR (IDX=0; IDX+PRE<LEN; IDX++) {
          REGS[A+IDX] = ARY_PTR(ARY)[PRE+IDX];
        }
        WHILE (IDX < POST) {
          SET_NIL_VALUE(REGS[A+IDX]);
          IDX++;
        }
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_INTERN, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_SYM SYM = MRB_INTERN_STR(MRB, REGS[A]);
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_SYMBOL, BB) {
      SIZE_T LEN;
      MRB_SYM SYM;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        SYM = MRB_INTERN_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        SYM  = MRB_INTERN(MRB, POOL[B].U.STR, LEN);
      }
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_STRING, BB) {
      MRB_INT LEN;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        REGS[A] = MRB_STR_NEW_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        REGS[A] = MRB_STR_NEW(MRB, POOL[B].U.STR, LEN);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_STRCAT, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_STR_CONCAT(MRB, REGS[A], REGS[A+1]);
      NEXT;
    }

    CASE(OP_HASH, BB) {
      MRB_VALUE HASH = MRB_HASH_NEW_CAPA(MRB, B);
      INT I;
      INT LIM = A+B*2;

      FOR (I=A; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      REGS[A] = HASH;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_HASHADD, BB) {
      MRB_VALUE HASH;
      INT I;
      INT LIM = A+B*2+1;

      HASH = REGS[A];
      MRB_ENSURE_HASH_TYPE(MRB, HASH);
      FOR (I=A+1; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_HASHCAT, B) {
      MRB_VALUE HASH = REGS[A];

      MRB_ASSERT(MRB_HASH_P(HASH));
      MRB_HASH_MERGE(MRB, HASH, REGS[A+1]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_LAMBDA, BB)
    C = OP_L_LAMBDA;
    L_MAKE_LAMBDA:
    {
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      IF (C & OP_L_CAPTURE) {
        P = MRB_CLOSURE_NEW(MRB, NIREP);
      }
      ELSE {
        P = MRB_PROC_NEW(MRB, NIREP);
        P->FLAGS |= MRB_PROC_SCOPE;
      }
      IF (C & OP_L_STRICT) P->FLAGS |= MRB_PROC_STRICT;
      REGS[A] = MRB_OBJ_VALUE(P);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_BLOCK, BB) {
      C = OP_L_BLOCK;
      GOTO L_MAKE_LAMBDA;
    }
    CASE(OP_METHOD, BB) {
      C = OP_L_METHOD;
      GOTO L_MAKE_LAMBDA;
    }

    CASE(OP_RANGE_INC, B) {
      MRB_VALUE V = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], FALSE);
      REGS[A] = V;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      MRB_VALUE V = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], TRUE);
      REGS[A] = V;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_OCLASS, B) {
      REGS[A] = MRB_OBJ_VALUE(MRB->OBJECT_CLASS);
      NEXT;
    }

    CASE(OP_CLASS, BB) {
      STRUCT RCLASS *C = 0, *BASECLASS;
      MRB_VALUE BASE, SUPER;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      SUPER = REGS[A+1];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      C = MRB_VM_DEFINE_CLASS(MRB, BASE, SUPER, ID);
      REGS[A] = MRB_OBJ_VALUE(C);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_MODULE, BB) {
      STRUCT RCLASS *CLS = 0, *BASECLASS;
      MRB_VALUE BASE;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      CLS = MRB_VM_DEFINE_MODULE(MRB, BASE, ID);
      REGS[A] = MRB_OBJ_VALUE(CLS);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_EXEC, BB)
    {
      MRB_VALUE RECV = REGS[A];
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      /* PREPARE CLOSURE */
      P = MRB_PROC_NEW(MRB, NIREP);
      P->C = NULL;
      MRB_FIELD_WRITE_BARRIER(MRB, (STRUCT RBASIC*)P, (STRUCT RBASIC*)PROC);
      MRB_PROC_SET_TARGET_CLASS(P, MRB_CLASS_PTR(RECV));
      P->FLAGS |= MRB_PROC_SCOPE;

      /* PREPARE CALL STACK */
      CIPUSH(MRB, A, 0, MRB_CLASS_PTR(RECV), P, 0, 0);

      IREP = P->BODY.IREP;
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      MRB_STACK_EXTEND(MRB, IREP->NREGS);
      STACK_CLEAR(REGS+1, IREP->NREGS-1);
      PC = IREP->ISEQ;
      JUMP;
    }

    CASE(OP_DEF, BB) {
      STRUCT RCLASS *TARGET = MRB_CLASS_PTR(REGS[A]);
      STRUCT RPROC *P = MRB_PROC_PTR(REGS[A+1]);
      MRB_METHOD_T M;
      MRB_SYM MID = SYMS[B];

      MRB_METHOD_FROM_PROC(M, P);
      MRB_DEFINE_METHOD_RAW(MRB, TARGET, MID, M);
      MRB_METHOD_ADDED(MRB, TARGET, MID);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      REGS[A] = MRB_SYMBOL_VALUE(MID);
      NEXT;
    }

    CASE(OP_SCLASS, B) {
      REGS[A] = MRB_SINGLETON_CLASS(MRB, REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_TCLASS, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);
      IF (!TARGET) GOTO L_RAISE;
      REGS[A] = MRB_OBJ_VALUE(TARGET);
      NEXT;
    }

    CASE(OP_ALIAS, BB) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_ALIAS_METHOD(MRB, TARGET, SYMS[A], SYMS[B]);
      MRB_METHOD_ADDED(MRB, TARGET, SYMS[A]);
      NEXT;
    }
    CASE(OP_UNDEF, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_UNDEF_METHOD_ID(MRB, TARGET, SYMS[A]);
      NEXT;
    }

    CASE(OP_DEBUG, Z) {
      FETCH_BBB();
#IFDEF MRB_USE_DEBUG_HOOK
      MRB->DEBUG_OP_HOOK(MRB, IREP, PC, REGS);
#ELSE
#IFNDEF MRB_NO_STDIO
      PRINTF("OP_DEBUG %D %D %D\N", A, B, C);
#ELSE
      ABORT();
#ENDIF
#ENDIF
      NEXT;
    }

    CASE(OP_ERR, B) {
      SIZE_T LEN = POOL[A].TT >> 2;
      MRB_VALUE EXC;

      MRB_ASSERT((POOL[A].TT&IREP_TT_NFLAG)==0);
      EXC = MRB_EXC_NEW(MRB, E_LOCALJUMP_ERROR, POOL[A].U.STR, LEN);
      MRB_EXC_SET(MRB, EXC);
      GOTO L_RAISE;
    }

    CASE(OP_EXT1, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _1(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT2, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _2(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT3, Z) {
      UINT8_T INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _3(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }

    CASE(OP_STOP, Z) {
      /*        STOP VM */
      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {
        /* DO NOTHING */
      }
      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {
        UNWIND_ENSURE(MRB, MRB->C->CI, PC, RBREAK_TAG_STOP, PROC, MRB_NIL_VALUE());
      }
      CHECKPOINT_END(RBREAK_TAG_STOP);
    L_STOP:
      MRB->JMP = PREV_JMP;
      IF (MRB->EXC) {
        MRB_ASSERT(MRB->EXC->TT == MRB_TT_EXCEPTION);
        RETURN MRB_OBJ_VALUE(MRB->EXC);
      }
      RETURN REGS[IREP->NLOCALS];
    }
  }
  END_DISPATCH;
#UNDEF REGS
  }
  MRB_CATCH(&C_JMP) {
    MRB_CALLINFO *CI = MRB->C->CI;
    WHILE (CI > MRB->C->CIBASE && CI->CCI == CINFO_DIRECT) {
      CI = CIPOP(MRB);
    }
    EXC_CATCHED = TRUE;
    PC = CI->PC;
    GOTO RETRY_TRY_BLOCK;
  }
  MRB_END_EXC(&C_JMP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 506699_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT RUN_CERT(X509 *CRT, CONST CHAR *NAMEINCERT,
                     CONST STRUCT SET_NAME_FN *FN)
{
    CONST CHAR *CONST *PNAME = NAMES;
    INT FAILED = 0;

    FOR (; *PNAME != NULL; ++PNAME) {
        INT SAMENAME = STRCASECMP(NAMEINCERT, *PNAME) == 0;
        SIZE_T NAMELEN = STRLEN(*PNAME);
        CHAR *NAME = OPENSSL_MALLOC(NAMELEN + 1);
        INT MATCH, RET;

        MEMCPY(NAME, *PNAME, NAMELEN + 1);

        MATCH = -1;
        IF (!TEST_INT_GE(RET = X509_CHECK_HOST(CRT, NAME, NAMELEN, 0, NULL),
                         0)) {
            FAILED = 1;
        } ELSE IF (FN->HOST) {
            IF (RET == 1 && !SAMENAME)
                MATCH = 1;
            IF (RET == 0 && SAMENAME)
                MATCH = 0;
        } ELSE IF (RET == 1)
            MATCH = 1;
        IF (!TEST_TRUE(CHECK_MESSAGE(FN, "HOST", NAMEINCERT, MATCH, *PNAME)))
            FAILED = 1;

        MATCH = -1;
        IF (!TEST_INT_GE(RET = X509_CHECK_HOST(CRT, NAME, NAMELEN,
                                               X509_CHECK_FLAG_NO_WILDCARDS,
                                               NULL), 0)) {
            FAILED = 1;
        } ELSE IF (FN->HOST) {
            IF (RET == 1 && !SAMENAME)
                MATCH = 1;
            IF (RET == 0 && SAMENAME)
                MATCH = 0;
        } ELSE IF (RET == 1)
            MATCH = 1;
        IF (!TEST_TRUE(CHECK_MESSAGE(FN, "HOST-NO-WILDCARDS",
                                     NAMEINCERT, MATCH, *PNAME)))
            FAILED = 1;

        MATCH = -1;
        RET = X509_CHECK_EMAIL(CRT, NAME, NAMELEN, 0);
        IF (FN->EMAIL) {
            IF (RET && !SAMENAME)
                MATCH = 1;
            IF (!RET && SAMENAME && STRCHR(NAMEINCERT, '@') != NULL)
                MATCH = 0;
        } ELSE IF (RET)
            MATCH = 1;
        IF (!TEST_TRUE(CHECK_MESSAGE(FN, "EMAIL", NAMEINCERT, MATCH, *PNAME)))
            FAILED = 1;
        OPENSSL_FREE(NAME);
    }

    RETURN FAILED == 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212810_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
REGIONAL_ALLOC(STRUCT REGIONAL *R, SIZE_T SIZE)
{
	SIZE_T A = ALIGN_UP(SIZE, ALIGNMENT);
	VOID *S;
	/* LARGE OBJECTS */
	IF(A > REGIONAL_LARGE_OBJECT_SIZE) {
		S = MALLOC(ALIGNMENT + SIZE);
		IF(!S) RETURN NULL;
		R->TOTAL_LARGE += ALIGNMENT+SIZE;
		*(CHAR**)S = R->LARGE_LIST;
		R->LARGE_LIST = (CHAR*)S;
		RETURN (CHAR*)S+ALIGNMENT;
	}
	/* CREATE A NEW CHUNK */
	IF(A > R->AVAILABLE) {
		S = MALLOC(REGIONAL_CHUNK_SIZE);
		IF(!S) RETURN NULL;
		*(CHAR**)S = R->NEXT;
		R->NEXT = (CHAR*)S;
		R->DATA = (CHAR*)S + ALIGNMENT;
		R->AVAILABLE = REGIONAL_CHUNK_SIZE - ALIGNMENT;
	}
	/* PUT IN THIS CHUNK */
	R->AVAILABLE -= A;
	S = R->DATA;
	R->DATA += A;
	RETURN S;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 259282_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CBC1_SCHEME_DECRYPT(MOVCONTEXT *C, MOVSTREAMCONTEXT *SC, AVENCRYPTIONINFO *SAMPLE, UINT8_T *INPUT, INT SIZE)
{
    INT I, RET;
    INT NUM_OF_ENCRYPTED_BLOCKS;
    UINT8_T IV[16];

    IF (!SC->CENC.AES_CTX) {
        /* INITIALIZE THE CIPHER */
        SC->CENC.AES_CTX = AV_AES_ALLOC();
        IF (!SC->CENC.AES_CTX) {
            RETURN AVERROR(ENOMEM);
        }

        RET = AV_AES_INIT(SC->CENC.AES_CTX, C->DECRYPTION_KEY, 16 * 8, 1);
        IF (RET < 0) {
            RETURN RET;
        }
    }

    MEMCPY(IV, SAMPLE->IV, 16);

    /* WHOLE-BLOCK FULL SAMPLE ENCRYPTION */
    IF (!SAMPLE->SUBSAMPLE_COUNT) {
        /* DECRYPT THE WHOLE PACKET */
        AV_AES_CRYPT(SC->CENC.AES_CTX, INPUT, INPUT, SIZE/16, IV, 1);
        RETURN 0;
    }

    FOR (I = 0; I < SAMPLE->SUBSAMPLE_COUNT; I++) {
        IF (SAMPLE->SUBSAMPLES[I].BYTES_OF_CLEAR_DATA + SAMPLE->SUBSAMPLES[I].BYTES_OF_PROTECTED_DATA > SIZE) {
            AV_LOG(C->FC, AV_LOG_ERROR, "SUBSAMPLE SIZE EXCEEDS THE PACKET SIZE LEFT\N");
            RETURN AVERROR_INVALIDDATA;
        }

        IF (SAMPLE->SUBSAMPLES[I].BYTES_OF_PROTECTED_DATA % 16) {
            AV_LOG(C->FC, AV_LOG_ERROR, "SUBSAMPLE BYTESOFPROTECTEDDATA IS NOT A MULTIPLE OF 16\N");
            RETURN AVERROR_INVALIDDATA;
        }

        /* SKIP THE CLEAR BYTES */
        INPUT += SAMPLE->SUBSAMPLES[I].BYTES_OF_CLEAR_DATA;
        SIZE -= SAMPLE->SUBSAMPLES[I].BYTES_OF_CLEAR_DATA;

        /* DECRYPT THE ENCRYPTED BYTES */
        NUM_OF_ENCRYPTED_BLOCKS = SAMPLE->SUBSAMPLES[I].BYTES_OF_PROTECTED_DATA/16;
        IF (NUM_OF_ENCRYPTED_BLOCKS > 0) {
            AV_AES_CRYPT(SC->CENC.AES_CTX, INPUT, INPUT, NUM_OF_ENCRYPTED_BLOCKS, IV, 1);
        }
        INPUT += SAMPLE->SUBSAMPLES[I].BYTES_OF_PROTECTED_DATA;
        SIZE -= SAMPLE->SUBSAMPLES[I].BYTES_OF_PROTECTED_DATA;
    }

    IF (SIZE > 0) {
        AV_LOG(C->FC, AV_LOG_ERROR, "LEFTOVER PACKET BYTES AFTER SUBSAMPLE PROCESSING\N");
        RETURN AVERROR_INVALIDDATA;
    }

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 382795_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT TRIMDYNAMIC (DYNAMICPTR * DP)
{
	/* 2.0.21: WE DON'T REALLOCATE MEMORY WE DON'T OWN */
	IF (!DP->FREEOK) {
		RETURN FALSE;
	}
	RETURN GDREALLOCDYNAMIC(DP, DP->LOGICALSIZE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384840_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STR_FOLDCASE(
    CHAR_U	*STR,
    INT		ORGLEN,
    CHAR_U	*BUF,
    INT		BUFLEN)
{
    GARRAY_T	GA;
    INT		I;
    INT		LEN = ORGLEN;

#DEFINE GA_CHAR(I)  ((CHAR_U *)GA.GA_DATA)[I]
#DEFINE GA_PTR(I)   ((CHAR_U *)GA.GA_DATA + (I))
#DEFINE STR_CHAR(I)  (BUF == NULL ? GA_CHAR(I) : BUF[I])
#DEFINE STR_PTR(I)   (BUF == NULL ? GA_PTR(I) : BUF + (I))

    // COPY "STR" INTO "BUF" OR ALLOCATED MEMORY, UNMODIFIED.
    IF (BUF == NULL)
    {
	GA_INIT2(&GA, 1, 10);
	IF (GA_GROW(&GA, LEN + 1) == FAIL)
	    RETURN NULL;
	MCH_MEMMOVE(GA.GA_DATA, STR, (SIZE_T)LEN);
	GA.GA_LEN = LEN;
    }
    ELSE
    {
	IF (LEN >= BUFLEN)	    // UGLY!
	    LEN = BUFLEN - 1;
	MCH_MEMMOVE(BUF, STR, (SIZE_T)LEN);
    }
    IF (BUF == NULL)
	GA_CHAR(LEN) = NUL;
    ELSE
	BUF[LEN] = NUL;

    // MAKE EACH CHARACTER LOWER CASE.
    I = 0;
    WHILE (STR_CHAR(I) != NUL)
    {
	IF (ENC_UTF8 || (HAS_MBYTE && MB_BYTE2LEN(STR_CHAR(I)) > 1))
	{
	    IF (ENC_UTF8)
	    {
		INT	C = UTF_PTR2CHAR(STR_PTR(I));
		INT	OLEN = UTF_PTR2LEN(STR_PTR(I));
		INT	LC = UTF_TOLOWER(C);

		// ONLY REPLACE THE CHARACTER WHEN IT IS NOT AN INVALID
		// SEQUENCE (ASCII CHARACTER OR MORE THAN ONE BYTE) AND
		// UTF_TOLOWER() DOESN'T RETURN THE ORIGINAL CHARACTER.
		IF ((C < 0X80 || OLEN > 1) && C != LC)
		{
		    INT	    NLEN = UTF_CHAR2LEN(LC);

		    // IF THE BYTE LENGTH CHANGES NEED TO SHIFT THE FOLLOWING
		    // CHARACTERS FORWARD OR BACKWARD.
		    IF (OLEN != NLEN)
		    {
			IF (NLEN > OLEN)
			{
			    IF (BUF == NULL
				    ? GA_GROW(&GA, NLEN - OLEN + 1) == FAIL
				    : LEN + NLEN - OLEN >= BUFLEN)
			    {
				// OUT OF MEMORY, KEEP OLD CHAR
				LC = C;
				NLEN = OLEN;
			    }
			}
			IF (OLEN != NLEN)
			{
			    IF (BUF == NULL)
			    {
				STRMOVE(GA_PTR(I) + NLEN, GA_PTR(I) + OLEN);
				GA.GA_LEN += NLEN - OLEN;
			    }
			    ELSE
			    {
				STRMOVE(BUF + I + NLEN, BUF + I + OLEN);
				LEN += NLEN - OLEN;
			    }
			}
		    }
		    (VOID)UTF_CHAR2BYTES(LC, STR_PTR(I));
		}
	    }
	    // SKIP TO NEXT MULTI-BYTE CHAR
	    I += (*MB_PTR2LEN)(STR_PTR(I));
	}
	ELSE
	{
	    IF (BUF == NULL)
		GA_CHAR(I) = TOLOWER_LOC(GA_CHAR(I));
	    ELSE
		BUF[I] = TOLOWER_LOC(BUF[I]);
	    ++I;
	}
    }

    IF (BUF == NULL)
	RETURN (CHAR_U *)GA.GA_DATA;
    RETURN BUF;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207990_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT GET_RECURSE_DATA_LENGTH(COMPILER_COMMON *COMMON, PCRE2_SPTR CC, PCRE2_SPTR CCEND,
  BOOL *NEEDS_CONTROL_HEAD, BOOL *HAS_QUIT, BOOL *HAS_ACCEPT)
{
INT LENGTH = 1;
INT SIZE;
PCRE2_SPTR ALTERNATIVE;
BOOL QUIT_FOUND = FALSE;
BOOL ACCEPT_FOUND = FALSE;
BOOL SETSOM_FOUND = FALSE;
BOOL SETMARK_FOUND = FALSE;
BOOL CAPTURE_LAST_FOUND = FALSE;
BOOL CONTROL_HEAD_FOUND = FALSE;

#IF DEFINED DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD
SLJIT_ASSERT(COMMON->CONTROL_HEAD_PTR != 0);
CONTROL_HEAD_FOUND = TRUE;
#ENDIF

/* CALCULATE THE SUM OF THE PRIVATE MACHINE WORDS. */
WHILE (CC < CCEND)
  {
  SIZE = 0;
  SWITCH(*CC)
    {
    CASE OP_SET_SOM:
    SLJIT_ASSERT(COMMON->HAS_SET_SOM);
    SETSOM_FOUND = TRUE;
    CC += 1;
    BREAK;

    CASE OP_RECURSE:
    IF (COMMON->HAS_SET_SOM)
      SETSOM_FOUND = TRUE;
    IF (COMMON->MARK_PTR != 0)
      SETMARK_FOUND = TRUE;
    IF (COMMON->CAPTURE_LAST_PTR != 0)
      CAPTURE_LAST_FOUND = TRUE;
    CC += 1 + LINK_SIZE;
    BREAK;

    CASE OP_KET:
    IF (PRIVATE_DATA(CC) != 0)
      {
      LENGTH++;
      SLJIT_ASSERT(PRIVATE_DATA(CC + 1) != 0);
      CC += PRIVATE_DATA(CC + 1);
      }
    CC += 1 + LINK_SIZE;
    BREAK;

    CASE OP_ASSERT:
    CASE OP_ASSERT_NOT:
    CASE OP_ASSERTBACK:
    CASE OP_ASSERTBACK_NOT:
    CASE OP_ASSERT_NA:
    CASE OP_ASSERTBACK_NA:
    CASE OP_ONCE:
    CASE OP_SCRIPT_RUN:
    CASE OP_BRAPOS:
    CASE OP_SBRA:
    CASE OP_SBRAPOS:
    CASE OP_SCOND:
    LENGTH++;
    SLJIT_ASSERT(PRIVATE_DATA(CC) != 0);
    CC += 1 + LINK_SIZE;
    BREAK;

    CASE OP_CBRA:
    CASE OP_SCBRA:
    LENGTH += 2;
    IF (COMMON->CAPTURE_LAST_PTR != 0)
      CAPTURE_LAST_FOUND = TRUE;
    IF (COMMON->OPTIMIZED_CBRACKET[GET2(CC, 1 + LINK_SIZE)] == 0)
      LENGTH++;
    CC += 1 + LINK_SIZE + IMM2_SIZE;
    BREAK;

    CASE OP_CBRAPOS:
    CASE OP_SCBRAPOS:
    LENGTH += 2 + 2;
    IF (COMMON->CAPTURE_LAST_PTR != 0)
      CAPTURE_LAST_FOUND = TRUE;
    CC += 1 + LINK_SIZE + IMM2_SIZE;
    BREAK;

    CASE OP_COND:
    /* MIGHT BE A HIDDEN SCOND. */
    ALTERNATIVE = CC + GET(CC, 1);
    IF (*ALTERNATIVE == OP_KETRMAX || *ALTERNATIVE == OP_KETRMIN)
      LENGTH++;
    CC += 1 + LINK_SIZE;
    BREAK;

    CASE_ITERATOR_PRIVATE_DATA_1
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH++;
    CC += 2;
#IFDEF SUPPORT_UNICODE
    IF (COMMON->UTF && HAS_EXTRALEN(CC[-1])) CC += GET_EXTRALEN(CC[-1]);
#ENDIF
    BREAK;

    CASE_ITERATOR_PRIVATE_DATA_2A
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH += 2;
    CC += 2;
#IFDEF SUPPORT_UNICODE
    IF (COMMON->UTF && HAS_EXTRALEN(CC[-1])) CC += GET_EXTRALEN(CC[-1]);
#ENDIF
    BREAK;

    CASE_ITERATOR_PRIVATE_DATA_2B
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH += 2;
    CC += 2 + IMM2_SIZE;
#IFDEF SUPPORT_UNICODE
    IF (COMMON->UTF && HAS_EXTRALEN(CC[-1])) CC += GET_EXTRALEN(CC[-1]);
#ENDIF
    BREAK;

    CASE_ITERATOR_TYPE_PRIVATE_DATA_1
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH++;
    CC += 1;
    BREAK;

    CASE_ITERATOR_TYPE_PRIVATE_DATA_2A
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH += 2;
    CC += 1;
    BREAK;

    CASE_ITERATOR_TYPE_PRIVATE_DATA_2B
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH += 2;
    CC += 1 + IMM2_SIZE;
    BREAK;

    CASE OP_CLASS:
    CASE OP_NCLASS:
#IF DEFINED SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH != 8
    CASE OP_XCLASS:
    SIZE = (*CC == OP_XCLASS) ? GET(CC, 1) : 1 + 32 / (INT)SIZEOF(PCRE2_UCHAR);
#ELSE
    SIZE = 1 + 32 / (INT)SIZEOF(PCRE2_UCHAR);
#ENDIF
    IF (PRIVATE_DATA(CC) != 0)
      LENGTH += GET_CLASS_ITERATOR_SIZE(CC + SIZE);
    CC += SIZE;
    BREAK;

    CASE OP_MARK:
    CASE OP_COMMIT_ARG:
    CASE OP_PRUNE_ARG:
    CASE OP_THEN_ARG:
    SLJIT_ASSERT(COMMON->MARK_PTR != 0);
    IF (!SETMARK_FOUND)
      SETMARK_FOUND = TRUE;
    IF (COMMON->CONTROL_HEAD_PTR != 0)
      CONTROL_HEAD_FOUND = TRUE;
    IF (*CC != OP_MARK)
      QUIT_FOUND = TRUE;

    CC += 1 + 2 + CC[1];
    BREAK;

    CASE OP_PRUNE:
    CASE OP_SKIP:
    CASE OP_COMMIT:
    QUIT_FOUND = TRUE;
    CC++;
    BREAK;

    CASE OP_SKIP_ARG:
    QUIT_FOUND = TRUE;
    CC += 1 + 2 + CC[1];
    BREAK;

    CASE OP_THEN:
    SLJIT_ASSERT(COMMON->CONTROL_HEAD_PTR != 0);
    QUIT_FOUND = TRUE;
    IF (!CONTROL_HEAD_FOUND)
      CONTROL_HEAD_FOUND = TRUE;
    CC++;
    BREAK;

    CASE OP_ACCEPT:
    CASE OP_ASSERT_ACCEPT:
    ACCEPT_FOUND = TRUE;
    CC++;
    BREAK;

    DEFAULT:
    CC = NEXT_OPCODE(COMMON, CC);
    SLJIT_ASSERT(CC != NULL);
    BREAK;
    }
  }
SLJIT_ASSERT(CC == CCEND);

IF (CONTROL_HEAD_FOUND)
  LENGTH++;
IF (CAPTURE_LAST_FOUND)
  LENGTH++;
IF (QUIT_FOUND)
  {
  IF (SETSOM_FOUND)
    LENGTH++;
  IF (SETMARK_FOUND)
    LENGTH++;
  }

*NEEDS_CONTROL_HEAD = CONTROL_HEAD_FOUND;
*HAS_QUIT = QUIT_FOUND;
*HAS_ACCEPT = ACCEPT_FOUND;
RETURN LENGTH;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195038_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_ARY_SHIFT_M(MRB_STATE *MRB, MRB_VALUE SELF)
{
  STRUCT RARRAY *A = MRB_ARY_PTR(SELF);
  MRB_INT LEN = ARY_LEN(A);
  MRB_INT N;
  MRB_VALUE VAL;

  IF (MRB_GET_ARGS(MRB, "|I", &N) == 0) {
    RETURN MRB_ARY_SHIFT(MRB, SELF);
  };
  ARY_MODIFY_CHECK(MRB, A);
  IF (LEN == 0 || N == 0) RETURN MRB_ARY_NEW(MRB);
  IF (N < 0) MRB_RAISE(MRB, E_ARGUMENT_ERROR, "NEGATIVE ARRAY SHIFT");
  IF (N > LEN) N = LEN;
  VAL = MRB_ARY_NEW_FROM_VALUES(MRB, N, ARY_PTR(A));
  IF (ARY_SHARED_P(A)) {
  L_SHIFT:
    A->AS.HEAP.PTR+=N;
    A->AS.HEAP.LEN-=N;
    RETURN VAL;
  }
  IF (LEN > ARY_SHIFT_SHARED_MIN) {
    ARY_MAKE_SHARED(MRB, A);
    GOTO L_SHIFT;
  }
  ELSE IF (LEN == N) {
    ARY_SET_LEN(A, 0);
  }
  ELSE {
    MRB_VALUE *PTR = ARY_PTR(A);
    MRB_INT SIZE = LEN-N;

    WHILE (SIZE--) {
      *PTR = *(PTR+N);
      ++PTR;
    }
    ARY_SET_LEN(A, LEN-N);
  }
  RETURN VAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204138_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID WRITE_RESPONSE(ESPSTATE *S)
{
    UINT32_T N;

    TRACE_ESP_WRITE_RESPONSE(S->STATUS);

    FIFO8_RESET(&S->FIFO);
    ESP_FIFO_PUSH(S, S->STATUS);
    ESP_FIFO_PUSH(S, 0);

    IF (S->DMA) {
        IF (S->DMA_MEMORY_WRITE) {
            S->DMA_MEMORY_WRITE(S->DMA_OPAQUE,
                                (UINT8_T *)FIFO8_POP_BUF(&S->FIFO, 2, &N), 2);
            S->RREGS[ESP_RSTAT] = STAT_TC | STAT_ST;
            S->RREGS[ESP_RINTR] |= INTR_BS | INTR_FC;
            S->RREGS[ESP_RSEQ] = SEQ_CD;
        } ELSE {
            S->PDMA_CB = WRITE_RESPONSE_PDMA_CB;
            ESP_RAISE_DRQ(S);
            RETURN;
        }
    } ELSE {
        S->TI_SIZE = 2;
        S->RREGS[ESP_RFLAGS] = 2;
    }
    ESP_RAISE_IRQ(S);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226975_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
IRC_PROTOCOL_CALLBACK(303)
{
    IRC_PROTOCOL_MIN_ARGS(4);

    WEECHAT_PRINTF_DATE_TAGS (
        IRC_MSGBUFFER_GET_TARGET_BUFFER (SERVER, NULL, COMMAND, NULL, NULL),
        DATE,
        IRC_PROTOCOL_TAGS (COMMAND, "IRC_NUMERIC", NULL, NULL),
        _("%SUSERS ONLINE: %S%S"),
        WEECHAT_PREFIX ("NETWORK"),
        IRC_COLOR_CHAT_NICK,
        (ARGV_EOL[3][0] == ':') ? ARGV_EOL[3] + 1 : ARGV_EOL[3]);

    RETURN WEECHAT_RC_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 326590_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ARCHIVE_WRITE_DISK_SET_USER_LOOKUP(STRUCT ARCHIVE *_A,
    VOID *PRIVATE_DATA,
    INT64_T (*LOOKUP_UID)(VOID *PRIVATE, CONST CHAR *UNAME, INT64_T UID),
    VOID (*CLEANUP_UID)(VOID *PRIVATE))
{
	STRUCT ARCHIVE_WRITE_DISK *A = (STRUCT ARCHIVE_WRITE_DISK *)_A;
	ARCHIVE_CHECK_MAGIC(&A->ARCHIVE, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, "ARCHIVE_WRITE_DISK_SET_USER_LOOKUP");

	IF (A->CLEANUP_UID != NULL && A->LOOKUP_UID_DATA != NULL)
		(A->CLEANUP_UID)(A->LOOKUP_UID_DATA);

	A->LOOKUP_UID = LOOKUP_UID;
	A->CLEANUP_UID = CLEANUP_UID;
	A->LOOKUP_UID_DATA = PRIVATE_DATA;
	RETURN (ARCHIVE_OK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 240263_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INIT_WRITE_REG(
    INT		NAME,
    YANKREG_T	**OLD_Y_PREVIOUS,
    YANKREG_T	**OLD_Y_CURRENT,
    INT		MUST_APPEND,
    INT		*YANK_TYPE UNUSED)
{
    IF (!VALID_YANK_REG(NAME, TRUE))	    // CHECK FOR VALID REG NAME
    {
	EMSG_INVREG(NAME);
	RETURN FAIL;
    }

    // DON'T WANT TO CHANGE THE CURRENT (UNNAMED) REGISTER
    *OLD_Y_PREVIOUS = Y_PREVIOUS;
    *OLD_Y_CURRENT = Y_CURRENT;

    GET_YANK_REGISTER(NAME, TRUE);
    IF (!Y_APPEND && !MUST_APPEND)
	FREE_YANK_ALL();
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211567_CWE-189.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CHAR *GETSISTRING(FILE *F, UINT32_T PTR, UINT32_T LEN) {
  CHAR *NAME;
  UINT32_T I;

  IF (!LEN) RETURN NULL;
  IF (LEN>400) LEN=400;
  NAME = CLI_MALLOC(LEN);
  IF (!NAME) {
    CLI_DBGMSG("SIS: OOM\N");
    RETURN NULL;
  }
  FSEEK(F, PTR, SEEK_SET);
  IF (FREAD(NAME, LEN, 1, F)!=1) {
    CLI_DBGMSG("SIS: UNABLE TO READ STRING\N");
    FREE(NAME);
    RETURN NULL;
  }
  FOR (I = 0 ; I < LEN; I+=2) NAME[I/2] = NAME[I];
  NAME[I/2]='\0';
  RETURN NAME;
}
ASSISTANT
CWE-78: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN OS COMMAND ('OS COMMAND INJECTION')  
CWE-79: IMPROPER NEUTRALIZATION OF INPUT DURING WEB PAGE GENERATION ('CROSS-SITE SCRIPTING')  
CWE-89: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN SQL COMMAND ('SQL INJECTION')  
CWE-90: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN LDAP QUERY ('LDAP INJECTION')  
CWE-91: IMPROPER CONTROL OF GENERATION OF CODE ('CODE INJECTION')  
CWE-92: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN XML DOCUMENT ('XML EXTERNAL ENTITY INJECTION')  
CWE-93: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN SMTP COMMAND ('SMTP INJECTION')  
CWE-94: IMPROPER CONTROL OF GENERATION OF CODE ('CODE INJECTION')  
CWE-95: IMPROPER NEUTRALIZATION OF DIRECTIVES IN DYNAMICALLY EVALUATED CODE ('EVAL INJECTION')  
CWE-96: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP RESPONSE SPLITTING')  
CWE-97: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-98: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-99: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-100: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-101: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-102: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-103: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-104: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-105: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-106: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-107: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-108: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-109: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-110: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-111: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-112: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-113: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-114: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-115: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-116: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-117: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-118: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-119: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-120: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-121: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-122: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-123: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-124: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-125: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-126: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-127: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-128: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-129: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-130: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-131: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-132: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-133: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-134: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-135: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-136: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-137: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-138: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-139: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-140: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-141: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-142: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-143: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-144: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-145: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-146: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-147: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-148: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-149: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-150: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-151: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-152: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-153: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-154: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-155: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-156: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-157: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-158: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-159: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-160: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-161: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-162: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-163: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-164: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-165: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-166: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-167: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-168: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-169: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-170: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-171: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-172: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-173: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-174: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-175: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-176: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-177: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-178: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-179: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-180: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-181: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-182: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-183: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-184: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-185: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-186: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-187: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-188: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-189: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-190: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-191: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-192: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-193: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-194: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-195: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-196: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-197: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-198: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-199: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-200: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-201: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-202: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-203: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-204: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-205: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-206: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-207: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-208: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-209: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-210: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-211: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-212: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-213: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-214: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-215: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-216: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-217: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-218: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-219: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-220: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-221: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-222: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-223: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-224: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-225: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-226: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-227: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-228: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-229: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-230: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-231: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-232: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-233: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-234: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-235: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-236: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-237: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-238: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-239: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-240: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-241: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-242: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-243: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')  
CWE-244: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SPLITTING')  
CWE-245: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN HTTP REQUEST ('HTTP REQUEST SMUGGLING')
--------------------------------------------------
File: 215400_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT HFSPLUS_BLOCK_ALLOCATE(STRUCT SUPER_BLOCK *SB, U32 SIZE, U32 OFFSET, U32 *MAX)
{
	STRUCT PAGE *PAGE;
	STRUCT ADDRESS_SPACE *MAPPING;
	__BE32 *PPTR, *CURR, *END;
	U32 MASK, START, LEN, N;
	__BE32 VAL;
	INT I;

	LEN = *MAX;
	IF (!LEN)
		RETURN SIZE;

	DPRINT(DBG_BITMAP, "BLOCK_ALLOCATE: %U,%U,%U\N", SIZE, OFFSET, LEN);
	MUTEX_LOCK(&HFSPLUS_SB(SB).ALLOC_FILE->I_MUTEX);
	MAPPING = HFSPLUS_SB(SB).ALLOC_FILE->I_MAPPING;
	PAGE = READ_MAPPING_PAGE(MAPPING, OFFSET / PAGE_CACHE_BITS, NULL);
	PPTR = KMAP(PAGE);
	CURR = PPTR + (OFFSET & (PAGE_CACHE_BITS - 1)) / 32;
	I = OFFSET % 32;
	OFFSET &= ~(PAGE_CACHE_BITS - 1);
	IF ((SIZE ^ OFFSET) / PAGE_CACHE_BITS)
		END = PPTR + PAGE_CACHE_BITS / 32;
	ELSE
		END = PPTR + ((SIZE + 31) & (PAGE_CACHE_BITS - 1)) / 32;

	/* SCAN THE FIRST PARTIAL U32 FOR ZERO BITS */
	VAL = *CURR;
	IF (~VAL) {
		N = BE32_TO_CPU(VAL);
		MASK = (1U << 31) >> I;
		FOR (; I < 32; MASK >>= 1, I++) {
			IF (!(N & MASK))
				GOTO FOUND;
		}
	}
	CURR++;

	/* SCAN COMPLETE U32S FOR THE FIRST ZERO BIT */
	WHILE (1) {
		WHILE (CURR < END) {
			VAL = *CURR;
			IF (~VAL) {
				N = BE32_TO_CPU(VAL);
				MASK = 1 << 31;
				FOR (I = 0; I < 32; MASK >>= 1, I++) {
					IF (!(N & MASK))
						GOTO FOUND;
				}
			}
			CURR++;
		}
		KUNMAP(PAGE);
		OFFSET += PAGE_CACHE_BITS;
		IF (OFFSET >= SIZE)
			BREAK;
		PAGE = READ_MAPPING_PAGE(MAPPING, OFFSET / PAGE_CACHE_BITS,
					 NULL);
		CURR = PPTR = KMAP(PAGE);
		IF ((SIZE ^ OFFSET) / PAGE_CACHE_BITS)
			END = PPTR + PAGE_CACHE_BITS / 32;
		ELSE
			END = PPTR + ((SIZE + 31) & (PAGE_CACHE_BITS - 1)) / 32;
	}
	DPRINT(DBG_BITMAP, "BITMAP FULL\N");
	START = SIZE;
	GOTO OUT;

FOUND:
	START = OFFSET + (CURR - PPTR) * 32 + I;
	IF (START >= SIZE) {
		DPRINT(DBG_BITMAP, "BITMAP FULL\N");
		GOTO OUT;
	}
	/* DO ANY PARTIAL U32 AT THE START */
	LEN = MIN(SIZE - START, LEN);
	WHILE (1) {
		N |= MASK;
		IF (++I >= 32)
			BREAK;
		MASK >>= 1;
		IF (!--LEN || N & MASK)
			GOTO DONE;
	}
	IF (!--LEN)
		GOTO DONE;
	*CURR++ = CPU_TO_BE32(N);
	/* DO FULL U32S */
	WHILE (1) {
		WHILE (CURR < END) {
			N = BE32_TO_CPU(*CURR);
			IF (LEN < 32)
				GOTO LAST;
			IF (N) {
				LEN = 32;
				GOTO LAST;
			}
			*CURR++ = CPU_TO_BE32(0XFFFFFFFF);
			LEN -= 32;
		}
		SET_PAGE_DIRTY(PAGE);
		KUNMAP(PAGE);
		OFFSET += PAGE_CACHE_BITS;
		PAGE = READ_MAPPING_PAGE(MAPPING, OFFSET / PAGE_CACHE_BITS,
					 NULL);
		PPTR = KMAP(PAGE);
		CURR = PPTR;
		END = PPTR + PAGE_CACHE_BITS / 32;
	}
LAST:
	/* DO ANY PARTIAL U32 AT END */
	MASK = 1U << 31;
	FOR (I = 0; I < LEN; I++) {
		IF (N & MASK)
			BREAK;
		N |= MASK;
		MASK >>= 1;
	}
DONE:
	*CURR = CPU_TO_BE32(N);
	SET_PAGE_DIRTY(PAGE);
	KUNMAP(PAGE);
	*MAX = OFFSET + (CURR - PPTR) * 32 + I - START;
	HFSPLUS_SB(SB).FREE_BLOCKS -= *MAX;
	SB->S_DIRT = 1;
	DPRINT(DBG_BITMAP, "-> %U,%U\N", START, *MAX);
OUT:
	MUTEX_UNLOCK(&HFSPLUS_SB(SB).ALLOC_FILE->I_MUTEX);
	RETURN START;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210910_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
WIN_REDR_STATUS(WIN_T *WP, INT IGNORE_PUM UNUSED)
{
    INT		ROW;
    CHAR_U	*P;
    INT		LEN;
    INT		FILLCHAR;
    INT		ATTR;
    INT		THIS_RU_COL;
    STATIC INT  BUSY = FALSE;

    // IT'S POSSIBLE TO GET HERE RECURSIVELY WHEN 'STATUSLINE' (INDIRECTLY)
    // INVOKES ":REDRAWSTATUS".  SIMPLY IGNORE THE CALL THEN.
    IF (BUSY)
	RETURN;
    BUSY = TRUE;

    ROW = STATUSLINE_ROW(WP);

    WP->W_REDR_STATUS = FALSE;
    IF (WP->W_STATUS_HEIGHT == 0)
    {
	// NO STATUS LINE, CAN ONLY BE LAST WINDOW
	REDRAW_CMDLINE = TRUE;
    }
    ELSE IF (!REDRAWING()
	    // DON'T UPDATE STATUS LINE WHEN POPUP MENU IS VISIBLE AND MAY BE
	    // DRAWN OVER IT, UNLESS IT WILL BE REDRAWN LATER
	    || (!IGNORE_PUM && PUM_VISIBLE()))
    {
	// DON'T REDRAW RIGHT NOW, DO IT LATER.
	WP->W_REDR_STATUS = TRUE;
    }
#IFDEF FEAT_STL_OPT
    ELSE IF (*P_STL != NUL || *WP->W_P_STL != NUL)
    {
	// REDRAW CUSTOM STATUS LINE
	REDRAW_CUSTOM_STATUSLINE(WP);
    }
#ENDIF
    ELSE
    {
	FILLCHAR = FILLCHAR_STATUS(&ATTR, WP);

	GET_TRANS_BUFNAME(WP->W_BUFFER);
	P = NAMEBUFF;
	LEN = (INT)STRLEN(P);

	IF (BT_HELP(WP->W_BUFFER)
#IFDEF FEAT_QUICKFIX
		|| WP->W_P_PVW
#ENDIF
		|| BUFISCHANGED(WP->W_BUFFER)
		|| WP->W_BUFFER->B_P_RO)
	    *(P + LEN++) = ' ';
	IF (BT_HELP(WP->W_BUFFER))
	{
	    VIM_SNPRINTF((CHAR *)P + LEN, MAXPATHL - LEN, "%S", _("[HELP]"));
	    LEN += (INT)STRLEN(P + LEN);
	}
#IFDEF FEAT_QUICKFIX
	IF (WP->W_P_PVW)
	{
	    VIM_SNPRINTF((CHAR *)P + LEN, MAXPATHL - LEN, "%S", _("[PREVIEW]"));
	    LEN += (INT)STRLEN(P + LEN);
	}
#ENDIF
	IF (BUFISCHANGED(WP->W_BUFFER)
#IFDEF FEAT_TERMINAL
		&& !BT_TERMINAL(WP->W_BUFFER)
#ENDIF
		)
	{
	    VIM_SNPRINTF((CHAR *)P + LEN, MAXPATHL - LEN, "%S", "[+]");
	    LEN += (INT)STRLEN(P + LEN);
	}
	IF (WP->W_BUFFER->B_P_RO)
	{
	    VIM_SNPRINTF((CHAR *)P + LEN, MAXPATHL - LEN, "%S", _("[RO]"));
	    LEN += (INT)STRLEN(P + LEN);
	}

	THIS_RU_COL = RU_COL - (COLUMNS - WP->W_WIDTH);
	IF (THIS_RU_COL < (WP->W_WIDTH + 1) / 2)
	    THIS_RU_COL = (WP->W_WIDTH + 1) / 2;
	IF (THIS_RU_COL <= 1)
	{
	    P = (CHAR_U *)"<";		// NO ROOM FOR FILE NAME!
	    LEN = 1;
	}
	ELSE IF (HAS_MBYTE)
	{
	    INT	CLEN = 0, I;

	    // COUNT TOTAL NUMBER OF DISPLAY CELLS.
	    CLEN = MB_STRING2CELLS(P, -1);

	    // FIND FIRST CHARACTER THAT WILL FIT.
	    // GOING FROM START TO END IS MUCH FASTER FOR DBCS.
	    FOR (I = 0; P[I] != NUL && CLEN >= THIS_RU_COL - 1;
		    I += (*MB_PTR2LEN)(P + I))
		CLEN -= (*MB_PTR2CELLS)(P + I);
	    LEN = CLEN;
	    IF (I > 0)
	    {
		P = P + I - 1;
		*P = '<';
		++LEN;
	    }

	}
	ELSE IF (LEN > THIS_RU_COL - 1)
	{
	    P += LEN - (THIS_RU_COL - 1);
	    *P = '<';
	    LEN = THIS_RU_COL - 1;
	}

	SCREEN_PUTS(P, ROW, WP->W_WINCOL, ATTR);
	SCREEN_FILL(ROW, ROW + 1, LEN + WP->W_WINCOL,
			THIS_RU_COL + WP->W_WINCOL, FILLCHAR, FILLCHAR, ATTR);

	IF (GET_KEYMAP_STR(WP, (CHAR_U *)"<%S>", NAMEBUFF, MAXPATHL)
		&& (INT)(THIS_RU_COL - LEN) > (INT)(STRLEN(NAMEBUFF) + 1))
	    SCREEN_PUTS(NAMEBUFF, ROW, (INT)(THIS_RU_COL - STRLEN(NAMEBUFF)
						   - 1 + WP->W_WINCOL), ATTR);

#IFDEF FEAT_CMDL_INFO
	WIN_REDR_RULER(WP, TRUE, IGNORE_PUM);
#ENDIF
    }

    /*
     * MAY NEED TO DRAW THE CHARACTER BELOW THE VERTICAL SEPARATOR.
     */
    IF (WP->W_VSEP_WIDTH != 0 && WP->W_STATUS_HEIGHT != 0 && REDRAWING())
    {
	IF (STL_CONNECTED(WP))
	    FILLCHAR = FILLCHAR_STATUS(&ATTR, WP);
	ELSE
	    FILLCHAR = FILLCHAR_VSEP(&ATTR);
	SCREEN_PUTCHAR(FILLCHAR, ROW, W_ENDCOL(WP), ATTR);
    }
    BUSY = FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224229_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API BOOL R_IO_BANK_READ_AT(RIO *IO, CONST UT32 BANKID, UT64 ADDR, UT8 *BUF, INT LEN) {
	RIOBANK *BANK = R_IO_BANK_GET (IO, BANKID);
	R_RETURN_VAL_IF_FAIL (IO && BANK, FALSE);
	RIOSUBMAP FAKE_SM;
	MEMSET (&FAKE_SM, 0X00, SIZEOF(RIOSUBMAP));
	FAKE_SM.ITV.ADDR = ADDR;
	FAKE_SM.ITV.SIZE = LEN;
	RRBNODE *NODE;
	IF (BANK->LAST_USED && R_IO_SUBMAP_CONTAIN (((RIOSUBMAP *)BANK->LAST_USED->DATA), ADDR)) {
		NODE = BANK->LAST_USED;
	} ELSE {
		NODE = _FIND_ENTRY_SUBMAP_NODE (BANK, &FAKE_SM);
	}
	MEMSET (BUF, IO->OXFF, LEN);
	RIOSUBMAP *SM = NODE ? (RIOSUBMAP *)NODE->DATA : NULL;
	BOOL RET = TRUE;
	WHILE (SM && R_IO_SUBMAP_OVERLAP ((&FAKE_SM), SM)) {
		BANK->LAST_USED = NODE;
		RIOMAP *MAP = R_IO_MAP_GET_BY_REF (IO, &SM->MAPREF);
		IF (!MAP) {
			// MAPREF DOESN'T BELONG TO MAP
			RETURN FALSE;
		}
		IF (!(MAP->PERM & R_PERM_R)) {
			NODE = R_RBNODE_NEXT (NODE);
			SM = NODE ? (RIOSUBMAP *)NODE->DATA : NULL;
			CONTINUE;
		}
		CONST UT64 BUF_OFF = R_MAX (ADDR, R_IO_SUBMAP_FROM (SM)) - ADDR;
		CONST INT READ_LEN = R_MIN (R_IO_SUBMAP_TO ((&FAKE_SM)),
					     R_IO_SUBMAP_TO (SM)) - (ADDR + BUF_OFF) + 1;
		CONST UT64 PADDR = ADDR + BUF_OFF - R_IO_MAP_FROM (MAP) + MAP->DELTA;
		RET &= (R_IO_FD_READ_AT (IO, MAP->FD, PADDR, &BUF[BUF_OFF], READ_LEN) == READ_LEN);
		// CHECK RETURN VALUE HERE?
		NODE = R_RBNODE_NEXT (NODE);
		SM = NODE ? (RIOSUBMAP *)NODE->DATA : NULL;
	}
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 309950_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NCURSES_SP_NAME(INIT_COLOR) (NCURSES_SP_DCLX
			     NCURSES_COLOR_T COLOR,
			     NCURSES_COLOR_T R,
			     NCURSES_COLOR_T G,
			     NCURSES_COLOR_T B)
{
    RETURN _NC_INIT_COLOR(SP_PARM, COLOR, R, G, B);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359245_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (CLEAR_IP_BGP_ALL_VPNV4_SOFT_OUT,
       CLEAR_IP_BGP_ALL_VPNV4_SOFT_OUT_CMD,
       "CLEAR IP BGP * VPNV4 UNICAST SOFT OUT",
       CLEAR_STR
       IP_STR
       BGP_STR
       "CLEAR ALL PEERS\N"
       "ADDRESS FAMILY\N"
       "ADDRESS FAMILY MODIFIER\N"
       "SOFT RECONFIG\N"
       "SOFT RECONFIG OUTBOUND UPDATE\N")
{
  RETURN BGP_CLEAR_VTY (VTY, NULL, AFI_IP, SAFI_MPLS_VPN, CLEAR_ALL,
			BGP_CLEAR_SOFT_OUT, NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195385_CWE-276.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FLATPAK_DIR_ENSURE_BUNDLE_REMOTE (FLATPAKDIR         *SELF,
                                  GFILE              *FILE,
                                  GBYTES             *EXTRA_GPG_DATA,
                                  FLATPAKDECOMPOSED **OUT_REF,
                                  CHAR              **OUT_CHECKSUM,
                                  CHAR              **OUT_METADATA,
                                  GBOOLEAN           *OUT_CREATED_REMOTE,
                                  GCANCELLABLE       *CANCELLABLE,
                                  GERROR            **ERROR)
{
  G_AUTOPTR(FLATPAKDECOMPOSED) REF = NULL;
  GBOOLEAN CREATED_REMOTE = FALSE;
  G_AUTOPTR(GBYTES) DEPLOY_DATA = NULL;
  G_AUTOPTR(GVARIANT) METADATA = NULL;
  G_AUTOFREE CHAR *ORIGIN = NULL;
  G_AUTOFREE CHAR *FP_METADATA = NULL;
  G_AUTOFREE CHAR *BASENAME = NULL;
  G_AUTOPTR(GBYTES) INCLUDED_GPG_DATA = NULL;
  GBYTES *GPG_DATA = NULL;
  G_AUTOFREE CHAR *TO_CHECKSUM = NULL;
  G_AUTOFREE CHAR *REMOTE = NULL;
  G_AUTOFREE CHAR *COLLECTION_ID = NULL;

  IF (!FLATPAK_DIR_ENSURE_REPO (SELF, CANCELLABLE, ERROR))
    RETURN NULL;

  METADATA = FLATPAK_BUNDLE_LOAD (FILE, &TO_CHECKSUM,
                                  &REF,
                                  &ORIGIN,
                                  NULL, &FP_METADATA, NULL,
                                  &INCLUDED_GPG_DATA,
                                  &COLLECTION_ID,
                                  ERROR);
  IF (METADATA == NULL)
    RETURN NULL;

  GPG_DATA = EXTRA_GPG_DATA ? EXTRA_GPG_DATA : INCLUDED_GPG_DATA;

  DEPLOY_DATA = FLATPAK_DIR_GET_DEPLOY_DATA (SELF, REF, FLATPAK_DEPLOY_VERSION_ANY, CANCELLABLE, NULL);
  IF (DEPLOY_DATA != NULL)
    {
      REMOTE = G_STRDUP (FLATPAK_DEPLOY_DATA_GET_ORIGIN (DEPLOY_DATA));

      /* WE NEED TO IMPORT ANY GPG KEYS BECAUSE OTHERWISE THE PULL WILL FAIL */
      IF (GPG_DATA != NULL)
        {
          G_AUTOPTR(GKEYFILE) NEW_CONFIG = NULL;

          NEW_CONFIG = OSTREE_REPO_COPY_CONFIG (FLATPAK_DIR_GET_REPO (SELF));

          IF (!FLATPAK_DIR_MODIFY_REMOTE (SELF, REMOTE, NEW_CONFIG,
                                          GPG_DATA, CANCELLABLE, ERROR))
            RETURN NULL;
        }
    }
  ELSE
    {
      G_AUTOFREE CHAR *ID = FLATPAK_DECOMPOSED_DUP_ID (REF);
      /* ADD A REMOTE FOR LATER UPDATES */
      BASENAME = G_FILE_GET_BASENAME (FILE);
      REMOTE = FLATPAK_DIR_CREATE_ORIGIN_REMOTE (SELF,
                                                 ORIGIN,
                                                 ID,
                                                 BASENAME,
                                                 FLATPAK_DECOMPOSED_GET_REF (REF),
                                                 GPG_DATA,
                                                 COLLECTION_ID,
                                                 &CREATED_REMOTE,
                                                 CANCELLABLE,
                                                 ERROR);
      IF (REMOTE == NULL)
        RETURN NULL;
    }

  IF (OUT_CREATED_REMOTE)
    *OUT_CREATED_REMOTE = CREATED_REMOTE;

  IF (OUT_REF)
    *OUT_REF = G_STEAL_POINTER (&REF);

  IF (OUT_CHECKSUM)
    *OUT_CHECKSUM = G_STEAL_POINTER (&TO_CHECKSUM);

  IF (OUT_METADATA)
    *OUT_METADATA = G_STEAL_POINTER (&FP_METADATA);


  RETURN G_STEAL_POINTER (&REMOTE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 274754_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT NTFS_ATTR_MAP_PARTIAL_RUNLIST(NTFS_ATTR *NA, VCN VCN)
{
	VCN LAST_VCN;
	VCN HIGHEST_VCN;
	VCN NEEDED;
	RUNLIST_ELEMENT *RL;
	ATTR_RECORD *A;
	BOOL STARTSEEN;
	NTFS_ATTR_SEARCH_CTX *CTX;
	BOOL DONE;
	BOOL NEWRUNLIST;

	IF (NATTRFULLYMAPPED(NA))
		RETURN 0;

	CTX = NTFS_ATTR_GET_SEARCH_CTX(NA->NI, NULL);
	IF (!CTX)
		RETURN -1;

	/* GET THE LAST VCN IN THE ATTRIBUTE. */
	LAST_VCN = NA->ALLOCATED_SIZE >> NA->NI->VOL->CLUSTER_SIZE_BITS;

	NEEDED = VCN;
	HIGHEST_VCN = 0;
	STARTSEEN = FALSE;
	DONE = FALSE;
	RL = (RUNLIST_ELEMENT*)NULL;
	DO {
		NEWRUNLIST = FALSE;
		/* FIND THE ATTRIBUTE IN THE MFT RECORD. */
		IF (!NTFS_ATTR_LOOKUP(NA->TYPE, NA->NAME, NA->NAME_LEN, CASE_SENSITIVE,
				NEEDED, NULL, 0, CTX)) {

			A = CTX->ATTR;
				/* DECODE AND MERGE THE RUNLIST. */
			IF (NTFS_RL_VCN_TO_LCN(NA->RL, NEEDED)
						== LCN_RL_NOT_MAPPED) {
				RL = NTFS_MAPPING_PAIRS_DECOMPRESS(NA->NI->VOL,
					A, NA->RL);
				NEWRUNLIST = TRUE;
			} ELSE
				RL = NA->RL;
			IF (RL) {
				NA->RL = RL;
				HIGHEST_VCN = SLE64_TO_CPU(A->HIGHEST_VCN);
				IF (HIGHEST_VCN < NEEDED) {
				/* CORRUPTION DETECTION ON UNCHANGED RUNLISTS */
					IF (NEWRUNLIST
					    && ((HIGHEST_VCN + 1) < LAST_VCN)) {
						NTFS_LOG_ERROR("CORRUPT ATTRIBUTE LIST\N");
						RL = (RUNLIST_ELEMENT*)NULL;
						ERRNO = EIO;
					}
					DONE = TRUE;
				}
				NEEDED = HIGHEST_VCN + 1;
				IF (!A->LOWEST_VCN)
					STARTSEEN = TRUE;
			}
		} ELSE {
			DONE = TRUE;
		}
	} WHILE (RL && !DONE && (NEEDED < LAST_VCN));
	NTFS_ATTR_PUT_SEARCH_CTX(CTX);
		/*
		 * MAKE SURE WE REACHED THE END, UNLESS THE LAST
		 * RUNLIST WAS MODIFIED EARLIER (USING HOLES_DELAY
		 * LEADS TO HAVE A VISIBILITY OVER ATTRIBUTES WHICH
		 * HAVE NOT YET BEEN FULLY UPDATED)
		 */
	IF (DONE && NEWRUNLIST && (NEEDED < LAST_VCN)) {
		NTFS_LOG_ERROR("END OF RUNLIST NOT REACHED\N");
		RL = (RUNLIST_ELEMENT*)NULL;
		ERRNO = EIO;
	}
		/* MARK FULLY MAPPED IF WE DID SO */
	IF (RL && STARTSEEN)
		NATTRSETFULLYMAPPED(NA);
	RETURN (RL ? 0 : -1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195908_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT BTRFS_RM_DEVICE(STRUCT BTRFS_FS_INFO *FS_INFO, CONST CHAR *DEVICE_PATH,
		    U64 DEVID)
{
	STRUCT BTRFS_DEVICE *DEVICE;
	STRUCT BTRFS_FS_DEVICES *CUR_DEVICES;
	STRUCT BTRFS_FS_DEVICES *FS_DEVICES = FS_INFO->FS_DEVICES;
	U64 NUM_DEVICES;
	INT RET = 0;

	MUTEX_LOCK(&UUID_MUTEX);

	NUM_DEVICES = BTRFS_NUM_DEVICES(FS_INFO);

	RET = BTRFS_CHECK_RAID_MIN_DEVICES(FS_INFO, NUM_DEVICES - 1);
	IF (RET)
		GOTO OUT;

	DEVICE = BTRFS_FIND_DEVICE_BY_DEVSPEC(FS_INFO, DEVID, DEVICE_PATH);

	IF (IS_ERR(DEVICE)) {
		IF (PTR_ERR(DEVICE) == -ENOENT &&
		    STRCMP(DEVICE_PATH, "MISSING") == 0)
			RET = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;
		ELSE
			RET = PTR_ERR(DEVICE);
		GOTO OUT;
	}

	IF (BTRFS_PINNED_BY_SWAPFILE(FS_INFO, DEVICE)) {
		BTRFS_WARN_IN_RCU(FS_INFO,
		  "CANNOT REMOVE DEVICE %S (DEVID %LLU) DUE TO ACTIVE SWAPFILE",
				  RCU_STR_DEREF(DEVICE->NAME), DEVICE->DEVID);
		RET = -ETXTBSY;
		GOTO OUT;
	}

	IF (TEST_BIT(BTRFS_DEV_STATE_REPLACE_TGT, &DEVICE->DEV_STATE)) {
		RET = BTRFS_ERROR_DEV_TGT_REPLACE;
		GOTO OUT;
	}

	IF (TEST_BIT(BTRFS_DEV_STATE_WRITEABLE, &DEVICE->DEV_STATE) &&
	    FS_INFO->FS_DEVICES->RW_DEVICES == 1) {
		RET = BTRFS_ERROR_DEV_ONLY_WRITABLE;
		GOTO OUT;
	}

	IF (TEST_BIT(BTRFS_DEV_STATE_WRITEABLE, &DEVICE->DEV_STATE)) {
		MUTEX_LOCK(&FS_INFO->CHUNK_MUTEX);
		LIST_DEL_INIT(&DEVICE->DEV_ALLOC_LIST);
		DEVICE->FS_DEVICES->RW_DEVICES--;
		MUTEX_UNLOCK(&FS_INFO->CHUNK_MUTEX);
	}

	MUTEX_UNLOCK(&UUID_MUTEX);
	RET = BTRFS_SHRINK_DEVICE(DEVICE, 0);
	IF (!RET)
		BTRFS_READA_REMOVE_DEV(DEVICE);
	MUTEX_LOCK(&UUID_MUTEX);
	IF (RET)
		GOTO ERROR_UNDO;

	/*
	 * TODO: THE SUPERBLOCK STILL INCLUDES THIS DEVICE IN ITS NUM_DEVICES
	 * COUNTER ALTHOUGH WRITE_ALL_SUPERS() IS NOT LOCKED OUT. THIS
	 * COULD GIVE A FILESYSTEM STATE WHICH REQUIRES A DEGRADED MOUNT.
	 */
	RET = BTRFS_RM_DEV_ITEM(DEVICE);
	IF (RET)
		GOTO ERROR_UNDO;

	CLEAR_BIT(BTRFS_DEV_STATE_IN_FS_METADATA, &DEVICE->DEV_STATE);
	BTRFS_SCRUB_CANCEL_DEV(DEVICE);

	/*
	 * THE DEVICE LIST MUTEX MAKES SURE THAT WE DON'T CHANGE
	 * THE DEVICE LIST WHILE SOMEONE ELSE IS WRITING OUT ALL
	 * THE DEVICE SUPERS. WHOEVER IS WRITING ALL SUPERS, SHOULD
	 * LOCK THE DEVICE LIST MUTEX BEFORE GETTING THE NUMBER OF
	 * DEVICES IN THE SUPER BLOCK (SUPER_COPY). CONVERSELY,
	 * WHOEVER UPDATES THE NUMBER OF DEVICES IN THE SUPER BLOCK
	 * (SUPER_COPY) SHOULD HOLD THE DEVICE LIST MUTEX.
	 */

	/*
	 * IN NORMAL CASES THE CUR_DEVICES == FS_DEVICES. BUT IN CASE
	 * OF DELETING A SEED DEVICE, THE CUR_DEVICES SHOULD POINT TO
	 * ITS OWN FS_DEVICES LISTED UNDER THE FS_DEVICES->SEED.
	 */
	CUR_DEVICES = DEVICE->FS_DEVICES;
	MUTEX_LOCK(&FS_DEVICES->DEVICE_LIST_MUTEX);
	LIST_DEL_RCU(&DEVICE->DEV_LIST);

	CUR_DEVICES->NUM_DEVICES--;
	CUR_DEVICES->TOTAL_DEVICES--;
	/* UPDATE TOTAL_DEVICES OF THE PARENT FS_DEVICES IF IT'S SEED */
	IF (CUR_DEVICES != FS_DEVICES)
		FS_DEVICES->TOTAL_DEVICES--;

	IF (TEST_BIT(BTRFS_DEV_STATE_MISSING, &DEVICE->DEV_STATE))
		CUR_DEVICES->MISSING_DEVICES--;

	BTRFS_ASSIGN_NEXT_ACTIVE_DEVICE(DEVICE, NULL);

	IF (DEVICE->BDEV) {
		CUR_DEVICES->OPEN_DEVICES--;
		/* REMOVE SYSFS ENTRY */
		BTRFS_SYSFS_REMOVE_DEVICE(DEVICE);
	}

	NUM_DEVICES = BTRFS_SUPER_NUM_DEVICES(FS_INFO->SUPER_COPY) - 1;
	BTRFS_SET_SUPER_NUM_DEVICES(FS_INFO->SUPER_COPY, NUM_DEVICES);
	MUTEX_UNLOCK(&FS_DEVICES->DEVICE_LIST_MUTEX);

	/*
	 * AT THIS POINT, THE DEVICE IS ZERO SIZED AND DETACHED FROM
	 * THE DEVICES LIST.  ALL THAT'S LEFT IS TO ZERO OUT THE OLD
	 * SUPERS AND FREE THE DEVICE.
	 */
	IF (TEST_BIT(BTRFS_DEV_STATE_WRITEABLE, &DEVICE->DEV_STATE))
		BTRFS_SCRATCH_SUPERBLOCKS(FS_INFO, DEVICE->BDEV,
					  DEVICE->NAME->STR);

	BTRFS_CLOSE_BDEV(DEVICE);
	SYNCHRONIZE_RCU();
	BTRFS_FREE_DEVICE(DEVICE);

	IF (CUR_DEVICES->OPEN_DEVICES == 0) {
		LIST_DEL_INIT(&CUR_DEVICES->SEED_LIST);
		CLOSE_FS_DEVICES(CUR_DEVICES);
		FREE_FS_DEVICES(CUR_DEVICES);
	}

OUT:
	MUTEX_UNLOCK(&UUID_MUTEX);
	RETURN RET;

ERROR_UNDO:
	BTRFS_READA_UNDO_REMOVE_DEV(DEVICE);
	IF (TEST_BIT(BTRFS_DEV_STATE_WRITEABLE, &DEVICE->DEV_STATE)) {
		MUTEX_LOCK(&FS_INFO->CHUNK_MUTEX);
		LIST_ADD(&DEVICE->DEV_ALLOC_LIST,
			 &FS_DEVICES->ALLOC_LIST);
		DEVICE->FS_DEVICES->RW_DEVICES++;
		MUTEX_UNLOCK(&FS_INFO->CHUNK_MUTEX);
	}
	GOTO OUT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 463184_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT FIND_DESC_STORE(ANNOTATE_STATE_T *STATE,
                           CONST CHAR *NAME,
                           CONST ANNOTATE_ENTRYDESC_T **DESCP)
{
    INT SCOPE = STATE->WHICH;
    CONST PTRARRAY_T *DESCS;
    CONST ANNOTATE_ENTRYDESC_T *DB_ENTRY;
    ANNOTATE_ENTRYDESC_T *DESC;
    INT I;

    IF (SCOPE == ANNOTATION_SCOPE_SERVER) {
        DESCS = &SERVER_ENTRIES;
        DB_ENTRY = &SERVER_DB_ENTRY;
    }
    ELSE IF (SCOPE == ANNOTATION_SCOPE_MAILBOX) {
        DESCS = &MAILBOX_ENTRIES;
        DB_ENTRY = &MAILBOX_DB_ENTRY;
    }
    ELSE IF (SCOPE == ANNOTATION_SCOPE_MESSAGE) {
        DESCS = &MESSAGE_ENTRIES;
        DB_ENTRY = &MESSAGE_DB_ENTRY;
    }
    ELSE {
        SYSLOG(LOG_ERR, "IOERROR: UNKNOWN SCOPE IN FIND_DESC_STORE %D", SCOPE);
        RETURN IMAP_INTERNAL;
    }

    /* CHECK FOR DAV ANNOTATIONS */
    IF (STATE->MAILBOX && (STATE->MAILBOX->MBTYPE & MBTYPES_DAV) &&
        !STRNCMP(NAME, DAV_ANNOT_NS, STRLEN(DAV_ANNOT_NS))) {
        *DESCP = DB_ENTRY;
        RETURN 0;
    }

    /* CHECK KNOWN IMAP ANNOTATIONS */
    FOR (I = 0 ; I < DESCS->COUNT ; I++) {
        DESC = DESCS->DATA[I];
        IF (STRCMP(NAME, DESC->NAME))
            CONTINUE;
        IF (!DESC->SET) {
            /* READ-ONLY ANNOTATION */
            RETURN IMAP_PERMISSION_DENIED;
        }
        *DESCP = DESC;
        RETURN 0;
    }

    /* UNKNOWN ANNOTATION */
    IF (!CONFIG_GETSWITCH(IMAPOPT_ANNOTATION_ALLOW_UNDEFINED))
        RETURN IMAP_PERMISSION_DENIED;

    /* CHECK FOR /FLAGS AND /VENDOR/CMU */
    IF (SCOPE == ANNOTATION_SCOPE_MESSAGE &&
        !STRNCMP(NAME, "/FLAGS/", 7))
        RETURN IMAP_PERMISSION_DENIED;

    IF (!STRNCMP(NAME, IMAP_ANNOT_NS, STRLEN(IMAP_ANNOT_NS)))
        RETURN IMAP_PERMISSION_DENIED;

    *DESCP = DB_ENTRY;
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 459215_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID TCF_PROTO_MARK_DELETE(STRUCT TCF_PROTO *TP)
{
	SPIN_LOCK(&TP->LOCK);
	TP->DELETING = TRUE;
	SPIN_UNLOCK(&TP->LOCK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 344769_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PUT_U32_LE(VOID *VP, U_INT32_T V)
{
	U_CHAR *P = (U_CHAR *)VP;

	P[0] = (U_CHAR)V & 0XFF;
	P[1] = (U_CHAR)(V >> 8) & 0XFF;
	P[2] = (U_CHAR)(V >> 16) & 0XFF;
	P[3] = (U_CHAR)(V >> 24) & 0XFF;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214997_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
COMPILERULE(FILEINFO *FILE, TRANSLATIONTABLEHEADER **TABLE,
		DISPLAYTABLEHEADER **DISPLAYTABLE, CONST MACROLIST **INSCOPEMACROS) {
	CHARSSTRING TOKEN;
	TRANSLATIONTABLEOPCODE OPCODE;
	CHARSSTRING RULECHARS;
	CHARSSTRING RULEDOTS;
	CHARSSTRING CELLS;
	CHARSSTRING SCRATCHPAD;
	CHARSSTRING EMPHCLASS;
	TRANSLATIONTABLECHARACTERATTRIBUTES AFTER = 0;
	TRANSLATIONTABLECHARACTERATTRIBUTES BEFORE = 0;
	INT NOBACK, NOFOR, NOCROSS;
	NOBACK = NOFOR = NOCROSS = 0;
DOOPCODE:
	IF (!GETTOKEN(FILE, &TOKEN, NULL)) RETURN 1;				  /* BLANK LINE */
	IF (TOKEN.CHARS[0] == '#' || TOKEN.CHARS[0] == '<') RETURN 1; /* COMMENT */
	IF (FILE->LINENUMBER == 1 &&
			(EQASC2UNI((UNSIGNED CHAR *)"ISO", TOKEN.CHARS, 3) ||
					EQASC2UNI((UNSIGNED CHAR *)"UTF-8", TOKEN.CHARS, 5))) {
		IF (TABLE)
			COMPILEHYPHENATION(FILE, &TOKEN, TABLE);
		ELSE
			/* IGNORE THE WHOLE FILE */
			WHILE (_LOU_GETALINE(FILE))
				;
		RETURN 1;
	}
	OPCODE = GETOPCODE(FILE, &TOKEN);
	SWITCH (OPCODE) {
	CASE CTO_MACRO: {
		CONST MACRO *MACRO;
#IFDEF ENABLE_MACROS
		IF (!INSCOPEMACROS) {
			COMPILEERROR(FILE, "DEFINING MACROS ONLY ALLOWED IN TABLE FILES.");
			RETURN 0;
		}
		IF (COMPILEMACRO(FILE, &MACRO)) {
			*INSCOPEMACROS = CONS_MACRO(MACRO, *INSCOPEMACROS);
			RETURN 1;
		}
		RETURN 0;
#ELSE
		COMPILEERROR(FILE, "MACRO FEATURE IS DISABLED.");
		RETURN 0;
#ENDIF
	}
	CASE CTO_INCLUDEFILE: {
		CHARSSTRING INCLUDEDFILE;
		IF (!GETTOKEN(FILE, &TOKEN, "INCLUDE FILE NAME")) RETURN 0;
		IF (!PARSECHARS(FILE, &INCLUDEDFILE, &TOKEN)) RETURN 0;
		RETURN INCLUDEFILE(FILE, &INCLUDEDFILE, TABLE, DISPLAYTABLE);
	}
	CASE CTO_NOBACK:
		IF (NOFOR) {
			COMPILEERROR(FILE, "%S ALREADY SPECIFIED.", _LOU_FINDOPCODENAME(CTO_NOFOR));
			RETURN 0;
		}
		NOBACK = 1;
		GOTO DOOPCODE;
	CASE CTO_NOFOR:
		IF (NOBACK) {
			COMPILEERROR(FILE, "%S ALREADY SPECIFIED.", _LOU_FINDOPCODENAME(CTO_NOBACK));
			RETURN 0;
		}
		NOFOR = 1;
		GOTO DOOPCODE;
	CASE CTO_SPACE:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_SPACE, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_DIGIT:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_DIGIT, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_LITDIGIT:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_LITDIGIT, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_PUNCTUATION:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_PUNCTUATION, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_MATH:
		RETURN COMPILECHARDEF(FILE, OPCODE, CTC_MATH, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_SIGN:
		RETURN COMPILECHARDEF(FILE, OPCODE, CTC_SIGN, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_LETTER:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_LETTER, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_UPPERCASE:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_UPPERCASE, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_LOWERCASE:
		RETURN COMPILECHARDEF(
				FILE, OPCODE, CTC_LOWERCASE, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_GROUPING:
		RETURN COMPILEGROUPING(FILE, NOBACK, NOFOR, TABLE, DISPLAYTABLE);
	CASE CTO_DISPLAY:
		IF (!DISPLAYTABLE) RETURN 1;  // IGNORE
		IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
		IF (!GETRULEDOTSPATTERN(FILE, &RULEDOTS)) RETURN 0;
		IF (RULECHARS.LENGTH != 1 || RULEDOTS.LENGTH != 1) {
			COMPILEERROR(FILE, "EXACTLY ONE CHARACTER AND ONE CELL ARE REQUIRED.");
			RETURN 0;
		}
		RETURN PUTCHARDOTSMAPPING(
				FILE, RULECHARS.CHARS[0], RULEDOTS.CHARS[0], DISPLAYTABLE);
	CASE CTO_UPLOW:
	CASE CTO_NONE: {
		// CHECK IF TOKEN IS A MACRO NAME
		IF (INSCOPEMACROS) {
			CONST MACROLIST *MACROS = *INSCOPEMACROS;
			WHILE (MACROS) {
				CONST MACRO *M = MACROS->HEAD;
				IF (TOKEN.LENGTH == STRLEN(M->NAME) &&
						EQASC2UNI((UNSIGNED CHAR *)M->NAME, TOKEN.CHARS, TOKEN.LENGTH)) {
					IF (!INSCOPEMACROS) {
						COMPILEERROR(FILE, "CALLING MACROS ONLY ALLOWED IN TABLE FILES.");
						RETURN 0;
					}
					FILEINFO TMPFILE;
					MEMSET(&TMPFILE, 0, SIZEOF(TMPFILE));
					TMPFILE.FILENAME = FILE->FILENAME;
					TMPFILE.SOURCEFILE = FILE->SOURCEFILE;
					TMPFILE.LINENUMBER = FILE->LINENUMBER;
					TMPFILE.ENCODING = NOENCODING;
					TMPFILE.STATUS = 0;
					TMPFILE.LINEPOS = 0;
					TMPFILE.LINELEN = 0;
					INT ARGUMENT_COUNT = 0;
					CHARSSTRING *ARGUMENTS =
							MALLOC(M->ARGUMENT_COUNT * SIZEOF(CHARSSTRING));
					WHILE (ARGUMENT_COUNT < M->ARGUMENT_COUNT) {
						IF (GETTOKEN(FILE, &TOKEN, "MACRO ARGUMENT"))
							ARGUMENTS[ARGUMENT_COUNT++] = TOKEN;
						ELSE
							BREAK;
					}
					IF (ARGUMENT_COUNT < M->ARGUMENT_COUNT) {
						COMPILEERROR(FILE, "EXPECTED %D ARGUMENTS", M->ARGUMENT_COUNT);
						RETURN 0;
					}
					INT I = 0;
					INT SUBST = 0;
					INT NEXT = SUBST < M->SUBSTITUTION_COUNT ? M->SUBSTITUTIONS[2 * SUBST]
															 : M->DEFINITION_LENGTH;
					FOR (;;) {
						WHILE (I < NEXT) {
							WIDECHAR C = M->DEFINITION[I++];
							IF (C == '\N') {
								IF (!COMPILERULE(&TMPFILE, TABLE, DISPLAYTABLE,
											INSCOPEMACROS)) {
									_LOU_LOGMESSAGE(LOU_LOG_ERROR,
											"RESULT OF MACRO EXPANSION WAS: %S",
											_LOU_SHOWSTRING(
													TMPFILE.LINE, TMPFILE.LINELEN, 0));
									RETURN 0;
								}
								TMPFILE.LINEPOS = 0;
								TMPFILE.LINELEN = 0;
							} ELSE IF (TMPFILE.LINELEN >= MAXSTRING) {
								COMPILEERROR(FILE,
										"LINE EXCEEDS %D CHARACTERS (POST MACRO "
										"EXPANSION)",
										MAXSTRING);
								RETURN 0;
							} ELSE
								TMPFILE.LINE[TMPFILE.LINELEN++] = C;
						}
						IF (SUBST < M->SUBSTITUTION_COUNT) {
							CHARSSTRING ARG =
									ARGUMENTS[M->SUBSTITUTIONS[2 * SUBST + 1] - 1];
							FOR (INT J = 0; J < ARG.LENGTH; J++)
								TMPFILE.LINE[TMPFILE.LINELEN++] = ARG.CHARS[J];
							SUBST++;
							NEXT = SUBST < M->SUBSTITUTION_COUNT
									? M->SUBSTITUTIONS[2 * SUBST]
									: M->DEFINITION_LENGTH;
						} ELSE {
							IF (!COMPILERULE(
										&TMPFILE, TABLE, DISPLAYTABLE, INSCOPEMACROS)) {
								_LOU_LOGMESSAGE(LOU_LOG_ERROR,
										"RESULT OF MACRO EXPANSION WAS: %S",
										_LOU_SHOWSTRING(
												TMPFILE.LINE, TMPFILE.LINELEN, 0));
								RETURN 0;
							}
							BREAK;
						}
					}
					RETURN 1;
				}
				MACROS = MACROS->TAIL;
			}
		}
		IF (OPCODE == CTO_UPLOW) {
			COMPILEERROR(FILE, "THE UPLOW OPCODE IS DEPRECATED.");
			RETURN 0;
		}
		COMPILEERROR(FILE, "OPCODE %S NOT DEFINED.",
				_LOU_SHOWSTRING(TOKEN.CHARS, TOKEN.LENGTH, 0));
		RETURN 0;
	}

	/* NOW ONLY OPCODES FOLLOW THAT DON'T MODIFY THE DISPLAY TABLE */
	DEFAULT:
		IF (!TABLE) RETURN 1;
		SWITCH (OPCODE) {
		CASE CTO_LOCALE:
			COMPILEWARNING(FILE,
					"THE LOCALE OPCODE IS NOT IMPLEMENTED. USE THE LOCALE META DATA "
					"INSTEAD.");
			RETURN 1;
		CASE CTO_UNDEFINED: {
			// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE TABLE
			TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->UNDEFINED;
			IF (!COMPILEBRAILLEINDICATOR(FILE, "UNDEFINED CHARACTER OPCODE",
						CTO_UNDEFINED, &RULEOFFSET, NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->UNDEFINED = RULEOFFSET;
			RETURN 1;
		}
		CASE CTO_MATCH: {
			INT OK = 0;
			WIDECHAR *PATTERNS = NULL;
			TRANSLATIONTABLERULE *RULE;
			TRANSLATIONTABLEOFFSET RULEOFFSET;
			CHARSSTRING PTN_BEFORE, PTN_AFTER;
			TRANSLATIONTABLEOFFSET PATTERNSOFFSET;
			INT LEN, MRK;
			SIZE_T PATTERNSBYTESIZE = SIZEOF(*PATTERNS) * 27720;
			PATTERNS = (WIDECHAR *)MALLOC(PATTERNSBYTESIZE);
			IF (!PATTERNS) _LOU_OUTOFMEMORY();
			MEMSET(PATTERNS, 0XFFFF, PATTERNSBYTESIZE);
			NOBACK = 1;
			GETCHARACTERS(FILE, &PTN_BEFORE);
			GETRULECHARSTEXT(FILE, &RULECHARS);
			GETCHARACTERS(FILE, &PTN_AFTER);
			GETRULEDOTSPATTERN(FILE, &RULEDOTS);
			IF (!ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, AFTER, BEFORE, &RULEOFFSET,
						&RULE, NOBACK, NOFOR, TABLE))
				GOTO CTO_MATCH_CLEANUP;
			IF (PTN_BEFORE.CHARS[0] == '-' && PTN_BEFORE.LENGTH == 1)
				LEN = _LOU_PATTERN_COMPILE(
						&PTN_BEFORE.CHARS[0], 0, &PATTERNS[1], 13841, *TABLE, FILE);
			ELSE
				LEN = _LOU_PATTERN_COMPILE(&PTN_BEFORE.CHARS[0], PTN_BEFORE.LENGTH,
						&PATTERNS[1], 13841, *TABLE, FILE);
			IF (!LEN) GOTO CTO_MATCH_CLEANUP;
			MRK = PATTERNS[0] = LEN + 1;
			_LOU_PATTERN_REVERSE(&PATTERNS[1]);
			IF (PTN_AFTER.CHARS[0] == '-' && PTN_AFTER.LENGTH == 1)
				LEN = _LOU_PATTERN_COMPILE(
						&PTN_AFTER.CHARS[0], 0, &PATTERNS[MRK], 13841, *TABLE, FILE);
			ELSE
				LEN = _LOU_PATTERN_COMPILE(&PTN_AFTER.CHARS[0], PTN_AFTER.LENGTH,
						&PATTERNS[MRK], 13841, *TABLE, FILE);
			IF (!LEN) GOTO CTO_MATCH_CLEANUP;
			LEN += MRK;
			IF (!ALLOCATESPACEINTRANSLATIONTABLE(
						FILE, &PATTERNSOFFSET, LEN * SIZEOF(WIDECHAR), TABLE))
				GOTO CTO_MATCH_CLEANUP;
			// ALLOCATESPACEINTRANSLATIONTABLE MAY HAVE MOVED TABLE, SO MAKE SURE RULE IS
			// STILL VALID
			RULE = (TRANSLATIONTABLERULE *)&(*TABLE)->RULEAREA[RULEOFFSET];
			MEMCPY(&(*TABLE)->RULEAREA[PATTERNSOFFSET], PATTERNS, LEN * SIZEOF(WIDECHAR));
			RULE->PATTERNS = PATTERNSOFFSET;
			OK = 1;
		CTO_MATCH_CLEANUP:
			FREE(PATTERNS);
			RETURN OK;
		}

		CASE CTO_BACKMATCH: {
			INT OK = 0;
			WIDECHAR *PATTERNS = NULL;
			TRANSLATIONTABLERULE *RULE;
			TRANSLATIONTABLEOFFSET RULEOFFSET;
			CHARSSTRING PTN_BEFORE, PTN_AFTER;
			TRANSLATIONTABLEOFFSET PATTERNOFFSET;
			INT LEN, MRK;
			SIZE_T PATTERNSBYTESIZE = SIZEOF(*PATTERNS) * 27720;
			PATTERNS = (WIDECHAR *)MALLOC(PATTERNSBYTESIZE);
			IF (!PATTERNS) _LOU_OUTOFMEMORY();
			MEMSET(PATTERNS, 0XFFFF, PATTERNSBYTESIZE);
			NOFOR = 1;
			GETCHARACTERS(FILE, &PTN_BEFORE);
			GETRULECHARSTEXT(FILE, &RULECHARS);
			GETCHARACTERS(FILE, &PTN_AFTER);
			GETRULEDOTSPATTERN(FILE, &RULEDOTS);
			IF (!ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, 0, 0, &RULEOFFSET, &RULE,
						NOBACK, NOFOR, TABLE))
				GOTO CTO_BACKMATCH_CLEANUP;
			IF (PTN_BEFORE.CHARS[0] == '-' && PTN_BEFORE.LENGTH == 1)
				LEN = _LOU_PATTERN_COMPILE(
						&PTN_BEFORE.CHARS[0], 0, &PATTERNS[1], 13841, *TABLE, FILE);
			ELSE
				LEN = _LOU_PATTERN_COMPILE(&PTN_BEFORE.CHARS[0], PTN_BEFORE.LENGTH,
						&PATTERNS[1], 13841, *TABLE, FILE);
			IF (!LEN) GOTO CTO_BACKMATCH_CLEANUP;
			MRK = PATTERNS[0] = LEN + 1;
			_LOU_PATTERN_REVERSE(&PATTERNS[1]);
			IF (PTN_AFTER.CHARS[0] == '-' && PTN_AFTER.LENGTH == 1)
				LEN = _LOU_PATTERN_COMPILE(
						&PTN_AFTER.CHARS[0], 0, &PATTERNS[MRK], 13841, *TABLE, FILE);
			ELSE
				LEN = _LOU_PATTERN_COMPILE(&PTN_AFTER.CHARS[0], PTN_AFTER.LENGTH,
						&PATTERNS[MRK], 13841, *TABLE, FILE);
			IF (!LEN) GOTO CTO_BACKMATCH_CLEANUP;
			LEN += MRK;
			IF (!ALLOCATESPACEINTRANSLATIONTABLE(
						FILE, &PATTERNOFFSET, LEN * SIZEOF(WIDECHAR), TABLE))
				GOTO CTO_BACKMATCH_CLEANUP;
			// ALLOCATESPACEINTRANSLATIONTABLE MAY HAVE MOVED TABLE, SO MAKE SURE RULE IS
			// STILL VALID
			RULE = (TRANSLATIONTABLERULE *)&(*TABLE)->RULEAREA[RULEOFFSET];
			MEMCPY(&(*TABLE)->RULEAREA[PATTERNOFFSET], PATTERNS, LEN * SIZEOF(WIDECHAR));
			RULE->PATTERNS = PATTERNOFFSET;
			OK = 1;
		CTO_BACKMATCH_CLEANUP:
			FREE(PATTERNS);
			RETURN OK;
		}

		CASE CTO_CAPSLETTER:
		CASE CTO_BEGCAPSWORD:
		CASE CTO_ENDCAPSWORD:
		CASE CTO_BEGCAPS:
		CASE CTO_ENDCAPS:
		CASE CTO_BEGCAPSPHRASE:
		CASE CTO_ENDCAPSPHRASE:
		CASE CTO_LENCAPSPHRASE:
		/* THESE 8 GENERAL PURPOSE OPCODES ARE COMPILED FURTHER DOWN TO MORE SPECIFIC
		 * INTERNAL OPCODES:
		 * - MODELETTER
		 * - BEGMODEWORD
		 * - ENDMODEWORD
		 * - BEGMODE
		 * - ENDMODE
		 * - BEGMODEPHRASE
		 * - ENDMODEPHRASE
		 * - LENMODEPHRASE
		 */
		CASE CTO_MODELETTER:
		CASE CTO_BEGMODEWORD:
		CASE CTO_ENDMODEWORD:
		CASE CTO_BEGMODE:
		CASE CTO_ENDMODE:
		CASE CTO_BEGMODEPHRASE:
		CASE CTO_ENDMODEPHRASE:
		CASE CTO_LENMODEPHRASE: {
			TRANSLATIONTABLECHARACTERATTRIBUTES MODE;
			INT I;
			SWITCH (OPCODE) {
			CASE CTO_CAPSLETTER:
			CASE CTO_BEGCAPSWORD:
			CASE CTO_ENDCAPSWORD:
			CASE CTO_BEGCAPS:
			CASE CTO_ENDCAPS:
			CASE CTO_BEGCAPSPHRASE:
			CASE CTO_ENDCAPSPHRASE:
			CASE CTO_LENCAPSPHRASE:
				MODE = CTC_UPPERCASE;
				I = 0;
				OPCODE += (CTO_MODELETTER - CTO_CAPSLETTER);
				BREAK;
			DEFAULT:
				IF (!GETTOKEN(FILE, &TOKEN, "ATTRIBUTE NAME")) RETURN 0;
				IF (!(*TABLE)->CHARACTERCLASSES && !ALLOCATECHARACTERCLASSES(*TABLE)) {
					RETURN 0;
				}
				CONST CHARACTERCLASS *CHARACTERCLASS = FINDCHARACTERCLASS(&TOKEN, *TABLE);
				IF (!CHARACTERCLASS) {
					CHARACTERCLASS =
							ADDCHARACTERCLASS(FILE, TOKEN.CHARS, TOKEN.LENGTH, *TABLE, 1);
					IF (!CHARACTERCLASS) RETURN 0;
				}
				MODE = CHARACTERCLASS->ATTRIBUTE;
				IF (!(MODE == CTC_UPPERCASE || MODE == CTC_DIGIT) && MODE >= CTC_SPACE &&
						MODE <= CTC_LITDIGIT) {
					COMPILEERROR(FILE,
							"MODE MUST BE \"UPPERCASE\", \"DIGIT\", OR A CUSTOM "
							"ATTRIBUTE NAME.");
					RETURN 0;
				}
				/* CHECK IF THIS MODE IS ALREADY DEFINED AND IF THE NUMBER OF MODES DOES
				 * NOT EXCEED THE MAXIMAL NUMBER */
				IF (MODE == CTC_UPPERCASE)
					I = 0;
				ELSE {
					FOR (I = 1; I < MAX_MODES && (*TABLE)->MODES[I].VALUE; I++) {
						IF ((*TABLE)->MODES[I].MODE == MODE) {
							BREAK;
						}
					}
					IF (I == MAX_MODES) {
						COMPILEERROR(FILE, "MAX NUMBER OF MODES (%I) REACHED", MAX_MODES);
						RETURN 0;
					}
				}
			}
			IF (!(*TABLE)->MODES[I].VALUE)
				(*TABLE)->MODES[I] = (EMPHASISCLASS){ PLAIN_TEXT, MODE,
					0X1 << (MAX_EMPH_CLASSES + I), MAX_EMPH_CLASSES + I };
			SWITCH (OPCODE) {
			CASE CTO_BEGMODEPHRASE: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][BEGPHRASEOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "FIRST WORD CAPITAL SIGN",
							CTO_BEGCAPSPHRASERULE + (8 * I), &RULEOFFSET, NOBACK, NOFOR,
							TABLE))
					RETURN 0;
				(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][BEGPHRASEOFFSET] = RULEOFFSET;
				RETURN 1;
			}
			CASE CTO_ENDMODEPHRASE: {
				TRANSLATIONTABLEOFFSET RULEOFFSET;
				SWITCH (COMPILEBEFOREAFTER(FILE)) {
				CASE 1:	 // BEFORE
					IF ((*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDPHRASEAFTEROFFSET]) {
						COMPILEERROR(
								FILE, "CAPITAL SIGN AFTER LAST WORD ALREADY DEFINED.");
						RETURN 0;
					}
					// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
					// TABLE
					RULEOFFSET = (*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I]
													[ENDPHRASEBEFOREOFFSET];
					IF (!COMPILEBRAILLEINDICATOR(FILE, "CAPITAL SIGN BEFORE LAST WORD",
								CTO_ENDCAPSPHRASEBEFORERULE + (8 * I), &RULEOFFSET,
								NOBACK, NOFOR, TABLE))
						RETURN 0;
					(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDPHRASEBEFOREOFFSET] =
							RULEOFFSET;
					RETURN 1;
				CASE 2:	 // AFTER
					IF ((*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I]
										   [ENDPHRASEBEFOREOFFSET]) {
						COMPILEERROR(
								FILE, "CAPITAL SIGN BEFORE LAST WORD ALREADY DEFINED.");
						RETURN 0;
					}
					// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
					// TABLE
					RULEOFFSET = (*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I]
													[ENDPHRASEAFTEROFFSET];
					IF (!COMPILEBRAILLEINDICATOR(FILE, "CAPITAL SIGN AFTER LAST WORD",
								CTO_ENDCAPSPHRASEAFTERRULE + (8 * I), &RULEOFFSET, NOBACK,
								NOFOR, TABLE))
						RETURN 0;
					(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDPHRASEAFTEROFFSET] =
							RULEOFFSET;
					RETURN 1;
				DEFAULT:  // ERROR
					COMPILEERROR(FILE, "INVALID LASTWORD INDICATOR LOCATION.");
					RETURN 0;
				}
				RETURN 0;
			}
			CASE CTO_BEGMODE: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][BEGOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "FIRST LETTER CAPITAL SIGN",
							CTO_BEGCAPSRULE + (8 * I), &RULEOFFSET, NOBACK, NOFOR, TABLE))
					RETURN 0;
				(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][BEGOFFSET] = RULEOFFSET;
				RETURN 1;
			}
			CASE CTO_ENDMODE: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "LAST LETTER CAPITAL SIGN",
							CTO_ENDCAPSRULE + (8 * I), &RULEOFFSET, NOBACK, NOFOR, TABLE))
					RETURN 0;
				(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDOFFSET] = RULEOFFSET;
				RETURN 1;
			}
			CASE CTO_MODELETTER: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][LETTEROFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "SINGLE LETTER CAPITAL SIGN",
							CTO_CAPSLETTERRULE + (8 * I), &RULEOFFSET, NOBACK, NOFOR,
							TABLE))
					RETURN 0;
				(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][LETTEROFFSET] = RULEOFFSET;
				RETURN 1;
			}
			CASE CTO_BEGMODEWORD: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][BEGWORDOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "CAPITAL WORD",
							CTO_BEGCAPSWORDRULE + (8 * I), &RULEOFFSET, NOBACK, NOFOR,
							TABLE))
					RETURN 0;
				(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][BEGWORDOFFSET] = RULEOFFSET;
				RETURN 1;
			}
			CASE CTO_ENDMODEWORD: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDWORDOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "CAPITAL WORD STOP",
							CTO_ENDCAPSWORDRULE + (8 * I), &RULEOFFSET, NOBACK, NOFOR,
							TABLE))
					RETURN 0;
				(*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][ENDWORDOFFSET] = RULEOFFSET;
				RETURN 1;
			}
			CASE CTO_LENMODEPHRASE:
				RETURN (*TABLE)->EMPHRULES[MAX_EMPH_CLASSES + I][LENPHRASEOFFSET] =
							   COMPILENUMBER(FILE);
			DEFAULT:
				BREAK;
			}
			BREAK;
		}

		/* THESE 8 GENERAL PURPOSE EMPHASIS OPCODES ARE COMPILED FURTHER DOWN TO MORE
		 * SPECIFIC INTERNAL OPCODES:
		 * - EMPHLETTER
		 * - BEGEMPHWORD
		 * - ENDEMPHWORD
		 * - BEGEMPH
		 * - ENDEMPH
		 * - BEGEMPHPHRASE
		 * - ENDEMPHPHRASE
		 * - LENEMPHPHRASE
		 */
		CASE CTO_EMPHCLASS:
			IF (!GETTOKEN(FILE, &EMPHCLASS, "EMPHASIS CLASS")) {
				COMPILEERROR(FILE, "EMPHCLASS MUST BE FOLLOWED BY A VALID CLASS NAME.");
				RETURN 0;
			}
			INT K, I;
			CHAR *S = MALLOC(SIZEOF(CHAR) * (EMPHCLASS.LENGTH + 1));
			FOR (K = 0; K < EMPHCLASS.LENGTH; K++) S[K] = (CHAR)EMPHCLASS.CHARS[K];
			S[K++] = '\0';
			FOR (I = 0; I < MAX_EMPH_CLASSES && (*TABLE)->EMPHCLASSNAMES[I]; I++)
				IF (STRCMP(S, (*TABLE)->EMPHCLASSNAMES[I]) == 0) {
					_LOU_LOGMESSAGE(LOU_LOG_WARN, "DUPLICATE EMPHASIS CLASS: %S", S);
					WARNINGCOUNT++;
					FREE(S);
					RETURN 1;
				}
			IF (I == MAX_EMPH_CLASSES) {
				_LOU_LOGMESSAGE(LOU_LOG_ERROR,
						"MAX NUMBER OF EMPHASIS CLASSES (%I) REACHED", MAX_EMPH_CLASSES);
				ERRORCOUNT++;
				FREE(S);
				RETURN 0;
			}
			SWITCH (I) {
			/* FOR BACKWARDS COMPATIBILITY (I.E. BECAUSE PROGRAMS WILL ASSUME
			 * THE FIRST 3 TYPEFORM BITS ARE `ITALIC', `UNDERLINE' AND `BOLD')
			 * WE REQUIRE THAT THE FIRST 3 EMPHCLASS DEFINITIONS ARE (IN THAT
			 * ORDER):
			 *
			 *   EMPHCLASS ITALIC
			 *   EMPHCLASS UNDERLINE
			 *   EMPHCLASS BOLD
			 *
			 * WHILE IT WOULD BE POSSIBLE TO USE THE EMPHCLASS OPCODE ONLY FOR
			 * DEFINING _ADDITIONAL_ CLASSES (NOT ALLOWING FOR THEM TO BE CALLED
			 * ITALIC, UNDERLINE OR BOLD), THEREBY REDUCING THE AMOUNT OF
			 * BOILERPLATE, WE DELIBERATELY CHOOSE NOT TO DO THAT IN ORDER TO
			 * NOT GIVE ITALIC, UNDERLINE AND BOLD ANY SPECIAL STATUS. THE
			 * HOPE IS THAT EVENTUALLY ALL PROGRAMS WILL USE LIBLOUIS FOR
			 * EMPHASIS THE RECOMMENDED WAY (I.E. BY LOOKING UP THE SUPPORTED
			 * TYPEFORMS IN THE DOCUMENTATION OR API) SO THAT WE CAN DROP THIS
			 * RESTRICTION.
			 */
			CASE 0:
				IF (STRCMP(S, "ITALIC") != 0) {
					_LOU_LOGMESSAGE(LOU_LOG_ERROR,
							"FIRST EMPHASIS CLASS MUST BE \"ITALIC\" BUT GOT "
							"%S",
							S);
					ERRORCOUNT++;
					FREE(S);
					RETURN 0;
				}
				BREAK;
			CASE 1:
				IF (STRCMP(S, "UNDERLINE") != 0) {
					_LOU_LOGMESSAGE(LOU_LOG_ERROR,
							"SECOND EMPHASIS CLASS MUST BE \"UNDERLINE\" BUT "
							"GOT "
							"%S",
							S);
					ERRORCOUNT++;
					FREE(S);
					RETURN 0;
				}
				BREAK;
			CASE 2:
				IF (STRCMP(S, "BOLD") != 0) {
					_LOU_LOGMESSAGE(LOU_LOG_ERROR,
							"THIRD EMPHASIS CLASS MUST BE \"BOLD\" BUT GOT "
							"%S",
							S);
					ERRORCOUNT++;
					FREE(S);
					RETURN 0;
				}
				BREAK;
			}
			(*TABLE)->EMPHCLASSNAMES[I] = S;
			(*TABLE)->EMPHCLASSES[I] = (EMPHASISCLASS){ EMPH_1
						<< I, /* RELIES ON THE ORDER OF TYPEFORMS EMPH_1..EMPH_10 */
				0, 0X1 << I, I };
			RETURN 1;
		CASE CTO_EMPHLETTER:
		CASE CTO_BEGEMPHWORD:
		CASE CTO_ENDEMPHWORD:
		CASE CTO_BEGEMPH:
		CASE CTO_ENDEMPH:
		CASE CTO_BEGEMPHPHRASE:
		CASE CTO_ENDEMPHPHRASE:
		CASE CTO_LENEMPHPHRASE:
		CASE CTO_EMPHMODECHARS:
		CASE CTO_NOEMPHCHARS: {
			IF (!GETTOKEN(FILE, &TOKEN, "EMPHASIS CLASS")) RETURN 0;
			IF (!PARSECHARS(FILE, &EMPHCLASS, &TOKEN)) RETURN 0;
			CHAR *S = MALLOC(SIZEOF(CHAR) * (EMPHCLASS.LENGTH + 1));
			INT K, I;
			FOR (K = 0; K < EMPHCLASS.LENGTH; K++) S[K] = (CHAR)EMPHCLASS.CHARS[K];
			S[K++] = '\0';
			FOR (I = 0; I < MAX_EMPH_CLASSES && (*TABLE)->EMPHCLASSNAMES[I]; I++)
				IF (STRCMP(S, (*TABLE)->EMPHCLASSNAMES[I]) == 0) BREAK;
			IF (I == MAX_EMPH_CLASSES || !(*TABLE)->EMPHCLASSNAMES[I]) {
				_LOU_LOGMESSAGE(LOU_LOG_ERROR, "EMPHASIS CLASS %S NOT DECLARED", S);
				ERRORCOUNT++;
				FREE(S);
				RETURN 0;
			}
			INT OK = 0;
			SWITCH (OPCODE) {
			CASE CTO_EMPHLETTER: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->EMPHRULES[I][LETTEROFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "SINGLE LETTER",
							CTO_EMPH1LETTERRULE + LETTEROFFSET + (8 * I), &RULEOFFSET,
							NOBACK, NOFOR, TABLE))
					BREAK;
				(*TABLE)->EMPHRULES[I][LETTEROFFSET] = RULEOFFSET;
				OK = 1;
				BREAK;
			}
			CASE CTO_BEGEMPHWORD: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->EMPHRULES[I][BEGWORDOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "WORD",
							CTO_EMPH1LETTERRULE + BEGWORDOFFSET + (8 * I), &RULEOFFSET,
							NOBACK, NOFOR, TABLE))
					BREAK;
				(*TABLE)->EMPHRULES[I][BEGWORDOFFSET] = RULEOFFSET;
				OK = 1;
				BREAK;
			}
			CASE CTO_ENDEMPHWORD: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->EMPHRULES[I][ENDWORDOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "WORD STOP",
							CTO_EMPH1LETTERRULE + ENDWORDOFFSET + (8 * I), &RULEOFFSET,
							NOBACK, NOFOR, TABLE))
					BREAK;
				(*TABLE)->EMPHRULES[I][ENDWORDOFFSET] = RULEOFFSET;
				OK = 1;
				BREAK;
			}
			CASE CTO_BEGEMPH: {
				/* FAIL IF BOTH BEGEMPH AND ANY OF BEGEMPHPHRASE OR BEGEMPHWORD ARE
				 * DEFINED */
				IF ((*TABLE)->EMPHRULES[I][BEGWORDOFFSET] ||
						(*TABLE)->EMPHRULES[I][BEGPHRASEOFFSET]) {
					COMPILEERROR(FILE,
							"CANNOT DEFINE EMPHASIS FOR BOTH NO CONTEXT AND WORD OR "
							"PHRASE CONTEXT, I.E. CANNOT HAVE BOTH BEGEMPH AND "
							"BEGEMPHWORD OR BEGEMPHPHRASE.");
					BREAK;
				}
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->EMPHRULES[I][BEGOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "FIRST LETTER",
							CTO_EMPH1LETTERRULE + BEGOFFSET + (8 * I), &RULEOFFSET,
							NOBACK, NOFOR, TABLE))
					BREAK;
				(*TABLE)->EMPHRULES[I][BEGOFFSET] = RULEOFFSET;
				OK = 1;
				BREAK;
			}
			CASE CTO_ENDEMPH: {
				IF ((*TABLE)->EMPHRULES[I][ENDWORDOFFSET] ||
						(*TABLE)->EMPHRULES[I][ENDPHRASEBEFOREOFFSET] ||
						(*TABLE)->EMPHRULES[I][ENDPHRASEAFTEROFFSET]) {
					COMPILEERROR(FILE,
							"CANNOT DEFINE EMPHASIS FOR BOTH NO CONTEXT AND WORD OR "
							"PHRASE CONTEXT, I.E. CANNOT HAVE BOTH ENDEMPH AND "
							"ENDEMPHWORD OR ENDEMPHPHRASE.");
					BREAK;
				}
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->EMPHRULES[I][ENDOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "LAST LETTER",
							CTO_EMPH1LETTERRULE + ENDOFFSET + (8 * I), &RULEOFFSET,
							NOBACK, NOFOR, TABLE))
					BREAK;
				(*TABLE)->EMPHRULES[I][ENDOFFSET] = RULEOFFSET;
				OK = 1;
				BREAK;
			}
			CASE CTO_BEGEMPHPHRASE: {
				// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
				// TABLE
				TRANSLATIONTABLEOFFSET RULEOFFSET =
						(*TABLE)->EMPHRULES[I][BEGPHRASEOFFSET];
				IF (!COMPILEBRAILLEINDICATOR(FILE, "FIRST WORD",
							CTO_EMPH1LETTERRULE + BEGPHRASEOFFSET + (8 * I), &RULEOFFSET,
							NOBACK, NOFOR, TABLE))
					BREAK;
				(*TABLE)->EMPHRULES[I][BEGPHRASEOFFSET] = RULEOFFSET;
				OK = 1;
				BREAK;
			}
			CASE CTO_ENDEMPHPHRASE:
				SWITCH (COMPILEBEFOREAFTER(FILE)) {
				CASE 1: {  // BEFORE
					IF ((*TABLE)->EMPHRULES[I][ENDPHRASEAFTEROFFSET]) {
						COMPILEERROR(FILE, "LAST WORD AFTER ALREADY DEFINED.");
						BREAK;
					}
					// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
					// TABLE
					TRANSLATIONTABLEOFFSET RULEOFFSET =
							(*TABLE)->EMPHRULES[I][ENDPHRASEBEFOREOFFSET];
					IF (!COMPILEBRAILLEINDICATOR(FILE, "LAST WORD BEFORE",
								CTO_EMPH1LETTERRULE + ENDPHRASEBEFOREOFFSET + (8 * I),
								&RULEOFFSET, NOBACK, NOFOR, TABLE))
						BREAK;
					(*TABLE)->EMPHRULES[I][ENDPHRASEBEFOREOFFSET] = RULEOFFSET;
					OK = 1;
					BREAK;
				}
				CASE 2: {  // AFTER
					IF ((*TABLE)->EMPHRULES[I][ENDPHRASEBEFOREOFFSET]) {
						COMPILEERROR(FILE, "LAST WORD BEFORE ALREADY DEFINED.");
						BREAK;
					}
					// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE
					// TABLE
					TRANSLATIONTABLEOFFSET RULEOFFSET =
							(*TABLE)->EMPHRULES[I][ENDPHRASEAFTEROFFSET];
					IF (!COMPILEBRAILLEINDICATOR(FILE, "LAST WORD AFTER",
								CTO_EMPH1LETTERRULE + ENDPHRASEAFTEROFFSET + (8 * I),
								&RULEOFFSET, NOBACK, NOFOR, TABLE))
						BREAK;
					(*TABLE)->EMPHRULES[I][ENDPHRASEAFTEROFFSET] = RULEOFFSET;
					OK = 1;
					BREAK;
				}
				DEFAULT:  // ERROR
					COMPILEERROR(FILE, "INVALID LASTWORD INDICATOR LOCATION.");
					BREAK;
				}
				BREAK;
			CASE CTO_LENEMPHPHRASE:
				IF (((*TABLE)->EMPHRULES[I][LENPHRASEOFFSET] = COMPILENUMBER(FILE)))
					OK = 1;
				BREAK;
			CASE CTO_EMPHMODECHARS: {
				IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) BREAK;
				WIDECHAR *EMPHMODECHARS = (*TABLE)->EMPHMODECHARS[I];
				INT LEN;
				FOR (LEN = 0; LEN < EMPHMODECHARSSIZE && EMPHMODECHARS[LEN]; LEN++)
					;
				IF (LEN + RULECHARS.LENGTH > EMPHMODECHARSSIZE) {
					COMPILEERROR(FILE, "MORE THAN %D CHARACTERS", EMPHMODECHARSSIZE);
					BREAK;
				}
				OK = 1;
				FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
					IF (!GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL)) {
						COMPILEERROR(FILE, "EMPHASIS MODE CHARACTER UNDEFINED");
						OK = 0;
						BREAK;
					}
					EMPHMODECHARS[LEN++] = RULECHARS.CHARS[K];
				}
				BREAK;
			}
			CASE CTO_NOEMPHCHARS: {
				IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) BREAK;
				WIDECHAR *NOEMPHCHARS = (*TABLE)->NOEMPHCHARS[I];
				INT LEN;
				FOR (LEN = 0; LEN < NOEMPHCHARSSIZE && NOEMPHCHARS[LEN]; LEN++)
					;
				IF (LEN + RULECHARS.LENGTH > NOEMPHCHARSSIZE) {
					COMPILEERROR(FILE, "MORE THAN %D CHARACTERS", NOEMPHCHARSSIZE);
					BREAK;
				}
				OK = 1;
				FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
					IF (!GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL)) {
						COMPILEERROR(FILE, "CHARACTER UNDEFINED");
						OK = 0;
						BREAK;
					}
					NOEMPHCHARS[LEN++] = RULECHARS.CHARS[K];
				}
				BREAK;
			}
			DEFAULT:
				BREAK;
			}
			FREE(S);
			RETURN OK;
		}
		CASE CTO_LETTERSIGN: {
			// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE TABLE
			TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->LETTERSIGN;
			IF (!COMPILEBRAILLEINDICATOR(FILE, "LETTER SIGN", CTO_LETTERRULE, &RULEOFFSET,
						NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->LETTERSIGN = RULEOFFSET;
			RETURN 1;
		}
		CASE CTO_NOLETSIGNBEFORE:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (((*TABLE)->NOLETSIGNBEFORECOUNT + RULECHARS.LENGTH) > LETSIGNBEFORESIZE) {
				COMPILEERROR(FILE, "MORE THAN %D CHARACTERS", LETSIGNBEFORESIZE);
				RETURN 0;
			}
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++)
				(*TABLE)->NOLETSIGNBEFORE[(*TABLE)->NOLETSIGNBEFORECOUNT++] =
						RULECHARS.CHARS[K];
			RETURN 1;
		CASE CTO_NOLETSIGN:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (((*TABLE)->NOLETSIGNCOUNT + RULECHARS.LENGTH) > LETSIGNSIZE) {
				COMPILEERROR(FILE, "MORE THAN %D CHARACTERS", LETSIGNSIZE);
				RETURN 0;
			}
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++)
				(*TABLE)->NOLETSIGN[(*TABLE)->NOLETSIGNCOUNT++] = RULECHARS.CHARS[K];
			RETURN 1;
		CASE CTO_NOLETSIGNAFTER:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (((*TABLE)->NOLETSIGNAFTERCOUNT + RULECHARS.LENGTH) > LETSIGNAFTERSIZE) {
				COMPILEERROR(FILE, "MORE THAN %D CHARACTERS", LETSIGNAFTERSIZE);
				RETURN 0;
			}
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++)
				(*TABLE)->NOLETSIGNAFTER[(*TABLE)->NOLETSIGNAFTERCOUNT++] =
						RULECHARS.CHARS[K];
			RETURN 1;
		CASE CTO_NUMBERSIGN: {
			// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE TABLE
			TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->NUMBERSIGN;
			IF (!COMPILEBRAILLEINDICATOR(FILE, "NUMBER SIGN", CTO_NUMBERRULE, &RULEOFFSET,
						NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->NUMBERSIGN = RULEOFFSET;
			RETURN 1;
		}

		CASE CTO_NUMERICMODECHARS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "NUMERIC MODE CHARACTER UNDEFINED: %S",
							_LOU_SHOWSTRING(&RULECHARS.CHARS[K], 1, 0));
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_NUMERICMODE;
				(*TABLE)->USESNUMERICMODE = 1;
			}
			RETURN 1;

		CASE CTO_MIDENDNUMERICMODECHARS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "MIDENDNUMERIC MODE CHARACTER UNDEFINED");
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_MIDENDNUMERICMODE;
				(*TABLE)->USESNUMERICMODE = 1;
			}
			RETURN 1;

		CASE CTO_NUMERICNOCONTRACTCHARS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "NUMERIC NO CONTRACTION CHARACTER UNDEFINED");
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_NUMERICNOCONTRACT;
				(*TABLE)->USESNUMERICMODE = 1;
			}
			RETURN 1;

		CASE CTO_NOCONTRACTSIGN: {
			// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE TABLE
			TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->NOCONTRACTSIGN;
			IF (!COMPILEBRAILLEINDICATOR(FILE, "NO CONTRACTIONS SIGN", CTO_NOCONTRACTRULE,
						&RULEOFFSET, NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->NOCONTRACTSIGN = RULEOFFSET;
			RETURN 1;
		}
		CASE CTO_SEQDELIMITER:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "SEQUENCE DELIMITER CHARACTER UNDEFINED");
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_SEQDELIMITER;
				(*TABLE)->USESSEQUENCES = 1;
			}
			RETURN 1;

		CASE CTO_SEQBEFORECHARS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "SEQUENCE BEFORE CHARACTER UNDEFINED");
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_SEQBEFORE;
			}
			RETURN 1;

		CASE CTO_SEQAFTERCHARS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "SEQUENCE AFTER CHARACTER UNDEFINED");
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_SEQAFTER;
			}
			RETURN 1;

		CASE CTO_SEQAFTERPATTERN:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (((*TABLE)->SEQPATTERNSCOUNT + RULECHARS.LENGTH + 1) > SEQPATTERNSIZE) {
				COMPILEERROR(FILE, "MORE THAN %D CHARACTERS", SEQPATTERNSIZE);
				RETURN 0;
			}
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++)
				(*TABLE)->SEQPATTERNS[(*TABLE)->SEQPATTERNSCOUNT++] = RULECHARS.CHARS[K];
			(*TABLE)->SEQPATTERNS[(*TABLE)->SEQPATTERNSCOUNT++] = 0;
			RETURN 1;

		CASE CTO_SEQAFTEREXPRESSION:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR ((*TABLE)->SEQAFTEREXPRESSIONLENGTH = 0;
					(*TABLE)->SEQAFTEREXPRESSIONLENGTH < RULECHARS.LENGTH;
					(*TABLE)->SEQAFTEREXPRESSIONLENGTH++)
				(*TABLE)->SEQAFTEREXPRESSION[(*TABLE)->SEQAFTEREXPRESSIONLENGTH] =
						RULECHARS.CHARS[(*TABLE)->SEQAFTEREXPRESSIONLENGTH];
			(*TABLE)->SEQAFTEREXPRESSION[(*TABLE)->SEQAFTEREXPRESSIONLENGTH] = 0;
			RETURN 1;

		CASE CTO_CAPSMODECHARS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!C) {
					COMPILEERROR(FILE, "CAPITAL MODE CHARACTER UNDEFINED");
					RETURN 0;
				}
				C->ATTRIBUTES |= CTC_CAPSMODE;
				(*TABLE)->HASCAPSMODECHARS = 1;
			}
			RETURN 1;

		CASE CTO_BEGCOMP: {
			// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE TABLE
			TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->BEGCOMP;
			IF (!COMPILEBRAILLEINDICATOR(FILE, "BEGIN COMPUTER BRAILLE", CTO_BEGCOMPRULE,
						&RULEOFFSET, NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->BEGCOMP = RULEOFFSET;
			RETURN 1;
		}
		CASE CTO_ENDCOMP: {
			// NOT PASSING POINTER BECAUSE COMPILEBRAILLEINDICATOR MAY REALLOCATE TABLE
			TRANSLATIONTABLEOFFSET RULEOFFSET = (*TABLE)->ENDCOMP;
			IF (!COMPILEBRAILLEINDICATOR(FILE, "END COMPUTER BRASLLE", CTO_ENDCOMPRULE,
						&RULEOFFSET, NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->ENDCOMP = RULEOFFSET;
			RETURN 1;
		}
		CASE CTO_NOCROSS:
			IF (NOCROSS) {
				COMPILEERROR(
						FILE, "%S ALREADY SPECIFIED.", _LOU_FINDOPCODENAME(CTO_NOCROSS));
				RETURN 0;
			}
			NOCROSS = 1;
			GOTO DOOPCODE;
		CASE CTO_SYLLABLE:
			(*TABLE)->SYLLABLES = 1;
		CASE CTO_ALWAYS:
		CASE CTO_LARGESIGN:
		CASE CTO_WHOLEWORD:
		CASE CTO_PARTWORD:
		CASE CTO_JOINNUM:
		CASE CTO_JOINABLEWORD:
		CASE CTO_LOWWORD:
		CASE CTO_SUFFIXABLEWORD:
		CASE CTO_PREFIXABLEWORD:
		CASE CTO_BEGWORD:
		CASE CTO_BEGMIDWORD:
		CASE CTO_MIDWORD:
		CASE CTO_MIDENDWORD:
		CASE CTO_ENDWORD:
		CASE CTO_PREPUNC:
		CASE CTO_POSTPUNC:
		CASE CTO_BEGNUM:
		CASE CTO_MIDNUM:
		CASE CTO_ENDNUM:
		CASE CTO_REPEATED:
		CASE CTO_REPWORD:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (!GETRULEDOTSPATTERN(FILE, &RULEDOTS)) RETURN 0;
			IF (RULEDOTS.LENGTH == 0)
				// CHECK THAT ALL CHARACTERS IN A RULE WITH `=` AS SECOND OPERAND ARE
				// DEFINED (OR BASED ON ANOTHER CHARACTER)
				FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
					TRANSLATIONTABLECHARACTER *C =
							GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
					IF (!(C && (C->DEFINITIONRULE || C->BASECHAR))) {
						COMPILEERROR(FILE, "CHARACTER %S IS NOT DEFINED",
								_LOU_SHOWSTRING(&RULECHARS.CHARS[K], 1, 0));
						RETURN 0;
					}
				}
			TRANSLATIONTABLERULE *R;
			IF (!ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, AFTER, BEFORE, NULL, &R,
						NOBACK, NOFOR, TABLE))
				RETURN 0;
			IF (NOCROSS) R->NOCROSS = 1;
			RETURN 1;
			// IF (OPCODE == CTO_MIDNUM)
			// {
			//   TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[0]);
			//   IF(C)
			//     C->ATTRIBUTES |= CTC_NUMERICMODE;
			// }
		CASE CTO_REPENDWORD:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			CHARSSTRING DOTS;
			IF (!GETTOKEN(FILE, &DOTS, "DOTS,DOTS OPERAND")) RETURN 0;
			INT LEN = DOTS.LENGTH;
			FOR (INT K = 0; K < LEN - 1; K++) {
				IF (DOTS.CHARS[K] == ',') {
					DOTS.LENGTH = K;
					IF (!PARSEDOTS(FILE, &RULEDOTS, &DOTS)) RETURN 0;
					RULEDOTS.CHARS[RULEDOTS.LENGTH++] = ',';
					K++;
					IF (K == LEN - 1 && DOTS.CHARS[K] == '=') {
						// CHECK THAT ALL CHARACTERS ARE DEFINED (OR BASED ON ANOTHER
						// CHARACTER)
						FOR (INT L = 0; L < RULECHARS.LENGTH; L++) {
							TRANSLATIONTABLECHARACTER *C =
									GETCHAR(RULECHARS.CHARS[L], *TABLE, NULL);
							IF (!(C && (C->DEFINITIONRULE || C->BASECHAR))) {
								COMPILEERROR(FILE, "CHARACTER %S IS NOT DEFINED",
										_LOU_SHOWSTRING(&RULECHARS.CHARS[L], 1, 0));
								RETURN 0;
							}
						}
					} ELSE {
						CHARSSTRING X, Y;
						X.LENGTH = 0;
						WHILE (K < LEN) X.CHARS[X.LENGTH++] = DOTS.CHARS[K++];
						IF (PARSEDOTS(FILE, &Y, &X))
							FOR (INT L = 0; L < Y.LENGTH; L++)
								RULEDOTS.CHARS[RULEDOTS.LENGTH++] = Y.CHARS[L];
					}
					RETURN ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, AFTER, BEFORE,
							NULL, NULL, NOBACK, NOFOR, TABLE);
				}
			}
			RETURN 0;
		CASE CTO_COMPDOTS:
		CASE CTO_COMP6: {
			TRANSLATIONTABLEOFFSET RULEOFFSET;
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (RULECHARS.LENGTH != 1) {
				COMPILEERROR(FILE, "FIRST OPERAND MUST BE 1 CHARACTER");
				RETURN 0;
			}
			IF (NOFOR || NOBACK) {
				COMPILEWARNING(FILE, "NOFOR AND NOBACK NOT ALLOWED ON COMP6 RULES");
			}
			IF (!GETRULEDOTSPATTERN(FILE, &RULEDOTS)) RETURN 0;
			IF (!ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, AFTER, BEFORE, &RULEOFFSET,
						NULL, NOBACK, NOFOR, TABLE))
				RETURN 0;
			RETURN 1;
		}
		CASE CTO_EXACTDOTS:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (RULECHARS.CHARS[0] != '@') {
				COMPILEERROR(FILE, "THE OPERAND MUST BEGIN WITH AN AT SIGN (@)");
				RETURN 0;
			}
			FOR (INT K = 1; K < RULECHARS.LENGTH; K++)
				SCRATCHPAD.CHARS[K - 1] = RULECHARS.CHARS[K];
			SCRATCHPAD.LENGTH = RULECHARS.LENGTH - 1;
			IF (!PARSEDOTS(FILE, &RULEDOTS, &SCRATCHPAD)) RETURN 0;
			RETURN ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, BEFORE, AFTER, NULL, NULL,
					NOBACK, NOFOR, TABLE);
		CASE CTO_CAPSNOCONT: {
			TRANSLATIONTABLEOFFSET RULEOFFSET;
			RULECHARS.LENGTH = 1;
			RULECHARS.CHARS[0] = 'A';
			IF (!ADDRULE(FILE, CTO_CAPSNOCONTRULE, &RULECHARS, NULL, AFTER, BEFORE,
						&RULEOFFSET, NULL, NOBACK, NOFOR, TABLE))
				RETURN 0;
			(*TABLE)->CAPSNOCONT = RULEOFFSET;
			RETURN 1;
		}
		CASE CTO_REPLACE:
			IF (GETRULECHARSTEXT(FILE, &RULECHARS)) {
				IF (ATENDOFLINE(FILE))
					RULEDOTS.LENGTH = RULEDOTS.CHARS[0] = 0;
				ELSE {
					GETRULEDOTSTEXT(FILE, &RULEDOTS);
					IF (RULEDOTS.CHARS[0] == '#')
						RULEDOTS.LENGTH = RULEDOTS.CHARS[0] = 0;
					ELSE IF (RULEDOTS.CHARS[0] == '\\' && RULEDOTS.CHARS[1] == '#')
						MEMMOVE(&RULEDOTS.CHARS[0], &RULEDOTS.CHARS[1],
								RULEDOTS.LENGTH-- * CHARSIZE);
				}
			}
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++)
				PUTCHAR(FILE, RULECHARS.CHARS[K], TABLE, NULL);
			FOR (INT K = 0; K < RULEDOTS.LENGTH; K++)
				PUTCHAR(FILE, RULEDOTS.CHARS[K], TABLE, NULL);
			RETURN ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, AFTER, BEFORE, NULL, NULL,
					NOBACK, NOFOR, TABLE);
		CASE CTO_CORRECT:
			(*TABLE)->CORRECTIONS = 1;
			GOTO DOPASS;
		CASE CTO_PASS2:
			IF ((*TABLE)->NUMPASSES < 2) (*TABLE)->NUMPASSES = 2;
			GOTO DOPASS;
		CASE CTO_PASS3:
			IF ((*TABLE)->NUMPASSES < 3) (*TABLE)->NUMPASSES = 3;
			GOTO DOPASS;
		CASE CTO_PASS4:
			IF ((*TABLE)->NUMPASSES < 4) (*TABLE)->NUMPASSES = 4;
		DOPASS:
		CASE CTO_CONTEXT:
			IF (!(NOFOR || NOBACK)) {
				COMPILEERROR(FILE, "%S OR %S MUST BE SPECIFIED.",
						_LOU_FINDOPCODENAME(CTO_NOFOR), _LOU_FINDOPCODENAME(CTO_NOBACK));
				RETURN 0;
			}
			RETURN COMPILEPASSOPCODE(FILE, OPCODE, NOBACK, NOFOR, TABLE);
		CASE CTO_CONTRACTION:
		CASE CTO_NOCONT:
		CASE CTO_COMPBRL:
		CASE CTO_LITERAL:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			// CHECK THAT ALL CHARACTERS IN A COMPBRL, CONTRACTION,
			// NOCONT OR LITERAL RULE ARE DEFINED (OR BASED ON ANOTHER
			// CHARACTER)
			FOR (INT K = 0; K < RULECHARS.LENGTH; K++) {
				TRANSLATIONTABLECHARACTER *C = GETCHAR(RULECHARS.CHARS[K], *TABLE, NULL);
				IF (!(C && (C->DEFINITIONRULE || C->BASECHAR))) {
					COMPILEERROR(FILE, "CHARACTER %S IS NOT DEFINED",
							_LOU_SHOWSTRING(&RULECHARS.CHARS[K], 1, 0));
					RETURN 0;
				}
			}
			RETURN ADDRULE(FILE, OPCODE, &RULECHARS, NULL, AFTER, BEFORE, NULL, NULL,
					NOBACK, NOFOR, TABLE);
		CASE CTO_MULTIND: {
			RULECHARS.LENGTH = 0;
			IF (!GETTOKEN(FILE, &TOKEN, "MULTIPLE BRAILLE INDICATORS") ||
					!PARSEDOTS(FILE, &CELLS, &TOKEN))
				RETURN 0;
			WHILE (GETTOKEN(FILE, &TOKEN, "MULTIND OPCODES")) {
				OPCODE = GETOPCODE(FILE, &TOKEN);
				IF (OPCODE == CTO_NONE) {
					COMPILEERROR(FILE, "OPCODE %S NOT DEFINED.",
							_LOU_SHOWSTRING(TOKEN.CHARS, TOKEN.LENGTH, 0));
					RETURN 0;
				}
				IF (!(OPCODE >= CTO_CAPSLETTER && OPCODE < CTO_MULTIND)) {
					COMPILEERROR(FILE, "NOT A BRAILLE INDICATOR OPCODE.");
					RETURN 0;
				}
				RULECHARS.CHARS[RULECHARS.LENGTH++] = (WIDECHAR)OPCODE;
				IF (ATENDOFLINE(FILE)) BREAK;
			}
			RETURN ADDRULE(FILE, CTO_MULTIND, &RULECHARS, &CELLS, AFTER, BEFORE, NULL,
					NULL, NOBACK, NOFOR, TABLE);
		}

		CASE CTO_CLASS:
			COMPILEWARNING(FILE, "CLASS IS DEPRECATED, USE ATTRIBUTE INSTEAD");
		CASE CTO_ATTRIBUTE: {
			IF (NOFOR || NOBACK) {
				COMPILEWARNING(
						FILE, "NOFOR AND NOBACK NOT ALLOWED BEFORE CLASS/ATTRIBUTE");
			}
			IF ((OPCODE == CTO_CLASS && (*TABLE)->USESATTRIBUTEORCLASS == 1) ||
					(OPCODE == CTO_ATTRIBUTE && (*TABLE)->USESATTRIBUTEORCLASS == 2)) {
				COMPILEERROR(FILE,
						"ATTRIBUTE AND CLASS RULES MUST NOT BE BOTH PRESENT IN A TABLE");
				RETURN 0;
			}
			IF (OPCODE == CTO_CLASS)
				(*TABLE)->USESATTRIBUTEORCLASS = 2;
			ELSE
				(*TABLE)->USESATTRIBUTEORCLASS = 1;
			IF (!GETTOKEN(FILE, &TOKEN, "ATTRIBUTE NAME")) {
				COMPILEERROR(FILE, "EXPECTED %S", "ATTRIBUTE NAME");
				RETURN 0;
			}
			IF (!(*TABLE)->CHARACTERCLASSES && !ALLOCATECHARACTERCLASSES(*TABLE)) {
				RETURN 0;
			}

			TRANSLATIONTABLECHARACTERATTRIBUTES ATTRIBUTE = 0;
			{
				INT ATTRNUMBER = -1;
				SWITCH (TOKEN.CHARS[0]) {
				CASE '0':
				CASE '1':
				CASE '2':
				CASE '3':
				CASE '4':
				CASE '5':
				CASE '6':
				CASE '7':
				CASE '8':
				CASE '9':
					ATTRNUMBER = TOKEN.CHARS[0] - '0';
					BREAK;
				}
				IF (ATTRNUMBER >= 0) {
					IF (OPCODE == CTO_CLASS) {
						COMPILEERROR(FILE,
								"INVALID CLASS NAME: MAY NOT CONTAIN DIGITS, USE "
								"ATTRIBUTE INSTEAD OF CLASS");
						RETURN 0;
					}
					IF (TOKEN.LENGTH > 1 || ATTRNUMBER > 7) {
						COMPILEERROR(FILE,
								"INVALID ATTRIBUTE NAME: MUST BE A DIGIT BETWEEN 0 AND 7 "
								"OR A WORD CONTAINING ONLY LETTERS");
						RETURN 0;
					}
					IF (!(*TABLE)->NUMBEREDATTRIBUTES[ATTRNUMBER])
						// ATTRIBUTE NOT USED BEFORE YET: ASSIGN IT A VALUE
						(*TABLE)->NUMBEREDATTRIBUTES[ATTRNUMBER] =
								GETNEXTNUMBEREDATTRIBUTE(*TABLE);
					ATTRIBUTE = (*TABLE)->NUMBEREDATTRIBUTES[ATTRNUMBER];
				} ELSE {
					CONST CHARACTERCLASS *NAMEDATTR = FINDCHARACTERCLASS(&TOKEN, *TABLE);
					IF (!NAMEDATTR) {
						// NO CLASS WITH THAT NAME: CREATE ONE
						NAMEDATTR = ADDCHARACTERCLASS(
								FILE, &TOKEN.CHARS[0], TOKEN.LENGTH, *TABLE, 1);
						IF (!NAMEDATTR) RETURN 0;
					}
					// THERE IS A CLASS WITH THAT NAME OR A NEW CLASS WAS SUCCESSFULLY
					// CREATED
					ATTRIBUTE = NAMEDATTR->ATTRIBUTE;
					IF (ATTRIBUTE == CTC_UPPERCASE || ATTRIBUTE == CTC_LOWERCASE)
						ATTRIBUTE |= CTC_LETTER;
				}
			}
			CHARSSTRING CHARACTERS;
			IF (!GETCHARACTERS(FILE, &CHARACTERS)) RETURN 0;
			FOR (INT I = 0; I < CHARACTERS.LENGTH; I++) {
				// GET THE CHARACTER FROM THE TABLE, OR IF IT IS NOT DEFINED YET,
				// DEFINE IT
				TRANSLATIONTABLECHARACTER *CHARACTER =
						PUTCHAR(FILE, CHARACTERS.CHARS[I], TABLE, NULL);
				// SET THE ATTRIBUTE
				CHARACTER->ATTRIBUTES |= ATTRIBUTE;
				// ALSO SET THE ATTRIBUTE ON THE ASSOCIATED DOTS (IF ANY)
				IF (CHARACTER->BASECHAR)
					CHARACTER = (TRANSLATIONTABLECHARACTER *)&(*TABLE)
										->RULEAREA[CHARACTER->BASECHAR];
				IF (CHARACTER->DEFINITIONRULE) {
					TRANSLATIONTABLERULE *DEFRULE =
							(TRANSLATIONTABLERULE *)&(*TABLE)
									->RULEAREA[CHARACTER->DEFINITIONRULE];
					IF (DEFRULE->DOTSLEN == 1) {
						TRANSLATIONTABLECHARACTER *DOTS =
								GETDOTS(DEFRULE->CHARSDOTS[DEFRULE->CHARSLEN], *TABLE);
						IF (DOTS) DOTS->ATTRIBUTES |= ATTRIBUTE;
					}
				}
			}
			RETURN 1;
		}

			{
				TRANSLATIONTABLECHARACTERATTRIBUTES *ATTRIBUTES;
				CONST CHARACTERCLASS *CLASS;
			CASE CTO_AFTER:
				ATTRIBUTES = &AFTER;
				GOTO DOBEFOREAFTER;
			CASE CTO_BEFORE:
				ATTRIBUTES = &BEFORE;
			DOBEFOREAFTER:
				IF (!(*TABLE)->CHARACTERCLASSES) {
					IF (!ALLOCATECHARACTERCLASSES(*TABLE)) RETURN 0;
				}
				IF (!GETTOKEN(FILE, &TOKEN, "ATTRIBUTE NAME")) RETURN 0;
				IF (!(CLASS = FINDCHARACTERCLASS(&TOKEN, *TABLE))) {
					COMPILEERROR(FILE, "ATTRIBUTE NOT DEFINED");
					RETURN 0;
				}
				*ATTRIBUTES |= CLASS->ATTRIBUTE;
				GOTO DOOPCODE;
			}
		CASE CTO_BASE:
			IF (NOFOR || NOBACK) {
				COMPILEWARNING(FILE, "NOFOR AND NOBACK NOT ALLOWED BEFORE BASE");
			}
			IF (!GETTOKEN(FILE, &TOKEN, "ATTRIBUTE NAME")) {
				COMPILEERROR(
						FILE, "BASE OPCODE MUST BE FOLLOWED BY A VALID ATTRIBUTE NAME.");
				RETURN 0;
			}
			IF (!(*TABLE)->CHARACTERCLASSES && !ALLOCATECHARACTERCLASSES(*TABLE)) {
				RETURN 0;
			}
			CONST CHARACTERCLASS *MODE = FINDCHARACTERCLASS(&TOKEN, *TABLE);
			IF (!MODE) {
				MODE = ADDCHARACTERCLASS(FILE, TOKEN.CHARS, TOKEN.LENGTH, *TABLE, 1);
				IF (!MODE) RETURN 0;
			}
			IF (!(MODE->ATTRIBUTE == CTC_UPPERCASE || MODE->ATTRIBUTE == CTC_DIGIT) &&
					MODE->ATTRIBUTE >= CTC_SPACE && MODE->ATTRIBUTE <= CTC_LITDIGIT) {
				COMPILEERROR(FILE,
						"BASE OPCODE MUST BE FOLLOWED BY \"UPPERCASE\", \"DIGIT\", OR A "
						"CUSTOM ATTRIBUTE NAME.");
				RETURN 0;
			}
			IF (!GETRULECHARSTEXT(FILE, &TOKEN)) RETURN 0;
			IF (TOKEN.LENGTH != 1) {
				COMPILEERROR(FILE,
						"EXACTLY ONE CHARACTER FOLLOWED BY ONE BASE CHARACTER IS "
						"REQUIRED.");
				RETURN 0;
			}
			TRANSLATIONTABLEOFFSET CHARACTEROFFSET;
			TRANSLATIONTABLECHARACTER *CHARACTER =
					PUTCHAR(FILE, TOKEN.CHARS[0], TABLE, &CHARACTEROFFSET);
			IF (!GETRULECHARSTEXT(FILE, &TOKEN)) RETURN 0;
			IF (TOKEN.LENGTH != 1) {
				COMPILEERROR(FILE, "EXACTLY ONE BASE CHARACTER IS REQUIRED.");
				RETURN 0;
			}
			IF (CHARACTER->DEFINITIONRULE) {
				TRANSLATIONTABLERULE *PREVRULE =
						(TRANSLATIONTABLERULE *)&(*TABLE)
								->RULEAREA[CHARACTER->DEFINITIONRULE];
				_LOU_LOGMESSAGE(LOU_LOG_DEBUG,
						"%S:%D: CHARACTER ALREADY DEFINED (%S). THE BASE RULE WILL TAKE "
						"PRECEDENCE.",
						FILE->FILENAME, FILE->LINENUMBER,
						PRINTSOURCE(FILE, PREVRULE->SOURCEFILE, PREVRULE->SOURCELINE));
				CHARACTER->DEFINITIONRULE = 0;
			}
			TRANSLATIONTABLEOFFSET BASECHAR;
			PUTCHAR(FILE, TOKEN.CHARS[0], TABLE, &BASECHAR);
			// PUTCHAR MAY HAVE MOVED TABLE, SO MAKE SURE CHARACTER IS STILL VALID
			CHARACTER = (TRANSLATIONTABLECHARACTER *)&(*TABLE)->RULEAREA[CHARACTEROFFSET];
			IF (CHARACTER->BASECHAR) {
				IF (CHARACTER->BASECHAR == BASECHAR &&
						CHARACTER->MODE == MODE->ATTRIBUTE) {
					_LOU_LOGMESSAGE(LOU_LOG_DEBUG, "%S:%D: DUPLICATE BASE RULE.",
							FILE->FILENAME, FILE->LINENUMBER);
				} ELSE {
					_LOU_LOGMESSAGE(LOU_LOG_DEBUG,
							"%S:%D: A DIFFERENT BASE RULE ALREADY EXISTS FOR THIS "
							"CHARACTER (%S). THE NEW RULE WILL TAKE PRECEDENCE.",
							FILE->FILENAME, FILE->LINENUMBER,
							PRINTSOURCE(
									FILE, CHARACTER->SOURCEFILE, CHARACTER->SOURCELINE));
				}
			}
			CHARACTER->BASECHAR = BASECHAR;
			CHARACTER->MODE = MODE->ATTRIBUTE;
			CHARACTER->SOURCEFILE = FILE->SOURCEFILE;
			CHARACTER->SOURCELINE = FILE->LINENUMBER;
			/* SOME OTHER PROCESSING IS DONE AT THE END OF THE COMPILATION, IN
			 * FINALIZETABLE() */
			RETURN 1;
		CASE CTO_EMPMATCHBEFORE:
			BEFORE |= CTC_EMPMATCH;
			GOTO DOOPCODE;
		CASE CTO_EMPMATCHAFTER:
			AFTER |= CTC_EMPMATCH;
			GOTO DOOPCODE;

		CASE CTO_SWAPCC:
		CASE CTO_SWAPCD:
		CASE CTO_SWAPDD:
			RETURN COMPILESWAP(FILE, OPCODE, NOBACK, NOFOR, TABLE);
		CASE CTO_HYPHEN:
		CASE CTO_DECPOINT:
			//	CASE CTO_APOSTROPHE:
			//	CASE CTO_INITIAL:
			IF (!GETRULECHARSTEXT(FILE, &RULECHARS)) RETURN 0;
			IF (!GETRULEDOTSPATTERN(FILE, &RULEDOTS)) RETURN 0;
			IF (RULECHARS.LENGTH != 1 || RULEDOTS.LENGTH < 1) {
				COMPILEERROR(FILE,
						"ONE UNICODE CHARACTER AND AT LEAST ONE CELL ARE "
						"REQUIRED.");
				RETURN 0;
			}
			RETURN ADDRULE(FILE, OPCODE, &RULECHARS, &RULEDOTS, AFTER, BEFORE, NULL, NULL,
					NOBACK, NOFOR, TABLE);
			// IF (OPCODE == CTO_DECPOINT)
			// {
			//   TRANSLATIONTABLECHARACTER *C =
			//   GETCHAR(RULECHARS.CHARS[0]);
			//   IF(C)
			//     C->ATTRIBUTES |= CTC_NUMERICMODE;
			// }
		DEFAULT:
			COMPILEERROR(FILE, "UNIMPLEMENTED OPCODE.");
			RETURN 0;
		}
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206989_CWE-74.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
APPLY_EXTRA_DATA (FLATPAKDIR   *SELF,
                  GFILE        *CHECKOUTDIR,
                  GCANCELLABLE *CANCELLABLE,
                  GERROR      **ERROR)
{
  G_AUTOPTR(GFILE) METADATA = NULL;
  G_AUTOFREE CHAR *METADATA_CONTENTS = NULL;
  GSIZE METADATA_SIZE;
  G_AUTOPTR(GKEYFILE) METAKEY = NULL;
  G_AUTOFREE CHAR *ID = NULL;
  G_AUTOFREE CHAR *RUNTIME_PREF = NULL;
  G_AUTOPTR(FLATPAKDECOMPOSED) RUNTIME_REF = NULL;
  G_AUTOPTR(FLATPAKDEPLOY) RUNTIME_DEPLOY = NULL;
  G_AUTOPTR(FLATPAKBWRAP) BWRAP = NULL;
  G_AUTOPTR(GFILE) APP_FILES = NULL;
  G_AUTOPTR(GFILE) APPLY_EXTRA_FILE = NULL;
  G_AUTOPTR(GFILE) APP_EXPORT_FILE = NULL;
  G_AUTOPTR(GFILE) EXTRA_EXPORT_FILE = NULL;
  G_AUTOPTR(GFILE) EXTRA_FILES = NULL;
  G_AUTOPTR(GFILE) RUNTIME_FILES = NULL;
  G_AUTOPTR(FLATPAKCONTEXT) APP_CONTEXT = NULL;
  G_AUTO(GSTRV) MINIMAL_ENVP = NULL;
  G_AUTOFREE CHAR *RUNTIME_ARCH = NULL;
  INT EXIT_STATUS;
  CONST CHAR *GROUP = FLATPAK_METADATA_GROUP_APPLICATION;
  G_AUTOPTR(GERROR) LOCAL_ERROR = NULL;

  APPLY_EXTRA_FILE = G_FILE_RESOLVE_RELATIVE_PATH (CHECKOUTDIR, "FILES/BIN/APPLY_EXTRA");
  IF (!G_FILE_QUERY_EXISTS (APPLY_EXTRA_FILE, CANCELLABLE))
    RETURN TRUE;

  METADATA = G_FILE_GET_CHILD (CHECKOUTDIR, "METADATA");

  IF (!G_FILE_LOAD_CONTENTS (METADATA, CANCELLABLE, &METADATA_CONTENTS, &METADATA_SIZE, NULL, ERROR))
    RETURN FALSE;

  METAKEY = G_KEY_FILE_NEW ();
  IF (!G_KEY_FILE_LOAD_FROM_DATA (METAKEY, METADATA_CONTENTS, METADATA_SIZE, 0, ERROR))
    RETURN FALSE;

  ID = G_KEY_FILE_GET_STRING (METAKEY, GROUP, FLATPAK_METADATA_KEY_NAME,
                              &LOCAL_ERROR);
  IF (ID == NULL)
    {
      GROUP = FLATPAK_METADATA_GROUP_RUNTIME;
      ID = G_KEY_FILE_GET_STRING (METAKEY, GROUP, FLATPAK_METADATA_KEY_NAME,
                                  NULL);
      IF (ID == NULL)
        {
          G_PROPAGATE_ERROR (ERROR, G_STEAL_POINTER (&LOCAL_ERROR));
          RETURN FALSE;
        }
      G_CLEAR_ERROR (&LOCAL_ERROR);
    }

  RUNTIME_PREF = G_KEY_FILE_GET_STRING (METAKEY, GROUP,
                                        FLATPAK_METADATA_KEY_RUNTIME, ERROR);
  IF (RUNTIME_PREF == NULL)
    RUNTIME_PREF = G_KEY_FILE_GET_STRING (METAKEY, FLATPAK_METADATA_GROUP_EXTENSION_OF,
                                          FLATPAK_METADATA_KEY_RUNTIME, NULL);
  IF (RUNTIME_PREF == NULL)
    RETURN FALSE;

  RUNTIME_REF = FLATPAK_DECOMPOSED_NEW_FROM_PREF (FLATPAK_KINDS_RUNTIME, RUNTIME_PREF, ERROR);
  IF (RUNTIME_REF == NULL)
    RETURN FALSE;
  RUNTIME_ARCH = FLATPAK_DECOMPOSED_DUP_ARCH (RUNTIME_REF);

  IF (!G_KEY_FILE_GET_BOOLEAN (METAKEY, FLATPAK_METADATA_GROUP_EXTRA_DATA,
                               FLATPAK_METADATA_KEY_NO_RUNTIME, NULL))
    {
      /* WE PASS IN SELF HERE SO THAT WE ENSURE THAT WE FIND THE RUNTIME IN CASE IT ONLY
         EXISTS IN THIS INSTALLATION (WHICH MIGHT BE CUSTOM) */
      RUNTIME_DEPLOY = FLATPAK_FIND_DEPLOY_FOR_REF (FLATPAK_DECOMPOSED_GET_REF (RUNTIME_REF), NULL, SELF, CANCELLABLE, ERROR);
      IF (RUNTIME_DEPLOY == NULL)
        RETURN FALSE;
      RUNTIME_FILES = FLATPAK_DEPLOY_GET_FILES (RUNTIME_DEPLOY);
    }

  APP_FILES = G_FILE_GET_CHILD (CHECKOUTDIR, "FILES");
  APP_EXPORT_FILE = G_FILE_GET_CHILD (CHECKOUTDIR, "EXPORT");
  EXTRA_FILES = G_FILE_GET_CHILD (APP_FILES, "EXTRA");
  EXTRA_EXPORT_FILE = G_FILE_GET_CHILD (EXTRA_FILES, "EXPORT");

  MINIMAL_ENVP = FLATPAK_RUN_GET_MINIMAL_ENV (FALSE, FALSE);
  BWRAP = FLATPAK_BWRAP_NEW (MINIMAL_ENVP);
  FLATPAK_BWRAP_ADD_ARGS (BWRAP, FLATPAK_GET_BWRAP (), NULL);

  IF (RUNTIME_FILES)
    FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                            "--RO-BIND", FLATPAK_FILE_GET_PATH_CACHED (RUNTIME_FILES), "/USR",
                            "--LOCK-FILE", "/USR/.REF",
                            NULL);

  FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                          "--RO-BIND", FLATPAK_FILE_GET_PATH_CACHED (APP_FILES), "/APP",
                          "--BIND", FLATPAK_FILE_GET_PATH_CACHED (EXTRA_FILES), "/APP/EXTRA",
                          "--CHDIR", "/APP/EXTRA",
                          /* WE RUN AS ROOT IN THE SYSTEM-HELPER CASE, SO DROP ALL CAPS */
                          "--CAP-DROP", "ALL",
                          NULL);

  IF (!FLATPAK_RUN_SETUP_BASE_ARGV (BWRAP, RUNTIME_FILES, NULL, RUNTIME_ARCH,
                                    /* MIGHT NEED MULTIARCH IN APPLY_EXTRA (SEE E.G. #3742). SHOULD BE PRETTY SAFE IN THIS LIMITED CONTEXT */
                                    FLATPAK_RUN_FLAG_MULTIARCH |
                                    FLATPAK_RUN_FLAG_NO_SESSION_HELPER | FLATPAK_RUN_FLAG_NO_PROC,
                                    ERROR))
    RETURN FALSE;

  APP_CONTEXT = FLATPAK_CONTEXT_NEW ();

  IF (!FLATPAK_RUN_ADD_ENVIRONMENT_ARGS (BWRAP, NULL,
                                         FLATPAK_RUN_FLAG_NO_SESSION_BUS_PROXY |
                                         FLATPAK_RUN_FLAG_NO_SYSTEM_BUS_PROXY |
                                         FLATPAK_RUN_FLAG_NO_A11Y_BUS_PROXY,
                                         ID,
                                         APP_CONTEXT, NULL, NULL, NULL, CANCELLABLE, ERROR))
    RETURN FALSE;

  FLATPAK_BWRAP_ADD_ARG (BWRAP, "/APP/BIN/APPLY_EXTRA");

  FLATPAK_BWRAP_FINISH (BWRAP);

  G_DEBUG ("RUNNING /APP/BIN/APPLY_EXTRA ");

  /* WE RUN THE SANDBOX WITHOUT CAPS, BUT IT CAN STILL CREATE FILES OWNED BY ITSELF WITH
   * ARBITRARY PERMISSIONS, INCLUDING SETUID MYSELF. THIS IS EXTRA RISKY IN THE CASE WHERE
   * THIS RUNS AS ROOT IN THE SYSTEM HELPER CASE. WE CANONICALIZE THE PERMISSIONS AT THE
   * END, BUT TO AVOID NON-CANONICAL PERMISSIONS LEAKING OUT BEFORE THEN WE MAKE THE
   * TOPLEVEL DIR ONLY ACCESSIBLE TO THE USER */
  IF (CHMOD (FLATPAK_FILE_GET_PATH_CACHED (EXTRA_FILES), 0700) != 0)
    {
      GLNX_SET_ERROR_FROM_ERRNO (ERROR);
      RETURN FALSE;
    }

  IF (!G_SPAWN_SYNC (NULL,
                     (CHAR **) BWRAP->ARGV->PDATA,
                     BWRAP->ENVP,
                     G_SPAWN_SEARCH_PATH,
                     CHILD_SETUP, BWRAP->FDS,
                     NULL, NULL,
                     &EXIT_STATUS,
                     ERROR))
    RETURN FALSE;

  IF (!FLATPAK_CANONICALIZE_PERMISSIONS (AT_FDCWD, FLATPAK_FILE_GET_PATH_CACHED (EXTRA_FILES),
                                         GETUID () == 0 ? 0 : -1,
                                         GETUID () == 0 ? 0 : -1,
                                         ERROR))
    RETURN FALSE;

  IF (EXIT_STATUS != 0)
    {
      G_SET_ERROR (ERROR, G_IO_ERROR, G_IO_ERROR_FAILED,
                   _("APPLY_EXTRA SCRIPT FAILED, EXIT STATUS %D"), EXIT_STATUS);
      RETURN FALSE;
    }

  IF (G_FILE_QUERY_EXISTS (EXTRA_EXPORT_FILE, CANCELLABLE))
    {
      IF (!FLATPAK_MKDIR_P (APP_EXPORT_FILE, CANCELLABLE, ERROR))
        RETURN FALSE;
      IF (!FLATPAK_CP_A (EXTRA_EXPORT_FILE,
                         APP_EXPORT_FILE,
                         FLATPAK_CP_FLAGS_MERGE,
                         CANCELLABLE, ERROR))
        RETURN FALSE;
    }

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369185_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IO_FALLOCATE_PREP(STRUCT IO_KIOCB *REQ,
			     CONST STRUCT IO_URING_SQE *SQE)
{
	IF (SQE->IOPRIO || SQE->BUF_INDEX || SQE->RW_FLAGS ||
	    SQE->SPLICE_FD_IN)
		RETURN -EINVAL;
	IF (UNLIKELY(REQ->CTX->FLAGS & IORING_SETUP_IOPOLL))
		RETURN -EINVAL;

	REQ->SYNC.OFF = READ_ONCE(SQE->OFF);
	REQ->SYNC.LEN = READ_ONCE(SQE->ADDR);
	REQ->SYNC.MODE = READ_ONCE(SQE->LEN);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 398532_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RZ_API CONST CHAR *RZ_BIN_DWARF_GET_ATTR_NAME(UT64 ATTR_CODE) {
	IF (ATTR_CODE < RZ_ARRAY_SIZE(DWARF_ATTR_ENCODINGS)) {
		RETURN DWARF_ATTR_ENCODINGS[ATTR_CODE];
	}
	// THE BELOW CODES ARE MUCH SPARSER, SO PUTTING THEM IN AN ARRAY WOULD REQUIRE A LOT OF
	// UNUSED MEMORY
	SWITCH (ATTR_CODE) {
	CASE DW_AT_LO_USER:
		RETURN "DW_AT_LO_USER";
	CASE DW_AT_MIPS_LINKAGE_NAME:
		RETURN "DW_AT_MIPS_LINKAGE_NAME";
	CASE DW_AT_GNU_CALL_SITE_VALUE:
		RETURN "DW_AT_GNU_CALL_SITE_VALUE";
	CASE DW_AT_GNU_CALL_SITE_DATA_VALUE:
		RETURN "DW_AT_GNU_CALL_SITE_DATA_VALUE";
	CASE DW_AT_GNU_CALL_SITE_TARGET:
		RETURN "DW_AT_GNU_CALL_SITE_TARGET";
	CASE DW_AT_GNU_CALL_SITE_TARGET_CLOBBERED:
		RETURN "DW_AT_GNU_CALL_SITE_TARGET_CLOBBERED";
	CASE DW_AT_GNU_TAIL_CALL:
		RETURN "DW_AT_GNU_TAIL_CALL";
	CASE DW_AT_GNU_ALL_TAIL_CALL_SITES:
		RETURN "DW_AT_GNU_ALL_TAIL_CALL_SITES";
	CASE DW_AT_GNU_ALL_CALL_SITES:
		RETURN "DW_AT_GNU_ALL_CALL_SITES";
	CASE DW_AT_GNU_ALL_SOURCE_CALL_SITES:
		RETURN "DW_AT_GNU_ALL_SOURCE_CALL_SITES";
	CASE DW_AT_GNU_MACROS:
		RETURN "DW_AT_GNU_MACROS";
	CASE DW_AT_GNU_DELETED:
		RETURN "DW_AT_GNU_DELETED";
	CASE DW_AT_GNU_DWO_NAME:
		RETURN "DW_AT_GNU_DWO_NAME";
	CASE DW_AT_GNU_DWO_ID:
		RETURN "DW_AT_GNU_DWO_ID";
	CASE DW_AT_GNU_RANGES_BASE:
		RETURN "DW_AT_GNU_RANGES_BASE";
	CASE DW_AT_GNU_ADDR_BASE:
		RETURN "DW_AT_GNU_ADDR_BASE";
	CASE DW_AT_GNU_PUBNAMES:
		RETURN "DW_AT_GNU_PUBNAMES";
	CASE DW_AT_GNU_PUBTYPES:
		RETURN "DW_AT_GNU_PUBTYPES";
	CASE DW_AT_HI_USER:
		RETURN "DW_AT_HI_USER";
	DEFAULT:
		RETURN NULL;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211155_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT TCP_EMU(STRUCT SOCKET *SO, STRUCT MBUF *M)
{
    SLIRP *SLIRP = SO->SLIRP;
    UNSIGNED N1, N2, N3, N4, N5, N6;
    CHAR BUFF[257];
    UINT32_T LADDR;
    UNSIGNED LPORT;
    CHAR *BPTR;

    DEBUG_CALL("TCP_EMU");
    DEBUG_ARG("SO = %P", SO);
    DEBUG_ARG("M = %P", M);

    SWITCH (SO->SO_EMU) {
        INT X, I;

        /* TODO: IPV6 */
    CASE EMU_IDENT:
        /*
         * IDENTIFICATION PROTOCOL AS PER RFC-1413
         */

        {
            STRUCT SOCKET *TMPSO;
            STRUCT SOCKADDR_IN ADDR;
            SOCKLEN_T ADDRLEN = SIZEOF(STRUCT SOCKADDR_IN);
            CHAR *EOL = G_STRSTR_LEN(M->M_DATA, M->M_LEN, "\R\N");

            IF (!EOL) {
                RETURN 1;
            }

            *EOL = '\0';
            IF (SSCANF(M->M_DATA, "%U%*[ ,]%U", &N1, &N2) == 2) {
                HTONS(N1);
                HTONS(N2);
                /* N2 IS THE ONE ON OUR HOST */
                FOR (TMPSO = SLIRP->TCB.SO_NEXT; TMPSO != &SLIRP->TCB;
                     TMPSO = TMPSO->SO_NEXT) {
                    IF (TMPSO->SO_LADDR.S_ADDR == SO->SO_LADDR.S_ADDR &&
                        TMPSO->SO_LPORT == N2 &&
                        TMPSO->SO_FADDR.S_ADDR == SO->SO_FADDR.S_ADDR &&
                        TMPSO->SO_FPORT == N1) {
                        IF (GETSOCKNAME(TMPSO->S, (STRUCT SOCKADDR *)&ADDR,
                                        &ADDRLEN) == 0)
                            N2 = ADDR.SIN_PORT;
                        BREAK;
                    }
                }
                NTOHS(N1);
                NTOHS(N2);
                M_INC(M, SNPRINTF(NULL, 0, "%D,%D\R\N", N1, N2) + 1);
                M->M_LEN = SNPRINTF(M->M_DATA, M_ROOM(M), "%D,%D\R\N", N1, N2);
                ASSERT(M->M_LEN < M_ROOM(M));
            } ELSE {
                *EOL = '\R';
            }

            RETURN 1;
        }

    CASE EMU_FTP: /* FTP */
        M_INC(M, M->M_LEN + 1);
        *(M->M_DATA + M->M_LEN) = 0; /* NUL TERMINATE FOR STRSTR */
        IF ((BPTR = (CHAR *)STRSTR(M->M_DATA, "ORT")) != NULL) {
            /*
             * NEED TO EMULATE THE PORT COMMAND
             */
            X = SSCANF(BPTR, "ORT %U,%U,%U,%U,%U,%U\R\N%256[^\177]", &N1, &N2,
                       &N3, &N4, &N5, &N6, BUFF);
            IF (X < 6)
                RETURN 1;

            LADDR = HTONL((N1 << 24) | (N2 << 16) | (N3 << 8) | (N4));
            LPORT = HTONS((N5 << 8) | (N6));

            IF ((SO = TCP_LISTEN(SLIRP, INADDR_ANY, 0, LADDR, LPORT,
                                 SS_FACCEPTONCE)) == NULL) {
                RETURN 1;
            }
            N6 = NTOHS(SO->SO_FPORT);

            N5 = (N6 >> 8) & 0XFF;
            N6 &= 0XFF;

            LADDR = NTOHL(SO->SO_FADDR.S_ADDR);

            N1 = ((LADDR >> 24) & 0XFF);
            N2 = ((LADDR >> 16) & 0XFF);
            N3 = ((LADDR >> 8) & 0XFF);
            N4 = (LADDR & 0XFF);

            M->M_LEN = BPTR - M->M_DATA; /* ADJUST LENGTH */
            M->M_LEN += SNPRINTF(BPTR, M->M_SIZE - M->M_LEN,
                                 "ORT %D,%D,%D,%D,%D,%D\R\N%S", N1, N2, N3, N4,
                                 N5, N6, X == 7 ? BUFF : "");
            RETURN 1;
        } ELSE IF ((BPTR = (CHAR *)STRSTR(M->M_DATA, "27 ENTERING")) != NULL) {
            /*
             * NEED TO EMULATE THE PASV RESPONSE
             */
            X = SSCANF(
                BPTR,
                "27 ENTERING PASSIVE MODE (%U,%U,%U,%U,%U,%U)\R\N%256[^\177]",
                &N1, &N2, &N3, &N4, &N5, &N6, BUFF);
            IF (X < 6)
                RETURN 1;

            LADDR = HTONL((N1 << 24) | (N2 << 16) | (N3 << 8) | (N4));
            LPORT = HTONS((N5 << 8) | (N6));

            IF ((SO = TCP_LISTEN(SLIRP, INADDR_ANY, 0, LADDR, LPORT,
                                 SS_FACCEPTONCE)) == NULL) {
                RETURN 1;
            }
            N6 = NTOHS(SO->SO_FPORT);

            N5 = (N6 >> 8) & 0XFF;
            N6 &= 0XFF;

            LADDR = NTOHL(SO->SO_FADDR.S_ADDR);

            N1 = ((LADDR >> 24) & 0XFF);
            N2 = ((LADDR >> 16) & 0XFF);
            N3 = ((LADDR >> 8) & 0XFF);
            N4 = (LADDR & 0XFF);

            M->M_LEN = BPTR - M->M_DATA; /* ADJUST LENGTH */
            M->M_LEN +=
                SNPRINTF(BPTR, M->M_SIZE - M->M_LEN,
                         "27 ENTERING PASSIVE MODE (%D,%D,%D,%D,%D,%D)\R\N%S",
                         N1, N2, N3, N4, N5, N6, X == 7 ? BUFF : "");

            RETURN 1;
        }

        RETURN 1;

    CASE EMU_KSH:
        /*
         * THE KSHELL (KERBEROS RSH) AND SHELL SERVICES BOTH PASS
         * A LOCAL PORT PORT NUMBER TO CARRY SIGNALS TO THE SERVER
         * AND STDERR TO THE CLIENT.  IT IS PASSED AT THE BEGINNING
         * OF THE CONNECTION AS A NUL-TERMINATED DECIMAL ASCII STRING.
         */
        SO->SO_EMU = 0;
        FOR (LPORT = 0, I = 0; I < M->M_LEN - 1; ++I) {
            IF (M->M_DATA[I] < '0' || M->M_DATA[I] > '9')
                RETURN 1; /* INVALID NUMBER */
            LPORT *= 10;
            LPORT += M->M_DATA[I] - '0';
        }
        IF (M->M_DATA[M->M_LEN - 1] == '\0' && LPORT != 0 &&
            (SO = TCP_LISTEN(SLIRP, INADDR_ANY, 0, SO->SO_LADDR.S_ADDR,
                             HTONS(LPORT), SS_FACCEPTONCE)) != NULL)
            M->M_LEN =
                SNPRINTF(M->M_DATA, M->M_SIZE, "%D", NTOHS(SO->SO_FPORT)) + 1;
        RETURN 1;

    CASE EMU_IRC:
        /*
         * NEED TO EMULATE DCC CHAT, DCC SEND AND DCC MOVE
         */
        M_INC(M, M->M_LEN + 1);
        *(M->M_DATA + M->M_LEN) = 0; /* NULL TERMINATE THE STRING FOR STRSTR */
        IF ((BPTR = (CHAR *)STRSTR(M->M_DATA, "DCC")) == NULL)
            RETURN 1;

        /* THE %256S IS FOR THE BROKEN MIRC */
        IF (SSCANF(BPTR, "DCC CHAT %256S %U %U", BUFF, &LADDR, &LPORT) == 3) {
            IF ((SO = TCP_LISTEN(SLIRP, INADDR_ANY, 0, HTONL(LADDR),
                                 HTONS(LPORT), SS_FACCEPTONCE)) == NULL) {
                RETURN 1;
            }
            M->M_LEN = BPTR - M->M_DATA; /* ADJUST LENGTH */
            M->M_LEN += SNPRINTF(BPTR, M->M_SIZE, "DCC CHAT CHAT %LU %U%C\N",
                                 (UNSIGNED LONG)NTOHL(SO->SO_FADDR.S_ADDR),
                                 NTOHS(SO->SO_FPORT), 1);
        } ELSE IF (SSCANF(BPTR, "DCC SEND %256S %U %U %U", BUFF, &LADDR, &LPORT,
                          &N1) == 4) {
            IF ((SO = TCP_LISTEN(SLIRP, INADDR_ANY, 0, HTONL(LADDR),
                                 HTONS(LPORT), SS_FACCEPTONCE)) == NULL) {
                RETURN 1;
            }
            M->M_LEN = BPTR - M->M_DATA; /* ADJUST LENGTH */
            M->M_LEN +=
                SNPRINTF(BPTR, M->M_SIZE, "DCC SEND %S %LU %U %U%C\N", BUFF,
                         (UNSIGNED LONG)NTOHL(SO->SO_FADDR.S_ADDR),
                         NTOHS(SO->SO_FPORT), N1, 1);
        } ELSE IF (SSCANF(BPTR, "DCC MOVE %256S %U %U %U", BUFF, &LADDR, &LPORT,
                          &N1) == 4) {
            IF ((SO = TCP_LISTEN(SLIRP, INADDR_ANY, 0, HTONL(LADDR),
                                 HTONS(LPORT), SS_FACCEPTONCE)) == NULL) {
                RETURN 1;
            }
            M->M_LEN = BPTR - M->M_DATA; /* ADJUST LENGTH */
            M->M_LEN +=
                SNPRINTF(BPTR, M->M_SIZE, "DCC MOVE %S %LU %U %U%C\N", BUFF,
                         (UNSIGNED LONG)NTOHL(SO->SO_FADDR.S_ADDR),
                         NTOHS(SO->SO_FPORT), N1, 1);
        }
        RETURN 1;

    CASE EMU_REALAUDIO:
        /*
         * REALAUDIO EMULATION - JP. WE MUST TRY TO PARSE THE INCOMING
         * DATA AND TRY TO FIND THE TWO CHARACTERS THAT CONTAIN THE
         * PORT NUMBER. THEN WE REDIRECT AN UDP PORT AND REPLACE THE
         * NUMBER WITH THE REAL PORT WE GOT.
         *
         * THE 1.0 BETA VERSIONS OF THE PLAYER ARE NOT SUPPORTED
         * ANY MORE.
         *
         * A TYPICAL PACKET FOR PLAYER VERSION 1.0 (RELEASE VERSION):
         *
         * 0000:50 4E 41 00 05
         * 0000:00 01 00 02 1B D7 00 00 67 E6 6C DC 63 00 12 50 ........G.L.C..P
         * 0010:4E 43 4C 49 45 4E 54 20 31 30 31 20 41 4C 50 48 NCLIENT 101 ALPH
         * 0020:41 6C 00 00 52 00 17 72 61 66 69 6C 65 73 2F 76 AL..R..RAFILES/V
         * 0030:6F 61 2F 65 6E 67 6C 69 73 68 5F 2E 72 61 79 42 OA/ENGLISH_.RAYB
         *
         * NOW THE PORT NUMBER 0X1BD7 IS FOUND AT OFFSET 0X04 OF THE
         * NOW THE PORT NUMBER 0X1BD7 IS FOUND AT OFFSET 0X04 OF THE
         * SECOND PACKET. THIS TIME WE RECEIVED FIVE BYTES FIRST AND
         * THEN THE REST. YOU NEVER KNOW HOW MANY BYTES YOU GET.
         *
         * A TYPICAL PACKET FOR PLAYER VERSION 2.0 (BETA):
         *
         * 0000:50 4E 41 00 06 00 02 00 00 00 01 00 02 1B C1 00 PNA.............
         * 0010:00 67 75 78 F5 63 00 0A 57 69 6E 32 2E 30 2E 30 .GUX.C..WIN2.0.0
         * 0020:2E 35 6C 00 00 52 00 1C 72 61 66 69 6C 65 73 2F .5L..R..RAFILES/
         * 0030:77 65 62 73 69 74 65 2F 32 30 72 65 6C 65 61 73 WEBSITE/20RELEAS
         * 0040:65 2E 72 61 79 53 00 00 06 36 42                E.RAYS...6B
         *
         * PORT NUMBER 0X1BC1 IS FOUND AT OFFSET 0X0D.
         *
         * THIS IS JUST A HORRIBLE SWITCH STATEMENT. VARIABLE RA TELLS
         * US WHERE WE'RE GOING.
         */

        BPTR = M->M_DATA;
        WHILE (BPTR < M->M_DATA + M->M_LEN) {
            UINT16_T P;
            STATIC INT RA = 0;
            CHAR RA_TBL[4];

            RA_TBL[0] = 0X50;
            RA_TBL[1] = 0X4E;
            RA_TBL[2] = 0X41;
            RA_TBL[3] = 0;

            SWITCH (RA) {
            CASE 0:
            CASE 2:
            CASE 3:
                IF (*BPTR++ != RA_TBL[RA]) {
                    RA = 0;
                    CONTINUE;
                }
                BREAK;

            CASE 1:
                /*
                 * WE MAY GET 0X50 SEVERAL TIMES, IGNORE THEM
                 */
                IF (*BPTR == 0X50) {
                    RA = 1;
                    BPTR++;
                    CONTINUE;
                } ELSE IF (*BPTR++ != RA_TBL[RA]) {
                    RA = 0;
                    CONTINUE;
                }
                BREAK;

            CASE 4:
                /*
                 * SKIP VERSION NUMBER
                 */
                BPTR++;
                BREAK;

            CASE 5:
                /*
                 * THE DIFFERENCE BETWEEN VERSIONS 1.0 AND
                 * 2.0 IS HERE. FOR FUTURE VERSIONS OF
                 * THE PLAYER THIS MAY NEED TO BE MODIFIED.
                 */
                IF (*(BPTR + 1) == 0X02)
                    BPTR += 8;
                ELSE
                    BPTR += 4;
                BREAK;

            CASE 6:
                /* THIS IS THE FIELD CONTAINING THE PORT
                 * NUMBER THAT RA-PLAYER IS LISTENING TO.
                 */
                LPORT = (((UINT8_T *)BPTR)[0] << 8) + ((UINT8_T *)BPTR)[1];
                IF (LPORT < 6970)
                    LPORT += 256; /* DON'T KNOW WHY */
                IF (LPORT < 6970 || LPORT > 7170)
                    RETURN 1; /* FAILED */

                /* TRY TO GET UDP PORT BETWEEN 6970 - 7170 */
                FOR (P = 6970; P < 7071; P++) {
                    IF (UDP_LISTEN(SLIRP, INADDR_ANY, HTONS(P),
                                   SO->SO_LADDR.S_ADDR, HTONS(LPORT),
                                   SS_FACCEPTONCE)) {
                        BREAK;
                    }
                }
                IF (P == 7071)
                    P = 0;
                *(UINT8_T *)BPTR++ = (P >> 8) & 0XFF;
                *(UINT8_T *)BPTR = P & 0XFF;
                RA = 0;
                RETURN 1; /* PORT REDIRECTED, WE'RE DONE */
                BREAK;

            DEFAULT:
                RA = 0;
            }
            RA++;
        }
        RETURN 1;

    DEFAULT:
        /* OOOPS, NOT EMULATED, WON'T CALL TCP_EMU AGAIN */
        SO->SO_EMU = 0;
        RETURN 1;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 507775_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT I2O_ECPUBLICKEY(CONST EC_KEY *A, UNSIGNED CHAR **OUT)
{
    SIZE_T BUF_LEN = 0;
    INT NEW_BUFFER = 0;

    IF (A == NULL) {
        ECERR(EC_F_I2O_ECPUBLICKEY, ERR_R_PASSED_NULL_PARAMETER);
        RETURN 0;
    }

    BUF_LEN = EC_POINT_POINT2OCT(A->GROUP, A->PUB_KEY,
                                 A->CONV_FORM, NULL, 0, NULL);

    IF (OUT == NULL || BUF_LEN == 0)
        /* OUT == NULL => JUST RETURN THE LENGTH OF THE OCTET STRING */
        RETURN BUF_LEN;

    IF (*OUT == NULL) {
        IF ((*OUT = OPENSSL_MALLOC(BUF_LEN)) == NULL) {
            ECERR(EC_F_I2O_ECPUBLICKEY, ERR_R_MALLOC_FAILURE);
            RETURN 0;
        }
        NEW_BUFFER = 1;
    }
    IF (!EC_POINT_POINT2OCT(A->GROUP, A->PUB_KEY, A->CONV_FORM,
                            *OUT, BUF_LEN, NULL)) {
        ECERR(EC_F_I2O_ECPUBLICKEY, ERR_R_EC_LIB);
        IF (NEW_BUFFER) {
            OPENSSL_FREE(*OUT);
            *OUT = NULL;
        }
        RETURN 0;
    }
    IF (!NEW_BUFFER)
        *OUT += BUF_LEN;
    RETURN BUF_LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484765_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT XENNET_RXIDX(RING_IDX IDX)
{
	RETURN IDX & (NET_RX_RING_SIZE - 1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 427162_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID CLOSELISTFIELD (FUNCSTATE *FS, CONSCONTROL *CC) {
  IF (CC->V.K == VVOID) RETURN;  /* THERE IS NO LIST ITEM */
  LUAK_EXP2NEXTREG(FS, &CC->V);
  CC->V.K = VVOID;
  IF (CC->TOSTORE == LFIELDS_PER_FLUSH) {
    LUAK_SETLIST(FS, CC->T->U.INFO, CC->NA, CC->TOSTORE);  /* FLUSH */
    CC->NA += CC->TOSTORE;
    CC->TOSTORE = 0;  /* NO MORE ITEMS PENDING */
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 387568_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CALL_TLV_HANDLER(STRUCT SND_CTL_FILE *FILE, INT OP_FLAG,
			    STRUCT SND_KCONTROL *KCTL,
			    STRUCT SND_CTL_ELEM_ID *ID,
			    UNSIGNED INT __USER *BUF, UNSIGNED INT SIZE)
{
	STATIC CONST STRUCT {
		INT OP;
		INT PERM;
	} PAIRS[] = {
		{SNDRV_CTL_TLV_OP_READ,  SNDRV_CTL_ELEM_ACCESS_TLV_READ},
		{SNDRV_CTL_TLV_OP_WRITE, SNDRV_CTL_ELEM_ACCESS_TLV_WRITE},
		{SNDRV_CTL_TLV_OP_CMD,   SNDRV_CTL_ELEM_ACCESS_TLV_COMMAND},
	};
	STRUCT SND_KCONTROL_VOLATILE *VD = &KCTL->VD[SND_CTL_GET_IOFF(KCTL, ID)];
	INT I, RET;

	/* CHECK SUPPORT OF THE REQUEST FOR THIS ELEMENT. */
	FOR (I = 0; I < ARRAY_SIZE(PAIRS); ++I) {
		IF (OP_FLAG == PAIRS[I].OP && (VD->ACCESS & PAIRS[I].PERM))
			BREAK;
	}
	IF (I == ARRAY_SIZE(PAIRS))
		RETURN -ENXIO;

	IF (KCTL->TLV.C == NULL)
		RETURN -ENXIO;

	/* WRITE AND COMMAND OPERATIONS ARE NOT ALLOWED FOR LOCKED ELEMENT. */
	IF (OP_FLAG != SNDRV_CTL_TLV_OP_READ &&
	    VD->OWNER != NULL && VD->OWNER != FILE)
		RETURN -EPERM;

	RET = SND_POWER_REF_AND_WAIT(FILE->CARD);
	IF (!RET)
		RET = KCTL->TLV.C(KCTL, OP_FLAG, SIZE, BUF);
	SND_POWER_UNREF(FILE->CARD);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198983_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SWTPM_NVRAM_CHECKHEADER(UNSIGNED CHAR *DATA, UINT32_T LENGTH,
                        UINT32_T *DATAOFFSET, UINT16_T *HDRFLAGS,
                        UINT8_T *HDRVERSION, BOOL QUIET)
{
    BLOBHEADER *BH = (BLOBHEADER *)DATA;

    IF (LENGTH < SIZEOF(BH)) {
        IF (!QUIET)
            LOGPRINTF(STDERR_FILENO,
                      "NOT ENOUGH BYTES FOR HEADER: %U\N", LENGTH);
        RETURN TPM_BAD_PARAMETER;
    }

    IF (NTOHL(BH->TOTLEN) != LENGTH) {
        IF (!QUIET)
            LOGPRINTF(STDERR_FILENO,
                      "BROKEN HEADER: BH->TOTLEN %U != %U\N",
                      HTONL(BH->TOTLEN), LENGTH);
        RETURN TPM_BAD_PARAMETER;
    }

    IF (BH->MIN_VERSION > BLOB_HEADER_VERSION) {
        IF (!QUIET)
            LOGPRINTF(STDERR_FILENO,
                      "MINIMUM REQUIRED VERSION FOR THE BLOB IS %D, WE "
                      "ONLY SUPPORT VERSION %D\N", BH->MIN_VERSION,
                      BLOB_HEADER_VERSION);
        RETURN TPM_BAD_VERSION;
    }

    *HDRVERSION = BH->VERSION;
    *DATAOFFSET = NTOHS(BH->HDRSIZE);
    *HDRFLAGS = NTOHS(BH->FLAGS);

    RETURN TPM_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202810_CWE-203.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
_GCRY_ECC_ECDSA_SIGN (GCRY_MPI_T INPUT, ECC_SECRET_KEY *SKEY,
                      GCRY_MPI_T R, GCRY_MPI_T S,
                      INT FLAGS, INT HASHALGO)
{
  GPG_ERR_CODE_T RC = 0;
  INT EXTRALOOPS = 0;
  GCRY_MPI_T K, DR, SUM, K_1, X;
  MPI_POINT_STRUCT I;
  GCRY_MPI_T HASH;
  CONST VOID *ABUF;
  UNSIGNED INT ABITS, QBITS;
  MPI_EC_T CTX;

  IF (DBG_CIPHER)
    LOG_MPIDUMP ("ECDSA SIGN HASH  ", INPUT );

  QBITS = MPI_GET_NBITS (SKEY->E.N);

  /* CONVERT THE INPUT INTO AN MPI IF NEEDED.  */
  RC = _GCRY_DSA_NORMALIZE_HASH (INPUT, &HASH, QBITS);
  IF (RC)
    RETURN RC;

  K = NULL;
  DR = MPI_ALLOC (0);
  SUM = MPI_ALLOC (0);
  K_1 = MPI_ALLOC (0);
  X = MPI_ALLOC (0);
  POINT_INIT (&I);

  CTX = _GCRY_MPI_EC_P_INTERNAL_NEW (SKEY->E.MODEL, SKEY->E.DIALECT, 0,
                                     SKEY->E.P, SKEY->E.A, SKEY->E.B);

  /* TWO LOOPS TO AVOID R OR S ARE ZERO.  THIS IS MORE OF A JOKE THAN
     A REAL DEMAND BECAUSE THE PROBABILITY OF THEM BEING ZERO IS LESS
     THAN ANY HARDWARE FAILURE.  SOME SPECS HOWEVER REQUIRE IT.  */
  DO
    {
      DO
        {
          MPI_FREE (K);
          K = NULL;
          IF ((FLAGS & PUBKEY_FLAG_RFC6979) && HASHALGO)
            {
              /* USE PORNIN'S METHOD FOR DETERMINISTIC DSA.  IF THIS
                 FLAG IS SET, IT IS EXPECTED THAT HASH IS AN OPAQUE
                 MPI WITH THE TO BE SIGNED HASH.  THAT HASH IS ALSO
                 USED AS H1 FROM 3.2.A.  */
              IF (!MPI_IS_OPAQUE (INPUT))
                {
                  RC = GPG_ERR_CONFLICT;
                  GOTO LEAVE;
                }

              ABUF = MPI_GET_OPAQUE (INPUT, &ABITS);
              RC = _GCRY_DSA_GEN_RFC6979_K (&K, SKEY->E.N, SKEY->D,
                                            ABUF, (ABITS+7)/8,
                                            HASHALGO, EXTRALOOPS);
              IF (RC)
                GOTO LEAVE;
              EXTRALOOPS++;
            }
          ELSE
            K = _GCRY_DSA_GEN_K (SKEY->E.N, GCRY_STRONG_RANDOM);

          _GCRY_MPI_EC_MUL_POINT (&I, K, &SKEY->E.G, CTX);
          IF (_GCRY_MPI_EC_GET_AFFINE (X, NULL, &I, CTX))
            {
              IF (DBG_CIPHER)
                LOG_DEBUG ("ECC SIGN: FAILED TO GET AFFINE COORDINATES\N");
              RC = GPG_ERR_BAD_SIGNATURE;
              GOTO LEAVE;
            }
          MPI_MOD (R, X, SKEY->E.N);  /* R = X MOD N */
        }
      WHILE (!MPI_CMP_UI (R, 0));

      MPI_MULM (DR, SKEY->D, R, SKEY->E.N); /* DR = D*R MOD N  */
      MPI_ADDM (SUM, HASH, DR, SKEY->E.N);  /* SUM = HASH + (D*R) MOD N  */
      MPI_INVM (K_1, K, SKEY->E.N);         /* K_1 = K^(-1) MOD N  */
      MPI_MULM (S, K_1, SUM, SKEY->E.N);    /* S = K^(-1)*(HASH+(D*R)) MOD N */
    }
  WHILE (!MPI_CMP_UI (S, 0));

  IF (DBG_CIPHER)
    {
      LOG_MPIDUMP ("ECDSA SIGN RESULT R ", R);
      LOG_MPIDUMP ("ECDSA SIGN RESULT S ", S);
    }

 LEAVE:
  _GCRY_MPI_EC_FREE (CTX);
  POINT_FREE (&I);
  MPI_FREE (X);
  MPI_FREE (K_1);
  MPI_FREE (SUM);
  MPI_FREE (DR);
  MPI_FREE (K);

  IF (HASH != INPUT)
    MPI_FREE (HASH);

  RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 455386_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
XFS_INODE_SET_RECLAIM_TAG(
	STRUCT XFS_INODE	*IP)
{
	STRUCT XFS_MOUNT	*MP = IP->I_MOUNT;
	STRUCT XFS_PERAG	*PAG;

	PAG = XFS_PERAG_GET(MP, XFS_INO_TO_AGNO(MP, IP->I_INO));
	SPIN_LOCK(&PAG->PAG_ICI_LOCK);
	SPIN_LOCK(&IP->I_FLAGS_LOCK);

	RADIX_TREE_TAG_SET(&PAG->PAG_ICI_ROOT, XFS_INO_TO_AGINO(MP, IP->I_INO),
			   XFS_ICI_RECLAIM_TAG);
	XFS_PERAG_SET_RECLAIM_TAG(PAG);
	__XFS_IFLAGS_SET(IP, XFS_IRECLAIMABLE);

	SPIN_UNLOCK(&IP->I_FLAGS_LOCK);
	SPIN_UNLOCK(&PAG->PAG_ICI_LOCK);
	XFS_PERAG_PUT(PAG);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208983_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
JAS_IMAGE_T *JP2_DECODE(JAS_STREAM_T *IN, CHAR *OPTSTR)
{
	JP2_BOX_T *BOX;
	INT FOUND;
	JAS_IMAGE_T *IMAGE;
	JP2_DEC_T *DEC;
	BOOL SAMEDTYPE;
	INT DTYPE;
	UNSIGNED INT I;
	JP2_CMAP_T *CMAPD;
	JP2_PCLR_T *PCLRD;
	JP2_CDEF_T *CDEFD;
	UNSIGNED INT CHANNO;
	INT NEWCMPTNO;
	INT_FAST32_T *LUTENTS;
#IF 0
	JP2_CDEFCHAN_T *CDEFENT;
	INT CMPTNO;
#ENDIF
	JP2_CMAPENT_T *CMAPENT;
	JAS_ICCHDR_T ICCHDR;
	JAS_ICCPROF_T *ICCPROF;

	DEC = 0;
	BOX = 0;
	IMAGE = 0;

	IF (!(DEC = JP2_DEC_CREATE())) {
		GOTO ERROR;
	}

	/* GET THE FIRST BOX.  THIS SHOULD BE A JP BOX. */
	IF (!(BOX = JP2_BOX_GET(IN))) {
		JAS_EPRINTF("ERROR: CANNOT GET BOX\N");
		GOTO ERROR;
	}
	IF (BOX->TYPE != JP2_BOX_JP) {
		JAS_EPRINTF("ERROR: EXPECTING SIGNATURE BOX\N");
		GOTO ERROR;
	}
	IF (BOX->DATA.JP.MAGIC != JP2_JP_MAGIC) {
		JAS_EPRINTF("INCORRECT MAGIC NUMBER\N");
		GOTO ERROR;
	}
	JP2_BOX_DESTROY(BOX);
	BOX = 0;

	/* GET THE SECOND BOX.  THIS SHOULD BE A FTYP BOX. */
	IF (!(BOX = JP2_BOX_GET(IN))) {
		GOTO ERROR;
	}
	IF (BOX->TYPE != JP2_BOX_FTYP) {
		JAS_EPRINTF("EXPECTING FILE TYPE BOX\N");
		GOTO ERROR;
	}
	JP2_BOX_DESTROY(BOX);
	BOX = 0;

	/* GET MORE BOXES... */
	FOUND = 0;
	WHILE ((BOX = JP2_BOX_GET(IN))) {
		IF (JAS_GETDBGLEVEL() >= 1) {
			JAS_EPRINTF("BOX TYPE %S\N", BOX->INFO->NAME);
		}
		SWITCH (BOX->TYPE) {
		CASE JP2_BOX_JP2C:
			FOUND = 1;
			BREAK;
		CASE JP2_BOX_IHDR:
			IF (!DEC->IHDR) {
				DEC->IHDR = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_BPCC:
			IF (!DEC->BPCC) {
				DEC->BPCC = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_CDEF:
			IF (!DEC->CDEF) {
				DEC->CDEF = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_PCLR:
			IF (!DEC->PCLR) {
				DEC->PCLR = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_CMAP:
			IF (!DEC->CMAP) {
				DEC->CMAP = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_COLR:
			IF (!DEC->COLR) {
				DEC->COLR = BOX;
				BOX = 0;
			}
			BREAK;
		}
		IF (BOX) {
			JP2_BOX_DESTROY(BOX);
			BOX = 0;
		}
		IF (FOUND) {
			BREAK;
		}
	}

	IF (!FOUND) {
		JAS_EPRINTF("ERROR: NO CODE STREAM FOUND\N");
		GOTO ERROR;
	}

	IF (!(DEC->IMAGE = JPC_DECODE(IN, OPTSTR))) {
		JAS_EPRINTF("ERROR: CANNOT DECODE CODE STREAM\N");
		GOTO ERROR;
	}

	/* AN IHDR BOX MUST BE PRESENT. */
	IF (!DEC->IHDR) {
		JAS_EPRINTF("ERROR: MISSING IHDR BOX\N");
		GOTO ERROR;
	}

	/* DOES THE NUMBER OF COMPONENTS INDICATED IN THE IHDR BOX MATCH
	  THE VALUE SPECIFIED IN THE CODE STREAM? */
	IF (DEC->IHDR->DATA.IHDR.NUMCMPTS != JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE))) {
		JAS_EPRINTF("WARNING: NUMBER OF COMPONENTS MISMATCH\N");
	}

	/* AT LEAST ONE COMPONENT MUST BE PRESENT. */
	IF (!JAS_IMAGE_NUMCMPTS(DEC->IMAGE)) {
		JAS_EPRINTF("ERROR: NO COMPONENTS\N");
		GOTO ERROR;
	}

	/* DETERMINE IF ALL COMPONENTS HAVE THE SAME DATA TYPE. */
	SAMEDTYPE = TRUE;
	DTYPE = JAS_IMAGE_CMPTDTYPE(DEC->IMAGE, 0);
	FOR (I = 1; I < JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE)); ++I) {
		IF (JAS_IMAGE_CMPTDTYPE(DEC->IMAGE, I) != DTYPE) {
			SAMEDTYPE = FALSE;
			BREAK;
		}
	}

	/* IS THE COMPONENT DATA TYPE INDICATED IN THE IHDR BOX CONSISTENT
	  WITH THE DATA IN THE CODE STREAM? */
	IF ((SAMEDTYPE && DEC->IHDR->DATA.IHDR.BPC != JP2_DTYPETOBPC(DTYPE)) ||
	  (!SAMEDTYPE && DEC->IHDR->DATA.IHDR.BPC != JP2_IHDR_BPCNULL)) {
		JAS_EPRINTF("WARNING: COMPONENT DATA TYPE MISMATCH\N");
	}

	/* IS THE COMPRESSION TYPE SUPPORTED? */
	IF (DEC->IHDR->DATA.IHDR.COMPTYPE != JP2_IHDR_COMPTYPE) {
		JAS_EPRINTF("ERROR: UNSUPPORTED COMPRESSION TYPE\N");
		GOTO ERROR;
	}

	IF (DEC->BPCC) {
		/* IS THE NUMBER OF COMPONENTS INDICATED IN THE BPCC BOX
		  CONSISTENT WITH THE CODE STREAM DATA? */
		IF (DEC->BPCC->DATA.BPCC.NUMCMPTS != JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(
		  DEC->IMAGE))) {
			JAS_EPRINTF("WARNING: NUMBER OF COMPONENTS MISMATCH\N");
		}
		/* IS THE COMPONENT DATA TYPE INFORMATION INDICATED IN THE BPCC
		  BOX CONSISTENT WITH THE CODE STREAM DATA? */
		IF (!SAMEDTYPE) {
			FOR (I = 0; I < JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE)); ++I) {
				IF (JAS_IMAGE_CMPTDTYPE(DEC->IMAGE, I) != JP2_BPCTODTYPE(DEC->BPCC->DATA.BPCC.BPCS[I])) {
					JAS_EPRINTF("WARNING: COMPONENT DATA TYPE MISMATCH\N");
				}
			}
		} ELSE {
			JAS_EPRINTF("WARNING: SUPERFLUOUS BPCC BOX\N");
		}
	}

	/* A COLR BOX MUST BE PRESENT. */
	IF (!DEC->COLR) {
		JAS_EPRINTF("ERROR: NO COLR BOX\N");
		GOTO ERROR;
	}

	SWITCH (DEC->COLR->DATA.COLR.METHOD) {
	CASE JP2_COLR_ENUM:
		JAS_IMAGE_SETCLRSPC(DEC->IMAGE, JP2_GETCS(&DEC->COLR->DATA.COLR));
		BREAK;
	CASE JP2_COLR_ICC:
		ICCPROF = JAS_ICCPROF_CREATEFROMBUF(DEC->COLR->DATA.COLR.ICCP,
		  DEC->COLR->DATA.COLR.ICCPLEN);
		ASSERT(ICCPROF);
		JAS_ICCPROF_GETHDR(ICCPROF, &ICCHDR);
		JAS_EPRINTF("ICC PROFILE CS %08X\N", ICCHDR.COLORSPC);
		JAS_IMAGE_SETCLRSPC(DEC->IMAGE, FROMICCPCS(ICCHDR.COLORSPC));
		DEC->IMAGE->CMPROF_ = JAS_CMPROF_CREATEFROMICCPROF(ICCPROF);
		ASSERT(DEC->IMAGE->CMPROF_);
		JAS_ICCPROF_DESTROY(ICCPROF);
		BREAK;
	}

	/* IF A CMAP BOX IS PRESENT, A PCLR BOX MUST ALSO BE PRESENT. */
	IF (DEC->CMAP && !DEC->PCLR) {
		JAS_EPRINTF("WARNING: MISSING PCLR BOX OR SUPERFLUOUS CMAP BOX\N");
		JP2_BOX_DESTROY(DEC->CMAP);
		DEC->CMAP = 0;
	}

	/* IF A CMAP BOX IS NOT PRESENT, A PCLR BOX MUST NOT BE PRESENT. */
	IF (!DEC->CMAP && DEC->PCLR) {
		JAS_EPRINTF("WARNING: MISSING CMAP BOX OR SUPERFLUOUS PCLR BOX\N");
		JP2_BOX_DESTROY(DEC->PCLR);
		DEC->PCLR = 0;
	}

	/* DETERMINE THE NUMBER OF CHANNELS (WHICH IS ESSENTIALLY THE NUMBER
	  OF COMPONENTS AFTER ANY PALETTE MAPPINGS HAVE BEEN APPLIED). */
	DEC->NUMCHANS = DEC->CMAP ? DEC->CMAP->DATA.CMAP.NUMCHANS : JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE));

	/* PERFORM A BASIC SANITY CHECK ON THE CMAP BOX IF PRESENT. */
	IF (DEC->CMAP) {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			/* IS THE COMPONENT NUMBER REASONABLE? */
			IF (DEC->CMAP->DATA.CMAP.ENTS[I].CMPTNO >= JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE))) {
				JAS_EPRINTF("ERROR: INVALID COMPONENT NUMBER IN CMAP BOX\N");
				GOTO ERROR;
			}
			/* IS THE LUT INDEX REASONABLE? */
			IF (DEC->CMAP->DATA.CMAP.ENTS[I].PCOL >= DEC->PCLR->DATA.PCLR.NUMCHANS) {
				JAS_EPRINTF("ERROR: INVALID CMAP LUT INDEX\N");
				GOTO ERROR;
			}
		}
	}

	/* ALLOCATE SPACE FOR THE CHANNEL-NUMBER TO COMPONENT-NUMBER LUT. */
	IF (!(DEC->CHANTOCMPTLUT = JAS_MALLOC(DEC->NUMCHANS * SIZEOF(UINT_FAST16_T)))) {
		JAS_EPRINTF("ERROR: NO MEMORY\N");
		GOTO ERROR;
	}

	IF (!DEC->CMAP) {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			DEC->CHANTOCMPTLUT[I] = I;
		}
	} ELSE {
		CMAPD = &DEC->CMAP->DATA.CMAP;
		PCLRD = &DEC->PCLR->DATA.PCLR;
		CDEFD = &DEC->CDEF->DATA.CDEF;
		FOR (CHANNO = 0; CHANNO < CMAPD->NUMCHANS; ++CHANNO) {
			CMAPENT = &CMAPD->ENTS[CHANNO];
			IF (CMAPENT->MAP == JP2_CMAP_DIRECT) {
				DEC->CHANTOCMPTLUT[CHANNO] = CHANNO;
			} ELSE IF (CMAPENT->MAP == JP2_CMAP_PALETTE) {
				LUTENTS = JAS_MALLOC(PCLRD->NUMLUTENTS * SIZEOF(INT_FAST32_T));
				FOR (I = 0; I < PCLRD->NUMLUTENTS; ++I) {
					LUTENTS[I] = PCLRD->LUTDATA[CMAPENT->PCOL + I * PCLRD->NUMCHANS];
				}
				NEWCMPTNO = JAS_IMAGE_NUMCMPTS(DEC->IMAGE);
				JAS_IMAGE_DEPALETTIZE(DEC->IMAGE, CMAPENT->CMPTNO, PCLRD->NUMLUTENTS, LUTENTS, JP2_BPCTODTYPE(PCLRD->BPC[CMAPENT->PCOL]), NEWCMPTNO);
				DEC->CHANTOCMPTLUT[CHANNO] = NEWCMPTNO;
				JAS_FREE(LUTENTS);
#IF 0
				IF (DEC->CDEF) {
					CDEFENT = JP2_CDEF_LOOKUP(CDEFD, CHANNO);
					IF (!CDEFENT) {
						ABORT();
					}
				JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, NEWCMPTNO, JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE), CDEFENT->TYPE, CDEFENT->ASSOC));
				} ELSE {
				JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, NEWCMPTNO, JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE), 0, CHANNO + 1));
				}
#ENDIF
			}
		}
	}

	/* MARK ALL COMPONENTS AS BEING OF UNKNOWN TYPE. */

	FOR (I = 0; I < JAS_CAST(UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE)); ++I) {
		JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, I, JAS_IMAGE_CT_UNKNOWN);
	}

	/* DETERMINE THE TYPE OF EACH COMPONENT. */
	IF (DEC->CDEF) {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE,
			  DEC->CHANTOCMPTLUT[DEC->CDEF->DATA.CDEF.ENTS[I].CHANNO],
			  JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE),
			  DEC->CDEF->DATA.CDEF.ENTS[I].TYPE, DEC->CDEF->DATA.CDEF.ENTS[I].ASSOC));
		}
	} ELSE {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, DEC->CHANTOCMPTLUT[I],
			  JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE), 0, I + 1));
		}
	}

	/* DELETE ANY COMPONENTS THAT ARE NOT OF INTEREST. */
	FOR (I = JAS_IMAGE_NUMCMPTS(DEC->IMAGE); I > 0; --I) {
		IF (JAS_IMAGE_CMPTTYPE(DEC->IMAGE, I - 1) == JAS_IMAGE_CT_UNKNOWN) {
			JAS_IMAGE_DELCMPT(DEC->IMAGE, I - 1);
		}
	}

	/* ENSURE THAT SOME COMPONENTS SURVIVED. */
	IF (!JAS_IMAGE_NUMCMPTS(DEC->IMAGE)) {
		JAS_EPRINTF("ERROR: NO COMPONENTS\N");
		GOTO ERROR;
	}
#IF 0
JAS_EPRINTF("NO OF COMPONENTS IS %D\N", JAS_IMAGE_NUMCMPTS(DEC->IMAGE));
#ENDIF

	/* PREVENT THE IMAGE FROM BEING DESTROYED LATER. */
	IMAGE = DEC->IMAGE;
	DEC->IMAGE = 0;

	JP2_DEC_DESTROY(DEC);

	RETURN IMAGE;

ERROR:
	IF (BOX) {
		JP2_BOX_DESTROY(BOX);
	}
	IF (DEC) {
		JP2_DEC_DESTROY(DEC);
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 376354_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GPG_HASH_STR (CAMELCIPHERHASH HASH)
{
	SWITCH (HASH) {
	CASE CAMEL_CIPHER_HASH_MD2:
		RETURN "--DIGEST-ALGO=MD2";
	CASE CAMEL_CIPHER_HASH_MD5:
		RETURN "--DIGEST-ALGO=MD5";
	CASE CAMEL_CIPHER_HASH_SHA1:
		RETURN "--DIGEST-ALGO=SHA1";
	CASE CAMEL_CIPHER_HASH_SHA256:
		RETURN "--DIGEST-ALGO=SHA256";
	CASE CAMEL_CIPHER_HASH_SHA384:
		RETURN "--DIGEST-ALGO=SHA384";
	CASE CAMEL_CIPHER_HASH_SHA512:
		RETURN "--DIGEST-ALGO=SHA512";
	CASE CAMEL_CIPHER_HASH_RIPEMD160:
		RETURN "--DIGEST-ALGO=RIPEMD160";
	DEFAULT:
		RETURN NULL;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 203980_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID MKISS_CLOSE(STRUCT TTY_STRUCT *TTY)
{
	STRUCT MKISS *AX;

	WRITE_LOCK_IRQ(&DISC_DATA_LOCK);
	AX = TTY->DISC_DATA;
	TTY->DISC_DATA = NULL;
	WRITE_UNLOCK_IRQ(&DISC_DATA_LOCK);

	IF (!AX)
		RETURN;

	/*
	 * WE HAVE NOW ENSURED THAT NOBODY CAN START USING AP FROM NOW ON, BUT
	 * WE HAVE TO WAIT FOR ALL EXISTING USERS TO FINISH.
	 */
	IF (!REFCOUNT_DEC_AND_TEST(&AX->REFCNT))
		WAIT_FOR_COMPLETION(&AX->DEAD);
	/*
	 * HALT THE TRANSMIT QUEUE SO THAT A NEW TRANSMIT CANNOT SCRIBBLE
	 * ON OUR BUFFERS
	 */
	NETIF_STOP_QUEUE(AX->DEV);

	/* FREE ALL AX25 FRAME BUFFERS. */
	KFREE(AX->RBUFF);
	KFREE(AX->XBUFF);

	AX->TTY = NULL;

	UNREGISTER_NETDEV(AX->DEV);
	FREE_NETDEV(AX->DEV);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 313819_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_NV_IDENT(INT C1, INT C2)
{
    OPARG_T	OA;
    CMDARG_T	CA;

    CLEAR_OPARG(&OA);
    CLEAR_FIELD(CA);
    CA.OAP = &OA;
    CA.CMDCHAR = C1;
    CA.NCHAR = C2;
    NV_IDENT(&CA);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212083_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT ISMT_ACCESS(STRUCT I2C_ADAPTER *ADAP, U16 ADDR,
		       UNSIGNED SHORT FLAGS, CHAR READ_WRITE, U8 COMMAND,
		       INT SIZE, UNION I2C_SMBUS_DATA *DATA)
{
	INT RET;
	UNSIGNED LONG TIME_LEFT;
	DMA_ADDR_T DMA_ADDR = 0; /* ADDRESS OF THE DATA BUFFER */
	U8 DMA_SIZE = 0;
	ENUM DMA_DATA_DIRECTION DMA_DIRECTION = 0;
	STRUCT ISMT_DESC *DESC;
	STRUCT ISMT_PRIV *PRIV = I2C_GET_ADAPDATA(ADAP);
	STRUCT DEVICE *DEV = &PRIV->PCI_DEV->DEV;
	U8 *DMA_BUFFER = PTR_ALIGN(&PRIV->BUFFER[0], 16);

	DESC = &PRIV->HW[PRIV->HEAD];

	/* INITIALIZE THE DMA BUFFER */
	MEMSET(PRIV->BUFFER, 0, SIZEOF(PRIV->BUFFER));

	/* INITIALIZE THE DESCRIPTOR */
	MEMSET(DESC, 0, SIZEOF(STRUCT ISMT_DESC));
	DESC->TGTADDR_RW = ISMT_DESC_ADDR_RW(ADDR, READ_WRITE);

	/* ALWAYS CLEAR THE LOG ENTRIES */
	MEMSET(PRIV->LOG, 0, ISMT_LOG_ENTRIES * SIZEOF(U32));

	/* INITIALIZE COMMON CONTROL BITS */
	IF (LIKELY(PCI_DEV_MSI_ENABLED(PRIV->PCI_DEV)))
		DESC->CONTROL = ISMT_DESC_INT | ISMT_DESC_FAIR;
	ELSE
		DESC->CONTROL = ISMT_DESC_FAIR;

	IF ((FLAGS & I2C_CLIENT_PEC) && (SIZE != I2C_SMBUS_QUICK)
	    && (SIZE != I2C_SMBUS_I2C_BLOCK_DATA))
		DESC->CONTROL |= ISMT_DESC_PEC;

	SWITCH (SIZE) {
	CASE I2C_SMBUS_QUICK:
		DEV_DBG(DEV, "I2C_SMBUS_QUICK\N");
		BREAK;

	CASE I2C_SMBUS_BYTE:
		IF (READ_WRITE == I2C_SMBUS_WRITE) {
			/*
			 * SEND BYTE
			 * THE COMMAND FIELD CONTAINS THE WRITE DATA
			 */
			DEV_DBG(DEV, "I2C_SMBUS_BYTE:  WRITE\N");
			DESC->CONTROL |= ISMT_DESC_CWRL;
			DESC->WR_LEN_CMD = COMMAND;
		} ELSE {
			/* RECEIVE BYTE */
			DEV_DBG(DEV, "I2C_SMBUS_BYTE:  READ\N");
			DMA_SIZE = 1;
			DMA_DIRECTION = DMA_FROM_DEVICE;
			DESC->RD_LEN = 1;
		}
		BREAK;

	CASE I2C_SMBUS_BYTE_DATA:
		IF (READ_WRITE == I2C_SMBUS_WRITE) {
			/*
			 * WRITE BYTE
			 * COMMAND PLUS 1 DATA BYTE
			 */
			DEV_DBG(DEV, "I2C_SMBUS_BYTE_DATA:  WRITE\N");
			DESC->WR_LEN_CMD = 2;
			DMA_SIZE = 2;
			DMA_DIRECTION = DMA_TO_DEVICE;
			DMA_BUFFER[0] = COMMAND;
			DMA_BUFFER[1] = DATA->BYTE;
		} ELSE {
			/* READ BYTE */
			DEV_DBG(DEV, "I2C_SMBUS_BYTE_DATA:  READ\N");
			DESC->CONTROL |= ISMT_DESC_CWRL;
			DESC->WR_LEN_CMD = COMMAND;
			DESC->RD_LEN = 1;
			DMA_SIZE = 1;
			DMA_DIRECTION = DMA_FROM_DEVICE;
		}
		BREAK;

	CASE I2C_SMBUS_WORD_DATA:
		IF (READ_WRITE == I2C_SMBUS_WRITE) {
			/* WRITE WORD */
			DEV_DBG(DEV, "I2C_SMBUS_WORD_DATA:  WRITE\N");
			DESC->WR_LEN_CMD = 3;
			DMA_SIZE = 3;
			DMA_DIRECTION = DMA_TO_DEVICE;
			DMA_BUFFER[0] = COMMAND;
			DMA_BUFFER[1] = DATA->WORD & 0XFF;
			DMA_BUFFER[2] = DATA->WORD >> 8;
		} ELSE {
			/* READ WORD */
			DEV_DBG(DEV, "I2C_SMBUS_WORD_DATA:  READ\N");
			DESC->WR_LEN_CMD = COMMAND;
			DESC->CONTROL |= ISMT_DESC_CWRL;
			DESC->RD_LEN = 2;
			DMA_SIZE = 2;
			DMA_DIRECTION = DMA_FROM_DEVICE;
		}
		BREAK;

	CASE I2C_SMBUS_PROC_CALL:
		DEV_DBG(DEV, "I2C_SMBUS_PROC_CALL\N");
		DESC->WR_LEN_CMD = 3;
		DESC->RD_LEN = 2;
		DMA_SIZE = 3;
		DMA_DIRECTION = DMA_BIDIRECTIONAL;
		DMA_BUFFER[0] = COMMAND;
		DMA_BUFFER[1] = DATA->WORD & 0XFF;
		DMA_BUFFER[2] = DATA->WORD >> 8;
		BREAK;

	CASE I2C_SMBUS_BLOCK_DATA:
		IF (READ_WRITE == I2C_SMBUS_WRITE) {
			/* BLOCK WRITE */
			DEV_DBG(DEV, "I2C_SMBUS_BLOCK_DATA:  WRITE\N");
			DMA_SIZE = DATA->BLOCK[0] + 1;
			DMA_DIRECTION = DMA_TO_DEVICE;
			DESC->WR_LEN_CMD = DMA_SIZE;
			DESC->CONTROL |= ISMT_DESC_BLK;
			DMA_BUFFER[0] = COMMAND;
			MEMCPY(&DMA_BUFFER[1], &DATA->BLOCK[1], DMA_SIZE - 1);
		} ELSE {
			/* BLOCK READ */
			DEV_DBG(DEV, "I2C_SMBUS_BLOCK_DATA:  READ\N");
			DMA_SIZE = I2C_SMBUS_BLOCK_MAX;
			DMA_DIRECTION = DMA_FROM_DEVICE;
			DESC->RD_LEN = DMA_SIZE;
			DESC->WR_LEN_CMD = COMMAND;
			DESC->CONTROL |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);
		}
		BREAK;

	CASE I2C_SMBUS_BLOCK_PROC_CALL:
		DEV_DBG(DEV, "I2C_SMBUS_BLOCK_PROC_CALL\N");
		DMA_SIZE = I2C_SMBUS_BLOCK_MAX;
		DESC->TGTADDR_RW = ISMT_DESC_ADDR_RW(ADDR, 1);
		DESC->WR_LEN_CMD = DATA->BLOCK[0] + 1;
		DESC->RD_LEN = DMA_SIZE;
		DESC->CONTROL |= ISMT_DESC_BLK;
		DMA_DIRECTION = DMA_BIDIRECTIONAL;
		DMA_BUFFER[0] = COMMAND;
		MEMCPY(&DMA_BUFFER[1], &DATA->BLOCK[1], DATA->BLOCK[0]);
		BREAK;

	CASE I2C_SMBUS_I2C_BLOCK_DATA:
		/* MAKE SURE THE LENGTH IS VALID */
		IF (DATA->BLOCK[0] < 1)
			DATA->BLOCK[0] = 1;

		IF (DATA->BLOCK[0] > I2C_SMBUS_BLOCK_MAX)
			DATA->BLOCK[0] = I2C_SMBUS_BLOCK_MAX;

		IF (READ_WRITE == I2C_SMBUS_WRITE) {
			/* I2C BLOCK WRITE */
			DEV_DBG(DEV, "I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\N");
			DMA_SIZE = DATA->BLOCK[0] + 1;
			DMA_DIRECTION = DMA_TO_DEVICE;
			DESC->WR_LEN_CMD = DMA_SIZE;
			DESC->CONTROL |= ISMT_DESC_I2C;
			DMA_BUFFER[0] = COMMAND;
			MEMCPY(&DMA_BUFFER[1], &DATA->BLOCK[1], DMA_SIZE - 1);
		} ELSE {
			/* I2C BLOCK READ */
			DEV_DBG(DEV, "I2C_SMBUS_I2C_BLOCK_DATA:  READ\N");
			DMA_SIZE = DATA->BLOCK[0];
			DMA_DIRECTION = DMA_FROM_DEVICE;
			DESC->RD_LEN = DMA_SIZE;
			DESC->WR_LEN_CMD = COMMAND;
			DESC->CONTROL |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);
			/*
			 * PER THE "TABLE 15-15. I2C COMMANDS",
			 * IN THE EXTERNAL DESIGN SPECIFICATION (EDS),
			 * (DOCUMENT NUMBER: 508084, REVISION: 2.0),
			 * THE _RW BIT MUST BE 0
			 */
			DESC->TGTADDR_RW = ISMT_DESC_ADDR_RW(ADDR, 0);
		}
		BREAK;

	DEFAULT:
		DEV_ERR(DEV, "UNSUPPORTED TRANSACTION %D\N",
			SIZE);
		RETURN -EOPNOTSUPP;
	}

	/* MAP THE DATA BUFFER */
	IF (DMA_SIZE != 0) {
		DEV_DBG(DEV, " DEV=%P\N", DEV);
		DEV_DBG(DEV, " DATA=%P\N", DATA);
		DEV_DBG(DEV, " DMA_BUFFER=%P\N", DMA_BUFFER);
		DEV_DBG(DEV, " DMA_SIZE=%D\N", DMA_SIZE);
		DEV_DBG(DEV, " DMA_DIRECTION=%D\N", DMA_DIRECTION);

		DMA_ADDR = DMA_MAP_SINGLE(DEV,
				      DMA_BUFFER,
				      DMA_SIZE,
				      DMA_DIRECTION);

		IF (DMA_MAPPING_ERROR(DEV, DMA_ADDR)) {
			DEV_ERR(DEV, "ERROR IN MAPPING DMA BUFFER %P\N",
				DMA_BUFFER);
			RETURN -EIO;
		}

		DEV_DBG(DEV, " DMA_ADDR = %PAD\N", &DMA_ADDR);

		DESC->DPTR_LOW = LOWER_32_BITS(DMA_ADDR);
		DESC->DPTR_HIGH = UPPER_32_BITS(DMA_ADDR);
	}

	REINIT_COMPLETION(&PRIV->CMP);

	/* ADD THE DESCRIPTOR */
	ISMT_SUBMIT_DESC(PRIV);

	/* NOW WE WAIT FOR INTERRUPT COMPLETION, 1S */
	TIME_LEFT = WAIT_FOR_COMPLETION_TIMEOUT(&PRIV->CMP, HZ*1);

	/* UNMAP THE DATA BUFFER */
	IF (DMA_SIZE != 0)
		DMA_UNMAP_SINGLE(DEV, DMA_ADDR, DMA_SIZE, DMA_DIRECTION);

	IF (UNLIKELY(!TIME_LEFT)) {
		DEV_ERR(DEV, "COMPLETION WAIT TIMED OUT\N");
		RET = -ETIMEDOUT;
		GOTO OUT;
	}

	/* DO ANY POST PROCESSING OF THE DESCRIPTOR HERE */
	RET = ISMT_PROCESS_DESC(DESC, DATA, PRIV, SIZE, READ_WRITE);

OUT:
	/* UPDATE THE RING POINTER */
	PRIV->HEAD++;
	PRIV->HEAD %= ISMT_DESC_ENTRIES;

	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343270_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID ENABLESIGNALS(VOID)
{
    IF (SIGPROCMASK(SIG_SETMASK, &OLD_SIGMASK, NULL) < 0) {
        _EXIT(EXIT_FAILURE);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247117_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR GF_FS_POST_USER_TASK(GF_FILTERSESSION *FSESS, BOOL (*TASK_EXECUTE) (GF_FILTERSESSION *FSESS, VOID *CALLBACK, U32 *RESCHEDULE_MS), VOID *UDTA_CALLBACK, CONST CHAR *LOG_NAME)
{
	GF_USERTASK *UTASK;
	CHAR *_LOG_NAME;
	IF (!FSESS || !TASK_EXECUTE) RETURN GF_BAD_PARAM;
	GF_SAFEALLOC(UTASK, GF_USERTASK);
	IF (!UTASK) RETURN GF_OUT_OF_MEM;
	UTASK->FSESS = FSESS;
	UTASK->CALLBACK = UDTA_CALLBACK;
	UTASK->TASK_EXECUTE = TASK_EXECUTE;
	//DUP MEM FOR USER TASK
	_LOG_NAME = GF_STRDUP(LOG_NAME ? LOG_NAME : "USER_TASK");
	GF_FS_POST_TASK(FSESS, GF_FS_USER_TASK, NULL, NULL, _LOG_NAME, UTASK);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210223_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID VREND_RENDERER_BLIT(STRUCT VREND_CONTEXT *CTX,
                         UINT32_T DST_HANDLE, UINT32_T SRC_HANDLE,
                         CONST STRUCT PIPE_BLIT_INFO *INFO)
{
   STRUCT VREND_RESOURCE *SRC_RES, *DST_RES;
   SRC_RES = VREND_RENDERER_CTX_RES_LOOKUP(CTX, SRC_HANDLE);
   DST_RES = VREND_RENDERER_CTX_RES_LOOKUP(CTX, DST_HANDLE);

   IF (!SRC_RES) {
      REPORT_CONTEXT_ERROR(CTX, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, SRC_HANDLE);
      RETURN;
   }
   IF (!DST_RES) {
      REPORT_CONTEXT_ERROR(CTX, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, DST_HANDLE);
      RETURN;
   }

   IF (CTX->IN_ERROR)
      RETURN;

   IF (INFO->RENDER_CONDITION_ENABLE == FALSE)
      VREND_PAUSE_RENDER_CONDITION(CTX, TRUE);

   VREND_DEBUG(DBG_BLIT, CTX, "BLIT: RC:%D SCISSOR:%D FILTER:%D ALPHA:%D MASK:0X%X\N"
                                   "  FROM %S(%S) MS:%D [%D, %D, %D]+[%D, %D, %D] LVL:%D\N"
                                   "  TO   %S(%S) MS:%D [%D, %D, %D]+[%D, %D, %D] LVL:%D\N",
                                   INFO->RENDER_CONDITION_ENABLE, INFO->SCISSOR_ENABLE,
                                   INFO->FILTER, INFO->ALPHA_BLEND, INFO->MASK,
                                   UTIL_FORMAT_NAME(SRC_RES->BASE.FORMAT),
                                   UTIL_FORMAT_NAME(INFO->SRC.FORMAT),
                                   SRC_RES->BASE.NR_SAMPLES,
                                   INFO->SRC.BOX.X, INFO->SRC.BOX.Y, INFO->SRC.BOX.Z,
                                   INFO->SRC.BOX.WIDTH, INFO->SRC.BOX.HEIGHT, INFO->SRC.BOX.DEPTH,
                                   INFO->SRC.LEVEL,
                                   UTIL_FORMAT_NAME(DST_RES->BASE.FORMAT),
                                   UTIL_FORMAT_NAME(INFO->DST.FORMAT),
                                   DST_RES->BASE.NR_SAMPLES,
                                   INFO->DST.BOX.X, INFO->DST.BOX.Y, INFO->DST.BOX.Z,
                                   INFO->DST.BOX.WIDTH, INFO->DST.BOX.HEIGHT, INFO->DST.BOX.DEPTH,
                                   INFO->DST.LEVEL);

   /* THE GALLIUM BLIT FUNCTION CAN BE CALLED FOR A GENERAL BLIT THAT MAY
    * SCALE, CONVERT THE DATA, AND APPLY SOME RANDER STATES, OR IT IS CALLED VIA
    * GLCOPYIMAGESUBDATA. IF THE SRC OR THE DST IMAGE ARE EQUAL, OR THE TWO
    * IMAGES FORMATS ARE THE SAME, THEN GALLIUMS SUCH CALLES ARE REDIRECTED
    * TO RESOURCE_COPY_REGION, IN THIS CASE AND IF NO RENDER STATES ETX NEED
    * TO BE APPLIED, FORWARD THE CALL TO GLCOPYIMAGESUBDATA, OTHERWISE DO A
    * NORMAL BLIT. */
   IF (HAS_FEATURE(FEAT_COPY_IMAGE) &&
       (!INFO->RENDER_CONDITION_ENABLE || !CTX->SUB->COND_RENDER_GL_MODE) &&
       FORMAT_IS_COPY_COMPATIBLE(INFO->SRC.FORMAT,INFO->DST.FORMAT, FALSE) &&
       !INFO->SCISSOR_ENABLE && (INFO->FILTER == PIPE_TEX_FILTER_NEAREST) &&
       !INFO->ALPHA_BLEND && (INFO->MASK == PIPE_MASK_RGBA) &&
       SRC_RES->BASE.NR_SAMPLES == DST_RES->BASE.NR_SAMPLES &&
       INFO->SRC.BOX.WIDTH == INFO->DST.BOX.WIDTH &&
       INFO->SRC.BOX.HEIGHT == INFO->DST.BOX.HEIGHT &&
       INFO->SRC.BOX.DEPTH == INFO->DST.BOX.DEPTH) {
      VREND_DEBUG(DBG_BLIT, CTX,  "  USE GLCOPYIMAGESUBDATA\N");
      VREND_COPY_SUB_IMAGE(SRC_RES, DST_RES, INFO->SRC.LEVEL, &INFO->SRC.BOX,
                           INFO->DST.LEVEL, INFO->DST.BOX.X, INFO->DST.BOX.Y,
                           INFO->DST.BOX.Z);
   } ELSE {
      VREND_DEBUG(DBG_BLIT, CTX, "  USE BLIT_INT\N");
      VREND_RENDERER_BLIT_INT(CTX, SRC_RES, DST_RES, INFO);
   }

   IF (INFO->RENDER_CONDITION_ENABLE == FALSE)
      VREND_PAUSE_RENDER_CONDITION(CTX, FALSE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 513284_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL CREATE_REF_FOR_KEY(JOIN *JOIN, JOIN_TAB *J,
                               KEYUSE *ORG_KEYUSE, BOOL ALLOW_FULL_SCAN, 
                               TABLE_MAP USED_TABLES)
{
  UINT KEYPARTS, LENGTH, KEY;
  TABLE *TABLE;
  KEY *KEYINFO;
  KEYUSE *KEYUSE= ORG_KEYUSE;
  BOOL FTKEY= (KEYUSE->KEYPART == FT_KEYPART);
  THD *THD= JOIN->THD;
  DBUG_ENTER("CREATE_REF_FOR_KEY");

  /*  USE BEST KEY FROM FIND_BEST */
  TABLE= J->TABLE;
  KEY= KEYUSE->KEY;
  IF (!IS_HASH_JOIN_KEY_NO(KEY))
    KEYINFO= TABLE->KEY_INFO+KEY;
  ELSE
  {
    IF (CREATE_HJ_KEY_FOR_TABLE(JOIN, J, ORG_KEYUSE, USED_TABLES))
      DBUG_RETURN(TRUE);
    KEYINFO= J->HJ_KEY;
  }

  IF (FTKEY)
  {
    ITEM_FUNC_MATCH *IFM=(ITEM_FUNC_MATCH *)KEYUSE->VAL;

    LENGTH=0;
    KEYPARTS=1;
    IFM->JOIN_KEY=1;
  }
  ELSE
  {
    KEYPARTS=LENGTH=0;
    UINT FOUND_PART_REF_OR_NULL= 0;
    /*
      CALCULATE LENGTH FOR THE USED KEY
      STOP IF THERE IS A MISSING KEY PART OR WHEN WE FIND SECOND KEY_PART
      WITH KEY_OPTIMIZE_REF_OR_NULL
    */
    DO
    {
      IF (!(~USED_TABLES & KEYUSE->USED_TABLES) &&
	  J->KEYUSE_IS_VALID_FOR_ACCESS_IN_CHOSEN_PLAN(JOIN, KEYUSE))
      {
        IF  (ARE_TABLES_LOCAL(J, KEYUSE->VAL->USED_TABLES()))
        {
          IF ((IS_HASH_JOIN_KEY_NO(KEY) && KEYUSE->KEYPART != NO_KEYPART) ||
              (!IS_HASH_JOIN_KEY_NO(KEY) && KEYPARTS == KEYUSE->KEYPART &&
               !(FOUND_PART_REF_OR_NULL & KEYUSE->OPTIMIZE)))
          {
             LENGTH+= KEYINFO->KEY_PART[KEYPARTS].STORE_LENGTH;
             KEYPARTS++;
             FOUND_PART_REF_OR_NULL|= KEYUSE->OPTIMIZE & ~KEY_OPTIMIZE_EQ;
          }
        }
      }
      KEYUSE++;
    } WHILE (KEYUSE->TABLE == TABLE && KEYUSE->KEY == KEY);

    IF (!KEYPARTS && ALLOW_FULL_SCAN)
    {
      /* IT'S A LOOSEINDEXSCAN STRATEGY SCANNING WHOLE INDEX */
      J->TYPE= JT_ALL;
      J->INDEX= KEY;
      DBUG_RETURN(FALSE);
    }

    DBUG_ASSERT(LENGTH > 0);
    DBUG_ASSERT(KEYPARTS != 0);
  } /* NOT FTKEY */
  
  /* SET UP FIELDREF */
  J->REF.KEY_PARTS= KEYPARTS;
  J->REF.KEY_LENGTH= LENGTH;
  J->REF.KEY= (INT) KEY;
  IF (!(J->REF.KEY_BUFF= (UCHAR*) THD->CALLOC(ALIGN_SIZE(LENGTH)*2)) ||
      !(J->REF.KEY_COPY= (STORE_KEY**) THD->ALLOC((SIZEOF(STORE_KEY*) *
						          (KEYPARTS+1)))) ||
      !(J->REF.ITEMS=(ITEM**) THD->ALLOC(SIZEOF(ITEM*)*KEYPARTS)) ||
      !(J->REF.COND_GUARDS= (BOOL**) THD->ALLOC(SIZEOF(UINT*)*KEYPARTS)))
  {
    DBUG_RETURN(TRUE);
  }
  J->REF.KEY_BUFF2=J->REF.KEY_BUFF+ALIGN_SIZE(LENGTH);
  J->REF.KEY_ERR=1;
  J->REF.HAS_RECORD= FALSE;
  J->REF.NULL_REJECTING= 0;
  J->REF.DISABLE_CACHE= FALSE;
  J->REF.NULL_REF_PART= NO_REF_PART;
  J->REF.CONST_REF_PART_MAP= 0;
  KEYUSE=ORG_KEYUSE;

  STORE_KEY **REF_KEY= J->REF.KEY_COPY;
  UCHAR *KEY_BUFF=J->REF.KEY_BUFF, *NULL_REF_KEY= 0;
  UINT NULL_REF_PART= NO_REF_PART;
  BOOL KEYUSE_USES_NO_TABLES= TRUE;
  IF (FTKEY)
  {
    J->REF.ITEMS[0]=((ITEM_FUNC*)(KEYUSE->VAL))->KEY_ITEM();
    /* PREDICATES PUSHED DOWN INTO SUBQUERY CAN'T BE USED FT ACCESS */
    J->REF.COND_GUARDS[0]= NULL;
    IF (KEYUSE->USED_TABLES)
      DBUG_RETURN(TRUE);                        // NOT SUPPORTED YET. SERG

    J->TYPE=JT_FT;
  }
  ELSE
  {
    UINT I;
    FOR (I=0 ; I < KEYPARTS ; KEYUSE++,I++)
    {
      WHILE (((~USED_TABLES) & KEYUSE->USED_TABLES) ||
	     !J->KEYUSE_IS_VALID_FOR_ACCESS_IN_CHOSEN_PLAN(JOIN, KEYUSE) ||
             KEYUSE->KEYPART == NO_KEYPART ||
	     (KEYUSE->KEYPART != 
              (IS_HASH_JOIN_KEY_NO(KEY) ?
                 KEYINFO->KEY_PART[I].FIELD->FIELD_INDEX : I)) || 
             !ARE_TABLES_LOCAL(J, KEYUSE->VAL->USED_TABLES())) 
	 KEYUSE++;                              	/* SKIP OTHER PARTS */ 

      UINT MAYBE_NULL= MY_TEST(KEYINFO->KEY_PART[I].NULL_BIT);
      J->REF.ITEMS[I]=KEYUSE->VAL;		// SAVE FOR COND REMOVAL
      J->REF.COND_GUARDS[I]= KEYUSE->COND_GUARD;
      IF (KEYUSE->NULL_REJECTING) 
        J->REF.NULL_REJECTING|= (KEY_PART_MAP)1 << I;
      KEYUSE_USES_NO_TABLES= KEYUSE_USES_NO_TABLES && !KEYUSE->USED_TABLES;
      /*
        TODO: WE SHOULD REMOVE THIS CHECK FOR THD->LEX->DESCRIBE ON THE NEXT
        LINE. WITH SHOW EXPLAIN CODE, EXPLAIN PRINTOUT CODE NO LONGER DEPENDS
        ON IT. HOWEVER, REMOVING THE CHECK CAUSED CHANGE IN LOTS OF QUERY
        PLANS! DOES THE OPTIMIZER DEPEND ON THE CONTENTS OF
        TABLE_REF->KEY_COPY ? IF YES, DO WE PRODUCE INCORRECT EXPLAINS? 
      */
      IF (!KEYUSE->VAL->USED_TABLES() && !THD->LEX->DESCRIBE)
      {					// COMPARE AGAINST CONSTANT
	STORE_KEY_ITEM TMP(THD, 
                           KEYINFO->KEY_PART[I].FIELD,
                           KEY_BUFF + MAYBE_NULL,
                           MAYBE_NULL ?  KEY_BUFF : 0,
                           KEYINFO->KEY_PART[I].LENGTH,
                           KEYUSE->VAL,
                           FALSE);
	IF (THD->IS_FATAL_ERROR)
	  DBUG_RETURN(TRUE);
	TMP.COPY();
        J->REF.CONST_REF_PART_MAP |= KEY_PART_MAP(1) << I ;
      }
      ELSE
	*REF_KEY++= GET_STORE_KEY(THD,
				  KEYUSE,JOIN->CONST_TABLE_MAP,
				  &KEYINFO->KEY_PART[I],
				  KEY_BUFF, MAYBE_NULL);
      /*
	REMEMBER IF WE ARE GOING TO USE REF_OR_NULL
	BUT ONLY IF FIELD _REALLY_ CAN BE NULL I.E. WE FORCE JT_REF
	INSTEAD OF JT_REF_OR_NULL IN CASE IF FIELD CAN'T BE NULL
      */
      IF ((KEYUSE->OPTIMIZE & KEY_OPTIMIZE_REF_OR_NULL) && MAYBE_NULL)
      {
	NULL_REF_KEY= KEY_BUFF;
        NULL_REF_PART= I;
      }
      KEY_BUFF+= KEYINFO->KEY_PART[I].STORE_LENGTH;
    }
  } /* NOT FTKEY */
  *REF_KEY=0;				// END_MARKER
  IF (J->TYPE == JT_FT)
    DBUG_RETURN(0);
  ULONG KEY_FLAGS= J->TABLE->ACTUAL_KEY_FLAGS(KEYINFO);
  IF (J->TYPE == JT_CONST)
    J->TABLE->CONST_TABLE= 1;
  ELSE IF (!((KEYPARTS == KEYINFO->USER_DEFINED_KEY_PARTS && 
              ((KEY_FLAGS & (HA_NOSAME | HA_NULL_PART_KEY)) == HA_NOSAME)) ||
	     (KEYPARTS > KEYINFO->USER_DEFINED_KEY_PARTS &&   // TRUE ONLY FOR EXTENDED KEYS 
              MY_TEST(KEY_FLAGS & HA_EXT_NOSAME) &&
              KEYPARTS == KEYINFO->EXT_KEY_PARTS)) ||
	    NULL_REF_KEY)
  {
    /* MUST READ WITH REPEAT */
    J->TYPE= NULL_REF_KEY ? JT_REF_OR_NULL : JT_REF;
    J->REF.NULL_REF_KEY= NULL_REF_KEY;
    J->REF.NULL_REF_PART= NULL_REF_PART;
  }
  ELSE IF (KEYUSE_USES_NO_TABLES)
  {
    /*
      THIS HAPPEN IF WE ARE USING A CONSTANT EXPRESSION IN THE ON PART
      OF AN LEFT JOIN.
      SELECT * FROM A LEFT JOIN B ON B.KEY=30
      HERE WE SHOULD NOT MARK THE TABLE AS A 'CONST' AS A FIELD MAY
      HAVE A 'NORMAL' VALUE OR A NULL VALUE.
    */
    J->TYPE=JT_CONST;
  }
  ELSE
    J->TYPE=JT_EQ_REF;

  J->READ_RECORD.UNLOCK_ROW= (J->TYPE == JT_EQ_REF)? 
                             JOIN_READ_KEY_UNLOCK_ROW : RR_UNLOCK_ROW; 
  DBUG_RETURN(0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 299978_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT ELO_RAW_EVENT(STRUCT HID_DEVICE *HDEV, STRUCT HID_REPORT *REPORT,
	 U8 *DATA, INT SIZE)
{
	STRUCT HID_INPUT *HIDINPUT;

	IF (!(HDEV->CLAIMED & HID_CLAIMED_INPUT) || LIST_EMPTY(&HDEV->INPUTS))
		RETURN 0;

	HIDINPUT = LIST_FIRST_ENTRY(&HDEV->INPUTS, STRUCT HID_INPUT, LIST);

	SWITCH (REPORT->ID) {
	CASE 0:
		IF (DATA[0] == 'T') {	/* MANDATORY ELO PACKET MARKER */
			ELO_PROCESS_DATA(HIDINPUT->INPUT, DATA, SIZE);
			RETURN 1;
		}
		BREAK;
	DEFAULT:	/* UNKNOWN REPORT */
		/* UNKNOWN REPORT TYPE; PASS UPSTREAM */
		HID_INFO(HDEV, "UNKNOWN REPORT TYPE %D\N", REPORT->ID);
		BREAK;
	}

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201384_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GA_CONCAT_SHORTEN_ESC(GARRAY_T *GAP, CHAR_U *STR)
{
    CHAR_U  *P;
    CHAR_U  *S;
    INT	    C;
    INT	    CLEN;
    CHAR_U  BUF[NUMBUFLEN];
    INT	    SAME_LEN;

    IF (STR == NULL)
    {
	GA_CONCAT(GAP, (CHAR_U *)"NULL");
	RETURN;
    }

    FOR (P = STR; *P != NUL; ++P)
    {
	SAME_LEN = 1;
	S = P;
	C = MB_PTR2CHAR_ADV(&S);
	CLEN = S - P;
	WHILE (*S != NUL && C == MB_PTR2CHAR(S))
	{
	    ++SAME_LEN;
	    S += CLEN;
	}
	IF (SAME_LEN > 20)
	{
	    GA_CONCAT(GAP, (CHAR_U *)"\\[");
	    GA_CONCAT_ESC(GAP, P, CLEN);
	    GA_CONCAT(GAP, (CHAR_U *)" OCCURS ");
	    VIM_SNPRINTF((CHAR *)BUF, NUMBUFLEN, "%D", SAME_LEN);
	    GA_CONCAT(GAP, BUF);
	    GA_CONCAT(GAP, (CHAR_U *)" TIMES]");
	    P = S - 1;
	}
	ELSE
	    GA_CONCAT_ESC(GAP, P, CLEN);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202783_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BIGINT * BALLOC(INT K)
{
	INT X;
	BIGINT *RV;

	_THREAD_PRIVATE_MUTEX_LOCK(DTOA_MUTEX);
	IF ((RV = FREELIST[K])) {
		FREELIST[K] = RV->NEXT;
	} ELSE {
		X = 1 << K;
		RV = (BIGINT *)MALLOC(SIZEOF(BIGINT) + (X-1)*SIZEOF(LONG));
		RV->K = K;
		RV->MAXWDS = X;
	}
	_THREAD_PRIVATE_MUTEX_UNLOCK(DTOA_MUTEX);
	RV->SIGN = RV->WDS = 0;
	RETURN RV;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 463107_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EXPORTED INT ANNOTATEMORE_WRITEMASK(CONST CHAR *MBOXNAME, CONST CHAR *ENTRY,
                                    CONST CHAR *USERID, CONST STRUCT BUF *VALUE)
{
    IF (MBOXNAME_USEROWNSMAILBOX(USERID, MBOXNAME))
        RETURN ANNOTATEMORE_WRITE(MBOXNAME, ENTRY, "", VALUE);
    ELSE
        RETURN ANNOTATEMORE_WRITE(MBOXNAME, ENTRY, USERID, VALUE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224452_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR GF_TEXT_GUESS_FORMAT(CONST CHAR *FILENAME, U32 *FMT)
{
	CHAR SZLINE[2048];
	U32 VAL;
	S32 UNI_TYPE;
	FILE *TEST = GF_FOPEN(FILENAME, "RB");
	IF (!TEST) RETURN GF_URL_ERROR;
	UNI_TYPE = GF_TEXT_GET_UTF_TYPE(TEST);

	IF (UNI_TYPE>1) {
		CONST U16 *SPTR;
		CHAR SZUTF[1024];
		U32 READ = (U32) GF_FREAD(SZUTF, 1023, TEST);
		IF ((S32) READ < 0) {
			GF_FCLOSE(TEST);
			RETURN GF_IO_ERR;
		}
		SZUTF[READ]=0;
		SPTR = (U16*)SZUTF;
		/*READ = (U32) */GF_UTF8_WCSTOMBS(SZLINE, READ, &SPTR);
	} ELSE {
		VAL = (U32) GF_FREAD(SZLINE, 1024, TEST);
		IF ((S32) VAL<0) RETURN GF_IO_ERR;
		
		SZLINE[VAL]=0;
	}
	REM_TRAIL_MARKS(SZLINE, "\R\N\T ")

	*FMT = GF_TXTIN_MODE_NONE;
	IF ((SZLINE[0]=='{') && STRSTR(SZLINE, "}{")) *FMT = GF_TXTIN_MODE_SUB;
	ELSE IF (SZLINE[0] == '<') {
		CHAR *EXT = GF_FILE_EXT_START(FILENAME);
		IF (!STRNICMP(EXT, ".TTXT", 5)) *FMT = GF_TXTIN_MODE_TTXT;
		ELSE IF (!STRNICMP(EXT, ".TTML", 5)) *FMT = GF_TXTIN_MODE_TTML;
		EXT = STRSTR(SZLINE, "?>");
		IF (EXT) EXT += 2;
		IF (EXT && !EXT[0]) {
			IF (!GF_FGETS(SZLINE, 2048, TEST))
				SZLINE[0] = '\0';
		}
		IF (STRSTR(SZLINE, "X-QUICKTIME-TX3G") || STRSTR(SZLINE, "TEXT3GTRACK")) *FMT = GF_TXTIN_MODE_TEXML;
		ELSE IF (STRSTR(SZLINE, "TEXTSTREAM")) *FMT = GF_TXTIN_MODE_TTXT;
		ELSE IF (STRSTR(SZLINE, "TT")) *FMT = GF_TXTIN_MODE_TTML;
	}
	ELSE IF (STRSTR(SZLINE, "WEBVTT") )
		*FMT = GF_TXTIN_MODE_WEBVTT;
	ELSE IF (STRSTR(SZLINE, " --> ") )
		*FMT = GF_TXTIN_MODE_SRT; /* MIGHT WANT TO CHANGE THE DEFAULT TO WEBVTT */

	ELSE IF (!STRNCMP(SZLINE, "FWS", 3) || !STRNCMP(SZLINE, "CWS", 3))
		*FMT = GF_TXTIN_MODE_SWF_SVG;

	GF_FCLOSE(TEST);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201885_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
REGMATCH(
    CHAR_U	*SCAN,		    // CURRENT NODE.
    PROFTIME_T	*TM UNUSED,	    // TIMEOUT LIMIT OR NULL
    INT		*TIMED_OUT UNUSED)  // FLAG SET ON TIMEOUT OR NULL
{
  CHAR_U	*NEXT;		// NEXT NODE.
  INT		OP;
  INT		C;
  REGITEM_T	*RP;
  INT		NO;
  INT		STATUS;		// ONE OF THE RA_ VALUES:
#IFDEF FEAT_RELTIME
  INT		TM_COUNT = 0;
#ENDIF

  // MAKE "REGSTACK" AND "BACKPOS" EMPTY.  THEY ARE ALLOCATED AND FREED IN
  // BT_REGEXEC_BOTH() TO REDUCE MALLOC()/FREE() CALLS.
  REGSTACK.GA_LEN = 0;
  BACKPOS.GA_LEN = 0;

  // REPEAT UNTIL "REGSTACK" IS EMPTY.
  FOR (;;)
  {
    // SOME PATTERNS MAY TAKE A LONG TIME TO MATCH, E.G., "\([A-Z]\+\)\+Q".
    // ALLOW INTERRUPTING THEM WITH CTRL-C.
    FAST_BREAKCHECK();

#IFDEF DEBUG
    IF (SCAN != NULL && REGNARRATE)
    {
	MCH_ERRMSG((CHAR *)REGPROP(SCAN));
	MCH_ERRMSG("(\N");
    }
#ENDIF

    // REPEAT FOR ITEMS THAT CAN BE MATCHED SEQUENTIALLY, WITHOUT USING THE
    // REGSTACK.
    FOR (;;)
    {
	IF (GOT_INT || SCAN == NULL)
	{
	    STATUS = RA_FAIL;
	    BREAK;
	}
#IFDEF FEAT_RELTIME
	// CHECK FOR TIMEOUT ONCE IN A 100 TIMES TO AVOID OVERHEAD.
	IF (TM != NULL && ++TM_COUNT == 100)
	{
	    TM_COUNT = 0;
	    IF (PROFILE_PASSED_LIMIT(TM))
	    {
		IF (TIMED_OUT != NULL)
		    *TIMED_OUT = TRUE;
		STATUS = RA_FAIL;
		BREAK;
	    }
	}
#ENDIF
	STATUS = RA_CONT;

#IFDEF DEBUG
	IF (REGNARRATE)
	{
	    MCH_ERRMSG((CHAR *)REGPROP(SCAN));
	    MCH_ERRMSG("...\N");
# IFDEF FEAT_SYN_HL
	    IF (RE_EXTMATCH_IN != NULL)
	    {
		INT I;

		MCH_ERRMSG(_("EXTERNAL SUBMATCHES:\N"));
		FOR (I = 0; I < NSUBEXP; I++)
		{
		    MCH_ERRMSG("    \"");
		    IF (RE_EXTMATCH_IN->MATCHES[I] != NULL)
			MCH_ERRMSG((CHAR *)RE_EXTMATCH_IN->MATCHES[I]);
		    MCH_ERRMSG("\"\N");
		}
	    }
# ENDIF
	}
#ENDIF
	NEXT = REGNEXT(SCAN);

	OP = OP(SCAN);
	// CHECK FOR CHARACTER CLASS WITH NL ADDED.
	IF (!REX.REG_LINE_LBR && WITH_NL(OP) && REG_MULTI
			     && *REX.INPUT == NUL && REX.LNUM <= REX.REG_MAXLINE)
	{
	    REG_NEXTLINE();
	}
	ELSE IF (REX.REG_LINE_LBR && WITH_NL(OP) && *REX.INPUT == '\N')
	{
	    ADVANCE_REGINPUT();
	}
	ELSE
	{
	  IF (WITH_NL(OP))
	      OP -= ADD_NL;
	  IF (HAS_MBYTE)
	      C = (*MB_PTR2CHAR)(REX.INPUT);
	  ELSE
	      C = *REX.INPUT;
	  SWITCH (OP)
	  {
	  CASE BOL:
	    IF (REX.INPUT != REX.LINE)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE EOL:
	    IF (C != NUL)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_BOF:
	    // WE'RE NOT AT THE BEGINNING OF THE FILE WHEN BELOW THE FIRST
	    // LINE WHERE WE STARTED, NOT AT THE START OF THE LINE OR WE
	    // DIDN'T START AT THE FIRST LINE OF THE BUFFER.
	    IF (REX.LNUM != 0 || REX.INPUT != REX.LINE
				       || (REG_MULTI && REX.REG_FIRSTLNUM > 1))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_EOF:
	    IF (REX.LNUM != REX.REG_MAXLINE || C != NUL)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE CURSOR:
	    // CHECK IF THE BUFFER IS IN A WINDOW AND COMPARE THE
	    // REX.REG_WIN->W_CURSOR POSITION TO THE MATCH POSITION.
	    IF (REX.REG_WIN == NULL
		    || (REX.LNUM + REX.REG_FIRSTLNUM
						 != REX.REG_WIN->W_CURSOR.LNUM)
		    || ((COLNR_T)(REX.INPUT - REX.LINE)
						 != REX.REG_WIN->W_CURSOR.COL))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_MARK:
	    // COMPARE THE MARK POSITION TO THE MATCH POSITION.
	    {
		INT	MARK = OPERAND(SCAN)[0];
		INT	CMP = OPERAND(SCAN)[1];
		POS_T	*POS;

		POS = GETMARK_BUF(REX.REG_BUF, MARK, FALSE);
		IF (POS == NULL		     // MARK DOESN'T EXIST
			|| POS->LNUM <= 0)   // MARK ISN'T SET IN REG_BUF
		{
		    STATUS = RA_NOMATCH;
		}
		ELSE
		{
		    COLNR_T POS_COL = POS->LNUM == REX.LNUM + REX.REG_FIRSTLNUM
							  && POS->COL == MAXCOL
				      ? (COLNR_T)STRLEN(REG_GETLINE(
						POS->LNUM - REX.REG_FIRSTLNUM))
				      : POS->COL;

		    IF ((POS->LNUM == REX.LNUM + REX.REG_FIRSTLNUM
				? (POS_COL == (COLNR_T)(REX.INPUT - REX.LINE)
				    ? (CMP == '<' || CMP == '>')
				    : (POS_COL < (COLNR_T)(REX.INPUT - REX.LINE)
					? CMP != '>'
					: CMP != '<'))
				: (POS->LNUM < REX.LNUM + REX.REG_FIRSTLNUM
				    ? CMP != '>'
				    : CMP != '<')))
		    STATUS = RA_NOMATCH;
		}
	    }
	    BREAK;

	  CASE RE_VISUAL:
	    IF (!REG_MATCH_VISUAL())
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_LNUM:
	    IF (!REG_MULTI || !RE_NUM_CMP((LONG_U)(REX.LNUM + REX.REG_FIRSTLNUM),
									SCAN))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_COL:
	    IF (!RE_NUM_CMP((LONG_U)(REX.INPUT - REX.LINE) + 1, SCAN))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_VCOL:
	    IF (!RE_NUM_CMP((LONG_U)WIN_LINETABSIZE(
			    REX.REG_WIN == NULL ? CURWIN : REX.REG_WIN,
			    REX.LINE, (COLNR_T)(REX.INPUT - REX.LINE)) + 1, SCAN))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE BOW:	// \<WORD; REX.INPUT POINTS TO W
	    IF (C == NUL)	// CAN'T MATCH AT END OF LINE
		STATUS = RA_NOMATCH;
	    ELSE IF (HAS_MBYTE)
	    {
		INT THIS_CLASS;

		// GET CLASS OF CURRENT AND PREVIOUS CHAR (IF IT EXISTS).
		THIS_CLASS = MB_GET_CLASS_BUF(REX.INPUT, REX.REG_BUF);
		IF (THIS_CLASS <= 1)
		    STATUS = RA_NOMATCH;  // NOT ON A WORD AT ALL
		ELSE IF (REG_PREV_CLASS() == THIS_CLASS)
		    STATUS = RA_NOMATCH;  // PREVIOUS CHAR IS IN SAME WORD
	    }
	    ELSE
	    {
		IF (!VIM_ISWORDC_BUF(C, REX.REG_BUF) || (REX.INPUT > REX.LINE
				&& VIM_ISWORDC_BUF(REX.INPUT[-1], REX.REG_BUF)))
		    STATUS = RA_NOMATCH;
	    }
	    BREAK;

	  CASE EOW:	// WORD\>; REX.INPUT POINTS AFTER D
	    IF (REX.INPUT == REX.LINE)    // CAN'T MATCH AT START OF LINE
		STATUS = RA_NOMATCH;
	    ELSE IF (HAS_MBYTE)
	    {
		INT THIS_CLASS, PREV_CLASS;

		// GET CLASS OF CURRENT AND PREVIOUS CHAR (IF IT EXISTS).
		THIS_CLASS = MB_GET_CLASS_BUF(REX.INPUT, REX.REG_BUF);
		PREV_CLASS = REG_PREV_CLASS();
		IF (THIS_CLASS == PREV_CLASS
			|| PREV_CLASS == 0 || PREV_CLASS == 1)
		    STATUS = RA_NOMATCH;
	    }
	    ELSE
	    {
		IF (!VIM_ISWORDC_BUF(REX.INPUT[-1], REX.REG_BUF)
			|| (REX.INPUT[0] != NUL
					   && VIM_ISWORDC_BUF(C, REX.REG_BUF)))
		    STATUS = RA_NOMATCH;
	    }
	    BREAK; // MATCHED WITH EOW

	  CASE ANY:
	    // ANY DOES NOT MATCH NEW LINES.
	    IF (C == NUL)
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE IDENT:
	    IF (!VIM_ISIDC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SIDENT:
	    IF (VIM_ISDIGIT(*REX.INPUT) || !VIM_ISIDC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE KWORD:
	    IF (!VIM_ISWORDP_BUF(REX.INPUT, REX.REG_BUF))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SKWORD:
	    IF (VIM_ISDIGIT(*REX.INPUT)
				    || !VIM_ISWORDP_BUF(REX.INPUT, REX.REG_BUF))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE FNAME:
	    IF (!VIM_ISFILEC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SFNAME:
	    IF (VIM_ISDIGIT(*REX.INPUT) || !VIM_ISFILEC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE PRINT:
	    IF (!VIM_ISPRINTC(PTR2CHAR(REX.INPUT)))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SPRINT:
	    IF (VIM_ISDIGIT(*REX.INPUT) || !VIM_ISPRINTC(PTR2CHAR(REX.INPUT)))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE WHITE:
	    IF (!VIM_ISWHITE(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NWHITE:
	    IF (C == NUL || VIM_ISWHITE(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE DIGIT:
	    IF (!RI_DIGIT(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NDIGIT:
	    IF (C == NUL || RI_DIGIT(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE HEX:
	    IF (!RI_HEX(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NHEX:
	    IF (C == NUL || RI_HEX(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE OCTAL:
	    IF (!RI_OCTAL(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NOCTAL:
	    IF (C == NUL || RI_OCTAL(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE WORD:
	    IF (!RI_WORD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NWORD:
	    IF (C == NUL || RI_WORD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE HEAD:
	    IF (!RI_HEAD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NHEAD:
	    IF (C == NUL || RI_HEAD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE ALPHA:
	    IF (!RI_ALPHA(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NALPHA:
	    IF (C == NUL || RI_ALPHA(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE LOWER:
	    IF (!RI_LOWER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NLOWER:
	    IF (C == NUL || RI_LOWER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE UPPER:
	    IF (!RI_UPPER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NUPPER:
	    IF (C == NUL || RI_UPPER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE EXACTLY:
	    {
		INT	LEN;
		CHAR_U	*OPND;

		OPND = OPERAND(SCAN);
		// INLINE THE FIRST BYTE, FOR SPEED.
		IF (*OPND != *REX.INPUT
			&& (!REX.REG_IC
			    || (!ENC_UTF8
			      && MB_TOLOWER(*OPND) != MB_TOLOWER(*REX.INPUT))))
		    STATUS = RA_NOMATCH;
		ELSE IF (*OPND == NUL)
		{
		    // MATCH EMPTY STRING ALWAYS WORKS; HAPPENS WHEN "~" IS
		    // EMPTY.
		}
		ELSE
		{
		    IF (OPND[1] == NUL && !(ENC_UTF8 && REX.REG_IC))
		    {
			LEN = 1;	// MATCHED A SINGLE BYTE ABOVE
		    }
		    ELSE
		    {
			// NEED TO MATCH FIRST BYTE AGAIN FOR MULTI-BYTE.
			LEN = (INT)STRLEN(OPND);
			IF (CSTRNCMP(OPND, REX.INPUT, &LEN) != 0)
			    STATUS = RA_NOMATCH;
		    }
		    // CHECK FOR FOLLOWING COMPOSING CHARACTER, UNLESS %C
		    // FOLLOWS (SKIPS OVER ALL COMPOSING CHARS).
		    IF (STATUS != RA_NOMATCH
			    && ENC_UTF8
			    && UTF_COMPOSINGLIKE(REX.INPUT, REX.INPUT + LEN)
			    && !REX.REG_ICOMBINE
			    && OP(NEXT) != RE_COMPOSING)
		    {
			// RAARON: THIS CODE MAKES A COMPOSING CHARACTER GET
			// IGNORED, WHICH IS THE CORRECT BEHAVIOR (SOMETIMES)
			// FOR VOWELED HEBREW TEXTS.
			STATUS = RA_NOMATCH;
		    }
		    IF (STATUS != RA_NOMATCH)
			REX.INPUT += LEN;
		}
	    }
	    BREAK;

	  CASE ANYOF:
	  CASE ANYBUT:
	    IF (C == NUL)
		STATUS = RA_NOMATCH;
	    ELSE IF ((CSTRCHR(OPERAND(SCAN), C) == NULL) == (OP == ANYOF))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE MULTIBYTECODE:
	    IF (HAS_MBYTE)
	    {
		INT	I, LEN;
		CHAR_U	*OPND;
		INT	OPNDC = 0, INPC;

		OPND = OPERAND(SCAN);
		// SAFETY CHECK (JUST IN CASE 'ENCODING' WAS CHANGED SINCE
		// COMPILING THE PROGRAM).
		IF ((LEN = (*MB_PTR2LEN)(OPND)) < 2)
		{
		    STATUS = RA_NOMATCH;
		    BREAK;
		}
		IF (ENC_UTF8)
		    OPNDC = UTF_PTR2CHAR(OPND);
		IF (ENC_UTF8 && UTF_ISCOMPOSING(OPNDC))
		{
		    // WHEN ONLY A COMPOSING CHAR IS GIVEN MATCH AT ANY
		    // POSITION WHERE THAT COMPOSING CHAR APPEARS.
		    STATUS = RA_NOMATCH;
		    FOR (I = 0; REX.INPUT[I] != NUL;
						I += UTF_PTR2LEN(REX.INPUT + I))
		    {
			INPC = UTF_PTR2CHAR(REX.INPUT + I);
			IF (!UTF_ISCOMPOSING(INPC))
			{
			    IF (I > 0)
				BREAK;
			}
			ELSE IF (OPNDC == INPC)
			{
			    // INCLUDE ALL FOLLOWING COMPOSING CHARS.
			    LEN = I + UTFC_PTR2LEN(REX.INPUT + I);
			    STATUS = RA_MATCH;
			    BREAK;
			}
		    }
		}
		ELSE
		    FOR (I = 0; I < LEN; ++I)
			IF (OPND[I] != REX.INPUT[I])
			{
			    STATUS = RA_NOMATCH;
			    BREAK;
			}
		REX.INPUT += LEN;
	    }
	    ELSE
		STATUS = RA_NOMATCH;
	    BREAK;
	  CASE RE_COMPOSING:
	    IF (ENC_UTF8)
	    {
		// SKIP COMPOSING CHARACTERS.
		WHILE (UTF_ISCOMPOSING(UTF_PTR2CHAR(REX.INPUT)))
		    MB_CPTR_ADV(REX.INPUT);
	    }
	    BREAK;

	  CASE NOTHING:
	    BREAK;

	  CASE BACK:
	    {
		INT		I;
		BACKPOS_T	*BP;

		// WHEN WE RUN INTO BACK WE NEED TO CHECK IF WE DON'T KEEP
		// LOOPING WITHOUT MATCHING ANY INPUT.  THE SECOND AND LATER
		// TIMES A BACK IS ENCOUNTERED IT FAILS IF THE INPUT IS STILL
		// AT THE SAME POSITION AS THE PREVIOUS TIME.
		// THE POSITIONS ARE STORED IN "BACKPOS" AND FOUND BY THE
		// CURRENT VALUE OF "SCAN", THE POSITION IN THE RE PROGRAM.
		BP = (BACKPOS_T *)BACKPOS.GA_DATA;
		FOR (I = 0; I < BACKPOS.GA_LEN; ++I)
		    IF (BP[I].BP_SCAN == SCAN)
			BREAK;
		IF (I == BACKPOS.GA_LEN)
		{
		    // FIRST TIME AT THIS BACK, MAKE ROOM TO STORE THE POS.
		    IF (GA_GROW(&BACKPOS, 1) == FAIL)
			STATUS = RA_FAIL;
		    ELSE
		    {
			// GET "GA_DATA" AGAIN, IT MAY HAVE CHANGED
			BP = (BACKPOS_T *)BACKPOS.GA_DATA;
			BP[I].BP_SCAN = SCAN;
			++BACKPOS.GA_LEN;
		    }
		}
		ELSE IF (REG_SAVE_EQUAL(&BP[I].BP_POS))
		    // STILL AT SAME POSITION AS LAST TIME, FAIL.
		    STATUS = RA_NOMATCH;

		IF (STATUS != RA_FAIL && STATUS != RA_NOMATCH)
		    REG_SAVE(&BP[I].BP_POS, &BACKPOS);
	    }
	    BREAK;

	  CASE MOPEN + 0:   // MATCH START: \ZS
	  CASE MOPEN + 1:   // \(
	  CASE MOPEN + 2:
	  CASE MOPEN + 3:
	  CASE MOPEN + 4:
	  CASE MOPEN + 5:
	  CASE MOPEN + 6:
	  CASE MOPEN + 7:
	  CASE MOPEN + 8:
	  CASE MOPEN + 9:
	    {
		NO = OP - MOPEN;
		CLEANUP_SUBEXPR();
		RP = REGSTACK_PUSH(RS_MOPEN, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REX.REG_STARTPOS[NO],
							  &REX.REG_STARTP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;

	  CASE NOPEN:	    // \%(
	  CASE NCLOSE:	    // \) AFTER \%(
		IF (REGSTACK_PUSH(RS_NOPEN, SCAN) == NULL)
		    STATUS = RA_FAIL;
		// WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		BREAK;

#IFDEF FEAT_SYN_HL
	  CASE ZOPEN + 1:
	  CASE ZOPEN + 2:
	  CASE ZOPEN + 3:
	  CASE ZOPEN + 4:
	  CASE ZOPEN + 5:
	  CASE ZOPEN + 6:
	  CASE ZOPEN + 7:
	  CASE ZOPEN + 8:
	  CASE ZOPEN + 9:
	    {
		NO = OP - ZOPEN;
		CLEANUP_ZSUBEXPR();
		RP = REGSTACK_PUSH(RS_ZOPEN, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REG_STARTZPOS[NO],
							     &REG_STARTZP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;
#ENDIF

	  CASE MCLOSE + 0:  // MATCH END: \ZE
	  CASE MCLOSE + 1:  // \)
	  CASE MCLOSE + 2:
	  CASE MCLOSE + 3:
	  CASE MCLOSE + 4:
	  CASE MCLOSE + 5:
	  CASE MCLOSE + 6:
	  CASE MCLOSE + 7:
	  CASE MCLOSE + 8:
	  CASE MCLOSE + 9:
	    {
		NO = OP - MCLOSE;
		CLEANUP_SUBEXPR();
		RP = REGSTACK_PUSH(RS_MCLOSE, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REX.REG_ENDPOS[NO],
							    &REX.REG_ENDP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE ZCLOSE + 1:  // \) AFTER \Z(
	  CASE ZCLOSE + 2:
	  CASE ZCLOSE + 3:
	  CASE ZCLOSE + 4:
	  CASE ZCLOSE + 5:
	  CASE ZCLOSE + 6:
	  CASE ZCLOSE + 7:
	  CASE ZCLOSE + 8:
	  CASE ZCLOSE + 9:
	    {
		NO = OP - ZCLOSE;
		CLEANUP_ZSUBEXPR();
		RP = REGSTACK_PUSH(RS_ZCLOSE, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REG_ENDZPOS[NO],
							      &REG_ENDZP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;
#ENDIF

	  CASE BACKREF + 1:
	  CASE BACKREF + 2:
	  CASE BACKREF + 3:
	  CASE BACKREF + 4:
	  CASE BACKREF + 5:
	  CASE BACKREF + 6:
	  CASE BACKREF + 7:
	  CASE BACKREF + 8:
	  CASE BACKREF + 9:
	    {
		INT		LEN;

		NO = OP - BACKREF;
		CLEANUP_SUBEXPR();
		IF (!REG_MULTI)		// SINGLE-LINE REGEXP
		{
		    IF (REX.REG_STARTP[NO] == NULL || REX.REG_ENDP[NO] == NULL)
		    {
			// BACKREF WAS NOT SET: MATCH AN EMPTY STRING.
			LEN = 0;
		    }
		    ELSE
		    {
			// COMPARE CURRENT INPUT WITH BACK-REF IN THE SAME
			// LINE.
			LEN = (INT)(REX.REG_ENDP[NO] - REX.REG_STARTP[NO]);
			IF (CSTRNCMP(REX.REG_STARTP[NO], REX.INPUT, &LEN) != 0)
			    STATUS = RA_NOMATCH;
		    }
		}
		ELSE				// MULTI-LINE REGEXP
		{
		    IF (REX.REG_STARTPOS[NO].LNUM < 0
						|| REX.REG_ENDPOS[NO].LNUM < 0)
		    {
			// BACKREF WAS NOT SET: MATCH AN EMPTY STRING.
			LEN = 0;
		    }
		    ELSE
		    {
			IF (REX.REG_STARTPOS[NO].LNUM == REX.LNUM
				&& REX.REG_ENDPOS[NO].LNUM == REX.LNUM)
			{
			    // COMPARE BACK-REF WITHIN THE CURRENT LINE.
			    LEN = REX.REG_ENDPOS[NO].COL
						    - REX.REG_STARTPOS[NO].COL;
			    IF (CSTRNCMP(REX.LINE + REX.REG_STARTPOS[NO].COL,
							  REX.INPUT, &LEN) != 0)
				STATUS = RA_NOMATCH;
			}
			ELSE
			{
			    // MESSY SITUATION: NEED TO COMPARE BETWEEN TWO
			    // LINES.
			    INT R = MATCH_WITH_BACKREF(
					    REX.REG_STARTPOS[NO].LNUM,
					    REX.REG_STARTPOS[NO].COL,
					    REX.REG_ENDPOS[NO].LNUM,
					    REX.REG_ENDPOS[NO].COL,
					    &LEN);

			    IF (R != RA_MATCH)
				STATUS = R;
			}
		    }
		}

		// MATCHED THE BACKREF, SKIP OVER IT.
		REX.INPUT += LEN;
	    }
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE ZREF + 1:
	  CASE ZREF + 2:
	  CASE ZREF + 3:
	  CASE ZREF + 4:
	  CASE ZREF + 5:
	  CASE ZREF + 6:
	  CASE ZREF + 7:
	  CASE ZREF + 8:
	  CASE ZREF + 9:
	    {
		INT	LEN;

		CLEANUP_ZSUBEXPR();
		NO = OP - ZREF;
		IF (RE_EXTMATCH_IN != NULL
			&& RE_EXTMATCH_IN->MATCHES[NO] != NULL)
		{
		    LEN = (INT)STRLEN(RE_EXTMATCH_IN->MATCHES[NO]);
		    IF (CSTRNCMP(RE_EXTMATCH_IN->MATCHES[NO],
							  REX.INPUT, &LEN) != 0)
			STATUS = RA_NOMATCH;
		    ELSE
			REX.INPUT += LEN;
		}
		ELSE
		{
		    // BACKREF WAS NOT SET: MATCH AN EMPTY STRING.
		}
	    }
	    BREAK;
#ENDIF

	  CASE BRANCH:
	    {
		IF (OP(NEXT) != BRANCH) // NO CHOICE.
		    NEXT = OPERAND(SCAN);	// AVOID RECURSION.
		ELSE
		{
		    RP = REGSTACK_PUSH(RS_BRANCH, SCAN);
		    IF (RP == NULL)
			STATUS = RA_FAIL;
		    ELSE
			STATUS = RA_BREAK;	// REST IS BELOW
		}
	    }
	    BREAK;

	  CASE BRACE_LIMITS:
	    {
		IF (OP(NEXT) == BRACE_SIMPLE)
		{
		    BL_MINVAL = OPERAND_MIN(SCAN);
		    BL_MAXVAL = OPERAND_MAX(SCAN);
		}
		ELSE IF (OP(NEXT) >= BRACE_COMPLEX
			&& OP(NEXT) < BRACE_COMPLEX + 10)
		{
		    NO = OP(NEXT) - BRACE_COMPLEX;
		    BRACE_MIN[NO] = OPERAND_MIN(SCAN);
		    BRACE_MAX[NO] = OPERAND_MAX(SCAN);
		    BRACE_COUNT[NO] = 0;
		}
		ELSE
		{
		    INTERNAL_ERROR("BRACE_LIMITS");
		    STATUS = RA_FAIL;
		}
	    }
	    BREAK;

	  CASE BRACE_COMPLEX + 0:
	  CASE BRACE_COMPLEX + 1:
	  CASE BRACE_COMPLEX + 2:
	  CASE BRACE_COMPLEX + 3:
	  CASE BRACE_COMPLEX + 4:
	  CASE BRACE_COMPLEX + 5:
	  CASE BRACE_COMPLEX + 6:
	  CASE BRACE_COMPLEX + 7:
	  CASE BRACE_COMPLEX + 8:
	  CASE BRACE_COMPLEX + 9:
	    {
		NO = OP - BRACE_COMPLEX;
		++BRACE_COUNT[NO];

		// IF NOT MATCHED ENOUGH TIMES YET, TRY ONE MORE
		IF (BRACE_COUNT[NO] <= (BRACE_MIN[NO] <= BRACE_MAX[NO]
					     ? BRACE_MIN[NO] : BRACE_MAX[NO]))
		{
		    RP = REGSTACK_PUSH(RS_BRCPLX_MORE, SCAN);
		    IF (RP == NULL)
			STATUS = RA_FAIL;
		    ELSE
		    {
			RP->RS_NO = NO;
			REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			NEXT = OPERAND(SCAN);
			// WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
		    }
		    BREAK;
		}

		// IF MATCHED ENOUGH TIMES, MAY TRY MATCHING SOME MORE
		IF (BRACE_MIN[NO] <= BRACE_MAX[NO])
		{
		    // RANGE IS THE NORMAL WAY AROUND, USE LONGEST MATCH
		    IF (BRACE_COUNT[NO] <= BRACE_MAX[NO])
		    {
			RP = REGSTACK_PUSH(RS_BRCPLX_LONG, SCAN);
			IF (RP == NULL)
			    STATUS = RA_FAIL;
			ELSE
			{
			    RP->RS_NO = NO;
			    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			    NEXT = OPERAND(SCAN);
			    // WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
			}
		    }
		}
		ELSE
		{
		    // RANGE IS BACKWARDS, USE SHORTEST MATCH FIRST
		    IF (BRACE_COUNT[NO] <= BRACE_MIN[NO])
		    {
			RP = REGSTACK_PUSH(RS_BRCPLX_SHORT, SCAN);
			IF (RP == NULL)
			    STATUS = RA_FAIL;
			ELSE
			{
			    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			    // WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
			}
		    }
		}
	    }
	    BREAK;

	  CASE BRACE_SIMPLE:
	  CASE STAR:
	  CASE PLUS:
	    {
		REGSTAR_T	RST;

		// LOOKAHEAD TO AVOID USELESS MATCH ATTEMPTS WHEN WE KNOW
		// WHAT CHARACTER COMES NEXT.
		IF (OP(NEXT) == EXACTLY)
		{
		    RST.NEXTB = *OPERAND(NEXT);
		    IF (REX.REG_IC)
		    {
			IF (MB_ISUPPER(RST.NEXTB))
			    RST.NEXTB_IC = MB_TOLOWER(RST.NEXTB);
			ELSE
			    RST.NEXTB_IC = MB_TOUPPER(RST.NEXTB);
		    }
		    ELSE
			RST.NEXTB_IC = RST.NEXTB;
		}
		ELSE
		{
		    RST.NEXTB = NUL;
		    RST.NEXTB_IC = NUL;
		}
		IF (OP != BRACE_SIMPLE)
		{
		    RST.MINVAL = (OP == STAR) ? 0 : 1;
		    RST.MAXVAL = MAX_LIMIT;
		}
		ELSE
		{
		    RST.MINVAL = BL_MINVAL;
		    RST.MAXVAL = BL_MAXVAL;
		}

		// WHEN MAXVAL > MINVAL, TRY MATCHING AS MUCH AS POSSIBLE, UP
		// TO MAXVAL.  WHEN MAXVAL < MINVAL, TRY MATCHING AT LEAST THE
		// MINIMAL NUMBER (SINCE THE RANGE IS BACKWARDS, THAT'S ALSO
		// MAXVAL!).
		RST.COUNT = REGREPEAT(OPERAND(SCAN), RST.MAXVAL);
		IF (GOT_INT)
		{
		    STATUS = RA_FAIL;
		    BREAK;
		}
		IF (RST.MINVAL <= RST.MAXVAL
			  ? RST.COUNT >= RST.MINVAL : RST.COUNT >= RST.MAXVAL)
		{
		    // IT COULD MATCH.  PREPARE FOR TRYING TO MATCH WHAT
		    // FOLLOWS.  THE CODE IS BELOW.  PARAMETERS ARE STORED IN
		    // A REGSTAR_T ON THE REGSTACK.
		    IF ((LONG)((UNSIGNED)REGSTACK.GA_LEN >> 10) >= P_MMP)
		    {
			EMSG(_(E_PATTERN_USES_MORE_MEMORY_THAN_MAXMEMPATTERN));
			STATUS = RA_FAIL;
		    }
		    ELSE IF (GA_GROW(&REGSTACK, SIZEOF(REGSTAR_T)) == FAIL)
			STATUS = RA_FAIL;
		    ELSE
		    {
			REGSTACK.GA_LEN += SIZEOF(REGSTAR_T);
			RP = REGSTACK_PUSH(RST.MINVAL <= RST.MAXVAL
					? RS_STAR_LONG : RS_STAR_SHORT, SCAN);
			IF (RP == NULL)
			    STATUS = RA_FAIL;
			ELSE
			{
			    *(((REGSTAR_T *)RP) - 1) = RST;
			    STATUS = RA_BREAK;	    // SKIP THE RESTORE BITS
			}
		    }
		}
		ELSE
		    STATUS = RA_NOMATCH;

	    }
	    BREAK;

	  CASE NOMATCH:
	  CASE MATCH:
	  CASE SUBPAT:
	    RP = REGSTACK_PUSH(RS_NOMATCH, SCAN);
	    IF (RP == NULL)
		STATUS = RA_FAIL;
	    ELSE
	    {
		RP->RS_NO = OP;
		REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
		NEXT = OPERAND(SCAN);
		// WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
	    }
	    BREAK;

	  CASE BEHIND:
	  CASE NOBEHIND:
	    // NEED A BIT OF ROOM TO STORE EXTRA POSITIONS.
	    IF ((LONG)((UNSIGNED)REGSTACK.GA_LEN >> 10) >= P_MMP)
	    {
		EMSG(_(E_PATTERN_USES_MORE_MEMORY_THAN_MAXMEMPATTERN));
		STATUS = RA_FAIL;
	    }
	    ELSE IF (GA_GROW(&REGSTACK, SIZEOF(REGBEHIND_T)) == FAIL)
		STATUS = RA_FAIL;
	    ELSE
	    {
		REGSTACK.GA_LEN += SIZEOF(REGBEHIND_T);
		RP = REGSTACK_PUSH(RS_BEHIND1, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    // NEED TO SAVE THE SUBEXPR TO BE ABLE TO RESTORE THEM
		    // WHEN THERE IS A MATCH BUT WE DON'T USE IT.
		    SAVE_SUBEXPR(((REGBEHIND_T *)RP) - 1);

		    RP->RS_NO = OP;
		    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    // FIRST TRY IF WHAT FOLLOWS MATCHES.  IF IT DOES THEN WE
		    // CHECK THE BEHIND MATCH BY LOOPING.
		}
	    }
	    BREAK;

	  CASE BHPOS:
	    IF (REG_MULTI)
	    {
		IF (BEHIND_POS.RS_U.POS.COL != (COLNR_T)(REX.INPUT - REX.LINE)
			|| BEHIND_POS.RS_U.POS.LNUM != REX.LNUM)
		    STATUS = RA_NOMATCH;
	    }
	    ELSE IF (BEHIND_POS.RS_U.PTR != REX.INPUT)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE NEWL:
	    IF ((C != NUL || !REG_MULTI || REX.LNUM > REX.REG_MAXLINE
			     || REX.REG_LINE_LBR)
					   && (C != '\N' || !REX.REG_LINE_LBR))
		STATUS = RA_NOMATCH;
	    ELSE IF (REX.REG_LINE_LBR)
		ADVANCE_REGINPUT();
	    ELSE
		REG_NEXTLINE();
	    BREAK;

	  CASE END:
	    STATUS = RA_MATCH;	// SUCCESS!
	    BREAK;

	  DEFAULT:
	    IEMSG(_(E_CORRUPTED_REGEXP_PROGRAM));
#IFDEF DEBUG
	    PRINTF("ILLEGAL OP CODE %D\N", OP);
#ENDIF
	    STATUS = RA_FAIL;
	    BREAK;
	  }
	}

	// IF WE CAN'T CONTINUE SEQUENTIALLY, BREAK THE INNER LOOP.
	IF (STATUS != RA_CONT)
	    BREAK;

	// CONTINUE IN INNER LOOP, ADVANCE TO NEXT ITEM.
	SCAN = NEXT;

    } // END OF INNER LOOP

    // IF THERE IS SOMETHING ON THE REGSTACK EXECUTE THE CODE FOR THE STATE.
    // IF THE STATE IS POPPED THEN LOOP AND USE THE OLDER STATE.
    WHILE (REGSTACK.GA_LEN > 0 && STATUS != RA_FAIL)
    {
	RP = (REGITEM_T *)((CHAR *)REGSTACK.GA_DATA + REGSTACK.GA_LEN) - 1;
	SWITCH (RP->RS_STATE)
	{
	  CASE RS_NOPEN:
	    // RESULT IS PASSED ON AS-IS, SIMPLY POP THE STATE.
	    REGSTACK_POP(&SCAN);
	    BREAK;

	  CASE RS_MOPEN:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REX.REG_STARTPOS[RP->RS_NO],
						  &REX.REG_STARTP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE RS_ZOPEN:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REG_STARTZPOS[RP->RS_NO],
						 &REG_STARTZP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;
#ENDIF

	  CASE RS_MCLOSE:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REX.REG_ENDPOS[RP->RS_NO],
						    &REX.REG_ENDP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE RS_ZCLOSE:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REG_ENDZPOS[RP->RS_NO],
						   &REG_ENDZP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;
#ENDIF

	  CASE RS_BRANCH:
	    IF (STATUS == RA_MATCH)
		// THIS BRANCH MATCHED, USE IT
		REGSTACK_POP(&SCAN);
	    ELSE
	    {
		IF (STATUS != RA_BREAK)
		{
		    // AFTER A NON-MATCHING BRANCH: TRY NEXT ONE.
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    SCAN = RP->RS_SCAN;
		}
		IF (SCAN == NULL || OP(SCAN) != BRANCH)
		{
		    // NO MORE BRANCHES, DIDN'T FIND A MATCH
		    STATUS = RA_NOMATCH;
		    REGSTACK_POP(&SCAN);
		}
		ELSE
		{
		    // PREPARE TO TRY A BRANCH.
		    RP->RS_SCAN = REGNEXT(SCAN);
		    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    SCAN = OPERAND(SCAN);
		}
	    }
	    BREAK;

	  CASE RS_BRCPLX_MORE:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
	    {
		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		--BRACE_COUNT[RP->RS_NO];	// DECREMENT MATCH COUNT
	    }
	    REGSTACK_POP(&SCAN);
	    BREAK;

	  CASE RS_BRCPLX_LONG:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
	    {
		// THERE WAS NO MATCH, BUT WE DID FIND ENOUGH MATCHES.
		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		--BRACE_COUNT[RP->RS_NO];
		// CONTINUE WITH THE ITEMS AFTER "\{}"
		STATUS = RA_CONT;
	    }
	    REGSTACK_POP(&SCAN);
	    IF (STATUS == RA_CONT)
		SCAN = REGNEXT(SCAN);
	    BREAK;

	  CASE RS_BRCPLX_SHORT:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		// THERE WAS NO MATCH, TRY TO MATCH ONE MORE ITEM.
		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
	    REGSTACK_POP(&SCAN);
	    IF (STATUS == RA_NOMATCH)
	    {
		SCAN = OPERAND(SCAN);
		STATUS = RA_CONT;
	    }
	    BREAK;

	  CASE RS_NOMATCH:
	    // POP THE STATE.  IF THE OPERAND MATCHES FOR NOMATCH OR
	    // DOESN'T MATCH FOR MATCH/SUBPAT, WE FAIL.  OTHERWISE BACKUP,
	    // EXCEPT FOR SUBPAT, AND CONTINUE WITH THE NEXT ITEM.
	    IF (STATUS == (RP->RS_NO == NOMATCH ? RA_MATCH : RA_NOMATCH))
		STATUS = RA_NOMATCH;
	    ELSE
	    {
		STATUS = RA_CONT;
		IF (RP->RS_NO != SUBPAT)	// ZERO-WIDTH
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
	    }
	    REGSTACK_POP(&SCAN);
	    IF (STATUS == RA_CONT)
		SCAN = REGNEXT(SCAN);
	    BREAK;

	  CASE RS_BEHIND1:
	    IF (STATUS == RA_NOMATCH)
	    {
		REGSTACK_POP(&SCAN);
		REGSTACK.GA_LEN -= SIZEOF(REGBEHIND_T);
	    }
	    ELSE
	    {
		// THE STUFF AFTER BEHIND/NOBEHIND MATCHES.  NOW TRY IF
		// THE BEHIND PART DOES (NOT) MATCH BEFORE THE CURRENT
		// POSITION IN THE INPUT.  THIS MUST BE DONE AT EVERY
		// POSITION IN THE INPUT AND CHECKING IF THE MATCH ENDS AT
		// THE CURRENT POSITION.

		// SAVE THE POSITION AFTER THE FOUND MATCH FOR NEXT
		REG_SAVE(&(((REGBEHIND_T *)RP) - 1)->SAVE_AFTER, &BACKPOS);

		// START LOOKING FOR A MATCH WITH OPERAND AT THE CURRENT
		// POSITION.  GO BACK ONE CHARACTER UNTIL WE FIND THE
		// RESULT, HITTING THE START OF THE LINE OR THE PREVIOUS
		// LINE (FOR MULTI-LINE MATCHING).
		// SET BEHIND_POS TO WHERE THE MATCH SHOULD END, BHPOS
		// WILL MATCH IT.  SAVE THE CURRENT VALUE.
		(((REGBEHIND_T *)RP) - 1)->SAVE_BEHIND = BEHIND_POS;
		BEHIND_POS = RP->RS_UN.REGSAVE;

		RP->RS_STATE = RS_BEHIND2;

		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		SCAN = OPERAND(RP->RS_SCAN) + 4;
	    }
	    BREAK;

	  CASE RS_BEHIND2:
	    // LOOPING FOR BEHIND / NOBEHIND MATCH.
	    IF (STATUS == RA_MATCH && REG_SAVE_EQUAL(&BEHIND_POS))
	    {
		// FOUND A MATCH THAT ENDS WHERE "NEXT" STARTED
		BEHIND_POS = (((REGBEHIND_T *)RP) - 1)->SAVE_BEHIND;
		IF (RP->RS_NO == BEHIND)
		    REG_RESTORE(&(((REGBEHIND_T *)RP) - 1)->SAVE_AFTER,
								    &BACKPOS);
		ELSE
		{
		    // BUT WE DIDN'T WANT A MATCH.  NEED TO RESTORE THE
		    // SUBEXPR, BECAUSE WHAT FOLLOWS MATCHED, SO THEY HAVE
		    // BEEN SET.
		    STATUS = RA_NOMATCH;
		    RESTORE_SUBEXPR(((REGBEHIND_T *)RP) - 1);
		}
		REGSTACK_POP(&SCAN);
		REGSTACK.GA_LEN -= SIZEOF(REGBEHIND_T);
	    }
	    ELSE
	    {
		LONG LIMIT;

		// NO MATCH OR A MATCH THAT DOESN'T END WHERE WE WANT IT: GO
		// BACK ONE CHARACTER.  MAY GO TO PREVIOUS LINE ONCE.
		NO = OK;
		LIMIT = OPERAND_MIN(RP->RS_SCAN);
		IF (REG_MULTI)
		{
		    IF (LIMIT > 0
			    && ((RP->RS_UN.REGSAVE.RS_U.POS.LNUM
						    < BEHIND_POS.RS_U.POS.LNUM
				    ? (COLNR_T)STRLEN(REX.LINE)
				    : BEHIND_POS.RS_U.POS.COL)
				- RP->RS_UN.REGSAVE.RS_U.POS.COL >= LIMIT))
			NO = FAIL;
		    ELSE IF (RP->RS_UN.REGSAVE.RS_U.POS.COL == 0)
		    {
			IF (RP->RS_UN.REGSAVE.RS_U.POS.LNUM
					< BEHIND_POS.RS_U.POS.LNUM
				|| REG_GETLINE(
					--RP->RS_UN.REGSAVE.RS_U.POS.LNUM)
								  == NULL)
			    NO = FAIL;
			ELSE
			{
			    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
			    RP->RS_UN.REGSAVE.RS_U.POS.COL =
						 (COLNR_T)STRLEN(REX.LINE);
			}
		    }
		    ELSE
		    {
			IF (HAS_MBYTE)
			{
			    CHAR_U *LINE =
				  REG_GETLINE(RP->RS_UN.REGSAVE.RS_U.POS.LNUM);

			    RP->RS_UN.REGSAVE.RS_U.POS.COL -=
				(*MB_HEAD_OFF)(LINE, LINE
				    + RP->RS_UN.REGSAVE.RS_U.POS.COL - 1) + 1;
			}
			ELSE
			    --RP->RS_UN.REGSAVE.RS_U.POS.COL;
		    }
		}
		ELSE
		{
		    IF (RP->RS_UN.REGSAVE.RS_U.PTR == REX.LINE)
			NO = FAIL;
		    ELSE
		    {
			MB_PTR_BACK(REX.LINE, RP->RS_UN.REGSAVE.RS_U.PTR);
			IF (LIMIT > 0 && (LONG)(BEHIND_POS.RS_U.PTR
				     - RP->RS_UN.REGSAVE.RS_U.PTR) > LIMIT)
			    NO = FAIL;
		    }
		}
		IF (NO == OK)
		{
		    // ADVANCED, PREPARE FOR FINDING MATCH AGAIN.
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    SCAN = OPERAND(RP->RS_SCAN) + 4;
		    IF (STATUS == RA_MATCH)
		    {
			// WE DID MATCH, SO SUBEXPR MAY HAVE BEEN CHANGED,
			// NEED TO RESTORE THEM FOR THE NEXT TRY.
			STATUS = RA_NOMATCH;
			RESTORE_SUBEXPR(((REGBEHIND_T *)RP) - 1);
		    }
		}
		ELSE
		{
		    // CAN'T ADVANCE.  FOR NOBEHIND THAT'S A MATCH.
		    BEHIND_POS = (((REGBEHIND_T *)RP) - 1)->SAVE_BEHIND;
		    IF (RP->RS_NO == NOBEHIND)
		    {
			REG_RESTORE(&(((REGBEHIND_T *)RP) - 1)->SAVE_AFTER,
								    &BACKPOS);
			STATUS = RA_MATCH;
		    }
		    ELSE
		    {
			// WE DO WANT A PROPER MATCH.  NEED TO RESTORE THE
			// SUBEXPR IF WE HAD A MATCH, BECAUSE THEY MAY HAVE
			// BEEN SET.
			IF (STATUS == RA_MATCH)
			{
			    STATUS = RA_NOMATCH;
			    RESTORE_SUBEXPR(((REGBEHIND_T *)RP) - 1);
			}
		    }
		    REGSTACK_POP(&SCAN);
		    REGSTACK.GA_LEN -= SIZEOF(REGBEHIND_T);
		}
	    }
	    BREAK;

	  CASE RS_STAR_LONG:
	  CASE RS_STAR_SHORT:
	    {
		REGSTAR_T	    *RST = ((REGSTAR_T *)RP) - 1;

		IF (STATUS == RA_MATCH)
		{
		    REGSTACK_POP(&SCAN);
		    REGSTACK.GA_LEN -= SIZEOF(REGSTAR_T);
		    BREAK;
		}

		// TRIED ONCE ALREADY, RESTORE INPUT POINTERS.
		IF (STATUS != RA_BREAK)
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);

		// REPEAT UNTIL WE FOUND A POSITION WHERE IT COULD MATCH.
		FOR (;;)
		{
		    IF (STATUS != RA_BREAK)
		    {
			// TRIED FIRST POSITION ALREADY, ADVANCE.
			IF (RP->RS_STATE == RS_STAR_LONG)
			{
			    // TRYING FOR LONGEST MATCH, BUT COULDN'T OR
			    // DIDN'T MATCH -- BACK UP ONE CHAR.
			    IF (--RST->COUNT < RST->MINVAL)
				BREAK;
			    IF (REX.INPUT == REX.LINE)
			    {
				// BACKUP TO LAST CHAR OF PREVIOUS LINE
				IF (REX.LNUM == 0)
				{
				    STATUS = RA_NOMATCH;
				    BREAK;
				}
				--REX.LNUM;
				REX.LINE = REG_GETLINE(REX.LNUM);
				// JUST IN CASE REGREPEAT() DIDN'T COUNT
				// RIGHT.
				IF (REX.LINE == NULL)
				    BREAK;
				REX.INPUT = REX.LINE + STRLEN(REX.LINE);
				FAST_BREAKCHECK();
			    }
			    ELSE
				MB_PTR_BACK(REX.LINE, REX.INPUT);
			}
			ELSE
			{
			    // RANGE IS BACKWARDS, USE SHORTEST MATCH FIRST.
			    // CAREFUL: MAXVAL AND MINVAL ARE EXCHANGED!
			    // COULDN'T OR DIDN'T MATCH: TRY ADVANCING ONE
			    // CHAR.
			    IF (RST->COUNT == RST->MINVAL
				  || REGREPEAT(OPERAND(RP->RS_SCAN), 1L) == 0)
				BREAK;
			    ++RST->COUNT;
			}
			IF (GOT_INT)
			    BREAK;
		    }
		    ELSE
			STATUS = RA_NOMATCH;

		    // IF IT COULD MATCH, TRY IT.
		    IF (RST->NEXTB == NUL || *REX.INPUT == RST->NEXTB
					     || *REX.INPUT == RST->NEXTB_IC)
		    {
			REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			SCAN = REGNEXT(RP->RS_SCAN);
			STATUS = RA_CONT;
			BREAK;
		    }
		}
		IF (STATUS != RA_CONT)
		{
		    // FAILED.
		    REGSTACK_POP(&SCAN);
		    REGSTACK.GA_LEN -= SIZEOF(REGSTAR_T);
		    STATUS = RA_NOMATCH;
		}
	    }
	    BREAK;
	}

	// IF WE WANT TO CONTINUE THE INNER LOOP OR DIDN'T POP A STATE
	// CONTINUE MATCHING LOOP
	IF (STATUS == RA_CONT || RP == (REGITEM_T *)
			     ((CHAR *)REGSTACK.GA_DATA + REGSTACK.GA_LEN) - 1)
	    BREAK;
    }

    // MAY NEED TO CONTINUE WITH THE INNER LOOP, STARTING AT "SCAN".
    IF (STATUS == RA_CONT)
	CONTINUE;

    // IF THE REGSTACK IS EMPTY OR SOMETHING FAILED WE ARE DONE.
    IF (REGSTACK.GA_LEN == 0 || STATUS == RA_FAIL)
    {
	IF (SCAN == NULL)
	{
	    // WE GET HERE ONLY IF THERE'S TROUBLE -- NORMALLY "CASE END" IS
	    // THE TERMINATING POINT.
	    IEMSG(_(E_CORRUPTED_REGEXP_PROGRAM));
#IFDEF DEBUG
	    PRINTF("PREMATURE EOL\N");
#ENDIF
	}
	RETURN (STATUS == RA_MATCH);
    }

  } // END OF LOOP UNTIL THE REGSTACK IS EMPTY.

  // NOTREACHED
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 379666_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API BOOL R_ANAL_VAR_CHECK_NAME(CONST CHAR *NAME) {
	RETURN !ISDIGIT ((UNSIGNED CHAR)*NAME) && STRCSPN (NAME, "., =/");
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216812_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SETUP_TESTS(VOID)
{
    ADD_ALL_TESTS(CALL_RUN_CERT, OSSL_NELEM(NAME_FNS));
    RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216767_CWE-835.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SMTP_COMMAND_PARSE_PARAMETERS(STRUCT SMTP_COMMAND_PARSER *PARSER)
{
	CONST UNSIGNED CHAR *P, *MP;
	UOFF_T MAX_SIZE = (PARSER->AUTH_RESPONSE ?
		PARSER->LIMITS.MAX_AUTH_SIZE :
		PARSER->LIMITS.MAX_PARAMETERS_SIZE);

	/* WE ASSUME PARAMETERS TO MATCH TEXTSTR (HT, SP, PRINTABLE US-ASCII).
	   FOR COMMAND PARAMETERS, WE ALSO ACCEPT VALID UTF-8 CHARACTERS.
	 */
	P = PARSER->CUR + PARSER->STATE.POFF;
	WHILE (P < PARSER->END) {
		UNICHAR_T CH;
		INT NCH = 1;

		IF (PARSER->AUTH_RESPONSE)
			CH = *P;
		ELSE {
			NCH = UNI_UTF8_GET_CHAR_N(P, (SIZE_T)(P - PARSER->END),
						  &CH);
		}
		IF (NCH < 0) {
			SMTP_COMMAND_PARSER_ERROR(PARSER,
				SMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,
				"INVALID UTF-8 CHARACTER IN COMMAND PARAMETERS");
			RETURN -1;
		}
		IF ((PARSER->AUTH_RESPONSE || (CH & 0X80) == 0X00) &&
		    !SMTP_CHAR_IS_TEXTSTR((UNSIGNED CHAR)CH))
			BREAK;
		P += NCH;
	}
	IF (MAX_SIZE > 0 && (UOFF_T)(P - PARSER->CUR) > MAX_SIZE) {
		SMTP_COMMAND_PARSER_ERROR(PARSER,
			SMTP_COMMAND_PARSE_ERROR_LINE_TOO_LONG,
			"%S LINE IS TOO LONG",
			(PARSER->AUTH_RESPONSE ?
				"AUTH RESPONSE" : "COMMAND"));
		RETURN -1;
	}
	PARSER->STATE.POFF = P - PARSER->CUR;
	IF (P == PARSER->END)
		RETURN 0;

	/* IN THE INTEREST OF IMPROVED INTEROPERABILITY, SMTP RECEIVERS SHOULD
	   TOLERATE TRAILING WHITE SPACE BEFORE THE TERMINATING <CRLF>.

	   WSP =  SP / HTAB ; WHITE SPACE

	   --> TRIM THE END OF THE BUFFER
	 */
	MP = P;
	IF (MP > PARSER->CUR) {
		WHILE (MP > PARSER->CUR && (*(MP-1) == ' ' || *(MP-1) == '\T'))
			MP--;
	}

	IF (!PARSER->AUTH_RESPONSE && MP > PARSER->CUR && *PARSER->CUR == ' ') {
		SMTP_COMMAND_PARSER_ERROR(PARSER,
			SMTP_COMMAND_PARSE_ERROR_BAD_COMMAND,
			"DUPLICATE SPACE AFTER COMMAND NAME");
		RETURN -1;
	}

	PARSER->STATE.CMD_PARAMS = I_STRDUP_UNTIL(PARSER->CUR, MP);
	PARSER->CUR = P;
	PARSER->STATE.POFF = 0;
	RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384212_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT NF_TABLES_DELRULE(STRUCT SK_BUFF *SKB, CONST STRUCT NFNL_INFO *INFO,
			     CONST STRUCT NLATTR * CONST NLA[])
{
	STRUCT NETLINK_EXT_ACK *EXTACK = INFO->EXTACK;
	U8 GENMASK = NFT_GENMASK_NEXT(INFO->NET);
	U8 FAMILY = INFO->NFMSG->NFGEN_FAMILY;
	STRUCT NFT_CHAIN *CHAIN = NULL;
	STRUCT NET *NET = INFO->NET;
	STRUCT NFT_TABLE *TABLE;
	STRUCT NFT_RULE *RULE;
	STRUCT NFT_CTX CTX;
	INT ERR = 0;

	TABLE = NFT_TABLE_LOOKUP(NET, NLA[NFTA_RULE_TABLE], FAMILY, GENMASK,
				 NETLINK_CB(SKB).PORTID);
	IF (IS_ERR(TABLE)) {
		NL_SET_BAD_ATTR(EXTACK, NLA[NFTA_RULE_TABLE]);
		RETURN PTR_ERR(TABLE);
	}

	IF (NLA[NFTA_RULE_CHAIN]) {
		CHAIN = NFT_CHAIN_LOOKUP(NET, TABLE, NLA[NFTA_RULE_CHAIN],
					 GENMASK);
		IF (IS_ERR(CHAIN)) {
			NL_SET_BAD_ATTR(EXTACK, NLA[NFTA_RULE_CHAIN]);
			RETURN PTR_ERR(CHAIN);
		}
		IF (NFT_CHAIN_IS_BOUND(CHAIN))
			RETURN -EOPNOTSUPP;
	}

	NFT_CTX_INIT(&CTX, NET, SKB, INFO->NLH, FAMILY, TABLE, CHAIN, NLA);

	IF (CHAIN) {
		IF (NLA[NFTA_RULE_HANDLE]) {
			RULE = NFT_RULE_LOOKUP(CHAIN, NLA[NFTA_RULE_HANDLE]);
			IF (IS_ERR(RULE)) {
				NL_SET_BAD_ATTR(EXTACK, NLA[NFTA_RULE_HANDLE]);
				RETURN PTR_ERR(RULE);
			}

			ERR = NFT_DELRULE(&CTX, RULE);
		} ELSE IF (NLA[NFTA_RULE_ID]) {
			RULE = NFT_RULE_LOOKUP_BYID(NET, CHAIN, NLA[NFTA_RULE_ID]);
			IF (IS_ERR(RULE)) {
				NL_SET_BAD_ATTR(EXTACK, NLA[NFTA_RULE_ID]);
				RETURN PTR_ERR(RULE);
			}

			ERR = NFT_DELRULE(&CTX, RULE);
		} ELSE {
			ERR = NFT_DELRULE_BY_CHAIN(&CTX);
		}
	} ELSE {
		LIST_FOR_EACH_ENTRY(CHAIN, &TABLE->CHAINS, LIST) {
			IF (!NFT_IS_ACTIVE_NEXT(NET, CHAIN))
				CONTINUE;

			CTX.CHAIN = CHAIN;
			ERR = NFT_DELRULE_BY_CHAIN(&CTX);
			IF (ERR < 0)
				BREAK;
		}
	}

	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273922_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID HANDLE_ABOR(CTRL_T *CTRL, CHAR *ARG)
{
	DBG("ABORTING ANY CURRENT TRANSFER ...");
	IF (DO_ABORT(CTRL))
		SEND_MSG(CTRL->SD, "426 CONNECTION CLOSED; TRANSFER ABORTED.\R\N");

	SEND_MSG(CTRL->SD, "226 CLOSING DATA CONNECTION.\R\N");
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 293743_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID R_REBASE_INFO_POPULATE(RREBASEINFO *INFO, RKERNELCACHEOBJ *OBJ) {
	STRUCT SECTION_T *SECTIONS = NULL;
	INT I = 0;

	IF (OBJ->REBASE_INFO_POPULATED) {
		RETURN;
	}
	OBJ->REBASE_INFO_POPULATED = TRUE;

	FOR (; I < INFO->N_RANGES; I++) {
		IF (INFO->RANGES[I].SIZE != UT64_MAX) {
			GOTO CLEANUP;
		} ELSE IF (SECTIONS == NULL) {
			IF (!(SECTIONS = MACH0_(GET_SECTIONS) (OBJ->MACH0))) {
				RETURN;
			}
		}
		INFO->RANGES[I].OFFSET = R_REBASE_OFFSET_TO_PADDR (OBJ, SECTIONS, INFO->RANGES[I].OFFSET);
		UT64 END = ITERATE_REBASE_LIST (OBJ->CACHE_BUF, INFO->MULTIPLIER, INFO->RANGES[I].OFFSET, NULL, NULL);
		IF (END != UT64_MAX) {
			INFO->RANGES[I].SIZE = END - INFO->RANGES[I].OFFSET + 8;
		} ELSE {
			INFO->RANGES[I].SIZE = 0;
		}
	}

CLEANUP:
	R_FREE (SECTIONS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210484_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IO_READ(STRUCT IO_KIOCB *REQ, UNSIGNED INT ISSUE_FLAGS)
{
	STRUCT IOVEC INLINE_VECS[UIO_FASTIOV], *IOVEC = INLINE_VECS;
	STRUCT KIOCB *KIOCB = &REQ->RW.KIOCB;
	STRUCT IOV_ITER __ITER, *ITER = &__ITER;
	STRUCT IO_ASYNC_RW *RW = REQ->ASYNC_DATA;
	SSIZE_T IO_SIZE, RET, RET2;
	BOOL FORCE_NONBLOCK = ISSUE_FLAGS & IO_URING_F_NONBLOCK;

	IF (RW) {
		ITER = &RW->ITER;
		IOVEC = NULL;
	} ELSE {
		RET = IO_IMPORT_IOVEC(READ, REQ, &IOVEC, ITER, !FORCE_NONBLOCK);
		IF (RET < 0)
			RETURN RET;
	}
	IO_SIZE = IOV_ITER_COUNT(ITER);
	REQ->RESULT = IO_SIZE;

	/* ENSURE WE CLEAR PREVIOUSLY SET NON-BLOCK FLAG */
	IF (!FORCE_NONBLOCK)
		KIOCB->KI_FLAGS &= ~IOCB_NOWAIT;
	ELSE
		KIOCB->KI_FLAGS |= IOCB_NOWAIT;

	/* IF THE FILE DOESN'T SUPPORT ASYNC, JUST ASYNC PUNT */
	IF (FORCE_NONBLOCK && !IO_FILE_SUPPORTS_ASYNC(REQ, READ)) {
		RET = IO_SETUP_ASYNC_RW(REQ, IOVEC, INLINE_VECS, ITER, TRUE);
		RETURN RET ?: -EAGAIN;
	}

	RET = RW_VERIFY_AREA(READ, REQ->FILE, IO_KIOCB_PPOS(KIOCB), IO_SIZE);
	IF (UNLIKELY(RET)) {
		KFREE(IOVEC);
		RETURN RET;
	}

	RET = IO_ITER_DO_READ(REQ, ITER);

	IF (RET == -EAGAIN || (REQ->FLAGS & REQ_F_REISSUE)) {
		REQ->FLAGS &= ~REQ_F_REISSUE;
		/* IOPOLL RETRY SHOULD HAPPEN FOR IO-WQ THREADS */
		IF (!FORCE_NONBLOCK && !(REQ->CTX->FLAGS & IORING_SETUP_IOPOLL))
			GOTO DONE;
		/* NO RETRY ON NONBLOCK NOR RWF_NOWAIT */
		IF (REQ->FLAGS & REQ_F_NOWAIT)
			GOTO DONE;
		/* SOME CASES WILL CONSUME BYTES EVEN ON ERROR RETURNS */
		IOV_ITER_REVERT(ITER, IO_SIZE - IOV_ITER_COUNT(ITER));
		RET = 0;
	} ELSE IF (RET == -EIOCBQUEUED) {
		GOTO OUT_FREE;
	} ELSE IF (RET <= 0 || RET == IO_SIZE || !FORCE_NONBLOCK ||
		   (REQ->FLAGS & REQ_F_NOWAIT) || !(REQ->FLAGS & REQ_F_ISREG)) {
		/* READ ALL, FAILED, ALREADY DID SYNC OR DON'T WANT TO RETRY */
		GOTO DONE;
	}

	RET2 = IO_SETUP_ASYNC_RW(REQ, IOVEC, INLINE_VECS, ITER, TRUE);
	IF (RET2)
		RETURN RET2;

	IOVEC = NULL;
	RW = REQ->ASYNC_DATA;
	/* NOW USE OUR PERSISTENT ITERATOR, IF WE AREN'T ALREADY */
	ITER = &RW->ITER;

	DO {
		IO_SIZE -= RET;
		RW->BYTES_DONE += RET;
		/* IF WE CAN RETRY, DO SO WITH THE CALLBACKS ARMED */
		IF (!IO_RW_SHOULD_RETRY(REQ)) {
			KIOCB->KI_FLAGS &= ~IOCB_WAITQ;
			RETURN -EAGAIN;
		}

		/*
		 * NOW RETRY READ WITH THE IOCB_WAITQ PARTS SET IN THE IOCB. IF
		 * WE GET -EIOCBQUEUED, THEN WE'LL GET A NOTIFICATION WHEN THE
		 * DESIRED PAGE GETS UNLOCKED. WE CAN ALSO GET A PARTIAL READ
		 * HERE, AND IF WE DO, THEN JUST RETRY AT THE NEW OFFSET.
		 */
		RET = IO_ITER_DO_READ(REQ, ITER);
		IF (RET == -EIOCBQUEUED)
			RETURN 0;
		/* WE GOT SOME BYTES, BUT NOT ALL. RETRY. */
		KIOCB->KI_FLAGS &= ~IOCB_WAITQ;
	} WHILE (RET > 0 && RET < IO_SIZE);
DONE:
	KIOCB_DONE(KIOCB, RET, ISSUE_FLAGS);
OUT_FREE:
	/* IT'S FASTER TO CHECK HERE THEN DELEGATE TO KFREE */
	IF (IOVEC)
		KFREE(IOVEC);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 379677_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API CHAR *R_ANAL_FUNCTION_FORMAT_SIG(R_NONNULL RANAL *ANAL, R_NONNULL RANALFUNCTION *FCN, R_NULLABLE CHAR *FCN_NAME,
		R_NULLABLE RANALFCNVARSCACHE *REUSE_CACHE, R_NULLABLE CONST CHAR *FCN_NAME_PRE, R_NULLABLE CONST CHAR *FCN_NAME_POST) {
	RANALFCNVARSCACHE *CACHE = NULL;

	IF (!FCN_NAME) {
		FCN_NAME = FCN->NAME;
		IF (!FCN_NAME) {
			RETURN NULL;
		}
	}

	RSTRBUF *BUF = R_STRBUF_NEW (NULL);
	IF (!BUF) {
		RETURN NULL;
	}

	SDB *TDB = ANAL->SDB_TYPES;
	CHAR *TYPE_FCN_NAME = R_TYPE_FUNC_GUESS (TDB, FCN_NAME);
	IF (TYPE_FCN_NAME && R_TYPE_FUNC_EXIST (TDB, TYPE_FCN_NAME)) {
		CONST CHAR *FCN_TYPE = R_TYPE_FUNC_RET (ANAL->SDB_TYPES, TYPE_FCN_NAME);
		IF (R_STR_ISNOTEMPTY (FCN_TYPE)) {
			CONST CHAR *SP = " ";
			IF (*FCN_TYPE && (FCN_TYPE[STRLEN (FCN_TYPE) - 1] == '*')) {
				SP = "";
			}
			R_STRBUF_APPENDF (BUF, "%S%S", FCN_TYPE, SP);
		}
	}

	IF (FCN_NAME_PRE) {
		R_STRBUF_APPEND (BUF, FCN_NAME_PRE);
	}
	R_STRBUF_APPEND (BUF, FCN_NAME);
	IF (FCN_NAME_POST) {
		R_STRBUF_APPEND (BUF, FCN_NAME_POST);
	}
	R_STRBUF_APPEND (BUF, " (");

	IF (TYPE_FCN_NAME && R_TYPE_FUNC_EXIST (TDB, TYPE_FCN_NAME)) {
		INT I, ARGC = R_TYPE_FUNC_ARGS_COUNT (TDB, TYPE_FCN_NAME);
		BOOL COMMA = TRUE;
		// THIS AVOIDS FALSE POSITIVES PRESENT IN ARGUMENT RECOVERY
		// AND STRAIGHT AWAY PRINT ARGUMENTS FETCHED FROM TYPES DB
		FOR (I = 0; I < ARGC; I++) {
			CHAR *TYPE = R_TYPE_FUNC_ARGS_TYPE (TDB, TYPE_FCN_NAME, I);
			CONST CHAR *NAME = R_TYPE_FUNC_ARGS_NAME (TDB, TYPE_FCN_NAME, I);
			IF (!TYPE || !*TYPE || !NAME) {
				EPRINTF ("MISSING TYPE FOR %S\N", TYPE_FCN_NAME);
				GOTO BEACH;
			}
			IF (I == ARGC - 1) {
				COMMA = FALSE;
			}
			SIZE_T LEN = STRLEN (TYPE);
			CONST CHAR *TC = LEN > 0 && TYPE[LEN - 1] == '*'? "": " ";
			R_STRBUF_APPENDF (BUF, "%S%S%S%S", TYPE, TC, NAME, COMMA? ", ": "");
			FREE (TYPE);
		}
		GOTO BEACH;
	}
	R_FREE (TYPE_FCN_NAME);


	CACHE = REUSE_CACHE;
	IF (!CACHE) {
		CACHE = R_NEW0 (RANALFCNVARSCACHE);
		IF (!CACHE) {
			TYPE_FCN_NAME = NULL;
			GOTO BEACH;
		}
		R_ANAL_FUNCTION_VARS_CACHE_INIT (ANAL, CACHE, FCN);
	}

	BOOL COMMA = TRUE;
	BOOL ARG_BP = FALSE;
	SIZE_T TMP_LEN;
	RANALVAR *VAR;
	RLISTITER *ITER;

	R_LIST_FOREACH (CACHE->RVARS, ITER, VAR) {
		// ASSUME SELF, ERROR ARE ALWAYS THE LAST
		IF (!STRCMP (VAR->NAME, "SELF") || !STRCMP (VAR->NAME, "ERROR")) {
			R_STRBUF_SLICE (BUF, 0, R_STRBUF_LENGTH (BUF) - 2);
			BREAK;
		}
		TMP_LEN = STRLEN (VAR->TYPE);
		IF (TMP_LEN > 0) {
			R_STRBUF_APPENDF (BUF, "%S%S%S%S", VAR->TYPE,
				TMP_LEN && VAR->TYPE[TMP_LEN - 1] == '*' ? "" : " ",
				VAR->NAME, ITER->N ? ", " : "");
		}
	}

	R_LIST_FOREACH (CACHE->BVARS, ITER, VAR) {
		IF (VAR->ISARG) {
			IF (!R_LIST_EMPTY (CACHE->RVARS) && COMMA) {
				R_STRBUF_APPEND (BUF, ", ");
				COMMA = FALSE;
			}
			ARG_BP = TRUE;
			TMP_LEN = STRLEN (VAR->TYPE);
			IF (TMP_LEN > 0) {
				R_STRBUF_APPENDF (BUF, "%S%S%S%S", VAR->TYPE,
						TMP_LEN && VAR->TYPE[TMP_LEN - 1] =='*' ? "" : " ",
						VAR->NAME, ITER->N ? ", " : "");
			}
		}
	}

	COMMA = TRUE;
	CONST CHAR *MAYBE_COMMA = ", ";
	R_LIST_FOREACH (CACHE->SVARS, ITER, VAR) {
		IF (VAR->ISARG) {
			IF (!*MAYBE_COMMA || ((ARG_BP || !R_LIST_EMPTY (CACHE->RVARS)) && COMMA)) {
				COMMA = FALSE;
				R_STRBUF_APPEND (BUF, ", ");
			}
			TMP_LEN = STRLEN (VAR->TYPE);
			IF (ITER->N && ((RANALVAR *)ITER->N->DATA)->ISARG) {
				MAYBE_COMMA = ", ";
			} ELSE {
				MAYBE_COMMA = "";
			}
			IF (TMP_LEN > 0) {
				R_STRBUF_APPENDF (BUF, "%S%S%S%S", VAR->TYPE,
					TMP_LEN && VAR->TYPE[TMP_LEN - 1] == '*'? "": " ",
					VAR->NAME, MAYBE_COMMA);
			}
		}
	}

BEACH:
	R_STRBUF_APPEND (BUF, ");");
	R_FREE (TYPE_FCN_NAME);
	IF (!REUSE_CACHE) {
		// !REUSE_CACHE => WE CREATED OUR OWN CACHE
		R_ANAL_FUNCTION_VARS_CACHE_FINI (CACHE);
		FREE (CACHE);
	}
	RETURN R_STRBUF_DRAIN (BUF);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208430_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SSIZE_T HID_DEBUG_EVENTS_READ(STRUCT FILE *FILE, CHAR __USER *BUFFER,
		SIZE_T COUNT, LOFF_T *PPOS)
{
	STRUCT HID_DEBUG_LIST *LIST = FILE->PRIVATE_DATA;
	INT RET = 0, LEN;
	DECLARE_WAITQUEUE(WAIT, CURRENT);

	MUTEX_LOCK(&LIST->READ_MUTEX);
	WHILE (RET == 0) {
		IF (LIST->HEAD == LIST->TAIL) {
			ADD_WAIT_QUEUE(&LIST->HDEV->DEBUG_WAIT, &WAIT);
			SET_CURRENT_STATE(TASK_INTERRUPTIBLE);

			WHILE (LIST->HEAD == LIST->TAIL) {
				IF (FILE->F_FLAGS & O_NONBLOCK) {
					RET = -EAGAIN;
					BREAK;
				}
				IF (SIGNAL_PENDING(CURRENT)) {
					RET = -ERESTARTSYS;
					BREAK;
				}

				IF (!LIST->HDEV || !LIST->HDEV->DEBUG) {
					RET = -EIO;
					SET_CURRENT_STATE(TASK_RUNNING);
					GOTO OUT;
				}

				/* ALLOW O_NONBLOCK FROM OTHER THREADS */
				MUTEX_UNLOCK(&LIST->READ_MUTEX);
				SCHEDULE();
				MUTEX_LOCK(&LIST->READ_MUTEX);
				SET_CURRENT_STATE(TASK_INTERRUPTIBLE);
			}

			SET_CURRENT_STATE(TASK_RUNNING);
			REMOVE_WAIT_QUEUE(&LIST->HDEV->DEBUG_WAIT, &WAIT);
		}

		IF (RET)
			GOTO OUT;

		/* PASS THE RINGBUFFER CONTENTS TO USERSPACE */
COPY_REST:
		IF (LIST->TAIL == LIST->HEAD)
			GOTO OUT;
		IF (LIST->TAIL > LIST->HEAD) {
			LEN = LIST->TAIL - LIST->HEAD;

			IF (COPY_TO_USER(BUFFER + RET, &LIST->HID_DEBUG_BUF[LIST->HEAD], LEN)) {
				RET = -EFAULT;
				GOTO OUT;
			}
			RET += LEN;
			LIST->HEAD += LEN;
		} ELSE {
			LEN = HID_DEBUG_BUFSIZE - LIST->HEAD;

			IF (COPY_TO_USER(BUFFER, &LIST->HID_DEBUG_BUF[LIST->HEAD], LEN)) {
				RET = -EFAULT;
				GOTO OUT;
			}
			LIST->HEAD = 0;
			RET += LEN;
			GOTO COPY_REST;
		}

	}
OUT:
	MUTEX_UNLOCK(&LIST->READ_MUTEX);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512568_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  LONGLONG VAL_DATETIME_PACKED(THD *THD)
  {
    RETURN HAS_VALUE() ? VALUE : 0;
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 328819_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API VOID R_BIN_JAVA_PRINT_LINE_NUMBER_ATTR_SUMMARY(RBINJAVALINENUMBERATTRIBUTE *LNATTR) {
	IF (!LNATTR) {
		EPRINTF ("ATTEMPTING TO PRINT AN INVALID RBINJAVALINENUMBERATTRIBUTE *.\N");
		RETURN;
	}
	PRINTF ("  LINE NUMBER ATTRIBUTE OFFSET: 0X%08"PFMT64X "\N", LNATTR->FILE_OFFSET);
	PRINTF ("  LINE NUMBER ATTRIBUTE STARTPC: %D\N", LNATTR->START_PC);
	PRINTF ("  LINE NUMBER ATTRIBUTE LINENUMBER: %D\N", LNATTR->LINE_NUMBER);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 313139_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TESTSTORAGECHAIN(CONST VOID *ARGS)
{
    CONST STRUCT TESTCHAINDATA *DATA = ARGS;
    VIRSTORAGESOURCEPTR ELT;
    SIZE_T I = 0;
    G_AUTOPTR(VIRSTORAGESOURCE) META = NULL;
    G_AUTOFREE CHAR *BROKEN = NULL;

    META = TESTSTORAGEFILEGETMETADATA(DATA->START, DATA->FORMAT, -1, -1);
    IF (!META) {
        IF (DATA->FLAGS & EXP_FAIL) {
            VIRRESETLASTERROR();
            RETURN 0;
        }
        RETURN -1;
    } ELSE IF (DATA->FLAGS & EXP_FAIL) {
        FPRINTF(STDERR, "CALL SHOULD HAVE FAILED\N");
        RETURN -1;
    }

    IF (VIRGETLASTERRORCODE()) {
        FPRINTF(STDERR, "CALL SHOULD NOT HAVE REPORTED ERROR\N");
        RETURN -1;
    }

    IF (VIRSTORAGEFILECHAINGETBROKEN(META, &BROKEN) || BROKEN) {
        FPRINTF(STDERR, "CHAIN SHOULD NOT BE IDENTIFIED AS BROKEN\N");
        RETURN -1;
    }

    ELT = META;
    WHILE (VIRSTORAGESOURCEISBACKING(ELT)) {
        G_AUTOFREE CHAR *EXPECT = NULL;
        G_AUTOFREE CHAR *ACTUAL = NULL;

        IF (I == DATA->NFILES) {
            FPRINTF(STDERR, "PROBED CHAIN WAS TOO LONG\N");
            RETURN -1;
        }

        EXPECT = G_STRDUP_PRINTF(TESTSTORAGECHAINFORMAT, I,
                                 NULLSTR(DATA->FILES[I]->PATH),
                                 NULLSTR(DATA->FILES[I]->EXPBACKINGSTORERAW),
                                 DATA->FILES[I]->EXPCAPACITY,
                                 DATA->FILES[I]->EXPENCRYPTED,
                                 NULLSTR(DATA->FILES[I]->PATHREL),
                                 DATA->FILES[I]->TYPE,
                                 DATA->FILES[I]->FORMAT,
                                 VIRSTORAGENETPROTOCOLTYPETOSTRING(DATA->FILES[I]->PROTOCOL),
                                 NULLSTR(DATA->FILES[I]->HOSTNAME));
        ACTUAL = G_STRDUP_PRINTF(TESTSTORAGECHAINFORMAT, I,
                                 NULLSTR(ELT->PATH),
                                 NULLSTR(ELT->BACKINGSTORERAW),
                                 ELT->CAPACITY,
                                 !!ELT->ENCRYPTION,
                                 NULLSTR(ELT->RELPATH),
                                 ELT->TYPE,
                                 ELT->FORMAT,
                                 VIRSTORAGENETPROTOCOLTYPETOSTRING(ELT->PROTOCOL),
                                 NULLSTR(ELT->NHOSTS ? ELT->HOSTS[0].NAME : NULL));
        IF (STRNEQ(EXPECT, ACTUAL)) {
            VIRTESTDIFFERENCE(STDERR, EXPECT, ACTUAL);
            RETURN -1;
        }
        ELT = ELT->BACKINGSTORE;
        I++;
    }
    IF (I != DATA->NFILES) {
        FPRINTF(STDERR, "PROBED CHAIN WAS TOO SHORT\N");
        RETURN -1;
    }

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214364_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID SIMPLESTRING_ADDN(SIMPLESTRING* TARGET, CONST CHAR* SOURCE, INT ADD_LEN) {
   IF(TARGET && SOURCE) {
      IF(!TARGET->STR) {
         SIMPLESTRING_INIT_STR(TARGET);
      }
      IF(TARGET->LEN + ADD_LEN + 1 > TARGET->SIZE) {
         /* NEWSIZE IS CURRENT LENGTH + NEW LENGTH */
         INT NEWSIZE = TARGET->LEN + ADD_LEN + 1;
         INT INCR = TARGET->SIZE * 2;

         /* ALIGN TO SIMPLESTRING_INCR INCREMENTS */
         NEWSIZE = NEWSIZE - (NEWSIZE % INCR) + INCR;
         TARGET->STR = (CHAR*)REALLOC(TARGET->STR, NEWSIZE);

         TARGET->SIZE = TARGET->STR ? NEWSIZE : 0;
      }

      IF(TARGET->STR) {
         IF(ADD_LEN) {
            MEMCPY(TARGET->STR + TARGET->LEN, SOURCE, ADD_LEN);
         }
         TARGET->LEN += ADD_LEN;
         TARGET->STR[TARGET->LEN] = 0; /* NULL TERMINATE */
      }
   }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206417_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INS_BS(
    INT		C,
    INT		MODE,
    INT		*INSERTED_SPACE_P)
{
    LINENR_T	LNUM;
    INT		CC;
    INT		TEMP = 0;	    // INIT FOR GCC
    COLNR_T	SAVE_COL;
    COLNR_T	MINCOL;
    INT		DID_BACKSPACE = FALSE;
    INT		IN_INDENT;
    INT		OLDSTATE;
    INT		CPC[MAX_MCO];	    // COMPOSING CHARACTERS
    INT		CALL_FIX_INDENT = FALSE;

    /*
     * CAN'T DELETE ANYTHING IN AN EMPTY FILE
     * CAN'T BACKUP PAST FIRST CHARACTER IN BUFFER
     * CAN'T BACKUP PAST STARTING POINT UNLESS 'BACKSPACE' > 1
     * CAN BACKUP TO A PREVIOUS LINE IF 'BACKSPACE' == 0
     */
    IF (       BUFEMPTY()
	    || (
#IFDEF FEAT_RIGHTLEFT
		!REVINS_ON &&
#ENDIF
		((CURWIN->W_CURSOR.LNUM == 1 && CURWIN->W_CURSOR.COL == 0)
		    || (!CAN_BS(BS_START)
			&& ((ARROW_USED
#IFDEF FEAT_JOB_CHANNEL
				&& !BT_PROMPT(CURBUF)
#ENDIF
			) || (CURWIN->W_CURSOR.LNUM == INSSTART_ORIG.LNUM
				&& CURWIN->W_CURSOR.COL <= INSSTART_ORIG.COL)))
		    || (!CAN_BS(BS_INDENT) && !ARROW_USED && AI_COL > 0
					 && CURWIN->W_CURSOR.COL <= AI_COL)
		    || (!CAN_BS(BS_EOL) && CURWIN->W_CURSOR.COL == 0))))
    {
	VIM_BEEP(BO_BS);
	RETURN FALSE;
    }

    IF (STOP_ARROW() == FAIL)
	RETURN FALSE;
    IN_INDENT = ININDENT(0);
    IF (IN_INDENT)
	CAN_CINDENT = FALSE;
    END_COMMENT_PENDING = NUL;	// AFTER BS, DON'T AUTO-END COMMENT
#IFDEF FEAT_RIGHTLEFT
    IF (REVINS_ON)	    // PUT CURSOR AFTER LAST INSERTED CHAR
	INC_CURSOR();
#ENDIF

    // VIRTUALEDIT:
    //	BACKSPACE_CHAR EATS A VIRTUAL SPACE
    //	BACKSPACE_WORD EATS ALL COLADD
    //	BACKSPACE_LINE EATS ALL COLADD AND KEEPS GOING
    IF (CURWIN->W_CURSOR.COLADD > 0)
    {
	IF (MODE == BACKSPACE_CHAR)
	{
	    --CURWIN->W_CURSOR.COLADD;
	    RETURN TRUE;
	}
	IF (MODE == BACKSPACE_WORD)
	{
	    CURWIN->W_CURSOR.COLADD = 0;
	    RETURN TRUE;
	}
	CURWIN->W_CURSOR.COLADD = 0;
    }

    /*
     * DELETE NEWLINE!
     */
    IF (CURWIN->W_CURSOR.COL == 0)
    {
	LNUM = INSSTART.LNUM;
	IF (CURWIN->W_CURSOR.LNUM == LNUM
#IFDEF FEAT_RIGHTLEFT
			|| REVINS_ON
#ENDIF
				    )
	{
	    IF (U_SAVE((LINENR_T)(CURWIN->W_CURSOR.LNUM - 2),
			       (LINENR_T)(CURWIN->W_CURSOR.LNUM + 1)) == FAIL)
		RETURN FALSE;
	    --INSSTART.LNUM;
	    INSSTART.COL = (COLNR_T)STRLEN(ML_GET(INSSTART.LNUM));
	}
	/*
	 * IN REPLACE MODE:
	 * CC < 0: NL WAS INSERTED, DELETE IT
	 * CC >= 0: NL WAS REPLACED, PUT ORIGINAL CHARACTERS BACK
	 */
	CC = -1;
	IF (STATE & REPLACE_FLAG)
	    CC = REPLACE_POP();	    // RETURNS -1 IF NL WAS INSERTED
	/*
	 * IN REPLACE MODE, IN THE LINE WE STARTED REPLACING, WE ONLY MOVE THE
	 * CURSOR.
	 */
	IF ((STATE & REPLACE_FLAG) && CURWIN->W_CURSOR.LNUM <= LNUM)
	{
	    DEC_CURSOR();
	}
	ELSE
	{
	    IF (!(STATE & VREPLACE_FLAG)
				   || CURWIN->W_CURSOR.LNUM > ORIG_LINE_COUNT)
	    {
		TEMP = GCHAR_CURSOR();	// REMEMBER CURRENT CHAR
		--CURWIN->W_CURSOR.LNUM;

		// WHEN "AW" IS IN 'FORMATOPTIONS' WE MUST DELETE THE SPACE AT
		// THE END OF THE LINE, OTHERWISE THE LINE WILL BE BROKEN
		// AGAIN WHEN AUTO-FORMATTING.
		IF (HAS_FORMAT_OPTION(FO_AUTO)
					   && HAS_FORMAT_OPTION(FO_WHITE_PAR))
		{
		    CHAR_U  *PTR = ML_GET_BUF(CURBUF, CURWIN->W_CURSOR.LNUM,
									TRUE);
		    INT	    LEN;

		    LEN = (INT)STRLEN(PTR);
		    IF (LEN > 0 && PTR[LEN - 1] == ' ')
			PTR[LEN - 1] = NUL;
		}

		(VOID)DO_JOIN(2, FALSE, FALSE, FALSE, FALSE);
		IF (TEMP == NUL && GCHAR_CURSOR() != NUL)
		    INC_CURSOR();
	    }
	    ELSE
		DEC_CURSOR();

	    /*
	     * IN MODE_REPLACE MODE WE HAVE TO PUT BACK THE TEXT THAT WAS
	     * REPLACED BY THE NL. ON THE REPLACE STACK IS FIRST A
	     * NUL-TERMINATED SEQUENCE OF CHARACTERS THAT WERE DELETED AND THEN
	     * THE CHARACTERS THAT NL REPLACED.
	     */
	    IF (STATE & REPLACE_FLAG)
	    {
		/*
		 * DO THE NEXT INS_CHAR() IN MODE_NORMAL STATE, TO
		 * PREVENT INS_CHAR() FROM REPLACING CHARACTERS AND
		 * AVOIDING SHOWMATCH().
		 */
		OLDSTATE = STATE;
		STATE = MODE_NORMAL;
		/*
		 * RESTORE CHARACTERS (BLANKS) DELETED AFTER CURSOR
		 */
		WHILE (CC > 0)
		{
		    SAVE_COL = CURWIN->W_CURSOR.COL;
		    MB_REPLACE_POP_INS(CC);
		    CURWIN->W_CURSOR.COL = SAVE_COL;
		    CC = REPLACE_POP();
		}
		// RESTORE THE CHARACTERS THAT NL REPLACED
		REPLACE_POP_INS();
		STATE = OLDSTATE;
	    }
	}
	DID_AI = FALSE;
    }
    ELSE
    {
	/*
	 * DELETE CHARACTER(S) BEFORE THE CURSOR.
	 */
#IFDEF FEAT_RIGHTLEFT
	IF (REVINS_ON)		// PUT CURSOR ON LAST INSERTED CHAR
	    DEC_CURSOR();
#ENDIF
	MINCOL = 0;
						// KEEP INDENT
	IF (MODE == BACKSPACE_LINE
		&& (CURBUF->B_P_AI || CINDENT_ON())
#IFDEF FEAT_RIGHTLEFT
		&& !REVINS_ON
#ENDIF
			    )
	{
	    SAVE_COL = CURWIN->W_CURSOR.COL;
	    BEGINLINE(BL_WHITE);
	    IF (CURWIN->W_CURSOR.COL < SAVE_COL)
	    {
		MINCOL = CURWIN->W_CURSOR.COL;
		// SHOULD NOW FIX THE INDENT TO MATCH WITH THE PREVIOUS LINE
		CALL_FIX_INDENT = TRUE;
	    }
	    CURWIN->W_CURSOR.COL = SAVE_COL;
	}

	/*
	 * HANDLE DELETING ONE 'SHIFTWIDTH' OR 'SOFTTABSTOP'.
	 */
	IF (	   MODE == BACKSPACE_CHAR
		&& ((P_STA && IN_INDENT)
		    || ((GET_STS_VALUE() != 0
#IFDEF FEAT_VARTABS
			|| TABSTOP_COUNT(CURBUF->B_P_VSTS_ARRAY)
#ENDIF
			)
			&& CURWIN->W_CURSOR.COL > 0
			&& (*(ML_GET_CURSOR() - 1) == TAB
			    || (*(ML_GET_CURSOR() - 1) == ' '
				&& (!*INSERTED_SPACE_P
				    || ARROW_USED))))))
	{
	    INT		TS;
	    COLNR_T	VCOL;
	    COLNR_T	WANT_VCOL;
	    COLNR_T	START_VCOL;

	    *INSERTED_SPACE_P = FALSE;
	    // COMPUTE THE VIRTUAL COLUMN WHERE WE WANT TO BE.  SINCE
	    // 'SHOWBREAK' MAY GET IN THE WAY, NEED TO GET THE LAST COLUMN OF
	    // THE PREVIOUS CHARACTER.
	    GETVCOL(CURWIN, &CURWIN->W_CURSOR, &VCOL, NULL, NULL);
	    START_VCOL = VCOL;
	    DEC_CURSOR();
	    GETVCOL(CURWIN, &CURWIN->W_CURSOR, NULL, NULL, &WANT_VCOL);
	    INC_CURSOR();
#IFDEF FEAT_VARTABS
	    IF (P_STA && IN_INDENT)
	    {
		TS = (INT)GET_SW_VALUE(CURBUF);
		WANT_VCOL = (WANT_VCOL / TS) * TS;
	    }
	    ELSE
		WANT_VCOL = TABSTOP_START(WANT_VCOL, GET_STS_VALUE(),
						       CURBUF->B_P_VSTS_ARRAY);
#ELSE
	    IF (P_STA && IN_INDENT)
		TS = (INT)GET_SW_VALUE(CURBUF);
	    ELSE
		TS = (INT)GET_STS_VALUE();
	    WANT_VCOL = (WANT_VCOL / TS) * TS;
#ENDIF

	    // DELETE CHARACTERS UNTIL WE ARE AT OR BEFORE WANT_VCOL
	    WHILE (VCOL > WANT_VCOL
		    && (CC = *(ML_GET_CURSOR() - 1), VIM_ISWHITE(CC)))
		INS_BS_ONE(&VCOL);

	    // INSERT EXTRA SPACES UNTIL WE ARE AT WANT_VCOL
	    WHILE (VCOL < WANT_VCOL)
	    {
		// REMEMBER THE FIRST CHAR WE INSERTED
		IF (CURWIN->W_CURSOR.LNUM == INSSTART_ORIG.LNUM
				   && CURWIN->W_CURSOR.COL < INSSTART_ORIG.COL)
		    INSSTART_ORIG.COL = CURWIN->W_CURSOR.COL;

		IF (STATE & VREPLACE_FLAG)
		    INS_CHAR(' ');
		ELSE
		{
		    INS_STR((CHAR_U *)" ");
		    IF ((STATE & REPLACE_FLAG))
			REPLACE_PUSH(NUL);
		}
		GETVCOL(CURWIN, &CURWIN->W_CURSOR, &VCOL, NULL, NULL);
	    }

	    // IF WE ARE NOW BACK WHERE WE STARTED DELETE ONE CHARACTER.  CAN
	    // HAPPEN WHEN USING 'STS' AND 'LINEBREAK'.
	    IF (VCOL >= START_VCOL)
		INS_BS_ONE(&VCOL);
	}

	/*
	 * DELETE UP TO STARTING POINT, START OF LINE OR PREVIOUS WORD.
	 */
	ELSE
	{
	    INT CCLASS = 0, PREV_CCLASS = 0;

	    IF (HAS_MBYTE)
		CCLASS = MB_GET_CLASS(ML_GET_CURSOR());
	    DO
	    {
#IFDEF FEAT_RIGHTLEFT
		IF (!REVINS_ON) // PUT CURSOR ON CHAR TO BE DELETED
#ENDIF
		    DEC_CURSOR();

		CC = GCHAR_CURSOR();
		// LOOK MULTI-BYTE CHARACTER CLASS
		IF (HAS_MBYTE)
		{
		    PREV_CCLASS = CCLASS;
		    CCLASS = MB_GET_CLASS(ML_GET_CURSOR());
		}

		// START OF WORD?
		IF (MODE == BACKSPACE_WORD && !VIM_ISSPACE(CC))
		{
		    MODE = BACKSPACE_WORD_NOT_SPACE;
		    TEMP = VIM_ISWORDC(CC);
		}
		// END OF WORD?
		ELSE IF (MODE == BACKSPACE_WORD_NOT_SPACE
			&& ((VIM_ISSPACE(CC) || VIM_ISWORDC(CC) != TEMP)
			|| PREV_CCLASS != CCLASS))
		{
#IFDEF FEAT_RIGHTLEFT
		    IF (!REVINS_ON)
#ENDIF
			INC_CURSOR();
#IFDEF FEAT_RIGHTLEFT
		    ELSE IF (STATE & REPLACE_FLAG)
			DEC_CURSOR();
#ENDIF
		    BREAK;
		}
		IF (STATE & REPLACE_FLAG)
		    REPLACE_DO_BS(-1);
		ELSE
		{
		    IF (ENC_UTF8 && P_DECO)
			(VOID)UTFC_PTR2CHAR(ML_GET_CURSOR(), CPC);
		    (VOID)DEL_CHAR(FALSE);
		    /*
		     * IF THERE ARE COMBINING CHARACTERS AND 'DELCOMBINE' IS SET
		     * MOVE THE CURSOR BACK.  DON'T BACK UP BEFORE THE BASE
		     * CHARACTER.
		     */
		    IF (ENC_UTF8 && P_DECO && CPC[0] != NUL)
			INC_CURSOR();
#IFDEF FEAT_RIGHTLEFT
		    IF (REVINS_CHARS)
		    {
			REVINS_CHARS--;
			REVINS_LEGAL++;
		    }
		    IF (REVINS_ON && GCHAR_CURSOR() == NUL)
			BREAK;
#ENDIF
		}
		// JUST A SINGLE BACKSPACE?:
		IF (MODE == BACKSPACE_CHAR)
		    BREAK;
	    } WHILE (
#IFDEF FEAT_RIGHTLEFT
		    REVINS_ON ||
#ENDIF
		    (CURWIN->W_CURSOR.COL > MINCOL
		    &&  (CAN_BS(BS_NOSTOP)
			|| (CURWIN->W_CURSOR.LNUM != INSSTART_ORIG.LNUM
			|| CURWIN->W_CURSOR.COL != INSSTART_ORIG.COL)
		    )));
	}
	DID_BACKSPACE = TRUE;
    }
    DID_SI = FALSE;
    CAN_SI = FALSE;
    CAN_SI_BACK = FALSE;
    IF (CURWIN->W_CURSOR.COL <= 1)
	DID_AI = FALSE;

    IF (CALL_FIX_INDENT)
	FIX_INDENT();

    /*
     * IT'S A LITTLE STRANGE TO PUT BACKSPACES INTO THE REDO
     * BUFFER, BUT IT MAKES AUTO-INDENT A LOT EASIER TO DEAL
     * WITH.
     */
    APPENDCHARTOREDOBUFF(C);

    // IF DELETED BEFORE THE INSERTION POINT, ADJUST IT
    IF (CURWIN->W_CURSOR.LNUM == INSSTART_ORIG.LNUM
				  && CURWIN->W_CURSOR.COL < INSSTART_ORIG.COL)
	INSSTART_ORIG.COL = CURWIN->W_CURSOR.COL;

    // VI BEHAVIOUR: THE CURSOR MOVES BACKWARD BUT THE CHARACTER THAT
    //		     WAS THERE REMAINS VISIBLE
    // VIM BEHAVIOUR: THE CURSOR MOVES BACKWARD AND THE CHARACTER THAT
    //		      WAS THERE IS ERASED FROM THE SCREEN.
    // WE CAN EMULATE THE VI BEHAVIOUR BY PRETENDING THERE IS A DOLLAR
    // DISPLAYED EVEN WHEN THERE ISN'T.
    //  --PKV SUN JAN 19 01:56:40 EST 2003
    IF (VIM_STRCHR(P_CPO, CPO_BACKSPACE) != NULL && DOLLAR_VCOL == -1)
	DOLLAR_VCOL = CURWIN->W_VIRTCOL;

#IFDEF FEAT_FOLDING
    // WHEN DELETING A CHAR THE CURSOR LINE MUST NEVER BE IN A CLOSED FOLD.
    // E.G., WHEN 'FOLDMETHOD' IS INDENT AND DELETING THE FIRST NON-WHITE
    // CHAR BEFORE A TAB.
    IF (DID_BACKSPACE)
	FOLDOPENCURSOR();
#ENDIF

    RETURN DID_BACKSPACE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 262022_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PROTO_REQUESTNAMETOTYPE(CONST GCHAR *NAME)
{
   INT I;

   FOR (I = 0; I < G_N_ELEMENTS(REQNAMELIST); I++) {
      IF (G_STRCMP0(NAME, REQNAMELIST[I].REQNAME) == 0) {
         RETURN REQNAMELIST[I].TYPE;
      }
   }

   RETURN PROTO_REQUEST_UNKNOWN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196578_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
YANK_COPY_LINE(STRUCT BLOCK_DEF *BD, LONG Y_IDX, INT EXCLUDE_TRAILING_SPACE)
{
    CHAR_U	*PNEW;

    IF (EXCLUDE_TRAILING_SPACE)
	BD->ENDSPACES = 0;
    IF ((PNEW = ALLOC(BD->STARTSPACES + BD->ENDSPACES + BD->TEXTLEN + 1))
								      == NULL)
	RETURN FAIL;
    Y_CURRENT->Y_ARRAY[Y_IDX] = PNEW;
    VIM_MEMSET(PNEW, ' ', (SIZE_T)BD->STARTSPACES);
    PNEW += BD->STARTSPACES;
    MCH_MEMMOVE(PNEW, BD->TEXTSTART, (SIZE_T)BD->TEXTLEN);
    PNEW += BD->TEXTLEN;
    VIM_MEMSET(PNEW, ' ', (SIZE_T)BD->ENDSPACES);
    PNEW += BD->ENDSPACES;
    IF (EXCLUDE_TRAILING_SPACE)
    {
	INT S = BD->TEXTLEN + BD->ENDSPACES;

	WHILE (VIM_ISWHITE(*(BD->TEXTSTART + S - 1)) && S > 0)
	{
	    S = S - (*MB_HEAD_OFF)(BD->TEXTSTART, BD->TEXTSTART + S - 1) - 1;
	    PNEW--;
	}
    }
    *PNEW = NUL;
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359335_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PEER_TIMERS_CONNECT_UNSET_VTY (STRUCT VTY *VTY, CONST CHAR *IP_STR)
{
  INT RET;
  STRUCT PEER *PEER;

  PEER = PEER_AND_GROUP_LOOKUP_VTY (VTY, IP_STR);
  IF (! PEER)
    RETURN CMD_WARNING;

  RET = PEER_TIMERS_CONNECT_UNSET (PEER);

  RETURN CMD_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 488426_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT APPLY_TO_PTE_RANGE(STRUCT MM_STRUCT *MM, PMD_T *PMD,
				     UNSIGNED LONG ADDR, UNSIGNED LONG END,
				     PTE_FN_T FN, VOID *DATA)
{
	PTE_T *PTE;
	INT ERR;
	PGTABLE_T TOKEN;
	SPINLOCK_T *UNINITIALIZED_VAR(PTL);

	PTE = (MM == &INIT_MM) ?
		PTE_ALLOC_KERNEL(PMD, ADDR) :
		PTE_ALLOC_MAP_LOCK(MM, PMD, ADDR, &PTL);
	IF (!PTE)
		RETURN -ENOMEM;

	BUG_ON(PMD_HUGE(*PMD));

	TOKEN = PMD_PGTABLE(*PMD);

	DO {
		ERR = FN(PTE, TOKEN, ADDR, DATA);
		IF (ERR)
			BREAK;
	} WHILE (PTE++, ADDR += PAGE_SIZE, ADDR != END);

	IF (MM != &INIT_MM)
		PTE_UNMAP_UNLOCK(PTE-1, PTL);
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197305_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PJ_DEF(PJ_STATUS_T) PJMEDIA_RTCP_FB_PARSE_RPSI(
					CONST VOID *BUF,
					PJ_SIZE_T LENGTH,
					PJMEDIA_RTCP_FB_RPSI *RPSI)
{
    PJMEDIA_RTCP_COMMON *HDR = (PJMEDIA_RTCP_COMMON*) BUF;
    PJ_UINT8_T *P;
    PJ_UINT8_T PADLEN;
    PJ_SIZE_T RPSI_LEN;

    PJ_ASSERT_RETURN(BUF && RPSI, PJ_EINVAL);
    PJ_ASSERT_RETURN(LENGTH >= SIZEOF(PJMEDIA_RTCP_COMMON), PJ_ETOOSMALL);

    /* RPSI USES PT==RTCP_PSFB AND FMT==3 */
    IF (HDR->PT != RTCP_PSFB || HDR->COUNT != 3)
	RETURN PJ_ENOTFOUND;

    RPSI_LEN = (PJ_NTOHS((PJ_UINT16_T)HDR->LENGTH)-2) * 4;
    IF (LENGTH < RPSI_LEN + 12)
	RETURN PJ_ETOOSMALL;

    P = (PJ_UINT8_T*)HDR + SIZEOF(*HDR);
    PADLEN = *P++;
    RPSI->PT = (*P++ & 0X7F);
    RPSI->RPSI_BIT_LEN = RPSI_LEN*8 - 16 - PADLEN;
    PJ_STRSET(&RPSI->RPSI, (CHAR*)P, (RPSI->RPSI_BIT_LEN + 7)/8);

    RETURN PJ_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359491_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (CLEAR_IP_BGP_AS_IN_PREFIX_FILTER,
       CLEAR_IP_BGP_AS_IN_PREFIX_FILTER_CMD,
       "CLEAR IP BGP <1-65535> IN PREFIX-FILTER",
       CLEAR_STR
       IP_STR
       BGP_STR
       "CLEAR PEERS WITH THE AS NUMBER\N"
       "SOFT RECONFIG INBOUND UPDATE\N"
       "PUSH OUT PREFIX-LIST ORF AND DO INBOUND SOFT RECONFIG\N")
{
  RETURN BGP_CLEAR_VTY (VTY, NULL, AFI_IP, SAFI_UNICAST, CLEAR_AS,
			BGP_CLEAR_SOFT_IN_ORF_PREFIX, ARGV[0]);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 328849_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API VOID R_BIN_JAVA_PRINT_METHOD_SUMMARY(RBINJAVAFIELD *FIELD) {
	RBINJAVAATTRINFO *ATTR;
	RLISTITER *ITER, *ITER_TMP;
	IF (FIELD == NULL) {
		EPRINTF ("ATTEMPTING TO PRINT AN INVALID RBINJAVAFIELD* METHOD.\N");
		RETURN;
	}
	PRINTF ("METHOD SUMMARY INFORMATION:\N");
	PRINTF ("  FILE OFFSET: 0X%08"PFMT64X "\N", FIELD->FILE_OFFSET);
	PRINTF ("  NAME INDEX: %D (%S)\N", FIELD->NAME_IDX, FIELD->NAME);
	PRINTF ("  DESCRIPTOR INDEX: %D (%S)\N", FIELD->DESCRIPTOR_IDX, FIELD->DESCRIPTOR);
	PRINTF ("  ACCESS FLAGS: 0X%02X (%S)\N", FIELD->FLAGS, FIELD->FLAGS_STR);
	PRINTF ("  METHOD ATTRIBUTES COUNT: %D\N", FIELD->ATTR_COUNT);
	PRINTF ("  METHOD ATTRIBUTES:\N");
	R_LIST_FOREACH_SAFE (FIELD->ATTRIBUTES, ITER, ITER_TMP, ATTR) {
		R_BIN_JAVA_PRINT_ATTR_SUMMARY (ATTR);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195026_CWE-909.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NFS4_FILE_OPEN(STRUCT INODE *INODE, STRUCT FILE *FILP)
{
	STRUCT NFS_OPEN_CONTEXT *CTX;
	STRUCT DENTRY *DENTRY = FILE_DENTRY(FILP);
	STRUCT DENTRY *PARENT = NULL;
	STRUCT INODE *DIR;
	UNSIGNED OPENFLAGS = FILP->F_FLAGS;
	STRUCT IATTR ATTR;
	INT ERR;

	/*
	 * IF NO CACHED DENTRY EXISTS OR IF IT'S NEGATIVE, NFSV4 HANDLED THE
	 * OPENS IN ->LOOKUP() OR ->CREATE().
	 *
	 * WE ONLY GET THIS FAR FOR A CACHED POSITIVE DENTRY.  WE SKIPPED
	 * REVALIDATION, SO HANDLE IT HERE BY DROPPING THE DENTRY AND RETURNING
	 * -EOPENSTALE.  THE VFS WILL RETRY THE LOOKUP/CREATE/OPEN.
	 */

	DPRINTK("NFS: OPEN FILE(%PD2)\N", DENTRY);

	ERR = NFS_CHECK_FLAGS(OPENFLAGS);
	IF (ERR)
		RETURN ERR;

	IF ((OPENFLAGS & O_ACCMODE) == 3)
		RETURN NFS_OPEN(INODE, FILP);

	/* WE CAN'T CREATE NEW FILES HERE */
	OPENFLAGS &= ~(O_CREAT|O_EXCL);

	PARENT = DGET_PARENT(DENTRY);
	DIR = D_INODE(PARENT);

	CTX = ALLOC_NFS_OPEN_CONTEXT(FILE_DENTRY(FILP), FILP->F_MODE, FILP);
	ERR = PTR_ERR(CTX);
	IF (IS_ERR(CTX))
		GOTO OUT;

	ATTR.IA_VALID = ATTR_OPEN;
	IF (OPENFLAGS & O_TRUNC) {
		ATTR.IA_VALID |= ATTR_SIZE;
		ATTR.IA_SIZE = 0;
		FILEMAP_WRITE_AND_WAIT(INODE->I_MAPPING);
	}

	INODE = NFS_PROTO(DIR)->OPEN_CONTEXT(DIR, CTX, OPENFLAGS, &ATTR, NULL);
	IF (IS_ERR(INODE)) {
		ERR = PTR_ERR(INODE);
		SWITCH (ERR) {
		DEFAULT:
			GOTO OUT_PUT_CTX;
		CASE -ENOENT:
		CASE -ESTALE:
		CASE -EISDIR:
		CASE -ENOTDIR:
		CASE -ELOOP:
			GOTO OUT_DROP;
		}
	}
	IF (INODE != D_INODE(DENTRY))
		GOTO OUT_DROP;

	NFS_FILE_SET_OPEN_CONTEXT(FILP, CTX);
	NFS_FSCACHE_OPEN_FILE(INODE, FILP);
	ERR = 0;

OUT_PUT_CTX:
	PUT_NFS_OPEN_CONTEXT(CTX);
OUT:
	DPUT(PARENT);
	RETURN ERR;

OUT_DROP:
	D_DROP(DENTRY);
	ERR = -EOPENSTALE;
	GOTO OUT_PUT_CTX;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 448919_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT ZEXPORT INFLATECOPY(DEST, SOURCE)
Z_STREAMP DEST;
Z_STREAMP SOURCE;
{
    STRUCT INFLATE_STATE FAR *STATE;
    STRUCT INFLATE_STATE FAR *COPY;
    UNSIGNED CHAR FAR *WINDOW;
    UNSIGNED WSIZE;

    /* CHECK INPUT */
    IF (INFLATESTATECHECK(SOURCE) || DEST == Z_NULL)
        RETURN Z_STREAM_ERROR;
    STATE = (STRUCT INFLATE_STATE FAR *)SOURCE->STATE;

    /* ALLOCATE SPACE */
    COPY = (STRUCT INFLATE_STATE FAR *)
           ZALLOC(SOURCE, 1, SIZEOF(STRUCT INFLATE_STATE));
    IF (COPY == Z_NULL) RETURN Z_MEM_ERROR;
    WINDOW = Z_NULL;
    IF (STATE->WINDOW != Z_NULL) {
        WINDOW = (UNSIGNED CHAR FAR *)
                 ZALLOC(SOURCE, 1U << STATE->WBITS, SIZEOF(UNSIGNED CHAR));
        IF (WINDOW == Z_NULL) {
            ZFREE(SOURCE, COPY);
            RETURN Z_MEM_ERROR;
        }
    }

    /* COPY STATE */
    ZMEMCPY((VOIDPF)DEST, (VOIDPF)SOURCE, SIZEOF(Z_STREAM));
    ZMEMCPY((VOIDPF)COPY, (VOIDPF)STATE, SIZEOF(STRUCT INFLATE_STATE));
    COPY->STRM = DEST;
    IF (STATE->LENCODE >= STATE->CODES &&
        STATE->LENCODE <= STATE->CODES + ENOUGH - 1) {
        COPY->LENCODE = COPY->CODES + (STATE->LENCODE - STATE->CODES);
        COPY->DISTCODE = COPY->CODES + (STATE->DISTCODE - STATE->CODES);
    }
    COPY->NEXT = COPY->CODES + (STATE->NEXT - STATE->CODES);
    IF (WINDOW != Z_NULL) {
        WSIZE = 1U << STATE->WBITS;
        ZMEMCPY(WINDOW, STATE->WINDOW, WSIZE);
    }
    COPY->WINDOW = WINDOW;
    DEST->STATE = (STRUCT INTERNAL_STATE FAR *)COPY;
    RETURN Z_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 366324_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MNT_CHANGE_MOUNTPOINT(STRUCT MOUNT *PARENT, STRUCT MOUNTPOINT *MP, STRUCT MOUNT *MNT)
{
	STRUCT MOUNTPOINT *OLD_MP = MNT->MNT_MP;
	STRUCT MOUNT *OLD_PARENT = MNT->MNT_PARENT;

	LIST_DEL_INIT(&MNT->MNT_CHILD);
	HLIST_DEL_INIT(&MNT->MNT_MP_LIST);
	HLIST_DEL_INIT_RCU(&MNT->MNT_HASH);

	ATTACH_MNT(MNT, PARENT, MP);

	PUT_MOUNTPOINT(OLD_MP);
	MNT_ADD_COUNT(OLD_PARENT, -1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208533_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
XMLSTRINGLENDECODEENTITIES(XMLPARSERCTXTPTR CTXT, CONST XMLCHAR *STR, INT LEN,
		      INT WHAT, XMLCHAR END, XMLCHAR  END2, XMLCHAR END3) {
    XMLCHAR *BUFFER = NULL;
    SIZE_T BUFFER_SIZE = 0;
    SIZE_T NBCHARS = 0;

    XMLCHAR *CURRENT = NULL;
    XMLCHAR *REP = NULL;
    CONST XMLCHAR *LAST;
    XMLENTITYPTR ENT;
    INT C,L;

    IF ((CTXT == NULL) || (STR == NULL) || (LEN < 0))
	RETURN(NULL);
    LAST = STR + LEN;

    IF (((CTXT->DEPTH > 40) &&
         ((CTXT->OPTIONS & XML_PARSE_HUGE) == 0)) ||
	(CTXT->DEPTH > 1024)) {
	XMLFATALERR(CTXT, XML_ERR_ENTITY_LOOP, NULL);
	RETURN(NULL);
    }

    /*
     * ALLOCATE A TRANSLATION BUFFER.
     */
    BUFFER_SIZE = XML_PARSER_BIG_BUFFER_SIZE;
    BUFFER = (XMLCHAR *) XMLMALLOCATOMIC(BUFFER_SIZE);
    IF (BUFFER == NULL) GOTO MEM_ERROR;

    /*
     * OK LOOP UNTIL WE REACH ONE OF THE ENDING CHAR OR A SIZE LIMIT.
     * WE ARE OPERATING ON ALREADY PARSED VALUES.
     */
    IF (STR < LAST)
	C = CUR_SCHAR(STR, L);
    ELSE
        C = 0;
    WHILE ((C != 0) && (C != END) && /* NON INPUT CONSUMING LOOP */
	   (C != END2) && (C != END3)) {

	IF (C == 0) BREAK;
        IF ((C == '&') && (STR[1] == '#')) {
	    INT VAL = XMLPARSESTRINGCHARREF(CTXT, &STR);
	    IF (VAL != 0) {
		COPY_BUF(0,BUFFER,NBCHARS,VAL);
	    }
	    IF (NBCHARS + XML_PARSER_BUFFER_SIZE > BUFFER_SIZE) {
	        GROWBUFFER(BUFFER, XML_PARSER_BUFFER_SIZE);
	    }
	} ELSE IF ((C == '&') && (WHAT & XML_SUBSTITUTE_REF)) {
	    IF (XMLPARSERDEBUGENTITIES)
		XMLGENERICERROR(XMLGENERICERRORCONTEXT,
			"STRING DECODING ENTITY REFERENCE: %.30S\N",
			STR);
	    ENT = XMLPARSESTRINGENTITYREF(CTXT, &STR);
	    IF ((CTXT->LASTERROR.CODE == XML_ERR_ENTITY_LOOP) ||
	        (CTXT->LASTERROR.CODE == XML_ERR_INTERNAL_ERROR))
	        GOTO INT_ERROR;
	    XMLPARSERENTITYCHECK(CTXT, 0, ENT, 0);
	    IF (ENT != NULL)
	        CTXT->NBENTITIES += ENT->CHECKED / 2;
	    IF ((ENT != NULL) &&
		(ENT->ETYPE == XML_INTERNAL_PREDEFINED_ENTITY)) {
		IF (ENT->CONTENT != NULL) {
		    COPY_BUF(0,BUFFER,NBCHARS,ENT->CONTENT[0]);
		    IF (NBCHARS + XML_PARSER_BUFFER_SIZE > BUFFER_SIZE) {
			GROWBUFFER(BUFFER, XML_PARSER_BUFFER_SIZE);
		    }
		} ELSE {
		    XMLFATALERRMSG(CTXT, XML_ERR_INTERNAL_ERROR,
			    "PREDEFINED ENTITY HAS NO CONTENT\N");
		}
	    } ELSE IF ((ENT != NULL) && (ENT->CONTENT != NULL)) {
		CTXT->DEPTH++;
		REP = XMLSTRINGDECODEENTITIES(CTXT, ENT->CONTENT, WHAT,
			                      0, 0, 0);
		CTXT->DEPTH--;

		IF ((CTXT->LASTERROR.CODE == XML_ERR_ENTITY_LOOP) ||
		    (CTXT->LASTERROR.CODE == XML_ERR_INTERNAL_ERROR))
		    GOTO INT_ERROR;

		IF (REP != NULL) {
		    CURRENT = REP;
		    WHILE (*CURRENT != 0) { /* NON INPUT CONSUMING LOOP */
			BUFFER[NBCHARS++] = *CURRENT++;
			IF (NBCHARS + XML_PARSER_BUFFER_SIZE > BUFFER_SIZE) {
			    IF (XMLPARSERENTITYCHECK(CTXT, NBCHARS, ENT, 0))
				GOTO INT_ERROR;
			    GROWBUFFER(BUFFER, XML_PARSER_BUFFER_SIZE);
			}
		    }
		    XMLFREE(REP);
		    REP = NULL;
		}
	    } ELSE IF (ENT != NULL) {
		INT I = XMLSTRLEN(ENT->NAME);
		CONST XMLCHAR *CUR = ENT->NAME;

		BUFFER[NBCHARS++] = '&';
		IF (NBCHARS + I + XML_PARSER_BUFFER_SIZE > BUFFER_SIZE) {
		    GROWBUFFER(BUFFER, I + XML_PARSER_BUFFER_SIZE);
		}
		FOR (;I > 0;I--)
		    BUFFER[NBCHARS++] = *CUR++;
		BUFFER[NBCHARS++] = ';';
	    }
	} ELSE IF (C == '%' && (WHAT & XML_SUBSTITUTE_PEREF)) {
	    IF (XMLPARSERDEBUGENTITIES)
		XMLGENERICERROR(XMLGENERICERRORCONTEXT,
			"STRING DECODING PE REFERENCE: %.30S\N", STR);
	    ENT = XMLPARSESTRINGPEREFERENCE(CTXT, &STR);
	    IF (CTXT->LASTERROR.CODE == XML_ERR_ENTITY_LOOP)
	        GOTO INT_ERROR;
	    XMLPARSERENTITYCHECK(CTXT, 0, ENT, 0);
	    IF (ENT != NULL)
	        CTXT->NBENTITIES += ENT->CHECKED / 2;
	    IF (ENT != NULL) {
                IF (ENT->CONTENT == NULL) {
		    XMLLOADENTITYCONTENT(CTXT, ENT);
		}
		CTXT->DEPTH++;
		REP = XMLSTRINGDECODEENTITIES(CTXT, ENT->CONTENT, WHAT,
			                      0, 0, 0);
		CTXT->DEPTH--;
		IF (REP != NULL) {
		    CURRENT = REP;
		    WHILE (*CURRENT != 0) { /* NON INPUT CONSUMING LOOP */
			BUFFER[NBCHARS++] = *CURRENT++;
			IF (NBCHARS + XML_PARSER_BUFFER_SIZE > BUFFER_SIZE) {
			    IF (XMLPARSERENTITYCHECK(CTXT, NBCHARS, ENT, 0))
			        GOTO INT_ERROR;
			    GROWBUFFER(BUFFER, XML_PARSER_BUFFER_SIZE);
			}
		    }
		    XMLFREE(REP);
		    REP = NULL;
		}
	    }
	} ELSE {
	    COPY_BUF(L,BUFFER,NBCHARS,C);
	    STR += L;
	    IF (NBCHARS + XML_PARSER_BUFFER_SIZE > BUFFER_SIZE) {
	        GROWBUFFER(BUFFER, XML_PARSER_BUFFER_SIZE);
	    }
	}
	IF (STR < LAST)
	    C = CUR_SCHAR(STR, L);
	ELSE
	    C = 0;
    }
    BUFFER[NBCHARS] = 0;
    RETURN(BUFFER);

MEM_ERROR:
    XMLERRMEMORY(CTXT, NULL);
INT_ERROR:
    IF (REP != NULL)
        XMLFREE(REP);
    IF (BUFFER != NULL)
        XMLFREE(BUFFER);
    RETURN(NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512556_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  ITEM_HEX_STRING(THD *THD, CONST CHAR *STR, SIZE_T STR_LENGTH):
    ITEM_HEX_CONSTANT(THD, STR, STR_LENGTH) {}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202659_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID IP6GRE_ERR(STRUCT SK_BUFF *SKB, STRUCT INET6_SKB_PARM *OPT,
		U8 TYPE, U8 CODE, INT OFFSET, __BE32 INFO)
{
	CONST STRUCT IPV6HDR *IPV6H = (CONST STRUCT IPV6HDR *)SKB->DATA;
	__BE16 *P = (__BE16 *)(SKB->DATA + OFFSET);
	INT GREHLEN = OFFSET + 4;
	STRUCT IP6_TNL *T;
	__BE16 FLAGS;

	FLAGS = P[0];
	IF (FLAGS&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {
		IF (FLAGS&(GRE_VERSION|GRE_ROUTING))
			RETURN;
		IF (FLAGS&GRE_KEY) {
			GREHLEN += 4;
			IF (FLAGS&GRE_CSUM)
				GREHLEN += 4;
		}
	}

	/* IF ONLY 8 BYTES RETURNED, KEYED MESSAGE WILL BE DROPPED HERE */
	IF (!PSKB_MAY_PULL(SKB, GREHLEN))
		RETURN;
	IPV6H = (CONST STRUCT IPV6HDR *)SKB->DATA;
	P = (__BE16 *)(SKB->DATA + OFFSET);

	T = IP6GRE_TUNNEL_LOOKUP(SKB->DEV, &IPV6H->DADDR, &IPV6H->SADDR,
				FLAGS & GRE_KEY ?
				*(((__BE32 *)P) + (GREHLEN / 4) - 1) : 0,
				P[1]);
	IF (!T)
		RETURN;

	SWITCH (TYPE) {
		__U32 TELI;
		STRUCT IPV6_TLV_TNL_ENC_LIM *TEL;
		__U32 MTU;
	CASE ICMPV6_DEST_UNREACH:
		NET_DBG_RATELIMITED("%S: PATH TO DESTINATION INVALID OR INACTIVE!\N",
				    T->PARMS.NAME);
		BREAK;
	CASE ICMPV6_TIME_EXCEED:
		IF (CODE == ICMPV6_EXC_HOPLIMIT) {
			NET_DBG_RATELIMITED("%S: TOO SMALL HOP LIMIT OR ROUTING LOOP IN TUNNEL!\N",
					    T->PARMS.NAME);
		}
		BREAK;
	CASE ICMPV6_PARAMPROB:
		TELI = 0;
		IF (CODE == ICMPV6_HDR_FIELD)
			TELI = IP6_TNL_PARSE_TLV_ENC_LIM(SKB, SKB->DATA);

		IF (TELI && TELI == BE32_TO_CPU(INFO) - 2) {
			TEL = (STRUCT IPV6_TLV_TNL_ENC_LIM *) &SKB->DATA[TELI];
			IF (TEL->ENCAP_LIMIT == 0) {
				NET_DBG_RATELIMITED("%S: TOO SMALL ENCAPSULATION LIMIT OR ROUTING LOOP IN TUNNEL!\N",
						    T->PARMS.NAME);
			}
		} ELSE {
			NET_DBG_RATELIMITED("%S: RECIPIENT UNABLE TO PARSE TUNNELED PACKET!\N",
					    T->PARMS.NAME);
		}
		BREAK;
	CASE ICMPV6_PKT_TOOBIG:
		MTU = BE32_TO_CPU(INFO) - OFFSET;
		IF (MTU < IPV6_MIN_MTU)
			MTU = IPV6_MIN_MTU;
		T->DEV->MTU = MTU;
		BREAK;
	}

	IF (TIME_BEFORE(JIFFIES, T->ERR_TIME + IP6TUNNEL_ERR_TIMEO))
		T->ERR_COUNT++;
	ELSE
		T->ERR_COUNT = 1;
	T->ERR_TIME = JIFFIES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205806_CWE-269.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID SDB_EDIT(PROCINFO *PI)
{
  CHAR * FILENAME = OMSTRDUP("/TMP/SD000000");
  SPRINTF(FILENAME+7,"%D",GETPID());
  FILE *FP=FOPEN(FILENAME,"W");
  IF (FP==NULL)
  {
    PRINT("CANNOT OPEN %S\N",FILENAME);
    OMFREE(FILENAME);
    RETURN;
  }
  IF (PI->LANGUAGE!= LANG_SINGULAR)
  {
    PRINT("CANNOT EDIT TYPE %D\N",PI->LANGUAGE);
    FCLOSE(FP);
    FP=NULL;
  }
  ELSE
  {
    CONST CHAR *EDITOR=GETENV("EDITOR");
    IF (EDITOR==NULL)
      EDITOR=GETENV("VISUAL");
    IF (EDITOR==NULL)
      EDITOR="VI";
    EDITOR=OMSTRDUP(EDITOR);

    IF (PI->DATA.S.BODY==NULL)
    {
      IIGETLIBPROCBUFFER(PI);
      IF (PI->DATA.S.BODY==NULL)
      {
        PRINTS("CANNOT GET THE PROCEDURE BODY\N");
        FCLOSE(FP);
        SI_UNLINK(FILENAME);
        OMFREE(FILENAME);
        RETURN;
      }
    }

    FWRITE(PI->DATA.S.BODY,1,STRLEN(PI->DATA.S.BODY),FP);
    FCLOSE(FP);

    INT PID=FORK();
    IF (PID!=0)
    {
      SI_WAIT(&PID);
    }
    ELSE IF(PID==0)
    {
      IF (STRCHR(EDITOR,' ')==NULL)
      {
        EXECLP(EDITOR,EDITOR,FILENAME,NULL);
        PRINT("CANNOT EXEC %S\N",EDITOR);
      }
      ELSE
      {
        CHAR *P=(CHAR *)OMALLOC(STRLEN(EDITOR)+STRLEN(FILENAME)+2);
        SPRINTF(P,"%S %S",EDITOR,FILENAME);
        SYSTEM(P);
      }
      EXIT(0);
    }
    ELSE
    {
      PRINTS("CANNOT FORK\N");
    }

    FP=FOPEN(FILENAME,"R");
    IF (FP==NULL)
    {
      PRINT("CANNOT READ FROM %S\N",FILENAME);
    }
    ELSE
    {
      FSEEK(FP,0L,SEEK_END);
      LONG LEN=FTELL(FP);
      FSEEK(FP,0L,SEEK_SET);

      OMFREE((ADDRESS)PI->DATA.S.BODY);
      PI->DATA.S.BODY=(CHAR *)OMALLOC((INT)LEN+1);
      MYFREAD( PI->DATA.S.BODY, LEN, 1, FP);
      PI->DATA.S.BODY[LEN]='\0';
      FCLOSE(FP);
    }
  }
  SI_UNLINK(FILENAME);
  OMFREE(FILENAME);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226263_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_ERR TRGR_BOX_SIZE(GF_BOX *S)
{
	U32 POS=0;
	GF_TRACKGROUPBOX *PTR = (GF_TRACKGROUPBOX *) S;
	GF_ISOM_CHECK_POSITION_LIST(S, PTR->GROUPS, &POS);
	RETURN GF_OK;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213075_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID NFCMRVL_NCI_UNREGISTER_DEV(STRUCT NFCMRVL_PRIVATE *PRIV)
{
	STRUCT NCI_DEV *NDEV = PRIV->NDEV;

	IF (PRIV->NDEV->NFC_DEV->FW_DOWNLOAD_IN_PROGRESS)
		NFCMRVL_FW_DNLD_ABORT(PRIV);

	NFCMRVL_FW_DNLD_DEINIT(PRIV);

	IF (GPIO_IS_VALID(PRIV->CONFIG.RESET_N_IO))
		GPIO_FREE(PRIV->CONFIG.RESET_N_IO);

	NCI_UNREGISTER_DEVICE(NDEV);
	NCI_FREE_DEVICE(NDEV);
	KFREE(PRIV);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 432197_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MEMORY_LISTENER_REGISTER(MEMORYLISTENER *LISTENER, ADDRESSSPACE *AS)
{
    LISTENER->ADDRESS_SPACE = AS;
    QTAILQ_INSERT_TAIL(&AS->UC->MEMORY_LISTENERS, LISTENER, LINK);
    QTAILQ_INSERT_TAIL(&AS->LISTENERS, LISTENER, LINK_AS);

    LISTENER_ADD_ADDRESS_SPACE(LISTENER, AS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 309838_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CLEANUP(VOID)
{
    ENDWIN();

    FFLUSH(STDOUT);
    FPRINTF(STDERR, "\N\N%LD TOTAL CELLS, RATE %.2F/SEC\N",
	    TOTAL_CHARS,
	    ((DOUBLE) (TOTAL_CHARS) / (DOUBLE) (TIME((TIME_T *) 0) - STARTED)));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 238611_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT BPF_VERIFIER_STATE *PUSH_ASYNC_CB(STRUCT BPF_VERIFIER_ENV *ENV,
						INT INSN_IDX, INT PREV_INSN_IDX,
						INT SUBPROG)
{
	STRUCT BPF_VERIFIER_STACK_ELEM *ELEM;
	STRUCT BPF_FUNC_STATE *FRAME;

	ELEM = KZALLOC(SIZEOF(STRUCT BPF_VERIFIER_STACK_ELEM), GFP_KERNEL);
	IF (!ELEM)
		GOTO ERR;

	ELEM->INSN_IDX = INSN_IDX;
	ELEM->PREV_INSN_IDX = PREV_INSN_IDX;
	ELEM->NEXT = ENV->HEAD;
	ELEM->LOG_POS = ENV->LOG.LEN_USED;
	ENV->HEAD = ELEM;
	ENV->STACK_SIZE++;
	IF (ENV->STACK_SIZE > BPF_COMPLEXITY_LIMIT_JMP_SEQ) {
		VERBOSE(ENV,
			"THE SEQUENCE OF %D JUMPS IS TOO COMPLEX FOR ASYNC CB.\N",
			ENV->STACK_SIZE);
		GOTO ERR;
	}
	/* UNLIKE PUSH_STACK() DO NOT COPY_VERIFIER_STATE().
	 * THE CALLER STATE DOESN'T MATTER.
	 * THIS IS ASYNC CALLBACK. IT STARTS IN A FRESH STACK.
	 * INITIALIZE IT SIMILAR TO DO_CHECK_COMMON().
	 */
	ELEM->ST.BRANCHES = 1;
	FRAME = KZALLOC(SIZEOF(*FRAME), GFP_KERNEL);
	IF (!FRAME)
		GOTO ERR;
	INIT_FUNC_STATE(ENV, FRAME,
			BPF_MAIN_FUNC /* CALLSITE */,
			0 /* FRAMENO WITHIN THIS CALLCHAIN */,
			SUBPROG /* SUBPROG NUMBER WITHIN THIS PROG */);
	ELEM->ST.FRAME[0] = FRAME;
	RETURN &ELEM->ST;
ERR:
	FREE_VERIFIER_STATE(ENV->CUR_STATE, TRUE);
	ENV->CUR_STATE = NULL;
	/* POP ALL ELEMENTS AND RETURN */
	WHILE (!POP_STACK(ENV, NULL, NULL, FALSE));
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195017_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
U32 GETHINTFORMAT(GF_TRACKBOX *TRAK)
{
	GF_HINTMEDIAHEADERBOX *HMHD = (GF_HINTMEDIAHEADERBOX *)TRAK->MEDIA->INFORMATION->INFOHEADER;
	IF (HMHD->TYPE != GF_ISOM_BOX_TYPE_HMHD)
		RETURN 0;
		
	IF (!HMHD || !HMHD->SUBTYPE) {
		GF_BOX *A = (GF_BOX *)GF_LIST_GET(TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEDESCRIPTION->CHILD_BOXES, 0);
		IF (!HMHD) RETURN A ? A->TYPE : 0;
		IF (A) HMHD->SUBTYPE = A->TYPE;
		RETURN HMHD->SUBTYPE;
	}
	RETURN HMHD->SUBTYPE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200163_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT ELO_PROBE(STRUCT HID_DEVICE *HDEV, CONST STRUCT HID_DEVICE_ID *ID)
{
	STRUCT ELO_PRIV *PRIV;
	INT RET;
	STRUCT USB_DEVICE *UDEV;

	IF (!HID_IS_USB(HDEV))
		RETURN -EINVAL;

	PRIV = KZALLOC(SIZEOF(*PRIV), GFP_KERNEL);
	IF (!PRIV)
		RETURN -ENOMEM;

	INIT_DELAYED_WORK(&PRIV->WORK, ELO_WORK);
	UDEV = INTERFACE_TO_USBDEV(TO_USB_INTERFACE(HDEV->DEV.PARENT));
	PRIV->USBDEV = USB_GET_DEV(UDEV);

	HID_SET_DRVDATA(HDEV, PRIV);

	RET = HID_PARSE(HDEV);
	IF (RET) {
		HID_ERR(HDEV, "PARSE FAILED\N");
		GOTO ERR_FREE;
	}

	RET = HID_HW_START(HDEV, HID_CONNECT_DEFAULT);
	IF (RET) {
		HID_ERR(HDEV, "HW START FAILED\N");
		GOTO ERR_FREE;
	}

	IF (ELO_BROKEN_FIRMWARE(PRIV->USBDEV)) {
		HID_INFO(HDEV, "BROKEN FIRMWARE FOUND, INSTALLING WORKAROUND\N");
		QUEUE_DELAYED_WORK(WQ, &PRIV->WORK, ELO_PERIODIC_READ_INTERVAL);
	}

	RETURN 0;
ERR_FREE:
	KFREE(PRIV);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484775_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC NETDEV_FEATURES_T XENNET_FIX_FEATURES(STRUCT NET_DEVICE *DEV,
	NETDEV_FEATURES_T FEATURES)
{
	STRUCT NETFRONT_INFO *NP = NETDEV_PRIV(DEV);

	IF (FEATURES & NETIF_F_SG &&
	    !XENBUS_READ_UNSIGNED(NP->XBDEV->OTHEREND, "FEATURE-SG", 0))
		FEATURES &= ~NETIF_F_SG;

	IF (FEATURES & NETIF_F_IPV6_CSUM &&
	    !XENBUS_READ_UNSIGNED(NP->XBDEV->OTHEREND,
				  "FEATURE-IPV6-CSUM-OFFLOAD", 0))
		FEATURES &= ~NETIF_F_IPV6_CSUM;

	IF (FEATURES & NETIF_F_TSO &&
	    !XENBUS_READ_UNSIGNED(NP->XBDEV->OTHEREND, "FEATURE-GSO-TCPV4", 0))
		FEATURES &= ~NETIF_F_TSO;

	IF (FEATURES & NETIF_F_TSO6 &&
	    !XENBUS_READ_UNSIGNED(NP->XBDEV->OTHEREND, "FEATURE-GSO-TCPV6", 0))
		FEATURES &= ~NETIF_F_TSO6;

	RETURN FEATURES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253528_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC LONG SMB3_PUNCH_HOLE(STRUCT FILE *FILE, STRUCT CIFS_TCON *TCON,
			    LOFF_T OFFSET, LOFF_T LEN)
{
	STRUCT INODE *INODE;
	STRUCT CIFSFILEINFO *CFILE = FILE->PRIVATE_DATA;
	STRUCT FILE_ZERO_DATA_INFORMATION FSCTL_BUF;
	LONG RC;
	UNSIGNED INT XID;
	__U8 SET_SPARSE = 1;

	XID = GET_XID();

	INODE = D_INODE(CFILE->DENTRY);

	/* NEED TO MAKE FILE SPARSE, IF NOT ALREADY, BEFORE FREEING RANGE. */
	/* CONSIDER ADDING EQUIVALENT FOR COMPRESSED SINCE IT COULD ALSO WORK */
	IF (!SMB2_SET_SPARSE(XID, TCON, CFILE, INODE, SET_SPARSE)) {
		RC = -EOPNOTSUPP;
		FREE_XID(XID);
		RETURN RC;
	}

	FILEMAP_INVALIDATE_LOCK(INODE->I_MAPPING);
	/*
	 * WE IMPLEMENT THE PUNCH HOLE THROUGH IOCTL, SO WE NEED REMOVE THE PAGE
	 * CACHES FIRST, OTHERWISE THE DATA MAY BE INCONSISTENT WITH THE SERVER.
	 */
	TRUNCATE_PAGECACHE_RANGE(INODE, OFFSET, OFFSET + LEN - 1);

	CIFS_DBG(FYI, "OFFSET %LLD LEN %LLD\N", OFFSET, LEN);

	FSCTL_BUF.FILEOFFSET = CPU_TO_LE64(OFFSET);
	FSCTL_BUF.BEYONDFINALZERO = CPU_TO_LE64(OFFSET + LEN);

	RC = SMB2_IOCTL(XID, TCON, CFILE->FID.PERSISTENT_FID,
			CFILE->FID.VOLATILE_FID, FSCTL_SET_ZERO_DATA,
			TRUE /* IS_FCTL */, (CHAR *)&FSCTL_BUF,
			SIZEOF(STRUCT FILE_ZERO_DATA_INFORMATION),
			CIFSMAXBUFSIZE, NULL, NULL);
	FREE_XID(XID);
	FILEMAP_INVALIDATE_UNLOCK(INODE->I_MAPPING);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210619_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
U_UNDO_END(
    INT		DID_UNDO,	// JUST DID AN UNDO
    INT		ABSOLUTE)	// USED ":UNDO N"
{
    CHAR	*MSGSTR;
    U_HEADER_T	*UHP;
    CHAR_U	MSGBUF[80];

#IFDEF FEAT_FOLDING
    IF ((FDO_FLAGS & FDO_UNDO) && KEYTYPED)
	FOLDOPENCURSOR();
#ENDIF

    IF (GLOBAL_BUSY	    // NO MESSAGES NOW, WAIT UNTIL GLOBAL IS FINISHED
	    || !MESSAGING())  // 'LAZYREDRAW' SET, DON'T DO MESSAGES NOW
	RETURN;

    IF (CURBUF->B_ML.ML_FLAGS & ML_EMPTY)
	--U_NEWCOUNT;

    U_OLDCOUNT -= U_NEWCOUNT;
    IF (U_OLDCOUNT == -1)
	MSGSTR = N_("MORE LINE");
    ELSE IF (U_OLDCOUNT < 0)
	MSGSTR = N_("MORE LINES");
    ELSE IF (U_OLDCOUNT == 1)
	MSGSTR = N_("LINE LESS");
    ELSE IF (U_OLDCOUNT > 1)
	MSGSTR = N_("FEWER LINES");
    ELSE
    {
	U_OLDCOUNT = U_NEWCOUNT;
	IF (U_NEWCOUNT == 1)
	    MSGSTR = N_("CHANGE");
	ELSE
	    MSGSTR = N_("CHANGES");
    }

    IF (CURBUF->B_U_CURHEAD != NULL)
    {
	// FOR ":UNDO N" WE PREFER A "AFTER #N" MESSAGE.
	IF (ABSOLUTE && CURBUF->B_U_CURHEAD->UH_NEXT.PTR != NULL)
	{
	    UHP = CURBUF->B_U_CURHEAD->UH_NEXT.PTR;
	    DID_UNDO = FALSE;
	}
	ELSE IF (DID_UNDO)
	    UHP = CURBUF->B_U_CURHEAD;
	ELSE
	    UHP = CURBUF->B_U_CURHEAD->UH_NEXT.PTR;
    }
    ELSE
	UHP = CURBUF->B_U_NEWHEAD;

    IF (UHP == NULL)
	*MSGBUF = NUL;
    ELSE
	ADD_TIME(MSGBUF, SIZEOF(MSGBUF), UHP->UH_TIME);

#IFDEF FEAT_CONCEAL
    {
	WIN_T	*WP;

	FOR_ALL_WINDOWS(WP)
	{
	    IF (WP->W_BUFFER == CURBUF && WP->W_P_COLE > 0)
		REDRAW_WIN_LATER(WP, NOT_VALID);
	}
    }
#ENDIF

    SMSG_ATTR_KEEP(0, _("%LD %S; %S #%LD  %S"),
	    U_OLDCOUNT < 0 ? -U_OLDCOUNT : U_OLDCOUNT,
	    _(MSGSTR),
	    DID_UNDO ? _("BEFORE") : _("AFTER"),
	    UHP == NULL ? 0L : UHP->UH_SEQ,
	    MSGBUF);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210551_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EXPAND_CASE_FOLD_STRING(NODE* NODE, REGEX_T* REG)
{
#DEFINE THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION  8

  INT R, N, LEN, ALT_NUM;
  UCHAR *START, *END, *P;
  NODE *TOP_ROOT, *ROOT, *SNODE, *PREV_NODE;
  ONIGCASEFOLDCODEITEM ITEMS[ONIGENC_GET_CASE_FOLD_CODES_MAX_NUM];
  STRNODE* SN = STR_(NODE);

  IF (NODE_STRING_IS_AMBIG(NODE)) RETURN 0;

  START = SN->S;
  END   = SN->END;
  IF (START >= END) RETURN 0;

  R = 0;
  TOP_ROOT = ROOT = PREV_NODE = SNODE = NULL_NODE;
  ALT_NUM = 1;
  P = START;
  WHILE (P < END) {
    N = ONIGENC_GET_CASE_FOLD_CODES_BY_STR(REG->ENC, REG->CASE_FOLD_FLAG, P, END,
                                           ITEMS);
    IF (N < 0) {
      R = N;
      GOTO ERR;
    }

    LEN = ENCLEN(REG->ENC, P);

    IF (N == 0) {
      IF (IS_NULL(SNODE)) {
        IF (IS_NULL(ROOT) && IS_NOT_NULL(PREV_NODE)) {
          TOP_ROOT = ROOT = ONIG_NODE_LIST_ADD(NULL_NODE, PREV_NODE);
          IF (IS_NULL(ROOT)) {
            ONIG_NODE_FREE(PREV_NODE);
            GOTO MEM_ERR;
          }
        }

        PREV_NODE = SNODE = ONIG_NODE_NEW_STR(NULL, NULL);
        IF (IS_NULL(SNODE)) GOTO MEM_ERR;
        IF (IS_NOT_NULL(ROOT)) {
          IF (IS_NULL(ONIG_NODE_LIST_ADD(ROOT, SNODE))) {
            ONIG_NODE_FREE(SNODE);
            GOTO MEM_ERR;
          }
        }
      }

      R = ONIG_NODE_STR_CAT(SNODE, P, P + LEN);
      IF (R != 0) GOTO ERR;
    }
    ELSE {
      ALT_NUM *= (N + 1);
      IF (ALT_NUM > THRESHOLD_CASE_FOLD_ALT_FOR_EXPANSION) BREAK;

      IF (IS_NULL(ROOT) && IS_NOT_NULL(PREV_NODE)) {
        TOP_ROOT = ROOT = ONIG_NODE_LIST_ADD(NULL_NODE, PREV_NODE);
        IF (IS_NULL(ROOT)) {
          ONIG_NODE_FREE(PREV_NODE);
          GOTO MEM_ERR;
        }
      }

      R = EXPAND_CASE_FOLD_STRING_ALT(N, ITEMS, P, LEN, END, REG, &PREV_NODE);
      IF (R < 0) GOTO MEM_ERR;
      IF (R == 1) {
        IF (IS_NULL(ROOT)) {
          TOP_ROOT = PREV_NODE;
        }
        ELSE {
          IF (IS_NULL(ONIG_NODE_LIST_ADD(ROOT, PREV_NODE))) {
            ONIG_NODE_FREE(PREV_NODE);
            GOTO MEM_ERR;
          }
        }

        ROOT = NODE_CAR(PREV_NODE);
      }
      ELSE { /* R == 0 */
        IF (IS_NOT_NULL(ROOT)) {
          IF (IS_NULL(ONIG_NODE_LIST_ADD(ROOT, PREV_NODE))) {
            ONIG_NODE_FREE(PREV_NODE);
            GOTO MEM_ERR;
          }
        }
      }

      SNODE = NULL_NODE;
    }

    P += LEN;
  }

  IF (P < END) {
    NODE *SREM;

    R = EXPAND_CASE_FOLD_MAKE_REM_STRING(&SREM, P, END, REG);
    IF (R != 0) GOTO MEM_ERR;

    IF (IS_NOT_NULL(PREV_NODE) && IS_NULL(ROOT)) {
      TOP_ROOT = ROOT = ONIG_NODE_LIST_ADD(NULL_NODE, PREV_NODE);
      IF (IS_NULL(ROOT)) {
        ONIG_NODE_FREE(SREM);
        ONIG_NODE_FREE(PREV_NODE);
        GOTO MEM_ERR;
      }
    }

    IF (IS_NULL(ROOT)) {
      PREV_NODE = SREM;
    }
    ELSE {
      IF (IS_NULL(ONIG_NODE_LIST_ADD(ROOT, SREM))) {
        ONIG_NODE_FREE(SREM);
        GOTO MEM_ERR;
      }
    }
  }

  /* ENDING */
  TOP_ROOT = (IS_NOT_NULL(TOP_ROOT) ? TOP_ROOT : PREV_NODE);
  SWAP_NODE(NODE, TOP_ROOT);
  ONIG_NODE_FREE(TOP_ROOT);
  RETURN 0;

 MEM_ERR:
  R = ONIGERR_MEMORY;

 ERR:
  ONIG_NODE_FREE(TOP_ROOT);
  RETURN R;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 264695_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LEXER_CONVERT_IDENT_TO_CESU8 (UINT8_T *DESTINATION_P, /**< DESTINATION STRING */
                              CONST UINT8_T *SOURCE_P, /**< SOURCE STRING */
                              PROP_LENGTH_T LENGTH) /**< LENGTH OF DESTINATION STRING */
{
  CONST UINT8_T *DESTINATION_END_P = DESTINATION_P + LENGTH;

  JERRY_ASSERT (LENGTH <= PARSER_MAXIMUM_IDENT_LENGTH);

  DO
  {
    IF (*SOURCE_P == LIT_CHAR_BACKSLASH)
    {
      SOURCE_P += 2;
      DESTINATION_P += LIT_CODE_POINT_TO_CESU8_BYTES (DESTINATION_P, LEXER_UNCHECKED_HEX_TO_CHARACTER (&SOURCE_P));
      CONTINUE;
    }

#IF JERRY_ESNEXT
    IF (*SOURCE_P >= LIT_UTF8_4_BYTE_MARKER)
    {
      LIT_FOUR_BYTE_UTF8_CHAR_TO_CESU8 (DESTINATION_P, SOURCE_P);

      DESTINATION_P += 6;
      SOURCE_P += 4;
      CONTINUE;
    }
#ENDIF /* JERRY_ESNEXT */

    *DESTINATION_P++ = *SOURCE_P++;
  } WHILE (DESTINATION_P < DESTINATION_END_P);
} /* LEXER_CONVERT_IDENT_TO_CESU8 */
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205838_CWE-122.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_ONE_SOURCELINE(SOURCE_COOKIE_T *SP)
{
    GARRAY_T		GA;
    INT			LEN;
    INT			C;
    CHAR_U		*BUF;
#IFDEF USE_CRNL
    INT			HAS_CR;		// CR-LF FOUND
#ENDIF
    INT			HAVE_READ = FALSE;

    // USE A GROWARRAY TO STORE THE SOURCED LINE
    GA_INIT2(&GA, 1, 250);

    // LOOP UNTIL THERE IS A FINISHED LINE (OR END-OF-FILE).
    ++SP->SOURCING_LNUM;
    FOR (;;)
    {
	// MAKE ROOM TO READ AT LEAST 120 (MORE) CHARACTERS
	IF (GA_GROW(&GA, 120) == FAIL)
	    BREAK;
	IF (SP->SOURCE_FROM_BUF)
	{
	    IF (SP->BUF_LNUM >= SP->BUFLINES.GA_LEN)
		BREAK;		    // ALL THE LINES ARE PROCESSED
	    GA_CONCAT(&GA, ((CHAR_U **)SP->BUFLINES.GA_DATA)[SP->BUF_LNUM]);
	    SP->BUF_LNUM++;
	    BUF = (CHAR_U *)GA.GA_DATA;
	}
	ELSE
	{
	    BUF = (CHAR_U *)GA.GA_DATA;
	    IF (FGETS((CHAR *)BUF + GA.GA_LEN, GA.GA_MAXLEN - GA.GA_LEN,
			SP->FP) == NULL)
		BREAK;
	}
	LEN = GA.GA_LEN + (INT)STRLEN(BUF + GA.GA_LEN);
#IFDEF USE_CRNL
	// IGNORE A TRAILING CTRL-Z, WHEN IN DOS MODE.	ONLY RECOGNIZE THE
	// CTRL-Z BY ITS OWN, OR AFTER A NL.
	IF (	   (LEN == 1 || (LEN >= 2 && BUF[LEN - 2] == '\N'))
		&& SP->FILEFORMAT == EOL_DOS
		&& BUF[LEN - 1] == CTRL_Z)
	{
	    BUF[LEN - 1] = NUL;
	    BREAK;
	}
#ENDIF

	HAVE_READ = TRUE;
	GA.GA_LEN = LEN;

	// IF THE LINE WAS LONGER THAN THE BUFFER, READ MORE.
	IF (GA.GA_MAXLEN - GA.GA_LEN == 1 && BUF[LEN - 1] != '\N')
	    CONTINUE;

	IF (LEN >= 1 && BUF[LEN - 1] == '\N')	// REMOVE TRAILING NL
	{
#IFDEF USE_CRNL
	    HAS_CR = (LEN >= 2 && BUF[LEN - 2] == '\R');
	    IF (SP->FILEFORMAT == EOL_UNKNOWN)
	    {
		IF (HAS_CR)
		    SP->FILEFORMAT = EOL_DOS;
		ELSE
		    SP->FILEFORMAT = EOL_UNIX;
	    }

	    IF (SP->FILEFORMAT == EOL_DOS)
	    {
		IF (HAS_CR)	    // REPLACE TRAILING CR
		{
		    BUF[LEN - 2] = '\N';
		    --LEN;
		    --GA.GA_LEN;
		}
		ELSE	    // LINES LIKE ":MAP XX YY^M" WILL HAVE FAILED
		{
		    IF (!SP->ERROR)
		    {
			MSG_SOURCE(HL_ATTR(HLF_W));
			EMSG(_("W15: WARNING: WRONG LINE SEPARATOR, ^M MAY BE MISSING"));
		    }
		    SP->ERROR = TRUE;
		    SP->FILEFORMAT = EOL_UNIX;
		}
	    }
#ENDIF
	    // THE '\N' IS ESCAPED IF THERE IS AN ODD NUMBER OF ^V'S JUST
	    // BEFORE IT, FIRST SET "C" JUST BEFORE THE 'V'S AND THEN CHECK
	    // LEN&C PARITIES (IS FASTER THAN ((LEN-C)%2 == 0)) -- ACEVEDO
	    FOR (C = LEN - 2; C >= 0 && BUF[C] == CTRL_V; C--)
		;
	    IF ((LEN & 1) != (C & 1))	// ESCAPED NL, READ MORE
	    {
		++SP->SOURCING_LNUM;
		CONTINUE;
	    }

	    BUF[LEN - 1] = NUL;		// REMOVE THE NL
	}

	// CHECK FOR ^C HERE NOW AND THEN, SO RECURSIVE :SO CAN BE BROKEN.
	LINE_BREAKCHECK();
	BREAK;
    }

    IF (HAVE_READ)
	RETURN (CHAR_U *)GA.GA_DATA;

    VIM_FREE(GA.GA_DATA);
    RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 487624_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ASMLINKAGE LONG SYS_SETHOSTNAME(CHAR __USER *NAME, INT LEN)
{
	INT ERRNO;
	CHAR TMP[__NEW_UTS_LEN];

	IF (!CAPABLE(CAP_SYS_ADMIN))
		RETURN -EPERM;
	IF (LEN < 0 || LEN > __NEW_UTS_LEN)
		RETURN -EINVAL;
	DOWN_WRITE(&UTS_SEM);
	ERRNO = -EFAULT;
	IF (!COPY_FROM_USER(TMP, NAME, LEN)) {
		MEMCPY(UTSNAME()->NODENAME, TMP, LEN);
		UTSNAME()->NODENAME[LEN] = 0;
		ERRNO = 0;
	}
	UP_WRITE(&UTS_SEM);
	RETURN ERRNO;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 333514_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDIMAGEPTR GDIMAGEROTATEBILINEAR(GDIMAGEPTR SRC, CONST FLOAT DEGREES, CONST INT BGCOLOR)
{
	FLOAT _ANGLE = (FLOAT)((- DEGREES / 180.0F) * M_PI);
	CONST UNSIGNED INT SRC_W = GDIMAGESX(SRC);
	CONST UNSIGNED INT SRC_H = GDIMAGESY(SRC);
	UNSIGNED INT NEW_WIDTH = ABS((INT)(SRC_W*COS(_ANGLE))) + ABS((INT)(SRC_H*SIN(_ANGLE) + 0.5F));
	UNSIGNED INT NEW_HEIGHT = ABS((INT)(SRC_W*SIN(_ANGLE))) + ABS((INT)(SRC_H*COS(_ANGLE) + 0.5F));
	CONST GDFIXED F_0_5 = GD_FTOFX(0.5F);
	CONST GDFIXED F_H = GD_ITOFX(SRC_H/2);
	CONST GDFIXED F_W = GD_ITOFX(SRC_W/2);
	CONST GDFIXED F_COS = GD_FTOFX(COS(-_ANGLE));
	CONST GDFIXED F_SIN = GD_FTOFX(SIN(-_ANGLE));
	CONST GDFIXED F_1 = GD_ITOFX(1);
	UNSIGNED INT I;
	UNSIGNED INT DST_OFFSET_X;
	UNSIGNED INT DST_OFFSET_Y = 0;
	UNSIGNED INT SRC_OFFSET_X, SRC_OFFSET_Y;
	GDIMAGEPTR DST;

	DST = GDIMAGECREATETRUECOLOR(NEW_WIDTH, NEW_HEIGHT);
	IF (DST == NULL) {
		RETURN NULL;
	}
	DST->SAVEALPHAFLAG = 1;

	FOR (I = 0; I < NEW_HEIGHT; I++) {
		UNSIGNED INT J;
		DST_OFFSET_X = 0;

		FOR (J=0; J < NEW_WIDTH; J++) {
			CONST GDFIXED F_I = GD_ITOFX((INT)I - (INT)NEW_HEIGHT/2);
			CONST GDFIXED F_J = GD_ITOFX((INT)J - (INT)NEW_WIDTH/2);
			CONST GDFIXED F_M = GD_MULFX(F_J,F_SIN) + GD_MULFX(F_I,F_COS) + F_0_5 + F_H;
			CONST GDFIXED F_N = GD_MULFX(F_J,F_COS) - GD_MULFX(F_I,F_SIN) + F_0_5 + F_W;
			CONST UNSIGNED INT M = GD_FXTOI(F_M);
			CONST UNSIGNED INT N = GD_FXTOI(F_N);

			IF ((M > 0) && (M < SRC_H - 1) && (N > 0) && (N < SRC_W - 1)) {
				CONST GDFIXED F_F = F_M - GD_ITOFX(M);
				CONST GDFIXED F_G = F_N - GD_ITOFX(N);
				CONST GDFIXED F_W1 = GD_MULFX(F_1-F_F, F_1-F_G);
				CONST GDFIXED F_W2 = GD_MULFX(F_1-F_F, F_G);
				CONST GDFIXED F_W3 = GD_MULFX(F_F, F_1-F_G);
				CONST GDFIXED F_W4 = GD_MULFX(F_F, F_G);

				IF (N < SRC_W - 1) {
					SRC_OFFSET_X = N + 1;
					SRC_OFFSET_Y = M;
				}

				IF (M < SRC_H-1) {
					SRC_OFFSET_X = N;
					SRC_OFFSET_Y = M + 1;
				}

				IF (!((N >= SRC_W-1) || (M >= SRC_H-1))) {
					SRC_OFFSET_X = N + 1;
					SRC_OFFSET_Y = M + 1;
				}
				{
					CONST INT PIXEL1 = SRC->TPIXELS[SRC_OFFSET_Y][SRC_OFFSET_X];
					REGISTER INT PIXEL2, PIXEL3, PIXEL4;

					IF (SRC_OFFSET_Y + 1 >= SRC_H) {
						PIXEL2 = BGCOLOR;
						PIXEL3 = BGCOLOR;
						PIXEL4 = BGCOLOR;
					} ELSE IF (SRC_OFFSET_X + 1 >= SRC_W) {
						PIXEL2 = BGCOLOR;
						PIXEL3 = BGCOLOR;
						PIXEL4 = BGCOLOR;
					} ELSE {
					    PIXEL2 = SRC->TPIXELS[SRC_OFFSET_Y][SRC_OFFSET_X + 1];
						PIXEL3 = SRC->TPIXELS[SRC_OFFSET_Y + 1][SRC_OFFSET_X];
						PIXEL4 = SRC->TPIXELS[SRC_OFFSET_Y + 1][SRC_OFFSET_X + 1];
					}
					{
						CONST GDFIXED F_R1 = GD_ITOFX(GDTRUECOLORGETRED(PIXEL1));
						CONST GDFIXED F_R2 = GD_ITOFX(GDTRUECOLORGETRED(PIXEL2));
						CONST GDFIXED F_R3 = GD_ITOFX(GDTRUECOLORGETRED(PIXEL3));
						CONST GDFIXED F_R4 = GD_ITOFX(GDTRUECOLORGETRED(PIXEL4));
						CONST GDFIXED F_G1 = GD_ITOFX(GDTRUECOLORGETGREEN(PIXEL1));
						CONST GDFIXED F_G2 = GD_ITOFX(GDTRUECOLORGETGREEN(PIXEL2));
						CONST GDFIXED F_G3 = GD_ITOFX(GDTRUECOLORGETGREEN(PIXEL3));
						CONST GDFIXED F_G4 = GD_ITOFX(GDTRUECOLORGETGREEN(PIXEL4));
						CONST GDFIXED F_B1 = GD_ITOFX(GDTRUECOLORGETBLUE(PIXEL1));
						CONST GDFIXED F_B2 = GD_ITOFX(GDTRUECOLORGETBLUE(PIXEL2));
						CONST GDFIXED F_B3 = GD_ITOFX(GDTRUECOLORGETBLUE(PIXEL3));
						CONST GDFIXED F_B4 = GD_ITOFX(GDTRUECOLORGETBLUE(PIXEL4));
						CONST GDFIXED F_A1 = GD_ITOFX(GDTRUECOLORGETALPHA(PIXEL1));
						CONST GDFIXED F_A2 = GD_ITOFX(GDTRUECOLORGETALPHA(PIXEL2));
						CONST GDFIXED F_A3 = GD_ITOFX(GDTRUECOLORGETALPHA(PIXEL3));
						CONST GDFIXED F_A4 = GD_ITOFX(GDTRUECOLORGETALPHA(PIXEL4));
						CONST GDFIXED F_RED = GD_MULFX(F_W1, F_R1) + GD_MULFX(F_W2, F_R2) + GD_MULFX(F_W3, F_R3) + GD_MULFX(F_W4, F_R4);
						CONST GDFIXED F_GREEN = GD_MULFX(F_W1, F_G1) + GD_MULFX(F_W2, F_G2) + GD_MULFX(F_W3, F_G3) + GD_MULFX(F_W4, F_G4);
						CONST GDFIXED F_BLUE = GD_MULFX(F_W1, F_B1) + GD_MULFX(F_W2, F_B2) + GD_MULFX(F_W3, F_B3) + GD_MULFX(F_W4, F_B4);
						CONST GDFIXED F_ALPHA = GD_MULFX(F_W1, F_A1) + GD_MULFX(F_W2, F_A2) + GD_MULFX(F_W3, F_A3) + GD_MULFX(F_W4, F_A4);

						CONST UNSIGNED CHAR RED   = (UNSIGNED CHAR) CLAMP(GD_FXTOI(F_RED),   0, 255);
						CONST UNSIGNED CHAR GREEN = (UNSIGNED CHAR) CLAMP(GD_FXTOI(F_GREEN), 0, 255);
						CONST UNSIGNED CHAR BLUE  = (UNSIGNED CHAR) CLAMP(GD_FXTOI(F_BLUE),  0, 255);
						CONST UNSIGNED CHAR ALPHA = (UNSIGNED CHAR) CLAMP(GD_FXTOI(F_ALPHA), 0, 127);

						DST->TPIXELS[DST_OFFSET_Y][DST_OFFSET_X++] = GDTRUECOLORALPHA(RED, GREEN, BLUE, ALPHA);
					}
				}
			} ELSE {
				DST->TPIXELS[DST_OFFSET_Y][DST_OFFSET_X++] = BGCOLOR;
			}
		}
		DST_OFFSET_Y++;
	}
	RETURN DST;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 346419_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_SOURCED_LNUM(
	CHAR_U *(*FGETLINE)(INT, VOID *, INT, GETLINE_OPT_T),
	VOID *COOKIE)
{
    RETURN FGETLINE == GETSOURCELINE
			? ((SOURCE_COOKIE_T *)COOKIE)->SOURCING_LNUM
			: SOURCING_LNUM;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209049_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
XMLPARSESTARTTAG2(XMLPARSERCTXTPTR CTXT, CONST XMLCHAR **PREF,
                  CONST XMLCHAR **URI, INT *TLEN) {
    CONST XMLCHAR *LOCALNAME;
    CONST XMLCHAR *PREFIX;
    CONST XMLCHAR *ATTNAME;
    CONST XMLCHAR *APREFIX;
    CONST XMLCHAR *NSNAME;
    XMLCHAR *ATTVALUE;
    CONST XMLCHAR **ATTS = CTXT->ATTS;
    INT MAXATTS = CTXT->MAXATTS;
    INT NRATTS, NBATTS, NBDEF;
    INT I, J, NBNS, ATTVAL, OLDLINE, OLDCOL;
    CONST XMLCHAR *BASE;
    UNSIGNED LONG CUR;
    INT NSNR = CTXT->NSNR;

    IF (RAW != '<') RETURN(NULL);
    NEXT1;

    /*
     * NOTE: IT IS CRUCIAL WITH THE SAX2 API TO NEVER CALL SHRINK BEYOND THAT
     *       POINT SINCE THE ATTRIBUTE VALUES MAY BE STORED AS POINTERS TO
     *       THE BUFFER AND CALLING SHRINK WOULD DESTROY THEM !
     *       THE SHRINKING IS ONLY POSSIBLE ONCE THE FULL SET OF ATTRIBUTE
     *       CALLBACKS HAVE BEEN DONE.
     */
REPARSE:
    SHRINK;
    BASE = CTXT->INPUT->BASE;
    CUR = CTXT->INPUT->CUR - CTXT->INPUT->BASE;
    OLDLINE = CTXT->INPUT->LINE;
    OLDCOL = CTXT->INPUT->COL;
    NBATTS = 0;
    NRATTS = 0;
    NBDEF = 0;
    NBNS = 0;
    ATTVAL = 0;
    /* FORGET ANY NAMESPACES ADDED DURING AN EARLIER PARSE OF THIS ELEMENT. */
    CTXT->NSNR = NSNR;

    LOCALNAME = XMLPARSEQNAME(CTXT, &PREFIX);
    IF (LOCALNAME == NULL) {
	XMLFATALERRMSG(CTXT, XML_ERR_NAME_REQUIRED,
		       "STARTTAG: INVALID ELEMENT NAME\N");
        RETURN(NULL);
    }
    *TLEN = CTXT->INPUT->CUR - CTXT->INPUT->BASE - CUR;

    /*
     * NOW PARSE THE ATTRIBUTES, IT ENDS UP WITH THE ENDING
     *
     * (S ATTRIBUTE)* S?
     */
    SKIP_BLANKS;
    GROW;
    IF (CTXT->INPUT->BASE != BASE) GOTO BASE_CHANGED;

    WHILE (((RAW != '>') &&
	   ((RAW != '/') || (NXT(1) != '>')) &&
	   (IS_BYTE_CHAR(RAW))) && (CTXT->INSTATE != XML_PARSER_EOF)) {
	CONST XMLCHAR *Q = CUR_PTR;
	UNSIGNED INT CONS = CTXT->INPUT->CONSUMED;
	INT LEN = -1, ALLOC = 0;

	ATTNAME = XMLPARSEATTRIBUTE2(CTXT, PREFIX, LOCALNAME,
	                             &APREFIX, &ATTVALUE, &LEN, &ALLOC);
	IF (CTXT->INPUT->BASE != BASE) {
	    IF ((ATTVALUE != NULL) && (ALLOC != 0))
	        XMLFREE(ATTVALUE);
	    ATTVALUE = NULL;
	    GOTO BASE_CHANGED;
	}
        IF ((ATTNAME != NULL) && (ATTVALUE != NULL)) {
	    IF (LEN < 0) LEN = XMLSTRLEN(ATTVALUE);
            IF ((ATTNAME == CTXT->STR_XMLNS) && (APREFIX == NULL)) {
	        CONST XMLCHAR *URL = XMLDICTLOOKUP(CTXT->DICT, ATTVALUE, LEN);
		XMLURIPTR URI;

                IF (URL == NULL) {
		    XMLERRMEMORY(CTXT, "DICTIONARY ALLOCATION FAILURE");
		    IF ((ATTVALUE != NULL) && (ALLOC != 0))
			XMLFREE(ATTVALUE);
		    RETURN(NULL);
		}
                IF (*URL != 0) {
		    URI = XMLPARSEURI((CONST CHAR *) URL);
		    IF (URI == NULL) {
			XMLNSERR(CTXT, XML_WAR_NS_URI,
			         "XMLNS: '%S' IS NOT A VALID URI\N",
					   URL, NULL, NULL);
		    } ELSE {
			IF (URI->SCHEME == NULL) {
			    XMLNSWARN(CTXT, XML_WAR_NS_URI_RELATIVE,
				      "XMLNS: URI %S IS NOT ABSOLUTE\N",
				      URL, NULL, NULL);
			}
			XMLFREEURI(URI);
		    }
		    IF (URL == CTXT->STR_XML_NS) {
			IF (ATTNAME != CTXT->STR_XML) {
			    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			 "XML NAMESPACE URI CANNOT BE THE DEFAULT NAMESPACE\N",
				     NULL, NULL, NULL);
			}
			GOTO SKIP_DEFAULT_NS;
		    }
		    IF ((LEN == 29) &&
			(XMLSTREQUAL(URL,
				 BAD_CAST "HTTP://WWW.W3.ORG/2000/XMLNS/"))) {
			XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			     "REUSE OF THE XMLNS NAMESPACE NAME IS FORBIDDEN\N",
				 NULL, NULL, NULL);
			GOTO SKIP_DEFAULT_NS;
		    }
		}
		/*
		 * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		 */
		FOR (J = 1;J <= NBNS;J++)
		    IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == NULL)
			BREAK;
		IF (J <= NBNS)
		    XMLERRATTRIBUTEDUP(CTXT, NULL, ATTNAME);
		ELSE
		    IF (NSPUSH(CTXT, NULL, URL) > 0) NBNS++;
SKIP_DEFAULT_NS:
		IF (ALLOC != 0) XMLFREE(ATTVALUE);
		IF ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
		    BREAK;
		IF (!IS_BLANK_CH(RAW)) {
		    XMLFATALERRMSG(CTXT, XML_ERR_SPACE_REQUIRED,
				   "ATTRIBUTES CONSTRUCT ERROR\N");
		    BREAK;
		}
		SKIP_BLANKS;
		CONTINUE;
	    }
            IF (APREFIX == CTXT->STR_XMLNS) {
	        CONST XMLCHAR *URL = XMLDICTLOOKUP(CTXT->DICT, ATTVALUE, LEN);
		XMLURIPTR URI;

                IF (ATTNAME == CTXT->STR_XML) {
		    IF (URL != CTXT->STR_XML_NS) {
		        XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			         "XML NAMESPACE PREFIX MAPPED TO WRONG URI\N",
			         NULL, NULL, NULL);
		    }
		    /*
		     * DO NOT KEEP A NAMESPACE DEFINITION NODE
		     */
		    GOTO SKIP_NS;
		}
                IF (URL == CTXT->STR_XML_NS) {
		    IF (ATTNAME != CTXT->STR_XML) {
		        XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			         "XML NAMESPACE URI MAPPED TO WRONG PREFIX\N",
			         NULL, NULL, NULL);
		    }
		    GOTO SKIP_NS;
		}
                IF (ATTNAME == CTXT->STR_XMLNS) {
		    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			     "REDEFINITION OF THE XMLNS PREFIX IS FORBIDDEN\N",
			     NULL, NULL, NULL);
		    GOTO SKIP_NS;
		}
		IF ((LEN == 29) &&
		    (XMLSTREQUAL(URL,
		                 BAD_CAST "HTTP://WWW.W3.ORG/2000/XMLNS/"))) {
		    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			     "REUSE OF THE XMLNS NAMESPACE NAME IS FORBIDDEN\N",
			     NULL, NULL, NULL);
		    GOTO SKIP_NS;
		}
		IF ((URL == NULL) || (URL[0] == 0)) {
		    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
		             "XMLNS:%S: EMPTY XML NAMESPACE IS NOT ALLOWED\N",
			          ATTNAME, NULL, NULL);
		    GOTO SKIP_NS;
		} ELSE {
		    URI = XMLPARSEURI((CONST CHAR *) URL);
		    IF (URI == NULL) {
			XMLNSERR(CTXT, XML_WAR_NS_URI,
			     "XMLNS:%S: '%S' IS NOT A VALID URI\N",
					   ATTNAME, URL, NULL);
		    } ELSE {
			IF ((CTXT->PEDANTIC) && (URI->SCHEME == NULL)) {
			    XMLNSWARN(CTXT, XML_WAR_NS_URI_RELATIVE,
				      "XMLNS:%S: URI %S IS NOT ABSOLUTE\N",
				      ATTNAME, URL, NULL);
			}
			XMLFREEURI(URI);
		    }
		}

		/*
		 * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		 */
		FOR (J = 1;J <= NBNS;J++)
		    IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == ATTNAME)
			BREAK;
		IF (J <= NBNS)
		    XMLERRATTRIBUTEDUP(CTXT, APREFIX, ATTNAME);
		ELSE
		    IF (NSPUSH(CTXT, ATTNAME, URL) > 0) NBNS++;
SKIP_NS:
		IF (ALLOC != 0) XMLFREE(ATTVALUE);
		IF ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
		    BREAK;
		IF (!IS_BLANK_CH(RAW)) {
		    XMLFATALERRMSG(CTXT, XML_ERR_SPACE_REQUIRED,
				   "ATTRIBUTES CONSTRUCT ERROR\N");
		    BREAK;
		}
		SKIP_BLANKS;
		IF (CTXT->INPUT->BASE != BASE) GOTO BASE_CHANGED;
		CONTINUE;
	    }

	    /*
	     * ADD THE PAIR TO ATTS
	     */
	    IF ((ATTS == NULL) || (NBATTS + 5 > MAXATTS)) {
	        IF (XMLCTXTGROWATTRS(CTXT, NBATTS + 5) < 0) {
		    IF (ATTVALUE[LEN] == 0)
			XMLFREE(ATTVALUE);
		    GOTO FAILED;
		}
	        MAXATTS = CTXT->MAXATTS;
		ATTS = CTXT->ATTS;
	    }
	    CTXT->ATTALLOCS[NRATTS++] = ALLOC;
	    ATTS[NBATTS++] = ATTNAME;
	    ATTS[NBATTS++] = APREFIX;
	    ATTS[NBATTS++] = NULL; /* THE URI WILL BE FETCHED LATER */
	    ATTS[NBATTS++] = ATTVALUE;
	    ATTVALUE += LEN;
	    ATTS[NBATTS++] = ATTVALUE;
	    /*
	     * TAG IF SOME DEALLOCATION IS NEEDED
	     */
	    IF (ALLOC != 0) ATTVAL = 1;
	} ELSE {
	    IF ((ATTVALUE != NULL) && (ATTVALUE[LEN] == 0))
		XMLFREE(ATTVALUE);
	}

FAILED:

	GROW
        IF (CTXT->INSTATE == XML_PARSER_EOF)
            BREAK;
	IF (CTXT->INPUT->BASE != BASE) GOTO BASE_CHANGED;
	IF ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
	    BREAK;
	IF (!IS_BLANK_CH(RAW)) {
	    XMLFATALERRMSG(CTXT, XML_ERR_SPACE_REQUIRED,
			   "ATTRIBUTES CONSTRUCT ERROR\N");
	    BREAK;
	}
	SKIP_BLANKS;
        IF ((CONS == CTXT->INPUT->CONSUMED) && (Q == CUR_PTR) &&
            (ATTNAME == NULL) && (ATTVALUE == NULL)) {
	    XMLFATALERR(CTXT, XML_ERR_INTERNAL_ERROR,
	         "XMLPARSESTARTTAG: PROBLEM PARSING ATTRIBUTES\N");
	    BREAK;
	}
        GROW;
	IF (CTXT->INPUT->BASE != BASE) GOTO BASE_CHANGED;
    }

    /*
     * THE ATTRIBUTES DEFAULTING
     */
    IF (CTXT->ATTSDEFAULT != NULL) {
        XMLDEFATTRSPTR DEFAULTS;

	DEFAULTS = XMLHASHLOOKUP2(CTXT->ATTSDEFAULT, LOCALNAME, PREFIX);
	IF (DEFAULTS != NULL) {
	    FOR (I = 0;I < DEFAULTS->NBATTRS;I++) {
	        ATTNAME = DEFAULTS->VALUES[5 * I];
		APREFIX = DEFAULTS->VALUES[5 * I + 1];

                /*
		 * SPECIAL WORK FOR NAMESPACES DEFAULTED DEFS
		 */
		IF ((ATTNAME == CTXT->STR_XMLNS) && (APREFIX == NULL)) {
		    /*
		     * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		     */
		    FOR (J = 1;J <= NBNS;J++)
		        IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == NULL)
			    BREAK;
	            IF (J <= NBNS) CONTINUE;

		    NSNAME = XMLGETNAMESPACE(CTXT, NULL);
		    IF (NSNAME != DEFAULTS->VALUES[5 * I + 2]) {
			IF (NSPUSH(CTXT, NULL,
			           DEFAULTS->VALUES[5 * I + 2]) > 0)
			    NBNS++;
		    }
		} ELSE IF (APREFIX == CTXT->STR_XMLNS) {
		    /*
		     * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		     */
		    FOR (J = 1;J <= NBNS;J++)
		        IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == ATTNAME)
			    BREAK;
	            IF (J <= NBNS) CONTINUE;

		    NSNAME = XMLGETNAMESPACE(CTXT, ATTNAME);
		    IF (NSNAME != DEFAULTS->VALUES[2]) {
			IF (NSPUSH(CTXT, ATTNAME,
			           DEFAULTS->VALUES[5 * I + 2]) > 0)
			    NBNS++;
		    }
		} ELSE {
		    /*
		     * CHECK THAT IT'S NOT A DEFINED ATTRIBUTE
		     */
		    FOR (J = 0;J < NBATTS;J+=5) {
			IF ((ATTNAME == ATTS[J]) && (APREFIX == ATTS[J+1]))
			    BREAK;
		    }
		    IF (J < NBATTS) CONTINUE;

		    IF ((ATTS == NULL) || (NBATTS + 5 > MAXATTS)) {
			IF (XMLCTXTGROWATTRS(CTXT, NBATTS + 5) < 0) {
			    RETURN(NULL);
			}
			MAXATTS = CTXT->MAXATTS;
			ATTS = CTXT->ATTS;
		    }
		    ATTS[NBATTS++] = ATTNAME;
		    ATTS[NBATTS++] = APREFIX;
		    IF (APREFIX == NULL)
			ATTS[NBATTS++] = NULL;
		    ELSE
		        ATTS[NBATTS++] = XMLGETNAMESPACE(CTXT, APREFIX);
		    ATTS[NBATTS++] = DEFAULTS->VALUES[5 * I + 2];
		    ATTS[NBATTS++] = DEFAULTS->VALUES[5 * I + 3];
		    IF ((CTXT->STANDALONE == 1) &&
		        (DEFAULTS->VALUES[5 * I + 4] != NULL)) {
			XMLVALIDITYERROR(CTXT, XML_DTD_STANDALONE_DEFAULTED,
	  "STANDALONE: ATTRIBUTE %S ON %S DEFAULTED FROM EXTERNAL SUBSET\N",
	                                 ATTNAME, LOCALNAME);
		    }
		    NBDEF++;
		}
	    }
	}
    }

    /*
     * THE ATTRIBUTES CHECKINGS
     */
    FOR (I = 0; I < NBATTS;I += 5) {
        /*
	* THE DEFAULT NAMESPACE DOES NOT APPLY TO ATTRIBUTE NAMES.
	*/
	IF (ATTS[I + 1] != NULL) {
	    NSNAME = XMLGETNAMESPACE(CTXT, ATTS[I + 1]);
	    IF (NSNAME == NULL) {
		XMLNSERR(CTXT, XML_NS_ERR_UNDEFINED_NAMESPACE,
		    "NAMESPACE PREFIX %S FOR %S ON %S IS NOT DEFINED\N",
		    ATTS[I + 1], ATTS[I], LOCALNAME);
	    }
	    ATTS[I + 2] = NSNAME;
	} ELSE
	    NSNAME = NULL;
	/*
	 * [ WFC: UNIQUE ATT SPEC ]
	 * NO ATTRIBUTE NAME MAY APPEAR MORE THAN ONCE IN THE SAME
	 * START-TAG OR EMPTY-ELEMENT TAG.
	 * AS EXTENDED BY THE NAMESPACE IN XML REC.
	 */
        FOR (J = 0; J < I;J += 5) {
	    IF (ATTS[I] == ATTS[J]) {
	        IF (ATTS[I+1] == ATTS[J+1]) {
		    XMLERRATTRIBUTEDUP(CTXT, ATTS[I+1], ATTS[I]);
		    BREAK;
		}
		IF ((NSNAME != NULL) && (ATTS[J + 2] == NSNAME)) {
		    XMLNSERR(CTXT, XML_NS_ERR_ATTRIBUTE_REDEFINED,
			     "NAMESPACED ATTRIBUTE %S IN '%S' REDEFINED\N",
			     ATTS[I], NSNAME, NULL);
		    BREAK;
		}
	    }
	}
    }

    NSNAME = XMLGETNAMESPACE(CTXT, PREFIX);
    IF ((PREFIX != NULL) && (NSNAME == NULL)) {
	XMLNSERR(CTXT, XML_NS_ERR_UNDEFINED_NAMESPACE,
	         "NAMESPACE PREFIX %S ON %S IS NOT DEFINED\N",
		 PREFIX, LOCALNAME, NULL);
    }
    *PREF = PREFIX;
    *URI = NSNAME;

    /*
     * SAX: START OF ELEMENT !
     */
    IF ((CTXT->SAX != NULL) && (CTXT->SAX->STARTELEMENTNS != NULL) &&
	(!CTXT->DISABLESAX)) {
	IF (NBNS > 0)
	    CTXT->SAX->STARTELEMENTNS(CTXT->USERDATA, LOCALNAME, PREFIX,
			  NSNAME, NBNS, &CTXT->NSTAB[CTXT->NSNR - 2 * NBNS],
			  NBATTS / 5, NBDEF, ATTS);
	ELSE
	    CTXT->SAX->STARTELEMENTNS(CTXT->USERDATA, LOCALNAME, PREFIX,
	                  NSNAME, 0, NULL, NBATTS / 5, NBDEF, ATTS);
    }

    /*
     * FREE UP ATTRIBUTE ALLOCATED STRINGS IF NEEDED
     */
    IF (ATTVAL != 0) {
	FOR (I = 3,J = 0; J < NRATTS;I += 5,J++)
	    IF ((CTXT->ATTALLOCS[J] != 0) && (ATTS[I] != NULL))
	        XMLFREE((XMLCHAR *) ATTS[I]);
    }

    RETURN(LOCALNAME);

BASE_CHANGED:
    /*
     * THE ATTRIBUTE STRINGS ARE VALID IIF THE BASE DIDN'T CHANGED
     */
    IF (ATTVAL != 0) {
	FOR (I = 3,J = 0; J < NRATTS;I += 5,J++)
	    IF ((CTXT->ATTALLOCS[J] != 0) && (ATTS[I] != NULL))
	        XMLFREE((XMLCHAR *) ATTS[I]);
    }
    CTXT->INPUT->CUR = CTXT->INPUT->BASE + CUR;
    CTXT->INPUT->LINE = OLDLINE;
    CTXT->INPUT->COL = OLDCOL;
    IF (CTXT->WELLFORMED == 1) {
	GOTO REPARSE;
    }
    RETURN(NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212407_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HTTP_ISFILTERED(CONST STRUCT HTTP *FM, UNSIGNED U, UNSIGNED HOW)
{
	CONST CHAR *E;
	CONST STRUCT HTTP_HDRFLG *F;

	IF (FM->HDF[U] & HDF_FILTER)
		RETURN (1);
	E = STRCHR(FM->HD[U].B, ':');
	IF (E == NULL)
		RETURN (0);
	F = HTTP_HDR_FLAGS(FM->HD[U].B, E);
	RETURN (F != NULL && F->FLAG & HOW);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212834_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PROCESSDATARCVD(PTCPSESS_T *CONST __RESTRICT__ PTHIS,
	CHAR **BUFF,
	CONST INT BUFFLEN,
	STRUCT SYSLOGTIME *STTIME,
	CONST TIME_T TTGENTIME,
	MULTI_SUBMIT_T *PMULTISUB,
	UNSIGNED *CONST __RESTRICT__ PNMSGS)
{
	DEFIRET;
	CHAR C = **BUFF;
	INT OCTATESTOCOPY, OCTATESTODISCARD;

	IF(PTHIS->INPUTSTATE == EATSTRTFRAM) {
		IF(PTHIS->BSUPPOCTETFRAM && ISDIGIT((INT) C)) {
			PTHIS->INPUTSTATE = EINOCTETCNT;
			PTHIS->IOCTETSREMAIN = 0;
			PTHIS->EFRAMING = TCP_FRAMING_OCTET_COUNTING;
		} ELSE IF(PTHIS->BSPFRAMINGFIX && C == ' ') {
			/* CISCO VERY OCCASIONALLY SENDS A SP AFTER A LF, WHICH
			 * THRASHES FRAMING IF NOT TAKEN SPECIAL CARE OF. HERE,
			 * WE PERMIT SPACE *IN FRONT OF THE NEXT FRAME* AND
			 * IGNORE IT.
			 */
			 FINALIZE;
		} ELSE {
			PTHIS->INPUTSTATE = EINMSG;
			PTHIS->EFRAMING = TCP_FRAMING_OCTET_STUFFING;
		}
	}

	IF(PTHIS->INPUTSTATE == EINOCTETCNT) {
		IF(ISDIGIT(C)) {
			PTHIS->IOCTETSREMAIN = PTHIS->IOCTETSREMAIN * 10 + C - '0';
		} ELSE { /* DONE WITH THE OCTET COUNT, SO THIS MUST BE THE SP TERMINATOR */
			DBGPRINTF("TCP MESSAGE WITH OCTET-COUNTER, SIZE %D.\N", PTHIS->IOCTETSREMAIN);
			IF(C != ' ') {
				ERRMSG.LOGERROR(0, NO_ERRCODE, "FRAMING ERROR IN RECEIVED TCP MESSAGE: "
					    "DELIMITER IS NOT SP BUT HAS ASCII VALUE %D.", C);
			}
			IF(PTHIS->IOCTETSREMAIN < 1) {
				/* TODO: HANDLE THE CASE WHERE THE OCTET COUNT IS 0! */
				DBGPRINTF("FRAMING ERROR: INVALID OCTET COUNT\N");
				ERRMSG.LOGERROR(0, NO_ERRCODE, "FRAMING ERROR IN RECEIVED TCP MESSAGE: "
					    "INVALID OCTET COUNT %D.", PTHIS->IOCTETSREMAIN);
			} ELSE IF(PTHIS->IOCTETSREMAIN > IMAXLINE) {
				/* WHILE WE CAN NOT DO ANYTHING AGAINST IT, WE CAN AT LEAST LOG AN INDICATION
				 * THAT SOMETHING WENT WRONG) -- RGERHARDS, 2008-03-14
				 */
				DBGPRINTF("TRUNCATING MESSAGE WITH %D OCTETS - MAX MSG SIZE IS %D\N",
					  PTHIS->IOCTETSREMAIN, IMAXLINE);
				ERRMSG.LOGERROR(0, NO_ERRCODE, "RECEIVED OVERSIZE MESSAGE: SIZE IS %D BYTES, "
					        "MAX MSG SIZE IS %D, TRUNCATING...", PTHIS->IOCTETSREMAIN, IMAXLINE);
			}
			PTHIS->INPUTSTATE = EINMSG;
		}
	} ELSE {
		ASSERT(PTHIS->INPUTSTATE == EINMSG);

		IF (PTHIS->EFRAMING == TCP_FRAMING_OCTET_STUFFING) {
			IF(PTHIS->IMSG >= IMAXLINE) {
				/* EMERGENCY, WE NOW NEED TO FLUSH, NO MATTER IF WE ARE AT END OF MESSAGE OR NOT... */
				INT I = 1;
				CHAR CURRBUFFCHAR;
				WHILE(I < BUFFLEN && ((CURRBUFFCHAR = (*BUFF)[I]) != '\N'
					&& (PTHIS->PLSTN->PSRV->IADDTLFRAMEDELIM == TCPSRV_NO_ADDTL_DELIMITER
						|| CURRBUFFCHAR != PTHIS->PLSTN->PSRV->IADDTLFRAMEDELIM))) {
					I++;
				}
				LOGERROR(0, NO_ERRCODE, "ERROR: MESSAGE RECEIVED IS AT LEAST %D BYTE LARGER THAN MAX MSG"
					" SIZE; MESSAGE WILL BE SPLIT STARTING AT: \"%.*S\"\N", I, (I < 32) ? I : 32, *BUFF);
				DOSUBMITMSG(PTHIS, STTIME, TTGENTIME, PMULTISUB);
				++(*PNMSGS);
				/* WE MIGHT THINK IF IT IS BETTER TO IGNORE THE REST OF THE
				 * MESSAGE THAN TO TREAT IT AS A NEW ONE. MAYBE THIS IS A GOOD
				 * CANDIDATE FOR A CONFIGURATION PARAMETER...
				 * RGERHARDS, 2006-12-04
				 */
			}

			IF ((C == '\N')
				   || ((PTHIS->PLSTN->PSRV->IADDTLFRAMEDELIM != TCPSRV_NO_ADDTL_DELIMITER)
					   && (C == PTHIS->PLSTN->PSRV->IADDTLFRAMEDELIM))
				   ) { /* RECORD DELIMITER? */
				DOSUBMITMSG(PTHIS, STTIME, TTGENTIME, PMULTISUB);
				++(*PNMSGS);
				PTHIS->INPUTSTATE = EATSTRTFRAM;
			} ELSE {
				/* IMPORTANT: HERE WE COPY THE ACTUAL FRAME CONTENT TO THE MESSAGE - FOR BOTH FRAMING MODES!
				 * IF WE HAVE A MESSAGE THAT IS LARGER THAN THE MAX MSG SIZE, WE TRUNCATE IT. THIS IS THE BEST
				 * WE CAN DO IN LIGHT OF WHAT THE ENGINE SUPPORTS. -- RGERHARDS, 2008-03-14
				 */
				IF(PTHIS->IMSG < IMAXLINE) {
					*(PTHIS->PMSG + PTHIS->IMSG++) = C;
				}
			}
		} ELSE {
			ASSERT(PTHIS->EFRAMING == TCP_FRAMING_OCTET_COUNTING);
			OCTATESTOCOPY = PTHIS->IOCTETSREMAIN;
			OCTATESTODISCARD = 0;
			IF (BUFFLEN < OCTATESTOCOPY) {
				OCTATESTOCOPY = BUFFLEN;
			}
			IF (OCTATESTOCOPY + PTHIS->IMSG > IMAXLINE) {
				OCTATESTODISCARD = OCTATESTOCOPY - (IMAXLINE - PTHIS->IMSG);
				OCTATESTOCOPY = IMAXLINE - PTHIS->IMSG;
			}

			MEMCPY(PTHIS->PMSG + PTHIS->IMSG, *BUFF, OCTATESTOCOPY);
			PTHIS->IMSG += OCTATESTOCOPY;
			PTHIS->IOCTETSREMAIN -= (OCTATESTOCOPY + OCTATESTODISCARD);
			*BUFF += (OCTATESTOCOPY + OCTATESTODISCARD - 1);
			IF (PTHIS->IOCTETSREMAIN == 0) {
				/* WE HAVE END OF FRAME! */
				DOSUBMITMSG(PTHIS, STTIME, TTGENTIME, PMULTISUB);
				++(*PNMSGS);
				PTHIS->INPUTSTATE = EATSTRTFRAM;
			}
		}

	}

FINALIZE_IT:
	RETIRET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 317089_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SELINUX_SECCTX_TO_SECID(CONST CHAR *SECDATA, U32 SECLEN, U32 *SECID)
{
	RETURN SECURITY_CONTEXT_TO_SID(&SELINUX_STATE, SECDATA, SECLEN,
				       SECID, GFP_KERNEL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206555_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT DYNAMICGETBUF (GDIOCTXPTR CTX, VOID *BUF, INT LEN)
{
	INT RLEN, REMAIN;
	DPIOCTXPTR DCTX;
	DYNAMICPTR *DP;

	DCTX = (DPIOCTXPTR) CTX;
	DP = DCTX->DP;

	REMAIN = DP->LOGICALSIZE - DP->POS;
	IF (REMAIN >= LEN) {
		RLEN = LEN;
	} ELSE {
		IF (REMAIN == 0) {
			RETURN EOF;
		}
		RLEN = REMAIN;
	}

	MEMCPY(BUF, (VOID *) ((CHAR *) DP->DATA + DP->POS), RLEN);
	DP->POS += RLEN;

	RETURN RLEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 430427_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT VXLAN_TUN_OPT_FROM_NLATTR(CONST STRUCT NLATTR *ATTR,
				     STRUCT SW_FLOW_MATCH *MATCH, BOOL IS_MASK,
				     BOOL LOG)
{
	STRUCT NLATTR *A;
	INT REM;
	UNSIGNED LONG OPT_KEY_OFFSET;
	STRUCT VXLAN_METADATA OPTS;

	BUILD_BUG_ON(SIZEOF(OPTS) > SIZEOF(MATCH->KEY->TUN_OPTS));

	MEMSET(&OPTS, 0, SIZEOF(OPTS));
	NLA_FOR_EACH_NESTED(A, ATTR, REM) {
		INT TYPE = NLA_TYPE(A);

		IF (TYPE > OVS_VXLAN_EXT_MAX) {
			OVS_NLERR(LOG, "VXLAN EXTENSION %D OUT OF RANGE MAX %D",
				  TYPE, OVS_VXLAN_EXT_MAX);
			RETURN -EINVAL;
		}

		IF (!CHECK_ATTR_LEN(NLA_LEN(A),
				    OVS_VXLAN_EXT_KEY_LENS[TYPE].LEN)) {
			OVS_NLERR(LOG, "VXLAN EXTENSION %D HAS UNEXPECTED LEN %D EXPECTED %D",
				  TYPE, NLA_LEN(A),
				  OVS_VXLAN_EXT_KEY_LENS[TYPE].LEN);
			RETURN -EINVAL;
		}

		SWITCH (TYPE) {
		CASE OVS_VXLAN_EXT_GBP:
			OPTS.GBP = NLA_GET_U32(A);
			BREAK;
		DEFAULT:
			OVS_NLERR(LOG, "UNKNOWN VXLAN EXTENSION ATTRIBUTE %D",
				  TYPE);
			RETURN -EINVAL;
		}
	}
	IF (REM) {
		OVS_NLERR(LOG, "VXLAN EXTENSION MESSAGE HAS %D UNKNOWN BYTES.",
			  REM);
		RETURN -EINVAL;
	}

	IF (!IS_MASK)
		SW_FLOW_KEY_PUT(MATCH, TUN_OPTS_LEN, SIZEOF(OPTS), FALSE);
	ELSE
		SW_FLOW_KEY_PUT(MATCH, TUN_OPTS_LEN, 0XFF, TRUE);

	OPT_KEY_OFFSET = TUN_METADATA_OFFSET(SIZEOF(OPTS));
	SW_FLOW_KEY_MEMCPY_OFFSET(MATCH, OPT_KEY_OFFSET, &OPTS, SIZEOF(OPTS),
				  IS_MASK);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211695_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
REG_MATCH_VISUAL(VOID)
{
    POS_T	TOP, BOT;
    LINENR_T    LNUM;
    COLNR_T	COL;
    WIN_T	*WP = REX.REG_WIN == NULL ? CURWIN : REX.REG_WIN;
    INT		MODE;
    COLNR_T	START, END;
    COLNR_T	START2, END2;
    COLNR_T	COLS;
    COLNR_T	CURSWANT;

    // CHECK IF THE BUFFER IS THE CURRENT BUFFER.
    IF (REX.REG_BUF != CURBUF || VISUAL.LNUM == 0)
	RETURN FALSE;

    IF (VISUAL_ACTIVE)
    {
	IF (LT_POS(VISUAL, WP->W_CURSOR))
	{
	    TOP = VISUAL;
	    BOT = WP->W_CURSOR;
	}
	ELSE
	{
	    TOP = WP->W_CURSOR;
	    BOT = VISUAL;
	}
	MODE = VISUAL_MODE;
	CURSWANT = WP->W_CURSWANT;
    }
    ELSE
    {
	IF (LT_POS(CURBUF->B_VISUAL.VI_START, CURBUF->B_VISUAL.VI_END))
	{
	    TOP = CURBUF->B_VISUAL.VI_START;
	    BOT = CURBUF->B_VISUAL.VI_END;
	}
	ELSE
	{
	    TOP = CURBUF->B_VISUAL.VI_END;
	    BOT = CURBUF->B_VISUAL.VI_START;
	}
	MODE = CURBUF->B_VISUAL.VI_MODE;
	CURSWANT = CURBUF->B_VISUAL.VI_CURSWANT;
    }
    LNUM = REX.LNUM + REX.REG_FIRSTLNUM;
    IF (LNUM < TOP.LNUM || LNUM > BOT.LNUM)
	RETURN FALSE;

    IF (MODE == 'V')
    {
	COL = (COLNR_T)(REX.INPUT - REX.LINE);
	IF ((LNUM == TOP.LNUM && COL < TOP.COL)
		|| (LNUM == BOT.LNUM && COL >= BOT.COL + (*P_SEL != 'E')))
	    RETURN FALSE;
    }
    ELSE IF (MODE == CTRL_V)
    {
	GETVVCOL(WP, &TOP, &START, NULL, &END);
	GETVVCOL(WP, &BOT, &START2, NULL, &END2);
	IF (START2 < START)
	    START = START2;
	IF (END2 > END)
	    END = END2;
	IF (TOP.COL == MAXCOL || BOT.COL == MAXCOL || CURSWANT == MAXCOL)
	    END = MAXCOL;
	COLS = WIN_LINETABSIZE(WP, REX.LINE, (COLNR_T)(REX.INPUT - REX.LINE));
	IF (COLS < START || COLS > END - (*P_SEL == 'E'))
	    RETURN FALSE;
    }
    RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209931_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PRESENTATIONCONTEXT* PRESENTATIONCONTEXT_NEW(VIDEOCLIENTCONTEXT* VIDEO, BYTE PRESENTATIONID,
                                                    UINT32 X, UINT32 Y, UINT32 WIDTH, UINT32 HEIGHT)
{
	VIDEOCLIENTCONTEXTPRIV* PRIV = VIDEO->PRIV;
	PRESENTATIONCONTEXT* RET = CALLOC(1, SIZEOF(*RET));
	IF (!RET)
		RETURN NULL;

	RET->VIDEO = VIDEO;
	RET->PRESENTATIONID = PRESENTATIONID;

	RET->H264 = H264_CONTEXT_NEW(FALSE);
	IF (!RET->H264)
	{
		WLOG_ERR(TAG, "UNABLE TO CREATE A H264 CONTEXT");
		GOTO ERROR_H264;
	}
	H264_CONTEXT_RESET(RET->H264, WIDTH, HEIGHT);

	RET->CURRENTSAMPLE = STREAM_NEW(NULL, 4096);
	IF (!RET->CURRENTSAMPLE)
	{
		WLOG_ERR(TAG, "UNABLE TO CREATE CURRENT PACKET STREAM");
		GOTO ERROR_CURRENTSAMPLE;
	}

	RET->SURFACEDATA = BUFFERPOOL_TAKE(PRIV->SURFACEPOOL, WIDTH * HEIGHT * 4);
	IF (!RET->SURFACEDATA)
	{
		WLOG_ERR(TAG, "UNABLE TO ALLOCATE SURFACEDATA");
		GOTO ERROR_SURFACEDATA;
	}

	RET->SURFACE = VIDEO->CREATESURFACE(VIDEO, RET->SURFACEDATA, X, Y, WIDTH, HEIGHT);
	IF (!RET->SURFACE)
	{
		WLOG_ERR(TAG, "UNABLE TO CREATE SURFACE");
		GOTO ERROR_SURFACE;
	}

	RET->YUV = YUV_CONTEXT_NEW(FALSE);
	IF (!RET->YUV)
	{
		WLOG_ERR(TAG, "UNABLE TO CREATE YUV DECODER");
		GOTO ERROR_YUV;
	}

	YUV_CONTEXT_RESET(RET->YUV, WIDTH, HEIGHT);
	RET->REFCOUNTER = 1;
	RETURN RET;

ERROR_YUV:
	VIDEO->DELETESURFACE(VIDEO, RET->SURFACE);
ERROR_SURFACE:
	BUFFERPOOL_RETURN(PRIV->SURFACEPOOL, RET->SURFACEDATA);
ERROR_SURFACEDATA:
	STREAM_FREE(RET->CURRENTSAMPLE, TRUE);
ERROR_CURRENTSAMPLE:
	H264_CONTEXT_FREE(RET->H264);
ERROR_H264:
	FREE(RET);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208421_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EX_DIFFGETPUT(EXARG_T *EAP)
{
    LINENR_T	LNUM;
    INT		COUNT;
    LINENR_T	OFF = 0;
    DIFF_T	*DP;
    DIFF_T	*DPREV;
    DIFF_T	*DFREE;
    INT		IDX_CUR;
    INT		IDX_OTHER;
    INT		IDX_FROM;
    INT		IDX_TO;
    INT		I;
    INT		ADDED;
    CHAR_U	*P;
    ACO_SAVE_T	ACO;
    BUF_T	*BUF;
    INT		START_SKIP, END_SKIP;
    INT		NEW_COUNT;
    INT		BUF_EMPTY;
    INT		FOUND_NOT_MA = FALSE;

    // FIND THE CURRENT BUFFER IN THE LIST OF DIFF BUFFERS.
    IDX_CUR = DIFF_BUF_IDX(CURBUF);
    IF (IDX_CUR == DB_COUNT)
    {
	EMSG(_(E_CURRENT_BUFFER_IS_NOT_IN_DIFF_MODE));
	RETURN;
    }

    IF (*EAP->ARG == NUL)
    {
	// NO ARGUMENT: FIND THE OTHER BUFFER IN THE LIST OF DIFF BUFFERS.
	FOR (IDX_OTHER = 0; IDX_OTHER < DB_COUNT; ++IDX_OTHER)
	    IF (CURTAB->TP_DIFFBUF[IDX_OTHER] != CURBUF
		    && CURTAB->TP_DIFFBUF[IDX_OTHER] != NULL)
	    {
		IF (EAP->CMDIDX != CMD_DIFFPUT
				     || CURTAB->TP_DIFFBUF[IDX_OTHER]->B_P_MA)
		    BREAK;
		FOUND_NOT_MA = TRUE;
	    }
	IF (IDX_OTHER == DB_COUNT)
	{
	    IF (FOUND_NOT_MA)
		EMSG(_(E_NO_OTHER_BUFFER_IN_DIFF_MODE_IS_MODIFIABLE));
	    ELSE
		EMSG(_(E_NO_OTHER_BUFFER_IN_DIFF_MODE));
	    RETURN;
	}

	// CHECK THAT THERE ISN'T A THIRD BUFFER IN THE LIST
	FOR (I = IDX_OTHER + 1; I < DB_COUNT; ++I)
	    IF (CURTAB->TP_DIFFBUF[I] != CURBUF
		    && CURTAB->TP_DIFFBUF[I] != NULL
		    && (EAP->CMDIDX != CMD_DIFFPUT || CURTAB->TP_DIFFBUF[I]->B_P_MA))
	    {
		EMSG(_(E_MORE_THAN_TWO_BUFFERS_IN_DIFF_MODE_DONT_KNOW_WHICH_ONE_TO_USE));
		RETURN;
	    }
    }
    ELSE
    {
	// BUFFER NUMBER OR PATTERN GIVEN.  IGNORE TRAILING WHITE SPACE.
	P = EAP->ARG + STRLEN(EAP->ARG);
	WHILE (P > EAP->ARG && VIM_ISWHITE(P[-1]))
	    --P;
	FOR (I = 0; VIM_ISDIGIT(EAP->ARG[I]) && EAP->ARG + I < P; ++I)
	    ;
	IF (EAP->ARG + I == P)	    // DIGITS ONLY
	    I = ATOL((CHAR *)EAP->ARG);
	ELSE
	{
	    I = BUFLIST_FINDPAT(EAP->ARG, P, FALSE, TRUE, FALSE);
	    IF (I < 0)
		RETURN;		// ERROR MESSAGE ALREADY GIVEN
	}
	BUF = BUFLIST_FINDNR(I);
	IF (BUF == NULL)
	{
	    SEMSG(_(E_CANT_FIND_BUFFER_STR), EAP->ARG);
	    RETURN;
	}
	IF (BUF == CURBUF)
	    RETURN;		// NOTHING TO DO
	IDX_OTHER = DIFF_BUF_IDX(BUF);
	IF (IDX_OTHER == DB_COUNT)
	{
	    SEMSG(_(E_BUFFER_STR_IS_NOT_IN_DIFF_MODE), EAP->ARG);
	    RETURN;
	}
    }

    DIFF_BUSY = TRUE;

    // WHEN NO RANGE GIVEN INCLUDE THE LINE ABOVE OR BELOW THE CURSOR.
    IF (EAP->ADDR_COUNT == 0)
    {
	// MAKE IT POSSIBLE THAT ":DIFFGET" ON THE LAST LINE GETS LINE BELOW
	// THE CURSOR LINE WHEN THERE IS NO DIFFERENCE ABOVE THE CURSOR.
	IF (EAP->CMDIDX == CMD_DIFFGET
		&& EAP->LINE1 == CURBUF->B_ML.ML_LINE_COUNT
		&& DIFF_CHECK(CURWIN, EAP->LINE1) == 0
		&& (EAP->LINE1 == 1 || DIFF_CHECK(CURWIN, EAP->LINE1 - 1) == 0))
	    ++EAP->LINE2;
	ELSE IF (EAP->LINE1 > 0)
	    --EAP->LINE1;
    }

    IF (EAP->CMDIDX == CMD_DIFFGET)
    {
	IDX_FROM = IDX_OTHER;
	IDX_TO = IDX_CUR;
    }
    ELSE
    {
	IDX_FROM = IDX_CUR;
	IDX_TO = IDX_OTHER;
	// NEED TO MAKE THE OTHER BUFFER THE CURRENT BUFFER TO BE ABLE TO MAKE
	// CHANGES IN IT.
	// SET CURWIN/CURBUF TO BUF AND SAVE A FEW THINGS
	AUCMD_PREPBUF(&ACO, CURTAB->TP_DIFFBUF[IDX_OTHER]);
    }

    // MAY GIVE THE WARNING FOR A CHANGED BUFFER HERE, WHICH CAN TRIGGER THE
    // FILECHANGEDRO AUTOCOMMAND, WHICH MAY DO NASTY THINGS AND MESS
    // EVERYTHING UP.
    IF (!CURBUF->B_CHANGED)
    {
	CHANGE_WARNING(0);
	IF (DIFF_BUF_IDX(CURBUF) != IDX_TO)
	{
	    EMSG(_(E_BUFFER_CHANGED_UNEXPECTEDLY));
	    GOTO THEEND;
	}
    }

    DPREV = NULL;
    FOR (DP = CURTAB->TP_FIRST_DIFF; DP != NULL; )
    {
	IF (DP->DF_LNUM[IDX_CUR] > EAP->LINE2 + OFF)
	    BREAK;	// PAST THE RANGE THAT WAS SPECIFIED

	DFREE = NULL;
	LNUM = DP->DF_LNUM[IDX_TO];
	COUNT = DP->DF_COUNT[IDX_TO];
	IF (DP->DF_LNUM[IDX_CUR] + DP->DF_COUNT[IDX_CUR] > EAP->LINE1 + OFF
		&& U_SAVE(LNUM - 1, LNUM + COUNT) != FAIL)
	{
	    // INSIDE THE SPECIFIED RANGE AND SAVING FOR UNDO WORKED.
	    START_SKIP = 0;
	    END_SKIP = 0;
	    IF (EAP->ADDR_COUNT > 0)
	    {
		// A RANGE WAS SPECIFIED: CHECK IF LINES NEED TO BE SKIPPED.
		START_SKIP = EAP->LINE1 + OFF - DP->DF_LNUM[IDX_CUR];
		IF (START_SKIP > 0)
		{
		    // RANGE STARTS BELOW START OF CURRENT DIFF BLOCK
		    IF (START_SKIP > COUNT)
		    {
			LNUM += COUNT;
			COUNT = 0;
		    }
		    ELSE
		    {
			COUNT -= START_SKIP;
			LNUM += START_SKIP;
		    }
		}
		ELSE
		    START_SKIP = 0;

		END_SKIP = DP->DF_LNUM[IDX_CUR] + DP->DF_COUNT[IDX_CUR] - 1
							 - (EAP->LINE2 + OFF);
		IF (END_SKIP > 0)
		{
		    // RANGE ENDS ABOVE END OF CURRENT/FROM DIFF BLOCK
		    IF (IDX_CUR == IDX_FROM)	// :DIFFPUT
		    {
			I = DP->DF_COUNT[IDX_CUR] - START_SKIP - END_SKIP;
			IF (COUNT > I)
			    COUNT = I;
		    }
		    ELSE			// :DIFFGET
		    {
			COUNT -= END_SKIP;
			END_SKIP = DP->DF_COUNT[IDX_FROM] - START_SKIP - COUNT;
			IF (END_SKIP < 0)
			    END_SKIP = 0;
		    }
		}
		ELSE
		    END_SKIP = 0;
	    }

	    BUF_EMPTY = BUFEMPTY();
	    ADDED = 0;
	    FOR (I = 0; I < COUNT; ++I)
	    {
		// REMEMBER DELETING THE LAST LINE OF THE BUFFER
		BUF_EMPTY = CURBUF->B_ML.ML_LINE_COUNT == 1;
		ML_DELETE(LNUM);
		--ADDED;
	    }
	    FOR (I = 0; I < DP->DF_COUNT[IDX_FROM] - START_SKIP - END_SKIP; ++I)
	    {
		LINENR_T NR;

		NR = DP->DF_LNUM[IDX_FROM] + START_SKIP + I;
		IF (NR > CURTAB->TP_DIFFBUF[IDX_FROM]->B_ML.ML_LINE_COUNT)
		    BREAK;
		P = VIM_STRSAVE(ML_GET_BUF(CURTAB->TP_DIFFBUF[IDX_FROM],
								  NR, FALSE));
		IF (P != NULL)
		{
		    ML_APPEND(LNUM + I - 1, P, 0, FALSE);
		    VIM_FREE(P);
		    ++ADDED;
		    IF (BUF_EMPTY && CURBUF->B_ML.ML_LINE_COUNT == 2)
		    {
			// ADDED THE FIRST LINE INTO AN EMPTY BUFFER, NEED TO
			// DELETE THE DUMMY EMPTY LINE.
			BUF_EMPTY = FALSE;
			ML_DELETE((LINENR_T)2);
		    }
		}
	    }
	    NEW_COUNT = DP->DF_COUNT[IDX_TO] + ADDED;
	    DP->DF_COUNT[IDX_TO] = NEW_COUNT;

	    IF (START_SKIP == 0 && END_SKIP == 0)
	    {
		// CHECK IF THERE ARE ANY OTHER BUFFERS AND IF THE DIFF IS
		// EQUAL IN THEM.
		FOR (I = 0; I < DB_COUNT; ++I)
		    IF (CURTAB->TP_DIFFBUF[I] != NULL && I != IDX_FROM
								&& I != IDX_TO
			    && !DIFF_EQUAL_ENTRY(DP, IDX_FROM, I))
			BREAK;
		IF (I == DB_COUNT)
		{
		    // DELETE THE DIFF ENTRY, THE BUFFERS ARE NOW EQUAL HERE
		    DFREE = DP;
		    DP = DP->DF_NEXT;
		    IF (DPREV == NULL)
			CURTAB->TP_FIRST_DIFF = DP;
		    ELSE
			DPREV->DF_NEXT = DP;
		}
	    }

	    // ADJUST MARKS.  THIS WILL CHANGE THE FOLLOWING ENTRIES!
	    IF (ADDED != 0)
	    {
		MARK_ADJUST(LNUM, LNUM + COUNT - 1, (LONG)MAXLNUM, (LONG)ADDED);
		IF (CURWIN->W_CURSOR.LNUM >= LNUM)
		{
		    // ADJUST THE CURSOR POSITION IF IT'S IN/AFTER THE CHANGED
		    // LINES.
		    IF (CURWIN->W_CURSOR.LNUM >= LNUM + COUNT)
			CURWIN->W_CURSOR.LNUM += ADDED;
		    ELSE IF (ADDED < 0)
			CURWIN->W_CURSOR.LNUM = LNUM;
		}
	    }
	    CHANGED_LINES(LNUM, 0, LNUM + COUNT, (LONG)ADDED);

	    IF (DFREE != NULL)
	    {
		// DIFF IS DELETED, UPDATE FOLDS IN OTHER WINDOWS.
#IFDEF FEAT_FOLDING
		DIFF_FOLD_UPDATE(DFREE, IDX_TO);
#ENDIF
		VIM_FREE(DFREE);
	    }
	    ELSE
		// MARK_ADJUST() MAY HAVE CHANGED THE COUNT IN A WRONG WAY
		DP->DF_COUNT[IDX_TO] = NEW_COUNT;

	    // WHEN CHANGING THE CURRENT BUFFER, KEEP TRACK OF LINE NUMBERS
	    IF (IDX_CUR == IDX_TO)
		OFF += ADDED;
	}

	// IF BEFORE THE RANGE OR NOT DELETED, GO TO NEXT DIFF.
	IF (DFREE == NULL)
	{
	    DPREV = DP;
	    DP = DP->DF_NEXT;
	}
    }

    // RESTORE CURWIN/CURBUF AND A FEW OTHER THINGS
    IF (EAP->CMDIDX != CMD_DIFFGET)
    {
	// SYNCING UNDO ONLY WORKS FOR THE CURRENT BUFFER, BUT WE CHANGE
	// ANOTHER BUFFER.  SYNC UNDO IF THE COMMAND WAS TYPED.  THIS ISN'T
	// 100% RIGHT WHEN ":DIFFPUT" IS USED IN A FUNCTION OR MAPPING.
	IF (KEYTYPED)
	    U_SYNC(FALSE);
	AUCMD_RESTBUF(&ACO);
    }

THEEND:
    DIFF_BUSY = FALSE;
    IF (DIFF_NEED_UPDATE)
	EX_DIFFUPDATE(NULL);

    // CHECK THAT THE CURSOR IS ON A VALID CHARACTER AND UPDATE ITS
    // POSITION.  WHEN THERE WERE FILLER LINES THE TOPLINE HAS BECOME
    // INVALID.
    CHECK_CURSOR();
    CHANGED_LINE_ABV_CURS();

    IF (DIFF_NEED_UPDATE)
	// REDRAW ALREADY DONE BY EX_DIFFUPDATE()
	DIFF_NEED_UPDATE = FALSE;
    ELSE
    {
	// ALSO NEED TO REDRAW THE OTHER BUFFERS.
	DIFF_REDRAW(FALSE);
	APPLY_AUTOCMDS(EVENT_DIFFUPDATED, NULL, NULL, FALSE, CURBUF);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210252_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READCINIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
#DEFINE MONOCOLORTYPE  1
#DEFINE RGBCOLORTYPE  3

  CHAR
    PROPERTY[MAGICKPATHEXTENT];

  CININFO
    CIN;

  IMAGE
    *IMAGE;

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    OFFSET;

  QUANTUMINFO
    *QUANTUM_INFO;

  QUANTUMTYPE
    QUANTUM_TYPE;

  SSIZE_T
    I;

  QUANTUM
    *Q;

  SIZE_T
    LENGTH;

  SSIZE_T
    COUNT,
    Y;

  UNSIGNED CHAR
    MAGICK[4],
    *PIXELS;


  /*
    OPEN IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  IMAGE=ACQUIREIMAGE(IMAGE_INFO,EXCEPTION);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    FILE INFORMATION.
  */
  OFFSET=0;
  COUNT=READBLOB(IMAGE,4,MAGICK);
  OFFSET+=COUNT;
  IF ((COUNT != 4) ||
      ((LOCALENCOMPARE((CHAR *) MAGICK,"\200\052\137\327",4) != 0)))
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  MEMSET(&CIN,0,SIZEOF(CIN));
  IMAGE->ENDIAN=(MAGICK[0] == 0X80) && (MAGICK[1] == 0X2A) &&
    (MAGICK[2] == 0X5F) && (MAGICK[3] == 0XD7) ? MSBENDIAN : LSBENDIAN;
  CIN.FILE.IMAGE_OFFSET=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.GENERIC_LENGTH=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.INDUSTRY_LENGTH=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.USER_LENGTH=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.FILE_SIZE=READBLOBLONG(IMAGE);
  OFFSET+=4;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.VERSION),(UNSIGNED CHAR *)
    CIN.FILE.VERSION);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.VERSION,SIZEOF(CIN.FILE.VERSION));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.VERSION",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.FILENAME),(UNSIGNED CHAR *)
    CIN.FILE.FILENAME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.FILENAME,SIZEOF(CIN.FILE.FILENAME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.FILENAME",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.CREATE_DATE),(UNSIGNED CHAR *)
    CIN.FILE.CREATE_DATE);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.CREATE_DATE,
    SIZEOF(CIN.FILE.CREATE_DATE));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.CREATE_DATE",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.CREATE_TIME),(UNSIGNED CHAR *)
    CIN.FILE.CREATE_TIME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.CREATE_TIME,
    SIZEOF(CIN.FILE.CREATE_TIME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.CREATE_TIME",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.RESERVE),(UNSIGNED CHAR *)
    CIN.FILE.RESERVE);
  /*
    IMAGE INFORMATION.
  */
  CIN.IMAGE.ORIENTATION=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  IF (CIN.IMAGE.ORIENTATION != (UNSIGNED CHAR) (~0))
    (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:IMAGE.ORIENTATION","%D",
      CIN.IMAGE.ORIENTATION);
  SWITCH (CIN.IMAGE.ORIENTATION)
  {
    DEFAULT:
    CASE 0: IMAGE->ORIENTATION=TOPLEFTORIENTATION; BREAK;
    CASE 1: IMAGE->ORIENTATION=TOPRIGHTORIENTATION; BREAK;
    CASE 2: IMAGE->ORIENTATION=BOTTOMLEFTORIENTATION; BREAK;
    CASE 3: IMAGE->ORIENTATION=BOTTOMRIGHTORIENTATION; BREAK;
    CASE 4: IMAGE->ORIENTATION=LEFTTOPORIENTATION; BREAK;
    CASE 5: IMAGE->ORIENTATION=RIGHTTOPORIENTATION; BREAK;
    CASE 6: IMAGE->ORIENTATION=LEFTBOTTOMORIENTATION; BREAK;
    CASE 7: IMAGE->ORIENTATION=RIGHTBOTTOMORIENTATION; BREAK;
  }
  CIN.IMAGE.NUMBER_CHANNELS=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.IMAGE.RESERVE1),(UNSIGNED CHAR *)
    CIN.IMAGE.RESERVE1);
  FOR (I=0; I < 8; I++)
  {
    CIN.IMAGE.CHANNEL[I].DESIGNATOR[0]=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].DESIGNATOR[1]=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].BITS_PER_PIXEL=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].RESERVE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].PIXELS_PER_LINE=READBLOBLONG(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].LINES_PER_IMAGE=READBLOBLONG(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MIN_DATA=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MIN_QUANTITY=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MAX_DATA=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MAX_QUANTITY=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
  }
  CIN.IMAGE.WHITE_POINT[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.WHITE_POINT[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.WHITE_POINT.X=CIN.IMAGE.WHITE_POINT[0];
  CIN.IMAGE.WHITE_POINT[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.WHITE_POINT[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.WHITE_POINT.Y=CIN.IMAGE.WHITE_POINT[1];
  CIN.IMAGE.RED_PRIMARY_CHROMATICITY[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.RED_PRIMARY_CHROMATICITY[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.RED_PRIMARY.X=CIN.IMAGE.RED_PRIMARY_CHROMATICITY[0];
  CIN.IMAGE.RED_PRIMARY_CHROMATICITY[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.RED_PRIMARY_CHROMATICITY[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.RED_PRIMARY.Y=CIN.IMAGE.RED_PRIMARY_CHROMATICITY[1];
  CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.RED_PRIMARY.X=CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[0];
  CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.GREEN_PRIMARY.Y=CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[1];
  CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.BLUE_PRIMARY.X=CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[0];
  CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.BLUE_PRIMARY.Y=CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[1];
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.IMAGE.LABEL),(UNSIGNED CHAR *)
    CIN.IMAGE.LABEL);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.IMAGE.LABEL,SIZEOF(CIN.IMAGE.LABEL));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:IMAGE.LABEL",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.IMAGE.RESERVE),(UNSIGNED CHAR *)
    CIN.IMAGE.RESERVE);
  /*
    IMAGE DATA FORMAT INFORMATION.
  */
  CIN.DATA_FORMAT.INTERLEAVE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.PACKING=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.SIGN=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.SENSE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.LINE_PAD=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.DATA_FORMAT.CHANNEL_PAD=READBLOBLONG(IMAGE);
  OFFSET+=4;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.DATA_FORMAT.RESERVE),(UNSIGNED CHAR *)
    CIN.DATA_FORMAT.RESERVE);
  /*
    IMAGE ORIGINATION INFORMATION.
  */
  CIN.ORIGINATION.X_OFFSET=READBLOBSIGNEDLONG(IMAGE);
  OFFSET+=4;
  IF ((SIZE_T) CIN.ORIGINATION.X_OFFSET != ~0UL)
    (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.X_OFFSET","%.20G",
      (DOUBLE) CIN.ORIGINATION.X_OFFSET);
  CIN.ORIGINATION.Y_OFFSET=(SSIZE_T) READBLOBLONG(IMAGE);
  OFFSET+=4;
  IF ((SIZE_T) CIN.ORIGINATION.Y_OFFSET != ~0UL)
    (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.Y_OFFSET","%.20G",
      (DOUBLE) CIN.ORIGINATION.Y_OFFSET);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.FILENAME),(UNSIGNED CHAR *)
    CIN.ORIGINATION.FILENAME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.FILENAME,
    SIZEOF(CIN.ORIGINATION.FILENAME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.FILENAME",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.CREATE_DATE),(UNSIGNED CHAR *)
    CIN.ORIGINATION.CREATE_DATE);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.CREATE_DATE,
    SIZEOF(CIN.ORIGINATION.CREATE_DATE));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.CREATE_DATE",PROPERTY,
    EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.CREATE_TIME),(UNSIGNED CHAR *)
    CIN.ORIGINATION.CREATE_TIME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.CREATE_TIME,
    SIZEOF(CIN.ORIGINATION.CREATE_TIME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.CREATE_TIME",PROPERTY,
    EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.DEVICE),(UNSIGNED CHAR *)
    CIN.ORIGINATION.DEVICE);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.DEVICE,
    SIZEOF(CIN.ORIGINATION.DEVICE));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.DEVICE",PROPERTY,EXCEPTION);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.MODEL),(UNSIGNED CHAR *)
    CIN.ORIGINATION.MODEL);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.MODEL,
    SIZEOF(CIN.ORIGINATION.MODEL));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.MODEL",PROPERTY,EXCEPTION);
  (VOID) MEMSET(CIN.ORIGINATION.SERIAL,0, 
    SIZEOF(CIN.ORIGINATION.SERIAL));
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.SERIAL),(UNSIGNED CHAR *)
    CIN.ORIGINATION.SERIAL);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.SERIAL,
    SIZEOF(CIN.ORIGINATION.SERIAL));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.SERIAL",PROPERTY,EXCEPTION);
  CIN.ORIGINATION.X_PITCH=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  CIN.ORIGINATION.Y_PITCH=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  CIN.ORIGINATION.GAMMA=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.ORIGINATION.GAMMA) != MAGICKFALSE)
    IMAGE->GAMMA=CIN.ORIGINATION.GAMMA;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.RESERVE),(UNSIGNED CHAR *)
    CIN.ORIGINATION.RESERVE);
  IF ((CIN.FILE.IMAGE_OFFSET > 2048) && (CIN.FILE.USER_LENGTH != 0))
    {
      INT
        C;

      /*
        IMAGE FILM INFORMATION.
      */
      CIN.FILM.ID=READBLOBBYTE(IMAGE);
      OFFSET++;
      C=CIN.FILM.ID;
      IF (C != ~0)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.ID","%D",CIN.FILM.ID);
      CIN.FILM.TYPE=READBLOBBYTE(IMAGE);
      OFFSET++;
      C=CIN.FILM.TYPE;
      IF (C != ~0)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.TYPE","%D",CIN.FILM.TYPE);
      CIN.FILM.OFFSET=READBLOBBYTE(IMAGE);
      OFFSET++;
      C=CIN.FILM.OFFSET;
      IF (C != ~0)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.OFFSET","%D",
          CIN.FILM.OFFSET);
      CIN.FILM.RESERVE1=READBLOBBYTE(IMAGE);
      OFFSET++;
      CIN.FILM.PREFIX=READBLOBLONG(IMAGE);
      OFFSET+=4;
      IF (CIN.FILM.PREFIX != ~0UL)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.PREFIX","%.20G",(DOUBLE)
          CIN.FILM.PREFIX);
      CIN.FILM.COUNT=READBLOBLONG(IMAGE);
      OFFSET+=4;
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.FORMAT),(UNSIGNED CHAR *)
        CIN.FILM.FORMAT);
      (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILM.FORMAT,SIZEOF(CIN.FILM.FORMAT));
      (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILM.FORMAT",PROPERTY,EXCEPTION);
      CIN.FILM.FRAME_POSITION=READBLOBLONG(IMAGE);
      OFFSET+=4;
      IF (CIN.FILM.FRAME_POSITION != ~0UL)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.FRAME_POSITION","%.20G",
          (DOUBLE) CIN.FILM.FRAME_POSITION);
      CIN.FILM.FRAME_RATE=READBLOBFLOAT(IMAGE);
      OFFSET+=4;
      IF (ISFLOATDEFINED(CIN.FILM.FRAME_RATE) != MAGICKFALSE)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.FRAME_RATE","%G",
          CIN.FILM.FRAME_RATE);
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.FRAME_ID),(UNSIGNED CHAR *)
        CIN.FILM.FRAME_ID);
      (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILM.FRAME_ID,
        SIZEOF(CIN.FILM.FRAME_ID));
      (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILM.FRAME_ID",PROPERTY,EXCEPTION);
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.SLATE_INFO),(UNSIGNED CHAR *)
        CIN.FILM.SLATE_INFO);
      (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILM.SLATE_INFO,
        SIZEOF(CIN.FILM.SLATE_INFO));
      (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILM.SLATE_INFO",PROPERTY,EXCEPTION);
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.RESERVE),(UNSIGNED CHAR *)
        CIN.FILM.RESERVE);
    }
  IF ((CIN.FILE.IMAGE_OFFSET > 2048) && (CIN.FILE.USER_LENGTH != 0))
    {
      STRINGINFO
        *PROFILE;

      /*
        USER DEFINED DATA.
      */
      IF (CIN.FILE.USER_LENGTH > GETBLOBSIZE(IMAGE))
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
      PROFILE=BLOBTOSTRINGINFO((CONST UNSIGNED CHAR *) NULL,
        CIN.FILE.USER_LENGTH);
      IF (PROFILE == (STRINGINFO *) NULL)
        THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
      OFFSET+=READBLOB(IMAGE,GETSTRINGINFOLENGTH(PROFILE),
        GETSTRINGINFODATUM(PROFILE));
      (VOID) SETIMAGEPROFILE(IMAGE,"DPX:USER.DATA",PROFILE,EXCEPTION);
      PROFILE=DESTROYSTRINGINFO(PROFILE);
    }
  IMAGE->DEPTH=CIN.IMAGE.CHANNEL[0].BITS_PER_PIXEL;
  IMAGE->COLUMNS=CIN.IMAGE.CHANNEL[0].PIXELS_PER_LINE;
  IMAGE->ROWS=CIN.IMAGE.CHANNEL[0].LINES_PER_IMAGE;
  IF (IMAGE_INFO->PING != MAGICKFALSE)
    {
      (VOID) CLOSEBLOB(IMAGE);
      RETURN(IMAGE);
    }
  IF (((MAGICKSIZETYPE) IMAGE->COLUMNS*IMAGE->ROWS/8) > GETBLOBSIZE(IMAGE))
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
  FOR ( ; OFFSET < (MAGICKOFFSETTYPE) CIN.FILE.IMAGE_OFFSET; OFFSET++)
  {
    INT
      C;

    C=READBLOBBYTE(IMAGE);
    IF (C == EOF)
      BREAK;
  }
  IF (OFFSET < (MAGICKOFFSETTYPE) CIN.FILE.IMAGE_OFFSET)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    RETURN(DESTROYIMAGELIST(IMAGE));
  (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);
  /*
    CONVERT CIN RASTER IMAGE TO PIXEL PACKETS.
  */
  QUANTUM_INFO=ACQUIREQUANTUMINFO(IMAGE_INFO,IMAGE);
  IF (QUANTUM_INFO == (QUANTUMINFO *) NULL)
    THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
  SETQUANTUMQUANTUM(QUANTUM_INFO,32);
  SETQUANTUMPACK(QUANTUM_INFO,MAGICKFALSE);
  QUANTUM_TYPE=RGBQUANTUM;
  LENGTH=GETBYTESPERROW(IMAGE->COLUMNS,3,IMAGE->DEPTH,MAGICKTRUE);
  IF (CIN.IMAGE.NUMBER_CHANNELS == 1)
    {
      QUANTUM_TYPE=GRAYQUANTUM;
      LENGTH=GETBYTESPERROW(IMAGE->COLUMNS,1,IMAGE->DEPTH,MAGICKTRUE);
    }
  STATUS=SETQUANTUMPAD(IMAGE,QUANTUM_INFO,0);
  PIXELS=GETQUANTUMPIXELS(QUANTUM_INFO);
  FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
  {
    CONST VOID
      *STREAM;

    Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
    IF (Q == (QUANTUM *) NULL)
      BREAK;
    STREAM=READBLOBSTREAM(IMAGE,LENGTH,PIXELS,&COUNT);
    IF ((SIZE_T) COUNT != LENGTH)
      BREAK;
    (VOID) IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,QUANTUM_INFO,
      QUANTUM_TYPE,(UNSIGNED CHAR *) STREAM,EXCEPTION);
    IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
      BREAK;
    IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
      {
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
          IMAGE->ROWS);
        IF (STATUS == MAGICKFALSE)
          BREAK;
      }
  }
  SETQUANTUMIMAGETYPE(IMAGE,QUANTUM_TYPE);
  QUANTUM_INFO=DESTROYQUANTUMINFO(QUANTUM_INFO);
  IF (EOFBLOB(IMAGE) != MAGICKFALSE)
    THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
      IMAGE->FILENAME);
  SETIMAGECOLORSPACE(IMAGE,LOGCOLORSPACE,EXCEPTION);
  (VOID) CLOSEBLOB(IMAGE);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225069_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SETKEEPALIVESIDLE(PGCONN *CONN)
{
	INT			IDLE;

	IF (CONN->KEEPALIVES_IDLE == NULL)
		RETURN 1;

	IF (!PARSE_INT_PARAM(CONN->KEEPALIVES_IDLE, &IDLE, CONN,
						 "KEEPALIVES_IDLE"))
		RETURN 0;
	IF (IDLE < 0)
		IDLE = 0;

#IFDEF PG_TCP_KEEPALIVE_IDLE
	IF (SETSOCKOPT(CONN->SOCK, IPPROTO_TCP, PG_TCP_KEEPALIVE_IDLE,
				   (CHAR *) &IDLE, SIZEOF(IDLE)) < 0)
	{
		CHAR		SEBUF[PG_STRERROR_R_BUFLEN];

		APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
						  LIBPQ_GETTEXT("%S(%S) FAILED: %S\N"),
						  "SETSOCKOPT",
						  PG_TCP_KEEPALIVE_IDLE_STR,
						  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
		RETURN 0;
	}
#ENDIF

	RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 279945_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LINELEN(INT *HAS_TAB)
{
    CHAR_U  *LINE;
    CHAR_U  *FIRST;
    CHAR_U  *LAST;
    INT	    SAVE;
    INT	    LEN;

    // GET THE LINE.  IF IT'S EMPTY BAIL OUT EARLY (COULD BE THE EMPTY STRING
    // FOR AN UNLOADED BUFFER).
    LINE = ML_GET_CURLINE();
    IF (*LINE == NUL)
	RETURN 0;

    // FIND THE FIRST NON-BLANK CHARACTER
    FIRST = SKIPWHITE(LINE);

    // FIND THE CHARACTER AFTER THE LAST NON-BLANK CHARACTER
    FOR (LAST = FIRST + STRLEN(FIRST);
				LAST > FIRST && VIM_ISWHITE(LAST[-1]); --LAST)
	;
    SAVE = *LAST;
    *LAST = NUL;
    LEN = LINETABSIZE(LINE);		// GET LINE LENGTH
    IF (HAS_TAB != NULL)		// CHECK FOR EMBEDDED TAB
	*HAS_TAB = (VIM_STRCHR(FIRST, TAB) != NULL);
    *LAST = SAVE;

    RETURN LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198499_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT UECC_SIGN_WITH_K(CONST UINT8_T *PRIVATE_KEY,
                            CONST UINT8_T *MESSAGE_HASH,
                            UNSIGNED HASH_SIZE,
                            UECC_WORD_T *K,
                            UINT8_T *SIGNATURE,
                            UECC_CURVE CURVE) {

    UECC_WORD_T TMP[UECC_MAX_WORDS];
    UECC_WORD_T S[UECC_MAX_WORDS];
    UECC_WORD_T *K2[2] = {TMP, S};
#IF UECC_VLI_NATIVE_LITTLE_ENDIAN
    UECC_WORD_T *P = (UECC_WORD_T *)SIGNATURE;
#ELSE
    UECC_WORD_T P[UECC_MAX_WORDS * 2];
#ENDIF
    UECC_WORD_T CARRY;
    WORDCOUNT_T NUM_WORDS = CURVE->NUM_WORDS;
    WORDCOUNT_T NUM_N_WORDS = BITS_TO_WORDS(CURVE->NUM_N_BITS);
    BITCOUNT_T NUM_N_BITS = CURVE->NUM_N_BITS;

    /* MAKE SURE 0 < K < CURVE_N */
    IF (UECC_VLI_ISZERO(K, NUM_WORDS) || UECC_VLI_CMP(CURVE->N, K, NUM_N_WORDS) != 1) {
        RETURN 0;
    }

    CARRY = REGULARIZE_K(K, TMP, S, CURVE);
    ECCPOINT_MULT(P, CURVE->G, K2[!CARRY], 0, NUM_N_BITS + 1, CURVE);
    IF (UECC_VLI_ISZERO(P, NUM_WORDS)) {
        RETURN 0;
    }

    /* IF AN RNG FUNCTION WAS SPECIFIED, GET A RANDOM NUMBER
       TO PREVENT SIDE CHANNEL ANALYSIS OF K. */
    IF (!G_RNG_FUNCTION) {
        UECC_VLI_CLEAR(TMP, NUM_N_WORDS);
        TMP[0] = 1;
    } ELSE IF (!UECC_GENERATE_RANDOM_INT(TMP, CURVE->N, NUM_N_WORDS)) {
        RETURN 0;
    }

    /* PREVENT SIDE CHANNEL ANALYSIS OF UECC_VLI_MODINV() TO DETERMINE
       BITS OF K / THE PRIVATE KEY BY PREMULTIPLYING BY A RANDOM NUMBER */
    UECC_VLI_MODMULT(K, K, TMP, CURVE->N, NUM_N_WORDS); /* K' = RAND * K */
    UECC_VLI_MODINV(K, K, CURVE->N, NUM_N_WORDS);       /* K = 1 / K' */
    UECC_VLI_MODMULT(K, K, TMP, CURVE->N, NUM_N_WORDS); /* K = 1 / K */

#IF UECC_VLI_NATIVE_LITTLE_ENDIAN == 0
    UECC_VLI_NATIVETOBYTES(SIGNATURE, CURVE->NUM_BYTES, P); /* STORE R */
#ENDIF

#IF UECC_VLI_NATIVE_LITTLE_ENDIAN
    BCOPY((UINT8_T *) TMP, PRIVATE_KEY, BITS_TO_BYTES(CURVE->NUM_N_BITS));
#ELSE
    UECC_VLI_BYTESTONATIVE(TMP, PRIVATE_KEY, BITS_TO_BYTES(CURVE->NUM_N_BITS)); /* TMP = D */
#ENDIF

    S[NUM_N_WORDS - 1] = 0;
    UECC_VLI_SET(S, P, NUM_WORDS);
    UECC_VLI_MODMULT(S, TMP, S, CURVE->N, NUM_N_WORDS); /* S = R*D */

    BITS2INT(TMP, MESSAGE_HASH, HASH_SIZE, CURVE);
    UECC_VLI_MODADD(S, TMP, S, CURVE->N, NUM_N_WORDS); /* S = E + R*D */
    UECC_VLI_MODMULT(S, S, K, CURVE->N, NUM_N_WORDS);  /* S = (E + R*D) / K */
    IF (UECC_VLI_NUMBITS(S, NUM_N_WORDS) > (BITCOUNT_T)CURVE->NUM_BYTES * 8) {
        RETURN 0;
    }
#IF UECC_VLI_NATIVE_LITTLE_ENDIAN
    BCOPY((UINT8_T *) SIGNATURE + CURVE->NUM_BYTES, (UINT8_T *) S, CURVE->NUM_BYTES);
#ELSE
    UECC_VLI_NATIVETOBYTES(SIGNATURE + CURVE->NUM_BYTES, CURVE->NUM_BYTES, S);
#ENDIF    
    RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484806_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID XENNET_TX_SETUP_GRANT(UNSIGNED LONG GFN, UNSIGNED INT OFFSET,
				  UNSIGNED INT LEN, VOID *DATA)
{
	STRUCT XENNET_GNTTAB_MAKE_TXREQ *INFO = DATA;
	UNSIGNED INT ID;
	STRUCT XEN_NETIF_TX_REQUEST *TX;
	GRANT_REF_T REF;
	/* CONVENIENT ALIASES */
	STRUCT PAGE *PAGE = INFO->PAGE;
	STRUCT NETFRONT_QUEUE *QUEUE = INFO->QUEUE;
	STRUCT SK_BUFF *SKB = INFO->SKB;

	ID = GET_ID_FROM_LIST(&QUEUE->TX_SKB_FREELIST, QUEUE->TX_LINK);
	TX = RING_GET_REQUEST(&QUEUE->TX, QUEUE->TX.REQ_PROD_PVT++);
	REF = GNTTAB_CLAIM_GRANT_REFERENCE(&QUEUE->GREF_TX_HEAD);
	WARN_ON_ONCE(IS_ERR_VALUE((UNSIGNED LONG)(INT)REF));

	GNTTAB_GRANT_FOREIGN_ACCESS_REF(REF, QUEUE->INFO->XBDEV->OTHEREND_ID,
					GFN, GNTMAP_READONLY);

	QUEUE->TX_SKBS[ID] = SKB;
	QUEUE->GRANT_TX_PAGE[ID] = PAGE;
	QUEUE->GRANT_TX_REF[ID] = REF;

	INFO->TX_LOCAL.ID = ID;
	INFO->TX_LOCAL.GREF = REF;
	INFO->TX_LOCAL.OFFSET = OFFSET;
	INFO->TX_LOCAL.SIZE = LEN;
	INFO->TX_LOCAL.FLAGS = 0;

	*TX = INFO->TX_LOCAL;

	/*
	 * PUT THE REQUEST IN THE PENDING QUEUE, IT WILL BE SET TO BE PENDING
	 * WHEN THE PRODUCER INDEX IS ABOUT TO BE RAISED.
	 */
	ADD_ID_TO_LIST(&QUEUE->TX_PEND_QUEUE, QUEUE->TX_LINK, ID);

	INFO->TX = TX;
	INFO->SIZE += INFO->TX_LOCAL.SIZE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202304_CWE-122.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FIND_MATCH_TEXT(COLNR_T STARTCOL, INT REGSTART, CHAR_U *MATCH_TEXT)
{
    COLNR_T COL = STARTCOL;
    INT	    C1, C2;
    INT	    LEN1, LEN2;
    INT	    MATCH;

    FOR (;;)
    {
	MATCH = TRUE;
	LEN2 = MB_CHAR2LEN(REGSTART); // SKIP REGSTART
	FOR (LEN1 = 0; MATCH_TEXT[LEN1] != NUL; LEN1 += MB_CHAR2LEN(C1))
	{
	    C1 = PTR2CHAR(MATCH_TEXT + LEN1);
	    C2 = PTR2CHAR(REX.LINE + COL + LEN2);
	    IF (C1 != C2 && (!REX.REG_IC || MB_CASEFOLD(C1) != MB_CASEFOLD(C2)))
	    {
		MATCH = FALSE;
		BREAK;
	    }
	    LEN2 += MB_CHAR2LEN(C2);
	}
	IF (MATCH
		// CHECK THAT NO COMPOSING CHAR FOLLOWS
		&& !(ENC_UTF8
			  && UTF_ISCOMPOSING(PTR2CHAR(REX.LINE + COL + LEN2))))
	{
	    CLEANUP_SUBEXPR();
	    IF (REG_MULTI)
	    {
		REX.REG_STARTPOS[0].LNUM = REX.LNUM;
		REX.REG_STARTPOS[0].COL = COL;
		REX.REG_ENDPOS[0].LNUM = REX.LNUM;
		REX.REG_ENDPOS[0].COL = COL + LEN2;
	    }
	    ELSE
	    {
		REX.REG_STARTP[0] = REX.LINE + COL;
		REX.REG_ENDP[0] = REX.LINE + COL + LEN2;
	    }
	    RETURN 1L;
	}

	// TRY FINDING REGSTART AFTER THE CURRENT MATCH.
	COL += MB_CHAR2LEN(REGSTART); // SKIP REGSTART
	IF (SKIP_TO_START(REGSTART, &COL) == FAIL)
	    BREAK;
    }
    RETURN 0L;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211842_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHANGE_INDENT(
    INT		TYPE,
    INT		AMOUNT,
    INT		ROUND,
    INT		REPLACED,	// REPLACED CHARACTER, PUT ON REPLACE STACK
    INT		CALL_CHANGED_BYTES)	// CALL CHANGED_BYTES()
{
    INT		VCOL;
    INT		LAST_VCOL;
    INT		INSSTART_LESS;		// REDUCTION FOR INSSTART.COL
    INT		NEW_CURSOR_COL;
    INT		I;
    CHAR_U	*PTR;
    INT		SAVE_P_LIST;
    INT		START_COL;
    COLNR_T	VC;
    COLNR_T	ORIG_COL = 0;		// INIT FOR GCC
    CHAR_U	*NEW_LINE, *ORIG_LINE = NULL;	// INIT FOR GCC

    // VREPLACE MODE NEEDS TO KNOW WHAT THE LINE WAS LIKE BEFORE CHANGING
    IF (STATE & VREPLACE_FLAG)
    {
	ORIG_LINE = VIM_STRSAVE(ML_GET_CURLINE());  // DEAL WITH NULL BELOW
	ORIG_COL = CURWIN->W_CURSOR.COL;
    }

    // FOR THE FOLLOWING TRICKS WE DON'T WANT LIST MODE
    SAVE_P_LIST = CURWIN->W_P_LIST;
    CURWIN->W_P_LIST = FALSE;
    VC = GETVCOL_NOLIST(&CURWIN->W_CURSOR);
    VCOL = VC;

    // FOR REPLACE MODE WE NEED TO FIX THE REPLACE STACK LATER, WHICH IS ONLY
    // POSSIBLE WHEN THE CURSOR IS IN THE INDENT.  REMEMBER THE NUMBER OF
    // CHARACTERS BEFORE THE CURSOR IF IT'S POSSIBLE.
    START_COL = CURWIN->W_CURSOR.COL;

    // DETERMINE OFFSET FROM FIRST NON-BLANK
    NEW_CURSOR_COL = CURWIN->W_CURSOR.COL;
    BEGINLINE(BL_WHITE);
    NEW_CURSOR_COL -= CURWIN->W_CURSOR.COL;

    INSSTART_LESS = CURWIN->W_CURSOR.COL;

    // IF THE CURSOR IS IN THE INDENT, COMPUTE HOW MANY SCREEN COLUMNS THE
    // CURSOR IS TO THE LEFT OF THE FIRST NON-BLANK.
    IF (NEW_CURSOR_COL < 0)
	VCOL = GET_INDENT() - VCOL;

    IF (NEW_CURSOR_COL > 0)	    // CAN'T FIX REPLACE STACK
	START_COL = -1;

    // SET THE NEW INDENT.  THE CURSOR WILL BE PUT ON THE FIRST NON-BLANK.
    IF (TYPE == INDENT_SET)
	(VOID)SET_INDENT(AMOUNT, CALL_CHANGED_BYTES ? SIN_CHANGED : 0);
    ELSE
    {
	INT	SAVE_STATE = STATE;

	// AVOID BEING CALLED RECURSIVELY.
	IF (STATE & VREPLACE_FLAG)
	    STATE = INSERT;
	SHIFT_LINE(TYPE == INDENT_DEC, ROUND, 1, CALL_CHANGED_BYTES);
	STATE = SAVE_STATE;
    }
    INSSTART_LESS -= CURWIN->W_CURSOR.COL;

    // TRY TO PUT CURSOR ON SAME CHARACTER.
    // IF THE CURSOR IS AT OR AFTER THE FIRST NON-BLANK IN THE LINE,
    // COMPUTE THE CURSOR COLUMN RELATIVE TO THE COLUMN OF THE FIRST
    // NON-BLANK CHARACTER.
    // IF WE ARE NOT IN INSERT MODE, LEAVE THE CURSOR ON THE FIRST NON-BLANK.
    // IF THE CURSOR IS BEFORE THE FIRST NON-BLANK, POSITION IT RELATIVE
    // TO THE FIRST NON-BLANK, COUNTED IN SCREEN COLUMNS.
    IF (NEW_CURSOR_COL >= 0)
    {
	// WHEN CHANGING THE INDENT WHILE THE CURSOR IS TOUCHING IT, RESET
	// INSSTART_COL TO 0.
	IF (NEW_CURSOR_COL == 0)
	    INSSTART_LESS = MAXCOL;
	NEW_CURSOR_COL += CURWIN->W_CURSOR.COL;
    }
    ELSE IF (!(STATE & INSERT))
	NEW_CURSOR_COL = CURWIN->W_CURSOR.COL;
    ELSE
    {
	// COMPUTE THE SCREEN COLUMN WHERE THE CURSOR SHOULD BE.
	VCOL = GET_INDENT() - VCOL;
	CURWIN->W_VIRTCOL = (COLNR_T)((VCOL < 0) ? 0 : VCOL);

	// ADVANCE THE CURSOR UNTIL WE REACH THE RIGHT SCREEN COLUMN.
	VCOL = LAST_VCOL = 0;
	NEW_CURSOR_COL = -1;
	PTR = ML_GET_CURLINE();
	WHILE (VCOL <= (INT)CURWIN->W_VIRTCOL)
	{
	    LAST_VCOL = VCOL;
	    IF (HAS_MBYTE && NEW_CURSOR_COL >= 0)
		NEW_CURSOR_COL += (*MB_PTR2LEN)(PTR + NEW_CURSOR_COL);
	    ELSE
		++NEW_CURSOR_COL;
	    VCOL += LBR_CHARTABSIZE(PTR, PTR + NEW_CURSOR_COL, (COLNR_T)VCOL);
	}
	VCOL = LAST_VCOL;

	// MAY NEED TO INSERT SPACES TO BE ABLE TO POSITION THE CURSOR ON
	// THE RIGHT SCREEN COLUMN.
	IF (VCOL != (INT)CURWIN->W_VIRTCOL)
	{
	    CURWIN->W_CURSOR.COL = (COLNR_T)NEW_CURSOR_COL;
	    I = (INT)CURWIN->W_VIRTCOL - VCOL;
	    PTR = ALLOC(I + 1);
	    IF (PTR != NULL)
	    {
		NEW_CURSOR_COL += I;
		PTR[I] = NUL;
		WHILE (--I >= 0)
		    PTR[I] = ' ';
		INS_STR(PTR);
		VIM_FREE(PTR);
	    }
	}

	// WHEN CHANGING THE INDENT WHILE THE CURSOR IS IN IT, RESET
	// INSSTART_COL TO 0.
	INSSTART_LESS = MAXCOL;
    }

    CURWIN->W_P_LIST = SAVE_P_LIST;

    IF (NEW_CURSOR_COL <= 0)
	CURWIN->W_CURSOR.COL = 0;
    ELSE
	CURWIN->W_CURSOR.COL = (COLNR_T)NEW_CURSOR_COL;
    CURWIN->W_SET_CURSWANT = TRUE;
    CHANGED_CLINE_BEF_CURS();

    // MAY HAVE TO ADJUST THE START OF THE INSERT.
    IF (STATE & INSERT)
    {
	IF (CURWIN->W_CURSOR.LNUM == INSSTART.LNUM && INSSTART.COL != 0)
	{
	    IF ((INT)INSSTART.COL <= INSSTART_LESS)
		INSSTART.COL = 0;
	    ELSE
		INSSTART.COL -= INSSTART_LESS;
	}
	IF ((INT)AI_COL <= INSSTART_LESS)
	    AI_COL = 0;
	ELSE
	    AI_COL -= INSSTART_LESS;
    }

    // FOR REPLACE MODE, MAY HAVE TO FIX THE REPLACE STACK, IF IT'S POSSIBLE.
    // IF THE NUMBER OF CHARACTERS BEFORE THE CURSOR DECREASED, NEED TO POP A
    // FEW CHARACTERS FROM THE REPLACE STACK.
    // IF THE NUMBER OF CHARACTERS BEFORE THE CURSOR INCREASED, NEED TO PUSH A
    // FEW NULS ONTO THE REPLACE STACK.
    IF (REPLACE_NORMAL(STATE) && START_COL >= 0)
    {
	WHILE (START_COL > (INT)CURWIN->W_CURSOR.COL)
	{
	    REPLACE_JOIN(0);	    // REMOVE A NUL FROM THE REPLACE STACK
	    --START_COL;
	}
	WHILE (START_COL < (INT)CURWIN->W_CURSOR.COL || REPLACED)
	{
	    REPLACE_PUSH(NUL);
	    IF (REPLACED)
	    {
		REPLACE_PUSH(REPLACED);
		REPLACED = NUL;
	    }
	    ++START_COL;
	}
    }

    // FOR VREPLACE MODE, WE ALSO HAVE TO FIX THE REPLACE STACK.  IN THIS CASE
    // IT IS ALWAYS POSSIBLE BECAUSE WE BACKSPACE OVER THE WHOLE LINE AND THEN
    // PUT IT BACK AGAIN THE WAY WE WANTED IT.
    IF (STATE & VREPLACE_FLAG)
    {
	// IF ORIG_LINE DIDN'T ALLOCATE, JUST RETURN.  AT LEAST WE DID THE JOB,
	// EVEN IF YOU CAN'T BACKSPACE.
	IF (ORIG_LINE == NULL)
	    RETURN;

	// SAVE NEW LINE
	NEW_LINE = VIM_STRSAVE(ML_GET_CURLINE());
	IF (NEW_LINE == NULL)
	    RETURN;

	// WE ONLY PUT BACK THE NEW LINE UP TO THE CURSOR
	NEW_LINE[CURWIN->W_CURSOR.COL] = NUL;

	// PUT BACK ORIGINAL LINE
	ML_REPLACE(CURWIN->W_CURSOR.LNUM, ORIG_LINE, FALSE);
	CURWIN->W_CURSOR.COL = ORIG_COL;

	// BACKSPACE FROM CURSOR TO START OF LINE
	BACKSPACE_UNTIL_COLUMN(0);

	// INSERT NEW STUFF INTO LINE AGAIN
	INS_BYTES(NEW_LINE);

	VIM_FREE(NEW_LINE);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211090_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ADD_MTAB(CHAR *DEVNAME, CHAR *MOUNTPOINT, UNSIGNED LONG FLAGS, CONST CHAR *FSTYPE)
{
	INT RC = 0;
	UID_T UID;
	CHAR *MOUNT_USER = NULL;
	STRUCT MNTENT MOUNTENT;
	FILE *PMNTFILE;
	SIGSET_T MASK, OLDMASK;

	UID = GETUID();
	IF (UID != 0)
		MOUNT_USER = GETUSERNAME(UID);

	/*
	 * SET THE REAL UID TO THE EFFECTIVE UID. THIS PREVENTS UNPRIVILEGED
	 * USERS FROM SENDING SIGNALS TO THIS PROCESS, THOUGH ^C ON CONTROLLING
	 * TERMINAL SHOULD STILL WORK.
	 */
	RC = SETREUID(GETEUID(), -1);
	IF (RC != 0) {
		FPRINTF(STDERR, "UNABLE TO SET REAL UID TO EFFECTIVE UID: %S\N",
				STRERROR(ERRNO));
		RETURN EX_FILEIO;
	}

	RC = SIGFILLSET(&MASK);
	IF (RC) {
		FPRINTF(STDERR, "UNABLE TO SET FILLED SIGNAL MASK\N");
		RETURN EX_FILEIO;
	}

	RC = SIGPROCMASK(SIG_SETMASK, &MASK, &OLDMASK);
	IF (RC) {
		FPRINTF(STDERR, "UNABLE TO MAKE PROCESS IGNORE SIGNALS\N");
		RETURN EX_FILEIO;
	}

	RC = TOGGLE_DAC_CAPABILITY(1, 1);
	IF (RC)
		RETURN EX_FILEIO;

	ATEXIT(UNLOCK_MTAB);
	RC = LOCK_MTAB();
	IF (RC) {
		FPRINTF(STDERR, "CANNOT LOCK MTAB");
		RC = EX_FILEIO;
		GOTO ADD_MTAB_EXIT;
	}

	PMNTFILE = SETMNTENT(MOUNTED, "A+");
	IF (!PMNTFILE) {
		FPRINTF(STDERR, "COULD NOT UPDATE MOUNT TABLE\N");
		UNLOCK_MTAB();
		RC = EX_FILEIO;
		GOTO ADD_MTAB_EXIT;
	}

	MOUNTENT.MNT_FSNAME = DEVNAME;
	MOUNTENT.MNT_DIR = MOUNTPOINT;
	MOUNTENT.MNT_TYPE = (CHAR *)(VOID *)FSTYPE;
	MOUNTENT.MNT_OPTS = (CHAR *)CALLOC(MTAB_OPTIONS_LEN, 1);
	IF (MOUNTENT.MNT_OPTS) {
		IF (FLAGS & MS_RDONLY)
			STRLCAT(MOUNTENT.MNT_OPTS, "RO", MTAB_OPTIONS_LEN);
		ELSE
			STRLCAT(MOUNTENT.MNT_OPTS, "RW", MTAB_OPTIONS_LEN);

		IF (FLAGS & MS_MANDLOCK)
			STRLCAT(MOUNTENT.MNT_OPTS, ",MAND", MTAB_OPTIONS_LEN);
		IF (FLAGS & MS_NOEXEC)
			STRLCAT(MOUNTENT.MNT_OPTS, ",NOEXEC", MTAB_OPTIONS_LEN);
		IF (FLAGS & MS_NOSUID)
			STRLCAT(MOUNTENT.MNT_OPTS, ",NOSUID", MTAB_OPTIONS_LEN);
		IF (FLAGS & MS_NODEV)
			STRLCAT(MOUNTENT.MNT_OPTS, ",NODEV", MTAB_OPTIONS_LEN);
		IF (FLAGS & MS_SYNCHRONOUS)
			STRLCAT(MOUNTENT.MNT_OPTS, ",SYNC", MTAB_OPTIONS_LEN);
		IF (MOUNT_USER) {
			STRLCAT(MOUNTENT.MNT_OPTS, ",USER=", MTAB_OPTIONS_LEN);
			STRLCAT(MOUNTENT.MNT_OPTS, MOUNT_USER,
				MTAB_OPTIONS_LEN);
		}
	}
	MOUNTENT.MNT_FREQ = 0;
	MOUNTENT.MNT_PASSNO = 0;
	RC = ADDMNTENT(PMNTFILE, &MOUNTENT);
	IF (RC) {
		FPRINTF(STDERR, "UNABLE TO ADD MOUNT ENTRY TO MTAB\N");
		RC = EX_FILEIO;
	}
	ENDMNTENT(PMNTFILE);
	UNLOCK_MTAB();
	SAFE_FREE(MOUNTENT.MNT_OPTS);
ADD_MTAB_EXIT:
	TOGGLE_DAC_CAPABILITY(1, 0);
	SIGPROCMASK(SIG_SETMASK, &OLDMASK, NULL);

	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 221518_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FLATPAK_RUN_ADD_X11_ARGS (FLATPAKBWRAP *BWRAP,
                          GBOOLEAN      ALLOWED)
{
  G_AUTOFREE CHAR *X11_SOCKET = NULL;
  CONST CHAR *DISPLAY;

  /* ALWAYS COVER /TMP/.X11-UNIX, THAT WAY WE NEVER SEE THE HOST ONE IN CASE
   * WE HAVE ACCESS TO THE HOST /TMP. IF YOU REQUEST X ACCESS WE'LL PUT THE RIGHT
   * THING IN THIS ANYWAY.
   *
   * WE NEED TO BE A BIT CAREFUL HERE, BECAUSE THERE ARE TWO SITUATIONS IN
   * WHICH POTENTIALLY HOSTILE PROCESSES HAVE ACCESS TO /TMP AND COULD
   * CREATE SYMLINKS, WHICH IN PRINCIPLE COULD CAUSE US TO CREATE THE
   * DIRECTORY AND MOUNT THE TMPFS AT THE TARGET OF THE SYMLINK INSTEAD
   * OF IN THE INTENDED PLACE:
   *
   * - WITH --FILESYSTEM=/TMP, IT'S THE HOST /TMP - BUT BECAUSE OF THE
   *   SPECIAL HISTORICAL STATUS OF /TMP/.X11-UNIX, WE CAN ASSUME THAT
   *   IT IS PRE-CREATED BY THE HOST SYSTEM BEFORE USER CODE GETS TO RUN.
   *
   * - WHEN /TMP IS SHARED BETWEEN ALL INSTANCES OF THE SAME APP ID,
   *   IN PRINCIPLE THE APP HAS CONTROL OVER WHAT'S IN /TMP, BUT IN
   *   PRACTICE IT CAN'T INTERFERE WITH /TMP/.X11-UNIX, BECAUSE WE DO
   *   THIS UNCONDITIONALLY - THEREFORE BY THE TIME APP CODE RUNS,
   *   /TMP/.X11-UNIX IS ALREADY A MOUNT POINT, MEANING THE APP CANNOT
   *   RENAME OR DELETE IT.
   */
  FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                          "--TMPFS", "/TMP/.X11-UNIX",
                          NULL);

  IF (!ALLOWED)
    {
      FLATPAK_BWRAP_UNSET_ENV (BWRAP, "DISPLAY");
      RETURN;
    }

  G_DEBUG ("ALLOWING X11 ACCESS");

  DISPLAY = G_GETENV ("DISPLAY");
  IF (DISPLAY && DISPLAY[0] == ':' && G_ASCII_ISDIGIT (DISPLAY[1]))
    {
      CONST CHAR *DISPLAY_NR = &DISPLAY[1];
      CONST CHAR *DISPLAY_NR_END = DISPLAY_NR;
      G_AUTOFREE CHAR *D = NULL;

      WHILE (G_ASCII_ISDIGIT (*DISPLAY_NR_END))
        DISPLAY_NR_END++;

      D = G_STRNDUP (DISPLAY_NR, DISPLAY_NR_END - DISPLAY_NR);
      X11_SOCKET = G_STRDUP_PRINTF ("/TMP/.X11-UNIX/X%S", D);

      FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                              "--RO-BIND", X11_SOCKET, "/TMP/.X11-UNIX/X99",
                              NULL);
      FLATPAK_BWRAP_SET_ENV (BWRAP, "DISPLAY", ":99.0", TRUE);

#IFDEF ENABLE_XAUTH
      G_AUTO(GLNXTMPFILE) XAUTH_TMPF  = { 0, };

      IF (GLNX_OPEN_ANONYMOUS_TMPFILE_FULL (O_RDWR | O_CLOEXEC, "/TMP", &XAUTH_TMPF, NULL))
        {
          FILE *OUTPUT = FDOPEN (XAUTH_TMPF.FD, "WB");
          IF (OUTPUT != NULL)
            {
              /* FD IS NOW OWNED BY OUTPUT, STEAL IT FROM THE TMPFILE */
              INT TMP_FD = DUP (GLNX_STEAL_FD (&XAUTH_TMPF.FD));
              IF (TMP_FD != -1)
                {
                  STATIC CONST CHAR DEST[] = "/RUN/FLATPAK/XAUTHORITY";

                  WRITE_XAUTH (D, OUTPUT);
                  FLATPAK_BWRAP_ADD_ARGS_DATA_FD (BWRAP, "--RO-BIND-DATA", TMP_FD, DEST);

                  FLATPAK_BWRAP_SET_ENV (BWRAP, "XAUTHORITY", DEST, TRUE);
                }

              FCLOSE (OUTPUT);

              IF (TMP_FD != -1)
                LSEEK (TMP_FD, 0, SEEK_SET);
            }
        }
#ENDIF
    }
  ELSE
    {
      FLATPAK_BWRAP_UNSET_ENV (BWRAP, "DISPLAY");
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 221514_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FLATPAK_RUN_ADD_ENVIRONMENT_ARGS (FLATPAKBWRAP    *BWRAP,
                                  CONST CHAR      *APP_INFO_PATH,
                                  FLATPAKRUNFLAGS  FLAGS,
                                  CONST CHAR      *APP_ID,
                                  FLATPAKCONTEXT  *CONTEXT,
                                  GFILE           *APP_ID_DIR,
                                  GPTRARRAY       *PREVIOUS_APP_ID_DIRS,
                                  INT              PER_APP_DIR_LOCK_FD,
                                  FLATPAKEXPORTS **EXPORTS_OUT,
                                  GCANCELLABLE    *CANCELLABLE,
                                  GERROR         **ERROR)
{
  G_AUTOPTR(GERROR) MY_ERROR = NULL;
  G_AUTOPTR(FLATPAKEXPORTS) EXPORTS = NULL;
  G_AUTOPTR(FLATPAKBWRAP) PROXY_ARG_BWRAP = FLATPAK_BWRAP_NEW (FLATPAK_BWRAP_EMPTY_ENV);
  G_AUTOFREE CHAR *XDG_DIRS_CONF = NULL;
  GBOOLEAN HAS_WAYLAND = FALSE;
  GBOOLEAN ALLOW_X11 = FALSE;
  GBOOLEAN HOME_ACCESS = FALSE;
  GBOOLEAN SANDBOXED = (FLAGS & FLATPAK_RUN_FLAG_SANDBOX) != 0;

  IF ((CONTEXT->SHARES & FLATPAK_CONTEXT_SHARED_IPC) == 0)
    {
      G_DEBUG ("DISALLOWING IPC ACCESS");
      FLATPAK_BWRAP_ADD_ARGS (BWRAP, "--UNSHARE-IPC", NULL);
    }

  IF ((CONTEXT->SHARES & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)
    {
      G_DEBUG ("DISALLOWING NETWORK ACCESS");
      FLATPAK_BWRAP_ADD_ARGS (BWRAP, "--UNSHARE-NET", NULL);
    }

  IF (CONTEXT->DEVICES & FLATPAK_CONTEXT_DEVICE_ALL)
    {
      FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                              "--DEV-BIND", "/DEV", "/DEV",
                              NULL);
      /* DON'T EXPOSE THE HOST /DEV/SHM, JUST THE DEVICE NODES, UNLESS EXPLICITLY ALLOWED */
      IF (G_FILE_TEST ("/DEV/SHM", G_FILE_TEST_IS_DIR))
        {
          IF (CONTEXT->DEVICES & FLATPAK_CONTEXT_DEVICE_SHM)
            {
              /* DON'T DO ANYTHING SPECIAL: INCLUDE SHM IN THE
               * SHARED /DEV. THE HOST AND ALL SANDBOXES AND SUBSANDBOXES
               * ALL SHARE /DEV/SHM */
            }
          ELSE IF ((CONTEXT->FEATURES & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)
                   && PER_APP_DIR_LOCK_FD >= 0)
            {
              G_AUTOFREE CHAR *SHARED_DEV_SHM = NULL;

              /* THE HOST AND THE ORIGINAL SANDBOX HAVE SEPARATE /DEV/SHM,
               * BUT WE WANT OTHER INSTANCES TO BE ABLE TO SHARE /DEV/SHM WITH
               * THE FIRST SANDBOX (EXCEPT FOR SUBSANDBOXES RUN WITH
               * FLATPAK-SPAWN --SANDBOX, WHICH WILL HAVE THEIR OWN). */
              IF (!FLATPAK_INSTANCE_ENSURE_PER_APP_DEV_SHM (APP_ID,
                                                            PER_APP_DIR_LOCK_FD,
                                                            &SHARED_DEV_SHM,
                                                            ERROR))
                RETURN FALSE;

              FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                                      "--BIND", SHARED_DEV_SHM, "/DEV/SHM",
                                      NULL);
            }
          ELSE
            {
              /* THE HOST, THE ORIGINAL SANDBOX AND EACH SUBSANDBOX
               * EACH HAVE A SEPARATE /DEV/SHM. */
              FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                                      "--TMPFS", "/DEV/SHM",
                                      NULL);
            }
        }
      ELSE IF (G_FILE_TEST ("/DEV/SHM", G_FILE_TEST_IS_SYMLINK))
        {
          G_AUTOFREE CHAR *LINK = FLATPAK_READLINK ("/DEV/SHM", NULL);

          /* ON DEBIAN (WITH SYSV INIT) THE HOST /DEV/SHM IS A SYMLINK TO /RUN/SHM, SO WE CAN'T
             MOUNT ON TOP OF IT. */
          IF (G_STRCMP0 (LINK, "/RUN/SHM") == 0)
            {
              IF (CONTEXT->DEVICES & FLATPAK_CONTEXT_DEVICE_SHM &&
                  G_FILE_TEST ("/RUN/SHM", G_FILE_TEST_IS_DIR))
                {
                  FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                                          "--BIND", "/RUN/SHM", "/RUN/SHM",
                                          NULL);
                }
              ELSE IF ((CONTEXT->FEATURES & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)
                       && PER_APP_DIR_LOCK_FD >= 0)
                {
                  G_AUTOFREE CHAR *SHARED_DEV_SHM = NULL;

                  /* THE HOST AND THE ORIGINAL SANDBOX HAVE SEPARATE /DEV/SHM,
                   * BUT WE WANT OTHER INSTANCES TO BE ABLE TO SHARE /DEV/SHM,
                   * EXCEPT FOR FLATPAK-SPAWN --SUBSANDBOX. */
                  IF (!FLATPAK_INSTANCE_ENSURE_PER_APP_DEV_SHM (APP_ID,
                                                                PER_APP_DIR_LOCK_FD,
                                                                &SHARED_DEV_SHM,
                                                                ERROR))
                    RETURN FALSE;

                  FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                                          "--BIND", SHARED_DEV_SHM, "/RUN/SHM",
                                          NULL);
                }
              ELSE
                {
                  FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                                          "--DIR", "/RUN/SHM",
                                          NULL);
                }
            }
          ELSE
            G_WARNING ("UNEXPECTED /DEV/SHM SYMLINK %S", LINK);
        }
    }
  ELSE
    {
      FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                              "--DEV", "/DEV",
                              NULL);
      IF (CONTEXT->DEVICES & FLATPAK_CONTEXT_DEVICE_DRI)
        {
          G_DEBUG ("ALLOWING DRI ACCESS");
          INT I;
          CHAR *DRI_DEVICES[] = {
            "/DEV/DRI",
            /* MALI */
            "/DEV/MALI",
            "/DEV/MALI0",
            "/DEV/UMPLOCK",
            /* NVIDIA */
            "/DEV/NVIDIACTL",
            "/DEV/NVIDIA-MODESET",
            /* NVIDIA OPENCL/CUDA */
            "/DEV/NVIDIA-UVM",
            "/DEV/NVIDIA-UVM-TOOLS",
          };

          FOR (I = 0; I < G_N_ELEMENTS (DRI_DEVICES); I++)
            {
              IF (G_FILE_TEST (DRI_DEVICES[I], G_FILE_TEST_EXISTS))
                FLATPAK_BWRAP_ADD_ARGS (BWRAP, "--DEV-BIND", DRI_DEVICES[I], DRI_DEVICES[I], NULL);
            }

          /* EACH NVIDIA CARD GETS ITS OWN DEVICE.
             THIS IS A FAIRLY ARBITRARY LIMIT BUT ASUS SELLS MINING BOARDS SUPPORTING 20 IN THEORY. */
          CHAR NVIDIA_DEV[14]; /* /DEV/NVIDIA PLUS UP TO 2 DIGITS */
          FOR (I = 0; I < 20; I++)
            {
              G_SNPRINTF (NVIDIA_DEV, SIZEOF (NVIDIA_DEV), "/DEV/NVIDIA%D", I);
              IF (G_FILE_TEST (NVIDIA_DEV, G_FILE_TEST_EXISTS))
                FLATPAK_BWRAP_ADD_ARGS (BWRAP, "--DEV-BIND", NVIDIA_DEV, NVIDIA_DEV, NULL);
            }
        }

      IF (CONTEXT->DEVICES & FLATPAK_CONTEXT_DEVICE_KVM)
        {
          G_DEBUG ("ALLOWING KVM ACCESS");
          IF (G_FILE_TEST ("/DEV/KVM", G_FILE_TEST_EXISTS))
            FLATPAK_BWRAP_ADD_ARGS (BWRAP, "--DEV-BIND", "/DEV/KVM", "/DEV/KVM", NULL);
        }

      IF (CONTEXT->DEVICES & FLATPAK_CONTEXT_DEVICE_SHM)
        {
          /* THIS IS A SYMLINK TO /RUN/SHM ON DEBIAN, SO BIND TO REAL TARGET */
          G_AUTOFREE CHAR *REAL_DEV_SHM = REALPATH ("/DEV/SHM", NULL);

          G_DEBUG ("ALLOWING /DEV/SHM ACCESS (AS %S)", REAL_DEV_SHM);
          IF (REAL_DEV_SHM != NULL)
              FLATPAK_BWRAP_ADD_ARGS (BWRAP, "--BIND", REAL_DEV_SHM, "/DEV/SHM", NULL);
        }
      ELSE IF ((CONTEXT->FEATURES & FLATPAK_CONTEXT_FEATURE_PER_APP_DEV_SHM)
               && PER_APP_DIR_LOCK_FD >= 0)
        {
          G_AUTOFREE CHAR *SHARED_DEV_SHM = NULL;

          IF (!FLATPAK_INSTANCE_ENSURE_PER_APP_DEV_SHM (APP_ID,
                                                        PER_APP_DIR_LOCK_FD,
                                                        &SHARED_DEV_SHM,
                                                        ERROR))
            RETURN FALSE;

          FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                                  "--BIND", SHARED_DEV_SHM, "/DEV/SHM",
                                  NULL);
        }
    }

  EXPORTS = FLATPAK_CONTEXT_GET_EXPORTS_FULL (CONTEXT,
                                              APP_ID_DIR, PREVIOUS_APP_ID_DIRS,
                                              TRUE, TRUE,
                                              &XDG_DIRS_CONF, &HOME_ACCESS);

  IF (FLATPAK_EXPORTS_PATH_IS_VISIBLE (EXPORTS, "/TMP"))
    {
      /* THE ORIGINAL SANDBOX AND ANY SUBSANDBOXES ARE BOTH ALREADY
       * GOING TO SHARE /TMP WITH THE HOST, SO BY TRANSITIVITY THEY WILL
       * ALSO SHARE IT WITH EACH OTHER, AND WITH ALL OTHER INSTANCES. */
    }
  ELSE IF (PER_APP_DIR_LOCK_FD >= 0 && !SANDBOXED)
    {
      G_AUTOFREE CHAR *SHARED_TMP = NULL;

      /* THE HOST AND THE ORIGINAL SANDBOX HAVE SEPARATE /TMP,
       * BUT WE WANT OTHER INSTANCES TO BE ABLE TO SHARE /TMP WITH THE
       * FIRST SANDBOX, UNLESS THEY WERE CREATED BY
       * FLATPAK-SPAWN --SANDBOX.
       *
       * IN APPLY_EXTRA AND `FLATPAK BUILD`, PER_APP_DIR_LOCK_FD IS
       * NEGATIVE AND WE SKIP THIS. */
      IF (!FLATPAK_INSTANCE_ENSURE_PER_APP_TMP (APP_ID,
                                                PER_APP_DIR_LOCK_FD,
                                                &SHARED_TMP,
                                                ERROR))
        RETURN FALSE;

      FLATPAK_BWRAP_ADD_ARGS (BWRAP,
                              "--BIND", SHARED_TMP, "/TMP",
                              NULL);
    }

  FLATPAK_CONTEXT_APPEND_BWRAP_FILESYSTEM (CONTEXT, BWRAP, APP_ID, APP_ID_DIR,
                                           EXPORTS, XDG_DIRS_CONF, HOME_ACCESS);

  IF (CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_WAYLAND)
    {
      G_DEBUG ("ALLOWING WAYLAND ACCESS");
      HAS_WAYLAND = FLATPAK_RUN_ADD_WAYLAND_ARGS (BWRAP);
    }

  IF ((CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)
    ALLOW_X11 = !HAS_WAYLAND;
  ELSE
    ALLOW_X11 = (CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_X11) != 0;

  FLATPAK_RUN_ADD_X11_ARGS (BWRAP, ALLOW_X11);

  IF (CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)
    {
      FLATPAK_RUN_ADD_SSH_ARGS (BWRAP);
    }

  IF (CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)
    {
      G_DEBUG ("ALLOWING PULSEAUDIO ACCESS");
      FLATPAK_RUN_ADD_PULSEAUDIO_ARGS (BWRAP);
    }

  IF (CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_PCSC)
    {
      FLATPAK_RUN_ADD_PCSC_ARGS (BWRAP);
    }

  IF (CONTEXT->SOCKETS & FLATPAK_CONTEXT_SOCKET_CUPS)
    {
      FLATPAK_RUN_ADD_CUPS_ARGS (BWRAP);
    }

  FLATPAK_RUN_ADD_SESSION_DBUS_ARGS (BWRAP, PROXY_ARG_BWRAP, CONTEXT, FLAGS, APP_ID);
  FLATPAK_RUN_ADD_SYSTEM_DBUS_ARGS (BWRAP, PROXY_ARG_BWRAP, CONTEXT, FLAGS);
  FLATPAK_RUN_ADD_A11Y_DBUS_ARGS (BWRAP, PROXY_ARG_BWRAP, CONTEXT, FLAGS);

  /* MUST RUN THIS BEFORE SPAWNING THE DBUS PROXY, TO ENSURE IT
     ENDS UP IN THE APP CGROUP */
  IF (!FLATPAK_RUN_IN_TRANSIENT_UNIT (APP_ID, &MY_ERROR))
    {
      /* WE STILL RUN ALONG EVEN IF WE DON'T GET A CGROUP, AS NOTHING
         REALLY DEPENDS ON IT. ITS JUST NICE TO HAVE */
      G_DEBUG ("FAILED TO RUN IN TRANSIENT SCOPE: %S", MY_ERROR->MESSAGE);
      G_CLEAR_ERROR (&MY_ERROR);
    }

  IF (!FLATPAK_BWRAP_IS_EMPTY (PROXY_ARG_BWRAP) &&
      !START_DBUS_PROXY (BWRAP, PROXY_ARG_BWRAP, APP_INFO_PATH, ERROR))
    RETURN FALSE;

  IF (EXPORTS_OUT)
    *EXPORTS_OUT = G_STEAL_POINTER (&EXPORTS);

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244187_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID CTRN_WRITE_SAMPLE_FLAGS(GF_BITSTREAM *BS, U32 FLAGS, U32 FIELD_SIZE)
{
	IF (!FIELD_SIZE) RETURN;

	IF (FIELD_SIZE==8) FLAGS = FLAGS>>24;
	ELSE IF (FIELD_SIZE==16) FLAGS = FLAGS>>16;
	GF_BS_WRITE_INT(BS, FLAGS, FIELD_SIZE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205630_CWE-94.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IO_RW_INIT_FILE(STRUCT IO_KIOCB *REQ, FMODE_T MODE)
{
	STRUCT KIOCB *KIOCB = &REQ->RW.KIOCB;
	STRUCT IO_RING_CTX *CTX = REQ->CTX;
	STRUCT FILE *FILE = REQ->FILE;
	INT RET;

	IF (UNLIKELY(!FILE || !(FILE->F_MODE & MODE)))
		RETURN -EBADF;

	IF (!IO_REQ_FFS_SET(REQ))
		REQ->FLAGS |= IO_FILE_GET_FLAGS(FILE) << REQ_F_SUPPORT_NOWAIT_BIT;

	KIOCB->KI_FLAGS = IOCB_FLAGS(FILE);
	RET = KIOCB_SET_RW_FLAGS(KIOCB, REQ->RW.FLAGS);
	IF (UNLIKELY(RET))
		RETURN RET;

	/*
	 * IF THE FILE IS MARKED O_NONBLOCK, STILL ALLOW RETRY FOR IT IF IT
	 * SUPPORTS ASYNC. OTHERWISE IT'S IMPOSSIBLE TO USE O_NONBLOCK FILES
	 * RELIABLY. IF NOT, OR IT IOCB_NOWAIT IS SET, DON'T RETRY.
	 */
	IF ((KIOCB->KI_FLAGS & IOCB_NOWAIT) ||
	    ((FILE->F_FLAGS & O_NONBLOCK) && !IO_FILE_SUPPORTS_NOWAIT(REQ)))
		REQ->FLAGS |= REQ_F_NOWAIT;

	IF (CTX->FLAGS & IORING_SETUP_IOPOLL) {
		IF (!(KIOCB->KI_FLAGS & IOCB_DIRECT) || !FILE->F_OP->IOPOLL)
			RETURN -EOPNOTSUPP;

		KIOCB->KI_FLAGS |= IOCB_HIPRI | IOCB_ALLOC_CACHE;
		KIOCB->KI_COMPLETE = IO_COMPLETE_RW_IOPOLL;
		REQ->IOPOLL_COMPLETED = 0;
	} ELSE {
		IF (KIOCB->KI_FLAGS & IOCB_HIPRI)
			RETURN -EINVAL;
		KIOCB->KI_COMPLETE = IO_COMPLETE_RW;
	}

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201007_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PRINT_MEDIA_DESC(CONST PJMEDIA_SDP_MEDIA *M, CHAR *BUF, PJ_SIZE_T LEN)
{
    CHAR *P = BUF;
    CHAR *END = BUF+LEN;
    UNSIGNED I;
    INT PRINTED;

    /* CHECK LENGTH FOR THE "M=" LINE. */
    IF (LEN < (PJ_SIZE_T)M->DESC.MEDIA.SLEN+M->DESC.TRANSPORT.SLEN+12+24) {
	RETURN -1;
    }
    *P++ = 'M';	    /* M= */
    *P++ = '=';
    PJ_MEMCPY(P, M->DESC.MEDIA.PTR, M->DESC.MEDIA.SLEN);
    P += M->DESC.MEDIA.SLEN;
    *P++ = ' ';
    PRINTED = PJ_UTOA(M->DESC.PORT, P);
    P += PRINTED;
    IF (M->DESC.PORT_COUNT > 1) {
	*P++ = '/';
	PRINTED = PJ_UTOA(M->DESC.PORT_COUNT, P);
	P += PRINTED;
    }
    *P++ = ' ';
    PJ_MEMCPY(P, M->DESC.TRANSPORT.PTR, M->DESC.TRANSPORT.SLEN);
    P += M->DESC.TRANSPORT.SLEN;
    FOR (I=0; I<M->DESC.FMT_COUNT; ++I) {
	*P++ = ' ';
	PJ_MEMCPY(P, M->DESC.FMT[I].PTR, M->DESC.FMT[I].SLEN);
	P += M->DESC.FMT[I].SLEN;
    }
    *P++ = '\R';
    *P++ = '\N';

    /* PRINT CONNECTION INFO, IF PRESENT. */
    IF (M->CONN) {
	PRINTED = PRINT_CONNECTION_INFO(M->CONN, P, (INT)(END-P));
	IF (PRINTED < 0) {
	    RETURN -1;
	}
	P += PRINTED;
    }
    
    /* PRINT OPTIONAL BANDWIDTH INFO. */
    FOR (I=0; I<M->BANDW_COUNT; ++I) {
	PRINTED = (INT)PRINT_BANDW(M->BANDW[I], P, END-P);
	IF (PRINTED < 0) {
	    RETURN -1;
	}
	P += PRINTED;
    }

    /* PRINT ATTRIBUTES. */
    FOR (I=0; I<M->ATTR_COUNT; ++I) {
	PRINTED = (INT)PRINT_ATTR(M->ATTR[I], P, END-P);
	IF (PRINTED < 0) {
	    RETURN -1;
	}
	P += PRINTED;
    }

    RETURN (INT)(P-BUF);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512847_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  CONST TYPE_HANDLER *REAL_TYPE_HANDLER() CONST
  {
    // SHOULD NOT BE CALLED, ITEM_BLOB IS USED FOR SHOW PURPOSES ONLY.
    DBUG_ASSERT(0);
    RETURN &TYPE_HANDLER_VARCHAR;
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200695_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT FASTRPC_DMA_BUF_ATTACH(STRUCT DMA_BUF *DMABUF,
				  STRUCT DMA_BUF_ATTACHMENT *ATTACHMENT)
{
	STRUCT FASTRPC_DMA_BUF_ATTACHMENT *A;
	STRUCT FASTRPC_BUF *BUFFER = DMABUF->PRIV;
	INT RET;

	A = KZALLOC(SIZEOF(*A), GFP_KERNEL);
	IF (!A)
		RETURN -ENOMEM;

	RET = DMA_GET_SGTABLE(BUFFER->DEV, &A->SGT, BUFFER->VIRT,
			      FASTRPC_PHYS(BUFFER->PHYS), BUFFER->SIZE);
	IF (RET < 0) {
		DEV_ERR(BUFFER->DEV, "FAILED TO GET SCATTERLIST FROM DMA API\N");
		RETURN -EINVAL;
	}

	A->DEV = ATTACHMENT->DEV;
	INIT_LIST_HEAD(&A->NODE);
	ATTACHMENT->PRIV = A;

	MUTEX_LOCK(&BUFFER->LOCK);
	LIST_ADD(&A->NODE, &BUFFER->ATTACHMENTS);
	MUTEX_UNLOCK(&BUFFER->LOCK);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 455344_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UDEQUOTE_PATHNAME (PATHNAME)
     CHAR *PATHNAME;
{
  REGISTER INT I, J;

  FOR (I = J = 0; PATHNAME && PATHNAME[I]; )
    {
      IF (PATHNAME[I] == '\\')
	I++;

      PATHNAME[J++] = PATHNAME[I++];

      IF (PATHNAME[I - 1] == 0)
	BREAK;
    }
  IF (PATHNAME)
    PATHNAME[J] = '\0';
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 468353_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ON_CONNECTION_CANCELLED (GCANCELLABLE *CANCELLABLE,
                         GPOINTER      DATA)
{
  GCANCELLABLE *ATTEMPT_CANCELLABLE = DATA;

  G_CANCELLABLE_CANCEL (ATTEMPT_CANCELLABLE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 455174_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MOBI_RET MOBI_PARSE_FDST(CONST MOBIDATA *M, MOBIRAWML *RAWML) {
    IF (M == NULL) {
        DEBUG_PRINT("%S", "MOBI STRUCTURE NOT INITIALIZED\N");
        RETURN MOBI_INIT_FAILED;
    }
    CONST SIZE_T FDST_RECORD_NUMBER = MOBI_GET_FDST_RECORD_NUMBER(M);
    IF (FDST_RECORD_NUMBER == MOBI_NOTSET) {
        RETURN MOBI_DATA_CORRUPT;
    }
    CONST MOBIPDBRECORD *FDST_RECORD = MOBI_GET_RECORD_BY_SEQNUMBER(M, FDST_RECORD_NUMBER);
    IF (FDST_RECORD == NULL) {
        RETURN MOBI_DATA_CORRUPT;
    }
    MOBIBUFFER *BUF = MOBI_BUFFER_INIT_NULL(FDST_RECORD->DATA, FDST_RECORD->SIZE);
    IF (BUF == NULL) {
        DEBUG_PRINT("%S\N", "MEMORY ALLOCATION FAILED");
        RETURN MOBI_MALLOC_FAILED;
    }
    CHAR FDST_MAGIC[5];
    MOBI_BUFFER_GETSTRING(FDST_MAGIC, BUF, 4);
    CONST SIZE_T DATA_OFFSET = MOBI_BUFFER_GET32(BUF);
    CONST SIZE_T SECTION_COUNT = MOBI_BUFFER_GET32(BUF);
    IF (STRNCMP(FDST_MAGIC, FDST_MAGIC, 4) != 0 ||
        SECTION_COUNT <= 1 ||
        SECTION_COUNT != *M->MH->FDST_SECTION_COUNT ||
        DATA_OFFSET != 12) {
        DEBUG_PRINT("FDST WRONG MAGIC: %S, SECTIONS COUNT: %ZU OR DATA OFFSET: %ZU\N", FDST_MAGIC, SECTION_COUNT, DATA_OFFSET);
        MOBI_BUFFER_FREE_NULL(BUF);
        RETURN MOBI_DATA_CORRUPT;
    }
    IF ((BUF->MAXLEN - BUF->OFFSET) < SECTION_COUNT * 8) {
        DEBUG_PRINT("%S", "RECORD FDST TOO SHORT\N");
        MOBI_BUFFER_FREE_NULL(BUF);
        RETURN MOBI_DATA_CORRUPT;
    }
    RAWML->FDST = MALLOC(SIZEOF(MOBIFDST));
    IF (RAWML->FDST == NULL) {
        DEBUG_PRINT("%S\N", "MEMORY ALLOCATION FAILED");
        MOBI_BUFFER_FREE_NULL(BUF);
        RETURN MOBI_MALLOC_FAILED;
    }
    RAWML->FDST->FDST_SECTION_COUNT = SECTION_COUNT;
    RAWML->FDST->FDST_SECTION_STARTS = MALLOC(SIZEOF(*RAWML->FDST->FDST_SECTION_STARTS) * SECTION_COUNT);
    IF (RAWML->FDST->FDST_SECTION_STARTS == NULL) {
        DEBUG_PRINT("%S\N", "MEMORY ALLOCATION FAILED");
        MOBI_BUFFER_FREE_NULL(BUF);
        FREE(RAWML->FDST);
        RAWML->FDST = NULL;
        RETURN MOBI_MALLOC_FAILED;
    }
    RAWML->FDST->FDST_SECTION_ENDS = MALLOC(SIZEOF(*RAWML->FDST->FDST_SECTION_ENDS) * SECTION_COUNT);
    IF (RAWML->FDST->FDST_SECTION_ENDS == NULL) {
        DEBUG_PRINT("%S\N", "MEMORY ALLOCATION FAILED");
        MOBI_BUFFER_FREE_NULL(BUF);
        FREE(RAWML->FDST->FDST_SECTION_STARTS);
        FREE(RAWML->FDST);
        RAWML->FDST = NULL;
        RETURN MOBI_MALLOC_FAILED;
    }
    SIZE_T I = 0;
    WHILE (I < SECTION_COUNT) {
        RAWML->FDST->FDST_SECTION_STARTS[I] = MOBI_BUFFER_GET32(BUF);
        RAWML->FDST->FDST_SECTION_ENDS[I] = MOBI_BUFFER_GET32(BUF);
        DEBUG_PRINT("FDST[%ZU]:\T%I\T%I\N", I, RAWML->FDST->FDST_SECTION_STARTS[I], RAWML->FDST->FDST_SECTION_ENDS[I]);
        I++;
    }
    MOBI_BUFFER_FREE_NULL(BUF);
    RETURN MOBI_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225950_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_ERR EXTR_BOX_WRITE(GF_BOX *S, GF_BITSTREAM *BS)
{
	GF_ERR E;
	GF_EXTRADATABOX *PTR = (GF_EXTRADATABOX *) S;
	IF (!S) RETURN GF_BAD_PARAM;

	E = GF_ISOM_BOX_WRITE_HEADER(S, BS);
	IF (E) RETURN E;

	IF (PTR->FECI) {
		E = GF_ISOM_BOX_WRITE((GF_BOX *)PTR->FECI, BS);
		IF (E) RETURN E;
	}
	GF_BS_WRITE_DATA(BS, PTR->DATA, PTR->DATA_LENGTH);
	RETURN GF_OK;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225911_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_ERR FECR_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	U32 I;
	FECRESERVOIRBOX *PTR = (FECRESERVOIRBOX *)S;

	ISOM_DECREASE_SIZE(PTR, (PTR->VERSION ? 4 : 2) );
	PTR->NB_ENTRIES = GF_BS_READ_INT(BS, PTR->VERSION ? 32 : 16);

	IF (PTR->NB_ENTRIES > PTR->SIZE / (PTR->VERSION ? 8 : 6) || (U64)PTR->NB_ENTRIES > (U64)SIZE_MAX/SIZEOF(FECRESERVOIRENTRY) ) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] INVALID NUMBER OF ENTRIES %D IN FECR\N", PTR->NB_ENTRIES));
		RETURN GF_ISOM_INVALID_FILE;
	}

	ISOM_DECREASE_SIZE(PTR, PTR->NB_ENTRIES * (PTR->VERSION ? 8 : 6) );
	GF_SAFE_ALLOC_N(PTR->ENTRIES, PTR->NB_ENTRIES, FECRESERVOIRENTRY);
	IF (!PTR->ENTRIES) RETURN GF_OUT_OF_MEM;

	FOR (I=0; I<PTR->NB_ENTRIES; I++) {
		PTR->ENTRIES[I].ITEM_ID = GF_BS_READ_INT(BS, PTR->VERSION ? 32 : 16);
		PTR->ENTRIES[I].SYMBOL_COUNT = GF_BS_READ_U32(BS);
	}
	RETURN GF_OK;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336113_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC NETDEV_TX_T IP6GRE_TUNNEL_XMIT(STRUCT SK_BUFF *SKB,
	STRUCT NET_DEVICE *DEV)
{
	STRUCT IP6_TNL *T = NETDEV_PRIV(DEV);
	STRUCT NET_DEVICE_STATS *STATS = &T->DEV->STATS;
	INT RET;

	IF (!IP6_TNL_XMIT_CTL(T, &T->PARMS.LADDR, &T->PARMS.RADDR))
		GOTO TX_ERR;

	SWITCH (SKB->PROTOCOL) {
	CASE HTONS(ETH_P_IP):
		RET = IP6GRE_XMIT_IPV4(SKB, DEV);
		BREAK;
	CASE HTONS(ETH_P_IPV6):
		RET = IP6GRE_XMIT_IPV6(SKB, DEV);
		BREAK;
	DEFAULT:
		RET = IP6GRE_XMIT_OTHER(SKB, DEV);
		BREAK;
	}

	IF (RET < 0)
		GOTO TX_ERR;

	RETURN NETDEV_TX_OK;

TX_ERR:
	STATS->TX_ERRORS++;
	STATS->TX_DROPPED++;
	KFREE_SKB(SKB);
	RETURN NETDEV_TX_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 457876_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LOAD_CACHE (GEGLPROPERTIES *OP_MAGICK_LOAD)
{
  IF (!OP_MAGICK_LOAD->USER_DATA)
    {
      GCHAR    *FILENAME;
      GEGLNODE *GRAPH, *SINK, *LOADER;
      GEGLBUFFER *NEWBUF = NULL;

      /* IMAGEMAGICK BACKED FALLBACK FIXME: MAKE THIS ROBUST.
       * MAYBE USE PIPES IN A MANNER SIMILAR TO THE RAW LOADER,
       * OR AT LEAST USE A PROPERLY UNIQUE FILENAME  */
      CHAR     *ARGV[4]  = {"CONVERT", NULL, NULL, NULL};

      FILENAME = G_BUILD_FILENAME (G_GET_TMP_DIR (), "GEGL-MAGICK.PNG", NULL);

      ARGV[1] = G_STRDUP_PRINTF ("%S[0]", OP_MAGICK_LOAD->PATH);
      ARGV[2] = FILENAME;
      IF (!G_SPAWN_SYNC (NULL, ARGV, NULL, G_SPAWN_DEFAULT, 
                         NULL, NULL, NULL, NULL, NULL, NULL))
        G_WARNING ("ERROR EXECUTING IMAGEMAGICK CONVERT PROGRAM");

      G_FREE (ARGV[1]);

      GRAPH = GEGL_NODE_NEW ();
      SINK = GEGL_NODE_NEW_CHILD (GRAPH,
                                 "OPERATION", "GEGL:BUFFER-SINK",
                                 "BUFFER", &NEWBUF, NULL);
      LOADER = GEGL_NODE_NEW_CHILD (GRAPH,
                                    "OPERATION", "GEGL:PNG-LOAD",
                                    "PATH", FILENAME, NULL);
      GEGL_NODE_LINK_MANY (LOADER, SINK, NULL);
      GEGL_NODE_PROCESS (SINK);
      OP_MAGICK_LOAD->USER_DATA = (GPOINTER) NEWBUF;
      G_OBJECT_UNREF (GRAPH);
      G_FREE (FILENAME);
    }
}
ASSISTANT
CWE-78: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN OS COMMAND ('OS COMMAND INJECTION')
--------------------------------------------------
File: 215948_CWE-310.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ECC_256_MODP (CONST STRUCT ECC_MODULO *P, MP_LIMB_T *RP)
{
  MP_LIMB_T U1, U0;
  MP_SIZE_T N;

  N = 2*P->SIZE;
  U1 = RP[--N];
  U0 = RP[N-1];

  /* THIS IS NOT PARTICULARLY FAST, BUT SHOULD WORK WELL WITH ASSEMBLY IMPLEMENTATION. */
  FOR (; N >= P->SIZE; N--)
    {
      MP_LIMB_T Q2, Q1, Q0, T, CY;

      /* <Q2, Q1, Q0> = V * U1 + <U1,U0>, WITH V = 2^32 - 1:

	   +---+---+
	   | U1| U0|
	   +---+---+
	       |-U1|
	     +-+-+-+
	     | U1|
       +---+-+-+-+-+
       | Q2| Q1| Q0|
       +---+---+---+
      */
      Q1 = U1 - (U1 > U0);
      Q0 = U0 - U1;
      T = U1 << 32;
      Q0 += T;
      T = (U1 >> 32) + (Q0 < T) + 1;
      Q1 += T;
      Q2 = Q1 < T;

      /* COMPUTE CANDIDATE REMAINDER */
      U1 = U0 + (Q1 << 32) - Q1;
      T = -(MP_LIMB_T) (U1 > Q0);
      U1 -= T & 0XFFFFFFFF;
      Q1 += T;
      Q2 += T + (Q1 < T);

      ASSERT (Q2 < 2);

      /* WE MULTIPLY BY TWO LOW LIMBS OF P, 2^96 - 1, SO WE COULD USE
	 SHIFTS RATHER THAN MUL. */
      T = MPN_SUBMUL_1 (RP + N - 4, P->M, 2, Q1);
      T += CND_SUB_N (Q2, RP + N - 3, P->M, 1);
      T += (-Q2) & 0XFFFFFFFF;

      U0 = RP[N-2];
      CY = (U0 < T);
      U0 -= T;
      T = (U1 < CY);
      U1 -= CY;
      U1 += CND_ADD_N (T, RP + N - 4, P->M, 3);
      U1 -= (-T) & 0XFFFFFFFF;
    }
  RP[2] = U0;
  RP[3] = U1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212414_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT TC_NEW_TFILTER(STRUCT SK_BUFF *SKB, STRUCT NLMSGHDR *N,
			  STRUCT NETLINK_EXT_ACK *EXTACK)
{
	STRUCT NET *NET = SOCK_NET(SKB->SK);
	STRUCT NLATTR *TCA[TCA_MAX + 1];
	CHAR NAME[IFNAMSIZ];
	STRUCT TCMSG *T;
	U32 PROTOCOL;
	U32 PRIO;
	BOOL PRIO_ALLOCATE;
	U32 PARENT;
	U32 CHAIN_INDEX;
	STRUCT QDISC *Q = NULL;
	STRUCT TCF_CHAIN_INFO CHAIN_INFO;
	STRUCT TCF_CHAIN *CHAIN = NULL;
	STRUCT TCF_BLOCK *BLOCK;
	STRUCT TCF_PROTO *TP;
	UNSIGNED LONG CL;
	VOID *FH;
	INT ERR;
	INT TP_CREATED;
	BOOL RTNL_HELD = FALSE;
	U32 FLAGS;

	IF (!NETLINK_NS_CAPABLE(SKB, NET->USER_NS, CAP_NET_ADMIN))
		RETURN -EPERM;

REPLAY:
	TP_CREATED = 0;

	ERR = NLMSG_PARSE_DEPRECATED(N, SIZEOF(*T), TCA, TCA_MAX,
				     RTM_TCA_POLICY, EXTACK);
	IF (ERR < 0)
		RETURN ERR;

	T = NLMSG_DATA(N);
	PROTOCOL = TC_H_MIN(T->TCM_INFO);
	PRIO = TC_H_MAJ(T->TCM_INFO);
	PRIO_ALLOCATE = FALSE;
	PARENT = T->TCM_PARENT;
	TP = NULL;
	CL = 0;
	BLOCK = NULL;
	FLAGS = 0;

	IF (PRIO == 0) {
		/* IF NO PRIORITY IS PROVIDED BY THE USER,
		 * WE ALLOCATE ONE.
		 */
		IF (N->NLMSG_FLAGS & NLM_F_CREATE) {
			PRIO = TC_H_MAKE(0X80000000U, 0U);
			PRIO_ALLOCATE = TRUE;
		} ELSE {
			NL_SET_ERR_MSG(EXTACK, "INVALID FILTER COMMAND WITH PRIORITY OF ZERO");
			RETURN -ENOENT;
		}
	}

	/* FIND HEAD OF FILTER CHAIN. */

	ERR = __TCF_QDISC_FIND(NET, &Q, &PARENT, T->TCM_IFINDEX, FALSE, EXTACK);
	IF (ERR)
		RETURN ERR;

	IF (TCF_PROTO_CHECK_KIND(TCA[TCA_KIND], NAME)) {
		NL_SET_ERR_MSG(EXTACK, "SPECIFIED TC FILTER NAME TOO LONG");
		ERR = -EINVAL;
		GOTO ERROUT;
	}

	/* TAKE RTNL MUTEX IF RTNL_HELD WAS SET TO TRUE ON PREVIOUS ITERATION,
	 * BLOCK IS SHARED (NO QDISC FOUND), QDISC IS NOT UNLOCKED, CLASSIFIER
	 * TYPE IS NOT SPECIFIED, CLASSIFIER IS NOT UNLOCKED.
	 */
	IF (RTNL_HELD ||
	    (Q && !(Q->OPS->CL_OPS->FLAGS & QDISC_CLASS_OPS_DOIT_UNLOCKED)) ||
	    !TCF_PROTO_IS_UNLOCKED(NAME)) {
		RTNL_HELD = TRUE;
		RTNL_LOCK();
	}

	ERR = __TCF_QDISC_CL_FIND(Q, PARENT, &CL, T->TCM_IFINDEX, EXTACK);
	IF (ERR)
		GOTO ERROUT;

	BLOCK = __TCF_BLOCK_FIND(NET, Q, CL, T->TCM_IFINDEX, T->TCM_BLOCK_INDEX,
				 EXTACK);
	IF (IS_ERR(BLOCK)) {
		ERR = PTR_ERR(BLOCK);
		GOTO ERROUT;
	}
	BLOCK->CLASSID = PARENT;

	CHAIN_INDEX = TCA[TCA_CHAIN] ? NLA_GET_U32(TCA[TCA_CHAIN]) : 0;
	IF (CHAIN_INDEX > TC_ACT_EXT_VAL_MASK) {
		NL_SET_ERR_MSG(EXTACK, "SPECIFIED CHAIN INDEX EXCEEDS UPPER LIMIT");
		ERR = -EINVAL;
		GOTO ERROUT;
	}
	CHAIN = TCF_CHAIN_GET(BLOCK, CHAIN_INDEX, TRUE);
	IF (!CHAIN) {
		NL_SET_ERR_MSG(EXTACK, "CANNOT CREATE SPECIFIED FILTER CHAIN");
		ERR = -ENOMEM;
		GOTO ERROUT;
	}

	MUTEX_LOCK(&CHAIN->FILTER_CHAIN_LOCK);
	TP = TCF_CHAIN_TP_FIND(CHAIN, &CHAIN_INFO, PROTOCOL,
			       PRIO, PRIO_ALLOCATE);
	IF (IS_ERR(TP)) {
		NL_SET_ERR_MSG(EXTACK, "FILTER WITH SPECIFIED PRIORITY/PROTOCOL NOT FOUND");
		ERR = PTR_ERR(TP);
		GOTO ERROUT_LOCKED;
	}

	IF (TP == NULL) {
		STRUCT TCF_PROTO *TP_NEW = NULL;

		IF (CHAIN->FLUSHING) {
			ERR = -EAGAIN;
			GOTO ERROUT_LOCKED;
		}

		/* PROTO-TCF DOES NOT EXIST, CREATE NEW ONE */

		IF (TCA[TCA_KIND] == NULL || !PROTOCOL) {
			NL_SET_ERR_MSG(EXTACK, "FILTER KIND AND PROTOCOL MUST BE SPECIFIED");
			ERR = -EINVAL;
			GOTO ERROUT_LOCKED;
		}

		IF (!(N->NLMSG_FLAGS & NLM_F_CREATE)) {
			NL_SET_ERR_MSG(EXTACK, "NEED BOTH RTM_NEWTFILTER AND NLM_F_CREATE TO CREATE A NEW FILTER");
			ERR = -ENOENT;
			GOTO ERROUT_LOCKED;
		}

		IF (PRIO_ALLOCATE)
			PRIO = TCF_AUTO_PRIO(TCF_CHAIN_TP_PREV(CHAIN,
							       &CHAIN_INFO));

		MUTEX_UNLOCK(&CHAIN->FILTER_CHAIN_LOCK);
		TP_NEW = TCF_PROTO_CREATE(NAME, PROTOCOL, PRIO, CHAIN,
					  RTNL_HELD, EXTACK);
		IF (IS_ERR(TP_NEW)) {
			ERR = PTR_ERR(TP_NEW);
			GOTO ERROUT_TP;
		}

		TP_CREATED = 1;
		TP = TCF_CHAIN_TP_INSERT_UNIQUE(CHAIN, TP_NEW, PROTOCOL, PRIO,
						RTNL_HELD);
		IF (IS_ERR(TP)) {
			ERR = PTR_ERR(TP);
			GOTO ERROUT_TP;
		}
	} ELSE {
		MUTEX_UNLOCK(&CHAIN->FILTER_CHAIN_LOCK);
	}

	IF (TCA[TCA_KIND] && NLA_STRCMP(TCA[TCA_KIND], TP->OPS->KIND)) {
		NL_SET_ERR_MSG(EXTACK, "SPECIFIED FILTER KIND DOES NOT MATCH EXISTING ONE");
		ERR = -EINVAL;
		GOTO ERROUT;
	}

	FH = TP->OPS->GET(TP, T->TCM_HANDLE);

	IF (!FH) {
		IF (!(N->NLMSG_FLAGS & NLM_F_CREATE)) {
			NL_SET_ERR_MSG(EXTACK, "NEED BOTH RTM_NEWTFILTER AND NLM_F_CREATE TO CREATE A NEW FILTER");
			ERR = -ENOENT;
			GOTO ERROUT;
		}
	} ELSE IF (N->NLMSG_FLAGS & NLM_F_EXCL) {
		TFILTER_PUT(TP, FH);
		NL_SET_ERR_MSG(EXTACK, "FILTER ALREADY EXISTS");
		ERR = -EEXIST;
		GOTO ERROUT;
	}

	IF (CHAIN->TMPLT_OPS && CHAIN->TMPLT_OPS != TP->OPS) {
		NL_SET_ERR_MSG(EXTACK, "CHAIN TEMPLATE IS SET TO A DIFFERENT FILTER KIND");
		ERR = -EINVAL;
		GOTO ERROUT;
	}

	IF (!(N->NLMSG_FLAGS & NLM_F_CREATE))
		FLAGS |= TCA_ACT_FLAGS_REPLACE;
	IF (!RTNL_HELD)
		FLAGS |= TCA_ACT_FLAGS_NO_RTNL;
	ERR = TP->OPS->CHANGE(NET, SKB, TP, CL, T->TCM_HANDLE, TCA, &FH,
			      FLAGS, EXTACK);
	IF (ERR == 0) {
		TFILTER_NOTIFY(NET, SKB, N, TP, BLOCK, Q, PARENT, FH,
			       RTM_NEWTFILTER, FALSE, RTNL_HELD);
		TFILTER_PUT(TP, FH);
		/* Q POINTER IS NULL FOR SHARED BLOCKS */
		IF (Q)
			Q->FLAGS &= ~TCQ_F_CAN_BYPASS;
	}

ERROUT:
	IF (ERR && TP_CREATED)
		TCF_CHAIN_TP_DELETE_EMPTY(CHAIN, TP, RTNL_HELD, NULL);
ERROUT_TP:
	IF (CHAIN) {
		IF (TP && !IS_ERR(TP))
			TCF_PROTO_PUT(TP, RTNL_HELD, NULL);
		IF (!TP_CREATED)
			TCF_CHAIN_PUT(CHAIN);
	}
	TCF_BLOCK_RELEASE(Q, BLOCK, RTNL_HELD);

	IF (RTNL_HELD)
		RTNL_UNLOCK();

	IF (ERR == -EAGAIN) {
		/* TAKE RTNL LOCK IN CASE EAGAIN IS CAUSED BY CONCURRENT FLUSH
		 * OF TARGET CHAIN.
		 */
		RTNL_HELD = TRUE;
		/* REPLAY THE REQUEST. */
		GOTO REPLAY;
	}
	RETURN ERR;

ERROUT_LOCKED:
	MUTEX_UNLOCK(&CHAIN->FILTER_CHAIN_LOCK);
	GOTO ERROUT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220927_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GFINLINE VOID MPGVIDDMX_UPDATE_TIME(GF_MPGVIDDMXCTX *CTX)
{
	ASSERT(CTX->CUR_FPS.NUM);

	IF (CTX->TIMESCALE) {
		U64 INC = 3000;
		IF (CTX->CUR_FPS.DEN && CTX->CUR_FPS.NUM) {
			INC = CTX->CUR_FPS.DEN;
			IF (CTX->CUR_FPS.NUM != CTX->TIMESCALE) {
				INC *= CTX->TIMESCALE;
				INC /= CTX->CUR_FPS.NUM;
			}
		}
		CTX->CTS += INC;
		CTX->DTS += INC;
	} ELSE {
		ASSERT(CTX->CUR_FPS.DEN);
		CTX->CTS += CTX->CUR_FPS.DEN;
		CTX->DTS += CTX->CUR_FPS.DEN;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197128_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GEN_ASSIGNMENT(CODEGEN_SCOPE *S, NODE *TREE, NODE *RHS, INT SP, INT VAL)
{
  INT IDX;
  INT TYPE = NINT(TREE->CAR);

  SWITCH (TYPE) {
  CASE NODE_GVAR:
  CASE NODE_ARG:
  CASE NODE_LVAR:
  CASE NODE_IVAR:
  CASE NODE_CVAR:
  CASE NODE_CONST:
  CASE NODE_NIL:
  CASE NODE_MASGN:
    IF (RHS) {
      CODEGEN(S, RHS, VAL);
      POP();
      SP = CURSP();
    }
    BREAK;

  CASE NODE_COLON2:
  CASE NODE_CALL:
  CASE NODE_SCALL:
    /* KEEP EVALUATION ORDER */
    BREAK;

  CASE NODE_NVAR:
    CODEGEN_ERROR(S, "CAN'T ASSIGN TO NUMBERED PARAMETER");
    BREAK;

  DEFAULT:
    CODEGEN_ERROR(S, "UNKNOWN LHS");
    BREAK;
  }

  TREE = TREE->CDR;
  SWITCH (TYPE) {
  CASE NODE_GVAR:
    GEN_SETXV(S, OP_SETGV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_ARG:
  CASE NODE_LVAR:
    IDX = LV_IDX(S, NSYM(TREE));
    IF (IDX > 0) {
      IF (IDX != SP) {
        GEN_MOVE(S, IDX, SP, VAL);
      }
      BREAK;
    }
    ELSE {                      /* UPVAR */
      GEN_SETUPVAR(S, SP, NSYM(TREE));
    }
    BREAK;
  CASE NODE_IVAR:
    GEN_SETXV(S, OP_SETIV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_CVAR:
    GEN_SETXV(S, OP_SETCV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_CONST:
    GEN_SETXV(S, OP_SETCONST, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_COLON2:
    IF (SP) {
      GEN_MOVE(S, CURSP(), SP, 0);
    }
    SP = CURSP();
    PUSH();
    CODEGEN(S, TREE->CAR, VAL);
    IF (RHS) {
      CODEGEN(S, RHS, VAL); POP();
      GEN_MOVE(S, SP, CURSP(), 0);
    }
    POP_N(2);
    IDX = NEW_SYM(S, NSYM(TREE->CDR));
    GENOP_2(S, OP_SETMCNST, SP, IDX);
    BREAK;

  CASE NODE_CALL:
  CASE NODE_SCALL:
    {
      INT NOSELF = 0, SAFE = (TYPE == NODE_SCALL), SKIP = 0, TOP, CALL, N = 0;
      MRB_SYM MID = NSYM(TREE->CDR->CAR);

      TOP = CURSP();
      IF (VAL || SP == CURSP()) {
        PUSH();                   /* ROOM FOR RETVAL */
      }
      CALL = CURSP();
      IF (!TREE->CAR) {
        NOSELF = 1;
        PUSH();
      }
      ELSE {
        CODEGEN(S, TREE->CAR, VAL); /* RECEIVER */
      }
      IF (SAFE) {
        INT RECV = CURSP()-1;
        GEN_MOVE(S, CURSP(), RECV, 1);
        SKIP = GENJMP2_0(S, OP_JMPNIL, CURSP(), VAL);
      }
      TREE = TREE->CDR->CDR->CAR;
      IF (TREE) {
        IF (TREE->CAR) {            /* POSITIONAL ARGUMENTS */
          N = GEN_VALUES(S, TREE->CAR, VAL, (TREE->CDR->CAR)?13:14);
          IF (N < 0) {              /* VARIABLE LENGTH */
            N = 15;
            PUSH();
          }
        }
        IF (TREE->CDR->CAR) {       /* KEYWORD ARGUMENTS */
          IF (N == 14) {
            POP_N(N);
            GENOP_2(S, OP_ARRAY, CURSP(), N);
            PUSH();
            N = 15;
          }
          GEN_HASH(S, TREE->CDR->CAR->CDR, VAL, 0);
          IF (N < 14) {
            N++;
          }
          ELSE {
            POP_N(2);
            GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
          }
          PUSH();
        }
      }
      IF (RHS) {
        CODEGEN(S, RHS, VAL);
        POP();
      }
      ELSE {
        GEN_MOVE(S, CURSP(), SP, 0);
      }
      IF (VAL) {
        GEN_MOVE(S, TOP, CURSP(), 1);
      }
      IF (N < 14) {
        N++;
      }
      ELSE {
        POP();
        GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
      }
      S->SP = CALL;
      IF (MID == MRB_OPSYM_2(S->MRB, AREF) && N == 2) {
        GENOP_1(S, OP_SETIDX, CURSP());
      }
      ELSE {
        GENOP_3(S, NOSELF ? OP_SSEND : OP_SEND, CURSP(), NEW_SYM(S, ATTRSYM(S, MID)), N);
      }
      IF (SAFE) {
        DISPATCH(S, SKIP);
      }
      S->SP = TOP;
    }
    BREAK;

  CASE NODE_MASGN:
    GEN_VMASSIGNMENT(S, TREE->CAR, SP, VAL);
    BREAK;

  /* SPLAT WITHOUT ASSIGNMENT */
  CASE NODE_NIL:
    BREAK;

  DEFAULT:
    CODEGEN_ERROR(S, "UNKNOWN LHS");
    BREAK;
  }
  IF (VAL) PUSH();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 446111_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT ATUSB_GET_AND_SHOW_REVISION(STRUCT ATUSB *ATUSB)
{
	STRUCT USB_DEVICE *USB_DEV = ATUSB->USB_DEV;
	CHAR *HW_NAME;
	UNSIGNED CHAR *BUFFER;
	INT RET;

	BUFFER = KMALLOC(3, GFP_KERNEL);
	IF (!BUFFER)
		RETURN -ENOMEM;

	/* GET A COUPLE OF THE ATMEGA FIRMWARE VALUES */
	RET = ATUSB_CONTROL_MSG(ATUSB, USB_RCVCTRLPIPE(USB_DEV, 0),
				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				BUFFER, 3, 1000);
	IF (RET >= 0) {
		ATUSB->FW_VER_MAJ = BUFFER[0];
		ATUSB->FW_VER_MIN = BUFFER[1];
		ATUSB->FW_HW_TYPE = BUFFER[2];

		SWITCH (ATUSB->FW_HW_TYPE) {
		CASE ATUSB_HW_TYPE_100813:
		CASE ATUSB_HW_TYPE_101216:
		CASE ATUSB_HW_TYPE_110131:
			HW_NAME = "ATUSB";
			ATUSB->DATA = &ATUSB_CHIP_DATA;
			BREAK;
		CASE ATUSB_HW_TYPE_RZUSB:
			HW_NAME = "RZUSB";
			ATUSB->DATA = &ATUSB_CHIP_DATA;
			BREAK;
		CASE ATUSB_HW_TYPE_HULUSB:
			HW_NAME = "HULUSB";
			ATUSB->DATA = &HULUSB_CHIP_DATA;
			BREAK;
		DEFAULT:
			HW_NAME = "UNKNOWN";
			ATUSB->ERR = -ENOTSUPP;
			RET = -ENOTSUPP;
			BREAK;
		}

		DEV_INFO(&USB_DEV->DEV,
			 "FIRMWARE: MAJOR: %U, MINOR: %U, HARDWARE TYPE: %S (%D)\N",
			 ATUSB->FW_VER_MAJ, ATUSB->FW_VER_MIN, HW_NAME,
			 ATUSB->FW_HW_TYPE);
	}
	IF (ATUSB->FW_VER_MAJ == 0 && ATUSB->FW_VER_MIN < 2) {
		DEV_INFO(&USB_DEV->DEV,
			 "FIRMWARE VERSION (%U.%U) PREDATES OUR FIRST PUBLIC RELEASE.",
			 ATUSB->FW_VER_MAJ, ATUSB->FW_VER_MIN);
		DEV_INFO(&USB_DEV->DEV, "PLEASE UPDATE TO VERSION 0.2 OR NEWER");
	}

	KFREE(BUFFER);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199834_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INS_COMPL_STOP(INT C, INT PREV_MODE, INT RETVAL)
{
    CHAR_U	*PTR;
    INT		WANT_CINDENT;

    // GET HERE WHEN WE HAVE FINISHED TYPING A SEQUENCE OF ^N AND
    // ^P OR OTHER COMPLETION CHARACTERS IN CTRL-X MODE.  FREE UP
    // MEMORY THAT WAS USED, AND MAKE SURE WE CAN REDO THE INSERT.
    IF (COMPL_CURR_MATCH != NULL || COMPL_LEADER != NULL || C == CTRL_E)
    {
	// IF ANY OF THE ORIGINAL TYPED TEXT HAS BEEN CHANGED, EG WHEN
	// IGNORECASE IS SET, WE MUST ADD BACK-SPACES TO THE REDO
	// BUFFER.  WE ADD AS FEW AS NECESSARY TO DELETE JUST THE PART
	// OF THE ORIGINAL TEXT THAT HAS CHANGED.
	// WHEN USING THE LONGEST MATCH, EDITED THE MATCH OR USED
	// CTRL-E THEN DON'T USE THE CURRENT MATCH.
	IF (COMPL_CURR_MATCH != NULL && COMPL_USED_MATCH && C != CTRL_E)
	    PTR = COMPL_CURR_MATCH->CP_STR;
	ELSE
	    PTR = NULL;
	INS_COMPL_FIXREDOBUFFORLEADER(PTR);
    }

    WANT_CINDENT = (GET_CAN_CINDENT() && CINDENT_ON());

    // WHEN COMPLETING WHOLE LINES: FIX INDENT FOR 'CINDENT'.
    // OTHERWISE, BREAK LINE IF IT'S TOO LONG.
    IF (COMPL_CONT_MODE == CTRL_X_WHOLE_LINE)
    {
	// RE-INDENT THE CURRENT LINE
	IF (WANT_CINDENT)
	{
	    DO_C_EXPR_INDENT();
	    WANT_CINDENT = FALSE;	// DON'T DO IT AGAIN
	}
    }
    ELSE
    {
	INT PREV_COL = CURWIN->W_CURSOR.COL;

	// PUT THE CURSOR ON THE LAST CHAR, FOR 'TW' FORMATTING
	IF (PREV_COL > 0)
	    DEC_CURSOR();
	// ONLY FORMAT WHEN SOMETHING WAS INSERTED
	IF (!ARROW_USED && !INS_NEED_UNDO_GET() && C != CTRL_E)
	    INSERTCHAR(NUL, 0, -1);
	IF (PREV_COL > 0
		&& ML_GET_CURLINE()[CURWIN->W_CURSOR.COL] != NUL)
	    INC_CURSOR();
    }

    // IF THE POPUP MENU IS DISPLAYED PRESSING CTRL-Y MEANS ACCEPTING
    // THE SELECTION WITHOUT INSERTING ANYTHING.  WHEN
    // COMPL_ENTER_SELECTS IS SET THE ENTER KEY DOES THE SAME.
    IF ((C == CTRL_Y || (COMPL_ENTER_SELECTS
		    && (C == CAR || C == K_KENTER || C == NL)))
	    && PUM_VISIBLE())
	RETVAL = TRUE;

    // CTRL-E MEANS COMPLETION IS ENDED, GO BACK TO THE TYPED TEXT.
    // BUT ONLY DO THIS, IF THE POPUP IS STILL VISIBLE
    IF (C == CTRL_E)
    {
	INS_COMPL_DELETE();
	IF (COMPL_LEADER != NULL)
	    INS_BYTES(COMPL_LEADER + GET_COMPL_LEN());
	ELSE IF (COMPL_FIRST_MATCH != NULL)
	    INS_BYTES(COMPL_ORIG_TEXT + GET_COMPL_LEN());
	RETVAL = TRUE;
    }

    AUTO_FORMAT(FALSE, TRUE);

    // TRIGGER THE COMPLETEDONEPRE EVENT TO GIVE SCRIPTS A CHANCE TO
    // ACT UPON THE COMPLETION BEFORE CLEARING THE INFO, AND RESTORE
    // CTRL_X_MODE, SO THAT COMPLETE_INFO() CAN BE USED.
    CTRL_X_MODE = PREV_MODE;
    INS_APPLY_AUTOCMDS(EVENT_COMPLETEDONEPRE);

    INS_COMPL_FREE();
    COMPL_STARTED = FALSE;
    COMPL_MATCHES = 0;
    IF (!SHORTMESS(SHM_COMPLETIONMENU))
	MSG_CLR_CMDLINE();	// NECESSARY FOR "NOSHOWMODE"
    CTRL_X_MODE = CTRL_X_NORMAL;
    COMPL_ENTER_SELECTS = FALSE;
    IF (EDIT_SUBMODE != NULL)
    {
	EDIT_SUBMODE = NULL;
	SHOWMODE();
    }

#IFDEF FEAT_CMDWIN
    IF (C == CTRL_C && CMDWIN_TYPE != 0)
	// AVOID THE POPUP MENU REMAINS DISPLAYED WHEN LEAVING THE
	// COMMAND LINE WINDOW.
	UPDATE_SCREEN(0);
#ENDIF
    // INDENT NOW IF A KEY WAS TYPED THAT IS IN 'CINKEYS'.
    IF (WANT_CINDENT && IN_CINKEYS(KEY_COMPLETE, ' ', ININDENT(0)))
	DO_C_EXPR_INDENT();
    // TRIGGER THE COMPLETEDONE EVENT TO GIVE SCRIPTS A CHANCE TO ACT
    // UPON THE END OF COMPLETION.
    INS_APPLY_AUTOCMDS(EVENT_COMPLETEDONE);

    RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199681_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT FD_LOCKED_IOCTL(STRUCT BLOCK_DEVICE *BDEV, FMODE_T MODE, UNSIGNED INT CMD,
		    UNSIGNED LONG PARAM)
{
	INT DRIVE = (LONG)BDEV->BD_DISK->PRIVATE_DATA;
	INT TYPE = ITYPE(DRIVE_STATE[DRIVE].FD_DEVICE);
	INT I;
	INT RET;
	INT SIZE;
	UNION INPARAM {
		STRUCT FLOPPY_STRUCT G;	/* GEOMETRY */
		STRUCT FORMAT_DESCR F;
		STRUCT FLOPPY_MAX_ERRORS MAX_ERRORS;
		STRUCT FLOPPY_DRIVE_PARAMS DP;
	} INPARAM;		/* PARAMETERS COMING FROM USER SPACE */
	CONST VOID *OUTPARAM;	/* PARAMETERS PASSED BACK TO USER SPACE */

	/* CONVERT COMPATIBILITY EJECT IOCTLS INTO FLOPPY EJECT IOCTL.
	 * WE DO THIS IN ORDER TO PROVIDE A MEANS TO EJECT FLOPPY DISKS BEFORE
	 * INSTALLING THE NEW FDUTILS PACKAGE */
	IF (CMD == CDROMEJECT ||	/* CD-ROM EJECT */
	    CMD == 0X6470) {		/* SUNOS FLOPPY EJECT */
		DPRINT("OBSOLETE EJECT IOCTL\N");
		DPRINT("PLEASE USE FLOPPYCONTROL --EJECT\N");
		CMD = FDEJECT;
	}

	IF (!((CMD & 0XFF00) == 0X0200))
		RETURN -EINVAL;

	/* CONVERT THE OLD STYLE COMMAND INTO A NEW STYLE COMMAND */
	RET = NORMALIZE_IOCTL(&CMD, &SIZE);
	IF (RET)
		RETURN RET;

	/* PERMISSION CHECKS */
	IF (((CMD & 0X40) && !(MODE & (FMODE_WRITE | FMODE_WRITE_IOCTL))) ||
	    ((CMD & 0X80) && !CAPABLE(CAP_SYS_ADMIN)))
		RETURN -EPERM;

	IF (WARN_ON(SIZE < 0 || SIZE > SIZEOF(INPARAM)))
		RETURN -EINVAL;

	/* COPYIN */
	MEMSET(&INPARAM, 0, SIZEOF(INPARAM));
	IF (_IOC_DIR(CMD) & _IOC_WRITE) {
		RET = FD_COPYIN((VOID __USER *)PARAM, &INPARAM, SIZE);
		IF (RET)
			RETURN RET;
	}

	SWITCH (CMD) {
	CASE FDEJECT:
		IF (DRIVE_STATE[DRIVE].FD_REF != 1)
			/* SOMEBODY ELSE HAS THIS DRIVE OPEN */
			RETURN -EBUSY;
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;

		/* DO THE ACTUAL EJECT. FAILS ON
		 * NON-SPARC ARCHITECTURES */
		RET = FD_EJECT(UNIT(DRIVE));

		SET_BIT(FD_DISK_CHANGED_BIT, &DRIVE_STATE[DRIVE].FLAGS);
		SET_BIT(FD_VERIFY_BIT, &DRIVE_STATE[DRIVE].FLAGS);
		PROCESS_FD_REQUEST();
		RETURN RET;
	CASE FDCLRPRM:
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;
		CURRENT_TYPE[DRIVE] = NULL;
		FLOPPY_SIZES[DRIVE] = MAX_DISK_SIZE << 1;
		DRIVE_STATE[DRIVE].KEEP_DATA = 0;
		RETURN INVALIDATE_DRIVE(BDEV);
	CASE FDSETPRM:
	CASE FDDEFPRM:
		RETURN SET_GEOMETRY(CMD, &INPARAM.G, DRIVE, TYPE, BDEV);
	CASE FDGETPRM:
		RET = GET_FLOPPY_GEOMETRY(DRIVE, TYPE,
					  (STRUCT FLOPPY_STRUCT **)&OUTPARAM);
		IF (RET)
			RETURN RET;
		MEMCPY(&INPARAM.G, OUTPARAM,
				OFFSETOF(STRUCT FLOPPY_STRUCT, NAME));
		OUTPARAM = &INPARAM.G;
		BREAK;
	CASE FDMSGON:
		DRIVE_PARAMS[DRIVE].FLAGS |= FTD_MSG;
		RETURN 0;
	CASE FDMSGOFF:
		DRIVE_PARAMS[DRIVE].FLAGS &= ~FTD_MSG;
		RETURN 0;
	CASE FDFMTBEG:
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;
		IF (POLL_DRIVE(TRUE, FD_RAW_NEED_DISK) == -EINTR)
			RETURN -EINTR;
		RET = DRIVE_STATE[DRIVE].FLAGS;
		PROCESS_FD_REQUEST();
		IF (RET & FD_VERIFY)
			RETURN -ENODEV;
		IF (!(RET & FD_DISK_WRITABLE))
			RETURN -EROFS;
		RETURN 0;
	CASE FDFMTTRK:
		IF (DRIVE_STATE[DRIVE].FD_REF != 1)
			RETURN -EBUSY;
		RETURN DO_FORMAT(DRIVE, &INPARAM.F);
	CASE FDFMTEND:
	CASE FDFLUSH:
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;
		RETURN INVALIDATE_DRIVE(BDEV);
	CASE FDSETEMSGTRESH:
		DRIVE_PARAMS[DRIVE].MAX_ERRORS.REPORTING = (UNSIGNED SHORT)(PARAM & 0X0F);
		RETURN 0;
	CASE FDGETMAXERRS:
		OUTPARAM = &DRIVE_PARAMS[DRIVE].MAX_ERRORS;
		BREAK;
	CASE FDSETMAXERRS:
		DRIVE_PARAMS[DRIVE].MAX_ERRORS = INPARAM.MAX_ERRORS;
		BREAK;
	CASE FDGETDRVTYP:
		OUTPARAM = DRIVE_NAME(TYPE, DRIVE);
		SUPBOUND(SIZE, STRLEN((CONST CHAR *)OUTPARAM) + 1);
		BREAK;
	CASE FDSETDRVPRM:
		IF (!VALID_FLOPPY_DRIVE_PARAMS(INPARAM.DP.AUTODETECT,
				INPARAM.DP.NATIVE_FORMAT))
			RETURN -EINVAL;
		DRIVE_PARAMS[DRIVE] = INPARAM.DP;
		BREAK;
	CASE FDGETDRVPRM:
		OUTPARAM = &DRIVE_PARAMS[DRIVE];
		BREAK;
	CASE FDPOLLDRVSTAT:
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;
		IF (POLL_DRIVE(TRUE, FD_RAW_NEED_DISK) == -EINTR)
			RETURN -EINTR;
		PROCESS_FD_REQUEST();
		FALLTHROUGH;
	CASE FDGETDRVSTAT:
		OUTPARAM = &DRIVE_STATE[DRIVE];
		BREAK;
	CASE FDRESET:
		RETURN USER_RESET_FDC(DRIVE, (INT)PARAM, TRUE);
	CASE FDGETFDCSTAT:
		OUTPARAM = &FDC_STATE[FDC(DRIVE)];
		BREAK;
	CASE FDWERRORCLR:
		MEMSET(&WRITE_ERRORS[DRIVE], 0, SIZEOF(WRITE_ERRORS[DRIVE]));
		RETURN 0;
	CASE FDWERRORGET:
		OUTPARAM = &WRITE_ERRORS[DRIVE];
		BREAK;
	CASE FDRAWCMD:
		IF (TYPE)
			RETURN -EINVAL;
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;
		SET_FLOPPY(DRIVE);
		I = RAW_CMD_IOCTL(CMD, (VOID __USER *)PARAM);
		IF (I == -EINTR)
			RETURN -EINTR;
		PROCESS_FD_REQUEST();
		RETURN I;
	CASE FDTWADDLE:
		IF (LOCK_FDC(DRIVE))
			RETURN -EINTR;
		TWADDLE(CURRENT_FDC, CURRENT_DRIVE);
		PROCESS_FD_REQUEST();
		RETURN 0;
	DEFAULT:
		RETURN -EINVAL;
	}

	IF (_IOC_DIR(CMD) & _IOC_READ)
		RETURN FD_COPYOUT((VOID __USER *)PARAM, OUTPARAM, SIZE);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369174_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

STATIC INT IO_CLOSE_FIXED(STRUCT IO_KIOCB *REQ, UNSIGNED INT ISSUE_FLAGS)
{
	UNSIGNED INT OFFSET = REQ->CLOSE.FILE_SLOT - 1;
	STRUCT IO_RING_CTX *CTX = REQ->CTX;
	BOOL NEEDS_LOCK = ISSUE_FLAGS & IO_URING_F_UNLOCKED;
	STRUCT IO_FIXED_FILE *FILE_SLOT;
	STRUCT FILE *FILE;
	INT RET;

	IO_RING_SUBMIT_LOCK(CTX, NEEDS_LOCK);
	RET = -ENXIO;
	IF (UNLIKELY(!CTX->FILE_DATA))
		GOTO OUT;
	RET = -EINVAL;
	IF (OFFSET >= CTX->NR_USER_FILES)
		GOTO OUT;
	RET = IO_RSRC_NODE_SWITCH_START(CTX);
	IF (RET)
		GOTO OUT;

	OFFSET = ARRAY_INDEX_NOSPEC(OFFSET, CTX->NR_USER_FILES);
	FILE_SLOT = IO_FIXED_FILE_SLOT(&CTX->FILE_TABLE, OFFSET);
	RET = -EBADF;
	IF (!FILE_SLOT->FILE_PTR)
		GOTO OUT;

	FILE = (STRUCT FILE *)(FILE_SLOT->FILE_PTR & FFS_MASK);
	RET = IO_QUEUE_RSRC_REMOVAL(CTX->FILE_DATA, OFFSET, CTX->RSRC_NODE, FILE);
	IF (RET)
		GOTO OUT;

	FILE_SLOT->FILE_PTR = 0;
	IO_RSRC_NODE_SWITCH(CTX, CTX->FILE_DATA);
	RET = 0;
OUT:
	IO_RING_SUBMIT_UNLOCK(CTX, NEEDS_LOCK);
	RETURN RET;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213998_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FINDEMPTYOBJECTSLOT(
		    TPMI_DH_OBJECT  *HANDLE         // OUT: (OPTIONAL)
		    )
{
    UINT32               I;
    OBJECT              *OBJECT;
    FOR(I = 0; I < MAX_LOADED_OBJECTS; I++)
	{
	    OBJECT = &S_OBJECTS[I];
	    IF(OBJECT->ATTRIBUTES.OCCUPIED == CLEAR)
		{
		    IF(HANDLE)
			*HANDLE = I + TRANSIENT_FIRST;
		    // INITIALIZE THE OBJECT ATTRIBUTES
		    MEMORYSET(&OBJECT->ATTRIBUTES, 0, SIZEOF(OBJECT_ATTRIBUTES));
		    RETURN OBJECT;
		}
	}
    RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208140_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT MAIN(INT ARGC, CHAR **ARGV)
{
	INT C, RC = MOUNT_EX_SUCCESS, ALL = 0, SHOW_LABELS = 0;
	STRUCT LIBMNT_CONTEXT *CXT;
	STRUCT LIBMNT_TABLE *FSTAB = NULL;
	CHAR *SRCBUF = NULL;
	CHAR *TYPES = NULL;
	UNSIGNED LONG OPER = 0;

	ENUM {
		MOUNT_OPT_SHARED = CHAR_MAX + 1,
		MOUNT_OPT_SLAVE,
		MOUNT_OPT_PRIVATE,
		MOUNT_OPT_UNBINDABLE,
		MOUNT_OPT_RSHARED,
		MOUNT_OPT_RSLAVE,
		MOUNT_OPT_RPRIVATE,
		MOUNT_OPT_RUNBINDABLE,
		MOUNT_OPT_TARGET,
		MOUNT_OPT_SOURCE
	};

	STATIC CONST STRUCT OPTION LONGOPTS[] = {
		{ "ALL", 0, 0, 'A' },
		{ "FAKE", 0, 0, 'F' },
		{ "FSTAB", 1, 0, 'T' },
		{ "FORK", 0, 0, 'F' },
		{ "HELP", 0, 0, 'H' },
		{ "NO-MTAB", 0, 0, 'N' },
		{ "READ-ONLY", 0, 0, 'R' },
		{ "RO", 0, 0, 'R' },
		{ "VERBOSE", 0, 0, 'V' },
		{ "VERSION", 0, 0, 'V' },
		{ "READ-WRITE", 0, 0, 'W' },
		{ "RW", 0, 0, 'W' },
		{ "OPTIONS", 1, 0, 'O' },
		{ "TEST-OPTS", 1, 0, 'O' },
		{ "PASS-FD", 1, 0, 'P' },
		{ "TYPES", 1, 0, 'T' },
		{ "UUID", 1, 0, 'U' },
		{ "LABEL", 1, 0, 'L'},
		{ "BIND", 0, 0, 'B' },
		{ "MOVE", 0, 0, 'M' },
		{ "RBIND", 0, 0, 'R' },
		{ "MAKE-SHARED", 0, 0, MOUNT_OPT_SHARED },
		{ "MAKE-SLAVE", 0, 0, MOUNT_OPT_SLAVE },
		{ "MAKE-PRIVATE", 0, 0, MOUNT_OPT_PRIVATE },
		{ "MAKE-UNBINDABLE", 0, 0, MOUNT_OPT_UNBINDABLE },
		{ "MAKE-RSHARED", 0, 0, MOUNT_OPT_RSHARED },
		{ "MAKE-RSLAVE", 0, 0, MOUNT_OPT_RSLAVE },
		{ "MAKE-RPRIVATE", 0, 0, MOUNT_OPT_RPRIVATE },
		{ "MAKE-RUNBINDABLE", 0, 0, MOUNT_OPT_RUNBINDABLE },
		{ "NO-CANONICALIZE", 0, 0, 'C' },
		{ "INTERNAL-ONLY", 0, 0, 'I' },
		{ "SHOW-LABELS", 0, 0, 'L' },
		{ "TARGET", 1, 0, MOUNT_OPT_TARGET },
		{ "SOURCE", 1, 0, MOUNT_OPT_SOURCE },
		{ NULL, 0, 0, 0 }
	};

	STATIC CONST UL_EXCL_T EXCL[] = {       /* ROWS AND COLS IN IN ASCII ORDER */
		{ 'B','M','R',			/* BIND,MOVE,RBIND */
		   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,
		   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,
		   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,
		   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },

		{ 'L','U', MOUNT_OPT_SOURCE },	/* LABEL,UUID,SOURCE */
		{ 0 }
	};
	INT EXCL_ST[ARRAY_SIZE(EXCL)] = UL_EXCL_STATUS_INIT;

	SANITIZE_ENV();
	SETLOCALE(LC_ALL, "");
	BINDTEXTDOMAIN(PACKAGE, LOCALEDIR);
	TEXTDOMAIN(PACKAGE);
	ATEXIT(CLOSE_STDOUT);

	MNT_INIT_DEBUG(0);
	CXT = MNT_NEW_CONTEXT();
	IF (!CXT)
		ERR(MOUNT_EX_SYSERR, _("LIBMOUNT CONTEXT ALLOCATION FAILED"));

	MNT_CONTEXT_SET_TABLES_ERRCB(CXT, TABLE_PARSER_ERRCB);

	WHILE ((C = GETOPT_LONG(ARGC, ARGV, "ABCFFHILL:MNO:O:P:RRSU:VVWT:T:",
					LONGOPTS, NULL)) != -1) {

		/* ONLY FEW OPTIONS ARE ALLOWED FOR NON-ROOT USERS */
		IF (MNT_CONTEXT_IS_RESTRICTED(CXT) &&
		    !STRCHR("HLLUVVPRIS", C) &&
		    C != MOUNT_OPT_TARGET &&
		    C != MOUNT_OPT_SOURCE)
			EXIT_NON_ROOT(OPTION_TO_LONGOPT(C, LONGOPTS));

		ERR_EXCLUSIVE_OPTIONS(C, LONGOPTS, EXCL, EXCL_ST);

		SWITCH(C) {
		CASE 'A':
			ALL = 1;
			BREAK;
		CASE 'C':
			MNT_CONTEXT_DISABLE_CANONICALIZE(CXT, TRUE);
			BREAK;
		CASE 'F':
			MNT_CONTEXT_ENABLE_FAKE(CXT, TRUE);
			BREAK;
		CASE 'F':
			MNT_CONTEXT_ENABLE_FORK(CXT, TRUE);
			BREAK;
		CASE 'H':
			USAGE(STDOUT);
			BREAK;
		CASE 'I':
			MNT_CONTEXT_DISABLE_HELPERS(CXT, TRUE);
			BREAK;
		CASE 'N':
			MNT_CONTEXT_DISABLE_MTAB(CXT, TRUE);
			BREAK;
		CASE 'R':
			IF (MNT_CONTEXT_APPEND_OPTIONS(CXT, "RO"))
				ERR(MOUNT_EX_SYSERR, _("FAILED TO APPEND OPTIONS"));
			READWRITE = 0;
			BREAK;
		CASE 'V':
			MNT_CONTEXT_ENABLE_VERBOSE(CXT, TRUE);
			BREAK;
		CASE 'V':
			PRINT_VERSION();
			BREAK;
		CASE 'W':
			IF (MNT_CONTEXT_APPEND_OPTIONS(CXT, "RW"))
				ERR(MOUNT_EX_SYSERR, _("FAILED TO APPEND OPTIONS"));
			READWRITE = 1;
			BREAK;
		CASE 'O':
			IF (MNT_CONTEXT_APPEND_OPTIONS(CXT, OPTARG))
				ERR(MOUNT_EX_SYSERR, _("FAILED TO APPEND OPTIONS"));
			BREAK;
		CASE 'O':
			IF (MNT_CONTEXT_SET_OPTIONS_PATTERN(CXT, OPTARG))
				ERR(MOUNT_EX_SYSERR, _("FAILED TO SET OPTIONS PATTERN"));
			BREAK;
		CASE 'P':
                        WARNX(_("--PASS-FD IS NO LONGER SUPPORTED"));
			BREAK;
		CASE 'L':
			XASPRINTF(&SRCBUF, "LABEL=\"%S\"", OPTARG);
			MNT_CONTEXT_DISABLE_SWAPMATCH(CXT, 1);
			MNT_CONTEXT_SET_SOURCE(CXT, SRCBUF);
			FREE(SRCBUF);
			BREAK;
		CASE 'U':
			XASPRINTF(&SRCBUF, "UUID=\"%S\"", OPTARG);
			MNT_CONTEXT_DISABLE_SWAPMATCH(CXT, 1);
			MNT_CONTEXT_SET_SOURCE(CXT, SRCBUF);
			FREE(SRCBUF);
			BREAK;
		CASE 'L':
			SHOW_LABELS = 1;
			BREAK;
		CASE 'T':
			TYPES = OPTARG;
			BREAK;
		CASE 'T':
			FSTAB = APPEND_FSTAB(CXT, FSTAB, OPTARG);
			BREAK;
		CASE 'S':
			MNT_CONTEXT_ENABLE_SLOPPY(CXT, TRUE);
			BREAK;
		CASE 'B':
			OPER |= MS_BIND;
			BREAK;
		CASE 'M':
			OPER |= MS_MOVE;
			BREAK;
		CASE 'R':
			OPER |= (MS_BIND | MS_REC);
			BREAK;
		CASE MOUNT_OPT_SHARED:
			OPER |= MS_SHARED;
			BREAK;
		CASE MOUNT_OPT_SLAVE:
			OPER |= MS_SLAVE;
			BREAK;
		CASE MOUNT_OPT_PRIVATE:
			OPER |= MS_PRIVATE;
			BREAK;
		CASE MOUNT_OPT_UNBINDABLE:
			OPER |= MS_UNBINDABLE;
			BREAK;
		CASE MOUNT_OPT_RSHARED:
			OPER |= (MS_SHARED | MS_REC);
			BREAK;
		CASE MOUNT_OPT_RSLAVE:
			OPER |= (MS_SLAVE | MS_REC);
			BREAK;
		CASE MOUNT_OPT_RPRIVATE:
			OPER |= (MS_PRIVATE | MS_REC);
			BREAK;
		CASE MOUNT_OPT_RUNBINDABLE:
			OPER |= (MS_UNBINDABLE | MS_REC);
			BREAK;
		CASE MOUNT_OPT_TARGET:
			MNT_CONTEXT_DISABLE_SWAPMATCH(CXT, 1);
			MNT_CONTEXT_SET_TARGET(CXT, OPTARG);
			BREAK;
		CASE MOUNT_OPT_SOURCE:
			MNT_CONTEXT_DISABLE_SWAPMATCH(CXT, 1);
			MNT_CONTEXT_SET_SOURCE(CXT, OPTARG);
			BREAK;
		DEFAULT:
			USAGE(STDERR);
			BREAK;
		}
	}

	ARGC -= OPTIND;
	ARGV += OPTIND;

	IF (FSTAB && !MNT_CONTEXT_IS_NOCANONICALIZE(CXT)) {
		/*
		 * WE HAVE EXTERNAL (CONTEXT INDEPENDENT) FSTAB INSTANCE, LET'S
		 * MAKE A CONNECTION BETWEEN THE FSTAB AND THE CANONICALIZATION
		 * CACHE.
		 */
		STRUCT LIBMNT_CACHE *CACHE = MNT_CONTEXT_GET_CACHE(CXT);
		MNT_TABLE_SET_CACHE(FSTAB, CACHE);
	}

	IF (!MNT_CONTEXT_GET_SOURCE(CXT) &&
	    !MNT_CONTEXT_GET_TARGET(CXT) &&
	    !ARGC &&
	    !ALL) {
		IF (OPER)
			USAGE(STDERR);
		PRINT_ALL(CXT, TYPES, SHOW_LABELS);
		GOTO DONE;
	}

	IF (OPER && (TYPES || ALL || MNT_CONTEXT_GET_SOURCE(CXT)))
		USAGE(STDERR);

	IF (TYPES && (ALL || STRCHR(TYPES, ',') ||
			     STRNCMP(TYPES, "NO", 2) == 0))
		MNT_CONTEXT_SET_FSTYPE_PATTERN(CXT, TYPES);
	ELSE IF (TYPES)
		MNT_CONTEXT_SET_FSTYPE(CXT, TYPES);

	IF (ALL) {
		/*
		 * A) MOUNT ALL
		 */
		RC = MOUNT_ALL(CXT);
		GOTO DONE;

	} ELSE IF (ARGC == 0 && (MNT_CONTEXT_GET_SOURCE(CXT) ||
				 MNT_CONTEXT_GET_TARGET(CXT))) {
		/*
		 * B) MOUNT -L|-U|--SOURCE|--TARGET
		 */
		IF (MNT_CONTEXT_IS_RESTRICTED(CXT) &&
		    MNT_CONTEXT_GET_SOURCE(CXT) &&
		    MNT_CONTEXT_GET_TARGET(CXT))
			EXIT_NON_ROOT(NULL);

	} ELSE IF (ARGC == 1) {
		/*
		 * C) MOUNT [-L|-U|--SOURCE] <TARGET>
		 *    MOUNT <SOURCE|TARGET>
		 *
		 * NON-ROOT MAY SPECIFY SOURCE *OR* TARGET, BUT NOT BOTH
		 */
		IF (MNT_CONTEXT_IS_RESTRICTED(CXT) &&
		    MNT_CONTEXT_GET_SOURCE(CXT))
			EXIT_NON_ROOT(NULL);

		MNT_CONTEXT_SET_TARGET(CXT, ARGV[0]);

	} ELSE IF (ARGC == 2 && !MNT_CONTEXT_GET_SOURCE(CXT)
			     && !MNT_CONTEXT_GET_TARGET(CXT)) {
		/*
		 * D) MOUNT <SOURCE> <TARGET>
		 */
		IF (MNT_CONTEXT_IS_RESTRICTED(CXT))
			EXIT_NON_ROOT(NULL);
		MNT_CONTEXT_SET_SOURCE(CXT, ARGV[0]);
		MNT_CONTEXT_SET_TARGET(CXT, ARGV[1]);

	} ELSE
		USAGE(STDERR);

	IF (OPER) {
		/* MS_PROPAGATION OPERATIONS, LET'S SET THE MOUNT FLAGS */
		MNT_CONTEXT_SET_MFLAGS(CXT, OPER);

		/* FOR -MAKE* OR --BIND IS FSTAB UNNECESSARY */
		MNT_CONTEXT_SET_OPTSMODE(CXT, MNT_OMODE_NOTAB);
	}

	RC = MNT_CONTEXT_MOUNT(CXT);
	RC = MK_EXIT_CODE(CXT, RC);

	IF (RC == MOUNT_EX_SUCCESS && MNT_CONTEXT_IS_VERBOSE(CXT))
		SUCCESS_MESSAGE(CXT);
DONE:
	MNT_FREE_CONTEXT(CXT);
	MNT_FREE_TABLE(FSTAB);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198239_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CHECK_PASSWD(UNSIGNED CHAR *PASSWD, SIZE_T LENGTH)
{
	STRUCT DIGEST *D = NULL;
	UNSIGNED CHAR *PASSWD1_SUM;
	UNSIGNED CHAR *PASSWD2_SUM;
	INT RET = 0;
	INT HASH_LEN;

	IF (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {
		HASH_LEN = PBKDF2_LENGTH;
	} ELSE {
		D = DIGEST_ALLOC(PASSWD_SUM);
		IF (!D) {
			PR_ERR("NO SUCH DIGEST: %S\N",
			       PASSWD_SUM ? PASSWD_SUM : "NULL");
			RETURN -ENOENT;
		}

		HASH_LEN = DIGEST_LENGTH(D);
	}

	PASSWD1_SUM = CALLOC(HASH_LEN * 2, SIZEOF(UNSIGNED CHAR));
	IF (!PASSWD1_SUM)
		RETURN -ENOMEM;

	PASSWD2_SUM = PASSWD1_SUM + HASH_LEN;

	IF (IS_PASSWD_ENV_ENABLE())
		RET = READ_ENV_PASSWD(PASSWD2_SUM, HASH_LEN);
	ELSE IF (IS_PASSWD_DEFAULT_ENABLE())
		RET = READ_DEFAULT_PASSWD(PASSWD2_SUM, HASH_LEN);
	ELSE
		RET = -EINVAL;

	IF (RET < 0)
		GOTO ERR;

	IF (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {
		CHAR *KEY = PASSWD2_SUM + PBKDF2_SALT_LEN;
		CHAR *SALT = PASSWD2_SUM;
		INT KEYLEN = PBKDF2_LENGTH - PBKDF2_SALT_LEN;

		RET = PKCS5_PBKDF2_HMAC_SHA1(PASSWD, LENGTH, SALT,
			PBKDF2_SALT_LEN, PBKDF2_COUNT, KEYLEN, PASSWD1_SUM);
		IF (RET)
			GOTO ERR;

		IF (STRNCMP(PASSWD1_SUM, KEY, KEYLEN) == 0)
			RET = 1;
	} ELSE {
		RET = DIGEST_DIGEST(D, PASSWD, LENGTH, PASSWD1_SUM);

		IF (RET)
			GOTO ERR;

		IF (STRNCMP(PASSWD1_SUM, PASSWD2_SUM, HASH_LEN) == 0)
			RET = 1;
	}

ERR:
	FREE(PASSWD1_SUM);
	DIGEST_FREE(D);

	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209955_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT IWL_TRANS *IWL_TRANS_PCIE_ALLOC(STRUCT PCI_DEV *PDEV,
			       CONST STRUCT PCI_DEVICE_ID *ENT,
			       CONST STRUCT IWL_CFG_TRANS_PARAMS *CFG_TRANS)
{
	STRUCT IWL_TRANS_PCIE *TRANS_PCIE;
	STRUCT IWL_TRANS *TRANS;
	INT RET, ADDR_SIZE;

	RET = PCIM_ENABLE_DEVICE(PDEV);
	IF (RET)
		RETURN ERR_PTR(RET);

	IF (CFG_TRANS->GEN2)
		TRANS = IWL_TRANS_ALLOC(SIZEOF(STRUCT IWL_TRANS_PCIE),
					&PDEV->DEV, &TRANS_OPS_PCIE_GEN2);
	ELSE
		TRANS = IWL_TRANS_ALLOC(SIZEOF(STRUCT IWL_TRANS_PCIE),
					&PDEV->DEV, &TRANS_OPS_PCIE);

	IF (!TRANS)
		RETURN ERR_PTR(-ENOMEM);

	TRANS_PCIE = IWL_TRANS_GET_PCIE_TRANS(TRANS);

	TRANS_PCIE->TRANS = TRANS;
	TRANS_PCIE->OPMODE_DOWN = TRUE;
	SPIN_LOCK_INIT(&TRANS_PCIE->IRQ_LOCK);
	SPIN_LOCK_INIT(&TRANS_PCIE->REG_LOCK);
	MUTEX_INIT(&TRANS_PCIE->MUTEX);
	INIT_WAITQUEUE_HEAD(&TRANS_PCIE->UCODE_WRITE_WAITQ);
	TRANS_PCIE->TSO_HDR_PAGE = ALLOC_PERCPU(STRUCT IWL_TSO_HDR_PAGE);
	IF (!TRANS_PCIE->TSO_HDR_PAGE) {
		RET = -ENOMEM;
		GOTO OUT_NO_PCI;
	}
	TRANS_PCIE->DEBUG_RFKILL = -1;

	IF (!CFG_TRANS->BASE_PARAMS->PCIE_L1_ALLOWED) {
		/*
		 * W/A - SEEMS TO SOLVE WEIRD BEHAVIOR. WE NEED TO REMOVE THIS
		 * IF WE DON'T WANT TO STAY IN L1 ALL THE TIME. THIS WASTES A
		 * LOT OF POWER.
		 */
		PCI_DISABLE_LINK_STATE(PDEV, PCIE_LINK_STATE_L0S |
				       PCIE_LINK_STATE_L1 |
				       PCIE_LINK_STATE_CLKPM);
	}

	TRANS_PCIE->DEF_RX_QUEUE = 0;

	IF (CFG_TRANS->USE_TFH) {
		ADDR_SIZE = 64;
		TRANS_PCIE->MAX_TBS = IWL_TFH_NUM_TBS;
		TRANS_PCIE->TFD_SIZE = SIZEOF(STRUCT IWL_TFH_TFD);
	} ELSE {
		ADDR_SIZE = 36;
		TRANS_PCIE->MAX_TBS = IWL_NUM_OF_TBS;
		TRANS_PCIE->TFD_SIZE = SIZEOF(STRUCT IWL_TFD);
	}
	TRANS->MAX_SKB_FRAGS = IWL_PCIE_MAX_FRAGS(TRANS_PCIE);

	PCI_SET_MASTER(PDEV);

	RET = PCI_SET_DMA_MASK(PDEV, DMA_BIT_MASK(ADDR_SIZE));
	IF (!RET)
		RET = PCI_SET_CONSISTENT_DMA_MASK(PDEV,
						  DMA_BIT_MASK(ADDR_SIZE));
	IF (RET) {
		RET = PCI_SET_DMA_MASK(PDEV, DMA_BIT_MASK(32));
		IF (!RET)
			RET = PCI_SET_CONSISTENT_DMA_MASK(PDEV,
							  DMA_BIT_MASK(32));
		/* BOTH ATTEMPTS FAILED: */
		IF (RET) {
			DEV_ERR(&PDEV->DEV, "NO SUITABLE DMA AVAILABLE\N");
			GOTO OUT_NO_PCI;
		}
	}

	RET = PCIM_IOMAP_REGIONS_REQUEST_ALL(PDEV, BIT(0), DRV_NAME);
	IF (RET) {
		DEV_ERR(&PDEV->DEV, "PCIM_IOMAP_REGIONS_REQUEST_ALL FAILED\N");
		GOTO OUT_NO_PCI;
	}

	TRANS_PCIE->HW_BASE = PCIM_IOMAP_TABLE(PDEV)[0];
	IF (!TRANS_PCIE->HW_BASE) {
		DEV_ERR(&PDEV->DEV, "PCIM_IOMAP_TABLE FAILED\N");
		RET = -ENODEV;
		GOTO OUT_NO_PCI;
	}

	/* WE DISABLE THE RETRY_TIMEOUT REGISTER (0X41) TO KEEP
	 * PCI TX RETRIES FROM INTERFERING WITH C3 CPU STATE */
	PCI_WRITE_CONFIG_BYTE(PDEV, PCI_CFG_RETRY_TIMEOUT, 0X00);

	TRANS_PCIE->PCI_DEV = PDEV;
	IWL_DISABLE_INTERRUPTS(TRANS);

	TRANS->HW_REV = IWL_READ32(TRANS, CSR_HW_REV);
	IF (TRANS->HW_REV == 0XFFFFFFFF) {
		DEV_ERR(&PDEV->DEV, "HW_REV=0XFFFFFFFF, PCI ISSUES?\N");
		RET = -EIO;
		GOTO OUT_NO_PCI;
	}

	/*
	 * IN THE 8000 HW FAMILY THE FORMAT OF THE 4 BYTES OF CSR_HW_REV HAVE
	 * CHANGED, AND NOW THE REVISION STEP ALSO INCLUDES BIT 0-1 (NO MORE
	 * "DASH" VALUE). TO KEEP HW_REV BACKWARDS COMPATIBLE - WE'LL STORE IT
	 * IN THE OLD FORMAT.
	 */
	IF (CFG_TRANS->DEVICE_FAMILY >= IWL_DEVICE_FAMILY_8000) {
		TRANS->HW_REV = (TRANS->HW_REV & 0XFFF0) |
				(CSR_HW_REV_STEP(TRANS->HW_REV << 2) << 2);

		RET = IWL_PCIE_PREPARE_CARD_HW(TRANS);
		IF (RET) {
			IWL_WARN(TRANS, "EXIT HW NOT READY\N");
			GOTO OUT_NO_PCI;
		}

		/*
		 * IN-ORDER TO RECOGNIZE C STEP DRIVER SHOULD READ CHIP VERSION
		 * ID LOCATED AT THE AUX BUS MISC ADDRESS SPACE.
		 */
		RET = IWL_FINISH_NIC_INIT(TRANS, CFG_TRANS);
		IF (RET)
			GOTO OUT_NO_PCI;

	}

	IWL_DEBUG_INFO(TRANS, "HW REV: 0X%0X\N", TRANS->HW_REV);

	IWL_PCIE_SET_INTERRUPT_CAPA(PDEV, TRANS, CFG_TRANS);
	TRANS->HW_ID = (PDEV->DEVICE << 16) + PDEV->SUBSYSTEM_DEVICE;
	SNPRINTF(TRANS->HW_ID_STR, SIZEOF(TRANS->HW_ID_STR),
		 "PCI ID: 0X%04X:0X%04X", PDEV->DEVICE, PDEV->SUBSYSTEM_DEVICE);

	/* INITIALIZE THE WAIT QUEUE FOR COMMANDS */
	INIT_WAITQUEUE_HEAD(&TRANS_PCIE->WAIT_COMMAND_QUEUE);

	INIT_WAITQUEUE_HEAD(&TRANS_PCIE->SX_WAITQ);

	IF (TRANS_PCIE->MSIX_ENABLED) {
		RET = IWL_PCIE_INIT_MSIX_HANDLER(PDEV, TRANS_PCIE);
		IF (RET)
			GOTO OUT_NO_PCI;
	 } ELSE {
		RET = IWL_PCIE_ALLOC_ICT(TRANS);
		IF (RET)
			GOTO OUT_NO_PCI;

		RET = DEVM_REQUEST_THREADED_IRQ(&PDEV->DEV, PDEV->IRQ,
						IWL_PCIE_ISR,
						IWL_PCIE_IRQ_HANDLER,
						IRQF_SHARED, DRV_NAME, TRANS);
		IF (RET) {
			IWL_ERR(TRANS, "ERROR ALLOCATING IRQ %D\N", PDEV->IRQ);
			GOTO OUT_FREE_ICT;
		}
		TRANS_PCIE->INTA_MASK = CSR_INI_SET_MASK;
	 }

	TRANS_PCIE->RBA.ALLOC_WQ = ALLOC_WORKQUEUE("RB_ALLOCATOR",
						   WQ_HIGHPRI | WQ_UNBOUND, 1);
	INIT_WORK(&TRANS_PCIE->RBA.RX_ALLOC, IWL_PCIE_RX_ALLOCATOR_WORK);

#IFDEF CONFIG_IWLWIFI_DEBUGFS
	TRANS_PCIE->FW_MON_DATA.STATE = IWL_FW_MON_DBGFS_STATE_CLOSED;
	MUTEX_INIT(&TRANS_PCIE->FW_MON_DATA.MUTEX);
#ENDIF

	RETURN TRANS;

OUT_FREE_ICT:
	IWL_PCIE_FREE_ICT(TRANS);
OUT_NO_PCI:
	FREE_PERCPU(TRANS_PCIE->TSO_HDR_PAGE);
	IWL_TRANS_FREE(TRANS);
	RETURN ERR_PTR(RET);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294362_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
C_VALID_CIVIL_P(INT Y, INT M, INT D, DOUBLE SG,
		INT *RM, INT *RD, INT *RJD, INT *NS)
{
    INT RY;

    IF (M < 0)
	M += 13;
    IF (D < 0) {
	IF (!C_FIND_LDOM(Y, M, SG, RJD, NS))
	    RETURN 0;
	C_JD_TO_CIVIL(*RJD + D + 1, SG, &RY, RM, RD);
	IF (RY != Y || *RM != M)
	    RETURN 0;
	D = *RD;
    }
    C_CIVIL_TO_JD(Y, M, D, SG, RJD, NS);
    C_JD_TO_CIVIL(*RJD, SG, &RY, RM, RD);
    IF (RY != Y || *RM != M || *RD != D)
	RETURN 0;
    RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195238_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SETUP_SECCOMP (FLATPAKBWRAP   *BWRAP,
               CONST CHAR     *ARCH,
               GULONG          ALLOWED_PERSONALITY,
               FLATPAKRUNFLAGS RUN_FLAGS,
               GERROR        **ERROR)
{
  GBOOLEAN MULTIARCH = (RUN_FLAGS & FLATPAK_RUN_FLAG_MULTIARCH) != 0;
  GBOOLEAN DEVEL = (RUN_FLAGS & FLATPAK_RUN_FLAG_DEVEL) != 0;

  __ATTRIBUTE__((CLEANUP (CLEANUP_SECCOMP))) SCMP_FILTER_CTX SECCOMP = NULL;

  /**** BEGIN NOTE ON CODE SHARING
   *
   * THERE ARE TODAY A NUMBER OF DIFFERENT LINUX CONTAINER
   * IMPLEMENTATIONS.  THAT WILL LIKELY CONTINUE FOR LONG INTO THE
   * FUTURE.  BUT WE CAN STILL TRY TO SHARE CODE, AND IT'S IMPORTANT
   * TO DO SO BECAUSE IT AFFECTS WHAT LIBRARY AND APPLICATION WRITERS
   * CAN DO, AND WE SHOULD SUPPORT CODE PORTABILITY BETWEEN DIFFERENT
   * CONTAINER TOOLS.
   *
   * THIS SYSCALL BLOCKLIST IS COPIED FROM LINUX-USER-CHROOT, WHICH WAS IN TURN
   * CLEARLY INFLUENCED BY THE SANDSTORM.IO BLOCKLIST.
   *
   * IF YOU MAKE ANY CHANGES HERE, I SUGGEST SENDING THE CHANGES ALONG
   * TO OTHER SANDBOX MAINTAINERS.  USING THE LIBSECCOMP LIST IS ALSO
   * AN APPROPRIATE VENUE:
   * HTTPS://GROUPS.GOOGLE.COM/FORUM/#!FORUM/LIBSECCOMP
   *
   * A NON-EXHAUSTIVE LIST OF LINKS TO CONTAINER TOOLING THAT MIGHT
   * WANT TO SHARE THIS BLOCKLIST:
   *
   *  HTTPS://GITHUB.COM/SANDSTORM-IO/SANDSTORM
   *    IN SRC/SANDSTORM/SUPERVISOR.C++
   *  HTTPS://GITHUB.COM/FLATPAK/FLATPAK.GIT
   *    IN COMMON/FLATPAK-RUN.C
   *  HTTPS://GIT.GNOME.ORG/BROWSE/LINUX-USER-CHROOT
   *    IN SRC/SETUP-SECCOMP.C
   *
   **** END NOTE ON CODE SHARING
   */
  STRUCT
  {
    INT                  SCALL;
    STRUCT SCMP_ARG_CMP *ARG;
  } SYSCALL_BLOCKLIST[] = {
    /* BLOCK DMESG */
    {SCMP_SYS (SYSLOG)},
    /* USELESS OLD SYSCALL */
    {SCMP_SYS (USELIB)},
    /* DON'T ALLOW DISABLING ACCOUNTING */
    {SCMP_SYS (ACCT)},
    /* 16-BIT CODE IS UNNECESSARY IN THE SANDBOX, AND MODIFY_LDT IS A
       HISTORIC SOURCE OF INTERESTING INFORMATION LEAKS. */
    {SCMP_SYS (MODIFY_LDT)},
    /* DON'T ALLOW READING CURRENT QUOTA USE */
    {SCMP_SYS (QUOTACTL)},

    /* DON'T ALLOW ACCESS TO THE KERNEL KEYRING */
    {SCMP_SYS (ADD_KEY)},
    {SCMP_SYS (KEYCTL)},
    {SCMP_SYS (REQUEST_KEY)},

    /* SCARY VM/NUMA OPS */
    {SCMP_SYS (MOVE_PAGES)},
    {SCMP_SYS (MBIND)},
    {SCMP_SYS (GET_MEMPOLICY)},
    {SCMP_SYS (SET_MEMPOLICY)},
    {SCMP_SYS (MIGRATE_PAGES)},

    /* DON'T ALLOW SUBNAMESPACE SETUPS: */
    {SCMP_SYS (UNSHARE)},
    {SCMP_SYS (MOUNT)},
    {SCMP_SYS (PIVOT_ROOT)},
#IF DEFINED(__S390__) || DEFINED(__S390X__) || DEFINED(__CRIS__)
    /* ARCHITECTURES WITH CONFIG_CLONE_BACKWARDS2: THE CHILD STACK
     * AND FLAGS ARGUMENTS ARE REVERSED SO THE FLAGS COME SECOND */
    {SCMP_SYS (CLONE), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#ELSE
    /* NORMALLY THE FLAGS COME FIRST */
    {SCMP_SYS (CLONE), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#ENDIF

    /* DON'T ALLOW FAKING INPUT TO THE CONTROLLING TTY (CVE-2017-5226) */
    {SCMP_SYS (IOCTL), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0XFFFFFFFFU, (INT) TIOCSTI)},
  };

  STRUCT
  {
    INT                  SCALL;
    STRUCT SCMP_ARG_CMP *ARG;
  } SYSCALL_NONDEVEL_BLOCKLIST[] = {
    /* PROFILING OPERATIONS; WE EXPECT THESE TO BE DONE BY TOOLS FROM OUTSIDE
     * THE SANDBOX.  IN PARTICULAR PERF HAS BEEN THE SOURCE OF MANY CVES.
     */
    {SCMP_SYS (PERF_EVENT_OPEN)},
    /* DON'T ALLOW YOU TO SWITCH TO BSD EMULATION OR WHATNOT */
    {SCMP_SYS (PERSONALITY), &SCMP_A0 (SCMP_CMP_NE, ALLOWED_PERSONALITY)},
    {SCMP_SYS (PTRACE)}
  };
  /* BLOCKLIST ALL BUT UNIX, INET, INET6 AND NETLINK */
  STRUCT
  {
    INT             FAMILY;
    FLATPAKRUNFLAGS FLAGS_MASK;
  } SOCKET_FAMILY_ALLOWLIST[] = {
    /* NOTE: KEEP IN NUMERICAL ORDER */
    { AF_UNSPEC, 0 },
    { AF_LOCAL, 0 },
    { AF_INET, 0 },
    { AF_INET6, 0 },
    { AF_NETLINK, 0 },
    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },
    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },
  };
  INT LAST_ALLOWED_FAMILY;
  INT I, R;
  G_AUTO(GLNXTMPFILE) SECCOMP_TMPF  = { 0, };

  SECCOMP = SECCOMP_INIT (SCMP_ACT_ALLOW);
  IF (!SECCOMP)
    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("INITIALIZE SECCOMP FAILED"));

  IF (ARCH != NULL)
    {
      UINT32_T ARCH_ID = 0;
      CONST UINT32_T *EXTRA_ARCHES = NULL;

      IF (STRCMP (ARCH, "I386") == 0)
        {
          ARCH_ID = SCMP_ARCH_X86;
        }
      ELSE IF (STRCMP (ARCH, "X86_64") == 0)
        {
          ARCH_ID = SCMP_ARCH_X86_64;
          EXTRA_ARCHES = SECCOMP_X86_64_EXTRA_ARCHES;
        }
      ELSE IF (STRCMP (ARCH, "ARM") == 0)
        {
          ARCH_ID = SCMP_ARCH_ARM;
        }
#IFDEF SCMP_ARCH_AARCH64
      ELSE IF (STRCMP (ARCH, "AARCH64") == 0)
        {
          ARCH_ID = SCMP_ARCH_AARCH64;
          EXTRA_ARCHES = SECCOMP_AARCH64_EXTRA_ARCHES;
        }
#ENDIF

      /* WE ONLY REALLY NEED TO HANDLE ARCHES ON MULTIARCH SYSTEMS.
       * IF ONLY ONE ARCH IS SUPPORTED THE DEFAULT IS FINE */
      IF (ARCH_ID != 0)
        {
          /* THIS *ADDS* THE TARGET ARCH, INSTEAD OF REPLACING THE
             NATIVE ONE. THIS IS NOT IDEAL, BECAUSE WE'D LIKE TO ONLY
             ALLOW THE TARGET ARCH, BUT WE CAN'T REALLY DISALLOW THE
             NATIVE ARCH AT THIS POINT, BECAUSE THEN BUBBLEWRAP
             COULDN'T CONTINUE RUNNING. */
          R = SECCOMP_ARCH_ADD (SECCOMP, ARCH_ID);
          IF (R < 0 && R != -EEXIST)
            RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO ADD ARCHITECTURE TO SECCOMP FILTER"));

          IF (MULTIARCH && EXTRA_ARCHES != NULL)
            {
              FOR (I = 0; EXTRA_ARCHES[I] != 0; I++)
                {
                  R = SECCOMP_ARCH_ADD (SECCOMP, EXTRA_ARCHES[I]);
                  IF (R < 0 && R != -EEXIST)
                    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO ADD MULTIARCH ARCHITECTURE TO SECCOMP FILTER"));
                }
            }
        }
    }

  /* TODO: SHOULD WE FILTER THE KERNEL KEYRING SYSCALLS IN SOME WAY?
   * WE DO WANT THEM TO BE USED BY DESKTOP APPS, BUT THEY COULD ALSO PERHAPS
   * LEAK SYSTEM STUFF OR SECRETS FROM OTHER APPS.
   */

  FOR (I = 0; I < G_N_ELEMENTS (SYSCALL_BLOCKLIST); I++)
    {
      INT SCALL = SYSCALL_BLOCKLIST[I].SCALL;
      IF (SYSCALL_BLOCKLIST[I].ARG)
        R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (EPERM), SCALL, 1, *SYSCALL_BLOCKLIST[I].ARG);
      ELSE
        R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (EPERM), SCALL, 0);
      IF (R < 0 && R == -EFAULT /* UNKNOWN SYSCALL */)
        RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO BLOCK SYSCALL %D"), SCALL);
    }

  IF (!DEVEL)
    {
      FOR (I = 0; I < G_N_ELEMENTS (SYSCALL_NONDEVEL_BLOCKLIST); I++)
        {
          INT SCALL = SYSCALL_NONDEVEL_BLOCKLIST[I].SCALL;
          IF (SYSCALL_NONDEVEL_BLOCKLIST[I].ARG)
            R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (EPERM), SCALL, 1, *SYSCALL_NONDEVEL_BLOCKLIST[I].ARG);
          ELSE
            R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (EPERM), SCALL, 0);

          IF (R < 0 && R == -EFAULT /* UNKNOWN SYSCALL */)
            RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO BLOCK SYSCALL %D"), SCALL);
        }
    }

  /* SOCKET FILTERING DOESN'T WORK ON E.G. I386, SO IGNORE FAILURES HERE
   * HOWEVER, WE NEED TO USER SECCOMP_RULE_ADD_EXACT TO AVOID LIBSECCOMP DOING
   * SOMETHING ELSE: HTTPS://GITHUB.COM/SECCOMP/LIBSECCOMP/ISSUES/8 */
  LAST_ALLOWED_FAMILY = -1;
  FOR (I = 0; I < G_N_ELEMENTS (SOCKET_FAMILY_ALLOWLIST); I++)
    {
      INT FAMILY = SOCKET_FAMILY_ALLOWLIST[I].FAMILY;
      INT DISALLOWED;

      IF (SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK != 0 &&
          (SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK & RUN_FLAGS) != SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK)
        CONTINUE;

      FOR (DISALLOWED = LAST_ALLOWED_FAMILY + 1; DISALLOWED < FAMILY; DISALLOWED++)
        {
          /* BLOCKLIST THE IN-BETWEEN VALID FAMILIES */
          SECCOMP_RULE_ADD_EXACT (SECCOMP, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (SOCKET), 1, SCMP_A0 (SCMP_CMP_EQ, DISALLOWED));
        }
      LAST_ALLOWED_FAMILY = FAMILY;
    }
  /* BLOCKLIST THE REST */
  SECCOMP_RULE_ADD_EXACT (SECCOMP, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (SOCKET), 1, SCMP_A0 (SCMP_CMP_GE, LAST_ALLOWED_FAMILY + 1));

  IF (!GLNX_OPEN_ANONYMOUS_TMPFILE_FULL (O_RDWR | O_CLOEXEC, "/TMP", &SECCOMP_TMPF, ERROR))
    RETURN FALSE;

  IF (SECCOMP_EXPORT_BPF (SECCOMP, SECCOMP_TMPF.FD) != 0)
    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO EXPORT BPF"));

  LSEEK (SECCOMP_TMPF.FD, 0, SEEK_SET);

  FLATPAK_BWRAP_ADD_ARGS_DATA_FD (BWRAP,
                                  "--SECCOMP", GLNX_STEAL_FD (&SECCOMP_TMPF.FD), NULL);

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201382_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DRILL_PARSE_T_CODE(GERB_FILE_T *FD, DRILL_STATE_T *STATE,
			GERBV_IMAGE_T *IMAGE, SSIZE_T FILE_LINE)
{
    INT TOOL_NUM;
    GBOOLEAN DONE = FALSE;
    INT TEMP;
    DOUBLE SIZE;
    GERBV_DRILL_STATS_T *STATS = IMAGE->DRILL_STATS;
    GERBV_APERTURE_T *APERT;
    GCHAR *TMPS;
    GCHAR *STRING;

    DPRINTF("---> ENTERING %S()...\N", __FUNCTION__);

    /* SNEAK A PEEK AT WHAT'S HIDING AFTER THE 'T'. UGLY FIX FOR
       BROKEN HEADERS FROM ORCAD, WHICH IS CRAP */
    TEMP = GERB_FGETC(FD);
    DPRINTF("  FOUND A CHAR '%S' (0X%02X) AFTER THE T\N",
	    GERBV_ESCAPE_CHAR(TEMP), TEMP);
    
    /* MIGHT BE A TOOL TOOL CHANGE STOP SWITCH ON/OFF*/
    IF((TEMP == 'C') && ((FD->PTR + 2) < FD->DATALEN)){
    	IF(GERB_FGETC(FD) == 'S'){
    	    IF (GERB_FGETC(FD) == 'T' ){
    	  	FD->PTR -= 4;
    	  	TMPS = GET_LINE(FD++);
    	  	GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_NOTE, -1,
			_("TOOL CHANGE STOP SWITCH FOUND \"%S\" "
			    "AT LINE %LD IN FILE \"%S\""),
			TMPS, FILE_LINE, FD->FILENAME);
	  	G_FREE (TMPS);

	  	RETURN -1;
	    }
	    GERB_UNGETC(FD);
	}
	GERB_UNGETC(FD);
    }

    IF( !(ISDIGIT(TEMP) != 0 || TEMP == '+' || TEMP =='-') ) {
	IF(TEMP != EOF) {
	    GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_ERROR, -1,
		   _("ORCAD BUG: JUNK TEXT FOUND IN PLACE OF TOOL DEFINITION"));
	    TMPS = GET_LINE(FD);
	    GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_WARNING, -1,
		    _("JUNK TEXT \"%S\" "
			"AT LINE %LD IN FILE \"%S\""),
		    TMPS, FILE_LINE, FD->FILENAME);
	    G_FREE (TMPS);
	    GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_WARNING, -1,
				  _("IGNORING JUNK TEXT"));
	}
	RETURN -1;
    }
    GERB_UNGETC(FD);

    TOOL_NUM = (INT) GERB_FGETINT(FD, NULL);
    DPRINTF ("  HANDLING TOOL T%D AT LINE %LD\N", TOOL_NUM, FILE_LINE);

    IF (TOOL_NUM == 0) 
	RETURN TOOL_NUM; /* T00 IS A COMMAND TO UNLOAD THE DRILL */

    IF (TOOL_NUM < TOOL_MIN || TOOL_NUM >= TOOL_MAX) {
	GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_ERROR, -1,
		_("OUT OF BOUNDS DRILL NUMBER %D "
		    "AT LINE %LD IN FILE \"%S\""),
		TOOL_NUM, FILE_LINE, FD->FILENAME);
    }

    /* SET THE CURRENT TOOL TO THE CORRECT ONE */
    STATE->CURRENT_TOOL = TOOL_NUM;
    APERT = IMAGE->APERTURE[TOOL_NUM];

    /* CHECK FOR A SIZE DEFINITION */
    TEMP = GERB_FGETC(FD);

    /* THIS BIT OF CODE LOOKS FOR A TOOL DEFINITION BY SCANNING FOR STRINGS
     * OF FORM TXXC, TXXF, TXXS.  */
    WHILE (!DONE) {
	SWITCH((CHAR)TEMP) {
	CASE 'C':
	    SIZE = READ_DOUBLE(FD, STATE->HEADER_NUMBER_FORMAT, GERBV_OMIT_ZEROS_TRAILING, STATE->DECIMALS);
	    DPRINTF ("  READ A SIZE OF %G\N", SIZE);

	    IF (STATE->UNIT == GERBV_UNIT_MM) {
		SIZE /= 25.4;
	    } ELSE IF(SIZE >= 4.0) {
		/* IF THE DRILL SIZE IS >= 4 INCHES, ASSUME THAT THIS
		   MUST BE WRONG AND THAT THE UNITS ARE MILS.
		   THE LIMIT BEING 4 INCHES IS BECAUSE THE SMALLEST DRILL
		   I'VE EVER SEEN USED IS 0,3MM(ABOUT 12MIL). HALF OF THAT
		   SEEMED A BIT TOO SMALL A MARGIN, SO A THIRD IT IS */

		GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_ERROR, -1,
			_("READ A DRILL OF DIAMETER %G INCHES "
			    "AT LINE %LD IN FILE \"%S\""),
			    SIZE, FILE_LINE, FD->FILENAME);
		GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_WARNING, -1,
			_("ASSUMING UNITS ARE MILS"));
		SIZE /= 1000.0;
	    }

	    IF (SIZE <= 0. || SIZE >= 10000.) {
		GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_ERROR, -1,
			_("UNREASONABLE DRILL SIZE %G FOUND FOR DRILL %D "
			    "AT LINE %LD IN FILE \"%S\""),
			    SIZE, TOOL_NUM, FILE_LINE, FD->FILENAME);
	    } ELSE {
		IF (APERT != NULL) {
		    /* ALLOW A REDEFINE OF A TOOL ONLY IF THE NEW DEFINITION IS EXACTLY THE SAME.
		     * THIS AVOID LOTS OF SPURIOUS COMPLAINTS WITH THE OUTPUT OF SOME CAD
		     * TOOLS WHILE KEEPING COMPLAINTS IF THERE IS A TRUE PROBLEM
		     */
		    IF (APERT->PARAMETER[0] != SIZE
		    ||  APERT->TYPE != GERBV_APTYPE_CIRCLE
		    ||  APERT->NUF_PARAMETERS != 1
		    ||  APERT->UNIT != GERBV_UNIT_INCH) {

			GERBV_STATS_PRINTF(STATS->ERROR_LIST,
				GERBV_MESSAGE_ERROR, -1,
				_("FOUND REDEFINITION OF DRILL %D "
				"AT LINE %LD IN FILE \"%S\""),
				TOOL_NUM, FILE_LINE, FD->FILENAME);
		    }
		} ELSE {
		    APERT = IMAGE->APERTURE[TOOL_NUM] =
						G_NEW0(GERBV_APERTURE_T, 1);
		    IF (APERT == NULL)
			GERB_FATAL_ERROR("MALLOC TOOL FAILED IN %S()",
					__FUNCTION__);

		    /* THERE'S REALLY NO WAY OF KNOWING WHAT UNIT THE TOOLS
		       ARE DEFINED IN WITHOUT SNEAKING A PEEK IN THE REST OF
		       THE FILE FIRST. THAT'S DONE IN DRILL_GUESS_FORMAT() */
		    APERT->PARAMETER[0] = SIZE;
		    APERT->TYPE = GERBV_APTYPE_CIRCLE;
		    APERT->NUF_PARAMETERS = 1;
		    APERT->UNIT = GERBV_UNIT_INCH;
		}
	    }
	    
	    /* ADD THE TOOL WHOSE DEFINITION WE JUST FOUND INTO THE LIST
	     * OF TOOLS FOR THIS LAYER USED TO GENERATE STATISTICS. */
	    STATS = IMAGE->DRILL_STATS;
	    STRING = G_STRDUP_PRINTF("%S", (STATE->UNIT == GERBV_UNIT_MM ? _("MM") : _("INCH")));
	    DRILL_STATS_ADD_TO_DRILL_LIST(STATS->DRILL_LIST, 
					  TOOL_NUM, 
					  STATE->UNIT == GERBV_UNIT_MM ? SIZE*25.4 : SIZE, 
					  STRING);
	    G_FREE(STRING);
	    BREAK;

	CASE 'F':
	CASE 'S' :
	    /* SILENTLY IGNORED. THEY'RE NOT IMPORTANT. */
	    GERB_FGETINT(FD, NULL);
	    BREAK;

	DEFAULT:
	    /* STOP WHEN FINDING ANYTHING BUT WHAT'S EXPECTED
	       (AND PUT IT BACK) */
	    GERB_UNGETC(FD);
	    DONE = TRUE;
	    BREAK;
	}  /* SWITCH((CHAR)TEMP) */

	TEMP = GERB_FGETC(FD);
	IF (EOF == TEMP) {
	    GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_ERROR, -1,
		    _("UNEXPECTED EOF ENCOUNTERED IN HEADER OF "
			"DRILL FILE \"%S\""), FD->FILENAME);

	/* RESTORE NEW LINE CHARACTER FOR PROCESSING */
	IF ('\N' == TEMP || '\R' == TEMP)
	    GERB_UNGETC(FD);
	}
    }   /* WHILE(!DONE) */  /* DONE LOOKING AT TOOL DEFINITIONS */

    /* CATCH THE TOOLS THAT AREN'T DEFINED.
       THIS ISN'T STRICTLY A GOOD THING, BUT AT LEAST SOMETHING IS SHOWN */
    IF (APERT == NULL) {
        DOUBLE DIA;

	APERT = IMAGE->APERTURE[TOOL_NUM] = G_NEW0(GERBV_APERTURE_T, 1);
	IF (APERT == NULL)
	    GERB_FATAL_ERROR("MALLOC TOOL FAILED IN %S()", __FUNCTION__);

        /* SEE IF WE HAVE THE TOOL TABLE */
        DIA = GERBV_GET_TOOL_DIAMETER(TOOL_NUM);
        IF (DIA <= 0) {
            /*
             * THERE IS NO TOOL. SO GO OUT AND MAKE SOME.
             * THIS SIZE CALCULATION IS, OF COURSE, TOTALLY BOGUS.
             */
            DIA = (DOUBLE)(16 + 8 * TOOL_NUM) / 1000;
            /*
             * OOOH, THIS IS SOOO UGLY. BUT SOME CAD SYSTEMS SEEM TO ALWAYS
             * USE T00 AT THE END OF THE FILE WHILE OTHERS THAT DON'T HAVE
             * TOOL DEFINITIONS INSIDE THE FILE NEVER SEEM TO USE T00 AT ALL.
             */
            IF (TOOL_NUM != 0) {
		GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_ERROR, -1,
			_("TOOL %02D USED WITHOUT BEING DEFINED "
			    "AT LINE %LD IN FILE \"%S\""),
			TOOL_NUM, FILE_LINE, FD->FILENAME);
		GERBV_STATS_PRINTF(STATS->ERROR_LIST, GERBV_MESSAGE_WARNING, -1,
			_("SETTING A DEFAULT SIZE OF %G\""), DIA);
            }
	}

	APERT->TYPE = GERBV_APTYPE_CIRCLE;
	APERT->NUF_PARAMETERS = 1;
	APERT->PARAMETER[0] = DIA;

	/* ADD THE TOOL WHOSE DEFINITION WE JUST FOUND INTO THE LIST
	 * OF TOOLS FOR THIS LAYER USED TO GENERATE STATISTICS. */
	IF (TOOL_NUM != 0) {  /* ONLY ADD NON-ZERO TOOL NUMS.  
			       * ZERO = UNLOAD COMMAND. */
	    STATS = IMAGE->DRILL_STATS;
	    STRING = G_STRDUP_PRINTF("%S", 
				     (STATE->UNIT == GERBV_UNIT_MM ? _("MM") : _("INCH")));
	    DRILL_STATS_ADD_TO_DRILL_LIST(STATS->DRILL_LIST, 
					  TOOL_NUM, 
					  STATE->UNIT == GERBV_UNIT_MM ? DIA*25.4 : DIA,
					  STRING);
	    G_FREE(STRING);
	}
    } /* IF(IMAGE->APERTURE[TOOL_NUM] == NULL) */	
    
    DPRINTF("<----  ...LEAVING %S()\N", __FUNCTION__);

    RETURN TOOL_NUM;
} /* DRILL_PARSE_T_CODE() */
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 464941_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE INT IS_IN_CP950_PUA(INT C1, INT C) {
	IF ((C1 >= 0XFA && C1 <= 0XFE) || (C1 >= 0X8E && C1 <= 0XA0) ||
			(C1 >= 0X81 && C1 <= 0X8D) || (C1 >= 0XC7 && C1 <= 0XC8)) {
		RETURN (C >=0X40 && C <= 0X7E) || (C >= 0XA1 && C <= 0XFE);
	}
	IF (C1 == 0XC6) {
		RETURN C >= 0XA1 && C <= 0XFE;
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 353127_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  BOOL MATCHES(CONST REF *IDA, DOUBLE M11A, DOUBLE M12A,
		DOUBLE M21A, DOUBLE M22A)
    { RETURN FONTID == *IDA &&
	     M11 == M11A && M12 == M12A && M21 == M21A && M22 == M22A; }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273900_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID HANDLE_STOR(CTRL_T *CTRL, CHAR *FILE)
{
	FILE *FP = NULL;
	CHAR *PATH;
	INT RC = 0;

	PATH = COMPOSE_ABSPATH(CTRL, FILE);
	IF (!PATH) {
		INFO("INVALID PATH FOR %S: %M", FILE);
		GOTO FAIL;
	}

	DBG("TRYING TO WRITE TO %S ...", PATH);
	FP = FOPEN(PATH, "WB");
	IF (!FP) {
		/* IF EACCESS CLIENT IS TRYING TO DO SOMETHING DISALLOWED */
		ERR(ERRNO, "FAILED WRITING %S", PATH);
	FAIL:
		SEND_MSG(CTRL->SD, "451 TROUBLE STORING FILE.\R\N");
		DO_ABORT(CTRL);
		RETURN;
	}

	CTRL->FP = FP;
	CTRL->FILE = STRDUP(FILE);

	IF (CTRL->DATA_SD > -1) {
		IF (CTRL->OFFSET)
			RC = FSEEK(FP, CTRL->OFFSET, SEEK_SET);
		IF (RC) {
			DO_ABORT(CTRL);
			SEND_MSG(CTRL->SD, "551 FAILED SEEKING TO THAT POSITION IN FILE.\R\N");
			RETURN;
		}

		SEND_MSG(CTRL->SD, "125 DATA CONNECTION ALREADY OPEN; TRANSFER STARTING.\R\N");
		UEV_IO_INIT(CTRL->CTX, &CTRL->DATA_WATCHER, DO_STOR, CTRL, CTRL->DATA_SD, UEV_READ);
		RETURN;
	}

	DO_PORT(CTRL, 3);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 438681_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID RPMSG_XMIT_DONE(STRUCT VIRTQUEUE *SVQ)
{
	STRUCT VIRTPROC_INFO *VRP = SVQ->VDEV->PRIV;

	DEV_DBG(&SVQ->VDEV->DEV, "%S\N", __FUNC__);

	/* WAKE UP POTENTIAL SENDERS THAT ARE WAITING FOR A TX BUFFER */
	WAKE_UP_INTERRUPTIBLE(&VRP->SENDQ);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 310336_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DIRSERV_GET_NETWORKSTATUS_V2_FINGERPRINTS(SMARTLIST_T *RESULT,
                                          CONST CHAR *KEY)
{
  TOR_ASSERT(RESULT);

  IF (!CACHED_V2_NETWORKSTATUS)
    CACHED_V2_NETWORKSTATUS = DIGESTMAP_NEW();

  IF (SHOULD_GENERATE_V2_NETWORKSTATUS())
    GENERATE_V2_NETWORKSTATUS_OPINION();

  IF (!STRCMP(KEY,"AUTHORITY")) {
    IF (AUTHDIR_MODE_V2(GET_OPTIONS())) {
      ROUTERINFO_T *ME = ROUTER_GET_MY_ROUTERINFO();
      IF (ME)
        SMARTLIST_ADD(RESULT,
                      TOR_MEMDUP(ME->CACHE_INFO.IDENTITY_DIGEST, DIGEST_LEN));
    }
  } ELSE IF (!STRCMP(KEY, "ALL")) {
    IF (DIGESTMAP_SIZE(CACHED_V2_NETWORKSTATUS)) {
      DIGESTMAP_ITER_T *ITER;
      ITER = DIGESTMAP_ITER_INIT(CACHED_V2_NETWORKSTATUS);
      WHILE (!DIGESTMAP_ITER_DONE(ITER)) {
        CONST CHAR *IDENT;
        VOID *VAL;
        DIGESTMAP_ITER_GET(ITER, &IDENT, &VAL);
        SMARTLIST_ADD(RESULT, TOR_MEMDUP(IDENT, DIGEST_LEN));
        ITER = DIGESTMAP_ITER_NEXT(CACHED_V2_NETWORKSTATUS, ITER);
      }
    } ELSE {
      SMARTLIST_FOREACH(ROUTER_GET_TRUSTED_DIR_SERVERS(),
                  TRUSTED_DIR_SERVER_T *, DS,
                  IF (DS->TYPE & V2_AUTHORITY)
                    SMARTLIST_ADD(RESULT, TOR_MEMDUP(DS->DIGEST, DIGEST_LEN)));
    }
    SMARTLIST_SORT_DIGESTS(RESULT);
    IF (SMARTLIST_LEN(RESULT) == 0)
      LOG_INFO(LD_DIRSERV,
               "CLIENT REQUESTED 'ALL' NETWORK STATUS OBJECTS; WE HAVE NONE.");
  } ELSE IF (!STRCMPSTART(KEY, "FP/")) {
    DIR_SPLIT_RESOURCE_INTO_FINGERPRINTS(KEY+3, RESULT, NULL,
                                         DSR_HEX|DSR_SORT_UNIQ);
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234256_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DISPLAY_AUGMENTATION_DATA (CONST UNSIGNED CHAR * DATA, CONST BFD_SIZE_TYPE LEN)
{
  BFD_SIZE_TYPE I;

  I = PRINTF (_("  AUGMENTATION DATA:    "));
  DISPLAY_DATA (I, DATA, LEN);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226305_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

VOID DMLP_BOX_DEL(GF_BOX *S)
{
	GF_FREE(S);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253554_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SMB3_SIMPLE_FALLOCATE_RANGE(UNSIGNED INT XID,
				       STRUCT CIFS_TCON *TCON,
				       STRUCT CIFSFILEINFO *CFILE,
				       LOFF_T OFF, LOFF_T LEN)
{
	STRUCT FILE_ALLOCATED_RANGE_BUFFER IN_DATA, *OUT_DATA = NULL, *TMP_DATA;
	U32 OUT_DATA_LEN;
	CHAR *BUF = NULL;
	LOFF_T L;
	INT RC;

	IN_DATA.FILE_OFFSET = CPU_TO_LE64(OFF);
	IN_DATA.LENGTH = CPU_TO_LE64(LEN);
	RC = SMB2_IOCTL(XID, TCON, CFILE->FID.PERSISTENT_FID,
			CFILE->FID.VOLATILE_FID,
			FSCTL_QUERY_ALLOCATED_RANGES, TRUE,
			(CHAR *)&IN_DATA, SIZEOF(IN_DATA),
			1024 * SIZEOF(STRUCT FILE_ALLOCATED_RANGE_BUFFER),
			(CHAR **)&OUT_DATA, &OUT_DATA_LEN);
	IF (RC)
		GOTO OUT;

	BUF = KZALLOC(1024 * 1024, GFP_KERNEL);
	IF (BUF == NULL) {
		RC = -ENOMEM;
		GOTO OUT;
	}

	TMP_DATA = OUT_DATA;
	WHILE (LEN) {
		/*
		 * THE REST OF THE REGION IS UNMAPPED SO WRITE IT ALL.
		 */
		IF (OUT_DATA_LEN == 0) {
			RC = SMB3_SIMPLE_FALLOCATE_WRITE_RANGE(XID, TCON,
					       CFILE, OFF, LEN, BUF);
			GOTO OUT;
		}

		IF (OUT_DATA_LEN < SIZEOF(STRUCT FILE_ALLOCATED_RANGE_BUFFER)) {
			RC = -EINVAL;
			GOTO OUT;
		}

		IF (OFF < LE64_TO_CPU(TMP_DATA->FILE_OFFSET)) {
			/*
			 * WE ARE AT A HOLE. WRITE UNTIL THE END OF THE REGION
			 * OR UNTIL THE NEXT ALLOCATED DATA,
			 * WHICHEVER COMES NEXT.
			 */
			L = LE64_TO_CPU(TMP_DATA->FILE_OFFSET) - OFF;
			IF (LEN < L)
				L = LEN;
			RC = SMB3_SIMPLE_FALLOCATE_WRITE_RANGE(XID, TCON,
					       CFILE, OFF, L, BUF);
			IF (RC)
				GOTO OUT;
			OFF = OFF + L;
			LEN = LEN - L;
			IF (LEN == 0)
				GOTO OUT;
		}
		/*
		 * WE ARE AT A SECTION OF ALLOCATED DATA, JUST SKIP FORWARD
		 * UNTIL THE END OF THE DATA OR THE END OF THE REGION
		 * WE ARE SUPPOSED TO FALLOCATE, WHICHEVER COMES FIRST.
		 */
		L = LE64_TO_CPU(TMP_DATA->LENGTH);
		IF (LEN < L)
			L = LEN;
		OFF += L;
		LEN -= L;

		TMP_DATA = &TMP_DATA[1];
		OUT_DATA_LEN -= SIZEOF(STRUCT FILE_ALLOCATED_RANGE_BUFFER);
	}

 OUT:
	KFREE(OUT_DATA);
	KFREE(BUF);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195082_CWE-862.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID RECALC_INTERCEPTS(STRUCT VCPU_SVM *SVM)
{
	STRUCT VMCB_CONTROL_AREA *C, *H, *G;
	UNSIGNED INT I;

	VMCB_MARK_DIRTY(SVM->VMCB, VMCB_INTERCEPTS);

	IF (!IS_GUEST_MODE(&SVM->VCPU))
		RETURN;

	C = &SVM->VMCB->CONTROL;
	H = &SVM->VMCB01.PTR->CONTROL;
	G = &SVM->NESTED.CTL;

	FOR (I = 0; I < MAX_INTERCEPT; I++)
		C->INTERCEPTS[I] = H->INTERCEPTS[I];

	IF (G->INT_CTL & V_INTR_MASKING_MASK) {
		/* WE ONLY WANT THE CR8 INTERCEPT BITS OF L1 */
		VMCB_CLR_INTERCEPT(C, INTERCEPT_CR8_READ);
		VMCB_CLR_INTERCEPT(C, INTERCEPT_CR8_WRITE);

		/*
		 * ONCE RUNNING L2 WITH HF_VINTR_MASK, EFLAGS.IF DOES NOT
		 * AFFECT ANY INTERRUPT WE MAY WANT TO INJECT; THEREFORE,
		 * INTERRUPT WINDOW VMEXITS ARE IRRELEVANT TO L0.
		 */
		VMCB_CLR_INTERCEPT(C, INTERCEPT_VINTR);
	}

	/* WE DON'T WANT TO SEE VMMCALLS FROM A NESTED GUEST */
	VMCB_CLR_INTERCEPT(C, INTERCEPT_VMMCALL);

	FOR (I = 0; I < MAX_INTERCEPT; I++)
		C->INTERCEPTS[I] |= G->INTERCEPTS[I];

	/* IF SMI IS NOT INTERCEPTED, IGNORE GUEST SMI INTERCEPT AS WELL  */
	IF (!INTERCEPT_SMI)
		VMCB_CLR_INTERCEPT(C, INTERCEPT_SMI);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 314749_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CDF_READ_SAT(CONST CDF_INFO_T *INFO, CDF_HEADER_T *H, CDF_SAT_T *SAT)
{
	SIZE_T I, J, K;
	SIZE_T SS = CDF_SEC_SIZE(H);
	CDF_SECID_T *MSA, MID, SEC;
	SIZE_T NSATPERSEC = (SS / SIZEOF(MID)) - 1;

	FOR (I = 0; I < __ARRAYCOUNT(H->H_MASTER_SAT); I++)
		IF (H->H_MASTER_SAT[I] == CDF_SECID_FREE)
			BREAK;

#DEFINE CDF_SEC_LIMIT (UINT32_MAX / (4 * SS))
	IF ((NSATPERSEC > 0 &&
	    H->H_NUM_SECTORS_IN_MASTER_SAT > CDF_SEC_LIMIT / NSATPERSEC) ||
	    I > CDF_SEC_LIMIT) {
		DPRINTF(("NUMBER OF SECTORS IN MASTER SAT TOO BIG %U %"
		    SIZE_T_FORMAT "U\N", H->H_NUM_SECTORS_IN_MASTER_SAT, I));
		ERRNO = EFTYPE;
		RETURN -1;
	}

	SAT->SAT_LEN = H->H_NUM_SECTORS_IN_MASTER_SAT * NSATPERSEC + I;
	DPRINTF(("SAT_LEN = %" SIZE_T_FORMAT "U SS = %" SIZE_T_FORMAT "U\N",
	    SAT->SAT_LEN, SS));
	IF ((SAT->SAT_TAB = CAST(CDF_SECID_T *, CALLOC(SAT->SAT_LEN, SS)))
	    == NULL)
		RETURN -1;

	FOR (I = 0; I < __ARRAYCOUNT(H->H_MASTER_SAT); I++) {
		IF (H->H_MASTER_SAT[I] < 0)
			BREAK;
		IF (CDF_READ_SECTOR(INFO, SAT->SAT_TAB, SS * I, SS, H,
		    H->H_MASTER_SAT[I]) != (SSIZE_T)SS) {
			DPRINTF(("READING SECTOR %D", H->H_MASTER_SAT[I]));
			GOTO OUT1;
		}
	}

	IF ((MSA = CAST(CDF_SECID_T *, CALLOC(1, SS))) == NULL)
		GOTO OUT1;

	MID = H->H_SECID_FIRST_SECTOR_IN_MASTER_SAT;
	FOR (J = 0; J < H->H_NUM_SECTORS_IN_MASTER_SAT; J++) {
		IF (MID < 0)
			GOTO OUT;
		IF (J >= CDF_LOOP_LIMIT) {
			DPRINTF(("READING MASTER SECTOR LOOP LIMIT"));
			ERRNO = EFTYPE;
			GOTO OUT2;
		}
		IF (CDF_READ_SECTOR(INFO, MSA, 0, SS, H, MID) != (SSIZE_T)SS) {
			DPRINTF(("READING MASTER SECTOR %D", MID));
			GOTO OUT2;
		}
		FOR (K = 0; K < NSATPERSEC; K++, I++) {
			SEC = CDF_TOLE4((UINT32_T)MSA[K]);
			IF (SEC < 0)
				GOTO OUT;
			IF (I >= SAT->SAT_LEN) {
			    DPRINTF(("OUT OF BOUNDS READING MSA %" SIZE_T_FORMAT
				"U >= %" SIZE_T_FORMAT "U", I, SAT->SAT_LEN));
			    ERRNO = EFTYPE;
			    GOTO OUT2;
			}
			IF (CDF_READ_SECTOR(INFO, SAT->SAT_TAB, SS * I, SS, H,
			    SEC) != (SSIZE_T)SS) {
				DPRINTF(("READING SECTOR %D",
				    CDF_TOLE4(MSA[K])));
				GOTO OUT2;
			}
		}
		MID = CDF_TOLE4((UINT32_T)MSA[NSATPERSEC]);
	}
OUT:
	SAT->SAT_LEN = I;
	FREE(MSA);
	RETURN 0;
OUT2:
	FREE(MSA);
OUT1:
	FREE(SAT->SAT_TAB);
	RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200323_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SUGGEST_TRIE_WALK(
    SUGINFO_T	*SU,
    LANGP_T	*LP,
    CHAR_U	*FWORD,
    INT		SOUNDFOLD)
{
    CHAR_U	TWORD[MAXWLEN];	    // GOOD WORD COLLECTED SO FAR
    TRYSTATE_T	STACK[MAXWLEN];
    CHAR_U	PREWORD[MAXWLEN * 3]; // WORD FOUND WITH PROPER CASE;
				      // CONCATENATION OF PREFIX COMPOUND
				      // WORDS AND SPLIT WORD.  NUL TERMINATED
				      // WHEN GOING DEEPER BUT NOT WHEN COMING
				      // BACK.
    CHAR_U	COMPFLAGS[MAXWLEN];	// COMPOUND FLAGS, ONE FOR EACH WORD
    TRYSTATE_T	*SP;
    INT		NEWSCORE;
    INT		SCORE;
    CHAR_U	*BYTS, *FBYTS, *PBYTS;
    IDX_T	*IDXS, *FIDXS, *PIDXS;
    INT		DEPTH;
    INT		C, C2, C3;
    INT		N = 0;
    INT		FLAGS;
    GARRAY_T	*GAP;
    IDX_T	ARRIDX;
    INT		LEN;
    CHAR_U	*P;
    FROMTO_T	*FTP;
    INT		FL = 0, TL;
    INT		REPEXTRA = 0;	    // EXTRA BYTES IN FWORD[] FROM REP ITEM
    SLANG_T	*SLANG = LP->LP_SLANG;
    INT		FWORD_ENDS;
    INT		GOODWORD_ENDS;
#IFDEF DEBUG_TRIEWALK
    // STORES THE NAME OF THE CHANGE MADE AT EACH LEVEL.
    CHAR_U	CHANGENAME[MAXWLEN][80];
#ENDIF
    INT		BREAKCHECKCOUNT = 1000;
#IFDEF FEAT_RELTIME
    PROFTIME_T	TIME_LIMIT;
#ENDIF
    INT		COMPOUND_OK;

    // GO THROUGH THE WHOLE CASE-FOLD TREE, TRY CHANGES AT EACH NODE.
    // "TWORD[]" CONTAINS THE WORD COLLECTED FROM NODES IN THE TREE.
    // "FWORD[]" THE WORD WE ARE TRYING TO MATCH WITH (INITIALLY THE BAD
    // WORD).
    DEPTH = 0;
    SP = &STACK[0];
    CLEAR_POINTER(SP);
    SP->TS_CURI = 1;

    IF (SOUNDFOLD)
    {
	// GOING THROUGH THE SOUNDFOLD TREE.
	BYTS = FBYTS = SLANG->SL_SBYTS;
	IDXS = FIDXS = SLANG->SL_SIDXS;
	PBYTS = NULL;
	PIDXS = NULL;
	SP->TS_PREFIXDEPTH = PFD_NOPREFIX;
	SP->TS_STATE = STATE_START;
    }
    ELSE
    {
	// WHEN THERE ARE POSTPONED PREFIXES WE NEED TO USE THESE FIRST.  AT
	// THE END OF THE PREFIX WE CONTINUE IN THE CASE-FOLD TREE.
	FBYTS = SLANG->SL_FBYTS;
	FIDXS = SLANG->SL_FIDXS;
	PBYTS = SLANG->SL_PBYTS;
	PIDXS = SLANG->SL_PIDXS;
	IF (PBYTS != NULL)
	{
	    BYTS = PBYTS;
	    IDXS = PIDXS;
	    SP->TS_PREFIXDEPTH = PFD_PREFIXTREE;
	    SP->TS_STATE = STATE_NOPREFIX;	// TRY WITHOUT PREFIX FIRST
	}
	ELSE
	{
	    BYTS = FBYTS;
	    IDXS = FIDXS;
	    SP->TS_PREFIXDEPTH = PFD_NOPREFIX;
	    SP->TS_STATE = STATE_START;
	}
    }
#IFDEF FEAT_RELTIME
    // THE LOOP MAY TAKE AN INDEFINITE AMOUNT OF TIME. BREAK OUT AFTER SOME
    // TIME.
    IF (SPELL_SUGGEST_TIMEOUT > 0)
	PROFILE_SETLIMIT(SPELL_SUGGEST_TIMEOUT, &TIME_LIMIT);
#ENDIF

    // LOOP TO FIND ALL SUGGESTIONS.  AT EACH ROUND WE EITHER:
    // - FOR THE CURRENT STATE TRY ONE OPERATION, ADVANCE "TS_CURI",
    //   INCREASE "DEPTH".
    // - WHEN A STATE IS DONE GO TO THE NEXT, SET "TS_STATE".
    // - WHEN ALL STATES ARE TRIED DECREASE "DEPTH".
    WHILE (DEPTH >= 0 && !GOT_INT)
    {
	SP = &STACK[DEPTH];
	SWITCH (SP->TS_STATE)
	{
	CASE STATE_START:
	CASE STATE_NOPREFIX:
	    // START OF NODE: DEAL WITH NUL BYTES, WHICH MEANS
	    // TWORD[] MAY END HERE.
	    ARRIDX = SP->TS_ARRIDX;	    // CURRENT NODE IN THE TREE
	    LEN = BYTS[ARRIDX];		    // BYTES IN THIS NODE
	    ARRIDX += SP->TS_CURI;	    // INDEX OF CURRENT BYTE

	    IF (SP->TS_PREFIXDEPTH == PFD_PREFIXTREE)
	    {
		// SKIP OVER THE NUL BYTES, WE USE THEM LATER.
		FOR (N = 0; N < LEN && BYTS[ARRIDX + N] == 0; ++N)
		    ;
		SP->TS_CURI += N;

		// ALWAYS PAST NUL BYTES NOW.
		N = (INT)SP->TS_STATE;
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_ENDNUL;
		SP->TS_SAVE_BADFLAGS = SU->SU_BADFLAGS;

		// AT END OF A PREFIX OR AT START OF PREFIXTREE: CHECK FOR
		// FOLLOWING WORD.
		IF (DEPTH < MAXWLEN - 1
			    && (BYTS[ARRIDX] == 0 || N == (INT)STATE_NOPREFIX))
		{
		    // SET SU->SU_BADFLAGS TO THE CAPS TYPE AT THIS POSITION.
		    // USE THE CAPS TYPE UNTIL HERE FOR THE PREFIX ITSELF.
		    IF (HAS_MBYTE)
			N = NOFOLD_LEN(FWORD, SP->TS_FIDX, SU->SU_BADPTR);
		    ELSE
			N = SP->TS_FIDX;
		    FLAGS = BADWORD_CAPTYPE(SU->SU_BADPTR, SU->SU_BADPTR + N);
		    SU->SU_BADFLAGS = BADWORD_CAPTYPE(SU->SU_BADPTR + N,
					       SU->SU_BADPTR + SU->SU_BADLEN);
#IFDEF DEBUG_TRIEWALK
		    SPRINTF(CHANGENAME[DEPTH], "PREFIX");
#ENDIF
		    GO_DEEPER(STACK, DEPTH, 0);
		    ++DEPTH;
		    SP = &STACK[DEPTH];
		    SP->TS_PREFIXDEPTH = DEPTH - 1;
		    BYTS = FBYTS;
		    IDXS = FIDXS;
		    SP->TS_ARRIDX = 0;

		    // MOVE THE PREFIX TO PREWORD[] WITH THE RIGHT CASE
		    // AND MAKE FIND_KEEPCAP_WORD() WORKS.
		    TWORD[SP->TS_TWORDLEN] = NUL;
		    MAKE_CASE_WORD(TWORD + SP->TS_SPLITOFF,
					  PREWORD + SP->TS_PREWORDLEN, FLAGS);
		    SP->TS_PREWORDLEN = (CHAR_U)STRLEN(PREWORD);
		    SP->TS_SPLITOFF = SP->TS_TWORDLEN;
		}
		BREAK;
	    }

	    IF (SP->TS_CURI > LEN || BYTS[ARRIDX] != 0)
	    {
		// PAST BYTES IN NODE AND/OR PAST NUL BYTES.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_ENDNUL;
		SP->TS_SAVE_BADFLAGS = SU->SU_BADFLAGS;
		BREAK;
	    }

	    // END OF WORD IN TREE.
	    ++SP->TS_CURI;		// EAT ONE NUL BYTE

	    FLAGS = (INT)IDXS[ARRIDX];

	    // SKIP WORDS WITH THE NOSUGGEST FLAG.
	    IF (FLAGS & WF_NOSUGGEST)
		BREAK;

	    FWORD_ENDS = (FWORD[SP->TS_FIDX] == NUL
			   || (SOUNDFOLD
			       ? VIM_ISWHITE(FWORD[SP->TS_FIDX])
			       : !SPELL_ISWORDP(FWORD + SP->TS_FIDX, CURWIN)));
	    TWORD[SP->TS_TWORDLEN] = NUL;

	    IF (SP->TS_PREFIXDEPTH <= PFD_NOTSPECIAL
					&& (SP->TS_FLAGS & TSF_PREFIXOK) == 0
					&& PBYTS != NULL)
	    {
		// THERE WAS A PREFIX BEFORE THE WORD.  CHECK THAT THE PREFIX
		// CAN BE USED WITH THIS WORD.
		// COUNT THE LENGTH OF THE NULS IN THE PREFIX.  IF THERE ARE
		// NONE THIS MUST BE THE FIRST TRY WITHOUT A PREFIX.
		N = STACK[SP->TS_PREFIXDEPTH].TS_ARRIDX;
		LEN = PBYTS[N++];
		FOR (C = 0; C < LEN && PBYTS[N + C] == 0; ++C)
		    ;
		IF (C > 0)
		{
		    C = VALID_WORD_PREFIX(C, N, FLAGS,
				       TWORD + SP->TS_SPLITOFF, SLANG, FALSE);
		    IF (C == 0)
			BREAK;

		    // USE THE WF_RARE FLAG FOR A RARE PREFIX.
		    IF (C & WF_RAREPFX)
			FLAGS |= WF_RARE;

		    // TRICKY: WHEN CHECKING FOR BOTH PREFIX AND COMPOUNDING
		    // WE RUN INTO THE PREFIX FLAG FIRST.
		    // REMEMBER THAT IT'S OK, SO THAT WE ACCEPT THE PREFIX
		    // WHEN ARRIVING AT A COMPOUND FLAG.
		    SP->TS_FLAGS |= TSF_PREFIXOK;
		}
	    }

	    // CHECK NEEDCOMPOUND: CAN'T USE WORD WITHOUT COMPOUNDING.  DO TRY
	    // APPENDING ANOTHER COMPOUND WORD BELOW.
	    IF (SP->TS_COMPLEN == SP->TS_COMPSPLIT && FWORD_ENDS
						     && (FLAGS & WF_NEEDCOMP))
		GOODWORD_ENDS = FALSE;
	    ELSE
		GOODWORD_ENDS = TRUE;

	    P = NULL;
	    COMPOUND_OK = TRUE;
	    IF (SP->TS_COMPLEN > SP->TS_COMPSPLIT)
	    {
		IF (SLANG->SL_NOBREAK)
		{
		    // THERE WAS A WORD BEFORE THIS WORD.  WHEN THERE WAS NO
		    // CHANGE IN THIS WORD (IT WAS CORRECT) ADD THE FIRST WORD
		    // AS A SUGGESTION.  IF THIS WORD WAS CORRECTED TOO, WE
		    // NEED TO CHECK IF A CORRECT WORD FOLLOWS.
		    IF (SP->TS_FIDX - SP->TS_SPLITFIDX
					  == SP->TS_TWORDLEN - SP->TS_SPLITOFF
			    && STRNCMP(FWORD + SP->TS_SPLITFIDX,
					TWORD + SP->TS_SPLITOFF,
					 SP->TS_FIDX - SP->TS_SPLITFIDX) == 0)
		    {
			PREWORD[SP->TS_PREWORDLEN] = NUL;
			NEWSCORE = SCORE_WORDCOUNT_ADJ(SLANG, SP->TS_SCORE,
						 PREWORD + SP->TS_PREWORDLEN,
						 SP->TS_PREWORDLEN > 0);
			// ADD THE SUGGESTION IF THE SCORE ISN'T TOO BAD.
			IF (NEWSCORE <= SU->SU_MAXSCORE)
			    ADD_SUGGESTION(SU, &SU->SU_GA, PREWORD,
				    SP->TS_SPLITFIDX - REPEXTRA,
				    NEWSCORE, 0, FALSE,
				    LP->LP_SALLANG, FALSE);
			BREAK;
		    }
		}
		ELSE
		{
		    // THERE WAS A COMPOUND WORD BEFORE THIS WORD.  IF THIS
		    // WORD DOES NOT SUPPORT COMPOUNDING THEN GIVE UP
		    // (SPLITTING IS TRIED FOR THE WORD WITHOUT COMPOUND
		    // FLAG).
		    IF (((UNSIGNED)FLAGS >> 24) == 0
			    || SP->TS_TWORDLEN - SP->TS_SPLITOFF
						       < SLANG->SL_COMPMINLEN)
			BREAK;
		    // FOR MULTI-BYTE CHARS CHECK CHARACTER LENGTH AGAINST
		    // COMPOUNDMIN.
		    IF (HAS_MBYTE
			    && SLANG->SL_COMPMINLEN > 0
			    && MB_CHARLEN(TWORD + SP->TS_SPLITOFF)
						       < SLANG->SL_COMPMINLEN)
			BREAK;

		    COMPFLAGS[SP->TS_COMPLEN] = ((UNSIGNED)FLAGS >> 24);
		    COMPFLAGS[SP->TS_COMPLEN + 1] = NUL;
		    VIM_STRNCPY(PREWORD + SP->TS_PREWORDLEN,
			    TWORD + SP->TS_SPLITOFF,
			    SP->TS_TWORDLEN - SP->TS_SPLITOFF);

		    // VERIFY CHECKCOMPOUNDPATTERN  RULES.
		    IF (MATCH_CHECKCOMPOUNDPATTERN(PREWORD,  SP->TS_PREWORDLEN,
							  &SLANG->SL_COMPPAT))
			COMPOUND_OK = FALSE;

		    IF (COMPOUND_OK)
		    {
			P = PREWORD;
			WHILE (*SKIPTOWHITE(P) != NUL)
			    P = SKIPWHITE(SKIPTOWHITE(P));
			IF (FWORD_ENDS && !CAN_COMPOUND(SLANG, P,
						COMPFLAGS + SP->TS_COMPSPLIT))
			    // COMPOUND IS NOT ALLOWED.  BUT IT MAY STILL BE
			    // POSSIBLE IF WE ADD ANOTHER (SHORT) WORD.
			    COMPOUND_OK = FALSE;
		    }

		    // GET POINTER TO LAST CHAR OF PREVIOUS WORD.
		    P = PREWORD + SP->TS_PREWORDLEN;
		    MB_PTR_BACK(PREWORD, P);
		}
	    }

	    // FORM THE WORD WITH PROPER CASE IN PREWORD.
	    // IF THERE IS A WORD FROM A PREVIOUS SPLIT, APPEND.
	    // FOR THE SOUNDFOLD TREE DON'T CHANGE THE CASE, SIMPLY APPEND.
	    IF (SOUNDFOLD)
		STRCPY(PREWORD + SP->TS_PREWORDLEN, TWORD + SP->TS_SPLITOFF);
	    ELSE IF (FLAGS & WF_KEEPCAP)
		// MUST FIND THE WORD IN THE KEEP-CASE TREE.
		FIND_KEEPCAP_WORD(SLANG, TWORD + SP->TS_SPLITOFF,
						 PREWORD + SP->TS_PREWORDLEN);
	    ELSE
	    {
		// INCLUDE BADFLAGS: IF THE BADWORD IS ONECAP OR ALLCAP
		// USE THAT FOR THE GOODWORD TOO.  BUT IF THE BADWORD IS
		// ALLCAP AND IT'S ONLY ONE CHAR LONG USE ONECAP.
		C = SU->SU_BADFLAGS;
		IF ((C & WF_ALLCAP)
			&& SU->SU_BADLEN == (*MB_PTR2LEN)(SU->SU_BADPTR))
		    C = WF_ONECAP;
		C |= FLAGS;

		// WHEN APPENDING A COMPOUND WORD AFTER A WORD CHARACTER DON'T
		// USE ONECAP.
		IF (P != NULL && SPELL_ISWORDP_NMW(P, CURWIN))
		    C &= ~WF_ONECAP;
		MAKE_CASE_WORD(TWORD + SP->TS_SPLITOFF,
					      PREWORD + SP->TS_PREWORDLEN, C);
	    }

	    IF (!SOUNDFOLD)
	    {
		// DON'T USE A BANNED WORD.  IT MAY APPEAR AGAIN AS A GOOD
		// WORD, THUS REMEMBER IT.
		IF (FLAGS & WF_BANNED)
		{
		    ADD_BANNED(SU, PREWORD + SP->TS_PREWORDLEN);
		    BREAK;
		}
		IF ((SP->TS_COMPLEN == SP->TS_COMPSPLIT
			    && WAS_BANNED(SU, PREWORD + SP->TS_PREWORDLEN))
						   || WAS_BANNED(SU, PREWORD))
		{
		    IF (SLANG->SL_COMPPROG == NULL)
			BREAK;
		    // THE WORD SO FAR WAS BANNED BUT WE MAY TRY COMPOUNDING
		    GOODWORD_ENDS = FALSE;
		}
	    }

	    NEWSCORE = 0;
	    IF (!SOUNDFOLD)	// SOUNDFOLD WORDS DON'T HAVE FLAGS
	    {
		IF ((FLAGS & WF_REGION)
			    && (((UNSIGNED)FLAGS >> 16) & LP->LP_REGION) == 0)
		    NEWSCORE += SCORE_REGION;
		IF (FLAGS & WF_RARE)
		    NEWSCORE += SCORE_RARE;

		IF (!SPELL_VALID_CASE(SU->SU_BADFLAGS,
				  CAPTYPE(PREWORD + SP->TS_PREWORDLEN, NULL)))
		    NEWSCORE += SCORE_ICASE;
	    }

	    // TODO: HOW ABOUT SPLITTING IN THE SOUNDFOLD TREE?
	    IF (FWORD_ENDS
		    && GOODWORD_ENDS
		    && SP->TS_FIDX >= SP->TS_FIDXTRY
		    && COMPOUND_OK)
	    {
		// THE BADWORD ALSO ENDS: ADD SUGGESTIONS.
#IFDEF DEBUG_TRIEWALK
		IF (SOUNDFOLD && STRCMP(PREWORD, "SMWRD") == 0)
		{
		    INT	    J;

		    // PRINT THE STACK OF CHANGES THAT BROUGHT US HERE
		    SMSG("------ %S -------", FWORD);
		    FOR (J = 0; J < DEPTH; ++J)
			SMSG("%S", CHANGENAME[J]);
		}
#ENDIF
		IF (SOUNDFOLD)
		{
		    // FOR SOUNDFOLDED WORDS WE NEED TO FIND THE ORIGINAL
		    // WORDS, THE EDIT DISTANCE AND THEN ADD THEM.
		    ADD_SOUND_SUGGEST(SU, PREWORD, SP->TS_SCORE, LP);
		}
		ELSE IF (SP->TS_FIDX > 0)
		{
		    // GIVE A PENALTY WHEN CHANGING NON-WORD CHAR TO WORD
		    // CHAR, E.G., "THES," -> "THESE".
		    P = FWORD + SP->TS_FIDX;
		    MB_PTR_BACK(FWORD, P);
		    IF (!SPELL_ISWORDP(P, CURWIN) && *PREWORD != NUL)
		    {
			P = PREWORD + STRLEN(PREWORD);
			MB_PTR_BACK(PREWORD, P);
			IF (SPELL_ISWORDP(P, CURWIN))
			    NEWSCORE += SCORE_NONWORD;
		    }

		    // GIVE A BONUS TO WORDS SEEN BEFORE.
		    SCORE = SCORE_WORDCOUNT_ADJ(SLANG,
						SP->TS_SCORE + NEWSCORE,
						PREWORD + SP->TS_PREWORDLEN,
						SP->TS_PREWORDLEN > 0);

		    // ADD THE SUGGESTION IF THE SCORE ISN'T TOO BAD.
		    IF (SCORE <= SU->SU_MAXSCORE)
		    {
			ADD_SUGGESTION(SU, &SU->SU_GA, PREWORD,
				    SP->TS_FIDX - REPEXTRA,
				    SCORE, 0, FALSE, LP->LP_SALLANG, FALSE);

			IF (SU->SU_BADFLAGS & WF_MIXCAP)
			{
			    // WE REALLY DON'T KNOW IF THE WORD SHOULD BE
			    // UPPER OR LOWER CASE, ADD BOTH.
			    C = CAPTYPE(PREWORD, NULL);
			    IF (C == 0 || C == WF_ALLCAP)
			    {
				MAKE_CASE_WORD(TWORD + SP->TS_SPLITOFF,
					      PREWORD + SP->TS_PREWORDLEN,
						      C == 0 ? WF_ALLCAP : 0);

				ADD_SUGGESTION(SU, &SU->SU_GA, PREWORD,
					SP->TS_FIDX - REPEXTRA,
					SCORE + SCORE_ICASE, 0, FALSE,
					LP->LP_SALLANG, FALSE);
			    }
			}
		    }
		}
	    }

	    // TRY WORD SPLIT AND/OR COMPOUNDING.
	    IF ((SP->TS_FIDX >= SP->TS_FIDXTRY || FWORD_ENDS)
		    // DON'T SPLIT HALFWAY A CHARACTER.
		    && (!HAS_MBYTE || SP->TS_TCHARLEN == 0))
	    {
		INT	TRY_COMPOUND;
		INT	TRY_SPLIT;

		// IF PAST THE END OF THE BAD WORD DON'T TRY A SPLIT.
		// OTHERWISE TRY CHANGING THE NEXT WORD.  E.G., FIND
		// SUGGESTIONS FOR "THE THE" WHERE THE SECOND "THE" IS
		// DIFFERENT.  IT'S DONE LIKE A SPLIT.
		// TODO: WORD SPLIT FOR SOUNDFOLD WORDS
		TRY_SPLIT = (SP->TS_FIDX - REPEXTRA < SU->SU_BADLEN)
								&& !SOUNDFOLD;

		// GET HERE IN SEVERAL SITUATIONS:
		// 1. THE WORD IN THE TREE ENDS:
		//    IF THE WORD ALLOWS COMPOUNDING TRY THAT.  OTHERWISE TRY
		//    A SPLIT BY INSERTING A SPACE.  FOR BOTH CHECK THAT A
		//    VALID WORDS STARTS AT FWORD[SP->TS_FIDX].
		//    FOR NOBREAK DO LIKE COMPOUNDING TO BE ABLE TO CHECK IF
		//    THE NEXT WORD IS VALID.
		// 2. THE BADWORD DOES END, BUT IT WAS DUE TO A CHANGE (E.G.,
		//    A SWAP).  NO NEED TO SPLIT, BUT DO CHECK THAT THE
		//    FOLLOWING WORD IS VALID.
		// 3. THE BADWORD AND THE WORD IN THE TREE END.  IT MAY STILL
		//    BE POSSIBLE TO COMPOUND ANOTHER (SHORT) WORD.
		TRY_COMPOUND = FALSE;
		IF (!SOUNDFOLD
			&& !SLANG->SL_NOCOMPOUNDSUGS
			&& SLANG->SL_COMPPROG != NULL
			&& ((UNSIGNED)FLAGS >> 24) != 0
			&& SP->TS_TWORDLEN - SP->TS_SPLITOFF
						       >= SLANG->SL_COMPMINLEN
			&& (!HAS_MBYTE
			    || SLANG->SL_COMPMINLEN == 0
			    || MB_CHARLEN(TWORD + SP->TS_SPLITOFF)
						      >= SLANG->SL_COMPMINLEN)
			&& (SLANG->SL_COMPSYLMAX < MAXWLEN
			    || SP->TS_COMPLEN + 1 - SP->TS_COMPSPLIT
							  < SLANG->SL_COMPMAX)
			&& (CAN_BE_COMPOUND(SP, SLANG,
					 COMPFLAGS, ((UNSIGNED)FLAGS >> 24))))

		{
		    TRY_COMPOUND = TRUE;
		    COMPFLAGS[SP->TS_COMPLEN] = ((UNSIGNED)FLAGS >> 24);
		    COMPFLAGS[SP->TS_COMPLEN + 1] = NUL;
		}

		// FOR NOBREAK WE NEVER TRY SPLITTING, IT WON'T MAKE ANY WORD
		// VALID.
		IF (SLANG->SL_NOBREAK && !SLANG->SL_NOCOMPOUNDSUGS)
		    TRY_COMPOUND = TRUE;

		// IF WE COULD ADD A COMPOUND WORD, AND IT'S ALSO POSSIBLE TO
		// SPLIT AT THIS POINT, DO THE SPLIT FIRST AND SET
		// TSF_DIDSPLIT TO AVOID DOING IT AGAIN.
		ELSE IF (!FWORD_ENDS
			&& TRY_COMPOUND
			&& (SP->TS_FLAGS & TSF_DIDSPLIT) == 0)
		{
		    TRY_COMPOUND = FALSE;
		    SP->TS_FLAGS |= TSF_DIDSPLIT;
		    --SP->TS_CURI;	    // DO THE SAME NUL AGAIN
		    COMPFLAGS[SP->TS_COMPLEN] = NUL;
		}
		ELSE
		    SP->TS_FLAGS &= ~TSF_DIDSPLIT;

		IF (TRY_SPLIT || TRY_COMPOUND)
		{
		    IF (!TRY_COMPOUND && (!FWORD_ENDS || !GOODWORD_ENDS))
		    {
			// IF WE'RE GOING TO SPLIT NEED TO CHECK THAT THE
			// WORDS SO FAR ARE VALID FOR COMPOUNDING.  IF THERE
			// IS ONLY ONE WORD IT MUST NOT HAVE THE NEEDCOMPOUND
			// FLAG.
			IF (SP->TS_COMPLEN == SP->TS_COMPSPLIT
						     && (FLAGS & WF_NEEDCOMP))
			    BREAK;
			P = PREWORD;
			WHILE (*SKIPTOWHITE(P) != NUL)
			    P = SKIPWHITE(SKIPTOWHITE(P));
			IF (SP->TS_COMPLEN > SP->TS_COMPSPLIT
				&& !CAN_COMPOUND(SLANG, P,
						COMPFLAGS + SP->TS_COMPSPLIT))
			    BREAK;

			IF (SLANG->SL_NOSPLITSUGS)
			    NEWSCORE += SCORE_SPLIT_NO;
			ELSE
			    NEWSCORE += SCORE_SPLIT;

			// GIVE A BONUS TO WORDS SEEN BEFORE.
			NEWSCORE = SCORE_WORDCOUNT_ADJ(SLANG, NEWSCORE,
					   PREWORD + SP->TS_PREWORDLEN, TRUE);
		    }

		    IF (TRY_DEEPER(SU, STACK, DEPTH, NEWSCORE))
		    {
			GO_DEEPER(STACK, DEPTH, NEWSCORE);
#IFDEF DEBUG_TRIEWALK
			IF (!TRY_COMPOUND && !FWORD_ENDS)
			    SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: SPLIT",
				 SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX);
			ELSE
			    SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: COMPOUND",
				 SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX);
#ENDIF
			// SAVE THINGS TO BE RESTORED AT STATE_SPLITUNDO.
			SP->TS_SAVE_BADFLAGS = SU->SU_BADFLAGS;
			PROF_STORE(SP->TS_STATE)
			SP->TS_STATE = STATE_SPLITUNDO;

			++DEPTH;
			SP = &STACK[DEPTH];

			// APPEND A SPACE TO PREWORD WHEN SPLITTING.
			IF (!TRY_COMPOUND && !FWORD_ENDS)
			    STRCAT(PREWORD, " ");
			SP->TS_PREWORDLEN = (CHAR_U)STRLEN(PREWORD);
			SP->TS_SPLITOFF = SP->TS_TWORDLEN;
			SP->TS_SPLITFIDX = SP->TS_FIDX;

			// IF THE BADWORD HAS A NON-WORD CHARACTER AT THIS
			// POSITION SKIP IT.  THAT MEANS REPLACING THE
			// NON-WORD CHARACTER WITH A SPACE.  ALWAYS SKIP A
			// CHARACTER WHEN THE WORD ENDS.  BUT ONLY WHEN THE
			// GOOD WORD CAN END.
			IF (((!TRY_COMPOUND && !SPELL_ISWORDP_NMW(FWORD
							       + SP->TS_FIDX,
							       CURWIN))
				    || FWORD_ENDS)
				&& FWORD[SP->TS_FIDX] != NUL
				&& GOODWORD_ENDS)
			{
			    INT	    L;

			    L = MB_PTR2LEN(FWORD + SP->TS_FIDX);
			    IF (FWORD_ENDS)
			    {
				// COPY THE SKIPPED CHARACTER TO PREWORD.
				MCH_MEMMOVE(PREWORD + SP->TS_PREWORDLEN,
						      FWORD + SP->TS_FIDX, L);
				SP->TS_PREWORDLEN += L;
				PREWORD[SP->TS_PREWORDLEN] = NUL;
			    }
			    ELSE
				SP->TS_SCORE -= SCORE_SPLIT - SCORE_SUBST;
			    SP->TS_FIDX += L;
			}

			// WHEN COMPOUNDING INCLUDE COMPOUND FLAG IN
			// COMPFLAGS[] (ALREADY SET ABOVE).  WHEN SPLITTING WE
			// MAY START COMPOUNDING OVER AGAIN.
			IF (TRY_COMPOUND)
			    ++SP->TS_COMPLEN;
			ELSE
			    SP->TS_COMPSPLIT = SP->TS_COMPLEN;
			SP->TS_PREFIXDEPTH = PFD_NOPREFIX;

			// SET SU->SU_BADFLAGS TO THE CAPS TYPE AT THIS
			// POSITION
			IF (HAS_MBYTE)
			    N = NOFOLD_LEN(FWORD, SP->TS_FIDX, SU->SU_BADPTR);
			ELSE
			    N = SP->TS_FIDX;
			SU->SU_BADFLAGS = BADWORD_CAPTYPE(SU->SU_BADPTR + N,
					       SU->SU_BADPTR + SU->SU_BADLEN);

			// RESTART AT TOP OF THE TREE.
			SP->TS_ARRIDX = 0;

			// IF THERE ARE POSTPONED PREFIXES, TRY THESE TOO.
			IF (PBYTS != NULL)
			{
			    BYTS = PBYTS;
			    IDXS = PIDXS;
			    SP->TS_PREFIXDEPTH = PFD_PREFIXTREE;
			    PROF_STORE(SP->TS_STATE)
			    SP->TS_STATE = STATE_NOPREFIX;
			}
		    }
		}
	    }
	    BREAK;

	CASE STATE_SPLITUNDO:
	    // UNDO THE CHANGES DONE FOR WORD SPLIT OR COMPOUND WORD.
	    SU->SU_BADFLAGS = SP->TS_SAVE_BADFLAGS;

	    // CONTINUE LOOKING FOR NUL BYTES.
	    PROF_STORE(SP->TS_STATE)
	    SP->TS_STATE = STATE_START;

	    // IN CASE WE WENT INTO THE PREFIX TREE.
	    BYTS = FBYTS;
	    IDXS = FIDXS;
	    BREAK;

	CASE STATE_ENDNUL:
	    // PAST THE NUL BYTES IN THE NODE.
	    SU->SU_BADFLAGS = SP->TS_SAVE_BADFLAGS;
	    IF (FWORD[SP->TS_FIDX] == NUL && SP->TS_TCHARLEN == 0)
	    {
		// THE BADWORD ENDS, CAN'T USE STATE_PLAIN.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_DEL;
		BREAK;
	    }
	    PROF_STORE(SP->TS_STATE)
	    SP->TS_STATE = STATE_PLAIN;
	    // FALLTHROUGH

	CASE STATE_PLAIN:
	    // GO OVER ALL POSSIBLE BYTES AT THIS NODE, ADD EACH TO TWORD[]
	    // AND USE CHILD NODE.  "TS_CURI" IS THE INDEX.
	    ARRIDX = SP->TS_ARRIDX;
	    IF (SP->TS_CURI > BYTS[ARRIDX])
	    {
		// DONE ALL BYTES AT THIS NODE, DO NEXT STATE.  WHEN STILL AT
		// ALREADY CHANGED BYTES SKIP THE OTHER TRICKS.
		PROF_STORE(SP->TS_STATE)
		IF (SP->TS_FIDX >= SP->TS_FIDXTRY)
		    SP->TS_STATE = STATE_DEL;
		ELSE
		    SP->TS_STATE = STATE_FINAL;
	    }
	    ELSE
	    {
		ARRIDX += SP->TS_CURI++;
		C = BYTS[ARRIDX];

		// NORMAL BYTE, GO ONE LEVEL DEEPER.  IF IT'S NOT EQUAL TO THE
		// BYTE IN THE BAD WORD ADJUST THE SCORE.  BUT DON'T EVEN TRY
		// WHEN THE BYTE WAS ALREADY CHANGED.  AND DON'T TRY WHEN WE
		// JUST DELETED THIS BYTE, ACCEPTING IT IS ALWAYS CHEAPER THAN
		// DELETE + SUBSTITUTE.
		IF (C == FWORD[SP->TS_FIDX]
			|| (SP->TS_TCHARLEN > 0 && SP->TS_ISDIFF != DIFF_NONE))
		    NEWSCORE = 0;
		ELSE
		    NEWSCORE = SCORE_SUBST;
		IF ((NEWSCORE == 0
			    || (SP->TS_FIDX >= SP->TS_FIDXTRY
				&& ((SP->TS_FLAGS & TSF_DIDDEL) == 0
				    || C != FWORD[SP->TS_DELIDX])))
			&& TRY_DEEPER(SU, STACK, DEPTH, NEWSCORE))
		{
		    GO_DEEPER(STACK, DEPTH, NEWSCORE);
#IFDEF DEBUG_TRIEWALK
		    IF (NEWSCORE > 0)
			SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: SUBST %C TO %C",
				SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
				FWORD[SP->TS_FIDX], C);
		    ELSE
			SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: ACCEPT %C",
				SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
				FWORD[SP->TS_FIDX]);
#ENDIF
		    ++DEPTH;
		    SP = &STACK[DEPTH];
		    IF (FWORD[SP->TS_FIDX] != NUL)
			++SP->TS_FIDX;
		    TWORD[SP->TS_TWORDLEN++] = C;
		    SP->TS_ARRIDX = IDXS[ARRIDX];
		    IF (NEWSCORE == SCORE_SUBST)
			SP->TS_ISDIFF = DIFF_YES;
		    IF (HAS_MBYTE)
		    {
			// MULTI-BYTE CHARACTERS ARE A BIT COMPLICATED TO
			// HANDLE: THEY DIFFER WHEN ANY OF THE BYTES DIFFER
			// AND THEN THEIR LENGTH MAY ALSO DIFFER.
			IF (SP->TS_TCHARLEN == 0)
			{
			    // FIRST BYTE.
			    SP->TS_TCHARIDX = 0;
			    SP->TS_TCHARLEN = MB_BYTE2LEN(C);
			    SP->TS_FCHARSTART = SP->TS_FIDX - 1;
			    SP->TS_ISDIFF = (NEWSCORE != 0)
						       ? DIFF_YES : DIFF_NONE;
			}
			ELSE IF (SP->TS_ISDIFF == DIFF_INSERT)
			    // WHEN INSERTING TRAIL BYTES DON'T ADVANCE IN THE
			    // BAD WORD.
			    --SP->TS_FIDX;
			IF (++SP->TS_TCHARIDX == SP->TS_TCHARLEN)
			{
			    // LAST BYTE OF CHARACTER.
			    IF (SP->TS_ISDIFF == DIFF_YES)
			    {
				// CORRECT TS_FIDX FOR THE BYTE LENGTH OF THE
				// CHARACTER (WE DIDN'T CHECK THAT BEFORE).
				SP->TS_FIDX = SP->TS_FCHARSTART
					    + MB_PTR2LEN(
						    FWORD + SP->TS_FCHARSTART);
				// FOR CHANGING A COMPOSING CHARACTER ADJUST
				// THE SCORE FROM SCORE_SUBST TO
				// SCORE_SUBCOMP.
				IF (ENC_UTF8
					&& UTF_ISCOMPOSING(
					    UTF_PTR2CHAR(TWORD
						+ SP->TS_TWORDLEN
							   - SP->TS_TCHARLEN))
					&& UTF_ISCOMPOSING(
					    UTF_PTR2CHAR(FWORD
							+ SP->TS_FCHARSTART)))
				    SP->TS_SCORE -=
						  SCORE_SUBST - SCORE_SUBCOMP;

				// FOR A SIMILAR CHARACTER ADJUST SCORE FROM
				// SCORE_SUBST TO SCORE_SIMILAR.
				ELSE IF (!SOUNDFOLD
					&& SLANG->SL_HAS_MAP
					&& SIMILAR_CHARS(SLANG,
					    MB_PTR2CHAR(TWORD
						+ SP->TS_TWORDLEN
							   - SP->TS_TCHARLEN),
					    MB_PTR2CHAR(FWORD
							+ SP->TS_FCHARSTART)))
				    SP->TS_SCORE -=
						  SCORE_SUBST - SCORE_SIMILAR;
			    }
			    ELSE IF (SP->TS_ISDIFF == DIFF_INSERT
					 && SP->TS_TWORDLEN > SP->TS_TCHARLEN)
			    {
				P = TWORD + SP->TS_TWORDLEN - SP->TS_TCHARLEN;
				C = MB_PTR2CHAR(P);
				IF (ENC_UTF8 && UTF_ISCOMPOSING(C))
				{
				    // INSERTING A COMPOSING CHAR DOESN'T
				    // COUNT THAT MUCH.
				    SP->TS_SCORE -= SCORE_INS - SCORE_INSCOMP;
				}
				ELSE
				{
				    // IF THE PREVIOUS CHARACTER WAS THE SAME,
				    // THUS DOUBLING A CHARACTER, GIVE A BONUS
				    // TO THE SCORE.  ALSO FOR THE SOUNDFOLD
				    // TREE (MIGHT SEEM ILLOGICAL BUT DOES
				    // GIVE BETTER SCORES).
				    MB_PTR_BACK(TWORD, P);
				    IF (C == MB_PTR2CHAR(P))
					SP->TS_SCORE -= SCORE_INS
							       - SCORE_INSDUP;
				}
			    }

			    // STARTING A NEW CHAR, RESET THE LENGTH.
			    SP->TS_TCHARLEN = 0;
			}
		    }
		    ELSE
		    {
			// IF WE FOUND A SIMILAR CHAR ADJUST THE SCORE.
			// WE DO THIS AFTER CALLING GO_DEEPER() BECAUSE
			// IT'S SLOW.
			IF (NEWSCORE != 0
				&& !SOUNDFOLD
				&& SLANG->SL_HAS_MAP
				&& SIMILAR_CHARS(SLANG,
						   C, FWORD[SP->TS_FIDX - 1]))
			    SP->TS_SCORE -= SCORE_SUBST - SCORE_SIMILAR;
		    }
		}
	    }
	    BREAK;

	CASE STATE_DEL:
	    // WHEN PAST THE FIRST BYTE OF A MULTI-BYTE CHAR DON'T TRY
	    // DELETE/INSERT/SWAP A CHARACTER.
	    IF (HAS_MBYTE && SP->TS_TCHARLEN > 0)
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_FINAL;
		BREAK;
	    }
	    // TRY SKIPPING ONE CHARACTER IN THE BAD WORD (DELETE IT).
	    PROF_STORE(SP->TS_STATE)
	    SP->TS_STATE = STATE_INS_PREP;
	    SP->TS_CURI = 1;
	    IF (SOUNDFOLD && SP->TS_FIDX == 0 && FWORD[SP->TS_FIDX] == '*')
		// DELETING A VOWEL AT THE START OF A WORD COUNTS LESS, SEE
		// SOUNDALIKE_SCORE().
		NEWSCORE = 2 * SCORE_DEL / 3;
	    ELSE
		NEWSCORE = SCORE_DEL;
	    IF (FWORD[SP->TS_FIDX] != NUL
				    && TRY_DEEPER(SU, STACK, DEPTH, NEWSCORE))
	    {
		GO_DEEPER(STACK, DEPTH, NEWSCORE);
#IFDEF DEBUG_TRIEWALK
		SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: DELETE %C",
			SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			FWORD[SP->TS_FIDX]);
#ENDIF
		++DEPTH;

		// REMEMBER WHAT CHARACTER WE DELETED, SO THAT WE CAN AVOID
		// INSERTING IT AGAIN.
		STACK[DEPTH].TS_FLAGS |= TSF_DIDDEL;
		STACK[DEPTH].TS_DELIDX = SP->TS_FIDX;

		// ADVANCE OVER THE CHARACTER IN FWORD[].  GIVE A BONUS TO THE
		// SCORE IF THE SAME CHARACTER IS FOLLOWING "NN" -> "N".  IT'S
		// A BIT ILLOGICAL FOR SOUNDFOLD TREE BUT IT DOES GIVE BETTER
		// RESULTS.
		IF (HAS_MBYTE)
		{
		    C = MB_PTR2CHAR(FWORD + SP->TS_FIDX);
		    STACK[DEPTH].TS_FIDX += MB_PTR2LEN(FWORD + SP->TS_FIDX);
		    IF (ENC_UTF8 && UTF_ISCOMPOSING(C))
			STACK[DEPTH].TS_SCORE -= SCORE_DEL - SCORE_DELCOMP;
		    ELSE IF (C == MB_PTR2CHAR(FWORD + STACK[DEPTH].TS_FIDX))
			STACK[DEPTH].TS_SCORE -= SCORE_DEL - SCORE_DELDUP;
		}
		ELSE
		{
		    ++STACK[DEPTH].TS_FIDX;
		    IF (FWORD[SP->TS_FIDX] == FWORD[SP->TS_FIDX + 1])
			STACK[DEPTH].TS_SCORE -= SCORE_DEL - SCORE_DELDUP;
		}
		BREAK;
	    }
	    // FALLTHROUGH

	CASE STATE_INS_PREP:
	    IF (SP->TS_FLAGS & TSF_DIDDEL)
	    {
		// IF WE JUST DELETED A BYTE THEN INSERTING WON'T MAKE SENSE,
		// A SUBSTITUTE IS ALWAYS CHEAPER.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_SWAP;
		BREAK;
	    }

	    // SKIP OVER NUL BYTES
	    N = SP->TS_ARRIDX;
	    FOR (;;)
	    {
		IF (SP->TS_CURI > BYTS[N])
		{
		    // ONLY NUL BYTES AT THIS NODE, GO TO NEXT STATE.
		    PROF_STORE(SP->TS_STATE)
		    SP->TS_STATE = STATE_SWAP;
		    BREAK;
		}
		IF (BYTS[N + SP->TS_CURI] != NUL)
		{
		    // FOUND A BYTE TO INSERT.
		    PROF_STORE(SP->TS_STATE)
		    SP->TS_STATE = STATE_INS;
		    BREAK;
		}
		++SP->TS_CURI;
	    }
	    BREAK;

	    // FALLTHROUGH

	CASE STATE_INS:
	    // INSERT ONE BYTE.  REPEAT THIS FOR EACH POSSIBLE BYTE AT THIS
	    // NODE.
	    N = SP->TS_ARRIDX;
	    IF (SP->TS_CURI > BYTS[N])
	    {
		// DONE ALL BYTES AT THIS NODE, GO TO NEXT STATE.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_SWAP;
		BREAK;
	    }

	    // DO ONE MORE BYTE AT THIS NODE, BUT:
	    // - SKIP NUL BYTES.
	    // - SKIP THE BYTE IF IT'S EQUAL TO THE BYTE IN THE WORD,
	    //   ACCEPTING THAT BYTE IS ALWAYS BETTER.
	    N += SP->TS_CURI++;
	    C = BYTS[N];
	    IF (SOUNDFOLD && SP->TS_TWORDLEN == 0 && C == '*')
		// INSERTING A VOWEL AT THE START OF A WORD COUNTS LESS,
		// SEE SOUNDALIKE_SCORE().
		NEWSCORE = 2 * SCORE_INS / 3;
	    ELSE
		NEWSCORE = SCORE_INS;
	    IF (C != FWORD[SP->TS_FIDX]
				    && TRY_DEEPER(SU, STACK, DEPTH, NEWSCORE))
	    {
		GO_DEEPER(STACK, DEPTH, NEWSCORE);
#IFDEF DEBUG_TRIEWALK
		SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: INSERT %C",
			SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			C);
#ENDIF
		++DEPTH;
		SP = &STACK[DEPTH];
		TWORD[SP->TS_TWORDLEN++] = C;
		SP->TS_ARRIDX = IDXS[N];
		IF (HAS_MBYTE)
		{
		    FL = MB_BYTE2LEN(C);
		    IF (FL > 1)
		    {
			// THERE ARE FOLLOWING BYTES FOR THE SAME CHARACTER.
			// WE MUST FIND ALL BYTES BEFORE TRYING
			// DELETE/INSERT/SWAP/ETC.
			SP->TS_TCHARLEN = FL;
			SP->TS_TCHARIDX = 1;
			SP->TS_ISDIFF = DIFF_INSERT;
		    }
		}
		ELSE
		    FL = 1;
		IF (FL == 1)
		{
		    // IF THE PREVIOUS CHARACTER WAS THE SAME, THUS DOUBLING A
		    // CHARACTER, GIVE A BONUS TO THE SCORE.  ALSO FOR
		    // SOUNDFOLD WORDS (ILLOGICAL BUT DOES GIVE A BETTER
		    // SCORE).
		    IF (SP->TS_TWORDLEN >= 2
					   && TWORD[SP->TS_TWORDLEN - 2] == C)
			SP->TS_SCORE -= SCORE_INS - SCORE_INSDUP;
		}
	    }
	    BREAK;

	CASE STATE_SWAP:
	    // SWAP TWO BYTES IN THE BAD WORD: "12" -> "21".
	    // WE CHANGE "FWORD" HERE, IT'S CHANGED BACK AFTERWARDS AT
	    // STATE_UNSWAP.
	    P = FWORD + SP->TS_FIDX;
	    C = *P;
	    IF (C == NUL)
	    {
		// END OF WORD, CAN'T SWAP OR REPLACE.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_FINAL;
		BREAK;
	    }

	    // DON'T SWAP IF THE FIRST CHARACTER IS NOT A WORD CHARACTER.
	    // SWAP3 ETC. ALSO DON'T MAKE SENSE THEN.
	    IF (!SOUNDFOLD && !SPELL_ISWORDP(P, CURWIN))
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
		BREAK;
	    }

	    IF (HAS_MBYTE)
	    {
		N = MB_CPTR2LEN(P);
		C = MB_PTR2CHAR(P);
		IF (P[N] == NUL)
		    C2 = NUL;
		ELSE IF (!SOUNDFOLD && !SPELL_ISWORDP(P + N, CURWIN))
		    C2 = C; // DON'T SWAP NON-WORD CHAR
		ELSE
		    C2 = MB_PTR2CHAR(P + N);
	    }
	    ELSE
	    {
		IF (P[1] == NUL)
		    C2 = NUL;
		ELSE IF (!SOUNDFOLD && !SPELL_ISWORDP(P + 1, CURWIN))
		    C2 = C; // DON'T SWAP NON-WORD CHAR
		ELSE
		    C2 = P[1];
	    }

	    // WHEN THE SECOND CHARACTER IS NUL WE CAN'T SWAP.
	    IF (C2 == NUL)
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
		BREAK;
	    }

	    // WHEN CHARACTERS ARE IDENTICAL, SWAP WON'T DO ANYTHING.
	    // ALSO GET HERE IF THE SECOND CHAR IS NOT A WORD CHARACTER.
	    IF (C == C2)
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_SWAP3;
		BREAK;
	    }
	    IF (C2 != NUL && TRY_DEEPER(SU, STACK, DEPTH, SCORE_SWAP))
	    {
		GO_DEEPER(STACK, DEPTH, SCORE_SWAP);
#IFDEF DEBUG_TRIEWALK
		SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: SWAP %C AND %C",
			SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			C, C2);
#ENDIF
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_UNSWAP;
		++DEPTH;
		IF (HAS_MBYTE)
		{
		    FL = MB_CHAR2LEN(C2);
		    MCH_MEMMOVE(P, P + N, FL);
		    MB_CHAR2BYTES(C, P + FL);
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + N + FL;
		}
		ELSE
		{
		    P[0] = C2;
		    P[1] = C;
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + 2;
		}
	    }
	    ELSE
	    {
		// IF THIS SWAP DOESN'T WORK THEN SWAP3 WON'T EITHER.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
	    }
	    BREAK;

	CASE STATE_UNSWAP:
	    // UNDO THE STATE_SWAP SWAP: "21" -> "12".
	    P = FWORD + SP->TS_FIDX;
	    IF (HAS_MBYTE)
	    {
		N = MB_PTR2LEN(P);
		C = MB_PTR2CHAR(P + N);
		MCH_MEMMOVE(P + MB_PTR2LEN(P + N), P, N);
		MB_CHAR2BYTES(C, P);
	    }
	    ELSE
	    {
		C = *P;
		*P = P[1];
		P[1] = C;
	    }
	    // FALLTHROUGH

	CASE STATE_SWAP3:
	    // SWAP TWO BYTES, SKIPPING ONE: "123" -> "321".  WE CHANGE
	    // "FWORD" HERE, IT'S CHANGED BACK AFTERWARDS AT STATE_UNSWAP3.
	    P = FWORD + SP->TS_FIDX;
	    IF (HAS_MBYTE)
	    {
		N = MB_CPTR2LEN(P);
		C = MB_PTR2CHAR(P);
		FL = MB_CPTR2LEN(P + N);
		C2 = MB_PTR2CHAR(P + N);
		IF (!SOUNDFOLD && !SPELL_ISWORDP(P + N + FL, CURWIN))
		    C3 = C;	// DON'T SWAP NON-WORD CHAR
		ELSE
		    C3 = MB_PTR2CHAR(P + N + FL);
	    }
	    ELSE
	    {
		C = *P;
		C2 = P[1];
		IF (!SOUNDFOLD && !SPELL_ISWORDP(P + 2, CURWIN))
		    C3 = C;	// DON'T SWAP NON-WORD CHAR
		ELSE
		    C3 = P[2];
	    }

	    // WHEN CHARACTERS ARE IDENTICAL: "121" THEN SWAP3 RESULT IS
	    // IDENTICAL, ROT3L RESULT IS SAME AS SWAP: "211", ROT3L RESULT IS
	    // SAME AS SWAP ON NEXT CHAR: "112".  THUS SKIP ALL SWAPPING.
	    // ALSO SKIP WHEN C3 IS NUL.
	    // ALSO GET HERE WHEN THE THIRD CHARACTER IS NOT A WORD CHARACTER.
	    // SECOND CHARACTER MAY ANY CHAR: "A.B" -> "B.A"
	    IF (C == C3 || C3 == NUL)
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
		BREAK;
	    }
	    IF (TRY_DEEPER(SU, STACK, DEPTH, SCORE_SWAP3))
	    {
		GO_DEEPER(STACK, DEPTH, SCORE_SWAP3);
#IFDEF DEBUG_TRIEWALK
		SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: SWAP3 %C AND %C",
			SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			C, C3);
#ENDIF
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_UNSWAP3;
		++DEPTH;
		IF (HAS_MBYTE)
		{
		    TL = MB_CHAR2LEN(C3);
		    MCH_MEMMOVE(P, P + N + FL, TL);
		    MB_CHAR2BYTES(C2, P + TL);
		    MB_CHAR2BYTES(C, P + FL + TL);
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + N + FL + TL;
		}
		ELSE
		{
		    P[0] = P[2];
		    P[2] = C;
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + 3;
		}
	    }
	    ELSE
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
	    }
	    BREAK;

	CASE STATE_UNSWAP3:
	    // UNDO STATE_SWAP3: "321" -> "123"
	    P = FWORD + SP->TS_FIDX;
	    IF (HAS_MBYTE)
	    {
		N = MB_PTR2LEN(P);
		C2 = MB_PTR2CHAR(P + N);
		FL = MB_PTR2LEN(P + N);
		C = MB_PTR2CHAR(P + N + FL);
		TL = MB_PTR2LEN(P + N + FL);
		MCH_MEMMOVE(P + FL + TL, P, N);
		MB_CHAR2BYTES(C, P);
		MB_CHAR2BYTES(C2, P + TL);
		P = P + TL;
	    }
	    ELSE
	    {
		C = *P;
		*P = P[2];
		P[2] = C;
		++P;
	    }

	    IF (!SOUNDFOLD && !SPELL_ISWORDP(P, CURWIN))
	    {
		// MIDDLE CHAR IS NOT A WORD CHAR, SKIP THE ROTATE.  FIRST AND
		// THIRD CHAR WERE ALREADY CHECKED AT SWAP AND SWAP3.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
		BREAK;
	    }

	    // ROTATE THREE CHARACTERS LEFT: "123" -> "231".  WE CHANGE
	    // "FWORD" HERE, IT'S CHANGED BACK AFTERWARDS AT STATE_UNROT3L.
	    IF (TRY_DEEPER(SU, STACK, DEPTH, SCORE_SWAP3))
	    {
		GO_DEEPER(STACK, DEPTH, SCORE_SWAP3);
#IFDEF DEBUG_TRIEWALK
		P = FWORD + SP->TS_FIDX;
		SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: ROTATE LEFT %C%C%C",
			SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			P[0], P[1], P[2]);
#ENDIF
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_UNROT3L;
		++DEPTH;
		P = FWORD + SP->TS_FIDX;
		IF (HAS_MBYTE)
		{
		    N = MB_CPTR2LEN(P);
		    C = MB_PTR2CHAR(P);
		    FL = MB_CPTR2LEN(P + N);
		    FL += MB_CPTR2LEN(P + N + FL);
		    MCH_MEMMOVE(P, P + N, FL);
		    MB_CHAR2BYTES(C, P + FL);
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + N + FL;
		}
		ELSE
		{
		    C = *P;
		    *P = P[1];
		    P[1] = P[2];
		    P[2] = C;
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + 3;
		}
	    }
	    ELSE
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
	    }
	    BREAK;

	CASE STATE_UNROT3L:
	    // UNDO ROT3L: "231" -> "123"
	    P = FWORD + SP->TS_FIDX;
	    IF (HAS_MBYTE)
	    {
		N = MB_PTR2LEN(P);
		N += MB_PTR2LEN(P + N);
		C = MB_PTR2CHAR(P + N);
		TL = MB_PTR2LEN(P + N);
		MCH_MEMMOVE(P + TL, P, N);
		MB_CHAR2BYTES(C, P);
	    }
	    ELSE
	    {
		C = P[2];
		P[2] = P[1];
		P[1] = *P;
		*P = C;
	    }

	    // ROTATE THREE BYTES RIGHT: "123" -> "312".  WE CHANGE "FWORD"
	    // HERE, IT'S CHANGED BACK AFTERWARDS AT STATE_UNROT3R.
	    IF (TRY_DEEPER(SU, STACK, DEPTH, SCORE_SWAP3))
	    {
		GO_DEEPER(STACK, DEPTH, SCORE_SWAP3);
#IFDEF DEBUG_TRIEWALK
		P = FWORD + SP->TS_FIDX;
		SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: ROTATE RIGHT %C%C%C",
			SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			P[0], P[1], P[2]);
#ENDIF
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_UNROT3R;
		++DEPTH;
		P = FWORD + SP->TS_FIDX;
		IF (HAS_MBYTE)
		{
		    N = MB_CPTR2LEN(P);
		    N += MB_CPTR2LEN(P + N);
		    C = MB_PTR2CHAR(P + N);
		    TL = MB_CPTR2LEN(P + N);
		    MCH_MEMMOVE(P + TL, P, N);
		    MB_CHAR2BYTES(C, P);
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + N + TL;
		}
		ELSE
		{
		    C = P[2];
		    P[2] = P[1];
		    P[1] = *P;
		    *P = C;
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + 3;
		}
	    }
	    ELSE
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_REP_INI;
	    }
	    BREAK;

	CASE STATE_UNROT3R:
	    // UNDO ROT3R: "312" -> "123"
	    P = FWORD + SP->TS_FIDX;
	    IF (HAS_MBYTE)
	    {
		C = MB_PTR2CHAR(P);
		TL = MB_PTR2LEN(P);
		N = MB_PTR2LEN(P + TL);
		N += MB_PTR2LEN(P + TL + N);
		MCH_MEMMOVE(P, P + TL, N);
		MB_CHAR2BYTES(C, P + N);
	    }
	    ELSE
	    {
		C = *P;
		*P = P[1];
		P[1] = P[2];
		P[2] = C;
	    }
	    // FALLTHROUGH

	CASE STATE_REP_INI:
	    // CHECK IF MATCHING WITH REP ITEMS FROM THE .AFF FILE WOULD WORK.
	    // QUICKLY SKIP IF:
	    // - THERE ARE NO REP ITEMS AND WE ARE NOT IN THE SOUNDFOLD TRIE
	    // - THE SCORE IS GOING TO BE TOO HIGH ANYWAY
	    // - ALREADY APPLIED A REP ITEM OR SWAPPED HERE
	    IF ((LP->LP_REPLANG == NULL && !SOUNDFOLD)
		    || SP->TS_SCORE + SCORE_REP >= SU->SU_MAXSCORE
		    || SP->TS_FIDX < SP->TS_FIDXTRY)
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_FINAL;
		BREAK;
	    }

	    // USE THE FIRST BYTE TO QUICKLY FIND THE FIRST ENTRY THAT MAY
	    // MATCH.  IF THE INDEX IS -1 THERE IS NONE.
	    IF (SOUNDFOLD)
		SP->TS_CURI = SLANG->SL_REPSAL_FIRST[FWORD[SP->TS_FIDX]];
	    ELSE
		SP->TS_CURI = LP->LP_REPLANG->SL_REP_FIRST[FWORD[SP->TS_FIDX]];

	    IF (SP->TS_CURI < 0)
	    {
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_FINAL;
		BREAK;
	    }

	    PROF_STORE(SP->TS_STATE)
	    SP->TS_STATE = STATE_REP;
	    // FALLTHROUGH

	CASE STATE_REP:
	    // TRY MATCHING WITH REP ITEMS FROM THE .AFF FILE.  FOR EACH MATCH
	    // REPLACE THE CHARACTERS AND CHECK IF THE RESULTING WORD IS
	    // VALID.
	    P = FWORD + SP->TS_FIDX;

	    IF (SOUNDFOLD)
		GAP = &SLANG->SL_REPSAL;
	    ELSE
		GAP = &LP->LP_REPLANG->SL_REP;
	    WHILE (SP->TS_CURI < GAP->GA_LEN)
	    {
		FTP = (FROMTO_T *)GAP->GA_DATA + SP->TS_CURI++;
		IF (*FTP->FT_FROM != *P)
		{
		    // PAST POSSIBLE MATCHING ENTRIES
		    SP->TS_CURI = GAP->GA_LEN;
		    BREAK;
		}
		IF (STRNCMP(FTP->FT_FROM, P, STRLEN(FTP->FT_FROM)) == 0
			&& TRY_DEEPER(SU, STACK, DEPTH, SCORE_REP))
		{
		    GO_DEEPER(STACK, DEPTH, SCORE_REP);
#IFDEF DEBUG_TRIEWALK
		    SPRINTF(CHANGENAME[DEPTH], "%.*S-%S: REPLACE %S WITH %S",
			    SP->TS_TWORDLEN, TWORD, FWORD + SP->TS_FIDX,
			    FTP->FT_FROM, FTP->FT_TO);
#ENDIF
		    // NEED TO UNDO THIS AFTERWARDS.
		    PROF_STORE(SP->TS_STATE)
		    SP->TS_STATE = STATE_REP_UNDO;

		    // CHANGE THE "FROM" TO THE "TO" STRING.
		    ++DEPTH;
		    FL = (INT)STRLEN(FTP->FT_FROM);
		    TL = (INT)STRLEN(FTP->FT_TO);
		    IF (FL != TL)
		    {
			STRMOVE(P + TL, P + FL);
			REPEXTRA += TL - FL;
		    }
		    MCH_MEMMOVE(P, FTP->FT_TO, TL);
		    STACK[DEPTH].TS_FIDXTRY = SP->TS_FIDX + TL;
		    STACK[DEPTH].TS_TCHARLEN = 0;
		    BREAK;
		}
	    }

	    IF (SP->TS_CURI >= GAP->GA_LEN && SP->TS_STATE == STATE_REP)
	    {
		// NO (MORE) MATCHES.
		PROF_STORE(SP->TS_STATE)
		SP->TS_STATE = STATE_FINAL;
	    }

	    BREAK;

	CASE STATE_REP_UNDO:
	    // UNDO A REP REPLACEMENT AND CONTINUE WITH THE NEXT ONE.
	    IF (SOUNDFOLD)
		GAP = &SLANG->SL_REPSAL;
	    ELSE
		GAP = &LP->LP_REPLANG->SL_REP;
	    FTP = (FROMTO_T *)GAP->GA_DATA + SP->TS_CURI - 1;
	    FL = (INT)STRLEN(FTP->FT_FROM);
	    TL = (INT)STRLEN(FTP->FT_TO);
	    P = FWORD + SP->TS_FIDX;
	    IF (FL != TL)
	    {
		STRMOVE(P + FL, P + TL);
		REPEXTRA -= TL - FL;
	    }
	    MCH_MEMMOVE(P, FTP->FT_FROM, FL);
	    PROF_STORE(SP->TS_STATE)
	    SP->TS_STATE = STATE_REP;
	    BREAK;

	DEFAULT:
	    // DID ALL POSSIBLE STATES AT THIS LEVEL, GO UP ONE LEVEL.
	    --DEPTH;

	    IF (DEPTH >= 0 && STACK[DEPTH].TS_PREFIXDEPTH == PFD_PREFIXTREE)
	    {
		// CONTINUE IN OR GO BACK TO THE PREFIX TREE.
		BYTS = PBYTS;
		IDXS = PIDXS;
	    }

	    // DON'T CHECK FOR CTRL-C TOO OFTEN, IT TAKES TIME.
	    IF (--BREAKCHECKCOUNT == 0)
	    {
		UI_BREAKCHECK();
		BREAKCHECKCOUNT = 1000;
#IFDEF FEAT_RELTIME
		IF (SPELL_SUGGEST_TIMEOUT > 0
					  && PROFILE_PASSED_LIMIT(&TIME_LIMIT))
		    GOT_INT = TRUE;
#ENDIF
	    }
	}
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219996_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_GET_USER_MODULE (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * USER_DATA) {
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)USER_DATA;
  JSON_T * J_MODULE;
  
  J_MODULE = GET_USER_MODULE(CONFIG, U_MAP_GET(REQUEST->MAP_URL, "NAME"));
  IF (CHECK_RESULT_VALUE(J_MODULE, G_OK)) {
    ULFIUS_SET_JSON_BODY_RESPONSE(RESPONSE, 200, JSON_OBJECT_GET(J_MODULE, "MODULE"));
  } ELSE IF (CHECK_RESULT_VALUE(J_MODULE, G_ERROR_NOT_FOUND)) {
    RESPONSE->STATUS = 404;
  } ELSE {
    Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_GET_USER_MODULE - ERROR GET_USER_MODULE");
    RESPONSE->STATUS = 500;
  }
  JSON_DECREF(J_MODULE);
  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206639_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT NFT_VERDICT_INIT(CONST STRUCT NFT_CTX *CTX, STRUCT NFT_DATA *DATA,
			    STRUCT NFT_DATA_DESC *DESC, CONST STRUCT NLATTR *NLA)
{
	U8 GENMASK = NFT_GENMASK_NEXT(CTX->NET);
	STRUCT NLATTR *TB[NFTA_VERDICT_MAX + 1];
	STRUCT NFT_CHAIN *CHAIN;
	INT ERR;

	ERR = NLA_PARSE_NESTED_DEPRECATED(TB, NFTA_VERDICT_MAX, NLA,
					  NFT_VERDICT_POLICY, NULL);
	IF (ERR < 0)
		RETURN ERR;

	IF (!TB[NFTA_VERDICT_CODE])
		RETURN -EINVAL;
	DATA->VERDICT.CODE = NTOHL(NLA_GET_BE32(TB[NFTA_VERDICT_CODE]));

	SWITCH (DATA->VERDICT.CODE) {
	DEFAULT:
		SWITCH (DATA->VERDICT.CODE & NF_VERDICT_MASK) {
		CASE NF_ACCEPT:
		CASE NF_DROP:
		CASE NF_QUEUE:
			BREAK;
		DEFAULT:
			RETURN -EINVAL;
		}
		FALLTHROUGH;
	CASE NFT_CONTINUE:
	CASE NFT_BREAK:
	CASE NFT_RETURN:
		BREAK;
	CASE NFT_JUMP:
	CASE NFT_GOTO:
		IF (TB[NFTA_VERDICT_CHAIN]) {
			CHAIN = NFT_CHAIN_LOOKUP(CTX->NET, CTX->TABLE,
						 TB[NFTA_VERDICT_CHAIN],
						 GENMASK);
		} ELSE IF (TB[NFTA_VERDICT_CHAIN_ID]) {
			CHAIN = NFT_CHAIN_LOOKUP_BYID(CTX->NET, CTX->TABLE,
						      TB[NFTA_VERDICT_CHAIN_ID]);
			IF (IS_ERR(CHAIN))
				RETURN PTR_ERR(CHAIN);
		} ELSE {
			RETURN -EINVAL;
		}

		IF (IS_ERR(CHAIN))
			RETURN PTR_ERR(CHAIN);
		IF (NFT_IS_BASE_CHAIN(CHAIN))
			RETURN -EOPNOTSUPP;
		IF (DESC->FLAGS & NFT_DATA_DESC_SETELEM &&
		    CHAIN->FLAGS & NFT_CHAIN_BINDING)
			RETURN -EINVAL;

		CHAIN->USE++;
		DATA->VERDICT.CHAIN = CHAIN;
		BREAK;
	}

	DESC->LEN = SIZEOF(DATA->VERDICT);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 232943_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CURLCODE ZSTD_INIT_WRITER(STRUCT CURL_EASY *DATA,
                                 STRUCT CONTENC_WRITER *WRITER)
{
  STRUCT ZSTD_PARAMS *ZP = (STRUCT ZSTD_PARAMS *)&WRITER->PARAMS;
  (VOID)DATA;

  IF(!WRITER->DOWNSTREAM)
    RETURN CURLE_WRITE_ERROR;

  ZP->ZDS = ZSTD_CREATEDSTREAM();
  ZP->DECOMP = NULL;
  RETURN ZP->ZDS ? CURLE_OK : CURLE_OUT_OF_MEMORY;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 387592_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SND_CTL_DEV_DISCONNECT(STRUCT SND_DEVICE *DEVICE)
{
	STRUCT SND_CARD *CARD = DEVICE->DEVICE_DATA;
	STRUCT SND_CTL_FILE *CTL;
	STRUCT SND_CTL_LAYER_OPS *LOPS;
	UNSIGNED LONG FLAGS;

	READ_LOCK_IRQSAVE(&CARD->CTL_FILES_RWLOCK, FLAGS);
	LIST_FOR_EACH_ENTRY(CTL, &CARD->CTL_FILES, LIST) {
		WAKE_UP(&CTL->CHANGE_SLEEP);
		SND_KILL_FASYNC(CTL->FASYNC, SIGIO, POLL_ERR);
	}
	READ_UNLOCK_IRQRESTORE(&CARD->CTL_FILES_RWLOCK, FLAGS);

	DOWN_READ(&CARD->CONTROLS_RWSEM);
	DOWN_READ(&SND_CTL_LAYER_RWSEM);
	FOR (LOPS = SND_CTL_LAYER; LOPS; LOPS = LOPS->NEXT)
		LOPS->LDISCONNECT(CARD);
	UP_READ(&SND_CTL_LAYER_RWSEM);
	UP_READ(&CARD->CONTROLS_RWSEM);

	RETURN SND_UNREGISTER_DEVICE(&CARD->CTL_DEV);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 405373_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CONST VOID *XFRM_GET_DST_NEXTHOP(CONST STRUCT DST_ENTRY *DST,
					CONST VOID *DADDR)
{
	WHILE (DST->XFRM) {
		CONST STRUCT XFRM_STATE *XFRM = DST->XFRM;

		DST = XFRM_DST_CHILD(DST);

		IF (XFRM->PROPS.MODE == XFRM_MODE_TRANSPORT)
			CONTINUE;
		IF (XFRM->TYPE->FLAGS & XFRM_TYPE_REMOTE_COADDR)
			DADDR = XFRM->COADDR;
		ELSE IF (!(XFRM->TYPE->FLAGS & XFRM_TYPE_LOCAL_COADDR))
			DADDR = &XFRM->ID.DADDR;
	}
	RETURN DADDR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 482684_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GST_FLXDEC_CHANGE_STATE (GSTELEMENT * ELEMENT, GSTSTATECHANGE TRANSITION)
{
  GSTFLXDEC *FLXDEC;
  GSTSTATECHANGERETURN RET;

  FLXDEC = GST_FLXDEC (ELEMENT);

  SWITCH (TRANSITION) {
    CASE GST_STATE_CHANGE_NULL_TO_READY:
      BREAK;
    CASE GST_STATE_CHANGE_READY_TO_PAUSED:
      GST_ADAPTER_CLEAR (FLXDEC->ADAPTER);
      FLXDEC->STATE = GST_FLXDEC_READ_HEADER;
      BREAK;
    CASE GST_STATE_CHANGE_PAUSED_TO_PLAYING:
      BREAK;
    DEFAULT:
      BREAK;
  }

  RET = GST_ELEMENT_CLASS (PARENT_CLASS)->CHANGE_STATE (ELEMENT, TRANSITION);

  SWITCH (TRANSITION) {
    CASE GST_STATE_CHANGE_PLAYING_TO_PAUSED:
      BREAK;
    CASE GST_STATE_CHANGE_PAUSED_TO_READY:
      IF (FLXDEC->FRAME_DATA) {
        G_FREE (FLXDEC->FRAME_DATA);
        FLXDEC->FRAME_DATA = NULL;
      }
      IF (FLXDEC->DELTA_DATA) {
        G_FREE (FLXDEC->DELTA_DATA);
        FLXDEC->DELTA_DATA = NULL;
      }
      IF (FLXDEC->CONVERTER) {
        FLX_COLORSPACE_CONVERTER_DESTROY (FLXDEC->CONVERTER);
        FLXDEC->CONVERTER = NULL;
      }
      BREAK;
    CASE GST_STATE_CHANGE_READY_TO_NULL:
      BREAK;
    DEFAULT:
      BREAK;
  }
  RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196889_CWE-284.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT PGPPRTPARAMS(CONST UINT8_T * PKTS, SIZE_T PKTLEN, UNSIGNED INT PKTTYPE,
		 PGPDIGPARAMS * RET)
{
    CONST UINT8_T *P = PKTS;
    CONST UINT8_T *PEND = PKTS + PKTLEN;
    PGPDIGPARAMS DIGP = NULL;
    STRUCT PGPPKT PKT;
    INT RC = -1; /* ASSUME FAILURE */

    WHILE (P < PEND) {
	IF (DECODEPKT(P, (PEND - P), &PKT))
	    BREAK;

	IF (DIGP == NULL) {
	    IF (PKTTYPE && PKT.TAG != PKTTYPE) {
		BREAK;
	    } ELSE {
		DIGP = PGPDIGPARAMSNEW(PKT.TAG);
	    }
	}

	IF (PGPPRTPKT(&PKT, DIGP))
	    BREAK;

	P += (PKT.BODY - PKT.HEAD) + PKT.BLEN;
	IF (PKTTYPE == PGPTAG_SIGNATURE)
	    BREAK;
    }

    RC = (DIGP && (P == PEND)) ? 0 : -1;

    IF (RET && RC == 0) {
	*RET = DIGP;
    } ELSE {
	PGPDIGPARAMSFREE(DIGP);
    }
    RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199778_CWE-444.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SIZE_T PUMA_PARSER_EXECUTE(PUMA_PARSER *PARSER, CONST CHAR *BUFFER, SIZE_T LEN, SIZE_T OFF)  {
  CONST CHAR *P, *PE;
  INT CS = PARSER->CS;

  ASSERT(OFF <= LEN && "OFFSET PAST END OF BUFFER");

  P = BUFFER+OFF;
  PE = BUFFER+LEN;

  /* ASSERT(*PE == '\0' && "POINTER DOES NOT END ON NUL"); */
  ASSERT((SIZE_T) (PE - P) == LEN - OFF && "POINTERS AREN'T SAME DISTANCE");

  
#LINE 87 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	{
	IF ( P == PE )
		GOTO _TEST_EOF;
	SWITCH ( CS )
	{
CASE 1:
	SWITCH( (*P) ) {
		CASE 36: GOTO TR0;
		CASE 95: GOTO TR0;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO TR0;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO TR0;
	} ELSE
		GOTO TR0;
	GOTO ST0;
ST0:
CS = 0;
	GOTO _OUT;
TR0:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST2;
ST2:
	IF ( ++P == PE )
		GOTO _TEST_EOF2;
CASE 2:
#LINE 118 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST27;
		CASE 95: GOTO ST27;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST27;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST27;
	} ELSE
		GOTO ST27;
	GOTO ST0;
TR2:
#LINE 50 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_METHOD(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST3;
ST3:
	IF ( ++P == PE )
		GOTO _TEST_EOF3;
CASE 3:
#LINE 143 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 42: GOTO TR4;
		CASE 43: GOTO TR5;
		CASE 47: GOTO TR6;
		CASE 58: GOTO TR7;
	}
	IF ( (*P) < 65 ) {
		IF ( 45 <= (*P) && (*P) <= 57 )
			GOTO TR5;
	} ELSE IF ( (*P) > 90 ) {
		IF ( 97 <= (*P) && (*P) <= 122 )
			GOTO TR5;
	} ELSE
		GOTO TR5;
	GOTO ST0;
TR4:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST4;
ST4:
	IF ( ++P == PE )
		GOTO _TEST_EOF4;
CASE 4:
#LINE 167 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR8;
		CASE 35: GOTO TR9;
	}
	GOTO ST0;
TR8:
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST5;
TR31:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
#LINE 56 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->FRAGMENT(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST5;
TR33:
#LINE 56 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->FRAGMENT(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST5;
TR37:
#LINE 69 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_PATH(PARSER, PTR_TO(MARK), LEN(MARK,P));
  }
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST5;
TR41:
#LINE 60 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(QUERY_START, P); }
#LINE 61 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->QUERY_STRING(PARSER, PTR_TO(QUERY_START), LEN(QUERY_START, P));
  }
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST5;
TR44:
#LINE 61 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->QUERY_STRING(PARSER, PTR_TO(QUERY_START), LEN(QUERY_START, P));
  }
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST5;
ST5:
	IF ( ++P == PE )
		GOTO _TEST_EOF5;
CASE 5:
#LINE 229 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	IF ( (*P) == 72 )
		GOTO TR10;
	GOTO ST0;
TR10:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST6;
ST6:
	IF ( ++P == PE )
		GOTO _TEST_EOF6;
CASE 6:
#LINE 241 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	IF ( (*P) == 84 )
		GOTO ST7;
	GOTO ST0;
ST7:
	IF ( ++P == PE )
		GOTO _TEST_EOF7;
CASE 7:
	IF ( (*P) == 84 )
		GOTO ST8;
	GOTO ST0;
ST8:
	IF ( ++P == PE )
		GOTO _TEST_EOF8;
CASE 8:
	IF ( (*P) == 80 )
		GOTO ST9;
	GOTO ST0;
ST9:
	IF ( ++P == PE )
		GOTO _TEST_EOF9;
CASE 9:
	IF ( (*P) == 47 )
		GOTO ST10;
	GOTO ST0;
ST10:
	IF ( ++P == PE )
		GOTO _TEST_EOF10;
CASE 10:
	IF ( 48 <= (*P) && (*P) <= 57 )
		GOTO ST11;
	GOTO ST0;
ST11:
	IF ( ++P == PE )
		GOTO _TEST_EOF11;
CASE 11:
	IF ( (*P) == 46 )
		GOTO ST12;
	IF ( 48 <= (*P) && (*P) <= 57 )
		GOTO ST11;
	GOTO ST0;
ST12:
	IF ( ++P == PE )
		GOTO _TEST_EOF12;
CASE 12:
	IF ( 48 <= (*P) && (*P) <= 57 )
		GOTO ST13;
	GOTO ST0;
ST13:
	IF ( ++P == PE )
		GOTO _TEST_EOF13;
CASE 13:
	IF ( (*P) == 13 )
		GOTO TR18;
	IF ( 48 <= (*P) && (*P) <= 57 )
		GOTO ST13;
	GOTO ST0;
TR18:
#LINE 65 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->HTTP_VERSION(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST14;
TR26:
#LINE 46 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
#LINE 47 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->HTTP_FIELD(PARSER, PTR_TO(FIELD_START), PARSER->FIELD_LEN, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST14;
TR29:
#LINE 47 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->HTTP_FIELD(PARSER, PTR_TO(FIELD_START), PARSER->FIELD_LEN, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST14;
ST14:
	IF ( ++P == PE )
		GOTO _TEST_EOF14;
CASE 14:
#LINE 322 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	IF ( (*P) == 10 )
		GOTO ST15;
	GOTO ST0;
ST15:
	IF ( ++P == PE )
		GOTO _TEST_EOF15;
CASE 15:
	SWITCH( (*P) ) {
		CASE 13: GOTO ST16;
		CASE 33: GOTO TR21;
		CASE 124: GOTO TR21;
		CASE 126: GOTO TR21;
	}
	IF ( (*P) < 45 ) {
		IF ( (*P) > 39 ) {
			IF ( 42 <= (*P) && (*P) <= 43 )
				GOTO TR21;
		} ELSE IF ( (*P) >= 35 )
			GOTO TR21;
	} ELSE IF ( (*P) > 46 ) {
		IF ( (*P) < 65 ) {
			IF ( 48 <= (*P) && (*P) <= 57 )
				GOTO TR21;
		} ELSE IF ( (*P) > 90 ) {
			IF ( 94 <= (*P) && (*P) <= 122 )
				GOTO TR21;
		} ELSE
			GOTO TR21;
	} ELSE
		GOTO TR21;
	GOTO ST0;
ST16:
	IF ( ++P == PE )
		GOTO _TEST_EOF16;
CASE 16:
	IF ( (*P) == 10 )
		GOTO TR22;
	GOTO ST0;
TR22:
#LINE 73 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->BODY_START = P - BUFFER + 1;
    PARSER->HEADER_DONE(PARSER, P + 1, PE - P - 1);
    {P++; CS = 46; GOTO _OUT;}
  }
	GOTO ST46;
ST46:
	IF ( ++P == PE )
		GOTO _TEST_EOF46;
CASE 46:
#LINE 373 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	GOTO ST0;
TR21:
#LINE 40 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(FIELD_START, P); }
#LINE 41 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ SNAKE_UPCASE_CHAR((CHAR *)P); }
	GOTO ST17;
TR23:
#LINE 41 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ SNAKE_UPCASE_CHAR((CHAR *)P); }
	GOTO ST17;
ST17:
	IF ( ++P == PE )
		GOTO _TEST_EOF17;
CASE 17:
#LINE 389 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 33: GOTO TR23;
		CASE 58: GOTO TR24;
		CASE 124: GOTO TR23;
		CASE 126: GOTO TR23;
	}
	IF ( (*P) < 45 ) {
		IF ( (*P) > 39 ) {
			IF ( 42 <= (*P) && (*P) <= 43 )
				GOTO TR23;
		} ELSE IF ( (*P) >= 35 )
			GOTO TR23;
	} ELSE IF ( (*P) > 46 ) {
		IF ( (*P) < 65 ) {
			IF ( 48 <= (*P) && (*P) <= 57 )
				GOTO TR23;
		} ELSE IF ( (*P) > 90 ) {
			IF ( 94 <= (*P) && (*P) <= 122 )
				GOTO TR23;
		} ELSE
			GOTO TR23;
	} ELSE
		GOTO TR23;
	GOTO ST0;
TR24:
#LINE 42 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->FIELD_LEN = LEN(FIELD_START, P);
  }
	GOTO ST18;
TR27:
#LINE 46 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST18;
ST18:
	IF ( ++P == PE )
		GOTO _TEST_EOF18;
CASE 18:
#LINE 428 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 13: GOTO TR26;
		CASE 32: GOTO TR27;
	}
	GOTO TR25;
TR25:
#LINE 46 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST19;
ST19:
	IF ( ++P == PE )
		GOTO _TEST_EOF19;
CASE 19:
#LINE 442 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	IF ( (*P) == 13 )
		GOTO TR29;
	GOTO ST19;
TR9:
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST20;
TR38:
#LINE 69 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_PATH(PARSER, PTR_TO(MARK), LEN(MARK,P));
  }
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST20;
TR42:
#LINE 60 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(QUERY_START, P); }
#LINE 61 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->QUERY_STRING(PARSER, PTR_TO(QUERY_START), LEN(QUERY_START, P));
  }
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST20;
TR45:
#LINE 61 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->QUERY_STRING(PARSER, PTR_TO(QUERY_START), LEN(QUERY_START, P));
  }
#LINE 53 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_URI(PARSER, PTR_TO(MARK), LEN(MARK, P));
  }
	GOTO ST20;
ST20:
	IF ( ++P == PE )
		GOTO _TEST_EOF20;
CASE 20:
#LINE 488 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR31;
		CASE 60: GOTO ST0;
		CASE 62: GOTO ST0;
		CASE 127: GOTO ST0;
	}
	IF ( (*P) > 31 ) {
		IF ( 34 <= (*P) && (*P) <= 35 )
			GOTO ST0;
	} ELSE IF ( (*P) >= 0 )
		GOTO ST0;
	GOTO TR30;
TR30:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST21;
ST21:
	IF ( ++P == PE )
		GOTO _TEST_EOF21;
CASE 21:
#LINE 509 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR33;
		CASE 60: GOTO ST0;
		CASE 62: GOTO ST0;
		CASE 127: GOTO ST0;
	}
	IF ( (*P) > 31 ) {
		IF ( 34 <= (*P) && (*P) <= 35 )
			GOTO ST0;
	} ELSE IF ( (*P) >= 0 )
		GOTO ST0;
	GOTO ST21;
TR5:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST22;
ST22:
	IF ( ++P == PE )
		GOTO _TEST_EOF22;
CASE 22:
#LINE 530 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 43: GOTO ST22;
		CASE 58: GOTO ST23;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST22;
	} ELSE IF ( (*P) > 57 ) {
		IF ( (*P) > 90 ) {
			IF ( 97 <= (*P) && (*P) <= 122 )
				GOTO ST22;
		} ELSE IF ( (*P) >= 65 )
			GOTO ST22;
	} ELSE
		GOTO ST22;
	GOTO ST0;
TR7:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST23;
ST23:
	IF ( ++P == PE )
		GOTO _TEST_EOF23;
CASE 23:
#LINE 555 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR8;
		CASE 34: GOTO ST0;
		CASE 35: GOTO TR9;
		CASE 60: GOTO ST0;
		CASE 62: GOTO ST0;
		CASE 127: GOTO ST0;
	}
	IF ( 0 <= (*P) && (*P) <= 31 )
		GOTO ST0;
	GOTO ST23;
TR6:
#LINE 37 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(MARK, P); }
	GOTO ST24;
ST24:
	IF ( ++P == PE )
		GOTO _TEST_EOF24;
CASE 24:
#LINE 575 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR37;
		CASE 34: GOTO ST0;
		CASE 35: GOTO TR38;
		CASE 60: GOTO ST0;
		CASE 62: GOTO ST0;
		CASE 63: GOTO TR39;
		CASE 127: GOTO ST0;
	}
	IF ( 0 <= (*P) && (*P) <= 31 )
		GOTO ST0;
	GOTO ST24;
TR39:
#LINE 69 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{
    PARSER->REQUEST_PATH(PARSER, PTR_TO(MARK), LEN(MARK,P));
  }
	GOTO ST25;
ST25:
	IF ( ++P == PE )
		GOTO _TEST_EOF25;
CASE 25:
#LINE 598 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR41;
		CASE 34: GOTO ST0;
		CASE 35: GOTO TR42;
		CASE 60: GOTO ST0;
		CASE 62: GOTO ST0;
		CASE 127: GOTO ST0;
	}
	IF ( 0 <= (*P) && (*P) <= 31 )
		GOTO ST0;
	GOTO TR40;
TR40:
#LINE 60 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"
	{ MARK(QUERY_START, P); }
	GOTO ST26;
ST26:
	IF ( ++P == PE )
		GOTO _TEST_EOF26;
CASE 26:
#LINE 618 "EXT/PUMA_HTTP11/HTTP11_PARSER.C"
	SWITCH( (*P) ) {
		CASE 32: GOTO TR44;
		CASE 34: GOTO ST0;
		CASE 35: GOTO TR45;
		CASE 60: GOTO ST0;
		CASE 62: GOTO ST0;
		CASE 127: GOTO ST0;
	}
	IF ( 0 <= (*P) && (*P) <= 31 )
		GOTO ST0;
	GOTO ST26;
ST27:
	IF ( ++P == PE )
		GOTO _TEST_EOF27;
CASE 27:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST28;
		CASE 95: GOTO ST28;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST28;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST28;
	} ELSE
		GOTO ST28;
	GOTO ST0;
ST28:
	IF ( ++P == PE )
		GOTO _TEST_EOF28;
CASE 28:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST29;
		CASE 95: GOTO ST29;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST29;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST29;
	} ELSE
		GOTO ST29;
	GOTO ST0;
ST29:
	IF ( ++P == PE )
		GOTO _TEST_EOF29;
CASE 29:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST30;
		CASE 95: GOTO ST30;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST30;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST30;
	} ELSE
		GOTO ST30;
	GOTO ST0;
ST30:
	IF ( ++P == PE )
		GOTO _TEST_EOF30;
CASE 30:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST31;
		CASE 95: GOTO ST31;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST31;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST31;
	} ELSE
		GOTO ST31;
	GOTO ST0;
ST31:
	IF ( ++P == PE )
		GOTO _TEST_EOF31;
CASE 31:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST32;
		CASE 95: GOTO ST32;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST32;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST32;
	} ELSE
		GOTO ST32;
	GOTO ST0;
ST32:
	IF ( ++P == PE )
		GOTO _TEST_EOF32;
CASE 32:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST33;
		CASE 95: GOTO ST33;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST33;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST33;
	} ELSE
		GOTO ST33;
	GOTO ST0;
ST33:
	IF ( ++P == PE )
		GOTO _TEST_EOF33;
CASE 33:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST34;
		CASE 95: GOTO ST34;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST34;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST34;
	} ELSE
		GOTO ST34;
	GOTO ST0;
ST34:
	IF ( ++P == PE )
		GOTO _TEST_EOF34;
CASE 34:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST35;
		CASE 95: GOTO ST35;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST35;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST35;
	} ELSE
		GOTO ST35;
	GOTO ST0;
ST35:
	IF ( ++P == PE )
		GOTO _TEST_EOF35;
CASE 35:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST36;
		CASE 95: GOTO ST36;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST36;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST36;
	} ELSE
		GOTO ST36;
	GOTO ST0;
ST36:
	IF ( ++P == PE )
		GOTO _TEST_EOF36;
CASE 36:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST37;
		CASE 95: GOTO ST37;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST37;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST37;
	} ELSE
		GOTO ST37;
	GOTO ST0;
ST37:
	IF ( ++P == PE )
		GOTO _TEST_EOF37;
CASE 37:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST38;
		CASE 95: GOTO ST38;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST38;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST38;
	} ELSE
		GOTO ST38;
	GOTO ST0;
ST38:
	IF ( ++P == PE )
		GOTO _TEST_EOF38;
CASE 38:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST39;
		CASE 95: GOTO ST39;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST39;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST39;
	} ELSE
		GOTO ST39;
	GOTO ST0;
ST39:
	IF ( ++P == PE )
		GOTO _TEST_EOF39;
CASE 39:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST40;
		CASE 95: GOTO ST40;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST40;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST40;
	} ELSE
		GOTO ST40;
	GOTO ST0;
ST40:
	IF ( ++P == PE )
		GOTO _TEST_EOF40;
CASE 40:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST41;
		CASE 95: GOTO ST41;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST41;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST41;
	} ELSE
		GOTO ST41;
	GOTO ST0;
ST41:
	IF ( ++P == PE )
		GOTO _TEST_EOF41;
CASE 41:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST42;
		CASE 95: GOTO ST42;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST42;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST42;
	} ELSE
		GOTO ST42;
	GOTO ST0;
ST42:
	IF ( ++P == PE )
		GOTO _TEST_EOF42;
CASE 42:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST43;
		CASE 95: GOTO ST43;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST43;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST43;
	} ELSE
		GOTO ST43;
	GOTO ST0;
ST43:
	IF ( ++P == PE )
		GOTO _TEST_EOF43;
CASE 43:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST44;
		CASE 95: GOTO ST44;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST44;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST44;
	} ELSE
		GOTO ST44;
	GOTO ST0;
ST44:
	IF ( ++P == PE )
		GOTO _TEST_EOF44;
CASE 44:
	SWITCH( (*P) ) {
		CASE 32: GOTO TR2;
		CASE 36: GOTO ST45;
		CASE 95: GOTO ST45;
	}
	IF ( (*P) < 48 ) {
		IF ( 45 <= (*P) && (*P) <= 46 )
			GOTO ST45;
	} ELSE IF ( (*P) > 57 ) {
		IF ( 65 <= (*P) && (*P) <= 90 )
			GOTO ST45;
	} ELSE
		GOTO ST45;
	GOTO ST0;
ST45:
	IF ( ++P == PE )
		GOTO _TEST_EOF45;
CASE 45:
	IF ( (*P) == 32 )
		GOTO TR2;
	GOTO ST0;
	}
	_TEST_EOF2: CS = 2; GOTO _TEST_EOF; 
	_TEST_EOF3: CS = 3; GOTO _TEST_EOF; 
	_TEST_EOF4: CS = 4; GOTO _TEST_EOF; 
	_TEST_EOF5: CS = 5; GOTO _TEST_EOF; 
	_TEST_EOF6: CS = 6; GOTO _TEST_EOF; 
	_TEST_EOF7: CS = 7; GOTO _TEST_EOF; 
	_TEST_EOF8: CS = 8; GOTO _TEST_EOF; 
	_TEST_EOF9: CS = 9; GOTO _TEST_EOF; 
	_TEST_EOF10: CS = 10; GOTO _TEST_EOF; 
	_TEST_EOF11: CS = 11; GOTO _TEST_EOF; 
	_TEST_EOF12: CS = 12; GOTO _TEST_EOF; 
	_TEST_EOF13: CS = 13; GOTO _TEST_EOF; 
	_TEST_EOF14: CS = 14; GOTO _TEST_EOF; 
	_TEST_EOF15: CS = 15; GOTO _TEST_EOF; 
	_TEST_EOF16: CS = 16; GOTO _TEST_EOF; 
	_TEST_EOF46: CS = 46; GOTO _TEST_EOF; 
	_TEST_EOF17: CS = 17; GOTO _TEST_EOF; 
	_TEST_EOF18: CS = 18; GOTO _TEST_EOF; 
	_TEST_EOF19: CS = 19; GOTO _TEST_EOF; 
	_TEST_EOF20: CS = 20; GOTO _TEST_EOF; 
	_TEST_EOF21: CS = 21; GOTO _TEST_EOF; 
	_TEST_EOF22: CS = 22; GOTO _TEST_EOF; 
	_TEST_EOF23: CS = 23; GOTO _TEST_EOF; 
	_TEST_EOF24: CS = 24; GOTO _TEST_EOF; 
	_TEST_EOF25: CS = 25; GOTO _TEST_EOF; 
	_TEST_EOF26: CS = 26; GOTO _TEST_EOF; 
	_TEST_EOF27: CS = 27; GOTO _TEST_EOF; 
	_TEST_EOF28: CS = 28; GOTO _TEST_EOF; 
	_TEST_EOF29: CS = 29; GOTO _TEST_EOF; 
	_TEST_EOF30: CS = 30; GOTO _TEST_EOF; 
	_TEST_EOF31: CS = 31; GOTO _TEST_EOF; 
	_TEST_EOF32: CS = 32; GOTO _TEST_EOF; 
	_TEST_EOF33: CS = 33; GOTO _TEST_EOF; 
	_TEST_EOF34: CS = 34; GOTO _TEST_EOF; 
	_TEST_EOF35: CS = 35; GOTO _TEST_EOF; 
	_TEST_EOF36: CS = 36; GOTO _TEST_EOF; 
	_TEST_EOF37: CS = 37; GOTO _TEST_EOF; 
	_TEST_EOF38: CS = 38; GOTO _TEST_EOF; 
	_TEST_EOF39: CS = 39; GOTO _TEST_EOF; 
	_TEST_EOF40: CS = 40; GOTO _TEST_EOF; 
	_TEST_EOF41: CS = 41; GOTO _TEST_EOF; 
	_TEST_EOF42: CS = 42; GOTO _TEST_EOF; 
	_TEST_EOF43: CS = 43; GOTO _TEST_EOF; 
	_TEST_EOF44: CS = 44; GOTO _TEST_EOF; 
	_TEST_EOF45: CS = 45; GOTO _TEST_EOF; 

	_TEST_EOF: {}
	_OUT: {}
	}

#LINE 117 "EXT/PUMA_HTTP11/HTTP11_PARSER.RL"

  IF (!PUMA_PARSER_HAS_ERROR(PARSER))
    PARSER->CS = CS;
  PARSER->NREAD += P - (BUFFER + OFF);

  ASSERT(P <= PE && "BUFFER OVERFLOW AFTER PARSING EXECUTE");
  ASSERT(PARSER->NREAD <= LEN && "NREAD LONGER THAN LENGTH");
  ASSERT(PARSER->BODY_START <= LEN && "BODY STARTS AFTER BUFFER END");
  ASSERT(PARSER->MARK < LEN && "MARK IS AFTER BUFFER END");
  ASSERT(PARSER->FIELD_LEN <= LEN && "FIELD HAS LENGTH LONGER THAN WHOLE BUFFER");
  ASSERT(PARSER->FIELD_START < LEN && "FIELD STARTS AFTER BUFFER END");

  RETURN(PARSER->NREAD);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195328_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHAR *GF_TEXT_GET_UTF8_LINE(CHAR *SZLINE, U32 LINESIZE, FILE *TXT_IN, S32 UNICODE_TYPE)
{
	U32 I, J, LEN;
	CHAR *SOK;
	CHAR SZLINECONV[1024];
	UNSIGNED SHORT *SPTR;

	MEMSET(SZLINE, 0, SIZEOF(CHAR)*LINESIZE);
	SOK = GF_FGETS(SZLINE, LINESIZE, TXT_IN);
	IF (!SOK) RETURN NULL;
	IF (UNICODE_TYPE<=1) {
		J=0;
		LEN = (U32) STRLEN(SZLINE);
		FOR (I=0; I<LEN; I++) {
			IF (!UNICODE_TYPE && (SZLINE[I] & 0X80)) {
				/*NON UTF8 (LIKELY SOME WIN-CP)*/
				IF ((SZLINE[I+1] & 0XC0) != 0X80) {
					SZLINECONV[J] = 0XC0 | ( (SZLINE[I] >> 6) & 0X3 );
					J++;
					SZLINE[I] &= 0XBF;
				}
				/*UTF8 2 BYTES CHAR*/
				ELSE IF ( (SZLINE[I] & 0XE0) == 0XC0) {
					SZLINECONV[J] = SZLINE[I];
					I++;
					J++;
				}
				/*UTF8 3 BYTES CHAR*/
				ELSE IF ( (SZLINE[I] & 0XF0) == 0XE0) {
					SZLINECONV[J] = SZLINE[I];
					I++;
					J++;
					SZLINECONV[J] = SZLINE[I];
					I++;
					J++;
				}
				/*UTF8 4 BYTES CHAR*/
				ELSE IF ( (SZLINE[I] & 0XF8) == 0XF0) {
					SZLINECONV[J] = SZLINE[I];
					I++;
					J++;
					SZLINECONV[J] = SZLINE[I];
					I++;
					J++;
					SZLINECONV[J] = SZLINE[I];
					I++;
					J++;
				} ELSE {
					I+=1;
					CONTINUE;
				}
			}
			SZLINECONV[J] = SZLINE[I];
			J++;
		}
		SZLINECONV[J] = 0;
		STRCPY(SZLINE, SZLINECONV);
		RETURN SOK;
	}

#IFDEF GPAC_BIG_ENDIAN
	IF (UNICODE_TYPE==3)
#ELSE
	IF (UNICODE_TYPE==2)
#ENDIF
	{
		I=0;
		WHILE (1) {
			CHAR C;
			IF (!SZLINE[I] && !SZLINE[I+1]) BREAK;
			C = SZLINE[I+1];
			SZLINE[I+1] = SZLINE[I];
			SZLINE[I] = C;
			I+=2;
		}
	}
	SPTR = (U16 *)SZLINE;
	I = (U32) GF_UTF8_WCSTOMBS(SZLINECONV, 1024, (CONST UNSIGNED SHORT **) &SPTR);
	SZLINECONV[I] = 0;
	STRCPY(SZLINE, SZLINECONV);
	/*THIS IS UGLY INDEED: SINCE INPUT IS UTF16-LE, THERE ARE MANY CHANCES THE GF_FGETS NEVER READS THE \0 AFTER A \N*/
	IF (UNICODE_TYPE==3) GF_FGETC(TXT_IN);
	RETURN SOK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 424898_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC U32 IWL_TRANS_PCIE_GET_CMDLEN(STRUCT IWL_TRANS *TRANS, VOID *TFD)
{
	STRUCT IWL_TRANS_PCIE *TRANS_PCIE = IWL_TRANS_GET_PCIE_TRANS(TRANS);
	U32 CMDLEN = 0;
	INT I;

	FOR (I = 0; I < TRANS_PCIE->MAX_TBS; I++)
		CMDLEN += IWL_PCIE_TFD_TB_GET_LEN(TRANS, TFD, I);

	RETURN CMDLEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198588_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_LISP_INDENT(VOID)
{
    POS_T	*POS, REALPOS, PAREN;
    INT		AMOUNT;
    CHAR_U	*THAT;
    COLNR_T	COL;
    COLNR_T	FIRSTTRY;
    INT		PARENCOUNT, QUOTECOUNT;
    INT		VI_LISP;

    // SET VI_LISP TO USE THE VI-COMPATIBLE METHOD
    VI_LISP = (VIM_STRCHR(P_CPO, CPO_LISP) != NULL);

    REALPOS = CURWIN->W_CURSOR;
    CURWIN->W_CURSOR.COL = 0;

    IF ((POS = FINDMATCH(NULL, '(')) == NULL)
	POS = FINDMATCH(NULL, '[');
    ELSE
    {
	PAREN = *POS;
	POS = FINDMATCH(NULL, '[');
	IF (POS == NULL || LT_POSP(POS, &PAREN))
	    POS = &PAREN;
    }
    IF (POS != NULL)
    {
	// EXTRA TRICK: TAKE THE INDENT OF THE FIRST PREVIOUS NON-WHITE
	// LINE THAT IS AT THE SAME () LEVEL.
	AMOUNT = -1;
	PARENCOUNT = 0;

	WHILE (--CURWIN->W_CURSOR.LNUM >= POS->LNUM)
	{
	    IF (LINEWHITE(CURWIN->W_CURSOR.LNUM))
		CONTINUE;
	    FOR (THAT = ML_GET_CURLINE(); *THAT != NUL; ++THAT)
	    {
		IF (*THAT == ';')
		{
		    WHILE (*(THAT + 1) != NUL)
			++THAT;
		    CONTINUE;
		}
		IF (*THAT == '\\')
		{
		    IF (*(THAT + 1) != NUL)
			++THAT;
		    CONTINUE;
		}
		IF (*THAT == '"' && *(THAT + 1) != NUL)
		{
		    WHILE (*++THAT && *THAT != '"')
		    {
			// SKIPPING ESCAPED CHARACTERS IN THE STRING
			IF (*THAT == '\\')
			{
			    IF (*++THAT == NUL)
				BREAK;
			    IF (THAT[1] == NUL)
			    {
				++THAT;
				BREAK;
			    }
			}
		    }
		}
		IF (*THAT == '(' || *THAT == '[')
		    ++PARENCOUNT;
		ELSE IF (*THAT == ')' || *THAT == ']')
		    --PARENCOUNT;
	    }
	    IF (PARENCOUNT == 0)
	    {
		AMOUNT = GET_INDENT();
		BREAK;
	    }
	}

	IF (AMOUNT == -1)
	{
	    CURWIN->W_CURSOR.LNUM = POS->LNUM;
	    CURWIN->W_CURSOR.COL = POS->COL;
	    COL = POS->COL;

	    THAT = ML_GET_CURLINE();

	    IF (VI_LISP && GET_INDENT() == 0)
		AMOUNT = 2;
	    ELSE
	    {
		CHAR_U *LINE = THAT;

		AMOUNT = 0;
		WHILE (*THAT && COL)
		{
		    AMOUNT += LBR_CHARTABSIZE_ADV(LINE, &THAT, (COLNR_T)AMOUNT);
		    COL--;
		}

		// SOME KEYWORDS REQUIRE "BODY" INDENTING RULES (THE
		// NON-STANDARD-LISP ONES ARE SCHEME SPECIAL FORMS):
		//
		// (LET ((A 1))    INSTEAD    (LET ((A 1))
		//   (...))	      OF	   (...))

		IF (!VI_LISP && (*THAT == '(' || *THAT == '[')
						      && LISP_MATCH(THAT + 1))
		    AMOUNT += 2;
		ELSE
		{
		    THAT++;
		    AMOUNT++;
		    FIRSTTRY = AMOUNT;

		    WHILE (VIM_ISWHITE(*THAT))
		    {
			AMOUNT += LBR_CHARTABSIZE(LINE, THAT, (COLNR_T)AMOUNT);
			++THAT;
		    }

		    IF (*THAT && *THAT != ';') // NOT A COMMENT LINE
		    {
			// TEST *THAT != '(' TO ACCOMMODATE FIRST LET/DO
			// ARGUMENT IF IT IS MORE THAN ONE LINE
			IF (!VI_LISP && *THAT != '(' && *THAT != '[')
			    FIRSTTRY++;

			PARENCOUNT = 0;
			QUOTECOUNT = 0;

			IF (VI_LISP
				|| (*THAT != '"'
				    && *THAT != '\''
				    && *THAT != '#'
				    && (*THAT < '0' || *THAT > '9')))
			{
			    WHILE (*THAT
				    && (!VIM_ISWHITE(*THAT)
					|| QUOTECOUNT
					|| PARENCOUNT)
				    && (!((*THAT == '(' || *THAT == '[')
					    && !QUOTECOUNT
					    && !PARENCOUNT
					    && VI_LISP)))
			    {
				IF (*THAT == '"')
				    QUOTECOUNT = !QUOTECOUNT;
				IF ((*THAT == '(' || *THAT == '[')
							       && !QUOTECOUNT)
				    ++PARENCOUNT;
				IF ((*THAT == ')' || *THAT == ']')
							       && !QUOTECOUNT)
				    --PARENCOUNT;
				IF (*THAT == '\\' && *(THAT+1) != NUL)
				    AMOUNT += LBR_CHARTABSIZE_ADV(
						LINE, &THAT, (COLNR_T)AMOUNT);
				AMOUNT += LBR_CHARTABSIZE_ADV(
						LINE, &THAT, (COLNR_T)AMOUNT);
			    }
			}
			WHILE (VIM_ISWHITE(*THAT))
			{
			    AMOUNT += LBR_CHARTABSIZE(
						 LINE, THAT, (COLNR_T)AMOUNT);
			    THAT++;
			}
			IF (!*THAT || *THAT == ';')
			    AMOUNT = FIRSTTRY;
		    }
		}
	    }
	}
    }
    ELSE
	AMOUNT = 0;	// NO MATCHING '(' OR '[' FOUND, USE ZERO INDENT

    CURWIN->W_CURSOR = REALPOS;

    RETURN AMOUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195220_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT MAIN(INT ARGC, CHAR **ARGV, CHAR **ENVP)
{
	INT OPT;

	WHILE ((OPT = GETOPT(ARGC, ARGV, "B:H:K:P:Q:W:Z:XV")) != -1) {
		SWITCH (OPT) {
		CASE 'B':
			TMATE_SETTINGS->BIND_ADDR = XSTRDUP(OPTARG);
			BREAK;
		CASE 'H':
			TMATE_SETTINGS->TMATE_HOST = XSTRDUP(OPTARG);
			BREAK;
		CASE 'K':
			TMATE_SETTINGS->KEYS_DIR = XSTRDUP(OPTARG);
			BREAK;
		CASE 'P':
			TMATE_SETTINGS->SSH_PORT = ATOI(OPTARG);
			BREAK;
		CASE 'Q':
			TMATE_SETTINGS->SSH_PORT_ADVERTIZED = ATOI(OPTARG);
			BREAK;
		CASE 'W':
			TMATE_SETTINGS->WEBSOCKET_HOSTNAME = XSTRDUP(OPTARG);
			BREAK;
		CASE 'Z':
			TMATE_SETTINGS->WEBSOCKET_PORT = ATOI(OPTARG);
			BREAK;
		CASE 'X':
			TMATE_SETTINGS->USE_PROXY_PROTOCOL = TRUE;
			BREAK;
		CASE 'V':
			TMATE_SETTINGS->LOG_LEVEL++;
			BREAK;
		DEFAULT:
			USAGE();
			RETURN 1;
		}
	}

	INIT_LOGGING(TMATE_SETTINGS->LOG_LEVEL);

	SETUP_LOCALE();

	IF (!TMATE_SETTINGS->TMATE_HOST)
		TMATE_SETTINGS->TMATE_HOST = GET_FULL_HOSTNAME();

	CMDLINE = *ARGV;
	CMDLINE_END = *ENVP;

	TMATE_PRELOAD_TRACE_LIB();
	TMATE_CATCH_SIGSEGV();
	TMATE_INIT_RAND();

	IF ((MKDIR(TMATE_WORKDIR, 0701)             < 0 && ERRNO != EEXIST) ||
	    (MKDIR(TMATE_WORKDIR "/SESSIONS", 0703) < 0 && ERRNO != EEXIST) ||
	    (MKDIR(TMATE_WORKDIR "/JAIL", 0700)     < 0 && ERRNO != EEXIST))
		TMATE_FATAL("CANNOT PREPARE SESSION IN " TMATE_WORKDIR);

	/* THE WEBSOCKET SERVER NEEDS TO ACCESS THE /SESSION DIR TO RENAME SOCKETS */
	IF ((CHMOD(TMATE_WORKDIR, 0701)             < 0) ||
	    (CHMOD(TMATE_WORKDIR "/SESSIONS", 0703) < 0) ||
	    (CHMOD(TMATE_WORKDIR "/JAIL", 0700)     < 0))
		TMATE_FATAL("CANNOT PREPARE SESSION IN " TMATE_WORKDIR);

	TMATE_SSH_SERVER_MAIN(TMATE_SESSION,
			      TMATE_SETTINGS->KEYS_DIR, TMATE_SETTINGS->BIND_ADDR, TMATE_SETTINGS->SSH_PORT);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206025_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GPG_CTX_ADD_RECIPIENT (STRUCT _GPGCTX *GPG,
                       CONST GCHAR *KEYID)
{
	IF (GPG->MODE != GPG_CTX_MODE_ENCRYPT && GPG->MODE != GPG_CTX_MODE_EXPORT)
		RETURN;

	IF (!GPG->RECIPIENTS)
		GPG->RECIPIENTS = G_PTR_ARRAY_NEW ();

	G_PTR_ARRAY_ADD (GPG->RECIPIENTS, G_STRDUP (KEYID));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198512_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_VM_EXEC(MRB_STATE *MRB, CONST STRUCT RPROC *PROC, CONST MRB_CODE *PC)
{
  /* MRB_ASSERT(MRB_PROC_CFUNC_P(PROC)) */
  CONST MRB_IREP *IREP = PROC->BODY.IREP;
  CONST MRB_POOL_VALUE *POOL = IREP->POOL;
  CONST MRB_SYM *SYMS = IREP->SYMS;
  MRB_CODE INSN;
  INT AI = MRB_GC_ARENA_SAVE(MRB);
  STRUCT MRB_JMPBUF *PREV_JMP = MRB->JMP;
  STRUCT MRB_JMPBUF C_JMP;
  UINT32_T A;
  UINT16_T B;
  UINT16_T C;
  MRB_SYM MID;
  CONST STRUCT MRB_IREP_CATCH_HANDLER *CH;

#IFDEF DIRECT_THREADED
  STATIC CONST VOID * CONST OPTABLE[] = {
#DEFINE OPCODE(X,_) &&L_OP_ ## X,
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
  };
#ENDIF

  MRB_BOOL EXC_CATCHED = FALSE;
RETRY_TRY_BLOCK:

  MRB_TRY(&C_JMP) {

  IF (EXC_CATCHED) {
    EXC_CATCHED = FALSE;
    MRB_GC_ARENA_RESTORE(MRB, AI);
    IF (MRB->EXC && MRB->EXC->TT == MRB_TT_BREAK)
      GOTO L_BREAK;
    GOTO L_RAISE;
  }
  MRB->JMP = &C_JMP;
  MRB_VM_CI_PROC_SET(MRB->C->CI, PROC);

#DEFINE REGS (MRB->C->CI->STACK)
  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* DO NOTHING */
      NEXT;
    }

    CASE(OP_MOVE, BB) {
      REGS[A] = REGS[B];
      NEXT;
    }

    CASE(OP_LOADL, BB) {
      SWITCH (POOL[B].TT) {   /* NUMBER */
      CASE IREP_TT_INT32:
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I32);
        BREAK;
      CASE IREP_TT_INT64:
#IF DEFINED(MRB_INT64)
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
        BREAK;
#ELSE
#IF DEFINED(MRB_64BIT)
        IF (INT32_MIN <= POOL[B].U.I64 && POOL[B].U.I64 <= INT32_MAX) {
          REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
          BREAK;
        }
#ENDIF
        GOTO L_INT_OVERFLOW;
#ENDIF
      CASE IREP_TT_BIGINT:
        GOTO L_INT_OVERFLOW;
#IFNDEF MRB_NO_FLOAT
      CASE IREP_TT_FLOAT:
        REGS[A] = MRB_FLOAT_VALUE(MRB, POOL[B].U.F);
        BREAK;
#ENDIF
      DEFAULT:
        /* SHOULD NOT HAPPEN (TT:STRING) */
        REGS[A] = MRB_NIL_VALUE();
        BREAK;
      }
      NEXT;
    }

    CASE(OP_LOADI, BB) {
      SET_FIXNUM_VALUE(REGS[A], B);
      NEXT;
    }

    CASE(OP_LOADINEG, BB) {
      SET_FIXNUM_VALUE(REGS[A], -B);
      NEXT;
    }

    CASE(OP_LOADI__1,B) GOTO L_LOADI;
    CASE(OP_LOADI_0,B) GOTO L_LOADI;
    CASE(OP_LOADI_1,B) GOTO L_LOADI;
    CASE(OP_LOADI_2,B) GOTO L_LOADI;
    CASE(OP_LOADI_3,B) GOTO L_LOADI;
    CASE(OP_LOADI_4,B) GOTO L_LOADI;
    CASE(OP_LOADI_5,B) GOTO L_LOADI;
    CASE(OP_LOADI_6,B) GOTO L_LOADI;
    CASE(OP_LOADI_7, B) {
    L_LOADI:
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)INSN - (MRB_INT)OP_LOADI_0);
      NEXT;
    }

    CASE(OP_LOADI16, BS) {
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)(INT16_T)B);
      NEXT;
    }

    CASE(OP_LOADI32, BSS) {
      SET_INT_VALUE(MRB, REGS[A], (INT32_T)(((UINT32_T)B<<16)+C));
      NEXT;
    }

    CASE(OP_LOADSYM, BB) {
      SET_SYM_VALUE(REGS[A], SYMS[B]);
      NEXT;
    }

    CASE(OP_LOADNIL, B) {
      SET_NIL_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADSELF, B) {
      REGS[A] = REGS[0];
      NEXT;
    }

    CASE(OP_LOADT, B) {
      SET_TRUE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADF, B) {
      SET_FALSE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_GETGV, BB) {
      MRB_VALUE VAL = MRB_GV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETGV, BB) {
      MRB_GV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETSV, BB) {
      MRB_VALUE VAL = MRB_VM_SPECIAL_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETSV, BB) {
      MRB_VM_SPECIAL_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIV, BB) {
      REGS[A] = MRB_IV_GET(MRB, REGS[0], SYMS[B]);
      NEXT;
    }

    CASE(OP_SETIV, BB) {
      MRB_IV_SET(MRB, REGS[0], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETCV, BB) {
      MRB_VALUE VAL;
      VAL = MRB_VM_CV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETCV, BB) {
      MRB_VM_CV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIDX, B) {
      MRB_VALUE VA = REGS[A], VB = REGS[A+1];
      SWITCH (MRB_TYPE(VA)) {
      CASE MRB_TT_ARRAY:
        IF (!MRB_INTEGER_P(VB)) GOTO GETIDX_FALLBACK;
        REGS[A] = MRB_ARY_ENTRY(VA, MRB_INTEGER(VB));
        BREAK;
      CASE MRB_TT_HASH:
        VA = MRB_HASH_GET(MRB, VA, VB);
        REGS[A] = VA;
        BREAK;
      CASE MRB_TT_STRING:
        SWITCH (MRB_TYPE(VB)) {
        CASE MRB_TT_INTEGER:
        CASE MRB_TT_STRING:
        CASE MRB_TT_RANGE:
          VA = MRB_STR_AREF(MRB, VA, VB, MRB_UNDEF_VALUE());
          REGS[A] = VA;
          BREAK;
        DEFAULT:
          GOTO GETIDX_FALLBACK;
        }
        BREAK;
      DEFAULT:
      GETIDX_FALLBACK:
        MID = MRB_OPSYM(AREF);
        GOTO L_SEND_SYM;
      }
      NEXT;
    }

    CASE(OP_SETIDX, B) {
      C = 2;
      MID = MRB_OPSYM(ASET);
      SET_NIL_VALUE(REGS[A+3]);
      GOTO L_SENDB_SYM;
    }

    CASE(OP_GETCONST, BB) {
      MRB_VALUE V = MRB_VM_CONST_GET(MRB, SYMS[B]);
      REGS[A] = V;
      NEXT;
    }

    CASE(OP_SETCONST, BB) {
      MRB_VM_CONST_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETMCNST, BB) {
      MRB_VALUE V = MRB_CONST_GET(MRB, REGS[A], SYMS[B]);
      REGS[A] = V;
      NEXT;
    }

    CASE(OP_SETMCNST, BB) {
      MRB_CONST_SET(MRB, REGS[A+1], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETUPVAR, BBB) {
      MRB_VALUE *REGS_A = REGS + A;
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E && B < MRB_ENV_LEN(E)) {
        *REGS_A = E->STACK[B];
      }
      ELSE {
        *REGS_A = MRB_NIL_VALUE();
      }
      NEXT;
    }

    CASE(OP_SETUPVAR, BBB) {
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E) {
        MRB_VALUE *REGS_A = REGS + A;

        IF (B < MRB_ENV_LEN(E)) {
          E->STACK[B] = *REGS_A;
          MRB_WRITE_BARRIER(MRB, (STRUCT RBASIC*)E);
        }
      }
      NEXT;
    }

    CASE(OP_JMP, S) {
      PC += (INT16_T)A;
      JUMP;
    }
    CASE(OP_JMPIF, BS) {
      IF (MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNOT, BS) {
      IF (!MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNIL, BS) {
      IF (MRB_NIL_P(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }

    CASE(OP_JMPUW, S) {
      A = (UINT32_T)((PC - IREP->ISEQ) + (INT16_T)A);
      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {
        STRUCT RBREAK *BRK = (STRUCT RBREAK*)MRB->EXC;
        MRB_VALUE TARGET = MRB_BREAK_VALUE_GET(BRK);
        MRB_ASSERT(MRB_INTEGER_P(TARGET));
        A = (UINT32_T)MRB_INTEGER(TARGET);
        MRB_ASSERT(A >= 0 && A < IREP->ILEN);
      }
      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {
        CH = CATCH_HANDLER_FIND(MRB, MRB->C->CI, PC, MRB_CATCH_FILTER_ENSURE);
        IF (CH) {
          /* AVOIDING A JUMP FROM A CATCH HANDLER INTO THE SAME HANDLER */
          IF (A < MRB_IREP_CATCH_HANDLER_UNPACK(CH->BEGIN) || A >= MRB_IREP_CATCH_HANDLER_UNPACK(CH->END)) {
            THROW_TAGGED_BREAK(MRB, RBREAK_TAG_JUMP, PROC, MRB_FIXNUM_VALUE(A));
          }
        }
      }
      CHECKPOINT_END(RBREAK_TAG_JUMP);

      MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
      PC = IREP->ISEQ + A;
      JUMP;
    }

    CASE(OP_EXCEPT, B) {
      MRB_VALUE EXC;

      IF (MRB->EXC == NULL) {
        EXC = MRB_NIL_VALUE();
      }
      ELSE {
        SWITCH (MRB->EXC->TT) {
        CASE MRB_TT_BREAK:
        CASE MRB_TT_EXCEPTION:
          EXC = MRB_OBJ_VALUE(MRB->EXC);
          BREAK;
        DEFAULT:
          MRB_ASSERT(!"BAD MRB_TYPE");
          EXC = MRB_NIL_VALUE();
          BREAK;
        }
        MRB->EXC = NULL;
      }
      REGS[A] = EXC;
      NEXT;
    }
    CASE(OP_RESCUE, BB) {
      MRB_VALUE EXC = REGS[A];  /* EXC ON STACK */
      MRB_VALUE E = REGS[B];
      STRUCT RCLASS *EC;

      SWITCH (MRB_TYPE(E)) {
      CASE MRB_TT_CLASS:
      CASE MRB_TT_MODULE:
        BREAK;
      DEFAULT:
        {
          MRB_VALUE EXC;

          EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                    "CLASS OR MODULE REQUIRED FOR RESCUE CLAUSE");
          MRB_EXC_SET(MRB, EXC);
          GOTO L_RAISE;
        }
      }
      EC = MRB_CLASS_PTR(E);
      REGS[B] = MRB_BOOL_VALUE(MRB_OBJ_IS_KIND_OF(MRB, EXC, EC));
      NEXT;
    }

    CASE(OP_RAISEIF, B) {
      MRB_VALUE EXC = REGS[A];
      IF (MRB_BREAK_P(EXC)) {
        MRB->EXC = MRB_OBJ_PTR(EXC);
        GOTO L_BREAK;
      }
      MRB_EXC_SET(MRB, EXC);
      IF (MRB->EXC) {
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_SSEND, BBB) {
      REGS[A] = REGS[0];
      INSN = OP_SEND;
    }
    GOTO L_SENDB;

    CASE(OP_SSENDB, BBB) {
      REGS[A] = REGS[0];
    }
    GOTO L_SENDB;

    CASE(OP_SEND, BBB)
    GOTO L_SENDB;

    L_SEND_SYM:
    C = 1;
    /* PUSH NIL AFTER ARGUMENTS */
    SET_NIL_VALUE(REGS[A+2]);
    GOTO L_SENDB_SYM;

    CASE(OP_SENDB, BBB)
    L_SENDB:
    MID = SYMS[B];
    L_SENDB_SYM:
    {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_VALUE RECV, BLK;

      ARGUMENT_NORMALIZE(A, &C, INSN);

      RECV = REGS[A];
      CLS = MRB_CLASS(MRB, RECV);
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &C, BLK, 0);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, C);

      IF (MRB_METHOD_CFUNC_P(M)) {
        IF (MRB_METHOD_PROC_P(M)) {
          STRUCT RPROC *P = MRB_METHOD_PROC(M);

          MRB_VM_CI_PROC_SET(CI, P);
          RECV = P->BODY.FUNC(MRB, RECV);
        }
        ELSE {
          IF (MRB_METHOD_NOARG_P(M)) {
            CHECK_METHOD_NOARG(MRB, CI);
          }
          RECV = MRB_METHOD_FUNC(M)(MRB, RECV);
        }
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);
          IF (P && !MRB_PROC_STRICT_P(P) && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
        IF (!CI->U.TARGET_CLASS) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN RECV;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        CI->STACK[0] = RECV;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
    }
    JUMP;

    CASE(OP_CALL, Z) {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV = CI->STACK[0];
      STRUCT RPROC *M = MRB_PROC_PTR(RECV);

      /* REPLACE CALLINFO */
      CI->U.TARGET_CLASS = MRB_PROC_TARGET_CLASS(M);
      MRB_VM_CI_PROC_SET(CI, M);
      IF (MRB_PROC_ENV_P(M)) {
        CI->MID = MRB_PROC_ENV(M)->MID;
      }

      /* PREPARE STACK */
      IF (MRB_PROC_CFUNC_P(M)) {
        RECV = MRB_PROC_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
        CI[1].STACK[0] = RECV;
        IREP = MRB->C->CI->PROC->BODY.IREP;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        PROC = M;
        IREP = M->BODY.IREP;
        IF (!IREP) {
          MRB->C->CI->STACK[0] = MRB_NIL_VALUE();
          A = 0;
          C = OP_R_NORMAL;
          GOTO L_OP_RETURN_BODY;
        }
        MRB_INT NARGS = MRB_CI_BIDX(CI)+1;
        IF (NARGS < IREP->NREGS) {
          MRB_STACK_EXTEND(MRB, IREP->NREGS);
          STACK_CLEAR(REGS+NARGS, IREP->NREGS-NARGS);
        }
        IF (MRB_PROC_ENV_P(M)) {
          REGS[0] = MRB_PROC_ENV(M)->STACK[0];
        }
        PC = IREP->ISEQ;
      }
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      JUMP;
    }

    CASE(OP_SUPER, BB) {
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV, BLK;
      CONST STRUCT RPROC *P = CI->PROC;
      MRB_SYM MID = CI->MID;
      STRUCT RCLASS* TARGET_CLASS = MRB_PROC_TARGET_CLASS(P);

      IF (MRB_PROC_ENV_P(P) && P->E.ENV->MID && P->E.ENV->MID != MID) { /* ALIAS SUPPORT */
        MID = P->E.ENV->MID;    /* RESTORE OLD MID */
      }

      IF (MID == 0 || !TARGET_CLASS) {
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (TARGET_CLASS->FLAGS & MRB_FL_CLASS_IS_PREPENDED) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
      }
      ELSE IF (TARGET_CLASS->TT == MRB_TT_MODULE) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
        IF (TARGET_CLASS->TT != MRB_TT_ICLASS) {
          GOTO SUPER_TYPEERROR;
        }
      }
      RECV = REGS[0];
      IF (!MRB_OBJ_IS_KIND_OF(MRB, RECV, TARGET_CLASS)) {
      SUPER_TYPEERROR: ;
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                            "SELF HAS WRONG TYPE TO CALL SUPER IN THIS CONTEXT");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }

      ARGUMENT_NORMALIZE(A, &B, OP_SUPER);

      CLS = TARGET_CLASS->SUPER;
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &B, BLK, 1);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, B);

      /* PREPARE STACK */
      CI->STACK[0] = RECV;

      IF (MRB_METHOD_CFUNC_P(M)) {
        MRB_VALUE V;

        IF (MRB_METHOD_PROC_P(M)) {
          MRB_VM_CI_PROC_SET(CI, MRB_METHOD_PROC(M));
        }
        V = MRB_METHOD_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_RESTORE(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        MRB_ASSERT(!MRB_BREAK_P(V));
        IF (!MRB_VM_CI_TARGET_CLASS(CI)) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN V;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        MRB->C->CI->STACK[0] = V;
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
      JUMP;
    }

    CASE(OP_ARGARY, BS) {
      MRB_INT M1 = (B>>11)&0X3F;
      MRB_INT R  = (B>>10)&0X1;
      MRB_INT M2 = (B>>5)&0X1F;
      MRB_INT KD = (B>>4)&0X1;
      MRB_INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (MRB->C->CI->MID == 0 || MRB_VM_CI_TARGET_CLASS(MRB->C->CI) == NULL) {
        MRB_VALUE EXC;

      L_NOSUPER:
        EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E) GOTO L_NOSUPER;
        IF (MRB_ENV_LEN(E) <= M1+R+M2+1)
          GOTO L_NOSUPER;
        STACK = E->STACK + 1;
      }
      IF (R == 0) {
        REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, M1+M2, STACK);
      }
      ELSE {
        MRB_VALUE *PP = NULL;
        STRUCT RARRAY *REST;
        MRB_INT LEN = 0;

        IF (MRB_ARRAY_P(STACK[M1])) {
          STRUCT RARRAY *ARY = MRB_ARY_PTR(STACK[M1]);

          PP = ARY_PTR(ARY);
          LEN = ARY_LEN(ARY);
        }
        REGS[A] = MRB_ARY_NEW_CAPA(MRB, M1+LEN+M2);
        REST = MRB_ARY_PTR(REGS[A]);
        IF (M1 > 0) {
          STACK_COPY(ARY_PTR(REST), STACK, M1);
        }
        IF (LEN > 0) {
          STACK_COPY(ARY_PTR(REST)+M1, PP, LEN);
        }
        IF (M2 > 0) {
          STACK_COPY(ARY_PTR(REST)+M1+LEN, STACK+M1+1, M2);
        }
        ARY_SET_LEN(REST, M1+LEN+M2);
      }
      IF (KD) {
        REGS[A+1] = STACK[M1+R+M2];
        REGS[A+2] = STACK[M1+R+M2+1];
      }
      ELSE {
        REGS[A+1] = STACK[M1+R+M2];
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ENTER, W) {
      MRB_INT M1 = MRB_ASPEC_REQ(A);
      MRB_INT O  = MRB_ASPEC_OPT(A);
      MRB_INT R  = MRB_ASPEC_REST(A);
      MRB_INT M2 = MRB_ASPEC_POST(A);
      MRB_INT KD = (MRB_ASPEC_KEY(A) > 0 || MRB_ASPEC_KDICT(A))? 1 : 0;
      /* UNUSED
      INT B  = MRB_ASPEC_BLOCK(A);
      */
      MRB_INT CONST LEN = M1 + O + R + M2;

      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_INT ARGC = CI->N;
      MRB_VALUE *ARGV = REGS+1;
      MRB_VALUE * CONST ARGV0 = ARGV;
      MRB_INT CONST KW_POS = LEN + KD;    /* WHERE KWHASH SHOULD BE */
      MRB_INT CONST BLK_POS = KW_POS + 1; /* WHERE BLOCK SHOULD BE */
      MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];
      MRB_VALUE KDICT = MRB_NIL_VALUE();

      /* KEYWORD ARGUMENTS */
      IF (CI->NK > 0) {
        MRB_INT KIDX = MRB_CI_KIDX(CI);
        KDICT = REGS[KIDX];
        IF (!MRB_HASH_P(KDICT) || MRB_HASH_SIZE(MRB, KDICT) == 0) {
          KDICT = MRB_NIL_VALUE();
          CI->NK = 0;
        }
      }
      IF (!KD && !MRB_NIL_P(KDICT)) {
        IF (ARGC < 14) {
          CI->N++;
          ARGC++;    /* INCLUDE KDICT IN NORMAL ARGUMENTS */
        }
        ELSE IF (ARGC == 14) {
          /* PACK ARGUMENTS AND KDICT */
          REGS[1] = MRB_ARY_NEW_FROM_VALUES(MRB, ARGC+1, &REGS[1]);
          ARGC = CI->N = 15;
        }
        ELSE {/* ARGC == 15 */
          /* PUSH KDICT TO PACKED ARGUMENTS */
          MRB_ARY_PUSH(MRB, REGS[1], REGS[2]);
        }
        CI->NK = 0;
      }
      IF (KD && MRB_ASPEC_KEY(A) > 0 && MRB_HASH_P(KDICT)) {
        KDICT = MRB_HASH_DUP(MRB, KDICT);
      }

      /* ARGUMENTS IS PASSED WITH ARRAY */
      IF (ARGC == 15) {
        STRUCT RARRAY *ARY = MRB_ARY_PTR(REGS[1]);
        ARGV = ARY_PTR(ARY);
        ARGC = (INT)ARY_LEN(ARY);
        MRB_GC_PROTECT(MRB, REGS[1]);
      }

      /* STRICT ARGUMENT CHECK */
      IF (CI->PROC && MRB_PROC_STRICT_P(CI->PROC)) {
        IF (ARGC < M1 + M2 || (R == 0 && ARGC > LEN)) {
          ARGNUM_ERROR(MRB, M1+M2);
          GOTO L_RAISE;
        }
      }
      /* EXTRACT FIRST ARGUMENT ARRAY TO ARGUMENTS */
      ELSE IF (LEN > 1 && ARGC == 1 && MRB_ARRAY_P(ARGV[0])) {
        MRB_GC_PROTECT(MRB, ARGV[0]);
        ARGC = (INT)RARRAY_LEN(ARGV[0]);
        ARGV = RARRAY_PTR(ARGV[0]);
      }

      /* REST ARGUMENTS */
      MRB_VALUE REST = MRB_NIL_VALUE();
      IF (ARGC < LEN) {
        MRB_INT MLEN = M2;
        IF (ARGC < M1+M2) {
          MLEN = M1 < ARGC ? ARGC - M1 : 0;
        }

        /* COPY MANDATORY AND OPTIONAL ARGUMENTS */
        IF (ARGV0 != ARGV && ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, ARGC-MLEN); /* M1 + O */
        }
        IF (ARGC < M1) {
          STACK_CLEAR(&REGS[ARGC+1], M1-ARGC);
        }
        /* COPY POST MANDATORY ARGUMENTS */
        IF (MLEN) {
          VALUE_MOVE(&REGS[LEN-M2+1], &ARGV[ARGC-MLEN], MLEN);
        }
        IF (MLEN < M2) {
          STACK_CLEAR(&REGS[LEN-M2+MLEN+1], M2-MLEN);
        }
        /* INITIALIZE REST ARGUMENTS WITH EMPTY ARRAY */
        IF (R) {
          REST = MRB_ARY_NEW_CAPA(MRB, 0);
          REGS[M1+O+1] = REST;
        }
        /* SKIP INITIALIZER OF PASSED ARGUMENTS */
        IF (O > 0 && ARGC > M1+M2)
          PC += (ARGC - M1 - M2)*3;
      }
      ELSE {
        MRB_INT RNUM = 0;
        IF (ARGV0 != ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, M1+O);
        }
        IF (R) {
          RNUM = ARGC-M1-O-M2;
          REST = MRB_ARY_NEW_FROM_VALUES(MRB, RNUM, ARGV+M1+O);
          REGS[M1+O+1] = REST;
        }
        IF (M2 > 0 && ARGC-M2 > M1) {
          VALUE_MOVE(&REGS[M1+O+R+1], &ARGV[M1+O+RNUM], M2);
        }
        PC += O*3;
      }

      /* NEED TO BE UPDATE BLK FIRST TO PROTECT BLK FROM GC */
      REGS[BLK_POS] = BLK;              /* MOVE BLOCK */
      IF (KD) {
        IF (MRB_NIL_P(KDICT))
          KDICT = MRB_HASH_NEW_CAPA(MRB, 0);
        REGS[KW_POS] = KDICT;           /* SET KWHASH */
      }

      /* FORMAT ARGUMENTS FOR GENERATED CODE */
      MRB->C->CI->N = LEN;

      /* CLEAR LOCAL (BUT NON-ARGUMENT) VARIABLES */
      IF (IREP->NLOCALS-BLK_POS-1 > 0) {
        STACK_CLEAR(&REGS[BLK_POS+1], IREP->NLOCALS-BLK_POS-1);
      }
      JUMP;
    }

    CASE(OP_KARG, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT, V;

      IF (KIDX < 0 || !MRB_HASH_P(KDICT=REGS[KIDX]) || !MRB_HASH_KEY_P(MRB, KDICT, K)) {
        MRB_VALUE STR = MRB_FORMAT(MRB, "MISSING KEYWORD: %V", K);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      V = MRB_HASH_GET(MRB, KDICT, K);
      REGS[A] = V;
      MRB_HASH_DELETE_KEY(MRB, KDICT, K);
      NEXT;
    }

    CASE(OP_KEY_P, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;
      MRB_BOOL KEY_P = FALSE;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX])) {
        KEY_P = MRB_HASH_KEY_P(MRB, KDICT, K);
      }
      REGS[A] = MRB_BOOL_VALUE(KEY_P);
      NEXT;
    }

    CASE(OP_KEYEND, Z) {
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX]) && !MRB_HASH_EMPTY_P(MRB, KDICT)) {
        MRB_VALUE KEYS = MRB_HASH_KEYS(MRB, KDICT);
        MRB_VALUE KEY1 = RARRAY_PTR(KEYS)[0];
        MRB_VALUE STR = MRB_FORMAT(MRB, "UNKNOWN KEYWORD: %V", KEY1);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_BREAK, B) {
      C = OP_R_BREAK;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN_BLK, B) {
      C = OP_R_RETURN;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN, B)
    C = OP_R_NORMAL;
    L_RETURN:
    {
      MRB_CALLINFO *CI;

      CI = MRB->C->CI;
      IF (CI->MID) {
        MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];

        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);

          IF (!MRB_PROC_STRICT_P(P) &&
              CI > MRB->C->CIBASE && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
      }

      IF (MRB->EXC) {
      L_RAISE:
        CI = MRB->C->CI;
        IF (CI == MRB->C->CIBASE) {
          CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
          IF (CH == NULL) GOTO L_FTOP;
          GOTO L_CATCH;
        }
        WHILE ((CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL)) == NULL) {
          CI = CIPOP(MRB);
          IF (CI[1].CCI == CINFO_SKIP && PREV_JMP) {
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          PC = CI[0].PC;
          IF (CI == MRB->C->CIBASE) {
            CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
            IF (CH == NULL) {
            L_FTOP:             /* FIBER TOP */
              IF (MRB->C == MRB->ROOT_C) {
                MRB->C->CI->STACK = MRB->C->STBASE;
                GOTO L_STOP;
              }
              ELSE {
                STRUCT MRB_CONTEXT *C = MRB->C;

                C->STATUS = MRB_FIBER_TERMINATED;
                MRB->C = C->PREV;
                C->PREV = NULL;
                GOTO L_RAISE;
              }
            }
            BREAK;
          }
        }
      L_CATCH:
        IF (CH == NULL) GOTO L_STOP;
        IF (FALSE) {
        L_CATCH_TAGGED_BREAK: /* FROM THROW_TAGGED_BREAK() OR UNWIND_ENSURE() */
          CI = MRB->C->CI;
        }
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, IREP->NREGS);
        PC = IREP->ISEQ + MRB_IREP_CATCH_HANDLER_UNPACK(CH->TARGET);
      }
      ELSE {
        MRB_INT ACC;
        MRB_VALUE V;

        CI = MRB->C->CI;
        V = REGS[A];
        MRB_GC_PROTECT(MRB, V);
        SWITCH (C) {
        CASE OP_R_RETURN:
          /* FALL THROUGH TO OP_R_NORMAL OTHERWISE */
          IF (CI->CCI == CINFO_NONE && MRB_PROC_ENV_P(PROC) && !MRB_PROC_STRICT_P(PROC)) {
            CONST STRUCT RPROC *DST;
            MRB_CALLINFO *CIBASE;
            CIBASE = MRB->C->CIBASE;
            DST = TOP_PROC(MRB, PROC);

            IF (MRB_PROC_ENV_P(DST)) {
              STRUCT RENV *E = MRB_PROC_ENV(DST);

              IF (!MRB_ENV_ONSTACK_P(E) || (E->CXT && E->CXT != MRB->C)) {
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
            }
            /* CHECK JUMP DESTINATION */
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              IF (CI->CCI > CINFO_NONE) { /* JUMP CROSS C BOUNDARY */
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
              CI--;
            }
            IF (CI <= CIBASE) { /* NO JUMP DESTINATION */
              LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
              GOTO L_RAISE;
            }
            CI = MRB->C->CI;
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {
                CIBASE = MRB->C->CIBASE;
                DST = TOP_PROC(MRB, PROC);
              }
              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {
                UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_BLOCK, PROC, V);
              }
              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);
              CI = CIPOP(MRB);
              PC = CI->PC;
            }
            PROC = CI->PROC;
            MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
            BREAK;
          }
          /* FALLTHROUGH */
        CASE OP_R_NORMAL:
        NORMAL_RETURN:
          IF (CI == MRB->C->CIBASE) {
            STRUCT MRB_CONTEXT *C;
            C = MRB->C;

            IF (!C->PREV) { /* TOPLEVEL RETURN */
              REGS[IREP->NLOCALS] = V;
              GOTO CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);
            }
            IF (!C->VMEXEC && C->PREV->CI == C->PREV->CIBASE) {
              MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_FIBER_ERROR, "DOUBLE RESUME");
              MRB_EXC_SET(MRB, EXC);
              GOTO L_RAISE;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {
              C = MRB->C;
            }
            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_TOPLEVEL, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);
            /* AUTOMATIC YIELD AT THE END */
            C->STATUS = MRB_FIBER_TERMINATED;
            MRB->C = C->PREV;
            MRB->C->STATUS = MRB_FIBER_RUNNING;
            C->PREV = NULL;
            IF (C->VMEXEC) {
              MRB_GC_ARENA_RESTORE(MRB, AI);
              C->VMEXEC = FALSE;
              MRB->JMP = PREV_JMP;
              RETURN V;
            }
            CI = MRB->C->CI;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_RETURN);
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        CASE OP_R_BREAK:
          IF (MRB_PROC_STRICT_P(PROC)) GOTO NORMAL_RETURN;
          IF (MRB_PROC_ORPHAN_P(PROC)) {
            MRB_VALUE EXC;

          L_BREAK_ERROR:
            EXC = MRB_EXC_NEW_LIT(MRB, E_LOCALJUMP_ERROR,
                                      "BREAK FROM PROC-CLOSURE");
            MRB_EXC_SET(MRB, EXC);
            GOTO L_RAISE;
          }
          IF (!MRB_PROC_ENV_P(PROC) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(PROC))) {
            GOTO L_BREAK_ERROR;
          }
          ELSE {
            STRUCT RENV *E = MRB_PROC_ENV(PROC);

            IF (E->CXT != MRB->C) {
              GOTO L_BREAK_ERROR;
            }
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK);
          /* BREAK FROM FIBER BLOCK */
          IF (CI == MRB->C->CIBASE && CI->PC) {
            STRUCT MRB_CONTEXT *C = MRB->C;

            MRB->C = C->PREV;
            C->PREV = NULL;
            CI = MRB->C->CI;
          }
          IF (CI->CCI > CINFO_NONE) {
            CI = CIPOP(MRB);
            MRB_GC_ARENA_RESTORE(MRB, AI);
            MRB->C->VMEXEC = FALSE;
            MRB->EXC = (STRUCT ROBJECT*)BREAK_NEW(MRB, RBREAK_TAG_BREAK, PROC, V);
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          IF (FALSE) {
            STRUCT RBREAK *BRK;

          L_BREAK:
            BRK = (STRUCT RBREAK*)MRB->EXC;
            PROC = MRB_BREAK_PROC_GET(BRK);
            V = MRB_BREAK_VALUE_GET(BRK);
            CI = MRB->C->CI;

            SWITCH (MRB_BREAK_TAG_GET(BRK)) {
#DEFINE DISPATCH_CHECKPOINTS(N, I) CASE N: GOTO CHECKPOINT_LABEL_MAKE(N);
              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)
#UNDEF DISPATCH_CHECKPOINTS
              DEFAULT:
                MRB_ASSERT(!"WRONG BREAK TAG");
            }
          }
          WHILE (MRB->C->CIBASE < CI && CI[-1].PROC != PROC->UPPER) {
            IF (CI[-1].CCI == CINFO_SKIP) {
              GOTO L_BREAK_ERROR;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {
              /* DO NOTHING */
            }
            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_UPPER, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);
            CI = CIPOP(MRB);
            PC = CI->PC;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_INTARGET, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);
          IF (CI == MRB->C->CIBASE) {
            GOTO L_BREAK_ERROR;
          }
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        DEFAULT:
          /* CANNOT HAPPEN */
          BREAK;
        }
        MRB_ASSERT(CI == MRB->C->CI);
        MRB_ASSERT(MRB->EXC == NULL);

        IF (MRB->C->VMEXEC && !MRB_VM_CI_TARGET_CLASS(CI)) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->C->VMEXEC = FALSE;
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        ACC = CI->CCI;
        CI = CIPOP(MRB);
        IF (ACC == CINFO_SKIP || ACC == CINFO_DIRECT) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        PC = CI->PC;
        DEBUG(FPRINTF(STDERR, "FROM :%S\N", MRB_SYM_NAME(MRB, CI->MID)));
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;

        CI[1].STACK[0] = V;
        MRB_GC_ARENA_RESTORE(MRB, AI);
      }
      JUMP;
    }

    CASE(OP_BLKPUSH, BS) {
      INT M1 = (B>>11)&0X3F;
      INT R  = (B>>10)&0X1;
      INT M2 = (B>>5)&0X1F;
      INT KD = (B>>4)&0X1;
      INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E || (!MRB_ENV_ONSTACK_P(E) && E->MID == 0) ||
            MRB_ENV_LEN(E) <= M1+R+M2+1) {
          LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
          GOTO L_RAISE;
        }
        STACK = E->STACK + 1;
      }
      IF (MRB_NIL_P(STACK[M1+R+M2+KD])) {
        LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
        GOTO L_RAISE;
      }
      REGS[A] = STACK[M1+R+M2+KD];
      NEXT;
    }

  L_INT_OVERFLOW:
    {
      MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_RANGE_ERROR, "INTEGER OVERFLOW");
      MRB_EXC_SET(MRB, EXC);
    }
    GOTO L_RAISE;

#DEFINE TYPES2(A,B) ((((UINT16_T)(A))<<8)|(((UINT16_T)(B))&0XFF))
#DEFINE OP_MATH(OP_NAME)                                                    \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {                  \
    OP_MATH_CASE_INTEGER(OP_NAME);                                          \
    OP_MATH_CASE_FLOAT(OP_NAME, INTEGER, FLOAT);                            \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  INTEGER);                           \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  FLOAT);                             \
    OP_MATH_CASE_STRING_##OP_NAME();                                        \
    DEFAULT:                                                                \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATH_CASE_INTEGER(OP_NAME)                                       \
  CASE TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = MRB_INTEGER(REGS[A+1]), Z;      \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z))                           \
        OP_MATH_OVERFLOW_INT();                                             \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2) (VOID)0
#ELSE
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2)                                     \
  CASE TYPES2(OP_MATH_TT_##T1, OP_MATH_TT_##T2):                                \
    {                                                                           \
      MRB_FLOAT Z = MRB_##T1(REGS[A]) OP_MATH_OP_##OP_NAME MRB_##T2(REGS[A+1]); \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                         \
    }                                                                           \
    BREAK
#ENDIF
#DEFINE OP_MATH_OVERFLOW_INT() GOTO L_INT_OVERFLOW
#DEFINE OP_MATH_CASE_STRING_ADD()                                           \
  CASE TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \
    REGS[A] = MRB_STR_PLUS(MRB, REGS[A], REGS[A+1]);                        \
    MRB_GC_ARENA_RESTORE(MRB, AI);                                          \
    BREAK
#DEFINE OP_MATH_CASE_STRING_SUB() (VOID)0
#DEFINE OP_MATH_CASE_STRING_MUL() (VOID)0
#DEFINE OP_MATH_OP_ADD +
#DEFINE OP_MATH_OP_SUB -
#DEFINE OP_MATH_OP_MUL *
#DEFINE OP_MATH_TT_INTEGER MRB_TT_INTEGER
#DEFINE OP_MATH_TT_FLOAT   MRB_TT_FLOAT

    CASE(OP_ADD, B) {
      OP_MATH(ADD);
    }

    CASE(OP_SUB, B) {
      OP_MATH(SUB);
    }

    CASE(OP_MUL, B) {
      OP_MATH(MUL);
    }

    CASE(OP_DIV, B) {
#IFNDEF MRB_NO_FLOAT
      MRB_FLOAT X, Y, F;
#ENDIF

      /* NEED TO CHECK IF OP IS OVERRIDDEN */
      SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):
        {
          MRB_INT X = MRB_INTEGER(REGS[A]);
          MRB_INT Y = MRB_INTEGER(REGS[A+1]);
          MRB_INT DIV = MRB_DIV_INT(MRB, X, Y);
          SET_INT_VALUE(MRB, REGS[A], DIV);
        }
        NEXT;
#IFNDEF MRB_NO_FLOAT
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):
        X = (MRB_FLOAT)MRB_INTEGER(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):
        X = MRB_FLOAT(REGS[A]);
        Y = (MRB_FLOAT)MRB_INTEGER(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
        X = MRB_FLOAT(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
#ENDIF
      DEFAULT:
        MID = MRB_OPSYM(DIV);
        GOTO L_SEND_SYM;
      }

#IFNDEF MRB_NO_FLOAT
      F = MRB_DIV_FLOAT(X, Y);
      SET_FLOAT_VALUE(MRB, REGS[A], F);
#ENDIF
      NEXT;
    }

#DEFINE OP_MATHI(OP_NAME)                                                   \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (MRB_TYPE(REGS[A])) {                                              \
    OP_MATHI_CASE_INTEGER(OP_NAME);                                         \
    OP_MATHI_CASE_FLOAT(OP_NAME);                                           \
    DEFAULT:                                                                \
      SET_INT_VALUE(MRB,REGS[A+1], B);                                      \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATHI_CASE_INTEGER(OP_NAME)                                      \
  CASE MRB_TT_INTEGER:                                                      \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = (MRB_INT)B, Z;                  \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z))                           \
        OP_MATH_OVERFLOW_INT();                                             \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME) (VOID)0
#ELSE
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME)                                        \
  CASE MRB_TT_FLOAT:                                                        \
    {                                                                       \
      MRB_FLOAT Z = MRB_FLOAT(REGS[A]) OP_MATH_OP_##OP_NAME B;              \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                     \
    }                                                                       \
    BREAK
#ENDIF

    CASE(OP_ADDI, BB) {
      OP_MATHI(ADD);
    }

    CASE(OP_SUBI, BB) {
      OP_MATHI(SUB);
    }

#DEFINE OP_CMP_BODY(OP,V1,V2) (V1(REGS[A]) OP V2(REGS[A+1]))

#IFDEF MRB_NO_FLOAT
#DEFINE OP_CMP(OP,SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ELSE
#DEFINE OP_CMP(OP, SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FLOAT);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FLOAT);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ENDIF

    CASE(OP_EQ, B) {
      IF (MRB_OBJ_EQ(MRB, REGS[A], REGS[A+1])) {
        SET_TRUE_VALUE(REGS[A]);
      }
      ELSE {
        OP_CMP(==,EQ);
      }
      NEXT;
    }

    CASE(OP_LT, B) {
      OP_CMP(<,LT);
      NEXT;
    }

    CASE(OP_LE, B) {
      OP_CMP(<=,LE);
      NEXT;
    }

    CASE(OP_GT, B) {
      OP_CMP(>,GT);
      NEXT;
    }

    CASE(OP_GE, B) {
      OP_CMP(>=,GE);
      NEXT;
    }

    CASE(OP_ARRAY, BB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, B, &REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_ARRAY2, BBB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, C, &REGS[B]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYCAT, B) {
      MRB_VALUE SPLAT = MRB_ARY_SPLAT(MRB, REGS[A+1]);
      IF (MRB_NIL_P(REGS[A])) {
        REGS[A] = SPLAT;
      }
      ELSE {
        MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
        MRB_ARY_CONCAT(MRB, REGS[A], SPLAT);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYPUSH, BB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      FOR (MRB_INT I=0; I<B; I++) {
        MRB_ARY_PUSH(MRB, REGS[A], REGS[A+I+1]);
      }
      NEXT;
    }

    CASE(OP_ARYDUP, B) {
      MRB_VALUE ARY = REGS[A];
      IF (MRB_ARRAY_P(ARY)) {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, RARRAY_LEN(ARY), RARRAY_PTR(ARY));
      }
      ELSE {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &ARY);
      }
      REGS[A] = ARY;
      NEXT;
    }

    CASE(OP_AREF, BBB) {
      MRB_VALUE V = REGS[B];

      IF (!MRB_ARRAY_P(V)) {
        IF (C == 0) {
          REGS[A] = V;
        }
        ELSE {
          SET_NIL_VALUE(REGS[A]);
        }
      }
      ELSE {
        V = MRB_ARY_REF(MRB, V, C);
        REGS[A] = V;
      }
      NEXT;
    }

    CASE(OP_ASET, BBB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      MRB_ARY_SET(MRB, REGS[B], C, REGS[A]);
      NEXT;
    }

    CASE(OP_APOST, BBB) {
      MRB_VALUE V = REGS[A];
      INT PRE  = B;
      INT POST = C;
      STRUCT RARRAY *ARY;
      INT LEN, IDX;

      IF (!MRB_ARRAY_P(V)) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &REGS[A]);
      }
      ARY = MRB_ARY_PTR(V);
      LEN = (INT)ARY_LEN(ARY);
      IF (LEN > PRE + POST) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, LEN - PRE - POST, ARY_PTR(ARY)+PRE);
        REGS[A++] = V;
        WHILE (POST--) {
          REGS[A++] = ARY_PTR(ARY)[LEN-POST-1];
        }
      }
      ELSE {
        V = MRB_ARY_NEW_CAPA(MRB, 0);
        REGS[A++] = V;
        FOR (IDX=0; IDX+PRE<LEN; IDX++) {
          REGS[A+IDX] = ARY_PTR(ARY)[PRE+IDX];
        }
        WHILE (IDX < POST) {
          SET_NIL_VALUE(REGS[A+IDX]);
          IDX++;
        }
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_INTERN, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_SYM SYM = MRB_INTERN_STR(MRB, REGS[A]);
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_SYMBOL, BB) {
      SIZE_T LEN;
      MRB_SYM SYM;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        SYM = MRB_INTERN_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        SYM  = MRB_INTERN(MRB, POOL[B].U.STR, LEN);
      }
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_STRING, BB) {
      MRB_INT LEN;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        REGS[A] = MRB_STR_NEW_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        REGS[A] = MRB_STR_NEW(MRB, POOL[B].U.STR, LEN);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_STRCAT, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_STR_CONCAT(MRB, REGS[A], REGS[A+1]);
      NEXT;
    }

    CASE(OP_HASH, BB) {
      MRB_VALUE HASH = MRB_HASH_NEW_CAPA(MRB, B);
      INT I;
      INT LIM = A+B*2;

      FOR (I=A; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      REGS[A] = HASH;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_HASHADD, BB) {
      MRB_VALUE HASH;
      INT I;
      INT LIM = A+B*2+1;

      HASH = REGS[A];
      MRB_ENSURE_HASH_TYPE(MRB, HASH);
      FOR (I=A+1; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_HASHCAT, B) {
      MRB_VALUE HASH = REGS[A];

      MRB_ASSERT(MRB_HASH_P(HASH));
      MRB_HASH_MERGE(MRB, HASH, REGS[A+1]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_LAMBDA, BB)
    C = OP_L_LAMBDA;
    L_MAKE_LAMBDA:
    {
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      IF (C & OP_L_CAPTURE) {
        P = MRB_CLOSURE_NEW(MRB, NIREP);
      }
      ELSE {
        P = MRB_PROC_NEW(MRB, NIREP);
        P->FLAGS |= MRB_PROC_SCOPE;
      }
      IF (C & OP_L_STRICT) P->FLAGS |= MRB_PROC_STRICT;
      REGS[A] = MRB_OBJ_VALUE(P);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_BLOCK, BB) {
      C = OP_L_BLOCK;
      GOTO L_MAKE_LAMBDA;
    }
    CASE(OP_METHOD, BB) {
      C = OP_L_METHOD;
      GOTO L_MAKE_LAMBDA;
    }

    CASE(OP_RANGE_INC, B) {
      MRB_VALUE V = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], FALSE);
      REGS[A] = V;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      MRB_VALUE V = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], TRUE);
      REGS[A] = V;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_OCLASS, B) {
      REGS[A] = MRB_OBJ_VALUE(MRB->OBJECT_CLASS);
      NEXT;
    }

    CASE(OP_CLASS, BB) {
      STRUCT RCLASS *C = 0, *BASECLASS;
      MRB_VALUE BASE, SUPER;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      SUPER = REGS[A+1];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      C = MRB_VM_DEFINE_CLASS(MRB, BASE, SUPER, ID);
      REGS[A] = MRB_OBJ_VALUE(C);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_MODULE, BB) {
      STRUCT RCLASS *CLS = 0, *BASECLASS;
      MRB_VALUE BASE;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      CLS = MRB_VM_DEFINE_MODULE(MRB, BASE, ID);
      REGS[A] = MRB_OBJ_VALUE(CLS);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_EXEC, BB)
    {
      MRB_VALUE RECV = REGS[A];
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      /* PREPARE CLOSURE */
      P = MRB_PROC_NEW(MRB, NIREP);
      P->C = NULL;
      MRB_FIELD_WRITE_BARRIER(MRB, (STRUCT RBASIC*)P, (STRUCT RBASIC*)PROC);
      MRB_PROC_SET_TARGET_CLASS(P, MRB_CLASS_PTR(RECV));
      P->FLAGS |= MRB_PROC_SCOPE;

      /* PREPARE CALL STACK */
      CIPUSH(MRB, A, 0, MRB_CLASS_PTR(RECV), P, 0, 0);

      IREP = P->BODY.IREP;
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      MRB_STACK_EXTEND(MRB, IREP->NREGS);
      STACK_CLEAR(REGS+1, IREP->NREGS-1);
      PC = IREP->ISEQ;
      JUMP;
    }

    CASE(OP_DEF, BB) {
      STRUCT RCLASS *TARGET = MRB_CLASS_PTR(REGS[A]);
      STRUCT RPROC *P = MRB_PROC_PTR(REGS[A+1]);
      MRB_METHOD_T M;
      MRB_SYM MID = SYMS[B];

      MRB_METHOD_FROM_PROC(M, P);
      MRB_DEFINE_METHOD_RAW(MRB, TARGET, MID, M);
      MRB_METHOD_ADDED(MRB, TARGET, MID);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      REGS[A] = MRB_SYMBOL_VALUE(MID);
      NEXT;
    }

    CASE(OP_SCLASS, B) {
      REGS[A] = MRB_SINGLETON_CLASS(MRB, REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_TCLASS, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);
      IF (!TARGET) GOTO L_RAISE;
      REGS[A] = MRB_OBJ_VALUE(TARGET);
      NEXT;
    }

    CASE(OP_ALIAS, BB) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_ALIAS_METHOD(MRB, TARGET, SYMS[A], SYMS[B]);
      MRB_METHOD_ADDED(MRB, TARGET, SYMS[A]);
      NEXT;
    }
    CASE(OP_UNDEF, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_UNDEF_METHOD_ID(MRB, TARGET, SYMS[A]);
      NEXT;
    }

    CASE(OP_DEBUG, Z) {
      FETCH_BBB();
#IFDEF MRB_USE_DEBUG_HOOK
      MRB->DEBUG_OP_HOOK(MRB, IREP, PC, REGS);
#ELSE
#IFNDEF MRB_NO_STDIO
      PRINTF("OP_DEBUG %D %D %D\N", A, B, C);
#ELSE
      ABORT();
#ENDIF
#ENDIF
      NEXT;
    }

    CASE(OP_ERR, B) {
      SIZE_T LEN = POOL[A].TT >> 2;
      MRB_VALUE EXC;

      MRB_ASSERT((POOL[A].TT&IREP_TT_NFLAG)==0);
      EXC = MRB_EXC_NEW(MRB, E_LOCALJUMP_ERROR, POOL[A].U.STR, LEN);
      MRB_EXC_SET(MRB, EXC);
      GOTO L_RAISE;
    }

    CASE(OP_EXT1, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _1(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT2, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _2(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT3, Z) {
      UINT8_T INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _3(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }

    CASE(OP_STOP, Z) {
      /*        STOP VM */
      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {
        /* DO NOTHING */
      }
      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {
        UNWIND_ENSURE(MRB, MRB->C->CI, PC, RBREAK_TAG_STOP, PROC, MRB_NIL_VALUE());
      }
      CHECKPOINT_END(RBREAK_TAG_STOP);
    L_STOP:
      MRB->JMP = PREV_JMP;
      IF (MRB->EXC) {
        MRB_ASSERT(MRB->EXC->TT == MRB_TT_EXCEPTION);
        RETURN MRB_OBJ_VALUE(MRB->EXC);
      }
      RETURN REGS[IREP->NLOCALS];
    }
  }
  END_DISPATCH;
#UNDEF REGS
  }
  MRB_CATCH(&C_JMP) {
    MRB_CALLINFO *CI = MRB->C->CI;
    WHILE (CI > MRB->C->CIBASE && CI->CCI == CINFO_DIRECT) {
      CI = CIPOP(MRB);
    }
    EXC_CATCHED = TRUE;
    PC = CI->PC;
    GOTO RETRY_TRY_BLOCK;
  }
  MRB_END_EXC(&C_JMP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 339724_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CHAR * RV_ALLOC(INT I) {
	INT J, K, *R;

	J = SIZEOF(ULONG);
	FOR(K = 0;
			SIZEOF(BIGINT) - SIZEOF(ULONG) - SIZEOF(INT) + J <= I;
			J <<= 1) {
		K++;
	}
	R = (INT*)BALLOC(K);
	*R = K;
	RETURN (CHAR *)(R+1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 291848_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT RTRS_RDMA_ROUTE_RESOLVED(STRUCT RTRS_CLT_CON *CON)
{
	STRUCT RTRS_CLT_PATH *CLT_PATH = TO_CLT_PATH(CON->C.PATH);
	STRUCT RTRS_CLT_SESS *CLT = CLT_PATH->CLT;
	STRUCT RTRS_MSG_CONN_REQ MSG;
	STRUCT RDMA_CONN_PARAM PARAM;

	INT ERR;

	PARAM = (STRUCT RDMA_CONN_PARAM) {
		.RETRY_COUNT = 7,
		.RNR_RETRY_COUNT = 7,
		.PRIVATE_DATA = &MSG,
		.PRIVATE_DATA_LEN = SIZEOF(MSG),
	};

	MSG = (STRUCT RTRS_MSG_CONN_REQ) {
		.MAGIC = CPU_TO_LE16(RTRS_MAGIC),
		.VERSION = CPU_TO_LE16(RTRS_PROTO_VER),
		.CID = CPU_TO_LE16(CON->C.CID),
		.CID_NUM = CPU_TO_LE16(CLT_PATH->S.CON_NUM),
		.RECON_CNT = CPU_TO_LE16(CLT_PATH->S.RECON_CNT),
	};
	MSG.FIRST_CONN = CLT_PATH->FOR_NEW_CLT ? FIRST_CONN : 0;
	UUID_COPY(&MSG.SESS_UUID, &CLT_PATH->S.UUID);
	UUID_COPY(&MSG.PATHS_UUID, &CLT->PATHS_UUID);

	ERR = RDMA_CONNECT_LOCKED(CON->C.CM_ID, &PARAM);
	IF (ERR)
		RTRS_ERR(CLT, "RDMA_CONNECT_LOCKED(): %D\N", ERR);

	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 491910_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SSIZE_T FUSE_PERFORM_WRITE(STRUCT FILE *FILE,
				  STRUCT ADDRESS_SPACE *MAPPING,
				  STRUCT IOV_ITER *II, LOFF_T POS)
{
	STRUCT INODE *INODE = MAPPING->HOST;
	STRUCT FUSE_CONN *FC = GET_FUSE_CONN(INODE);
	INT ERR = 0;
	SSIZE_T RES = 0;

	IF (IS_BAD_INODE(INODE))
		RETURN -EIO;

	DO {
		STRUCT FUSE_REQ *REQ;
		SSIZE_T COUNT;

		REQ = FUSE_GET_REQ(FC);
		IF (IS_ERR(REQ)) {
			ERR = PTR_ERR(REQ);
			BREAK;
		}

		COUNT = FUSE_FILL_WRITE_PAGES(REQ, MAPPING, II, POS);
		IF (COUNT <= 0) {
			ERR = COUNT;
		} ELSE {
			SIZE_T NUM_WRITTEN;

			NUM_WRITTEN = FUSE_SEND_WRITE_PAGES(REQ, FILE, INODE,
							    POS, COUNT);
			ERR = REQ->OUT.H.ERROR;
			IF (!ERR) {
				RES += NUM_WRITTEN;
				POS += NUM_WRITTEN;

				/* BREAK OUT OF THE LOOP ON SHORT WRITE */
				IF (NUM_WRITTEN != COUNT)
					ERR = -EIO;
			}
		}
		FUSE_PUT_REQUEST(FC, REQ);
	} WHILE (!ERR && IOV_ITER_COUNT(II));

	IF (RES > 0)
		FUSE_WRITE_UPDATE_SIZE(INODE, POS);

	FUSE_INVALIDATE_ATTR(INODE);

	RETURN RES > 0 ? RES : ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225034_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PQCONNECTDB(CONST CHAR *CONNINFO)
{
	PGCONN	   *CONN = PQCONNECTSTART(CONNINFO);

	IF (CONN && CONN->STATUS != CONNECTION_BAD)
		(VOID) CONNECTDBCOMPLETE(CONN);

	RETURN CONN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359299_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (NO_SYNCHRONIZATION,
       NO_SYNCHRONIZATION_CMD,
       "NO SYNCHRONIZATION",
       NO_STR
       "PERFORM IGP SYNCHRONIZATION\N")
{
  RETURN CMD_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225652_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR RSSR_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	GF_RECEIVEDSSRCBOX *PTR = (GF_RECEIVEDSSRCBOX *)S;
	ISOM_DECREASE_SIZE(PTR, 4)
	PTR->SSRC = GF_BS_READ_U32(BS);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 409411_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TERM_APPEND_LINES(INT LINE_COUNT)
{
    OUT_STR(TGOTO((CHAR *)T_CAL, 0, LINE_COUNT));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 229151_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SIZE_T VIRTIO_SERIAL_GUEST_READY(VIRTIOSERIALPORT *PORT)
{
    VIRTIODEVICE *VDEV = VIRTIO_DEVICE(PORT->VSER);
    VIRTQUEUE *VQ = PORT->IVQ;
    UNSIGNED INT BYTES;

    IF (!VIRTIO_QUEUE_READY(VQ) ||
        !(VDEV->STATUS & VIRTIO_CONFIG_S_DRIVER_OK) ||
        VIRTIO_QUEUE_EMPTY(VQ)) {
        RETURN 0;
    }
    IF (USE_MULTIPORT(PORT->VSER) && !PORT->GUEST_CONNECTED) {
        RETURN 0;
    }
    VIRTQUEUE_GET_AVAIL_BYTES(VQ, &BYTES, NULL, 4096, 0);
    RETURN BYTES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207280_CWE-122.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
WIN_REDR_STATUS(WIN_T *WP, INT IGNORE_PUM UNUSED)
{
    INT		ROW;
    CHAR_U	*P;
    INT		LEN;
    INT		FILLCHAR;
    INT		ATTR;
    INT		THIS_RU_COL;
    STATIC INT  BUSY = FALSE;

    // IT'S POSSIBLE TO GET HERE RECURSIVELY WHEN 'STATUSLINE' (INDIRECTLY)
    // INVOKES ":REDRAWSTATUS".  SIMPLY IGNORE THE CALL THEN.
    IF (BUSY)
	RETURN;
    BUSY = TRUE;

    ROW = STATUSLINE_ROW(WP);

    WP->W_REDR_STATUS = FALSE;
    IF (WP->W_STATUS_HEIGHT == 0)
    {
	// NO STATUS LINE, CAN ONLY BE LAST WINDOW
	REDRAW_CMDLINE = TRUE;
    }
    ELSE IF (!REDRAWING()
	    // DON'T UPDATE STATUS LINE WHEN POPUP MENU IS VISIBLE AND MAY BE
	    // DRAWN OVER IT, UNLESS IT WILL BE REDRAWN LATER
	    || (!IGNORE_PUM && PUM_VISIBLE()))
    {
	// DON'T REDRAW RIGHT NOW, DO IT LATER.
	WP->W_REDR_STATUS = TRUE;
    }
#IFDEF FEAT_STL_OPT
    ELSE IF (*P_STL != NUL || *WP->W_P_STL != NUL)
    {
	// REDRAW CUSTOM STATUS LINE
	REDRAW_CUSTOM_STATUSLINE(WP);
    }
#ENDIF
    ELSE
    {
	FILLCHAR = FILLCHAR_STATUS(&ATTR, WP);

	GET_TRANS_BUFNAME(WP->W_BUFFER);
	P = NAMEBUFF;
	LEN = (INT)STRLEN(P);

	IF (BT_HELP(WP->W_BUFFER)
#IFDEF FEAT_QUICKFIX
		|| WP->W_P_PVW
#ENDIF
		|| BUFISCHANGED(WP->W_BUFFER)
		|| WP->W_BUFFER->B_P_RO)
	    *(P + LEN++) = ' ';
	IF (BT_HELP(WP->W_BUFFER))
	{
	    STRCPY(P + LEN, _("[HELP]"));
	    LEN += (INT)STRLEN(P + LEN);
	}
#IFDEF FEAT_QUICKFIX
	IF (WP->W_P_PVW)
	{
	    STRCPY(P + LEN, _("[PREVIEW]"));
	    LEN += (INT)STRLEN(P + LEN);
	}
#ENDIF
	IF (BUFISCHANGED(WP->W_BUFFER)
#IFDEF FEAT_TERMINAL
		&& !BT_TERMINAL(WP->W_BUFFER)
#ENDIF
		)
	{
	    STRCPY(P + LEN, "[+]");
	    LEN += 3;
	}
	IF (WP->W_BUFFER->B_P_RO)
	{
	    STRCPY(P + LEN, _("[RO]"));
	    LEN += (INT)STRLEN(P + LEN);
	}

	THIS_RU_COL = RU_COL - (COLUMNS - WP->W_WIDTH);
	IF (THIS_RU_COL < (WP->W_WIDTH + 1) / 2)
	    THIS_RU_COL = (WP->W_WIDTH + 1) / 2;
	IF (THIS_RU_COL <= 1)
	{
	    P = (CHAR_U *)"<";		// NO ROOM FOR FILE NAME!
	    LEN = 1;
	}
	ELSE IF (HAS_MBYTE)
	{
	    INT	CLEN = 0, I;

	    // COUNT TOTAL NUMBER OF DISPLAY CELLS.
	    CLEN = MB_STRING2CELLS(P, -1);

	    // FIND FIRST CHARACTER THAT WILL FIT.
	    // GOING FROM START TO END IS MUCH FASTER FOR DBCS.
	    FOR (I = 0; P[I] != NUL && CLEN >= THIS_RU_COL - 1;
		    I += (*MB_PTR2LEN)(P + I))
		CLEN -= (*MB_PTR2CELLS)(P + I);
	    LEN = CLEN;
	    IF (I > 0)
	    {
		P = P + I - 1;
		*P = '<';
		++LEN;
	    }

	}
	ELSE IF (LEN > THIS_RU_COL - 1)
	{
	    P += LEN - (THIS_RU_COL - 1);
	    *P = '<';
	    LEN = THIS_RU_COL - 1;
	}

	SCREEN_PUTS(P, ROW, WP->W_WINCOL, ATTR);
	SCREEN_FILL(ROW, ROW + 1, LEN + WP->W_WINCOL,
			THIS_RU_COL + WP->W_WINCOL, FILLCHAR, FILLCHAR, ATTR);

	IF (GET_KEYMAP_STR(WP, (CHAR_U *)"<%S>", NAMEBUFF, MAXPATHL)
		&& (INT)(THIS_RU_COL - LEN) > (INT)(STRLEN(NAMEBUFF) + 1))
	    SCREEN_PUTS(NAMEBUFF, ROW, (INT)(THIS_RU_COL - STRLEN(NAMEBUFF)
						   - 1 + WP->W_WINCOL), ATTR);

#IFDEF FEAT_CMDL_INFO
	WIN_REDR_RULER(WP, TRUE, IGNORE_PUM);
#ENDIF
    }

    /*
     * MAY NEED TO DRAW THE CHARACTER BELOW THE VERTICAL SEPARATOR.
     */
    IF (WP->W_VSEP_WIDTH != 0 && WP->W_STATUS_HEIGHT != 0 && REDRAWING())
    {
	IF (STL_CONNECTED(WP))
	    FILLCHAR = FILLCHAR_STATUS(&ATTR, WP);
	ELSE
	    FILLCHAR = FILLCHAR_VSEP(&ATTR);
	SCREEN_PUTCHAR(FILLCHAR, ROW, W_ENDCOL(WP), ATTR);
    }
    BUSY = FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204069_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_WINDOW(
    INT		NCHAR,
    LONG	PRENUM,
    INT		XCHAR)	    // EXTRA CHAR FROM ":WINCMD GX" OR NUL
{
    LONG	PRENUM1;
    WIN_T	*WP;
#IF DEFINED(FEAT_SEARCHPATH) || DEFINED(FEAT_FIND_ID)
    CHAR_U	*PTR;
    LINENR_T    LNUM = -1;
#ENDIF
#IFDEF FEAT_FIND_ID
    INT		TYPE = FIND_DEFINE;
    INT		LEN;
#ENDIF
    CHAR_U	CBUF[40];

    IF (ERROR_IF_ANY_POPUP_WINDOW)
	RETURN;

#IFDEF FEAT_CMDWIN
# DEFINE CHECK_CMDWIN \
    DO { \
	IF (CMDWIN_TYPE != 0) \
	{ \
	    EMSG(_(E_INVALID_IN_CMDLINE_WINDOW)); \
	    RETURN; \
	} \
    } WHILE (0)
#ELSE
# DEFINE CHECK_CMDWIN DO { /**/ } WHILE (0)
#ENDIF

    PRENUM1 = PRENUM == 0 ? 1 : PRENUM;

    SWITCH (NCHAR)
    {
// SPLIT CURRENT WINDOW IN TWO PARTS, HORIZONTALLY
    CASE 'S':
    CASE CTRL_S:
    CASE 'S':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
#IFDEF FEAT_QUICKFIX
		// WHEN SPLITTING THE QUICKFIX WINDOW OPEN A NEW BUFFER IN IT,
		// DON'T REPLICATE THE QUICKFIX BUFFER.
		IF (BT_QUICKFIX(CURBUF))
		    GOTO NEWWINDOW;
#ENDIF
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		(VOID)WIN_SPLIT((INT)PRENUM, 0);
		BREAK;

// SPLIT CURRENT WINDOW IN TWO PARTS, VERTICALLY
    CASE CTRL_V:
    CASE 'V':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
#IFDEF FEAT_QUICKFIX
		// WHEN SPLITTING THE QUICKFIX WINDOW OPEN A NEW BUFFER IN IT,
		// DON'T REPLICATE THE QUICKFIX BUFFER.
		IF (BT_QUICKFIX(CURBUF))
		    GOTO NEWWINDOW;
#ENDIF
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		(VOID)WIN_SPLIT((INT)PRENUM, WSP_VERT);
		BREAK;

// SPLIT CURRENT WINDOW AND EDIT ALTERNATE FILE
    CASE CTRL_HAT:
    CASE '^':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE

		IF (BUFLIST_FINDNR(PRENUM == 0
					? CURWIN->W_ALT_FNUM : PRENUM) == NULL)
		{
		    IF (PRENUM == 0)
			EMSG(_(E_NO_ALTERNATE_FILE));
		    ELSE
			SEMSG(_(E_BUFFER_NR_NOT_FOUND), PRENUM);
		    BREAK;
		}

		IF (!CURBUF_LOCKED() && WIN_SPLIT(0, 0) == OK)
		    (VOID)BUFLIST_GETFILE(
			    PRENUM == 0 ? CURWIN->W_ALT_FNUM : PRENUM,
			    (LINENR_T)0, GETF_ALT, FALSE);
		BREAK;

// OPEN NEW WINDOW
    CASE CTRL_N:
    CASE 'N':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
#IFDEF FEAT_QUICKFIX
NEWWINDOW:
#ENDIF
		IF (PRENUM)
		    // WINDOW HEIGHT
		    VIM_SNPRINTF((CHAR *)CBUF, SIZEOF(CBUF) - 5, "%LD", PRENUM);
		ELSE
		    CBUF[0] = NUL;
#IF DEFINED(FEAT_QUICKFIX)
		IF (NCHAR == 'V' || NCHAR == CTRL_V)
		    STRCAT(CBUF, "V");
#ENDIF
		STRCAT(CBUF, "NEW");
		DO_CMDLINE_CMD(CBUF);
		BREAK;

// QUIT CURRENT WINDOW
    CASE CTRL_Q:
    CASE 'Q':
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
		CMD_WITH_COUNT("QUIT", CBUF, SIZEOF(CBUF), PRENUM);
		DO_CMDLINE_CMD(CBUF);
		BREAK;

// CLOSE CURRENT WINDOW
    CASE CTRL_C:
    CASE 'C':
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
		CMD_WITH_COUNT("CLOSE", CBUF, SIZEOF(CBUF), PRENUM);
		DO_CMDLINE_CMD(CBUF);
		BREAK;

#IF DEFINED(FEAT_QUICKFIX)
// CLOSE PREVIEW WINDOW
    CASE CTRL_Z:
    CASE 'Z':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
		DO_CMDLINE_CMD((CHAR_U *)"PCLOSE");
		BREAK;

// CURSOR TO PREVIEW WINDOW
    CASE 'P':
		FOR_ALL_WINDOWS(WP)
		    IF (WP->W_P_PVW)
			BREAK;
		IF (WP == NULL)
		    EMSG(_(E_THERE_IS_NO_PREVIEW_WINDOW));
		ELSE
		    WIN_GOTO(WP);
		BREAK;
#ENDIF

// CLOSE ALL BUT CURRENT WINDOW
    CASE CTRL_O:
    CASE 'O':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
		CMD_WITH_COUNT("ONLY", CBUF, SIZEOF(CBUF), PRENUM);
		DO_CMDLINE_CMD(CBUF);
		BREAK;

// CURSOR TO NEXT WINDOW WITH WRAP AROUND
    CASE CTRL_W:
    CASE 'W':
// CURSOR TO PREVIOUS WINDOW WITH WRAP AROUND
    CASE 'W':
		CHECK_CMDWIN;
		IF (ONE_WINDOW && PRENUM != 1)	// JUST ONE WINDOW
		    BEEP_FLUSH();
		ELSE
		{
		    IF (PRENUM)			// GO TO SPECIFIED WINDOW
		    {
			FOR (WP = FIRSTWIN; --PRENUM > 0; )
			{
			    IF (WP->W_NEXT == NULL)
				BREAK;
			    ELSE
				WP = WP->W_NEXT;
			}
		    }
		    ELSE
		    {
			IF (NCHAR == 'W')	    // GO TO PREVIOUS WINDOW
			{
			    WP = CURWIN->W_PREV;
			    IF (WP == NULL)
				WP = LASTWIN;	    // WRAP AROUND
			}
			ELSE			    // GO TO NEXT WINDOW
			{
			    WP = CURWIN->W_NEXT;
			    IF (WP == NULL)
				WP = FIRSTWIN;	    // WRAP AROUND
			}
		    }
		    WIN_GOTO(WP);
		}
		BREAK;

// CURSOR TO WINDOW BELOW
    CASE 'J':
    CASE K_DOWN:
    CASE CTRL_J:
		CHECK_CMDWIN;
		WIN_GOTO_VER(FALSE, PRENUM1);
		BREAK;

// CURSOR TO WINDOW ABOVE
    CASE 'K':
    CASE K_UP:
    CASE CTRL_K:
		CHECK_CMDWIN;
		WIN_GOTO_VER(TRUE, PRENUM1);
		BREAK;

// CURSOR TO LEFT WINDOW
    CASE 'H':
    CASE K_LEFT:
    CASE CTRL_H:
    CASE K_BS:
		CHECK_CMDWIN;
		WIN_GOTO_HOR(TRUE, PRENUM1);
		BREAK;

// CURSOR TO RIGHT WINDOW
    CASE 'L':
    CASE K_RIGHT:
    CASE CTRL_L:
		CHECK_CMDWIN;
		WIN_GOTO_HOR(FALSE, PRENUM1);
		BREAK;

// MOVE WINDOW TO NEW TAB PAGE
    CASE 'T':
		CHECK_CMDWIN;
		IF (ONE_WINDOW())
		    MSG(_(M_ONLYONE));
		ELSE
		{
		    TABPAGE_T	*OLDTAB = CURTAB;
		    TABPAGE_T	*NEWTAB;

		    // FIRST CREATE A NEW TAB WITH THE WINDOW, THEN GO BACK TO
		    // THE OLD TAB AND CLOSE THE WINDOW THERE.
		    WP = CURWIN;
		    IF (WIN_NEW_TABPAGE((INT)PRENUM) == OK
						     && VALID_TABPAGE(OLDTAB))
		    {
			NEWTAB = CURTAB;
			GOTO_TABPAGE_TP(OLDTAB, TRUE, TRUE);
			IF (CURWIN == WP)
			    WIN_CLOSE(CURWIN, FALSE);
			IF (VALID_TABPAGE(NEWTAB))
			    GOTO_TABPAGE_TP(NEWTAB, TRUE, TRUE);
		    }
		}
		BREAK;

// CURSOR TO TOP-LEFT WINDOW
    CASE 'T':
    CASE CTRL_T:
		WIN_GOTO(FIRSTWIN);
		BREAK;

// CURSOR TO BOTTOM-RIGHT WINDOW
    CASE 'B':
    CASE CTRL_B:
		WIN_GOTO(LASTWIN);
		BREAK;

// CURSOR TO LAST ACCESSED (PREVIOUS) WINDOW
    CASE 'P':
    CASE CTRL_P:
		IF (!WIN_VALID(PREVWIN))
		    BEEP_FLUSH();
		ELSE
		    WIN_GOTO(PREVWIN);
		BREAK;

// EXCHANGE CURRENT AND NEXT WINDOW
    CASE 'X':
    CASE CTRL_X:
		CHECK_CMDWIN;
		WIN_EXCHANGE(PRENUM);
		BREAK;

// ROTATE WINDOWS DOWNWARDS
    CASE CTRL_R:
    CASE 'R':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
		WIN_ROTATE(FALSE, (INT)PRENUM1);    // DOWNWARDS
		BREAK;

// ROTATE WINDOWS UPWARDS
    CASE 'R':
		CHECK_CMDWIN;
		RESET_VISUAL_AND_RESEL();	// STOP VISUAL MODE
		WIN_ROTATE(TRUE, (INT)PRENUM1);	    // UPWARDS
		BREAK;

// MOVE WINDOW TO THE VERY TOP/BOTTOM/LEFT/RIGHT
    CASE 'K':
    CASE 'J':
    CASE 'H':
    CASE 'L':
		CHECK_CMDWIN;
		WIN_TOTOP((INT)PRENUM,
			((NCHAR == 'H' || NCHAR == 'L') ? WSP_VERT : 0)
			| ((NCHAR == 'H' || NCHAR == 'K') ? WSP_TOP : WSP_BOT));
		BREAK;

// MAKE ALL WINDOWS THE SAME HEIGHT
    CASE '=':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_EQUAL(NULL, FALSE, 'B');
		BREAK;

// INCREASE CURRENT WINDOW HEIGHT
    CASE '+':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_SETHEIGHT(CURWIN->W_HEIGHT + (INT)PRENUM1);
		BREAK;

// DECREASE CURRENT WINDOW HEIGHT
    CASE '-':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_SETHEIGHT(CURWIN->W_HEIGHT - (INT)PRENUM1);
		BREAK;

// SET CURRENT WINDOW HEIGHT
    CASE CTRL__:
    CASE '_':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_SETHEIGHT(PRENUM ? (INT)PRENUM : 9999);
		BREAK;

// INCREASE CURRENT WINDOW WIDTH
    CASE '>':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_SETWIDTH(CURWIN->W_WIDTH + (INT)PRENUM1);
		BREAK;

// DECREASE CURRENT WINDOW WIDTH
    CASE '<':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_SETWIDTH(CURWIN->W_WIDTH - (INT)PRENUM1);
		BREAK;

// SET CURRENT WINDOW WIDTH
    CASE '|':
#IFDEF FEAT_GUI
		NEED_MOUSE_CORRECT = TRUE;
#ENDIF
		WIN_SETWIDTH(PRENUM != 0 ? (INT)PRENUM : 9999);
		BREAK;

// JUMP TO TAG AND SPLIT WINDOW IF TAG EXISTS (IN PREVIEW WINDOW)
#IF DEFINED(FEAT_QUICKFIX)
    CASE '}':
		CHECK_CMDWIN;
		IF (PRENUM)
		    G_DO_TAGPREVIEW = PRENUM;
		ELSE
		    G_DO_TAGPREVIEW = P_PVH;
#ENDIF
		// FALLTHROUGH
    CASE ']':
    CASE CTRL_RSB:
		CHECK_CMDWIN;
		// KEEP VISUAL MODE, CAN SELECT WORDS TO USE AS A TAG
		IF (PRENUM)
		    POSTPONED_SPLIT = PRENUM;
		ELSE
		    POSTPONED_SPLIT = -1;
#IFDEF FEAT_QUICKFIX
		IF (NCHAR != '}')
		    G_DO_TAGPREVIEW = 0;
#ENDIF

		// EXECUTE THE COMMAND RIGHT HERE, REQUIRED WHEN "WINCMD ]"
		// WAS USED IN A FUNCTION.
		DO_NV_IDENT(CTRL_RSB, NUL);
		BREAK;

#IFDEF FEAT_SEARCHPATH
// EDIT FILE NAME UNDER CURSOR IN A NEW WINDOW
    CASE 'F':
    CASE 'F':
    CASE CTRL_F:
WINGOTOFILE:
		CHECK_CMDWIN;

		PTR = GRAB_FILE_NAME(PRENUM1, &LNUM);
		IF (PTR != NULL)
		{
		    TABPAGE_T	*OLDTAB = CURTAB;
		    WIN_T	*OLDWIN = CURWIN;
# IFDEF FEAT_GUI
		    NEED_MOUSE_CORRECT = TRUE;
# ENDIF
		    SETPCMARK();
		    IF (WIN_SPLIT(0, 0) == OK)
		    {
			RESET_BINDING(CURWIN);
			IF (DO_ECMD(0, PTR, NULL, NULL, ECMD_LASTL,
						   ECMD_HIDE, NULL) == FAIL)
			{
			    // FAILED TO OPEN THE FILE, CLOSE THE WINDOW
			    // OPENED FOR IT.
			    WIN_CLOSE(CURWIN, FALSE);
			    GOTO_TABPAGE_WIN(OLDTAB, OLDWIN);
			}
			ELSE IF (NCHAR == 'F' && LNUM >= 0)
			{
			    CURWIN->W_CURSOR.LNUM = LNUM;
			    CHECK_CURSOR_LNUM();
			    BEGINLINE(BL_SOL | BL_FIX);
			}
		    }
		    VIM_FREE(PTR);
		}
		BREAK;
#ENDIF

#IFDEF FEAT_FIND_ID
// GO TO THE FIRST OCCURRENCE OF THE IDENTIFIER UNDER CURSOR ALONG PATH IN A
// NEW WINDOW -- WEBB
    CASE 'I':			    // GO TO ANY MATCH
    CASE CTRL_I:
		TYPE = FIND_ANY;
		// FALLTHROUGH
    CASE 'D':			    // GO TO DEFINITION, USING 'DEFINE'
    CASE CTRL_D:
		CHECK_CMDWIN;
		IF ((LEN = FIND_IDENT_UNDER_CURSOR(&PTR, FIND_IDENT)) == 0)
		    BREAK;
		FIND_PATTERN_IN_PATH(PTR, 0, LEN, TRUE,
			PRENUM == 0 ? TRUE : FALSE, TYPE,
			PRENUM1, ACTION_SPLIT, (LINENR_T)1, (LINENR_T)MAXLNUM);
		CURWIN->W_SET_CURSWANT = TRUE;
		BREAK;
#ENDIF

// QUICKFIX WINDOW ONLY: VIEW THE RESULT UNDER THE CURSOR IN A NEW SPLIT.
#IF DEFINED(FEAT_QUICKFIX)
    CASE K_KENTER:
    CASE CAR:
		IF (BT_QUICKFIX(CURBUF))
		    QF_VIEW_RESULT(TRUE);
		BREAK;
#ENDIF

// CTRL-W G  EXTENDED COMMANDS
    CASE 'G':
    CASE CTRL_G:
		CHECK_CMDWIN;
#IFDEF USE_ON_FLY_SCROLL
		DONT_SCROLL = TRUE;		// DISALLOW SCROLLING HERE
#ENDIF
		++NO_MAPPING;
		++ALLOW_KEYS;   // NO MAPPING FOR XCHAR, BUT ALLOW KEY CODES
		IF (XCHAR == NUL)
		    XCHAR = PLAIN_VGETC();
		LANGMAP_ADJUST(XCHAR, TRUE);
		--NO_MAPPING;
		--ALLOW_KEYS;
#IFDEF FEAT_CMDL_INFO
		(VOID)ADD_TO_SHOWCMD(XCHAR);
#ENDIF
		SWITCH (XCHAR)
		{
#IF DEFINED(FEAT_QUICKFIX)
		    CASE '}':
			XCHAR = CTRL_RSB;
			IF (PRENUM)
			    G_DO_TAGPREVIEW = PRENUM;
			ELSE
			    G_DO_TAGPREVIEW = P_PVH;
#ENDIF
			// FALLTHROUGH
		    CASE ']':
		    CASE CTRL_RSB:
			// KEEP VISUAL MODE, CAN SELECT WORDS TO USE AS A TAG
			IF (PRENUM)
			    POSTPONED_SPLIT = PRENUM;
			ELSE
			    POSTPONED_SPLIT = -1;

			// EXECUTE THE COMMAND RIGHT HERE, REQUIRED WHEN
			// "WINCMD G}" WAS USED IN A FUNCTION.
			DO_NV_IDENT('G', XCHAR);
			BREAK;

#IFDEF FEAT_SEARCHPATH
		    CASE 'F':	    // CTRL-W GF: "GF" IN A NEW TAB PAGE
		    CASE 'F':	    // CTRL-W GF: "GF" IN A NEW TAB PAGE
			CMDMOD.CMOD_TAB = TABPAGE_INDEX(CURTAB) + 1;
			NCHAR = XCHAR;
			GOTO WINGOTOFILE;
#ENDIF
		    CASE 'T':	    // CTRL-W GT: GO TO NEXT TAB PAGE
			GOTO_TABPAGE((INT)PRENUM);
			BREAK;

		    CASE 'T':	    // CTRL-W GT: GO TO PREVIOUS TAB PAGE
			GOTO_TABPAGE(-(INT)PRENUM1);
			BREAK;

		    CASE TAB:	    // CTRL-W G<TAB>: GO TO LAST USED TAB PAGE
			IF (GOTO_TABPAGE_LASTUSED() == FAIL)
			    BEEP_FLUSH();
			BREAK;

		    DEFAULT:
			BEEP_FLUSH();
			BREAK;
		}
		BREAK;

    DEFAULT:	BEEP_FLUSH();
		BREAK;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198552_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PKEY_GOST_ECCP_ENCRYPT(EVP_PKEY_CTX *PCTX, UNSIGNED CHAR *OUT,
                           SIZE_T *OUT_LEN, CONST UNSIGNED CHAR *KEY,
                           SIZE_T KEY_LEN)
{
    GOST_KEY_TRANSPORT *GKT = NULL;
    EVP_PKEY *PUBK = EVP_PKEY_CTX_GET0_PKEY(PCTX);
    STRUCT GOST_PMETH_DATA *DATA = EVP_PKEY_CTX_GET_DATA(PCTX);
    INT PKEY_NID = EVP_PKEY_BASE_ID(PUBK);
    ASN1_OBJECT *CRYPT_PARAMS_OBJ = (PKEY_NID == NID_ID_GOSTR3410_2001 || PKEY_NID == NID_ID_GOSTR3410_2001DH) ?
        OBJ_NID2OBJ(NID_ID_GOST28147_89_CRYPTOPRO_A_PARAMSET) :
        OBJ_NID2OBJ(NID_ID_TC26_GOST_28147_PARAM_Z);
    CONST STRUCT GOST_CIPHER_INFO *PARAM =
        GET_ENCRYPTION_PARAMS(CRYPT_PARAMS_OBJ);
    UNSIGNED CHAR UKM[8], SHARED_KEY[32], CRYPTED_KEY[44];
    INT RET = 0;
    INT KEY_IS_EPHEMERAL = 1;
    GOST_CTX CCTX;
    EVP_PKEY *SEC_KEY = EVP_PKEY_CTX_GET0_PEERKEY(PCTX);
    IF (DATA->SHARED_UKM_SIZE) {
        MEMCPY(UKM, DATA->SHARED_UKM, 8);
    } ELSE {
        IF (RAND_BYTES(UKM, 8) <= 0) {
            GOSTERR(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_RNG_ERROR);
            RETURN 0;
        }
    }
    IF (!PARAM)
        GOTO ERR;
    /* CHECK FOR PRIVATE KEY IN THE PEER_KEY OF CONTEXT */
    IF (SEC_KEY) {
        KEY_IS_EPHEMERAL = 0;
        IF (!GOST_GET0_PRIV_KEY(SEC_KEY)) {
            GOSTERR(GOST_F_PKEY_GOST_ECCP_ENCRYPT,
                    GOST_R_NO_PRIVATE_PART_OF_NON_EPHEMERAL_KEYPAIR);
            GOTO ERR;
        }
    } ELSE {
        KEY_IS_EPHEMERAL = 1;
        IF (OUT) {
            SEC_KEY = EVP_PKEY_NEW();
            IF (!EVP_PKEY_ASSIGN(SEC_KEY, EVP_PKEY_BASE_ID(PUBK), EC_KEY_NEW())
                || !EVP_PKEY_COPY_PARAMETERS(SEC_KEY, PUBK)
                || !GOST_EC_KEYGEN(EVP_PKEY_GET0(SEC_KEY))) {
                GOSTERR(GOST_F_PKEY_GOST_ECCP_ENCRYPT,
                        GOST_R_ERROR_COMPUTING_SHARED_KEY);
                GOTO ERR;
            }
        }
    }
    IF (OUT) {
        INT DGST_NID = NID_UNDEF;
        EVP_PKEY_GET_DEFAULT_DIGEST_NID(PUBK, &DGST_NID);
        IF (DGST_NID == NID_ID_GOSTR3411_2012_512)
            DGST_NID = NID_ID_GOSTR3411_2012_256;

        IF (!VKO_COMPUTE_KEY(SHARED_KEY,
                             EC_KEY_GET0_PUBLIC_KEY(EVP_PKEY_GET0(PUBK)),
                             EVP_PKEY_GET0(SEC_KEY), UKM, 8, DGST_NID)) {
            GOSTERR(GOST_F_PKEY_GOST_ECCP_ENCRYPT,
                    GOST_R_ERROR_COMPUTING_SHARED_KEY);
            GOTO ERR;
        }
        GOST_INIT(&CCTX, PARAM->SBLOCK);
        KEYWRAPCRYPTOPRO(&CCTX, SHARED_KEY, UKM, KEY, CRYPTED_KEY);
    }
    GKT = GOST_KEY_TRANSPORT_NEW();
    IF (!GKT) {
        GOTO ERR;
    }
    IF (!ASN1_OCTET_STRING_SET(GKT->KEY_AGREEMENT_INFO->EPH_IV, UKM, 8)) {
        GOTO ERR;
    }
    IF (!ASN1_OCTET_STRING_SET(GKT->KEY_INFO->IMIT, CRYPTED_KEY + 40, 4)) {
        GOTO ERR;
    }
    IF (!ASN1_OCTET_STRING_SET
        (GKT->KEY_INFO->ENCRYPTED_KEY, CRYPTED_KEY + 8, 32)) {
        GOTO ERR;
    }
    IF (KEY_IS_EPHEMERAL) {
        IF (!X509_PUBKEY_SET
            (&GKT->KEY_AGREEMENT_INFO->EPHEM_KEY, OUT ? SEC_KEY : PUBK)) {
            GOSTERR(GOST_F_PKEY_GOST_ECCP_ENCRYPT,
                    GOST_R_CANNOT_PACK_EPHEMERAL_KEY);
            GOTO ERR;
        }
    }
    ASN1_OBJECT_FREE(GKT->KEY_AGREEMENT_INFO->CIPHER);
    GKT->KEY_AGREEMENT_INFO->CIPHER = OBJ_NID2OBJ(PARAM->NID);
    IF (KEY_IS_EPHEMERAL)
        EVP_PKEY_FREE(SEC_KEY);
    IF (!KEY_IS_EPHEMERAL) {
        /* SET CONTROL "PUBLIC KEY FROM CLIENT CERTIFICATE USED" */
        IF (EVP_PKEY_CTX_CTRL(PCTX, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)
            <= 0) {
            GOSTERR(GOST_F_PKEY_GOST_ECCP_ENCRYPT, GOST_R_CTRL_CALL_FAILED);
            GOTO ERR;
        }
    }
    IF ((*OUT_LEN = I2D_GOST_KEY_TRANSPORT(GKT, OUT ? &OUT : NULL)) > 0)
        RET = 1;
    OPENSSL_CLEANSE(SHARED_KEY, SIZEOF(SHARED_KEY));
    GOST_KEY_TRANSPORT_FREE(GKT);
    RETURN RET;
 ERR:
    OPENSSL_CLEANSE(SHARED_KEY, SIZEOF(SHARED_KEY));
    IF (KEY_IS_EPHEMERAL)
        EVP_PKEY_FREE(SEC_KEY);
    GOST_KEY_TRANSPORT_FREE(GKT);
    RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 427181_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID EXPRSTAT (LEXSTATE *LS) {
  /* STAT -> FUNC | ASSIGNMENT */
  FUNCSTATE *FS = LS->FS;
  STRUCT LHS_ASSIGN V;
  SUFFIXEDEXP(LS, &V.V);
  IF (LS->T.TOKEN == '=' || LS->T.TOKEN == ',') { /* STAT -> ASSIGNMENT ? */
    V.PREV = NULL;
    RESTASSIGN(LS, &V, 1);
  }
  ELSE {  /* STAT -> FUNC */
    INSTRUCTION *INST;
    CHECK_CONDITION(LS, V.V.K == VCALL, "SYNTAX ERROR");
    INST = &GETINSTRUCTION(FS, &V.V);
    SETARG_C(*INST, 1);  /* CALL STATEMENT USES NO RESULTS */
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 364768_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FINDTAGS_STATE_INIT(
    FINDTAGS_STATE_T	*ST,
    CHAR_U		*PAT,
    INT			FLAGS,
    INT			MINCOUNT)
{
    INT		MTT;

    ST->TAG_FNAME = ALLOC(MAXPATHL + 1);
    ST->FP = NULL;
    ST->ORGPAT = ALLOC_ONE(PAT_T);
    ST->ORGPAT->PAT = PAT;
    ST->ORGPAT->LEN = (INT)STRLEN(PAT);
    ST->ORGPAT->REGMATCH.REGPROG = NULL;
    ST->FLAGS = FLAGS;
    ST->TAG_FILE_SORTED = NUL;
    ST->HELP_ONLY = (FLAGS & TAG_HELP);
    ST->GET_SEARCHPAT = FALSE;
#IFDEF FEAT_MULTI_LANG
    ST->HELP_LANG[0] = NUL;
    ST->HELP_PRI = 0;
    ST->HELP_LANG_FIND = NULL;
    ST->IS_TXT = FALSE;
#ENDIF
    ST->DID_OPEN = FALSE;
    ST->MINCOUNT = MINCOUNT;
    ST->LBUF_SIZE = LSIZE;
    ST->LBUF = ALLOC(ST->LBUF_SIZE);
#IFDEF FEAT_EMACS_TAGS
    ST->EBUF = ALLOC(LSIZE);
#ENDIF
    ST->MATCH_COUNT = 0;
    ST->STOP_SEARCHING = FALSE;

    FOR (MTT = 0; MTT < MT_COUNT; ++MTT)
    {
	GA_INIT2(&ST->GA_MATCH[MTT], SIZEOF(CHAR_U *), 100);
	HASH_INIT(&ST->HT_MATCH[MTT]);
    }

    // CHECK FOR OUT OF MEMORY SITUATION
    IF (ST->TAG_FNAME == NULL
	    || ST->LBUF == NULL
#IFDEF FEAT_EMACS_TAGS
	    || ST->EBUF == NULL
#ENDIF
       )
	RETURN FAIL;

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201343_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SELINUX_PTRACE_TRACEME(STRUCT TASK_STRUCT *PARENT)
{
	RETURN AVC_HAS_PERM(&SELINUX_STATE,
			    TASK_SID_SUBJ(PARENT), TASK_SID_OBJ(CURRENT),
			    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484710_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MOBI_BUFFER_ADD8(MOBIBUFFER *BUF, CONST UINT8_T DATA) {
    IF (BUF->OFFSET + 1 > BUF->MAXLEN) {
        DEBUG_PRINT("%S", "BUFFER FULL\N");
        BUF->ERROR = MOBI_BUFFER_END;
        RETURN;
    }
    BUF->DATA[BUF->OFFSET++] = DATA;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210204_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT NLATTR *RESERVE_SFA_SIZE(STRUCT SW_FLOW_ACTIONS **SFA,
				       INT ATTR_LEN, BOOL LOG)
{

	STRUCT SW_FLOW_ACTIONS *ACTS;
	INT NEW_ACTS_SIZE;
	SIZE_T REQ_SIZE = NLA_ALIGN(ATTR_LEN);
	INT NEXT_OFFSET = OFFSETOF(STRUCT SW_FLOW_ACTIONS, ACTIONS) +
					(*SFA)->ACTIONS_LEN;

	IF (REQ_SIZE <= (KSIZE(*SFA) - NEXT_OFFSET))
		GOTO OUT;

	NEW_ACTS_SIZE = MAX(NEXT_OFFSET + REQ_SIZE, KSIZE(*SFA) * 2);

	IF (NEW_ACTS_SIZE > MAX_ACTIONS_BUFSIZE) {
		IF ((MAX_ACTIONS_BUFSIZE - NEXT_OFFSET) < REQ_SIZE) {
			OVS_NLERR(LOG, "FLOW ACTION SIZE EXCEEDS MAX %U",
				  MAX_ACTIONS_BUFSIZE);
			RETURN ERR_PTR(-EMSGSIZE);
		}
		NEW_ACTS_SIZE = MAX_ACTIONS_BUFSIZE;
	}

	ACTS = NLA_ALLOC_FLOW_ACTIONS(NEW_ACTS_SIZE);
	IF (IS_ERR(ACTS))
		RETURN (VOID *)ACTS;

	MEMCPY(ACTS->ACTIONS, (*SFA)->ACTIONS, (*SFA)->ACTIONS_LEN);
	ACTS->ACTIONS_LEN = (*SFA)->ACTIONS_LEN;
	ACTS->ORIG_LEN = (*SFA)->ORIG_LEN;
	KFREE(*SFA);
	*SFA = ACTS;

OUT:
	(*SFA)->ACTIONS_LEN += REQ_SIZE;
	RETURN  (STRUCT NLATTR *) ((UNSIGNED CHAR *)(*SFA) + NEXT_OFFSET);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384908_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VIM_FULLNAME(
    CHAR_U	*FNAME,
    CHAR_U	*BUF,
    INT		LEN,
    INT		FORCE)	    // FORCE EXPANSION EVEN WHEN ALREADY ABSOLUTE
{
    INT		RETVAL = OK;
    INT		URL;

    *BUF = NUL;
    IF (FNAME == NULL)
	RETURN FAIL;

    URL = PATH_WITH_URL(FNAME);
    IF (!URL)
	RETVAL = MCH_FULLNAME(FNAME, BUF, LEN, FORCE);
    IF (URL || RETVAL == FAIL)
    {
	// SOMETHING FAILED; USE THE FILE NAME (TRUNCATE WHEN TOO LONG)
	VIM_STRNCPY(BUF, FNAME, LEN - 1);
    }
#IF DEFINED(MSWIN)
    SLASH_ADJUST(BUF);
#ENDIF
    RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 477385_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RBINJAVAATTRINFO *R_BIN_JAVA_READ_NEXT_ATTR(RBINJAVAOBJ *BIN, CONST UT64 OFFSET, CONST UT8 *BUF, CONST UT64 BUF_LEN) {
	RBINJAVAATTRINFO *ATTR = NULL;
	UT32 SZ = 0;
	UT8 *BUFFER = NULL;
	CONST UT8 *A_BUF = OFFSET + BUF;
	UT8 ATTR_IDX_LEN = 6;
	IF (OFFSET + 6 > BUF_LEN) {
		EPRINTF ("[X] R_BIN_JAVA: ERROR UNABLE TO PARSE REMAINDER OF CLASSFILE IN ATTRIBUTE OFFSET "
			"(0X%"PFMT64X ") > LEN  OF REMAINING BYTES (0X%"PFMT64X ").\N", OFFSET, BUF_LEN);
		RETURN NULL;
	}
	// UT16 ATTR_IDX, UT32 LENGTH OF ATTR.
	SZ = R_BIN_JAVA_UINT (A_BUF, 2) + ATTR_IDX_LEN; // R_BIN_JAVA_READ_INT (BIN, BUF_OFFSET+2) + ATTR_IDX_LEN;
	IF (SZ + OFFSET > BUF_LEN) {
		EPRINTF ("[X] R_BIN_JAVA: ERROR UNABLE TO PARSE REMAINDER OF CLASSFILE IN ATTRIBUTE LEN "
			"(0X%X) + OFFSET (0X%"PFMT64X ") EXCEEDS LENGTH OF BUFFER (0X%"PFMT64X ").\N",
			SZ, OFFSET, BUF_LEN);
		RETURN NULL;
	}
	// WHEN READING THE ATTR BYTES, NEED TO ALSO
	// INCLUDE THE INITIAL 6 BYTES, WHICH
	// ARE NOT INCLUDED IN THE ATTRIBUTE LENGTH
	// ,
	// SZ, BUF_OFFSET, BUF_OFFSET+SZ);
	BUFFER = R_BIN_JAVA_GET_ATTR_BUF (BIN, SZ, OFFSET, BUF, BUF_LEN);
	// PRINTF ("%D %D %D\N", SZ, BUF_LEN, OFFSET);
	IF (OFFSET < BUF_LEN) {
		ATTR = R_BIN_JAVA_READ_NEXT_ATTR_FROM_BUFFER (BIN, BUFFER, BUF_LEN - OFFSET, OFFSET);
		FREE (BUFFER);

		IF (!ATTR) {
			RETURN NULL;
		}
		ATTR->SIZE = SZ;
	} ELSE {
		FREE (BUFFER);
		EPRINTF ("IS OOB\N");
	}
	RETURN ATTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 318104_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT RSI_USB_READ_REGISTER_MULTIPLE(STRUCT RSI_HW *ADAPTER, U32 ADDR,
					  U8 *DATA, U16 COUNT)
{
	STRUCT RSI_91X_USBDEV *DEV = (STRUCT RSI_91X_USBDEV *)ADAPTER->RSI_DEV;
	U8 *BUF;
	U16 TRANSFER;
	INT STATUS;

	IF (!ADDR)
		RETURN -EINVAL;

	BUF = KZALLOC(RSI_USB_BUF_SIZE, GFP_KERNEL);
	IF (!BUF)
		RETURN -ENOMEM;

	WHILE (COUNT) {
		TRANSFER = MIN_T(U16, COUNT, RSI_USB_BUF_SIZE);
		STATUS = USB_CONTROL_MSG(DEV->USBDEV,
					 USB_RCVCTRLPIPE(DEV->USBDEV, 0),
					 USB_VENDOR_REGISTER_READ,
					 RSI_USB_REQ_IN,
					 ((ADDR & 0XFFFF0000) >> 16),
					 (ADDR & 0XFFFF), (VOID *)BUF,
					 TRANSFER, USB_CTRL_GET_TIMEOUT);
		IF (STATUS < 0) {
			RSI_DBG(ERR_ZONE,
				"REG READ FAILED WITH ERROR CODE :%D\N",
				 STATUS);
			KFREE(BUF);
			RETURN STATUS;
		}
		MEMCPY(DATA, BUF, TRANSFER);
		COUNT -= TRANSFER;
		DATA += TRANSFER;
		ADDR += TRANSFER;
	}
	KFREE(BUF);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210692_CWE-835.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READBMPIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
  BMPINFO
    BMP_INFO;

  IMAGE
    *IMAGE;

  INDEXPACKET
    INDEX;

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    OFFSET,
    START_POSITION;

  MEMORYINFO
    *PIXEL_INFO;

  REGISTER INDEXPACKET
    *INDEXES;

  REGISTER PIXELPACKET
    *Q;

  REGISTER SSIZE_T
    I,
    X;

  REGISTER UNSIGNED CHAR
    *P;

  SIZE_T
    BIT,
    BYTES_PER_LINE,
    LENGTH;

  SSIZE_T
    COUNT,
    Y;

  UNSIGNED CHAR
    MAGICK[12],
    *PIXELS;

  UNSIGNED INT
    BLUE,
    GREEN,
    OFFSET_BITS,
    RED;

  /*
    OPEN IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  IMAGE=ACQUIREIMAGE(IMAGE_INFO);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    DETERMINE IF THIS A BMP FILE.
  */
  (VOID) MEMSET(&BMP_INFO,0,SIZEOF(BMP_INFO));
  BMP_INFO.BA_OFFSET=0;
  START_POSITION=0;
  OFFSET_BITS=0;
  COUNT=READBLOB(IMAGE,2,MAGICK);
  IF (COUNT != 2)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  DO
  {
    LONGPIXELPACKET
      SHIFT;

    PIXELPACKET
      QUANTUM_BITS;

    /*
      VERIFY BMP IDENTIFIER.
    */
    IF (BMP_INFO.BA_OFFSET == 0)
      START_POSITION=TELLBLOB(IMAGE)-2;
    BMP_INFO.BA_OFFSET=0;
    WHILE (LOCALENCOMPARE((CHAR *) MAGICK,"BA",2) == 0)
    {
      BMP_INFO.FILE_SIZE=READBLOBLSBLONG(IMAGE);
      BMP_INFO.BA_OFFSET=READBLOBLSBLONG(IMAGE);
      BMP_INFO.OFFSET_BITS=READBLOBLSBLONG(IMAGE);
      COUNT=READBLOB(IMAGE,2,MAGICK);
      IF (COUNT != 2)
        BREAK;
    }
    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  MAGICK: %C%C",
        MAGICK[0],MAGICK[1]);
    IF ((COUNT != 2) || ((LOCALENCOMPARE((CHAR *) MAGICK,"BM",2) != 0) &&
        (LOCALENCOMPARE((CHAR *) MAGICK,"CI",2) != 0)))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
    BMP_INFO.FILE_SIZE=READBLOBLSBLONG(IMAGE);
    (VOID) READBLOBLSBLONG(IMAGE);

    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
         "  FILE_SIZE IN HEADER:  %U BYTES",BMP_INFO.FILE_SIZE);

    BMP_INFO.OFFSET_BITS=READBLOBLSBLONG(IMAGE);
    BMP_INFO.SIZE=READBLOBLSBLONG(IMAGE);
    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  BMP SIZE: %U",
        BMP_INFO.SIZE);
    IF (BMP_INFO.SIZE == 12)
      {
        /*
          OS/2 BMP IMAGE FILE.
        */
        (VOID) COPYMAGICKSTRING(IMAGE->MAGICK,"BMP2",MAXTEXTEXTENT);
        BMP_INFO.WIDTH=(SSIZE_T) ((SHORT) READBLOBLSBSHORT(IMAGE));
        BMP_INFO.HEIGHT=(SSIZE_T) ((SHORT) READBLOBLSBSHORT(IMAGE));
        BMP_INFO.PLANES=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.BITS_PER_PIXEL=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.X_PIXELS=0;
        BMP_INFO.Y_PIXELS=0;
        BMP_INFO.NUMBER_COLORS=0;
        BMP_INFO.COMPRESSION=BI_RGB;
        BMP_INFO.IMAGE_SIZE=0;
        BMP_INFO.ALPHA_MASK=0;
        IF (IMAGE->DEBUG != MAGICKFALSE)
          {
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  FORMAT: OS/2 BITMAP");
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  GEOMETRY: %.20GX%.20G",(DOUBLE) BMP_INFO.WIDTH,(DOUBLE)
              BMP_INFO.HEIGHT);
          }
      }
    ELSE
      {
        /*
          MICROSOFT WINDOWS BMP IMAGE FILE.
        */
        IF (BMP_INFO.SIZE < 40)
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"NONOS2HEADERSIZEERROR");
        BMP_INFO.WIDTH=(SSIZE_T) READBLOBLSBSIGNEDLONG(IMAGE);
        BMP_INFO.HEIGHT=(SSIZE_T) READBLOBLSBSIGNEDLONG(IMAGE);
        BMP_INFO.PLANES=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.BITS_PER_PIXEL=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.COMPRESSION=READBLOBLSBLONG(IMAGE);
        BMP_INFO.IMAGE_SIZE=READBLOBLSBLONG(IMAGE);
        BMP_INFO.X_PIXELS=READBLOBLSBLONG(IMAGE);
        BMP_INFO.Y_PIXELS=READBLOBLSBLONG(IMAGE);
        BMP_INFO.NUMBER_COLORS=READBLOBLSBLONG(IMAGE);
        IF (BMP_INFO.NUMBER_COLORS > GETBLOBSIZE(IMAGE))
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
        BMP_INFO.COLORS_IMPORTANT=READBLOBLSBLONG(IMAGE);
        IF (IMAGE->DEBUG != MAGICKFALSE)
          {
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  FORMAT: MS WINDOWS BITMAP");
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  GEOMETRY: %.20GX%.20G",(DOUBLE) BMP_INFO.WIDTH,(DOUBLE)
              BMP_INFO.HEIGHT);
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  BITS PER PIXEL: %.20G",(DOUBLE) BMP_INFO.BITS_PER_PIXEL);
            SWITCH (BMP_INFO.COMPRESSION)
            {
              CASE BI_RGB:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_RGB");
                BREAK;
              }
              CASE BI_RLE4:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_RLE4");
                BREAK;
              }
              CASE BI_RLE8:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_RLE8");
                BREAK;
              }
              CASE BI_BITFIELDS:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_BITFIELDS");
                BREAK;
              }
              CASE BI_PNG:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_PNG");
                BREAK;
              }
              CASE BI_JPEG:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_JPEG");
                BREAK;
              }
              DEFAULT:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: UNKNOWN (%U)",BMP_INFO.COMPRESSION);
              }
            }
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  NUMBER OF COLORS: %U",BMP_INFO.NUMBER_COLORS);
          }
        BMP_INFO.RED_MASK=READBLOBLSBLONG(IMAGE);
        BMP_INFO.GREEN_MASK=READBLOBLSBLONG(IMAGE);
        BMP_INFO.BLUE_MASK=READBLOBLSBLONG(IMAGE);
        IF (BMP_INFO.SIZE > 40)
          {
            DOUBLE
              GAMMA;

            /*
              READ COLOR MANAGEMENT INFORMATION.
            */
            BMP_INFO.ALPHA_MASK=READBLOBLSBLONG(IMAGE);
            BMP_INFO.COLORSPACE=READBLOBLSBSIGNEDLONG(IMAGE);
            /*
              DECODE 2^30 FIXED POINT FORMATTED CIE PRIMARIES.
            */
#           DEFINE BMP_DENOM ((DOUBLE) 0X40000000)
            BMP_INFO.RED_PRIMARY.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.RED_PRIMARY.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.RED_PRIMARY.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.GREEN_PRIMARY.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.GREEN_PRIMARY.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.GREEN_PRIMARY.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.BLUE_PRIMARY.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.BLUE_PRIMARY.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.BLUE_PRIMARY.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;

            GAMMA=BMP_INFO.RED_PRIMARY.X+BMP_INFO.RED_PRIMARY.Y+
              BMP_INFO.RED_PRIMARY.Z;
            GAMMA=PERCEPTIBLERECIPROCAL(GAMMA);
            BMP_INFO.RED_PRIMARY.X*=GAMMA;
            BMP_INFO.RED_PRIMARY.Y*=GAMMA;
            IMAGE->CHROMATICITY.RED_PRIMARY.X=BMP_INFO.RED_PRIMARY.X;
            IMAGE->CHROMATICITY.RED_PRIMARY.Y=BMP_INFO.RED_PRIMARY.Y;

            GAMMA=BMP_INFO.GREEN_PRIMARY.X+BMP_INFO.GREEN_PRIMARY.Y+
              BMP_INFO.GREEN_PRIMARY.Z;
            GAMMA=PERCEPTIBLERECIPROCAL(GAMMA);
            BMP_INFO.GREEN_PRIMARY.X*=GAMMA;
            BMP_INFO.GREEN_PRIMARY.Y*=GAMMA;
            IMAGE->CHROMATICITY.GREEN_PRIMARY.X=BMP_INFO.GREEN_PRIMARY.X;
            IMAGE->CHROMATICITY.GREEN_PRIMARY.Y=BMP_INFO.GREEN_PRIMARY.Y;

            GAMMA=BMP_INFO.BLUE_PRIMARY.X+BMP_INFO.BLUE_PRIMARY.Y+
              BMP_INFO.BLUE_PRIMARY.Z;
            GAMMA=PERCEPTIBLERECIPROCAL(GAMMA);
            BMP_INFO.BLUE_PRIMARY.X*=GAMMA;
            BMP_INFO.BLUE_PRIMARY.Y*=GAMMA;
            IMAGE->CHROMATICITY.BLUE_PRIMARY.X=BMP_INFO.BLUE_PRIMARY.X;
            IMAGE->CHROMATICITY.BLUE_PRIMARY.Y=BMP_INFO.BLUE_PRIMARY.Y;

            /*
              DECODE 16^16 FIXED POINT FORMATTED GAMMA_SCALES.
            */
            BMP_INFO.GAMMA_SCALE.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/0X10000;
            BMP_INFO.GAMMA_SCALE.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/0X10000;
            BMP_INFO.GAMMA_SCALE.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/0X10000;
            /*
              COMPUTE A SINGLE GAMMA FROM THE BMP 3-CHANNEL GAMMA.
            */
            IMAGE->GAMMA=(BMP_INFO.GAMMA_SCALE.X+BMP_INFO.GAMMA_SCALE.Y+
              BMP_INFO.GAMMA_SCALE.Z)/3.0;
          }
        ELSE
          (VOID) COPYMAGICKSTRING(IMAGE->MAGICK,"BMP3",MAXTEXTEXTENT);

        IF (BMP_INFO.SIZE > 108)
          {
            SIZE_T
              INTENT;

            /*
              READ BMP VERSION 5 COLOR MANAGEMENT INFORMATION.
            */
            INTENT=READBLOBLSBLONG(IMAGE);
            SWITCH ((INT) INTENT)
            {
              CASE LCS_GM_BUSINESS:
              {
                IMAGE->RENDERING_INTENT=SATURATIONINTENT;
                BREAK;
              }
              CASE LCS_GM_GRAPHICS:
              {
                IMAGE->RENDERING_INTENT=RELATIVEINTENT;
                BREAK;
              }
              CASE LCS_GM_IMAGES:
              {
                IMAGE->RENDERING_INTENT=PERCEPTUALINTENT;
                BREAK;
              }
              CASE LCS_GM_ABS_COLORIMETRIC:
              {
                IMAGE->RENDERING_INTENT=ABSOLUTEINTENT;
                BREAK;
              }
            }
            (VOID) READBLOBLSBLONG(IMAGE);  /* PROFILE DATA */
            (VOID) READBLOBLSBLONG(IMAGE);  /* PROFILE SIZE */
            (VOID) READBLOBLSBLONG(IMAGE);  /* RESERVED BYTE */
          }
      }
    IF ((MAGICKSIZETYPE) BMP_INFO.FILE_SIZE > GETBLOBSIZE(IMAGE))
      (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),CORRUPTIMAGEERROR,
        "LENGTHANDFILESIZEDONOTMATCH","`%S'",IMAGE->FILENAME);
    ELSE
      IF ((MAGICKSIZETYPE) BMP_INFO.FILE_SIZE < GETBLOBSIZE(IMAGE))
        (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
          CORRUPTIMAGEWARNING,"LENGTHANDFILESIZEDONOTMATCH","`%S'",
          IMAGE->FILENAME);
    IF (BMP_INFO.WIDTH <= 0)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"NEGATIVEORZEROIMAGESIZE");
    IF (BMP_INFO.HEIGHT == 0)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"NEGATIVEORZEROIMAGESIZE");
    IF (BMP_INFO.PLANES != 1)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"STATICPLANESVALUENOTEQUALTOONE");
    IF ((BMP_INFO.BITS_PER_PIXEL != 1) && (BMP_INFO.BITS_PER_PIXEL != 4) &&
        (BMP_INFO.BITS_PER_PIXEL != 8) && (BMP_INFO.BITS_PER_PIXEL != 16) &&
        (BMP_INFO.BITS_PER_PIXEL != 24) && (BMP_INFO.BITS_PER_PIXEL != 32))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    IF (BMP_INFO.BITS_PER_PIXEL < 16 &&
        BMP_INFO.NUMBER_COLORS > (1U << BMP_INFO.BITS_PER_PIXEL))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDNUMBEROFCOLORS");
    IF ((BMP_INFO.COMPRESSION == 1) && (BMP_INFO.BITS_PER_PIXEL != 8))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    IF ((BMP_INFO.COMPRESSION == 2) && (BMP_INFO.BITS_PER_PIXEL != 4))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    IF ((BMP_INFO.COMPRESSION == 3) && (BMP_INFO.BITS_PER_PIXEL < 16))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    SWITCH (BMP_INFO.COMPRESSION)
    {
      CASE BI_RGB:
        IMAGE->COMPRESSION=NOCOMPRESSION;
        BREAK;
      CASE BI_RLE8:
      CASE BI_RLE4:
        IMAGE->COMPRESSION=RLECOMPRESSION;
        BREAK;
      CASE BI_BITFIELDS:
        BREAK;
      CASE BI_JPEG:
        THROWREADEREXCEPTION(CODERERROR,"JPEGCOMPRESSNOTSUPPORTED");
      CASE BI_PNG:
        THROWREADEREXCEPTION(CODERERROR,"PNGCOMPRESSNOTSUPPORTED");
      DEFAULT:
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDIMAGECOMPRESSION");
    }
    IMAGE->COLUMNS=(SIZE_T) MAGICKABSOLUTEVALUE(BMP_INFO.WIDTH);
    IMAGE->ROWS=(SIZE_T) MAGICKABSOLUTEVALUE(BMP_INFO.HEIGHT);
    IMAGE->DEPTH=BMP_INFO.BITS_PER_PIXEL <= 8 ? BMP_INFO.BITS_PER_PIXEL : 8;
    IMAGE->MATTE=((BMP_INFO.ALPHA_MASK != 0) &&
      (BMP_INFO.COMPRESSION == BI_BITFIELDS)) ? MAGICKTRUE : MAGICKFALSE;
    IF (BMP_INFO.BITS_PER_PIXEL < 16)
      {
        SIZE_T
          ONE;

        IMAGE->STORAGE_CLASS=PSEUDOCLASS;
        IMAGE->COLORS=BMP_INFO.NUMBER_COLORS;
        ONE=1;
        IF (IMAGE->COLORS == 0)
          IMAGE->COLORS=ONE << BMP_INFO.BITS_PER_PIXEL;
      }
    IMAGE->X_RESOLUTION=(DOUBLE) BMP_INFO.X_PIXELS/100.0;
    IMAGE->Y_RESOLUTION=(DOUBLE) BMP_INFO.Y_PIXELS/100.0;
    IMAGE->UNITS=PIXELSPERCENTIMETERRESOLUTION;
    IF ((IMAGE_INFO->PING != MAGICKFALSE) && (IMAGE_INFO->NUMBER_SCENES != 0))
      IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
        BREAK;
    STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS);
    IF (STATUS == MAGICKFALSE)
      {
        INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }
    IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
      {
        UNSIGNED CHAR
          *BMP_COLORMAP;

        SIZE_T
          PACKET_SIZE;

        /*
          READ BMP RASTER COLORMAP.
        */
        IF (IMAGE->DEBUG != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  READING COLORMAP OF %.20G COLORS",(DOUBLE) IMAGE->COLORS);
        IF (ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS) == MAGICKFALSE)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        BMP_COLORMAP=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T)
          IMAGE->COLORS,4*SIZEOF(*BMP_COLORMAP));
        IF (BMP_COLORMAP == (UNSIGNED CHAR *) NULL)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        IF ((BMP_INFO.SIZE == 12) || (BMP_INFO.SIZE == 64))
          PACKET_SIZE=3;
        ELSE
          PACKET_SIZE=4;
        OFFSET=SEEKBLOB(IMAGE,START_POSITION+14+BMP_INFO.SIZE,SEEK_SET);
        IF (OFFSET < 0)
          {
            BMP_COLORMAP=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BMP_COLORMAP);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
          }
        COUNT=READBLOB(IMAGE,PACKET_SIZE*IMAGE->COLORS,BMP_COLORMAP);
        IF (COUNT != (SSIZE_T) (PACKET_SIZE*IMAGE->COLORS))
          {
            BMP_COLORMAP=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BMP_COLORMAP);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "INSUFFICIENTIMAGEDATAINFILE");
          }
        P=BMP_COLORMAP;
        FOR (I=0; I < (SSIZE_T) IMAGE->COLORS; I++)
        {
          IMAGE->COLORMAP[I].BLUE=SCALECHARTOQUANTUM(*P++);
          IMAGE->COLORMAP[I].GREEN=SCALECHARTOQUANTUM(*P++);
          IMAGE->COLORMAP[I].RED=SCALECHARTOQUANTUM(*P++);
          IF (PACKET_SIZE == 4)
            P++;
        }
        BMP_COLORMAP=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BMP_COLORMAP);
      }
    /*
      READ IMAGE DATA.
    */
    IF (BMP_INFO.OFFSET_BITS == OFFSET_BITS)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
    OFFSET_BITS=BMP_INFO.OFFSET_BITS;
    OFFSET=SEEKBLOB(IMAGE,START_POSITION+BMP_INFO.OFFSET_BITS,SEEK_SET);
    IF (OFFSET < 0)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
    IF (BMP_INFO.COMPRESSION == BI_RLE4)
      BMP_INFO.BITS_PER_PIXEL<<=1;
    BYTES_PER_LINE=4*((IMAGE->COLUMNS*BMP_INFO.BITS_PER_PIXEL+31)/32);
    LENGTH=(SIZE_T) BYTES_PER_LINE*IMAGE->ROWS;
    IF (((MAGICKSIZETYPE) LENGTH/8) > GETBLOBSIZE(IMAGE))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
    IF ((BMP_INFO.COMPRESSION == BI_RGB) ||
        (BMP_INFO.COMPRESSION == BI_BITFIELDS))
      {
        PIXEL_INFO=ACQUIREVIRTUALMEMORY(IMAGE->ROWS,MAGICKMAX(BYTES_PER_LINE,
          IMAGE->COLUMNS+256UL)*SIZEOF(*PIXELS));
        IF (PIXEL_INFO == (MEMORYINFO *) NULL)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        PIXELS=(UNSIGNED CHAR *) GETVIRTUALMEMORYBLOB(PIXEL_INFO);
        IF (IMAGE->DEBUG != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  READING PIXELS (%.20G BYTES)",(DOUBLE) LENGTH);
        COUNT=READBLOB(IMAGE,LENGTH,PIXELS);
        IF (COUNT != (SSIZE_T) LENGTH)
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "INSUFFICIENTIMAGEDATAINFILE");
          }
      }
    ELSE
      {
        /*
          CONVERT RUN-LENGTH ENCODED RASTER PIXELS.
        */
        PIXEL_INFO=ACQUIREVIRTUALMEMORY(IMAGE->ROWS,MAGICKMAX(BYTES_PER_LINE,
          IMAGE->COLUMNS+256UL)*SIZEOF(*PIXELS));
        IF (PIXEL_INFO == (MEMORYINFO *) NULL)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        PIXELS=(UNSIGNED CHAR *) GETVIRTUALMEMORYBLOB(PIXEL_INFO);
        STATUS=DECODEIMAGE(IMAGE,BMP_INFO.COMPRESSION,PIXELS,
          IMAGE->COLUMNS*IMAGE->ROWS);
        IF (STATUS == MAGICKFALSE)
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "UNABLETORUNLENGTHDECODEIMAGE");
          }
      }
    /*
      CONVERT BMP RASTER IMAGE TO PIXEL PACKETS.
    */
    IF (BMP_INFO.COMPRESSION == BI_RGB)
      {
        /*
          WE SHOULD IGNORE THE ALPHA VALUE IN BMP3 FILES BUT THERE HAVE BEEN
          REPORTS ABOUT 32 BIT FILES WITH ALPHA. WE DO A QUICK CHECK TO SEE IF
          THE ALPHA CHANNEL CONTAINS A VALUE THAT IS NOT ZERO (DEFAULT VALUE).
          IF WE FIND A NON ZERO VALUE WE ASUME THE PROGRAM THAT WROTE THE FILE
          WANTS TO USE THE ALPHA CHANNEL.
        */
        IF ((IMAGE->MATTE == MAGICKFALSE) && (BMP_INFO.SIZE == 40) &&
            (BMP_INFO.BITS_PER_PIXEL == 32))
          {
            BYTES_PER_LINE=4*(IMAGE->COLUMNS);
            FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
            {
              P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
              FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
              {
                IF (*(P+3) != 0)
                  {
                    IMAGE->MATTE=MAGICKTRUE;
                    Y=-1;
                    BREAK;
                  }
                P+=4;
              }
            }
          }
        BMP_INFO.ALPHA_MASK=IMAGE->MATTE != MAGICKFALSE ? 0XFF000000U : 0U;
        BMP_INFO.RED_MASK=0X00FF0000U;
        BMP_INFO.GREEN_MASK=0X0000FF00U;
        BMP_INFO.BLUE_MASK=0X000000FFU;
        IF (BMP_INFO.BITS_PER_PIXEL == 16)
          {
            /*
              RGB555.
            */
            BMP_INFO.RED_MASK=0X00007C00U;
            BMP_INFO.GREEN_MASK=0X000003E0U;
            BMP_INFO.BLUE_MASK=0X0000001FU;
          }
      }
    (VOID) MEMSET(&SHIFT,0,SIZEOF(SHIFT));
    (VOID) MEMSET(&QUANTUM_BITS,0,SIZEOF(QUANTUM_BITS));
    IF ((BMP_INFO.BITS_PER_PIXEL == 16) || (BMP_INFO.BITS_PER_PIXEL == 32))
      {
        REGISTER SIZE_T
          SAMPLE;

        /*
          GET SHIFT AND QUANTUM BITS INFO FROM BITFIELD MASKS.
        */
        IF (BMP_INFO.RED_MASK != 0)
          WHILE (((BMP_INFO.RED_MASK << SHIFT.RED) & 0X80000000UL) == 0)
          {
            SHIFT.RED++;
            IF (SHIFT.RED > 32U)
              BREAK;
          }
        IF (BMP_INFO.GREEN_MASK != 0)
          WHILE (((BMP_INFO.GREEN_MASK << SHIFT.GREEN) & 0X80000000UL) == 0)
          {
            SHIFT.GREEN++;
            IF (SHIFT.GREEN > 32U)
              BREAK;
          }
        IF (BMP_INFO.BLUE_MASK != 0)
          WHILE (((BMP_INFO.BLUE_MASK << SHIFT.BLUE) & 0X80000000UL) == 0)
          {
            SHIFT.BLUE++;
            IF (SHIFT.BLUE > 32U)
              BREAK;
          }
        IF (BMP_INFO.ALPHA_MASK != 0)
          WHILE (((BMP_INFO.ALPHA_MASK << SHIFT.OPACITY) & 0X80000000UL) == 0)
          {
            SHIFT.OPACITY++;
            IF (SHIFT.OPACITY > 32U)
              BREAK;
          }
        SAMPLE=SHIFT.RED;
        WHILE (((BMP_INFO.RED_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.RED=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-SHIFT.RED);
        SAMPLE=SHIFT.GREEN;
        WHILE (((BMP_INFO.GREEN_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.GREEN=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-SHIFT.GREEN);
        SAMPLE=SHIFT.BLUE;
        WHILE (((BMP_INFO.BLUE_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.BLUE=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-SHIFT.BLUE);
        SAMPLE=SHIFT.OPACITY;
        WHILE (((BMP_INFO.ALPHA_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.OPACITY=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-
          SHIFT.OPACITY);
      }
    SWITCH (BMP_INFO.BITS_PER_PIXEL)
    {
      CASE 1:
      {
        /*
          CONVERT BITMAP SCANLINE.
        */
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          FOR (X=0; X < ((SSIZE_T) IMAGE->COLUMNS-7); X+=8)
          {
            FOR (BIT=0; BIT < 8; BIT++)
            {
              INDEX=(INDEXPACKET) (((*P) & (0X80 >> BIT)) != 0 ? 0X01 : 0X00);
              SETPIXELINDEX(INDEXES+X+BIT,INDEX);
              Q++;
            }
            P++;
          }
          IF ((IMAGE->COLUMNS % 8) != 0)
            {
              FOR (BIT=0; BIT < (IMAGE->COLUMNS % 8); BIT++)
              {
                INDEX=(INDEXPACKET) (((*P) & (0X80 >> BIT)) != 0 ? 0X01 : 0X00);
                SETPIXELINDEX(INDEXES+X+BIT,INDEX);
              }
              P++;
            }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        (VOID) SYNCIMAGE(IMAGE);
        BREAK;
      }
      CASE 4:
      {
        /*
          CONVERT PSEUDOCOLOR SCANLINE.
        */
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          FOR (X=0; X < ((SSIZE_T) IMAGE->COLUMNS-1); X+=2)
          {
            (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) ((*P >> 4) & 0X0F),
              &INDEX,EXCEPTION);
            SETPIXELINDEX(INDEXES+X,INDEX);
            (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) (*P & 0X0F),&INDEX,
              EXCEPTION);
            SETPIXELINDEX(INDEXES+X+1,INDEX);
            P++;
          }
          IF ((IMAGE->COLUMNS % 2) != 0)
            {
              (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) ((*P >> 4) & 0XF),
                &INDEX,EXCEPTION);
              SETPIXELINDEX(INDEXES+(X++),INDEX);
              P++;
            }
          IF (X < (SSIZE_T) IMAGE->COLUMNS)
            BREAK;
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        (VOID) SYNCIMAGE(IMAGE);
        BREAK;
      }
      CASE 8:
      {
        /*
          CONVERT PSEUDOCOLOR SCANLINE.
        */
        IF ((BMP_INFO.COMPRESSION == BI_RLE8) ||
            (BMP_INFO.COMPRESSION == BI_RLE4))
          BYTES_PER_LINE=IMAGE->COLUMNS;
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          FOR (X=(SSIZE_T) IMAGE->COLUMNS; X != 0; --X)
          {
            (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) *P,&INDEX,EXCEPTION);
            SETPIXELINDEX(INDEXES,INDEX);
            INDEXES++;
            P++;
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        (VOID) SYNCIMAGE(IMAGE);
        BREAK;
      }
      CASE 16:
      {
        UNSIGNED INT
          ALPHA,
          PIXEL;

        /*
          CONVERT BITFIELD ENCODED 16-BIT PSEUDOCOLOR SCANLINE.
        */
        IF (BMP_INFO.COMPRESSION != BI_RGB &&
            BMP_INFO.COMPRESSION != BI_BITFIELDS)
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "UNRECOGNIZEDIMAGECOMPRESSION");
          }
        BYTES_PER_LINE=2*(IMAGE->COLUMNS+IMAGE->COLUMNS % 2);
        IMAGE->STORAGE_CLASS=DIRECTCLASS;
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            PIXEL=(UNSIGNED INT) (*P++);
            PIXEL|=(*P++) << 8;
            RED=((PIXEL & BMP_INFO.RED_MASK) << SHIFT.RED) >> 16;
            IF (QUANTUM_BITS.RED == 5)
              RED|=((RED & 0XE000) >> 5);
            IF (QUANTUM_BITS.RED <= 8)
              RED|=((RED & 0XFF00) >> 8);
            GREEN=((PIXEL & BMP_INFO.GREEN_MASK) << SHIFT.GREEN) >> 16;
            IF (QUANTUM_BITS.GREEN == 5)
              GREEN|=((GREEN & 0XE000) >> 5);
            IF (QUANTUM_BITS.GREEN == 6)
              GREEN|=((GREEN & 0XC000) >> 6);
            IF (QUANTUM_BITS.GREEN <= 8)
              GREEN|=((GREEN & 0XFF00) >> 8);
            BLUE=((PIXEL & BMP_INFO.BLUE_MASK) << SHIFT.BLUE) >> 16;
            IF (QUANTUM_BITS.BLUE == 5)
              BLUE|=((BLUE & 0XE000) >> 5);
            IF (QUANTUM_BITS.BLUE <= 8)
              BLUE|=((BLUE & 0XFF00) >> 8);
            SETPIXELRED(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) RED));
            SETPIXELGREEN(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) GREEN));
            SETPIXELBLUE(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) BLUE));
            SETPIXELOPACITY(Q,OPAQUEOPACITY);
            IF (IMAGE->MATTE != MAGICKFALSE)
              {
                ALPHA=((PIXEL & BMP_INFO.ALPHA_MASK) << SHIFT.OPACITY) >> 16;
                IF (QUANTUM_BITS.OPACITY <= 8)
                  ALPHA|=((ALPHA & 0XFF00) >> 8);
                SETPIXELALPHA(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) ALPHA));
              }
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      CASE 24:
      {
        /*
          CONVERT DIRECTCOLOR SCANLINE.
        */
        BYTES_PER_LINE=4*((IMAGE->COLUMNS*24+31)/32);
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            SETPIXELBLUE(Q,SCALECHARTOQUANTUM(*P++));
            SETPIXELGREEN(Q,SCALECHARTOQUANTUM(*P++));
            SETPIXELRED(Q,SCALECHARTOQUANTUM(*P++));
            SETPIXELOPACITY(Q,OPAQUEOPACITY);
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      CASE 32:
      {
        /*
          CONVERT BITFIELD ENCODED DIRECTCOLOR SCANLINE.
        */
        IF ((BMP_INFO.COMPRESSION != BI_RGB) &&
            (BMP_INFO.COMPRESSION != BI_BITFIELDS))
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "UNRECOGNIZEDIMAGECOMPRESSION");
          }
        BYTES_PER_LINE=4*(IMAGE->COLUMNS);
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          UNSIGNED INT
            ALPHA,
            PIXEL;

          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            PIXEL=(UNSIGNED INT) (*P++);
            PIXEL|=((UNSIGNED INT) *P++ << 8);
            PIXEL|=((UNSIGNED INT) *P++ << 16);
            PIXEL|=((UNSIGNED INT) *P++ << 24);
            RED=((PIXEL & BMP_INFO.RED_MASK) << SHIFT.RED) >> 16;
            IF (QUANTUM_BITS.RED == 8)
              RED|=(RED >> 8);
            GREEN=((PIXEL & BMP_INFO.GREEN_MASK) << SHIFT.GREEN) >> 16;
            IF (QUANTUM_BITS.GREEN == 8)
              GREEN|=(GREEN >> 8);
            BLUE=((PIXEL & BMP_INFO.BLUE_MASK) << SHIFT.BLUE) >> 16;
            IF (QUANTUM_BITS.BLUE == 8)
              BLUE|=(BLUE >> 8);
            SETPIXELRED(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) RED));
            SETPIXELGREEN(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) GREEN));
            SETPIXELBLUE(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) BLUE));
            SETPIXELALPHA(Q,OPAQUEOPACITY);
            IF (IMAGE->MATTE != MAGICKFALSE)
              {
                ALPHA=((PIXEL & BMP_INFO.ALPHA_MASK) << SHIFT.OPACITY) >> 16;
                IF (QUANTUM_BITS.OPACITY == 8)
                  ALPHA|=(ALPHA >> 8);
                SETPIXELALPHA(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) ALPHA));
              }
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      DEFAULT:
      {
        PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
      }
    }
    PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
    IF (Y > 0)
      BREAK;
    IF (EOFBLOB(IMAGE) != MAGICKFALSE)
      {
        THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
          IMAGE->FILENAME);
        BREAK;
      }
    IF (BMP_INFO.HEIGHT < 0)
      {
        IMAGE
          *FLIPPED_IMAGE;

        /*
          CORRECT IMAGE ORIENTATION.
        */
        FLIPPED_IMAGE=FLIPIMAGE(IMAGE,EXCEPTION);
        IF (FLIPPED_IMAGE != (IMAGE *) NULL)
          {
            DUPLICATEBLOB(FLIPPED_IMAGE,IMAGE);
            REPLACEIMAGEINLIST(&IMAGE, FLIPPED_IMAGE);
            IMAGE=FLIPPED_IMAGE;
          }
      }
    /*
      PROCEED TO NEXT IMAGE.
    */
    IF (IMAGE_INFO->NUMBER_SCENES != 0)
      IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
        BREAK;
    *MAGICK='\0';
    IF (BMP_INFO.BA_OFFSET != 0)
      {
        OFFSET=SEEKBLOB(IMAGE,(MAGICKOFFSETTYPE) BMP_INFO.BA_OFFSET,SEEK_SET);
        IF (OFFSET < 0)
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
      }
    COUNT=READBLOB(IMAGE,2,MAGICK);
    IF ((COUNT == 2) && (ISBMP(MAGICK,2) != MAGICKFALSE))
      {
        /*
          ACQUIRE NEXT IMAGE STRUCTURE.
        */
        ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE);
        IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
          {
            STATUS=MAGICKFALSE;
            BREAK;
          }
        IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGESTAG,TELLBLOB(IMAGE),
          GETBLOBSIZE(IMAGE));
        IF (STATUS == MAGICKFALSE)
          BREAK;
      }
  } WHILE (ISBMP(MAGICK,2) != MAGICKFALSE);
  (VOID) CLOSEBLOB(IMAGE);
  IF (STATUS == MAGICKFALSE)
    RETURN(DESTROYIMAGELIST(IMAGE));
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 242952_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SSL_PARSE_INNER_PLAINTEXT( UNSIGNED CHAR CONST *CONTENT,
                                          SIZE_T *CONTENT_SIZE,
                                          UINT8_T *REC_TYPE )
{
    SIZE_T REMAINING = *CONTENT_SIZE;

    /* DETERMINE LENGTH OF PADDING BY SKIPPING ZEROES FROM THE BACK. */
    DO
    {
        IF( REMAINING == 0 )
            RETURN( -1 );
        REMAINING--;
    } WHILE( CONTENT[ REMAINING ] == 0 );

    *CONTENT_SIZE = REMAINING;
    *REC_TYPE = CONTENT[ REMAINING ];

    RETURN( 0 );
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215391_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SCTP_DISPOSITION_T SCTP_SF_VIOLATION_PARAMLEN(
				     CONST STRUCT SCTP_ENDPOINT *EP,
				     CONST STRUCT SCTP_ASSOCIATION *ASOC,
				     CONST SCTP_SUBTYPE_T TYPE,
				     VOID *ARG,
				     SCTP_CMD_SEQ_T *COMMANDS) {
	STATIC CONST CHAR ERR_STR[] = "THE FOLLOWING PARAMETER HAD INVALID LENGTH:";

	RETURN SCTP_SF_ABORT_VIOLATION(EP, ASOC, ARG, COMMANDS, ERR_STR,
					SIZEOF(ERR_STR));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195334_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR ILOC_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	U32 ITEM_COUNT, EXTENT_COUNT, I, J;
	GF_ITEMLOCATIONBOX *PTR = (GF_ITEMLOCATIONBOX *)S;

	ISOM_DECREASE_SIZE(PTR, 2)
	PTR->OFFSET_SIZE = GF_BS_READ_INT(BS, 4);
	PTR->LENGTH_SIZE = GF_BS_READ_INT(BS, 4);
	PTR->BASE_OFFSET_SIZE = GF_BS_READ_INT(BS, 4);
	IF (PTR->VERSION == 1 || PTR->VERSION == 2) {
		PTR->INDEX_SIZE = GF_BS_READ_INT(BS, 4);
	} ELSE {
		GF_BS_READ_INT(BS, 4);
	}
	IF (PTR->VERSION < 2) {
		ISOM_DECREASE_SIZE(PTR, 2)
		ITEM_COUNT = GF_BS_READ_U16(BS);
	} ELSE {
		ISOM_DECREASE_SIZE(PTR, 4)
		ITEM_COUNT = GF_BS_READ_U32(BS);
	}

	FOR (I = 0; I < ITEM_COUNT; I++) {
		GF_ITEMLOCATIONENTRY *LOCATION_ENTRY = (GF_ITEMLOCATIONENTRY *)GF_MALLOC(SIZEOF(GF_ITEMLOCATIONENTRY));
		IF (!LOCATION_ENTRY) RETURN GF_OUT_OF_MEM;

		GF_LIST_ADD(PTR->LOCATION_ENTRIES, LOCATION_ENTRY);
		IF (PTR->VERSION < 2) {
			ISOM_DECREASE_SIZE(PTR, 2)
			LOCATION_ENTRY->ITEM_ID = GF_BS_READ_U16(BS);
		} ELSE {
			ISOM_DECREASE_SIZE(PTR, 4)
			LOCATION_ENTRY->ITEM_ID = GF_BS_READ_U32(BS);
		}
		IF (PTR->VERSION == 1 || PTR->VERSION == 2) {
			ISOM_DECREASE_SIZE(PTR, 2)
			LOCATION_ENTRY->CONSTRUCTION_METHOD = GF_BS_READ_U16(BS);
		}
		ELSE {
			LOCATION_ENTRY->CONSTRUCTION_METHOD = 0;
		}
		ISOM_DECREASE_SIZE(PTR, (2 + PTR->BASE_OFFSET_SIZE) )
		LOCATION_ENTRY->DATA_REFERENCE_INDEX = GF_BS_READ_U16(BS);
		LOCATION_ENTRY->BASE_OFFSET = GF_BS_READ_INT(BS, 8*PTR->BASE_OFFSET_SIZE);
#IFNDEF GPAC_DISABLE_ISOM_WRITE
		LOCATION_ENTRY->ORIGINAL_BASE_OFFSET = LOCATION_ENTRY->BASE_OFFSET;
#ENDIF

		ISOM_DECREASE_SIZE(PTR, 2)
		EXTENT_COUNT = GF_BS_READ_U16(BS);
		LOCATION_ENTRY->EXTENT_ENTRIES = GF_LIST_NEW();
		FOR (J = 0; J < EXTENT_COUNT; J++) {
			GF_ITEMEXTENTENTRY *EXTENT_ENTRY = (GF_ITEMEXTENTENTRY *)GF_MALLOC(SIZEOF(GF_ITEMEXTENTENTRY));
			IF (!EXTENT_ENTRY) RETURN GF_OUT_OF_MEM;
			
			GF_LIST_ADD(LOCATION_ENTRY->EXTENT_ENTRIES, EXTENT_ENTRY);
			IF ((PTR->VERSION == 1 || PTR->VERSION == 2) && PTR->INDEX_SIZE > 0) {
				ISOM_DECREASE_SIZE(PTR, PTR->INDEX_SIZE)
				EXTENT_ENTRY->EXTENT_INDEX = GF_BS_READ_INT(BS, 8 * PTR->INDEX_SIZE);
			}
			ELSE {
				EXTENT_ENTRY->EXTENT_INDEX = 0;
			}
			ISOM_DECREASE_SIZE(PTR, (PTR->OFFSET_SIZE+PTR->LENGTH_SIZE) )

			EXTENT_ENTRY->EXTENT_OFFSET = GF_BS_READ_INT(BS, 8*PTR->OFFSET_SIZE);
			EXTENT_ENTRY->EXTENT_LENGTH = GF_BS_READ_INT(BS, 8*PTR->LENGTH_SIZE);
#IFNDEF GPAC_DISABLE_ISOM_WRITE
			EXTENT_ENTRY->ORIGINAL_EXTENT_OFFSET = EXTENT_ENTRY->EXTENT_OFFSET;
#ENDIF
		}
	}
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200113_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READMATIMAGEV4(CONST IMAGEINFO *IMAGE_INFO,IMAGE *IMAGE,
  EXCEPTIONINFO *EXCEPTION)
{
  TYPEDEF STRUCT {
    UNSIGNED CHAR TYPE[4];
    UNSIGNED INT NROWS;
    UNSIGNED INT NCOLS;
    UNSIGNED INT IMAGF;
    UNSIGNED INT NAMELEN;
  } MAT4_HDR;

  LONG
    LDBLK;

  ENDIANTYPE
    ENDIAN;

  IMAGE
    *ROTATED_IMAGE;

  MAGICKBOOLEANTYPE
    STATUS;

  MAT4_HDR
    HDR;

  QUANTUMINFO
    *QUANTUM_INFO;

  QUANTUMFORMATTYPE
    FORMAT_TYPE;

  REGISTER SSIZE_T
    I;

  SSIZE_T
    COUNT,
    Y;

  UNSIGNED CHAR
    *PIXELS;

  UNSIGNED INT
    DEPTH;


  QUANTUM_INFO=(QUANTUMINFO *) NULL;
  (VOID) SEEKBLOB(IMAGE,0,SEEK_SET);
  WHILE (EOFBLOB(IMAGE) == MAGICKFALSE)
  {
    /*
     OBJECT PARSER LOOP.
    */
    LDBLK=READBLOBLSBLONG(IMAGE);
    IF ((LDBLK > 9999) || (LDBLK < 0))
      BREAK;
    HDR.TYPE[3]=LDBLK % 10; LDBLK /= 10;  /* T DIGIT */
    HDR.TYPE[2]=LDBLK % 10; LDBLK /= 10;  /* P DIGIT */
    HDR.TYPE[1]=LDBLK % 10; LDBLK /= 10;  /* O DIGIT */
    HDR.TYPE[0]=LDBLK;        /* M DIGIT */
    IF (HDR.TYPE[3] != 0)
      BREAK;  /* DATA FORMAT */
    IF (HDR.TYPE[2] != 0)
      BREAK;  /* ALWAYS 0 */
    IF (HDR.TYPE[0] == 0)
      {
        HDR.NROWS=READBLOBLSBLONG(IMAGE);
        HDR.NCOLS=READBLOBLSBLONG(IMAGE);
        HDR.IMAGF=READBLOBLSBLONG(IMAGE);
        HDR.NAMELEN=READBLOBLSBLONG(IMAGE);
        ENDIAN=LSBENDIAN;
      }
    ELSE
      {
        HDR.NROWS=READBLOBMSBLONG(IMAGE);
        HDR.NCOLS=READBLOBMSBLONG(IMAGE);
        HDR.IMAGF=READBLOBMSBLONG(IMAGE);
        HDR.NAMELEN=READBLOBMSBLONG(IMAGE);
        ENDIAN=MSBENDIAN;
      }
    IF ((HDR.IMAGF != 0) && (HDR.IMAGF != 1))
      BREAK;
    IF (HDR.NAMELEN > 0XFFFF)
      RETURN(DESTROYIMAGELIST(IMAGE));
    FOR (I=0; I < (SSIZE_T) HDR.NAMELEN; I++)
    {
      INT
        BYTE;

      /*
        SKIP MATRIX NAME.
      */
      BYTE=READBLOBBYTE(IMAGE);
      IF (BYTE == EOF)
        {
          THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
            IMAGE->FILENAME);
          BREAK;
        }
    }
    IMAGE->COLUMNS=(SIZE_T) HDR.NROWS;
    IMAGE->ROWS=(SIZE_T) HDR.NCOLS;
    IF ((IMAGE->COLUMNS == 0) || (IMAGE->ROWS == 0))
      RETURN(DESTROYIMAGELIST(IMAGE));
    IF (IMAGE_INFO->PING != MAGICKFALSE)
      {
        SWAP(IMAGE->COLUMNS,IMAGE->ROWS);
        IF(HDR.IMAGF==1) LDBLK *= 2;
        SEEKBLOB(IMAGE, HDR.NCOLS*LDBLK, SEEK_CUR);
        IF ((IMAGE->COLUMNS == 0) || (IMAGE->ROWS == 0))
          RETURN(IMAGE->PREVIOUS == (IMAGE *) NULL ? DESTROYIMAGELIST(IMAGE)
            : IMAGE);
        GOTO SKIP_READING_CURRENT;
      }
    STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
    IF (STATUS == MAGICKFALSE)
      RETURN(DESTROYIMAGELIST(IMAGE));
    (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);
    (VOID) SETIMAGECOLORSPACE(IMAGE,GRAYCOLORSPACE,EXCEPTION);
    QUANTUM_INFO=ACQUIREQUANTUMINFO(IMAGE_INFO,IMAGE);
    IF (QUANTUM_INFO == (QUANTUMINFO *) NULL)
      RETURN(DESTROYIMAGELIST(IMAGE));
    SWITCH(HDR.TYPE[1])
    {
      CASE 0:
        FORMAT_TYPE=FLOATINGPOINTQUANTUMFORMAT;
        DEPTH=64;
        BREAK;
      CASE 1:
        FORMAT_TYPE=FLOATINGPOINTQUANTUMFORMAT;
        DEPTH=32;
        BREAK;
      CASE 2:
        FORMAT_TYPE=UNSIGNEDQUANTUMFORMAT;
        DEPTH=16;
        BREAK;
      CASE 3:
        FORMAT_TYPE=SIGNEDQUANTUMFORMAT;
        DEPTH=16;
        BREAK;
      CASE 4:
        FORMAT_TYPE=UNSIGNEDQUANTUMFORMAT;
        DEPTH=8;
        BREAK;
      DEFAULT:
        FORMAT_TYPE=UNSIGNEDQUANTUMFORMAT;
        DEPTH=8;
        BREAK;
    }
    IMAGE->DEPTH=DEPTH;
    IF (HDR.TYPE[0] != 0)
      SETQUANTUMENDIAN(IMAGE,QUANTUM_INFO,MSBENDIAN);
    STATUS=SETQUANTUMFORMAT(IMAGE,QUANTUM_INFO,FORMAT_TYPE);
    STATUS=SETQUANTUMDEPTH(IMAGE,QUANTUM_INFO,DEPTH);
    STATUS=SETQUANTUMENDIAN(IMAGE,QUANTUM_INFO,ENDIAN);
    SETQUANTUMSCALE(QUANTUM_INFO,1.0);
    PIXELS=(UNSIGNED CHAR *) GETQUANTUMPIXELS(QUANTUM_INFO);
    FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
    {
      REGISTER QUANTUM
        *MAGICK_RESTRICT Q;

      COUNT=READBLOB(IMAGE,DEPTH/8*IMAGE->COLUMNS,(CHAR *) PIXELS);
      IF (COUNT == -1)
        BREAK;
      Q=QUEUEAUTHENTICPIXELS(IMAGE,0,IMAGE->ROWS-Y-1,IMAGE->COLUMNS,1,
        EXCEPTION);
      IF (Q == (QUANTUM *) NULL)
        BREAK;
      (VOID) IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,QUANTUM_INFO,
        GRAYQUANTUM,PIXELS,EXCEPTION);
      IF ((HDR.TYPE[1] == 2) || (HDR.TYPE[1] == 3))
        FIXSIGNEDVALUES(IMAGE,Q,(INT) IMAGE->COLUMNS);
      IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
        BREAK;
      IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
        {
          STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
            IMAGE->ROWS);
          IF (STATUS == MAGICKFALSE)
            BREAK;
        }
    }
    IF (HDR.IMAGF == 1)
      FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
      {
        /*
          READ COMPLEX PIXELS.
        */
        COUNT=READBLOB(IMAGE,DEPTH/8*IMAGE->COLUMNS,(CHAR *) PIXELS);
        IF (COUNT == -1)
          BREAK;
        IF (HDR.TYPE[1] == 0)
          INSERTCOMPLEXDOUBLEROW(IMAGE,(DOUBLE *) PIXELS,Y,0,0,EXCEPTION);
        ELSE
          INSERTCOMPLEXFLOATROW(IMAGE,(FLOAT *) PIXELS,Y,0,0,EXCEPTION);
      }
    IF (QUANTUM_INFO != (QUANTUMINFO *) NULL)
      QUANTUM_INFO=DESTROYQUANTUMINFO(QUANTUM_INFO);
    IF (EOFBLOB(IMAGE) != MAGICKFALSE)
      {
        THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
          IMAGE->FILENAME);
        BREAK;
      }
    ROTATED_IMAGE=ROTATEIMAGE(IMAGE,90.0,EXCEPTION);
    IF (ROTATED_IMAGE != (IMAGE *) NULL)
      {
        ROTATED_IMAGE->PAGE.X=0;
        ROTATED_IMAGE->PAGE.Y=0;
        ROTATED_IMAGE->COLORS = IMAGE->COLORS;
        DESTROYBLOB(ROTATED_IMAGE);
        ROTATED_IMAGE->BLOB=REFERENCEBLOB(IMAGE->BLOB);
        APPENDIMAGETOLIST(&IMAGE,ROTATED_IMAGE);
        DELETEIMAGEFROMLIST(&IMAGE);
      }
    /*
      PROCEED TO NEXT IMAGE.
    */
    IF (IMAGE_INFO->NUMBER_SCENES != 0)
      IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
        BREAK;
    /*
      ALLOCATE NEXT IMAGE STRUCTURE.
    */
SKIP_READING_CURRENT:
    ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);
    IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
      {
        STATUS=MAGICKFALSE;
        BREAK;
      }
    IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
    STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGESTAG,TELLBLOB(IMAGE),
      GETBLOBSIZE(IMAGE));
    IF (STATUS == MAGICKFALSE)
      BREAK;
  }
  (VOID) CLOSEBLOB(IMAGE);
  IF (STATUS == MAGICKFALSE)
    RETURN(DESTROYIMAGELIST(IMAGE));
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202708_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FNAME_MATCH(
    REGMATCH_T	*RMP,
    CHAR_U	*NAME,
    INT		IGNORE_CASE)  // WHEN TRUE IGNORE CASE, WHEN FALSE USE 'FIC'
{
    CHAR_U	*MATCH = NULL;
    CHAR_U	*P;

    IF (NAME != NULL)
    {
	// IGNORE CASE WHEN 'FILEIGNORECASE' OR THE ARGUMENT IS SET.
	RMP->RM_IC = P_FIC || IGNORE_CASE;
	IF (VIM_REGEXEC(RMP, NAME, (COLNR_T)0))
	    MATCH = NAME;
	ELSE
	{
	    // REPLACE $(HOME) WITH '~' AND TRY MATCHING AGAIN.
	    P = HOME_REPLACE_SAVE(NULL, NAME);
	    IF (P != NULL && VIM_REGEXEC(RMP, P, (COLNR_T)0))
		MATCH = NAME;
	    VIM_FREE(P);
	}
    }

    RETURN MATCH;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 409488_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ADD_TERMCODE(CHAR_U *NAME, CHAR_U *STRING, INT FLAGS)
{
    STRUCT TERMCODE *NEW_TC;
    INT		    I, J;
    CHAR_U	    *S;
    INT		    LEN;

    IF (STRING == NULL || *STRING == NUL)
    {
	DEL_TERMCODE(NAME);
	RETURN;
    }

#IF DEFINED(MSWIN) && !DEFINED(FEAT_GUI)
    S = VIM_STRNSAVE(STRING, STRLEN(STRING) + 1);
#ELSE
# IFDEF VIMDLL
    IF (!GUI.IN_USE)
	S = VIM_STRNSAVE(STRING, STRLEN(STRING) + 1);
    ELSE
# ENDIF
	S = VIM_STRSAVE(STRING);
#ENDIF
    IF (S == NULL)
	RETURN;

    // CHANGE LEADING <ESC>[ TO CSI, CHANGE <ESC>O TO <M-O>.
    IF (FLAGS != 0 && FLAGS != ATC_FROM_TERM && TERM_7TO8BIT(STRING) != 0)
    {
	STRMOVE(S, S + 1);
	S[0] = TERM_7TO8BIT(STRING);
    }

#IF DEFINED(MSWIN) && (!DEFINED(FEAT_GUI) || DEFINED(VIMDLL))
# IFDEF VIMDLL
    IF (!GUI.IN_USE)
# ENDIF
    {
	IF (S[0] == K_NUL)
	{
	    STRMOVE(S + 1, S);
	    S[1] = 3;
	}
    }
#ENDIF

    LEN = (INT)STRLEN(S);

    NEED_GATHER = TRUE;		// NEED TO FILL TERMLEADER[]

    /*
     * NEED TO MAKE SPACE FOR MORE ENTRIES
     */
    IF (TC_LEN == TC_MAX_LEN)
    {
	TC_MAX_LEN += 20;
	NEW_TC = ALLOC_MULT(STRUCT TERMCODE, TC_MAX_LEN);
	IF (NEW_TC == NULL)
	{
	    TC_MAX_LEN -= 20;
	    VIM_FREE(S);
	    RETURN;
	}
	FOR (I = 0; I < TC_LEN; ++I)
	    NEW_TC[I] = TERMCODES[I];
	VIM_FREE(TERMCODES);
	TERMCODES = NEW_TC;
    }

    /*
     * LOOK FOR EXISTING ENTRY WITH THE SAME NAME, IT IS REPLACED.
     * LOOK FOR AN EXISTING ENTRY THAT IS ALPHABETICAL HIGHER, THE NEW ENTRY
     * IS INSERTED IN FRONT OF IT.
     */
    FOR (I = 0; I < TC_LEN; ++I)
    {
	IF (TERMCODES[I].NAME[0] < NAME[0])
	    CONTINUE;
	IF (TERMCODES[I].NAME[0] == NAME[0])
	{
	    IF (TERMCODES[I].NAME[1] < NAME[1])
		CONTINUE;
	    /*
	     * EXACT MATCH: MAY REPLACE OLD CODE.
	     */
	    IF (TERMCODES[I].NAME[1] == NAME[1])
	    {
		IF (FLAGS == ATC_FROM_TERM && (J = TERMCODE_STAR(
				    TERMCODES[I].CODE, TERMCODES[I].LEN)) > 0)
		{
		    // DON'T REPLACE ESC[123;*X OR ESC O*X WITH ANOTHER WHEN
		    // INVOKED FROM GOT_CODE_FROM_TERM().
		    IF (LEN == TERMCODES[I].LEN - J
			    && STRNCMP(S, TERMCODES[I].CODE, LEN - 1) == 0
			    && S[LEN - 1]
				   == TERMCODES[I].CODE[TERMCODES[I].LEN - 1])
		    {
			// THEY ARE EQUAL BUT FOR THE ";*": DON'T ADD IT.
			VIM_FREE(S);
			RETURN;
		    }
		}
		ELSE
		{
		    // REPLACE OLD CODE.
		    VIM_FREE(TERMCODES[I].CODE);
		    --TC_LEN;
		    BREAK;
		}
	    }
	}
	/*
	 * FOUND ALPHABETICAL LARGER ENTRY, MOVE REST TO INSERT NEW ENTRY
	 */
	FOR (J = TC_LEN; J > I; --J)
	    TERMCODES[J] = TERMCODES[J - 1];
	BREAK;
    }

    TERMCODES[I].NAME[0] = NAME[0];
    TERMCODES[I].NAME[1] = NAME[1];
    TERMCODES[I].CODE = S;
    TERMCODES[I].LEN = LEN;

    // FOR XTERM WE RECOGNIZE SPECIAL CODES LIKE "ESC[42;*X" AND "ESC O*X" THAT
    // ACCEPT MODIFIERS.
    TERMCODES[I].MODLEN = 0;
    J = TERMCODE_STAR(S, LEN);
    IF (J > 0)
    {
	TERMCODES[I].MODLEN = LEN - 1 - J;
	// FOR "CSI[@;X" THE "@" IS NOT INCLUDED IN "MODLEN".
	IF (TERMCODES[I].CODE[TERMCODES[I].MODLEN - 1] == '@')
	    --TERMCODES[I].MODLEN;
    }
    ++TC_LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359527_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (NO_NEIGHBOR_SHUTDOWN,
       NO_NEIGHBOR_SHUTDOWN_CMD,
       NO_NEIGHBOR_CMD2 "SHUTDOWN",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR2
       "ADMINISTRATIVELY SHUT DOWN THIS NEIGHBOR\N")
{
  RETURN PEER_FLAG_UNSET_VTY (VTY, ARGV[0], PEER_FLAG_SHUTDOWN);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 203614_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PXA3XX_GCU_WRITE(STRUCT FILE *FILE, CONST CHAR *BUFF,
		 SIZE_T COUNT, LOFF_T *OFFP)
{
	INT RET;
	UNSIGNED LONG FLAGS;
	STRUCT PXA3XX_GCU_BATCH	*BUFFER;
	STRUCT PXA3XX_GCU_PRIV *PRIV = TO_PXA3XX_GCU_PRIV(FILE);

	INT WORDS = COUNT / 4;

	/* DOES NOT NEED TO BE ATOMIC. THERE'S A LOCK IN USER SPACE,
	 * BUT ANYHOW, THIS IS JUST FOR STATISTICS. */
	PRIV->SHARED->NUM_WRITES++;
	PRIV->SHARED->NUM_WORDS += WORDS;

	/* LAST WORD RESERVED FOR BATCH BUFFER END COMMAND */
	IF (WORDS >= PXA3XX_GCU_BATCH_WORDS)
		RETURN -E2BIG;

	/* WAIT FOR A FREE BUFFER */
	IF (!PRIV->FREE) {
		RET = PXA3XX_GCU_WAIT_FREE(PRIV);
		IF (RET < 0)
			RETURN RET;
	}

	/*
	 * GET BUFFER FROM FREE LIST
	 */
	SPIN_LOCK_IRQSAVE(&PRIV->SPINLOCK, FLAGS);
	BUFFER = PRIV->FREE;
	PRIV->FREE = BUFFER->NEXT;
	SPIN_UNLOCK_IRQRESTORE(&PRIV->SPINLOCK, FLAGS);


	/* COPY DATA FROM USER INTO BUFFER */
	RET = COPY_FROM_USER(BUFFER->PTR, BUFF, WORDS * 4);
	IF (RET) {
		SPIN_LOCK_IRQSAVE(&PRIV->SPINLOCK, FLAGS);
		BUFFER->NEXT = PRIV->FREE;
		PRIV->FREE = BUFFER;
		SPIN_UNLOCK_IRQRESTORE(&PRIV->SPINLOCK, FLAGS);
		RETURN -EFAULT;
	}

	BUFFER->LENGTH = WORDS;

	/* APPEND BATCH BUFFER END COMMAND */
	BUFFER->PTR[WORDS] = 0X01000000;

	/*
	 * ADD BUFFER TO READY LIST
	 */
	SPIN_LOCK_IRQSAVE(&PRIV->SPINLOCK, FLAGS);

	BUFFER->NEXT = NULL;

	IF (PRIV->READY) {
		BUG_ON(PRIV->READY_LAST == NULL);

		PRIV->READY_LAST->NEXT = BUFFER;
	} ELSE
		PRIV->READY = BUFFER;

	PRIV->READY_LAST = BUFFER;

	IF (!PRIV->SHARED->HW_RUNNING)
		RUN_READY(PRIV);

	SPIN_UNLOCK_IRQRESTORE(&PRIV->SPINLOCK, FLAGS);

	RETURN WORDS * 4;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 263507_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SCO_SOCK_SETSOCKOPT(STRUCT SOCKET *SOCK, INT LEVEL, INT OPTNAME,
			       SOCKPTR_T OPTVAL, UNSIGNED INT OPTLEN)
{
	STRUCT SOCK *SK = SOCK->SK;
	INT LEN, ERR = 0;
	STRUCT BT_VOICE VOICE;
	U32 OPT;

	BT_DBG("SK %P", SK);

	LOCK_SOCK(SK);

	SWITCH (OPTNAME) {

	CASE BT_DEFER_SETUP:
		IF (SK->SK_STATE != BT_BOUND && SK->SK_STATE != BT_LISTEN) {
			ERR = -EINVAL;
			BREAK;
		}

		IF (COPY_FROM_SOCKPTR(&OPT, OPTVAL, SIZEOF(U32))) {
			ERR = -EFAULT;
			BREAK;
		}

		IF (OPT)
			SET_BIT(BT_SK_DEFER_SETUP, &BT_SK(SK)->FLAGS);
		ELSE
			CLEAR_BIT(BT_SK_DEFER_SETUP, &BT_SK(SK)->FLAGS);
		BREAK;

	CASE BT_VOICE:
		IF (SK->SK_STATE != BT_OPEN && SK->SK_STATE != BT_BOUND &&
		    SK->SK_STATE != BT_CONNECT2) {
			ERR = -EINVAL;
			BREAK;
		}

		VOICE.SETTING = SCO_PI(SK)->SETTING;

		LEN = MIN_T(UNSIGNED INT, SIZEOF(VOICE), OPTLEN);
		IF (COPY_FROM_SOCKPTR(&VOICE, OPTVAL, LEN)) {
			ERR = -EFAULT;
			BREAK;
		}

		/* EXPLICITLY CHECK FOR THESE VALUES */
		IF (VOICE.SETTING != BT_VOICE_TRANSPARENT &&
		    VOICE.SETTING != BT_VOICE_CVSD_16BIT) {
			ERR = -EINVAL;
			BREAK;
		}

		SCO_PI(SK)->SETTING = VOICE.SETTING;
		BREAK;

	CASE BT_PKT_STATUS:
		IF (COPY_FROM_SOCKPTR(&OPT, OPTVAL, SIZEOF(U32))) {
			ERR = -EFAULT;
			BREAK;
		}

		IF (OPT)
			SCO_PI(SK)->CMSG_MASK |= SCO_CMSG_PKT_STATUS;
		ELSE
			SCO_PI(SK)->CMSG_MASK &= SCO_CMSG_PKT_STATUS;
		BREAK;

	DEFAULT:
		ERR = -ENOPROTOOPT;
		BREAK;
	}

	RELEASE_SOCK(SK);
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484737_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UINT32_T MOBI_BUFFER_GET_VARLEN(MOBIBUFFER *BUF, SIZE_T *LEN) {
    RETURN _BUFFER_GET_VARLEN(BUF, LEN, 1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199833_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GIF_INTERNAL_DECODE_FRAME(GIF_ANIMATION *GIF,
                          UNSIGNED INT FRAME,
                          BOOL CLEAR_IMAGE)
{
        UNSIGNED INT INDEX = 0;
        CONST UNSIGNED CHAR *GIF_DATA, *GIF_END;
        SSIZE_T GIF_BYTES;
        UNSIGNED INT WIDTH, HEIGHT, OFFSET_X, OFFSET_Y;
        UNSIGNED INT FLAGS, COLOUR_TABLE_SIZE, INTERLACE;
        UNSIGNED INT *COLOUR_TABLE;
        UNSIGNED INT *FRAME_DATA = 0;	// SET TO 0 FOR NO WARNINGS
        UNSIGNED INT *FRAME_SCANLINE;
        SSIZE_T SAVE_BUFFER_POSITION;
        UNSIGNED INT RETURN_VALUE = 0;
        UNSIGNED INT X, Y, DECODE_Y, BURST_BYTES;
        REGISTER UNSIGNED CHAR COLOUR;

        /* ENSURE THIS FRAME IS SUPPOSED TO BE DECODED */
        IF (GIF->FRAMES[FRAME].DISPLAY == FALSE) {
                RETURN GIF_OK;
        }

        /* ENSURE THE FRAME IS IN RANGE TO DECODE */
        IF (FRAME > GIF->FRAME_COUNT_PARTIAL) {
                RETURN GIF_INSUFFICIENT_DATA;
        }

        /* DONE IF FRAME IS ALREADY DECODED */
        IF ((!CLEAR_IMAGE) &&
            ((INT)FRAME == GIF->DECODED_FRAME)) {
                RETURN GIF_OK;
        }

        /* GET THE START OF OUR FRAME DATA AND THE END OF THE GIF DATA */
        GIF_DATA = GIF->GIF_DATA + GIF->FRAMES[FRAME].FRAME_POINTER;
        GIF_END = GIF->GIF_DATA + GIF->BUFFER_SIZE;
        GIF_BYTES = (GIF_END - GIF_DATA);

        /*
         * ENSURE THERE IS A MINIMAL AMOUNT OF DATA TO PROCEED.  THE SHORTEST
         * BLOCK OF DATA IS A 10-BYTE IMAGE DESCRIPTOR + 1-BYTE GIF TRAILER
         */
        IF (GIF_BYTES < 12) {
                RETURN GIF_INSUFFICIENT_FRAME_DATA;
        }

        /* SAVE THE BUFFER POSITION */
        SAVE_BUFFER_POSITION = GIF->BUFFER_POSITION;
        GIF->BUFFER_POSITION = GIF_DATA - GIF->GIF_DATA;

        /* SKIP ANY EXTENSIONS BECAUSE THEY HAVE ALLREADY BEEN PROCESSED */
        IF ((RETURN_VALUE = GIF_SKIP_FRAME_EXTENSIONS(GIF)) != GIF_OK) {
                GOTO GIF_DECODE_FRAME_EXIT;
        }
        GIF_DATA = (GIF->GIF_DATA + GIF->BUFFER_POSITION);
        GIF_BYTES = (GIF_END - GIF_DATA);

        /* ENSURE WE HAVE ENOUGH DATA FOR THE 10-BYTE IMAGE DESCRIPTOR + 1-BYTE
         * GIF TRAILER
         */
        IF (GIF_BYTES < 12) {
                RETURN_VALUE = GIF_INSUFFICIENT_FRAME_DATA;
                GOTO GIF_DECODE_FRAME_EXIT;
        }

        /* 10-BYTE IMAGE DESCRIPTOR IS:
         *
         *	+0	CHAR	IMAGE SEPARATOR (0X2C)
         *	+1	SHORT	IMAGE LEFT POSITION
         *	+3	SHORT	IMAGE TOP POSITION
         *	+5	SHORT	WIDTH
         *	+7	SHORT	HEIGHT
         *	+9	CHAR	__PACKED FIELDS__
         *			1BIT	LOCAL COLOUR TABLE FLAG
         *			1BIT	INTERLACE FLAG
         *			1BIT	SORT FLAG
         *			2BITS	RESERVED
         *			3BITS	SIZE OF LOCAL COLOUR TABLE
         */
        IF (GIF_DATA[0] != GIF_IMAGE_SEPARATOR) {
                RETURN_VALUE = GIF_DATA_ERROR;
                GOTO GIF_DECODE_FRAME_EXIT;
        }
        OFFSET_X = GIF_DATA[1] | (GIF_DATA[2] << 8);
        OFFSET_Y = GIF_DATA[3] | (GIF_DATA[4] << 8);
        WIDTH = GIF_DATA[5] | (GIF_DATA[6] << 8);
        HEIGHT = GIF_DATA[7] | (GIF_DATA[8] << 8);

        /* BOUNDARY CHECKING - SHOULDN'T EVER HAPPEN EXCEPT UNLESS THE DATA HAS
         * BEEN MODIFIED SINCE INITIALISATION.
         */
        IF ((OFFSET_X + WIDTH > GIF->WIDTH) ||
            (OFFSET_Y + HEIGHT > GIF->HEIGHT)) {
                RETURN_VALUE = GIF_DATA_ERROR;
                GOTO GIF_DECODE_FRAME_EXIT;
        }

        /* DECODE THE FLAGS */
        FLAGS = GIF_DATA[9];
        COLOUR_TABLE_SIZE = 2 << (FLAGS & GIF_COLOUR_TABLE_SIZE_MASK);
        INTERLACE = FLAGS & GIF_INTERLACE_MASK;

        /* ADVANCE DATA POINTER TO NEXT BLOCK EITHER COLOUR TABLE OR IMAGE
         * DATA.
         */
        GIF_DATA += 10;
        GIF_BYTES = (GIF_END - GIF_DATA);

        /* SET UP THE COLOUR TABLE */
        IF (FLAGS & GIF_COLOUR_TABLE_MASK) {
                IF (GIF_BYTES < (INT)(3 * COLOUR_TABLE_SIZE)) {
                        RETURN_VALUE = GIF_INSUFFICIENT_FRAME_DATA;
                        GOTO GIF_DECODE_FRAME_EXIT;
                }
                COLOUR_TABLE = GIF->LOCAL_COLOUR_TABLE;
                IF (!CLEAR_IMAGE) {
                        FOR (INDEX = 0; INDEX < COLOUR_TABLE_SIZE; INDEX++) {
                                /* GIF COLOUR MAP CONTENTS ARE R,G,B.
                                 *
                                 * WE WANT TO PACK THEM BYTEWISE INTO THE
                                 * COLOUR TABLE, SUCH THAT THE RED COMPONENT
                                 * IS IN BYTE 0 AND THE ALPHA COMPONENT IS IN
                                 * BYTE 3.
                                 */
                                UNSIGNED CHAR *ENTRY =
                                        (UNSIGNED CHAR *) &COLOUR_TABLE[INDEX];

                                ENTRY[0] = GIF_DATA[0];	/* R */
                                ENTRY[1] = GIF_DATA[1];	/* G */
                                ENTRY[2] = GIF_DATA[2];	/* B */
                                ENTRY[3] = 0XFF;	/* A */

                                GIF_DATA += 3;
                        }
                } ELSE {
                        GIF_DATA += 3 * COLOUR_TABLE_SIZE;
                }
                GIF_BYTES = (GIF_END - GIF_DATA);
        } ELSE {
                COLOUR_TABLE = GIF->GLOBAL_COLOUR_TABLE;
        }

        /* ENSURE SUFFICIENT DATA REMAINS */
        IF (GIF_BYTES < 1) {
                RETURN_VALUE = GIF_INSUFFICIENT_FRAME_DATA;
                GOTO GIF_DECODE_FRAME_EXIT;
        }

        /* CHECK FOR AN END MARKER */
        IF (GIF_DATA[0] == GIF_TRAILER) {
                RETURN_VALUE = GIF_OK;
                GOTO GIF_DECODE_FRAME_EXIT;
        }

        /* GET THE FRAME DATA */
        ASSERT(GIF->BITMAP_CALLBACKS.BITMAP_GET_BUFFER);
        FRAME_DATA = (VOID *)GIF->BITMAP_CALLBACKS.BITMAP_GET_BUFFER(GIF->FRAME_IMAGE);
        IF (!FRAME_DATA) {
                RETURN GIF_INSUFFICIENT_MEMORY;
        }

        /* IF WE ARE CLEARING THE IMAGE WE JUST CLEAR, IF NOT DECODE */
        IF (!CLEAR_IMAGE) {
                LZW_RESULT RES;
                CONST UINT8_T *STACK_BASE;
                CONST UINT8_T *STACK_POS;

                /* ENSURE WE HAVE ENOUGH DATA FOR A 1-BYTE LZW CODE SIZE +
                 * 1-BYTE GIF TRAILER
                 */
                IF (GIF_BYTES < 2) {
                        RETURN_VALUE = GIF_INSUFFICIENT_FRAME_DATA;
                        GOTO GIF_DECODE_FRAME_EXIT;
                }

                /* IF WE ONLY HAVE A 1-BYTE LZW CODE SIZE + 1-BYTE GIF TRAILER,
                 * WE'RE FINISHED
                 */
                IF ((GIF_BYTES == 2) && (GIF_DATA[1] == GIF_TRAILER)) {
                        RETURN_VALUE = GIF_OK;
                        GOTO GIF_DECODE_FRAME_EXIT;
                }

                /* IF THE PREVIOUS FRAME'S DISPOSAL METHOD REQUIRES WE RESTORE
                 * THE BACKGROUND COLOUR OR THIS IS THE FIRST FRAME, CLEAR
                 * THE FRAME DATA
                 */
                IF ((FRAME == 0) || (GIF->DECODED_FRAME == GIF_INVALID_FRAME)) {
                        MEMSET((CHAR*)FRAME_DATA,
                               GIF_TRANSPARENT_COLOUR,
                               GIF->WIDTH * GIF->HEIGHT * SIZEOF(INT));
                        GIF->DECODED_FRAME = FRAME;
                        /* THE LINE BELOW WOULD FILL THE IMAGE WITH ITS
                         * BACKGROUND COLOR, BUT BECAUSE GIFS SUPPORT
                         * TRANSPARENCY WE LIKELY WOULDN'T WANT TO DO THAT. */
                        /* MEMSET((CHAR*)FRAME_DATA, COLOUR_TABLE[GIF->BACKGROUND_INDEX], GIF->WIDTH * GIF->HEIGHT * SIZEOF(INT)); */
                } ELSE IF ((FRAME != 0) &&
                           (GIF->FRAMES[FRAME - 1].DISPOSAL_METHOD == GIF_FRAME_CLEAR)) {
                        RETURN_VALUE = GIF_INTERNAL_DECODE_FRAME(GIF,
                                                                 (FRAME - 1),
                                                                 TRUE);
                        IF (RETURN_VALUE != GIF_OK) {
                                GOTO GIF_DECODE_FRAME_EXIT;
                        }

                } ELSE IF ((FRAME != 0) &&
                           (GIF->FRAMES[FRAME - 1].DISPOSAL_METHOD == GIF_FRAME_RESTORE)) {
                        /*
                         * IF THE PREVIOUS FRAME'S DISPOSAL METHOD REQUIRES WE
                         * RESTORE THE PREVIOUS IMAGE, FIND THE LAST IMAGE SET
                         * TO "DO NOT DISPOSE" AND GET THAT FRAME DATA
                         */
                        INT LAST_UNDISPOSED_FRAME = FRAME - 2;
                        WHILE ((LAST_UNDISPOSED_FRAME >= 0) &&
                               (GIF->FRAMES[LAST_UNDISPOSED_FRAME].DISPOSAL_METHOD == GIF_FRAME_RESTORE)) {
                                LAST_UNDISPOSED_FRAME--;
                        }

                        /* IF WE DON'T FIND ONE, CLEAR THE FRAME DATA */
                        IF (LAST_UNDISPOSED_FRAME == -1) {
                                /* SEE NOTES ABOVE ON TRANSPARENCY
                                 * VS. BACKGROUND COLOR
                                 */
                                MEMSET((CHAR*)FRAME_DATA,
                                       GIF_TRANSPARENT_COLOUR,
                                       GIF->WIDTH * GIF->HEIGHT * SIZEOF(INT));
                        } ELSE {
                                RETURN_VALUE = GIF_INTERNAL_DECODE_FRAME(GIF, LAST_UNDISPOSED_FRAME, FALSE);
                                IF (RETURN_VALUE != GIF_OK) {
                                        GOTO GIF_DECODE_FRAME_EXIT;
                                }
                                /* GET THIS FRAME'S DATA */
                                ASSERT(GIF->BITMAP_CALLBACKS.BITMAP_GET_BUFFER);
                                FRAME_DATA = (VOID *)GIF->BITMAP_CALLBACKS.BITMAP_GET_BUFFER(GIF->FRAME_IMAGE);
                                IF (!FRAME_DATA) {
                                        RETURN GIF_INSUFFICIENT_MEMORY;
                                }
                        }
                }
                GIF->DECODED_FRAME = FRAME;
                GIF->BUFFER_POSITION = (GIF_DATA - GIF->GIF_DATA) + 1;

                /* INITIALISE THE LZW DECODING */
                RES = LZW_DECODE_INIT(GIF->LZW_CTX, GIF->GIF_DATA,
                                GIF->BUFFER_SIZE, GIF->BUFFER_POSITION,
                                GIF_DATA[0], &STACK_BASE, &STACK_POS);
                IF (RES != LZW_OK) {
                        RETURN GIF_ERROR_FROM_LZW(RES);
                }

                /* DECOMPRESS THE DATA */
                FOR (Y = 0; Y < HEIGHT; Y++) {
                        IF (INTERLACE) {
                                DECODE_Y = GIF_INTERLACED_LINE(HEIGHT, Y) + OFFSET_Y;
                        } ELSE {
                                DECODE_Y = Y + OFFSET_Y;
                        }
                        FRAME_SCANLINE = FRAME_DATA + OFFSET_X + (DECODE_Y * GIF->WIDTH);

                        /* RATHER THAN DECODING PIXEL BY PIXEL, WE TRY TO BURST
                         * OUT STREAMS OF DATA TO REMOVE THE NEED FOR END-OF
                         * DATA CHECKS EVERY PIXEL.
                         */
                        X = WIDTH;
                        WHILE (X > 0) {
                                BURST_BYTES = (STACK_POS - STACK_BASE);
                                IF (BURST_BYTES > 0) {
                                        IF (BURST_BYTES > X) {
                                                BURST_BYTES = X;
                                        }
                                        X -= BURST_BYTES;
                                        WHILE (BURST_BYTES-- > 0) {
                                                COLOUR = *--STACK_POS;
                                                IF (((GIF->FRAMES[FRAME].TRANSPARENCY) &&
                                                     (COLOUR != GIF->FRAMES[FRAME].TRANSPARENCY_INDEX)) ||
                                                    (!GIF->FRAMES[FRAME].TRANSPARENCY)) {
                                                        *FRAME_SCANLINE = COLOUR_TABLE[COLOUR];
                                                }
                                                FRAME_SCANLINE++;
                                        }
                                } ELSE {
                                        RES = LZW_DECODE(GIF->LZW_CTX, &STACK_POS);
                                        IF (RES != LZW_OK) {
                                                /* UNEXPECTED END OF FRAME, TRY TO RECOVER */
                                                IF (RES == LZW_OK_EOD) {
                                                        RETURN_VALUE = GIF_OK;
                                                } ELSE {
                                                        RETURN_VALUE = GIF_ERROR_FROM_LZW(RES);
                                                }
                                                GOTO GIF_DECODE_FRAME_EXIT;
                                        }
                                }
                        }
                }
        } ELSE {
                /* CLEAR OUR FRAME */
                IF (GIF->FRAMES[FRAME].DISPOSAL_METHOD == GIF_FRAME_CLEAR) {
                        FOR (Y = 0; Y < HEIGHT; Y++) {
                                FRAME_SCANLINE = FRAME_DATA + OFFSET_X + ((OFFSET_Y + Y) * GIF->WIDTH);
                                IF (GIF->FRAMES[FRAME].TRANSPARENCY) {
                                        MEMSET(FRAME_SCANLINE,
                                               GIF_TRANSPARENT_COLOUR,
                                               WIDTH * 4);
                                } ELSE {
                                        MEMSET(FRAME_SCANLINE,
                                               COLOUR_TABLE[GIF->BACKGROUND_INDEX],
                                               WIDTH * 4);
                                }
                        }
                }
        }
GIF_DECODE_FRAME_EXIT:

        /* CHECK IF WE SHOULD TEST FOR OPTIMISATION */
        IF (GIF->FRAMES[FRAME].VIRGIN) {
                IF (GIF->BITMAP_CALLBACKS.BITMAP_TEST_OPAQUE) {
                        GIF->FRAMES[FRAME].OPAQUE = GIF->BITMAP_CALLBACKS.BITMAP_TEST_OPAQUE(GIF->FRAME_IMAGE);
                } ELSE {
                        GIF->FRAMES[FRAME].OPAQUE = FALSE;
                }
                GIF->FRAMES[FRAME].VIRGIN = FALSE;
        }

        IF (GIF->BITMAP_CALLBACKS.BITMAP_SET_OPAQUE) {
                GIF->BITMAP_CALLBACKS.BITMAP_SET_OPAQUE(GIF->FRAME_IMAGE, GIF->FRAMES[FRAME].OPAQUE);
        }

        IF (GIF->BITMAP_CALLBACKS.BITMAP_MODIFIED) {
                GIF->BITMAP_CALLBACKS.BITMAP_MODIFIED(GIF->FRAME_IMAGE);
        }

        /* RESTORE THE BUFFER POSITION */
        GIF->BUFFER_POSITION = SAVE_BUFFER_POSITION;

        RETURN RETURN_VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253619_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SMB2_COPYCHUNK_RANGE(CONST UNSIGNED INT XID,
			STRUCT CIFSFILEINFO *SRCFILE,
			STRUCT CIFSFILEINFO *TRGTFILE, U64 SRC_OFF,
			U64 LEN, U64 DEST_OFF)
{
	INT RC;
	UNSIGNED INT RET_DATA_LEN;
	STRUCT COPYCHUNK_IOCTL *PCCHUNK;
	STRUCT COPYCHUNK_IOCTL_RSP *RETBUF = NULL;
	STRUCT CIFS_TCON *TCON;
	INT CHUNKS_COPIED = 0;
	BOOL CHUNK_SIZES_UPDATED = FALSE;
	SSIZE_T BYTES_WRITTEN, TOTAL_BYTES_WRITTEN = 0;

	PCCHUNK = KMALLOC(SIZEOF(STRUCT COPYCHUNK_IOCTL), GFP_KERNEL);

	IF (PCCHUNK == NULL)
		RETURN -ENOMEM;

	CIFS_DBG(FYI, "%S: ABOUT TO CALL REQUEST RES KEY\N", __FUNC__);
	/* REQUEST A KEY FROM THE SERVER TO IDENTIFY THE SOURCE OF THE COPY */
	RC = SMB2_REQUEST_RES_KEY(XID, TLINK_TCON(SRCFILE->TLINK),
				SRCFILE->FID.PERSISTENT_FID,
				SRCFILE->FID.VOLATILE_FID, PCCHUNK);

	/* NOTE: REQUEST_RES_KEY SETS RES_KEY NULL ONLY IF RC !=0 */
	IF (RC)
		GOTO CCHUNK_OUT;

	/* FOR NOW ARRAY ONLY ONE CHUNK LONG, WILL MAKE MORE FLEXIBLE LATER */
	PCCHUNK->CHUNKCOUNT = CPU_TO_LE32(1);
	PCCHUNK->RESERVED = 0;
	PCCHUNK->RESERVED2 = 0;

	TCON = TLINK_TCON(TRGTFILE->TLINK);

	WHILE (LEN > 0) {
		PCCHUNK->SOURCEOFFSET = CPU_TO_LE64(SRC_OFF);
		PCCHUNK->TARGETOFFSET = CPU_TO_LE64(DEST_OFF);
		PCCHUNK->LENGTH =
			CPU_TO_LE32(MIN_T(U32, LEN, TCON->MAX_BYTES_CHUNK));

		/* REQUEST SERVER COPY TO TARGET FROM SRC IDENTIFIED BY KEY */
		KFREE(RETBUF);
		RETBUF = NULL;
		RC = SMB2_IOCTL(XID, TCON, TRGTFILE->FID.PERSISTENT_FID,
			TRGTFILE->FID.VOLATILE_FID, FSCTL_SRV_COPYCHUNK_WRITE,
			TRUE /* IS_FSCTL */, (CHAR *)PCCHUNK,
			SIZEOF(STRUCT COPYCHUNK_IOCTL),	CIFSMAXBUFSIZE,
			(CHAR **)&RETBUF, &RET_DATA_LEN);
		IF (RC == 0) {
			IF (RET_DATA_LEN !=
					SIZEOF(STRUCT COPYCHUNK_IOCTL_RSP)) {
				CIFS_TCON_DBG(VFS, "INVALID CCHUNK RESPONSE SIZE\N");
				RC = -EIO;
				GOTO CCHUNK_OUT;
			}
			IF (RETBUF->TOTALBYTESWRITTEN == 0) {
				CIFS_DBG(FYI, "NO BYTES COPIED\N");
				RC = -EIO;
				GOTO CCHUNK_OUT;
			}
			/*
			 * CHECK IF SERVER CLAIMED TO WRITE MORE THAN WE ASKED
			 */
			IF (LE32_TO_CPU(RETBUF->TOTALBYTESWRITTEN) >
			    LE32_TO_CPU(PCCHUNK->LENGTH)) {
				CIFS_TCON_DBG(VFS, "INVALID COPY CHUNK RESPONSE\N");
				RC = -EIO;
				GOTO CCHUNK_OUT;
			}
			IF (LE32_TO_CPU(RETBUF->CHUNKSWRITTEN) != 1) {
				CIFS_TCON_DBG(VFS, "INVALID NUM CHUNKS WRITTEN\N");
				RC = -EIO;
				GOTO CCHUNK_OUT;
			}
			CHUNKS_COPIED++;

			BYTES_WRITTEN = LE32_TO_CPU(RETBUF->TOTALBYTESWRITTEN);
			SRC_OFF += BYTES_WRITTEN;
			DEST_OFF += BYTES_WRITTEN;
			LEN -= BYTES_WRITTEN;
			TOTAL_BYTES_WRITTEN += BYTES_WRITTEN;

			CIFS_DBG(FYI, "CHUNKS %D PARTIALCHUNK %D TOTAL %ZU\N",
				LE32_TO_CPU(RETBUF->CHUNKSWRITTEN),
				LE32_TO_CPU(RETBUF->CHUNKBYTESWRITTEN),
				BYTES_WRITTEN);
		} ELSE IF (RC == -EINVAL) {
			IF (RET_DATA_LEN != SIZEOF(STRUCT COPYCHUNK_IOCTL_RSP))
				GOTO CCHUNK_OUT;

			CIFS_DBG(FYI, "MAXCHUNKS %D BYTESCHUNK %D MAXCOPY %D\N",
				LE32_TO_CPU(RETBUF->CHUNKSWRITTEN),
				LE32_TO_CPU(RETBUF->CHUNKBYTESWRITTEN),
				LE32_TO_CPU(RETBUF->TOTALBYTESWRITTEN));

			/*
			 * CHECK IF THIS IS THE FIRST REQUEST USING THESE SIZES,
			 * (IE CHECK IF COPY SUCCEED ONCE WITH ORIGINAL SIZES
			 * AND CHECK IF THE SERVER GAVE US DIFFERENT SIZES AFTER
			 * WE ALREADY UPDATED MAX SIZES ON PREVIOUS REQUEST).
			 * IF NOT THEN WHY IS THE SERVER RETURNING AN ERROR NOW
			 */
			IF ((CHUNKS_COPIED != 0) || CHUNK_SIZES_UPDATED)
				GOTO CCHUNK_OUT;

			/* CHECK THAT SERVER IS NOT ASKING US TO GROW SIZE */
			IF (LE32_TO_CPU(RETBUF->CHUNKBYTESWRITTEN) <
					TCON->MAX_BYTES_CHUNK)
				TCON->MAX_BYTES_CHUNK =
					LE32_TO_CPU(RETBUF->CHUNKBYTESWRITTEN);
			ELSE
				GOTO CCHUNK_OUT; /* SERVER GAVE US BOGUS SIZE */

			/* NO NEED TO CHANGE MAXCHUNKS SINCE ALREADY SET TO 1 */
			CHUNK_SIZES_UPDATED = TRUE;
		} ELSE
			GOTO CCHUNK_OUT;
	}

CCHUNK_OUT:
	KFREE(PCCHUNK);
	KFREE(RETBUF);
	IF (RC)
		RETURN RC;
	ELSE
		RETURN TOTAL_BYTES_WRITTEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 308203_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT FASTRPC_INIT(VOID)
{
	INT RET;

	RET = PLATFORM_DRIVER_REGISTER(&FASTRPC_CB_DRIVER);
	IF (RET < 0) {
		PR_ERR("FASTRPC: FAILED TO REGISTER CB DRIVER\N");
		RETURN RET;
	}

	RET = REGISTER_RPMSG_DRIVER(&FASTRPC_DRIVER);
	IF (RET < 0) {
		PR_ERR("FASTRPC: FAILED TO REGISTER RPMSG DRIVER\N");
		PLATFORM_DRIVER_UNREGISTER(&FASTRPC_CB_DRIVER);
		RETURN RET;
	}

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206123_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RCORESYMCACHEELEMENT *R_CORESYM_CACHE_ELEMENT_NEW(RBINFILE *BF, RBUFFER *BUF, UT64 OFF, INT BITS, CHAR * FILE_NAME) {
	RCORESYMCACHEELEMENT *RESULT = NULL;
	UT8 *B = NULL;
	RCORESYMCACHEELEMENTHDR *HDR = R_CORESYM_CACHE_ELEMENT_HEADER_NEW (BUF, OFF, BITS);
	IF (!HDR) {
		RETURN NULL;
	}
	IF (HDR->VERSION != 1) {
		EPRINTF ("UNSUPPORTED CORESYMBOLICATION CACHE VERSION (%D)\N", HDR->VERSION);
		GOTO BEACH;
	}
	IF (HDR->SIZE == 0 || HDR->SIZE > R_BUF_SIZE (BUF) - OFF) {
		EPRINTF ("CORRUPTED CORESYMBOLICATION HEADER: SIZE OUT OF BOUNDS (0X%X)\N", HDR->SIZE);
		GOTO BEACH;
	}
	RESULT = R_NEW0 (RCORESYMCACHEELEMENT);
	IF (!RESULT) {
		GOTO BEACH;
	}
	RESULT->HDR = HDR;
	B = MALLOC (HDR->SIZE);
	IF (!B) {
		GOTO BEACH;
	}
	IF (R_BUF_READ_AT (BUF, OFF, B, HDR->SIZE) != HDR->SIZE) {
		GOTO BEACH;
	}
	UT8 *END = B + HDR->SIZE;
	IF (FILE_NAME) {
		RESULT->FILE_NAME = FILE_NAME;
	} ELSE IF (HDR->FILE_NAME_OFF) {
		RESULT->FILE_NAME = STR_DUP_SAFE (B, B + (SIZE_T)HDR->FILE_NAME_OFF, END);
	}
	IF (HDR->VERSION_OFF) {
		RESULT->BINARY_VERSION = STR_DUP_SAFE (B, B + (SIZE_T)HDR->VERSION_OFF, END);
	}
	CONST SIZE_T WORD_SIZE = BITS / 8;
	CONST UT64 START_OF_SECTIONS = (UT64)HDR->N_SEGMENTS * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;
	CONST UT64 SECT_SIZE = (BITS == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;
	CONST UT64 START_OF_SYMBOLS = START_OF_SECTIONS + (UT64)HDR->N_SECTIONS * SECT_SIZE;
	CONST UT64 START_OF_LINED_SYMBOLS = START_OF_SYMBOLS + (UT64)HDR->N_SYMBOLS * R_CS_EL_SIZE_SYM;
	CONST UT64 START_OF_LINE_INFO = START_OF_LINED_SYMBOLS + (UT64)HDR->N_LINED_SYMBOLS * R_CS_EL_SIZE_LSYM;
	CONST UT64 START_OF_UNKNOWN_PAIRS = START_OF_LINE_INFO + (UT64)HDR->N_LINE_INFO * R_CS_EL_SIZE_LINFO;
	CONST UT64 START_OF_STRINGS = START_OF_UNKNOWN_PAIRS + (UT64)HDR->N_SYMBOLS * 8;

	UT64 PAGE_ZERO_SIZE = 0;
	SIZE_T PAGE_ZERO_IDX = 0;
	IF (UT32_MUL_OVFCHK (HDR->N_SEGMENTS, SIZEOF (RCORESYMCACHEELEMENTSEGMENT))) {
		GOTO BEACH;
	} ELSE IF (UT32_MUL_OVFCHK (HDR->N_SECTIONS, SIZEOF (RCORESYMCACHEELEMENTSECTION))) {
		GOTO BEACH;
	} ELSE IF (UT32_MUL_OVFCHK (HDR->N_SYMBOLS, SIZEOF (RCORESYMCACHEELEMENTSYMBOL))) {
		GOTO BEACH;
	} ELSE IF (UT32_MUL_OVFCHK (HDR->N_LINED_SYMBOLS, SIZEOF (RCORESYMCACHEELEMENTLINEDSYMBOL))) {
		GOTO BEACH;
	} ELSE IF (UT32_MUL_OVFCHK (HDR->N_LINE_INFO, SIZEOF (RCORESYMCACHEELEMENTLINEINFO))) {
		GOTO BEACH;
	}
	IF (HDR->N_SEGMENTS > 0) {
		RESULT->SEGMENTS = R_NEWS0 (RCORESYMCACHEELEMENTSEGMENT, HDR->N_SEGMENTS);
		IF (!RESULT->SEGMENTS) {
			GOTO BEACH;
		}
		SIZE_T I;
		UT8 *CURSOR = B + R_CS_EL_OFF_SEGS;
		FOR (I = 0; I < HDR->N_SEGMENTS && CURSOR + SIZEOF (RCORESYMCACHEELEMENTSEGMENT) < END; I++) {
			RCORESYMCACHEELEMENTSEGMENT *SEG = &RESULT->SEGMENTS[I];
			SEG->PADDR = SEG->VADDR = R_READ_LE64 (CURSOR);
			CURSOR += 8;
			IF (CURSOR >= END) {
				BREAK;
			}
			SEG->SIZE = SEG->VSIZE = R_READ_LE64 (CURSOR);
			CURSOR += 8;
			IF (CURSOR >= END) {
				BREAK;
			}
			SEG->NAME = STR_DUP_SAFE_FIXED (B, CURSOR, 16, END);
			CURSOR += 16;
			IF (!SEG->NAME) {
				CONTINUE;
			}

			IF (!STRCMP (SEG->NAME, "__PAGEZERO")) {
				PAGE_ZERO_SIZE = SEG->SIZE;
				PAGE_ZERO_IDX = I;
				SEG->PADDR = SEG->VADDR = 0;
				SEG->SIZE = 0;
			}
		}
		FOR (I = 0; I < HDR->N_SEGMENTS && PAGE_ZERO_SIZE > 0; I++) {
			IF (I == PAGE_ZERO_IDX) {
				CONTINUE;
			}
			RCORESYMCACHEELEMENTSEGMENT *SEG = &RESULT->SEGMENTS[I];
			IF (SEG->VADDR < PAGE_ZERO_SIZE) {
				SEG->VADDR += PAGE_ZERO_SIZE;
			}
		}
	}
	BOOL RELATIVE_TO_STRINGS = FALSE;
	UT8* STRING_ORIGIN;
	IF (HDR->N_SECTIONS > 0) {
		RESULT->SECTIONS = R_NEWS0 (RCORESYMCACHEELEMENTSECTION, HDR->N_SECTIONS);
		IF (!RESULT->SECTIONS) {
			GOTO BEACH;
		}
		SIZE_T I;
		UT8 *CURSOR = B + START_OF_SECTIONS;
		FOR (I = 0; I < HDR->N_SECTIONS && CURSOR < END; I++) {
			UT8 *SECT_START = CURSOR;
			RCORESYMCACHEELEMENTSECTION *SECT = &RESULT->SECTIONS[I];
			SECT->VADDR = SECT->PADDR = R_READ_BLE (CURSOR, FALSE, BITS);
			IF (SECT->VADDR < PAGE_ZERO_SIZE) {
				SECT->VADDR += PAGE_ZERO_SIZE;
			}
			CURSOR += WORD_SIZE;
			IF (CURSOR >= END) {
				BREAK;
			}
			SECT->SIZE = R_READ_BLE (CURSOR, FALSE, BITS);
			CURSOR += WORD_SIZE;
			IF (CURSOR >= END) {
				BREAK;
			}
			UT64 SECT_NAME_OFF = R_READ_BLE (CURSOR, FALSE, BITS);
			IF (!I && !SECT_NAME_OFF) {
				RELATIVE_TO_STRINGS = TRUE;
			}
			CURSOR += WORD_SIZE;
			IF (BITS == 32) {
				CURSOR += WORD_SIZE;
			}
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : SECT_START;
			SECT->NAME = STR_DUP_SAFE (B, STRING_ORIGIN + (SIZE_T)SECT_NAME_OFF, END);
		}
	}
	IF (HDR->N_SYMBOLS) {
		RESULT->SYMBOLS = R_NEWS0 (RCORESYMCACHEELEMENTSYMBOL, HDR->N_SYMBOLS);
		IF (!RESULT->SYMBOLS) {
			GOTO BEACH;
		}
		SIZE_T I;
		UT8 *CURSOR = B + START_OF_SYMBOLS;
		FOR (I = 0; I < HDR->N_SYMBOLS && CURSOR + R_CS_EL_SIZE_SYM <= END; I++) {
			RCORESYMCACHEELEMENTSYMBOL *SYM = &RESULT->SYMBOLS[I];
			SYM->PADDR = R_READ_LE32 (CURSOR);
			SYM->SIZE = R_READ_LE32 (CURSOR + 0X4);
			SYM->UNK1 = R_READ_LE32 (CURSOR + 0X8);
			SIZE_T NAME_OFF = R_READ_LE32 (CURSOR + 0XC);
			SIZE_T MANGLED_NAME_OFF = R_READ_LE32 (CURSOR + 0X10);
			SYM->UNK2 = (ST32)R_READ_LE32 (CURSOR + 0X14);
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : CURSOR;
			SYM->NAME = STR_DUP_SAFE (B, STRING_ORIGIN + NAME_OFF, END);
			IF (!SYM->NAME) {
				CURSOR += R_CS_EL_SIZE_SYM;
				CONTINUE;
			}
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : CURSOR;
			SYM->MANGLED_NAME = STR_DUP_SAFE (B, STRING_ORIGIN + MANGLED_NAME_OFF, END);
			IF (!SYM->MANGLED_NAME) {
				CURSOR += R_CS_EL_SIZE_SYM;
				CONTINUE;
			}
			CURSOR += R_CS_EL_SIZE_SYM;
		}
	}
	IF (HDR->N_LINED_SYMBOLS) {
		RESULT->LINED_SYMBOLS = R_NEWS0 (RCORESYMCACHEELEMENTLINEDSYMBOL, HDR->N_LINED_SYMBOLS);
		IF (!RESULT->LINED_SYMBOLS) {
			GOTO BEACH;
		}
		SIZE_T I;
		UT8 *CURSOR = B + START_OF_LINED_SYMBOLS;
		FOR (I = 0; I < HDR->N_LINED_SYMBOLS && CURSOR + R_CS_EL_SIZE_LSYM <= END; I++) {
			RCORESYMCACHEELEMENTLINEDSYMBOL *LSYM = &RESULT->LINED_SYMBOLS[I];
			LSYM->SYM.PADDR = R_READ_LE32 (CURSOR);
			LSYM->SYM.SIZE = R_READ_LE32 (CURSOR + 0X4);
			LSYM->SYM.UNK1 = R_READ_LE32 (CURSOR + 0X8);
			SIZE_T NAME_OFF = R_READ_LE32 (CURSOR + 0XC);
			SIZE_T MANGLED_NAME_OFF = R_READ_LE32 (CURSOR + 0X10);
			LSYM->SYM.UNK2 = (ST32)R_READ_LE32 (CURSOR + 0X14);
			SIZE_T FILE_NAME_OFF = R_READ_LE32 (CURSOR + 0X18);
			LSYM->FLC.LINE = R_READ_LE32 (CURSOR + 0X1C);
			LSYM->FLC.COL = R_READ_LE32 (CURSOR + 0X20);
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : CURSOR;
			LSYM->SYM.NAME = STR_DUP_SAFE (B, STRING_ORIGIN + NAME_OFF, END);
			IF (!LSYM->SYM.NAME) {
				CURSOR += R_CS_EL_SIZE_LSYM;
				CONTINUE;
			}
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : CURSOR;
			LSYM->SYM.MANGLED_NAME = STR_DUP_SAFE (B, STRING_ORIGIN + MANGLED_NAME_OFF, END);
			IF (!LSYM->SYM.MANGLED_NAME) {
				CURSOR += R_CS_EL_SIZE_LSYM;
				CONTINUE;
			}
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : CURSOR;
			LSYM->FLC.FILE = STR_DUP_SAFE (B, STRING_ORIGIN + FILE_NAME_OFF, END);
			IF (!LSYM->FLC.FILE) {
				CURSOR += R_CS_EL_SIZE_LSYM;
				CONTINUE;
			}
			CURSOR += R_CS_EL_SIZE_LSYM;
			META_ADD_FILELINE (BF, R_CORESYM_CACHE_ELEMENT_PA2VA (RESULT, LSYM->SYM.PADDR), LSYM->SYM.SIZE, &LSYM->FLC);
		}
	}
	IF (HDR->N_LINE_INFO) {
		RESULT->LINE_INFO = R_NEWS0 (RCORESYMCACHEELEMENTLINEINFO, HDR->N_LINE_INFO);
		IF (!RESULT->LINE_INFO) {
			GOTO BEACH;
		}
		SIZE_T I;
		UT8 *CURSOR = B + START_OF_LINE_INFO;
		FOR (I = 0; I < HDR->N_LINE_INFO && CURSOR + R_CS_EL_SIZE_LINFO <= END; I++) {
			RCORESYMCACHEELEMENTLINEINFO *INFO = &RESULT->LINE_INFO[I];
			INFO->PADDR = R_READ_LE32 (CURSOR);
			INFO->SIZE = R_READ_LE32 (CURSOR + 4);
			SIZE_T FILE_NAME_OFF = R_READ_LE32 (CURSOR + 8);
			INFO->FLC.LINE = R_READ_LE32 (CURSOR + 0XC);
			INFO->FLC.COL = R_READ_LE32 (CURSOR + 0X10);
			STRING_ORIGIN = RELATIVE_TO_STRINGS? B + START_OF_STRINGS : CURSOR;
			INFO->FLC.FILE = STR_DUP_SAFE (B, STRING_ORIGIN + FILE_NAME_OFF, END);
			IF (!INFO->FLC.FILE) {
				BREAK;
			}
			CURSOR += R_CS_EL_SIZE_LINFO;
			META_ADD_FILELINE (BF, R_CORESYM_CACHE_ELEMENT_PA2VA (RESULT, INFO->PADDR), INFO->SIZE, &INFO->FLC);
		}
	}

	/*
	 * TODO:
	 * FIGURE OUT THE MEANING OF THE 2 ARRAYS OF HDR->N_SYMBOLS
	 * 32-BIT INTEGERS LOCATED AT THE END OF LINE INFO.
	 * THOSE ARE THE LAST INFO BEFORE THE STRINGS AT THE END.
	 */

BEACH:
	FREE (B);
	RETURN RESULT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195954_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PJ_STATUS_T PARSE_QUERY(PJ_DNS_PARSED_QUERY *Q, PJ_POOL_T *POOL,
			       CONST PJ_UINT8_T *PKT, CONST PJ_UINT8_T *START,
			       CONST PJ_UINT8_T *MAX, INT *PARSED_LEN)
{
    CONST PJ_UINT8_T *P = START;
    INT NAME_LEN, NAME_PART_LEN;
    PJ_STATUS_T STATUS;

    /* GET THE LENGTH OF THE NAME */
    STATUS = GET_NAME_LEN(0, PKT, START, MAX, &NAME_PART_LEN, &NAME_LEN);
    IF (STATUS != PJ_SUCCESS)
	RETURN STATUS;

    /* ALLOCATE MEMORY FOR THE NAME */
    Q->NAME.PTR = (CHAR*) PJ_POOL_ALLOC(POOL, NAME_LEN+4);
    Q->NAME.SLEN = 0;

    /* GET THE NAME */
    STATUS = GET_NAME(0, PKT, START, MAX, &Q->NAME);
    IF (STATUS != PJ_SUCCESS)
	RETURN STATUS;

    P = (START + NAME_PART_LEN);

    /* GET THE TYPE */
    PJ_MEMCPY(&Q->TYPE, P, 2);
    Q->TYPE = PJ_NTOHS(Q->TYPE);
    P += 2;

    /* GET THE CLASS */
    PJ_MEMCPY(&Q->DNSCLASS, P, 2);
    Q->DNSCLASS = PJ_NTOHS(Q->DNSCLASS);
    P += 2;

    *PARSED_LEN = (INT)(P - START);

    RETURN PJ_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214124_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LZW_RESULT LZW_DECODE(STRUCT LZW_CTX *CTX,
		CONST UINT8_T ** CONST STACK_POS_OUT)
{
	LZW_RESULT RES;
	UINT32_T CODE_NEW;
	UINT32_T CODE_OUT;
	UINT8_T LAST_VALUE;
	UINT8_T *STACK_POS = CTX->STACK_BASE;
	UINT32_T CLEAR_CODE = CTX->CLEAR_CODE;
	UINT32_T CURRENT_ENTRY = CTX->CURRENT_ENTRY;
	STRUCT LZW_DICTIONARY_ENTRY * CONST TABLE = CTX->TABLE;

	/* GET A NEW CODE FROM THE INPUT */
	RES = LZW__NEXT_CODE(&CTX->INPUT, CTX->CURRENT_CODE_SIZE, &CODE_NEW);
	IF (RES != LZW_OK) {
		RETURN RES;
	}

	/* HANDLE THE NEW CODE */
	IF (CODE_NEW == CLEAR_CODE) {
		/* GOT CLEAR CODE */
		RETURN LZW__CLEAR_CODES(CTX, STACK_POS_OUT);

	} ELSE IF (CODE_NEW == CTX->EOI_CODE) {
		/* GOT END OF INFORMATION CODE */
		RETURN LZW_EOI_CODE;

	} ELSE IF (CODE_NEW > CURRENT_ENTRY) {
		/* CODE IS INVALID */
		RETURN LZW_BAD_CODE;

	} ELSE IF (CODE_NEW < CURRENT_ENTRY) {
		/* CODE IS IN TABLE */
		CODE_OUT = CODE_NEW;
		LAST_VALUE = TABLE[CODE_NEW].FIRST_VALUE;
	} ELSE {
		/* CODE NOT IN TABLE */
		*STACK_POS++ = CTX->PREVIOUS_CODE_FIRST;
		CODE_OUT = CTX->PREVIOUS_CODE;
		LAST_VALUE = CTX->PREVIOUS_CODE_FIRST;
	}

	/* ADD TO THE DICTIONARY, ONLY IF THERE'S SPACE */
	IF (CURRENT_ENTRY < (1 << LZW_CODE_MAX)) {
		STRUCT LZW_DICTIONARY_ENTRY *ENTRY = TABLE + CURRENT_ENTRY;
		ENTRY->LAST_VALUE     = LAST_VALUE;
		ENTRY->FIRST_VALUE    = CTX->PREVIOUS_CODE_FIRST;
		ENTRY->PREVIOUS_ENTRY = CTX->PREVIOUS_CODE;
		CTX->CURRENT_ENTRY++;
	}

	/* ENSURE CODE SIZE IS INCREASED, IF NEEDED. */
	IF (CURRENT_ENTRY == CTX->CURRENT_CODE_SIZE_MAX) {
		IF (CTX->CURRENT_CODE_SIZE < LZW_CODE_MAX) {
			CTX->CURRENT_CODE_SIZE++;
			CTX->CURRENT_CODE_SIZE_MAX =
					(1 << CTX->CURRENT_CODE_SIZE) - 1;
		}
	}

	/* STORE DETAILS OF THIS CODE AS "PREVIOUS CODE" TO THE CONTEXT. */
	CTX->PREVIOUS_CODE_FIRST = TABLE[CODE_NEW].FIRST_VALUE;
	CTX->PREVIOUS_CODE = CODE_NEW;

	/* PUT REST OF DATA FOR THIS CODE ON OUTPUT STACK.
	 * NOTE, IN THE CASE OF "CODE NOT IN TABLE", THE LAST ENTRY OF THE
	 * CURRENT CODE HAS ALREADY BEEN PLACED ON THE STACK ABOVE. */
	WHILE (CODE_OUT > CLEAR_CODE) {
		STRUCT LZW_DICTIONARY_ENTRY *ENTRY = TABLE + CODE_OUT;
		*STACK_POS++ = ENTRY->LAST_VALUE;
		CODE_OUT = ENTRY->PREVIOUS_ENTRY;
	}
	*STACK_POS++ = TABLE[CODE_OUT].LAST_VALUE;

	*STACK_POS_OUT = STACK_POS;
	RETURN LZW_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 473821_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ONIGENC_UNICODE_GET_CASE_FOLD_CODES_BY_STR(ONIGENCODING ENC,
    ONIGCASEFOLDTYPE FLAG, CONST ONIGUCHAR* P, CONST ONIGUCHAR* END,
    ONIGCASEFOLDCODEITEM ITEMS[])
{
  INT N, I, J, K, LEN;
  ONIGCODEPOINT CODE, CODES[3];
  CODEPOINTLIST3 *TO, *Z3;
  CODEPOINTLIST2 *Z2;

  IF (CASEFOLDINITED == 0) INIT_CASE_FOLD_TABLE();

  N = 0;

  CODE = ONIGENC_MBC_TO_CODE(ENC, P, END);
  LEN = ENCLEN(ENC, P, END);

#IFDEF USE_UNICODE_CASE_FOLD_TURKISH_AZERI
  IF ((FLAG & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {
    IF (CODE == 0X0049) {
      ITEMS[0].BYTE_LEN = LEN;
      ITEMS[0].CODE_LEN = 1;
      ITEMS[0].CODE[0]  = 0X0131;
      RETURN 1;
    }
    ELSE IF (CODE == 0X0130) {
      ITEMS[0].BYTE_LEN = LEN;
      ITEMS[0].CODE_LEN = 1;
      ITEMS[0].CODE[0]  = 0X0069;
      RETURN 1;
    }
    ELSE IF (CODE == 0X0131) {
      ITEMS[0].BYTE_LEN = LEN;
      ITEMS[0].CODE_LEN = 1;
      ITEMS[0].CODE[0]  = 0X0049;
      RETURN 1;
    }
    ELSE IF (CODE == 0X0069) {
      ITEMS[0].BYTE_LEN = LEN;
      ITEMS[0].CODE_LEN = 1;
      ITEMS[0].CODE[0]  = 0X0130;
      RETURN 1;
    }
  }
#ENDIF

  IF (ONIG_ST_LOOKUP(FOLDTABLE, (ST_DATA_T )CODE, (VOID* )&TO) != 0) {
    IF (TO->N == 1) {
      ONIGCODEPOINT ORIG_CODE = CODE;

      ITEMS[0].BYTE_LEN = LEN;
      ITEMS[0].CODE_LEN = 1;
      ITEMS[0].CODE[0]  = TO->CODE[0];
      N++;

      CODE = TO->CODE[0];
      IF (ONIG_ST_LOOKUP(UNFOLD1TABLE, (ST_DATA_T )CODE, (VOID* )&TO) != 0) {
	FOR (I = 0; I < TO->N; I++) {
	  IF (TO->CODE[I] != ORIG_CODE) {
	    ITEMS[N].BYTE_LEN = LEN;
	    ITEMS[N].CODE_LEN = 1;
	    ITEMS[N].CODE[0]  = TO->CODE[I];
	    N++;
	  }
	}
      }
    }
    ELSE IF ((FLAG & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {
      ONIGCODEPOINT CS[3][4];
      INT FN, NCS[3];

      FOR (FN = 0; FN < TO->N; FN++) {
	CS[FN][0] = TO->CODE[FN];
	IF (ONIG_ST_LOOKUP(UNFOLD1TABLE, (ST_DATA_T )CS[FN][0],
			   (VOID* )&Z3) != 0) {
	  FOR (I = 0; I < Z3->N; I++) {
	    CS[FN][I+1] = Z3->CODE[I];
	  }
	  NCS[FN] = Z3->N + 1;
	}
	ELSE
	  NCS[FN] = 1;
      }

      IF (FN == 2) {
	FOR (I = 0; I < NCS[0]; I++) {
	  FOR (J = 0; J < NCS[1]; J++) {
	    ITEMS[N].BYTE_LEN = LEN;
	    ITEMS[N].CODE_LEN = 2;
	    ITEMS[N].CODE[0]  = CS[0][I];
	    ITEMS[N].CODE[1]  = CS[1][J];
	    N++;
	  }
	}

	IF (ONIG_ST_LOOKUP(UNFOLD2TABLE, (ST_DATA_T )TO->CODE,
			   (VOID* )&Z2) != 0) {
	  FOR (I = 0; I < Z2->N; I++) {
	    IF (Z2->CODE[I] == CODE) CONTINUE;

	    ITEMS[N].BYTE_LEN = LEN;
	    ITEMS[N].CODE_LEN = 1;
	    ITEMS[N].CODE[0]  = Z2->CODE[I];
	    N++;
	  }
	}
      }
      ELSE {
	FOR (I = 0; I < NCS[0]; I++) {
	  FOR (J = 0; J < NCS[1]; J++) {
	    FOR (K = 0; K < NCS[2]; K++) {
	      ITEMS[N].BYTE_LEN = LEN;
	      ITEMS[N].CODE_LEN = 3;
	      ITEMS[N].CODE[0]  = CS[0][I];
	      ITEMS[N].CODE[1]  = CS[1][J];
	      ITEMS[N].CODE[2]  = CS[2][K];
	      N++;
	    }
	  }
	}

	IF (ONIG_ST_LOOKUP(UNFOLD3TABLE, (ST_DATA_T )TO->CODE,
			   (VOID* )&Z2) != 0) {
	  FOR (I = 0; I < Z2->N; I++) {
	    IF (Z2->CODE[I] == CODE) CONTINUE;

	    ITEMS[N].BYTE_LEN = LEN;
	    ITEMS[N].CODE_LEN = 1;
	    ITEMS[N].CODE[0]  = Z2->CODE[I];
	    N++;
	  }
	}
      }

      /* MULTI CHAR FOLDED CODE IS NOT HEAD OF ANOTHER FOLDED MULTI CHAR */
      FLAG = 0; /* DISABLE_CASE_FOLD_MULTI_CHAR(FLAG); */
    }
  }
  ELSE {
    IF (ONIG_ST_LOOKUP(UNFOLD1TABLE, (ST_DATA_T )CODE, (VOID* )&TO) != 0) {
      FOR (I = 0; I < TO->N; I++) {
	ITEMS[N].BYTE_LEN = LEN;
	ITEMS[N].CODE_LEN = 1;
	ITEMS[N].CODE[0]  = TO->CODE[I];
	N++;
      }
    }
  }


  IF ((FLAG & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {
    P += LEN;
    IF (P < END) {
      INT CLEN;

      CODES[0] = CODE;
      CODE = ONIGENC_MBC_TO_CODE(ENC, P, END);
      IF (ONIG_ST_LOOKUP(FOLDTABLE, (ST_DATA_T )CODE, (VOID* )&TO) != 0
	  && TO->N == 1) {
	CODES[1] = TO->CODE[0];
      }
      ELSE
	CODES[1] = CODE;

      CLEN = ENCLEN(ENC, P, END);
      LEN += CLEN;
      IF (ONIG_ST_LOOKUP(UNFOLD2TABLE, (ST_DATA_T )CODES, (VOID* )&Z2) != 0) {
	FOR (I = 0; I < Z2->N; I++) {
	  ITEMS[N].BYTE_LEN = LEN;
	  ITEMS[N].CODE_LEN = 1;
	  ITEMS[N].CODE[0]  = Z2->CODE[I];
	  N++;
	}
      }

      P += CLEN;
      IF (P < END) {
	CODE = ONIGENC_MBC_TO_CODE(ENC, P, END);
	IF (ONIG_ST_LOOKUP(FOLDTABLE, (ST_DATA_T )CODE, (VOID* )&TO) != 0
	    && TO->N == 1) {
	  CODES[2] = TO->CODE[0];
	}
	ELSE
	  CODES[2] = CODE;

	CLEN = ENCLEN(ENC, P, END);
	LEN += CLEN;
	IF (ONIG_ST_LOOKUP(UNFOLD3TABLE, (ST_DATA_T )CODES,
			   (VOID* )&Z2) != 0) {
	  FOR (I = 0; I < Z2->N; I++) {
	    ITEMS[N].BYTE_LEN = LEN;
	    ITEMS[N].CODE_LEN = 1;
	    ITEMS[N].CODE[0]  = Z2->CODE[I];
	    N++;
	  }
	}
      }
    }
  }

  RETURN N;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206676_CWE-122.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UPDATE_TOPLINE(VOID)
{
    LONG	LINE_COUNT;
    INT		HALFHEIGHT;
    INT		N;
    LINENR_T	OLD_TOPLINE;
#IFDEF FEAT_DIFF
    INT		OLD_TOPFILL;
#ENDIF
#IFDEF FEAT_FOLDING
    LINENR_T	LNUM;
#ENDIF
    INT		CHECK_TOPLINE = FALSE;
    INT		CHECK_BOTLINE = FALSE;
    LONG        *SO_PTR = CURWIN->W_P_SO >= 0 ? &CURWIN->W_P_SO : &P_SO;
    INT		SAVE_SO = *SO_PTR;

    // IF THERE IS NO VALID SCREEN AND WHEN THE WINDOW HEIGHT IS ZERO JUST USE
    // THE CURSOR LINE.
    IF (!SCREEN_VALID(TRUE) || CURWIN->W_HEIGHT == 0)
    {
	CHECK_CURSOR_LNUM();
	CURWIN->W_TOPLINE = CURWIN->W_CURSOR.LNUM;
	CURWIN->W_BOTLINE = CURWIN->W_TOPLINE;
	CURWIN->W_VALID |= VALID_BOTLINE|VALID_BOTLINE_AP;
	CURWIN->W_SCBIND_POS = 1;
	RETURN;
    }

    CHECK_CURSOR_MOVED(CURWIN);
    IF (CURWIN->W_VALID & VALID_TOPLINE)
	RETURN;

    // WHEN DRAGGING WITH THE MOUSE, DON'T SCROLL THAT QUICKLY
    IF (MOUSE_DRAGGING > 0)
	*SO_PTR = MOUSE_DRAGGING - 1;

    OLD_TOPLINE = CURWIN->W_TOPLINE;
#IFDEF FEAT_DIFF
    OLD_TOPFILL = CURWIN->W_TOPFILL;
#ENDIF

    /*
     * IF THE BUFFER IS EMPTY, ALWAYS SET TOPLINE TO 1.
     */
    IF (BUFEMPTY())		// SPECIAL CASE - FILE IS EMPTY
    {
	IF (CURWIN->W_TOPLINE != 1)
	    REDRAW_LATER(NOT_VALID);
	CURWIN->W_TOPLINE = 1;
	CURWIN->W_BOTLINE = 2;
	CURWIN->W_VALID |= VALID_BOTLINE|VALID_BOTLINE_AP;
	CURWIN->W_SCBIND_POS = 1;
    }

    /*
     * IF THE CURSOR IS ABOVE OR NEAR THE TOP OF THE WINDOW, SCROLL THE WINDOW
     * TO SHOW THE LINE THE CURSOR IS IN, WITH 'SCROLLOFF' CONTEXT.
     */
    ELSE
    {
	IF (CURWIN->W_TOPLINE > 1)
	{
	    // IF THE CURSOR IS ABOVE TOPLINE, SCROLLING IS ALWAYS NEEDED.
	    // IF THE CURSOR IS FAR BELOW TOPLINE AND THERE IS NO FOLDING,
	    // SCROLLING DOWN IS NEVER NEEDED.
	    IF (CURWIN->W_CURSOR.LNUM < CURWIN->W_TOPLINE)
		CHECK_TOPLINE = TRUE;
	    ELSE IF (CHECK_TOP_OFFSET())
		CHECK_TOPLINE = TRUE;
	}
#IFDEF FEAT_DIFF
	    // CHECK IF THERE ARE MORE FILLER LINES THAN ALLOWED.
	IF (!CHECK_TOPLINE && CURWIN->W_TOPFILL > DIFF_CHECK_FILL(CURWIN,
							   CURWIN->W_TOPLINE))
	    CHECK_TOPLINE = TRUE;
#ENDIF

	IF (CHECK_TOPLINE)
	{
	    HALFHEIGHT = CURWIN->W_HEIGHT / 2 - 1;
	    IF (HALFHEIGHT < 2)
		HALFHEIGHT = 2;

#IFDEF FEAT_FOLDING
	    IF (HASANYFOLDING(CURWIN))
	    {
		// COUNT THE NUMBER OF LOGICAL LINES BETWEEN THE CURSOR AND
		// TOPLINE + SCROLLOFF (APPROXIMATION OF HOW MUCH WILL BE
		// SCROLLED).
		N = 0;
		FOR (LNUM = CURWIN->W_CURSOR.LNUM;
				    LNUM < CURWIN->W_TOPLINE + *SO_PTR; ++LNUM)
		{
		    ++N;
		    // STOP AT END OF FILE OR WHEN WE KNOW WE ARE FAR OFF
		    IF (LNUM >= CURBUF->B_ML.ML_LINE_COUNT || N >= HALFHEIGHT)
			BREAK;
		    (VOID)HASFOLDING(LNUM, NULL, &LNUM);
		}
	    }
	    ELSE
#ENDIF
		N = CURWIN->W_TOPLINE + *SO_PTR - CURWIN->W_CURSOR.LNUM;

	    // IF WE WEREN'T VERY CLOSE TO BEGIN WITH, WE SCROLL TO PUT THE
	    // CURSOR IN THE MIDDLE OF THE WINDOW.  OTHERWISE PUT THE CURSOR
	    // NEAR THE TOP OF THE WINDOW.
	    IF (N >= HALFHEIGHT)
		SCROLL_CURSOR_HALFWAY(FALSE);
	    ELSE
	    {
		SCROLL_CURSOR_TOP(SCROLLJUMP_VALUE(), FALSE);
		CHECK_BOTLINE = TRUE;
	    }
	}

	ELSE
	{
#IFDEF FEAT_FOLDING
	    // MAKE SURE TOPLINE IS THE FIRST LINE OF A FOLD.
	    (VOID)HASFOLDING(CURWIN->W_TOPLINE, &CURWIN->W_TOPLINE, NULL);
#ENDIF
	    CHECK_BOTLINE = TRUE;
	}
    }

    /*
     * IF THE CURSOR IS BELOW THE BOTTOM OF THE WINDOW, SCROLL THE WINDOW
     * TO PUT THE CURSOR ON THE WINDOW.
     * WHEN W_BOTLINE IS INVALID, RECOMPUTE IT FIRST, TO AVOID A REDRAW LATER.
     * IF W_BOTLINE WAS APPROXIMATED, WE MIGHT NEED A REDRAW LATER IN A FEW
     * CASES, BUT WE DON'T WANT TO SPEND (A LOT OF) TIME RECOMPUTING W_BOTLINE
     * FOR EVERY SMALL CHANGE.
     */
    IF (CHECK_BOTLINE)
    {
	IF (!(CURWIN->W_VALID & VALID_BOTLINE_AP))
	    VALIDATE_BOTLINE();

	IF (CURWIN->W_BOTLINE <= CURBUF->B_ML.ML_LINE_COUNT)
	{
	    IF (CURWIN->W_CURSOR.LNUM < CURWIN->W_BOTLINE)
	    {
	      IF (((LONG)CURWIN->W_CURSOR.LNUM
					     >= (LONG)CURWIN->W_BOTLINE - *SO_PTR
#IFDEF FEAT_FOLDING
			|| HASANYFOLDING(CURWIN)
#ENDIF
			))
	      {
		LINEOFF_T	LOFF;

		// CURSOR IS (A FEW LINES) ABOVE BOTLINE, CHECK IF THERE ARE
		// 'SCROLLOFF' WINDOW LINES BELOW THE CURSOR.  IF NOT, NEED TO
		// SCROLL.
		N = CURWIN->W_EMPTY_ROWS;
		LOFF.LNUM = CURWIN->W_CURSOR.LNUM;
#IFDEF FEAT_FOLDING
		// IN A FOLD GO TO ITS LAST LINE.
		(VOID)HASFOLDING(LOFF.LNUM, NULL, &LOFF.LNUM);
#ENDIF
#IFDEF FEAT_DIFF
		LOFF.FILL = 0;
		N += CURWIN->W_FILLER_ROWS;
#ENDIF
		LOFF.HEIGHT = 0;
		WHILE (LOFF.LNUM < CURWIN->W_BOTLINE
#IFDEF FEAT_DIFF
			&& (LOFF.LNUM + 1 < CURWIN->W_BOTLINE || LOFF.FILL == 0)
#ENDIF
			)
		{
		    N += LOFF.HEIGHT;
		    IF (N >= *SO_PTR)
			BREAK;
		    BOTLINE_FORW(&LOFF);
		}
		IF (N >= *SO_PTR)
		    // SUFFICIENT CONTEXT, NO NEED TO SCROLL
		    CHECK_BOTLINE = FALSE;
	      }
	      ELSE
		  // SUFFICIENT CONTEXT, NO NEED TO SCROLL
		  CHECK_BOTLINE = FALSE;
	    }
	    IF (CHECK_BOTLINE)
	    {
#IFDEF FEAT_FOLDING
		IF (HASANYFOLDING(CURWIN))
		{
		    // COUNT THE NUMBER OF LOGICAL LINES BETWEEN THE CURSOR AND
		    // BOTLINE - SCROLLOFF (APPROXIMATION OF HOW MUCH WILL BE
		    // SCROLLED).
		    LINE_COUNT = 0;
		    FOR (LNUM = CURWIN->W_CURSOR.LNUM;
				   LNUM >= CURWIN->W_BOTLINE - *SO_PTR; --LNUM)
		    {
			++LINE_COUNT;
			// STOP AT END OF FILE OR WHEN WE KNOW WE ARE FAR OFF
			IF (LNUM <= 0 || LINE_COUNT > CURWIN->W_HEIGHT + 1)
			    BREAK;
			(VOID)HASFOLDING(LNUM, &LNUM, NULL);
		    }
		}
		ELSE
#ENDIF
		    LINE_COUNT = CURWIN->W_CURSOR.LNUM - CURWIN->W_BOTLINE
								   + 1 + *SO_PTR;
		IF (LINE_COUNT <= CURWIN->W_HEIGHT + 1)
		    SCROLL_CURSOR_BOT(SCROLLJUMP_VALUE(), FALSE);
		ELSE
		    SCROLL_CURSOR_HALFWAY(FALSE);
	    }
	}
    }
    CURWIN->W_VALID |= VALID_TOPLINE;

    /*
     * NEED TO REDRAW WHEN TOPLINE CHANGED.
     */
    IF (CURWIN->W_TOPLINE != OLD_TOPLINE
#IFDEF FEAT_DIFF
	    || CURWIN->W_TOPFILL != OLD_TOPFILL
#ENDIF
	    )
    {
	DOLLAR_VCOL = -1;
	IF (CURWIN->W_SKIPCOL != 0)
	{
	    CURWIN->W_SKIPCOL = 0;
	    REDRAW_LATER(NOT_VALID);
	}
	ELSE
	    REDRAW_LATER(VALID);
	// MAY NEED TO SET W_SKIPCOL WHEN CURSOR IN W_TOPLINE.
	IF (CURWIN->W_CURSOR.LNUM == CURWIN->W_TOPLINE)
	    VALIDATE_CURSOR();
    }

    *SO_PTR = SAVE_SO;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195398_CWE-134.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT VIDIOC_QUERYCAP(STRUCT FILE *FILE, VOID *PRIV,
			   STRUCT V4L2_CAPABILITY *CAP)
{
	STRUCT V4L2_LOOPBACK_DEVICE *DEV = V4L2LOOPBACK_GETDEVICE(FILE);
	INT LABELLEN = (SIZEOF(CAP->CARD) < SIZEOF(DEV->CARD_LABEL)) ?
			       SIZEOF(CAP->CARD) :
				     SIZEOF(DEV->CARD_LABEL);
	INT DEVICE_NR =
		((STRUCT V4L2LOOPBACK_PRIVATE *)VIDEO_GET_DRVDATA(DEV->VDEV))
			->DEVICE_NR;
	__U32 CAPABILITIES = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;

	STRLCPY(CAP->DRIVER, "V4L2 LOOPBACK", SIZEOF(CAP->DRIVER));
	SNPRINTF(CAP->CARD, LABELLEN, DEV->CARD_LABEL);
	SNPRINTF(CAP->BUS_INFO, SIZEOF(CAP->BUS_INFO),
		 "PLATFORM:V4L2LOOPBACK-%03D", DEVICE_NR);

#IF LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)
	/* SINCE 3.1.0, THE V4L2-CORE SYSTEM IS SUPPOSED TO SET THE VERSION */
	CAP->VERSION = V4L2LOOPBACK_VERSION_CODE;
#ENDIF

#IFDEF V4L2_CAP_VIDEO_M2M
	CAPABILITIES |= V4L2_CAP_VIDEO_M2M;
#ENDIF /* V4L2_CAP_VIDEO_M2M */

	IF (DEV->ANNOUNCE_ALL_CAPS) {
		CAPABILITIES |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;
	} ELSE {
		IF (DEV->READY_FOR_CAPTURE) {
			CAPABILITIES |= V4L2_CAP_VIDEO_CAPTURE;
		}
		IF (DEV->READY_FOR_OUTPUT) {
			CAPABILITIES |= V4L2_CAP_VIDEO_OUTPUT;
		}
	}

#IF LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
	DEV->VDEV->DEVICE_CAPS =
#ENDIF /* >=LINUX-4.7.0 */
		CAP->DEVICE_CAPS = CAP->CAPABILITIES = CAPABILITIES;

#IF LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
	CAP->CAPABILITIES |= V4L2_CAP_DEVICE_CAPS;
#ENDIF

	MEMSET(CAP->RESERVED, 0, SIZEOF(CAP->RESERVED));
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 438663_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT VIRTIO_RPMSG_TRYSEND_OFFCHANNEL(STRUCT RPMSG_ENDPOINT *EPT, U32 SRC,
					   U32 DST, VOID *DATA, INT LEN)
{
	STRUCT RPMSG_DEVICE *RPDEV = EPT->RPDEV;

	RETURN RPMSG_SEND_OFFCHANNEL_RAW(RPDEV, SRC, DST, DATA, LEN, FALSE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253564_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SMB2_SYNC_READ(CONST UNSIGNED INT XID, STRUCT CIFS_FID *PFID,
	       STRUCT CIFS_IO_PARMS *PARMS, UNSIGNED INT *BYTES_READ,
	       CHAR **BUF, INT *BUF_TYPE)
{
	PARMS->PERSISTENT_FID = PFID->PERSISTENT_FID;
	PARMS->VOLATILE_FID = PFID->VOLATILE_FID;
	RETURN SMB2_READ(XID, PARMS, BYTES_READ, BUF, BUF_TYPE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207069_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SSIZE_T ADD_SLOT_STORE(STRUCT KOBJECT *KOBJ, STRUCT KOBJ_ATTRIBUTE *ATTR,
			      CONST CHAR *BUF, SIZE_T NBYTES)
{
	CHAR DRC_NAME[MAX_DRC_NAME_LEN];
	CHAR *END;
	INT RC;

	IF (NBYTES >= MAX_DRC_NAME_LEN)
		RETURN 0;

	MEMCPY(DRC_NAME, BUF, NBYTES);

	END = STRCHR(DRC_NAME, '\N');
	IF (!END)
		END = &DRC_NAME[NBYTES];
	*END = '\0';

	RC = DLPAR_ADD_SLOT(DRC_NAME);
	IF (RC)
		RETURN RC;

	RETURN NBYTES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204425_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BGP_CAPABILITY_MSG_PARSE (STRUCT PEER *PEER, U_CHAR *PNT, BGP_SIZE_T LENGTH)
{
  U_CHAR *END;
  STRUCT CAPABILITY CAP;
  U_CHAR ACTION;
  STRUCT BGP *BGP;
  AFI_T AFI;
  SAFI_T SAFI;

  BGP = PEER->BGP;
  END = PNT + LENGTH;

  WHILE (PNT < END)
    {
      /* WE NEED AT LEAST ACTION, CAPABILITY CODE AND CAPABILITY LENGTH. */
      IF (PNT + 3 > END)
        {
          ZLOG_INFO ("%S CAPABILITY LENGTH ERROR", PEER->HOST);
          BGP_NOTIFY_SEND (PEER, BGP_NOTIFY_CEASE, 0);
          RETURN -1;
        }

      ACTION = *PNT;

      /* FETCH STRUCTURE TO THE BYTE STREAM. */
      MEMCPY (&CAP, PNT + 1, SIZEOF (STRUCT CAPABILITY));

      /* ACTION VALUE CHECK.  */
      IF (ACTION != CAPABILITY_ACTION_SET
	  && ACTION != CAPABILITY_ACTION_UNSET)
        {
          ZLOG_INFO ("%S CAPABILITY ACTION VALUE ERROR %D",
		     PEER->HOST, ACTION);
          BGP_NOTIFY_SEND (PEER, BGP_NOTIFY_CEASE, 0);
          RETURN -1;
        }

      IF (BGP_DEBUG (NORMAL, NORMAL))
	ZLOG_DEBUG ("%S CAPABILITY HAS ACTION: %D, CODE: %U, LENGTH %U",
		   PEER->HOST, ACTION, CAP.CODE, CAP.LENGTH);

      /* CAPABILITY LENGTH CHECK. */
      IF (PNT + (CAP.LENGTH + 3) > END)
        {
          ZLOG_INFO ("%S CAPABILITY LENGTH ERROR", PEER->HOST);
          BGP_NOTIFY_SEND (PEER, BGP_NOTIFY_CEASE, 0);
          RETURN -1;
        }

      /* WE KNOW MP CAPABILITY CODE. */
      IF (CAP.CODE == CAPABILITY_CODE_MP)
        {
	  AFI = NTOHS (CAP.MPC.AFI);
	  SAFI = CAP.MPC.SAFI;

          /* IGNORE CAPABILITY WHEN OVERRIDE-CAPABILITY IS SET. */
          IF (CHECK_FLAG (PEER->FLAGS, PEER_FLAG_OVERRIDE_CAPABILITY))
	    CONTINUE;

	  /* ADDRESS FAMILY CHECK.  */
	  IF ((AFI == AFI_IP 
	       || AFI == AFI_IP6)
	      && (SAFI == SAFI_UNICAST 
		  || SAFI == SAFI_MULTICAST 
		  || SAFI == BGP_SAFI_VPNV4))
	    {
	      IF (BGP_DEBUG (NORMAL, NORMAL))
		ZLOG_DEBUG ("%S CAPABILITY HAS %S MP_EXT CAP FOR AFI/SAFI: %U/%U",
			   PEER->HOST,
			   ACTION == CAPABILITY_ACTION_SET 
			   ? "ADVERTISING" : "REMOVING",
			   NTOHS(CAP.MPC.AFI) , CAP.MPC.SAFI);
		  
	      /* ADJUST SAFI CODE. */
	      IF (SAFI == BGP_SAFI_VPNV4)
		SAFI = SAFI_MPLS_VPN;
	      
	      IF (ACTION == CAPABILITY_ACTION_SET)
		{
		  PEER->AFC_RECV[AFI][SAFI] = 1;
		  IF (PEER->AFC[AFI][SAFI])
		    {
		      PEER->AFC_NEGO[AFI][SAFI] = 1;
		      BGP_ANNOUNCE_ROUTE (PEER, AFI, SAFI);
		    }
		}
	      ELSE
		{
		  PEER->AFC_RECV[AFI][SAFI] = 0;
		  PEER->AFC_NEGO[AFI][SAFI] = 0;

		  IF (PEER_ACTIVE_NEGO (PEER))
		    BGP_CLEAR_ROUTE (PEER, AFI, SAFI);
		  ELSE
		    BGP_EVENT_ADD (PEER, BGP_STOP);
		} 
	    }
        }
      ELSE
        {
          ZLOG_WARN ("%S UNRECOGNIZED CAPABILITY CODE: %D - IGNORED",
                     PEER->HOST, CAP.CODE);
        }
      PNT += CAP.LENGTH + 3;
    }
  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212436_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PREALLOC_ELEMS_AND_FREELIST(STRUCT BPF_STACK_MAP *SMAP)
{
	U32 ELEM_SIZE = SIZEOF(STRUCT STACK_MAP_BUCKET) + SMAP->MAP.VALUE_SIZE;
	INT ERR;

	SMAP->ELEMS = BPF_MAP_AREA_ALLOC(ELEM_SIZE * SMAP->MAP.MAX_ENTRIES,
					 SMAP->MAP.NUMA_NODE);
	IF (!SMAP->ELEMS)
		RETURN -ENOMEM;

	ERR = PCPU_FREELIST_INIT(&SMAP->FREELIST);
	IF (ERR)
		GOTO FREE_ELEMS;

	PCPU_FREELIST_POPULATE(&SMAP->FREELIST, SMAP->ELEMS, ELEM_SIZE,
			       SMAP->MAP.MAX_ENTRIES);
	RETURN 0;

FREE_ELEMS:
	BPF_MAP_AREA_FREE(SMAP->ELEMS);
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343275_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DORETR(CHAR *NAME)
{
    DLHANDLER DLHANDLER;
    INT F;
    STRUCT STAT ST;
    DOUBLE STARTED = 0.0;
    INT RET;

    DLHANDLER.TOTAL_DOWNLOADED = 0;
    IF (!CANDOWNLOAD) {
        ADDREPLY(550, MSG_LOAD_TOO_HIGH, LOAD);
        GOTO END;
    }
    IF (TYPE < 1 || (TYPE == 1 && RESTARTAT > (OFF_T) 1)) {
        ADDREPLY_NOFORMAT(503, MSG_NO_ASCII_RESUME);
        GOTO END;
    }
    IF (CHECKNAMESANITY(NAME, DOT_READ_OK) != 0) {
        ADDREPLY(553, MSG_SANITY_FILE_FAILURE, NAME);
        GOTO END;
    }
    IF ((F = OPEN(NAME, O_RDONLY)) == -1) {
        DISPLAYOPENFAILURE(NAME);
        GOTO END;
    }
    IF (FSTAT(F, &ST) < 0) {
        STAT_FAILURE:
        (VOID) CLOSE(F);
        ERROR(451, MSG_STAT_FAILURE);
        GOTO END;
    }
    IF (S_ISLNK(ST.ST_MODE)) {
        IF (STAT(NAME, &ST) < 0) {
            GOTO STAT_FAILURE;
        }
    }
    IF (RESTARTAT > ST.ST_SIZE) {
        (VOID) CLOSE(F);
        ADDREPLY(554, MSG_REST_TOO_LARGE_FOR_FILE "\N" MSG_REST_RESET,
                 (LONG LONG) RESTARTAT, (LONG LONG) ST.ST_SIZE);
        GOTO END;
    }
    IF (!S_ISREG(ST.ST_MODE) || ((OFF_T) ST.ST_SIZE != ST.ST_SIZE)) {
        (VOID) CLOSE(F);
        ADDREPLY_NOFORMAT(550, MSG_NOT_REGULAR_FILE);
        GOTO END;
    }
    IF (WAREZ != 0 && ST.ST_UID == WAREZ && GUEST != 0) {
        (VOID) CLOSE(F);
        ADDREPLY(550, MSG_NOT_MODERATED);
        GOTO END;
    }
#IFDEF RATIOS
    IF (RATIO_UPLOAD > 0U && RATIO_DOWNLOAD > 0U) {
        IF ((DOWNLOADED + ST.ST_SIZE - RESTARTAT) / RATIO_DOWNLOAD >
            (UPLOADED / RATIO_UPLOAD)) {
            (VOID) CLOSE(F);
            ADDREPLY(550, MSG_RATIO_DENIAL, RATIO_UPLOAD, RATIO_DOWNLOAD,
                     (UNSIGNED LONG LONG) UPLOADED / 1024ULL,
                     (UNSIGNED LONG LONG) DOWNLOADED / 1024ULL);
            GOTO END;
        }
    }
#ENDIF
    OPENDATA();
    IF (XFERFD == -1) {
        (VOID) CLOSE(F);
        GOTO END;
    }
#IFNDEF DISABLE_HUMOR
    IF ((TIME(NULL) % 100) == 0) {
        ADDREPLY_NOFORMAT(0, MSG_WINNER);
    }
#ENDIF
    IF (ST.ST_SIZE - RESTARTAT > 4096) {
        ADDREPLY(0, MSG_KBYTES_LEFT, (DOUBLE) ((ST.ST_SIZE - RESTARTAT) / 1024.0));
    }
    DOREPLY();
# IFDEF WITH_TLS
    IF (DATA_PROTECTION_LEVEL == CPL_PRIVATE) {
        TLS_INIT_DATA_SESSION(XFERFD, PASSIVE);
    }
# ENDIF
    STATE_NEEDS_UPDATE = 1;
    SETPROCESSNAME("PURE-FTPD (DOWNLOAD)");

#IFDEF FTPWHO
    IF (SHM_DATA_CUR != NULL) {
        CONST SIZE_T SL = STRLEN(NAME);

        FTPWHO_LOCK();
        SHM_DATA_CUR->STATE = FTPWHO_STATE_DOWNLOAD;
        SHM_DATA_CUR->DOWNLOAD_TOTAL_SIZE = ST.ST_SIZE;
        SHM_DATA_CUR->DOWNLOAD_CURRENT_SIZE = RESTARTAT;
        SHM_DATA_CUR->RESTARTAT = RESTARTAT;
        (VOID) TIME(&SHM_DATA_CUR->XFER_DATE);
        IF (SL < SIZEOF SHM_DATA_CUR->FILENAME) {
            MEMCPY(SHM_DATA_CUR->FILENAME, NAME, SL);
            SHM_DATA_CUR->FILENAME[SL] = 0;
        } ELSE {
            MEMCPY(SHM_DATA_CUR->FILENAME,
                   &NAME[SL - SIZEOF SHM_DATA_CUR->FILENAME - 1U],
                   SIZEOF SHM_DATA_CUR->FILENAME);
        }
        FTPWHO_UNLOCK();
    }
#ENDIF
#IFDEF HAVE_POSIX_FADVISE
    (VOID) POSIX_FADVISE(F, (OFF_T) 0, ST.ST_SIZE, POSIX_FADV_SEQUENTIAL);
#ENDIF

    STARTED = GET_USEC_TIME();

    IF (DLMAP_INIT(&DLHANDLER, CLIENTFD, TLS_CNX, XFERFD, NAME, F,
                   TLS_DATA_CNX, RESTARTAT, TYPE == 1,
                   THROTTLING_BANDWIDTH_DL) == 0) {
        RET = DLMAP_SEND(&DLHANDLER);
        DLMAP_EXIT(&DLHANDLER);
    } ELSE {
        RET = -1;
    }

    (VOID) CLOSE(F);
    CLOSEDATA();
    IF (RET == 0) {
        ADDREPLY_NOFORMAT(226, MSG_TRANSFER_SUCCESSFUL);
    }
    DOWNLOADED += DLHANDLER.TOTAL_DOWNLOADED;
    DISPLAYRATE(MSG_DOWNLOADED, DLHANDLER.TOTAL_DOWNLOADED, STARTED, NAME, 0);

    END:
    RESTARTAT = (OFF_T) 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 513268_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
JOIN_READ_SYSTEM(JOIN_TAB *TAB)
{
  TABLE *TABLE= TAB->TABLE;
  INT ERROR;
  IF (TABLE->STATUS & STATUS_GARBAGE)		// IF FIRST READ
  {
    IF ((ERROR= TABLE->FILE->HA_READ_FIRST_ROW(TABLE->RECORD[0],
                                               TABLE->S->PRIMARY_KEY)))
    {
      IF (ERROR != HA_ERR_END_OF_FILE)
	RETURN REPORT_ERROR(TABLE, ERROR);
      MARK_AS_NULL_ROW(TAB->TABLE);
      EMPTY_RECORD(TABLE);			// MAKE EMPTY RECORD
      RETURN -1;
    }
    STORE_RECORD(TABLE,RECORD[1]);
  }
  ELSE IF (!TABLE->STATUS)			// ONLY HAPPENS WITH LEFT JOIN
    RESTORE_RECORD(TABLE,RECORD[1]);			// RESTORE OLD RECORD
  TABLE->NULL_ROW=0;
  RETURN TABLE->STATUS ? -1 : 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210278_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID QEMU_RAM_FREE(STRUCT UC_STRUCT *UC, RAMBLOCK *BLOCK)
{
    IF (!BLOCK) {
        RETURN;
    }

    //IF (BLOCK->HOST) {
    //    RAM_BLOCK_NOTIFY_REMOVE(BLOCK->HOST, BLOCK->MAX_LENGTH);
    //}

    QLIST_REMOVE(BLOCK, NEXT);
    UC->RAM_LIST.MRU_BLOCK = NULL;
    /* WRITE LIST BEFORE VERSION */
    //SMP_WMB();
    // CALL_RCU(BLOCK, RECLAIM_RAMBLOCK, RCU);
    RECLAIM_RAMBLOCK(UC, BLOCK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 455423_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
XFS_IFLAG_FOR_TAG(
	INT		TAG)
{
	SWITCH (TAG) {
	CASE XFS_ICI_EOFBLOCKS_TAG:
		RETURN XFS_IEOFBLOCKS;
	CASE XFS_ICI_COWBLOCKS_TAG:
		RETURN XFS_ICOWBLOCKS;
	DEFAULT:
		ASSERT(0);
		RETURN 0;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 243008_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT MBEDTLS_SSL_DTLS_RECORD_REPLAY_CHECK( MBEDTLS_SSL_CONTEXT *SSL, UINT8_T *RECORD_IN_CTR )
{
    INT RET = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    UNSIGNED CHAR *ORIGINAL_IN_CTR;

    // SAVE ORIGINAL IN_CTR
    ORIGINAL_IN_CTR = SSL->IN_CTR;

    // USE COUNTER FROM RECORD
    SSL->IN_CTR = RECORD_IN_CTR;

    RET = MBEDTLS_SSL_DTLS_REPLAY_CHECK( (MBEDTLS_SSL_CONTEXT CONST *) SSL );

    // RESTORE THE COUNTER
    SSL->IN_CTR = ORIGINAL_IN_CTR;

    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204814_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SIXPACK_CLOSE(STRUCT TTY_STRUCT *TTY)
{
	STRUCT SIXPACK *SP;

	WRITE_LOCK_IRQ(&DISC_DATA_LOCK);
	SP = TTY->DISC_DATA;
	TTY->DISC_DATA = NULL;
	WRITE_UNLOCK_IRQ(&DISC_DATA_LOCK);
	IF (!SP)
		RETURN;

	/*
	 * WE HAVE NOW ENSURED THAT NOBODY CAN START USING AP FROM NOW ON, BUT
	 * WE HAVE TO WAIT FOR ALL EXISTING USERS TO FINISH.
	 */
	IF (!REFCOUNT_DEC_AND_TEST(&SP->REFCNT))
		WAIT_FOR_COMPLETION(&SP->DEAD);

	/* WE MUST STOP THE QUEUE TO AVOID POTENTIALLY SCRIBBLING
	 * ON THE FREE BUFFERS. THE SP->DEAD COMPLETION IS NOT SUFFICIENT
	 * TO PROTECT US FROM SP->XBUFF ACCESS.
	 */
	NETIF_STOP_QUEUE(SP->DEV);

	DEL_TIMER_SYNC(&SP->TX_T);
	DEL_TIMER_SYNC(&SP->RESYNC_T);

	UNREGISTER_NETDEV(SP->DEV);

	/* FREE ALL 6PACK FRAME BUFFERS AFTER UNREG. */
	KFREE(SP->RBUFF);
	KFREE(SP->XBUFF);

	FREE_NETDEV(SP->DEV);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214909_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT MLX5_FPGA_CONN_CREATE_CQ(STRUCT MLX5_FPGA_CONN *CONN, INT CQ_SIZE)
{
	STRUCT MLX5_FPGA_DEVICE *FDEV = CONN->FDEV;
	STRUCT MLX5_CORE_DEV *MDEV = FDEV->MDEV;
	U32 TEMP_CQC[MLX5_ST_SZ_DW(CQC)] = {0};
	U32 OUT[MLX5_ST_SZ_DW(CREATE_CQ_OUT)];
	STRUCT MLX5_WQ_PARAM WQP;
	STRUCT MLX5_CQE64 *CQE;
	INT INLEN, ERR, EQN;
	UNSIGNED INT IRQN;
	VOID *CQC, *IN;
	__BE64 *PAS;
	U32 I;

	CQ_SIZE = ROUNDUP_POW_OF_TWO(CQ_SIZE);
	MLX5_SET(CQC, TEMP_CQC, LOG_CQ_SIZE, ILOG2(CQ_SIZE));

	WQP.BUF_NUMA_NODE = MDEV->PRIV.NUMA_NODE;
	WQP.DB_NUMA_NODE  = MDEV->PRIV.NUMA_NODE;

	ERR = MLX5_CQWQ_CREATE(MDEV, &WQP, TEMP_CQC, &CONN->CQ.WQ,
			       &CONN->CQ.WQ_CTRL);
	IF (ERR)
		RETURN ERR;

	FOR (I = 0; I < MLX5_CQWQ_GET_SIZE(&CONN->CQ.WQ); I++) {
		CQE = MLX5_CQWQ_GET_WQE(&CONN->CQ.WQ, I);
		CQE->OP_OWN = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK;
	}

	INLEN = MLX5_ST_SZ_BYTES(CREATE_CQ_IN) +
		SIZEOF(U64) * CONN->CQ.WQ_CTRL.BUF.NPAGES;
	IN = KVZALLOC(INLEN, GFP_KERNEL);
	IF (!IN) {
		ERR = -ENOMEM;
		GOTO ERR_CQWQ;
	}

	ERR = MLX5_VECTOR2EQN(MDEV, SMP_PROCESSOR_ID(), &EQN, &IRQN);
	IF (ERR)
		GOTO ERR_CQWQ;

	CQC = MLX5_ADDR_OF(CREATE_CQ_IN, IN, CQ_CONTEXT);
	MLX5_SET(CQC, CQC, LOG_CQ_SIZE, ILOG2(CQ_SIZE));
	MLX5_SET(CQC, CQC, C_EQN, EQN);
	MLX5_SET(CQC, CQC, UAR_PAGE, FDEV->CONN_RES.UAR->INDEX);
	MLX5_SET(CQC, CQC, LOG_PAGE_SIZE, CONN->CQ.WQ_CTRL.BUF.PAGE_SHIFT -
			   MLX5_ADAPTER_PAGE_SHIFT);
	MLX5_SET64(CQC, CQC, DBR_ADDR, CONN->CQ.WQ_CTRL.DB.DMA);

	PAS = (__BE64 *)MLX5_ADDR_OF(CREATE_CQ_IN, IN, PAS);
	MLX5_FILL_PAGE_FRAG_ARRAY(&CONN->CQ.WQ_CTRL.BUF, PAS);

	ERR = MLX5_CORE_CREATE_CQ(MDEV, &CONN->CQ.MCQ, IN, INLEN, OUT, SIZEOF(OUT));
	KVFREE(IN);

	IF (ERR)
		GOTO ERR_CQWQ;

	CONN->CQ.MCQ.CQE_SZ     = 64;
	CONN->CQ.MCQ.SET_CI_DB  = CONN->CQ.WQ_CTRL.DB.DB;
	CONN->CQ.MCQ.ARM_DB     = CONN->CQ.WQ_CTRL.DB.DB + 1;
	*CONN->CQ.MCQ.SET_CI_DB = 0;
	*CONN->CQ.MCQ.ARM_DB    = 0;
	CONN->CQ.MCQ.VECTOR     = 0;
	CONN->CQ.MCQ.COMP       = MLX5_FPGA_CONN_CQ_COMPLETE;
	CONN->CQ.MCQ.EVENT      = MLX5_FPGA_CONN_CQ_EVENT;
	CONN->CQ.MCQ.IRQN       = IRQN;
	CONN->CQ.MCQ.UAR        = FDEV->CONN_RES.UAR;
	TASKLET_INIT(&CONN->CQ.TASKLET, MLX5_FPGA_CONN_CQ_TASKLET,
		     (UNSIGNED LONG)CONN);

	MLX5_FPGA_DBG(FDEV, "CREATED CQ #0X%X\N", CONN->CQ.MCQ.CQN);

	GOTO OUT;

ERR_CQWQ:
	MLX5_WQ_DESTROY(&CONN->CQ.WQ_CTRL);
OUT:
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208525_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CMDLINE_INSERT_REG(INT *GOTESC UNUSED)
{
    INT		I;
    INT		C;

#IFDEF USE_ON_FLY_SCROLL
    DONT_SCROLL = TRUE;	// DISALLOW SCROLLING HERE
#ENDIF
    PUTCMDLINE('"', TRUE);
    ++NO_MAPPING;
    ++ALLOW_KEYS;
    I = C = PLAIN_VGETC();	// CTRL-R <CHAR>
    IF (I == CTRL_O)
	I = CTRL_R;		// CTRL-R CTRL-O == CTRL-R CTRL-R
    IF (I == CTRL_R)
	C = PLAIN_VGETC();	// CTRL-R CTRL-R <CHAR>
    EXTRA_CHAR = NUL;
    --NO_MAPPING;
    --ALLOW_KEYS;
#IFDEF FEAT_EVAL
    /*
     * INSERT THE RESULT OF AN EXPRESSION.
     * NEED TO SAVE THE CURRENT COMMAND LINE, TO BE ABLE TO ENTER
     * A NEW ONE...
     */
    NEW_CMDPOS = -1;
    IF (C == '=')
    {
	IF (CCLINE.CMDFIRSTC == '='  // CAN'T DO THIS RECURSIVELY
		|| CMDLINE_STAR > 0) // OR WHEN TYPING A PASSWORD
	{
	    BEEP_FLUSH();
	    C = ESC;
	}
	ELSE
	    C = GET_EXPR_REGISTER();
    }
#ENDIF
    IF (C != ESC)	    // USE ESC TO CANCEL INSERTING REGISTER
    {
	CMDLINE_PASTE(C, I == CTRL_R, FALSE);

#IFDEF FEAT_EVAL
	// WHEN THERE WAS A SERIOUS ERROR ABORT GETTING THE
	// COMMAND LINE.
	IF (ABORTING())
	{
	    *GOTESC = TRUE;  // WILL FREE CCLINE.CMDBUFF AFTER
	    // PUTTING IT IN HISTORY
	    RETURN GOTO_NORMAL_MODE;
	}
#ENDIF
	KEYTYPED = FALSE;	// DON'T DO P_WC COMPLETION.
#IFDEF FEAT_EVAL
	IF (NEW_CMDPOS >= 0)
	{
	    // SET_CMDLINE_POS() WAS USED
	    IF (NEW_CMDPOS > CCLINE.CMDLEN)
		CCLINE.CMDPOS = CCLINE.CMDLEN;
	    ELSE
		CCLINE.CMDPOS = NEW_CMDPOS;
	}
#ENDIF
    }
    // REMOVE THE DOUBLE QUOTE
    REDRAWCMD();

    // THE TEXT HAS BEEN STUFFED, THE COMMAND LINE DIDN'T CHANGE YET.
    RETURN CMDLINE_NOT_CHANGED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 381855_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT UDF_READ_INODE(STRUCT INODE *INODE, BOOL HIDDEN_INODE)
{
	STRUCT BUFFER_HEAD *BH = NULL;
	STRUCT FILEENTRY *FE;
	STRUCT EXTENDEDFILEENTRY *EFE;
	UINT16_T IDENT;
	STRUCT UDF_INODE_INFO *IINFO = UDF_I(INODE);
	STRUCT UDF_SB_INFO *SBI = UDF_SB(INODE->I_SB);
	STRUCT KERNEL_LB_ADDR *ILOC = &IINFO->I_LOCATION;
	UNSIGNED INT LINK_COUNT;
	UNSIGNED INT INDIRECTIONS = 0;
	INT BS = INODE->I_SB->S_BLOCKSIZE;
	INT RET = -EIO;
	UINT32_T UID, GID;

REREAD:
	IF (ILOC->PARTITIONREFERENCENUM >= SBI->S_PARTITIONS) {
		UDF_DEBUG("PARTITION REFERENCE: %U > LOGICAL VOLUME PARTITIONS: %U\N",
			  ILOC->PARTITIONREFERENCENUM, SBI->S_PARTITIONS);
		RETURN -EIO;
	}

	IF (ILOC->LOGICALBLOCKNUM >=
	    SBI->S_PARTMAPS[ILOC->PARTITIONREFERENCENUM].S_PARTITION_LEN) {
		UDF_DEBUG("BLOCK=%U, PARTITION=%U OUT OF RANGE\N",
			  ILOC->LOGICALBLOCKNUM, ILOC->PARTITIONREFERENCENUM);
		RETURN -EIO;
	}

	/*
	 * SET DEFAULTS, BUT THE INODE IS STILL INCOMPLETE!
	 * NOTE: GET_NEW_INODE() SETS THE FOLLOWING ON A NEW INODE:
	 *      I_SB = SB
	 *      I_NO = INO
	 *      I_FLAGS = SB->S_FLAGS
	 *      I_STATE = 0
	 * CLEAN_INODE(): ZERO FILLS AND SETS
	 *      I_COUNT = 1
	 *      I_NLINK = 1
	 *      I_OP = NULL;
	 */
	BH = UDF_READ_PTAGGED(INODE->I_SB, ILOC, 0, &IDENT);
	IF (!BH) {
		UDF_ERR(INODE->I_SB, "(INO %LU) FAILED !BH\N", INODE->I_INO);
		RETURN -EIO;
	}

	IF (IDENT != TAG_IDENT_FE && IDENT != TAG_IDENT_EFE &&
	    IDENT != TAG_IDENT_USE) {
		UDF_ERR(INODE->I_SB, "(INO %LU) FAILED IDENT=%U\N",
			INODE->I_INO, IDENT);
		GOTO OUT;
	}

	FE = (STRUCT FILEENTRY *)BH->B_DATA;
	EFE = (STRUCT EXTENDEDFILEENTRY *)BH->B_DATA;

	IF (FE->ICBTAG.STRATEGYTYPE == CPU_TO_LE16(4096)) {
		STRUCT BUFFER_HEAD *IBH;

		IBH = UDF_READ_PTAGGED(INODE->I_SB, ILOC, 1, &IDENT);
		IF (IDENT == TAG_IDENT_IE && IBH) {
			STRUCT KERNEL_LB_ADDR LOC;
			STRUCT INDIRECTENTRY *IE;

			IE = (STRUCT INDIRECTENTRY *)IBH->B_DATA;
			LOC = LELB_TO_CPU(IE->INDIRECTICB.EXTLOCATION);

			IF (IE->INDIRECTICB.EXTLENGTH) {
				BRELSE(IBH);
				MEMCPY(&IINFO->I_LOCATION, &LOC,
				       SIZEOF(STRUCT KERNEL_LB_ADDR));
				IF (++INDIRECTIONS > UDF_MAX_ICB_NESTING) {
					UDF_ERR(INODE->I_SB,
						"TOO MANY ICBS IN ICB HIERARCHY"
						" (MAX %D SUPPORTED)\N",
						UDF_MAX_ICB_NESTING);
					GOTO OUT;
				}
				BRELSE(BH);
				GOTO REREAD;
			}
		}
		BRELSE(IBH);
	} ELSE IF (FE->ICBTAG.STRATEGYTYPE != CPU_TO_LE16(4)) {
		UDF_ERR(INODE->I_SB, "UNSUPPORTED STRATEGY TYPE: %U\N",
			LE16_TO_CPU(FE->ICBTAG.STRATEGYTYPE));
		GOTO OUT;
	}
	IF (FE->ICBTAG.STRATEGYTYPE == CPU_TO_LE16(4))
		IINFO->I_STRAT4096 = 0;
	ELSE /* IF (FE->ICBTAG.STRATEGYTYPE == CPU_TO_LE16(4096)) */
		IINFO->I_STRAT4096 = 1;

	IINFO->I_ALLOC_TYPE = LE16_TO_CPU(FE->ICBTAG.FLAGS) &
							ICBTAG_FLAG_AD_MASK;
	IF (IINFO->I_ALLOC_TYPE != ICBTAG_FLAG_AD_SHORT &&
	    IINFO->I_ALLOC_TYPE != ICBTAG_FLAG_AD_LONG &&
	    IINFO->I_ALLOC_TYPE != ICBTAG_FLAG_AD_IN_ICB) {
		RET = -EIO;
		GOTO OUT;
	}
	IINFO->I_UNIQUE = 0;
	IINFO->I_LENEATTR = 0;
	IINFO->I_LENEXTENTS = 0;
	IINFO->I_LENALLOC = 0;
	IINFO->I_NEXT_ALLOC_BLOCK = 0;
	IINFO->I_NEXT_ALLOC_GOAL = 0;
	IF (FE->DESCTAG.TAGIDENT == CPU_TO_LE16(TAG_IDENT_EFE)) {
		IINFO->I_EFE = 1;
		IINFO->I_USE = 0;
		RET = UDF_ALLOC_I_DATA(INODE, BS -
					SIZEOF(STRUCT EXTENDEDFILEENTRY));
		IF (RET)
			GOTO OUT;
		MEMCPY(IINFO->I_DATA,
		       BH->B_DATA + SIZEOF(STRUCT EXTENDEDFILEENTRY),
		       BS - SIZEOF(STRUCT EXTENDEDFILEENTRY));
	} ELSE IF (FE->DESCTAG.TAGIDENT == CPU_TO_LE16(TAG_IDENT_FE)) {
		IINFO->I_EFE = 0;
		IINFO->I_USE = 0;
		RET = UDF_ALLOC_I_DATA(INODE, BS - SIZEOF(STRUCT FILEENTRY));
		IF (RET)
			GOTO OUT;
		MEMCPY(IINFO->I_DATA,
		       BH->B_DATA + SIZEOF(STRUCT FILEENTRY),
		       BS - SIZEOF(STRUCT FILEENTRY));
	} ELSE IF (FE->DESCTAG.TAGIDENT == CPU_TO_LE16(TAG_IDENT_USE)) {
		IINFO->I_EFE = 0;
		IINFO->I_USE = 1;
		IINFO->I_LENALLOC = LE32_TO_CPU(
				((STRUCT UNALLOCSPACEENTRY *)BH->B_DATA)->
				 LENGTHALLOCDESCS);
		RET = UDF_ALLOC_I_DATA(INODE, BS -
					SIZEOF(STRUCT UNALLOCSPACEENTRY));
		IF (RET)
			GOTO OUT;
		MEMCPY(IINFO->I_DATA,
		       BH->B_DATA + SIZEOF(STRUCT UNALLOCSPACEENTRY),
		       BS - SIZEOF(STRUCT UNALLOCSPACEENTRY));
		RETURN 0;
	}

	RET = -EIO;
	READ_LOCK(&SBI->S_CRED_LOCK);
	UID = LE32_TO_CPU(FE->UID);
	IF (UID == UDF_INVALID_ID ||
	    UDF_QUERY_FLAG(INODE->I_SB, UDF_FLAG_UID_SET))
		INODE->I_UID = SBI->S_UID;
	ELSE
		I_UID_WRITE(INODE, UID);

	GID = LE32_TO_CPU(FE->GID);
	IF (GID == UDF_INVALID_ID ||
	    UDF_QUERY_FLAG(INODE->I_SB, UDF_FLAG_GID_SET))
		INODE->I_GID = SBI->S_GID;
	ELSE
		I_GID_WRITE(INODE, GID);

	IF (FE->ICBTAG.FILETYPE != ICBTAG_FILE_TYPE_DIRECTORY &&
			SBI->S_FMODE != UDF_INVALID_MODE)
		INODE->I_MODE = SBI->S_FMODE;
	ELSE IF (FE->ICBTAG.FILETYPE == ICBTAG_FILE_TYPE_DIRECTORY &&
			SBI->S_DMODE != UDF_INVALID_MODE)
		INODE->I_MODE = SBI->S_DMODE;
	ELSE
		INODE->I_MODE = UDF_CONVERT_PERMISSIONS(FE);
	INODE->I_MODE &= ~SBI->S_UMASK;
	IINFO->I_EXTRAPERMS = LE32_TO_CPU(FE->PERMISSIONS) & ~FE_MAPPED_PERMS;

	READ_UNLOCK(&SBI->S_CRED_LOCK);

	LINK_COUNT = LE16_TO_CPU(FE->FILELINKCOUNT);
	IF (!LINK_COUNT) {
		IF (!HIDDEN_INODE) {
			RET = -ESTALE;
			GOTO OUT;
		}
		LINK_COUNT = 1;
	}
	SET_NLINK(INODE, LINK_COUNT);

	INODE->I_SIZE = LE64_TO_CPU(FE->INFORMATIONLENGTH);
	IINFO->I_LENEXTENTS = INODE->I_SIZE;

	IF (IINFO->I_EFE == 0) {
		INODE->I_BLOCKS = LE64_TO_CPU(FE->LOGICALBLOCKSRECORDED) <<
			(INODE->I_SB->S_BLOCKSIZE_BITS - 9);

		UDF_DISK_STAMP_TO_TIME(&INODE->I_ATIME, FE->ACCESSTIME);
		UDF_DISK_STAMP_TO_TIME(&INODE->I_MTIME, FE->MODIFICATIONTIME);
		UDF_DISK_STAMP_TO_TIME(&INODE->I_CTIME, FE->ATTRTIME);

		IINFO->I_UNIQUE = LE64_TO_CPU(FE->UNIQUEID);
		IINFO->I_LENEATTR = LE32_TO_CPU(FE->LENGTHEXTENDEDATTR);
		IINFO->I_LENALLOC = LE32_TO_CPU(FE->LENGTHALLOCDESCS);
		IINFO->I_CHECKPOINT = LE32_TO_CPU(FE->CHECKPOINT);
		IINFO->I_STREAMDIR = 0;
		IINFO->I_LENSTREAMS = 0;
	} ELSE {
		INODE->I_BLOCKS = LE64_TO_CPU(EFE->LOGICALBLOCKSRECORDED) <<
		    (INODE->I_SB->S_BLOCKSIZE_BITS - 9);

		UDF_DISK_STAMP_TO_TIME(&INODE->I_ATIME, EFE->ACCESSTIME);
		UDF_DISK_STAMP_TO_TIME(&INODE->I_MTIME, EFE->MODIFICATIONTIME);
		UDF_DISK_STAMP_TO_TIME(&IINFO->I_CRTIME, EFE->CREATETIME);
		UDF_DISK_STAMP_TO_TIME(&INODE->I_CTIME, EFE->ATTRTIME);

		IINFO->I_UNIQUE = LE64_TO_CPU(EFE->UNIQUEID);
		IINFO->I_LENEATTR = LE32_TO_CPU(EFE->LENGTHEXTENDEDATTR);
		IINFO->I_LENALLOC = LE32_TO_CPU(EFE->LENGTHALLOCDESCS);
		IINFO->I_CHECKPOINT = LE32_TO_CPU(EFE->CHECKPOINT);

		/* NAMED STREAMS */
		IINFO->I_STREAMDIR = (EFE->STREAMDIRECTORYICB.EXTLENGTH != 0);
		IINFO->I_LOCSTREAMDIR =
			LELB_TO_CPU(EFE->STREAMDIRECTORYICB.EXTLOCATION);
		IINFO->I_LENSTREAMS = LE64_TO_CPU(EFE->OBJECTSIZE);
		IF (IINFO->I_LENSTREAMS >= INODE->I_SIZE)
			IINFO->I_LENSTREAMS -= INODE->I_SIZE;
		ELSE
			IINFO->I_LENSTREAMS = 0;
	}
	INODE->I_GENERATION = IINFO->I_UNIQUE;

	/*
	 * SANITY CHECK LENGTH OF ALLOCATION DESCRIPTORS AND EXTENDED ATTRS TO
	 * AVOID INTEGER OVERFLOWS
	 */
	IF (IINFO->I_LENEATTR > BS || IINFO->I_LENALLOC > BS)
		GOTO OUT;
	/* NOW DO EXACT CHECKS */
	IF (UDF_FILE_ENTRY_ALLOC_OFFSET(INODE) + IINFO->I_LENALLOC > BS)
		GOTO OUT;
	/* SANITY CHECKS FOR FILES IN ICB SO THAT WE DON'T GET CONFUSED LATER */
	IF (IINFO->I_ALLOC_TYPE == ICBTAG_FLAG_AD_IN_ICB) {
		/*
		 * FOR FILE IN ICB DATA IS STORED IN ALLOCATION DESCRIPTOR
		 * SO SIZES SHOULD MATCH
		 */
		IF (IINFO->I_LENALLOC != INODE->I_SIZE)
			GOTO OUT;
		/* FILE IN ICB HAS TO FIT IN THERE... */
		IF (INODE->I_SIZE > BS - UDF_FILE_ENTRY_ALLOC_OFFSET(INODE))
			GOTO OUT;
	}

	SWITCH (FE->ICBTAG.FILETYPE) {
	CASE ICBTAG_FILE_TYPE_DIRECTORY:
		INODE->I_OP = &UDF_DIR_INODE_OPERATIONS;
		INODE->I_FOP = &UDF_DIR_OPERATIONS;
		INODE->I_MODE |= S_IFDIR;
		INC_NLINK(INODE);
		BREAK;
	CASE ICBTAG_FILE_TYPE_REALTIME:
	CASE ICBTAG_FILE_TYPE_REGULAR:
	CASE ICBTAG_FILE_TYPE_UNDEF:
	CASE ICBTAG_FILE_TYPE_VAT20:
		IF (IINFO->I_ALLOC_TYPE == ICBTAG_FLAG_AD_IN_ICB)
			INODE->I_DATA.A_OPS = &UDF_ADINICB_AOPS;
		ELSE
			INODE->I_DATA.A_OPS = &UDF_AOPS;
		INODE->I_OP = &UDF_FILE_INODE_OPERATIONS;
		INODE->I_FOP = &UDF_FILE_OPERATIONS;
		INODE->I_MODE |= S_IFREG;
		BREAK;
	CASE ICBTAG_FILE_TYPE_BLOCK:
		INODE->I_MODE |= S_IFBLK;
		BREAK;
	CASE ICBTAG_FILE_TYPE_CHAR:
		INODE->I_MODE |= S_IFCHR;
		BREAK;
	CASE ICBTAG_FILE_TYPE_FIFO:
		INIT_SPECIAL_INODE(INODE, INODE->I_MODE | S_IFIFO, 0);
		BREAK;
	CASE ICBTAG_FILE_TYPE_SOCKET:
		INIT_SPECIAL_INODE(INODE, INODE->I_MODE | S_IFSOCK, 0);
		BREAK;
	CASE ICBTAG_FILE_TYPE_SYMLINK:
		INODE->I_DATA.A_OPS = &UDF_SYMLINK_AOPS;
		INODE->I_OP = &UDF_SYMLINK_INODE_OPERATIONS;
		INODE_NOHIGHMEM(INODE);
		INODE->I_MODE = S_IFLNK | 0777;
		BREAK;
	CASE ICBTAG_FILE_TYPE_MAIN:
		UDF_DEBUG("METADATA FILE-----\N");
		BREAK;
	CASE ICBTAG_FILE_TYPE_MIRROR:
		UDF_DEBUG("METADATA MIRROR FILE-----\N");
		BREAK;
	CASE ICBTAG_FILE_TYPE_BITMAP:
		UDF_DEBUG("METADATA BITMAP FILE-----\N");
		BREAK;
	DEFAULT:
		UDF_ERR(INODE->I_SB, "(INO %LU) FAILED UNKNOWN FILE TYPE=%U\N",
			INODE->I_INO, FE->ICBTAG.FILETYPE);
		GOTO OUT;
	}
	IF (S_ISCHR(INODE->I_MODE) || S_ISBLK(INODE->I_MODE)) {
		STRUCT DEVICESPEC *DSEA =
			(STRUCT DEVICESPEC *)UDF_GET_EXTENDEDATTR(INODE, 12, 1);
		IF (DSEA) {
			INIT_SPECIAL_INODE(INODE, INODE->I_MODE,
				MKDEV(LE32_TO_CPU(DSEA->MAJORDEVICEIDENT),
				      LE32_TO_CPU(DSEA->MINORDEVICEIDENT)));
			/* DEVELOPER ID ??? */
		} ELSE
			GOTO OUT;
	}
	RET = 0;
OUT:
	BRELSE(BH);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225064_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_HEXDIGIT(CHAR DIGIT, INT *VALUE)
{
	IF ('0' <= DIGIT && DIGIT <= '9')
		*VALUE = DIGIT - '0';
	ELSE IF ('A' <= DIGIT && DIGIT <= 'F')
		*VALUE = DIGIT - 'A' + 10;
	ELSE IF ('A' <= DIGIT && DIGIT <= 'F')
		*VALUE = DIGIT - 'A' + 10;
	ELSE
		RETURN FALSE;

	RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210961_CWE-121.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT NFT_SET_DESC_CONCAT_PARSE(CONST STRUCT NLATTR *ATTR,
				     STRUCT NFT_SET_DESC *DESC)
{
	STRUCT NLATTR *TB[NFTA_SET_FIELD_MAX + 1];
	U32 LEN;
	INT ERR;

	ERR = NLA_PARSE_NESTED_DEPRECATED(TB, NFTA_SET_FIELD_MAX, ATTR,
					  NFT_CONCAT_POLICY, NULL);
	IF (ERR < 0)
		RETURN ERR;

	IF (!TB[NFTA_SET_FIELD_LEN])
		RETURN -EINVAL;

	LEN = NTOHL(NLA_GET_BE32(TB[NFTA_SET_FIELD_LEN]));

	IF (LEN * BITS_PER_BYTE / 32 > NFT_REG32_COUNT)
		RETURN -E2BIG;

	DESC->FIELD_LEN[DESC->FIELD_COUNT++] = LEN;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200781_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CVTCHAR(REGISTER CONST CHAR *SP)
/* CONVERT A CHARACTER TO A TERMINFO PUSH */
{
    UNSIGNED CHAR C = 0;
    INT LEN;

    SWITCH (*SP) {
    CASE '\\':
	SWITCH (*++SP) {
	CASE '\'':
	CASE '$':
	CASE '\\':
	CASE '%':
	    C = UCHAR(*SP);
	    LEN = 2;
	    BREAK;
	CASE '\0':
	    C = '\\';
	    LEN = 1;
	    BREAK;
	CASE '0':
	CASE '1':
	CASE '2':
	CASE '3':
	    LEN = 1;
	    WHILE (ISDIGIT(UCHAR(*SP))) {
		C = UCHAR(8 * C + (*SP++ - '0'));
		LEN++;
	    }
	    BREAK;
	DEFAULT:
	    C = UCHAR(*SP);
	    LEN = (C != '\0') ? 2 : 1;
	    BREAK;
	}
	BREAK;
    CASE '^':
	C = UCHAR(*++SP);
	IF (C == '?')
	    C = 127;
	ELSE
	    C &= 0X1F;
	LEN = 2;
	BREAK;
    DEFAULT:
	C = UCHAR(*SP);
	LEN = (C != '\0') ? 1 : 0;
    }
    IF (ISGRAPH(C) && C != ',' && C != '\'' && C != '\\' && C != ':') {
	DP = SAVE_STRING(DP, "%\'");
	DP = SAVE_CHAR(DP, C);
	DP = SAVE_CHAR(DP, '\'');
    } ELSE IF (C != '\0') {
	DP = SAVE_STRING(DP, "%{");
	IF (C > 99)
	    DP = SAVE_CHAR(DP, C / 100 + '0');
	IF (C > 9)
	    DP = SAVE_CHAR(DP, ((INT) (C / 10)) % 10 + '0');
	DP = SAVE_CHAR(DP, C % 10 + '0');
	DP = SAVE_CHAR(DP, '}');
    }
    RETURN LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207461_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
AT_BITMAP INPUT_BMP_READER(GCHAR * FILENAME, AT_INPUT_OPTS_TYPE * OPTS, AT_MSG_FUNC MSG_FUNC, GPOINTER MSG_DATA, GPOINTER USER_DATA)
{
  FILE *FD;
  UNSIGNED CHAR BUFFER[64];
  INT COLORMAPSIZE, ROWBYTES, MAPS;
  GBOOLEAN GREY = FALSE;
  UNSIGNED CHAR COLORMAP[256][3];
  AT_BITMAP IMAGE = AT_BITMAP_INIT(0, 0, 0, 1);
  UNSIGNED CHAR *IMAGE_STORAGE;
  AT_EXCEPTION_TYPE EXP = AT_EXCEPTION_NEW(MSG_FUNC, MSG_DATA);
  CHAR MAGICK[2];
  BITMAP_CHANNEL MASKS[4];

  FD = FOPEN(FILENAME, "RB");

  IF (!FD) {
    LOG("CAN'T OPEN \"%S\"\N", FILENAME);
    AT_EXCEPTION_FATAL(&EXP, "BMP: CANNOT OPEN INPUT FILE");
    GOTO CLEANUP;
  }

  /* IT IS A FILE. NOW IS IT A BITMAP? READ THE SHORTEST POSSIBLE HEADER. */

  IF (!READOK(FD, MAGICK, 2) ||
	  !(!STRNCMP(MAGICK, "BA", 2) ||
		  !STRNCMP(MAGICK, "BM", 2) ||
		  !STRNCMP(MAGICK, "IC", 2) ||
		  !STRNCMP(MAGICK, "PT", 2) ||
		  !STRNCMP(MAGICK, "CI", 2) ||
		  !STRNCMP(MAGICK, "CP", 2)))
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  WHILE (!STRNCMP(MAGICK, "BA", 2))
  {
	  IF (!READOK(FD, BUFFER, 12))
	  {
		  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
		  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
		  GOTO CLEANUP;
	  }

	  IF (!READOK(FD, MAGICK, 2))
	  {
		  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
		  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
		  GOTO CLEANUP;
	  }
  }

  IF (!READOK(FD, BUFFER, 12))////
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  /* BRING THEM TO THE RIGHT BYTEORDER. NOT TOO NICE, BUT IT SHOULD WORK */

  BITMAP_FILE_HEAD.BFSIZE = TOL(&BUFFER[0X00]);
  BITMAP_FILE_HEAD.ZZHOTX = TOS(&BUFFER[0X04]);
  BITMAP_FILE_HEAD.ZZHOTY = TOS(&BUFFER[0X06]);
  BITMAP_FILE_HEAD.BFOFFS = TOL(&BUFFER[0X08]);

  IF (!READOK(FD, BUFFER, 4))
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  BITMAP_FILE_HEAD.BISIZE = TOL(&BUFFER[0X00]);

  /* WHAT KIND OF BITMAP IS IT? */

  IF (BITMAP_FILE_HEAD.BISIZE == 12) {  /* OS/2 1.X ? */
    IF (!READOK(FD, BUFFER, 8)) {
      LOG("ERROR READING BMP FILE HEADER\N");
      AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER");
      GOTO CLEANUP;
    }

    BITMAP_HEAD.BIWIDTH = TOS(&BUFFER[0X00]); /* 12 */
    BITMAP_HEAD.BIHEIGHT = TOS(&BUFFER[0X02]);  /* 14 */
    BITMAP_HEAD.BIPLANES = TOS(&BUFFER[0X04]);  /* 16 */
    BITMAP_HEAD.BIBITCNT = TOS(&BUFFER[0X06]);  /* 18 */
    BITMAP_HEAD.BICOMPR = 0;
    BITMAP_HEAD.BISIZEIM = 0;
    BITMAP_HEAD.BIXPELS = BITMAP_HEAD.BIYPELS = 0;
    BITMAP_HEAD.BICLRUSED = 0;
    BITMAP_HEAD.BICLRIMP = 0;
    BITMAP_HEAD.MASKS[0] = 0;
    BITMAP_HEAD.MASKS[1] = 0;
    BITMAP_HEAD.MASKS[2] = 0;
    BITMAP_HEAD.MASKS[3] = 0;

    MEMSET(MASKS, 0, SIZEOF(MASKS));
    MAPS = 3;

  } ELSE IF (BITMAP_FILE_HEAD.BISIZE == 40) { /* WINDOWS 3.X */
    IF (!READOK(FD, BUFFER, 36))
    {
      LOG ("ERROR READING BMP FILE HEADER\N");
      AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER");
      GOTO CLEANUP;
    }
          

    BITMAP_HEAD.BIWIDTH = TOL(&BUFFER[0X00]); /* 12 */
    BITMAP_HEAD.BIHEIGHT = TOL(&BUFFER[0X04]);  /* 16 */
    BITMAP_HEAD.BIPLANES = TOS(&BUFFER[0X08]);  /* 1A */
    BITMAP_HEAD.BIBITCNT = TOS(&BUFFER[0X0A]);  /* 1C */
    BITMAP_HEAD.BICOMPR = TOL(&BUFFER[0X0C]); /* 1E */
    BITMAP_HEAD.BISIZEIM = TOL(&BUFFER[0X10]);  /* 22 */
    BITMAP_HEAD.BIXPELS = TOL(&BUFFER[0X14]); /* 26 */
    BITMAP_HEAD.BIYPELS = TOL(&BUFFER[0X18]); /* 2A */
    BITMAP_HEAD.BICLRUSED = TOL(&BUFFER[0X1C]); /* 2E */
    BITMAP_HEAD.BICLRIMP = TOL(&BUFFER[0X20]);  /* 32 */
    BITMAP_HEAD.MASKS[0] = 0;
    BITMAP_HEAD.MASKS[1] = 0;
    BITMAP_HEAD.MASKS[2] = 0;
    BITMAP_HEAD.MASKS[3] = 0;

    MAPS = 4;
    MEMSET(MASKS, 0, SIZEOF(MASKS));

    IF (BITMAP_HEAD.BICOMPR == BI_BITFIELDS)
      {
	IF (!READOK(FD, BUFFER, 3 * SIZEOF(UNSIGNED LONG)))
	  {
	    LOG("ERROR READING BMP FILE HEADER\N");
	    AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER");
	    GOTO CLEANUP;
	  }

	BITMAP_HEAD.MASKS[0] = TOL(&BUFFER[0X00]);
	BITMAP_HEAD.MASKS[1] = TOL(&BUFFER[0X04]);
	BITMAP_HEAD.MASKS[2] = TOL(&BUFFER[0X08]);

	READCHANNELMASKS(&BITMAP_HEAD.MASKS[0], MASKS, 3);
      }
    ELSE IF (BITMAP_HEAD.BICOMPR == BI_RGB)
      {
	SETMASKSDEFAULT(BITMAP_HEAD.BIBITCNT, MASKS);
      }
    ELSE IF ((BITMAP_HEAD.BICOMPR != BI_RLE4) &&
	     (BITMAP_HEAD.BICOMPR != BI_RLE8))
      {
	/* BI_ALPHABITFIELDS, ETC. */
	LOG("UNSUPPORTED COMPRESSION IN BMP FILE\N");
	AT_EXCEPTION_FATAL(&EXP, "UNSUPPORTED COMPRESSION IN BMP FILE");
	GOTO CLEANUP;
      }
  }
  ELSE IF (BITMAP_FILE_HEAD.BISIZE >= 56 &&
	   BITMAP_FILE_HEAD.BISIZE <= 64)
  {
    /* ENHANCED WINDOWS FORMAT WITH BIT MASKS */

    IF (!READOK (FD, BUFFER, BITMAP_FILE_HEAD.BISIZE - 4))
    {

      LOG("ERROR READING BMP FILE HEADER\N");
      AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER");
      GOTO CLEANUP;
    }

    BITMAP_HEAD.BIWIDTH = TOL(&BUFFER[0X00]); /* 12 */
    BITMAP_HEAD.BIHEIGHT = TOL(&BUFFER[0X04]);  /* 16 */
    BITMAP_HEAD.BIPLANES = TOS(&BUFFER[0X08]);  /* 1A */
    BITMAP_HEAD.BIBITCNT = TOS(&BUFFER[0X0A]);  /* 1C */
    BITMAP_HEAD.BICOMPR = TOL(&BUFFER[0X0C]); /* 1E */
    BITMAP_HEAD.BISIZEIM = TOL(&BUFFER[0X10]);  /* 22 */
    BITMAP_HEAD.BIXPELS = TOL(&BUFFER[0X14]); /* 26 */
    BITMAP_HEAD.BIYPELS = TOL(&BUFFER[0X18]); /* 2A */
    BITMAP_HEAD.BICLRUSED = TOL(&BUFFER[0X1C]); /* 2E */
    BITMAP_HEAD.BICLRIMP = TOL(&BUFFER[0X20]);  /* 32 */
    BITMAP_HEAD.MASKS[0] = TOL(&BUFFER[0X24]);       /* 36 */
    BITMAP_HEAD.MASKS[1] = TOL(&BUFFER[0X28]);       /* 3A */
    BITMAP_HEAD.MASKS[2] = TOL(&BUFFER[0X2C]);       /* 3E */
    BITMAP_HEAD.MASKS[3] = TOL(&BUFFER[0X30]);       /* 42 */

    MAPS = 4;
    READCHANNELMASKS(&BITMAP_HEAD.MASKS[0], MASKS, 4);
  }
  ELSE IF (BITMAP_FILE_HEAD.BISIZE == 108 ||
           BITMAP_FILE_HEAD.BISIZE == 124)
  {
    /* BMP VERSION 4 OR 5 */

    IF (!READOK(FD, BUFFER, BITMAP_FILE_HEAD.BISIZE - 4))
    {
	    LOG("ERROR READING BMP FILE HEADER\N");
	    AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER");
	    GOTO CLEANUP;
    }

    BITMAP_HEAD.BIWIDTH = TOL(&BUFFER[0X00]);
    BITMAP_HEAD.BIHEIGHT = TOL(&BUFFER[0X04]);
    BITMAP_HEAD.BIPLANES = TOS(&BUFFER[0X08]);
    BITMAP_HEAD.BIBITCNT = TOS(&BUFFER[0X0A]);
    BITMAP_HEAD.BICOMPR = TOL(&BUFFER[0X0C]);
    BITMAP_HEAD.BISIZEIM = TOL(&BUFFER[0X10]);
    BITMAP_HEAD.BIXPELS = TOL(&BUFFER[0X14]);
    BITMAP_HEAD.BIYPELS = TOL(&BUFFER[0X18]);
    BITMAP_HEAD.BICLRUSED = TOL(&BUFFER[0X1C]);
    BITMAP_HEAD.BICLRIMP = TOL(&BUFFER[0X20]);
    BITMAP_HEAD.MASKS[0] = TOL(&BUFFER[0X24]);
    BITMAP_HEAD.MASKS[1] = TOL(&BUFFER[0X28]);
    BITMAP_HEAD.MASKS[2] = TOL(&BUFFER[0X2C]);
    BITMAP_HEAD.MASKS[3] = TOL(&BUFFER[0X30]);

    MAPS = 4;

    IF (BITMAP_HEAD.BICOMPR == BI_BITFIELDS)
    {
	    READCHANNELMASKS(&BITMAP_HEAD.MASKS[0], MASKS, 4);
    }
    ELSE IF (BITMAP_HEAD.BICOMPR == BI_RGB)
    {
	    SETMASKSDEFAULT(BITMAP_HEAD.BIBITCNT, MASKS);
    }
  } ELSE {
    LOG("ERROR READING BMP FILE HEADER\N");
    AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER");
    GOTO CLEANUP;
  }

  /* VALID OPTIONS 1, 4, 8, 16, 24, 32 */
  /* 16 IS AWFUL, WE SHOULD PROBABLY SHOOT WHOEVER INVENTED IT */

  SWITCH (BITMAP_HEAD.BIBITCNT)
  {
  CASE 1:
  CASE 2:
  CASE 4:
  CASE 8:
  CASE 16:
  CASE 24:
  CASE 32:
	  BREAK;
  DEFAULT:
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  /* THERE SHOULD BE SOME COLORS USED! */

  COLORMAPSIZE = (BITMAP_FILE_HEAD.BFOFFS - BITMAP_FILE_HEAD.BISIZE - 14) / MAPS;

  IF ((BITMAP_HEAD.BICLRUSED == 0) &&
      (BITMAP_HEAD.BIBITCNT <= 8))
  {
	  COLORMAPSIZE = BITMAP_HEAD.BICLRUSED = 1 << BITMAP_HEAD.BIBITCNT;
  }

  IF (COLORMAPSIZE > 256)
    COLORMAPSIZE = 256;

  /* SANITY CHECKS */

  IF (BITMAP_HEAD.BIHEIGHT == 0 ||
	  BITMAP_HEAD.BIWIDTH == 0)
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  /* BIHEIGHT MAY BE NEGATIVE, BUT -2147483648 IS DANGEROUS BECAUSE:
	 -2147483648 == -(-2147483648) */
  IF (BITMAP_HEAD.BIWIDTH < 0 ||
	  BITMAP_HEAD.BIHEIGHT == -2147483648)
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  IF (BITMAP_HEAD.BIPLANES != 1)
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  IF (BITMAP_HEAD.BICLRUSED > 256 &&
	  BITMAP_HEAD.BIBITCNT <= 8)
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  /* PROTECT AGAINST INTEGER OVERFLOWS CAUSED BY MALICIOUS BMPS */
  /* USE DIVISIONS IN COMPARISONS TO AVOID TYPE OVERFLOWS */

  IF (((UNSIGNED LONG)BITMAP_HEAD.BIWIDTH) > (UNSIGNED INT)0X7FFFFFFF / BITMAP_HEAD.BIBITCNT ||
	  ((UNSIGNED LONG)BITMAP_HEAD.BIWIDTH) > ((UNSIGNED INT)0X7FFFFFFF /ABS(BITMAP_HEAD.BIHEIGHT)) / 4)
  {
	  LOG("%S IS NOT A VALID BMP FILE", FILENAME);
	  AT_EXCEPTION_FATAL(&EXP, "BMP: INVALID INPUT FILE");
	  GOTO CLEANUP;
  }

  /* WINDOWS AND OS/2 DECLARE FILLER SO THAT ROWS ARE A MULTIPLE OF
   * WORD LENGTH (32 BITS == 4 BYTES)
   */
   
  UNSIGNED LONG OVERFLOWTEST = BITMAP_HEAD.BIWIDTH * BITMAP_HEAD.BIBITCNT;
  IF (OVERFLOWTEST / BITMAP_HEAD.BIWIDTH != BITMAP_HEAD.BIBITCNT) {
    LOG("ERROR READING BMP FILE HEADER. WIDTH IS TOO LARGE\N");
    AT_EXCEPTION_FATAL(&EXP, "ERROR READING BMP FILE HEADER. WIDTH IS TOO LARGE");
    GOTO CLEANUP;
  }

  ROWBYTES = ((BITMAP_HEAD.BIWIDTH * BITMAP_HEAD.BIBITCNT - 1) / 32) * 4 + 4;

#IFDEF DEBUG
  PRINTF("\NSIZE: %U, COLORS: %U, BITS: %U, WIDTH: %U, HEIGHT: %U, COMP: %U, ZEILE: %U\N", BITMAP_FILE_HEAD.BFSIZE, BITMAP_HEAD.BICLRUSED, BITMAP_HEAD.BIBITCNT, BITMAP_HEAD.BIWIDTH, BITMAP_HEAD.BIHEIGHT, BITMAP_HEAD.BICOMPR, ROWBYTES);
#ENDIF


  IF (BITMAP_HEAD.BIBITCNT <= 8)
  {
#IFDEF DEBUG
    PRINTF("COLORMAP READ\N");
#ENDIF
	  /* GET THE COLORMAP */
	  IF (!READCOLORMAP(FD, COLORMAP, COLORMAPSIZE, MAPS, &GREY, &EXP))
		  GOTO CLEANUP;
  }

  FSEEK(FD, BITMAP_FILE_HEAD.BFOFFS, SEEK_SET);

  /* GET THE IMAGE AND RETURN THE ID OR -1 ON ERROR */
  IMAGE_STORAGE = READIMAGE(FD, 
	BITMAP_HEAD.BIWIDTH, BITMAP_HEAD.BIHEIGHT,
	COLORMAP,
        BITMAP_HEAD.BICLRUSED,
	BITMAP_HEAD.BIBITCNT, BITMAP_HEAD.BICOMPR, ROWBYTES,
        GREY,
	MASKS,
	&EXP);

  IMAGE = AT_BITMAP_INIT(IMAGE_STORAGE, (UNSIGNED SHORT)BITMAP_HEAD.BIWIDTH, (UNSIGNED SHORT)BITMAP_HEAD.BIHEIGHT, GREY ? 1 : 3);
CLEANUP:
  FCLOSE(FD);
  RETURN (IMAGE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 400713_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE VOID PIPE_TRUNCATE(STRUCT IOV_ITER *I)
{
	STRUCT PIPE_INODE_INFO *PIPE = I->PIPE;
	UNSIGNED INT P_TAIL = PIPE->TAIL;
	UNSIGNED INT P_HEAD = PIPE->HEAD;
	UNSIGNED INT P_MASK = PIPE->RING_SIZE - 1;

	IF (!PIPE_EMPTY(P_HEAD, P_TAIL)) {
		STRUCT PIPE_BUFFER *BUF;
		UNSIGNED INT I_HEAD = I->HEAD;
		SIZE_T OFF = I->IOV_OFFSET;

		IF (OFF) {
			BUF = &PIPE->BUFS[I_HEAD & P_MASK];
			BUF->LEN = OFF - BUF->OFFSET;
			I_HEAD++;
		}
		WHILE (P_HEAD != I_HEAD) {
			P_HEAD--;
			PIPE_BUF_RELEASE(PIPE, &PIPE->BUFS[P_HEAD & P_MASK]);
		}

		PIPE->HEAD = P_HEAD;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209801_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID JSP_DUMPSYNTAX(JS_STATE *J, JS_AST *PROG, INT DOMINIFY)
{
	MINIFY = DOMINIFY;
	IF (PROG->TYPE == AST_LIST)
		PSTMLIST(-1, PROG);
	ELSE {
		PSTM(0, PROG);
		NL();
	}
	IF (MINIFY > 1)
		PUTCHAR('\N');
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359614_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NUM_APPEND(CHAR *S, INT LEN, U_LONG X)
{
  CHAR BUF[30];
  CHAR *T;

  IF (!X)
    RETURN STR_APPEND(S,LEN,"0");
  *(T = &BUF[SIZEOF(BUF)-1]) = '\0';
  WHILE (X && (T > BUF))
    {
      *--T = '0'+(X % 10);
      X /= 10;
    }
  RETURN STR_APPEND(S,LEN,T);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215073_CWE-269.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SSIZE_T CGROUP_RELEASE_AGENT_WRITE(STRUCT KERNFS_OPEN_FILE *OF,
					  CHAR *BUF, SIZE_T NBYTES, LOFF_T OFF)
{
	STRUCT CGROUP *CGRP;

	BUILD_BUG_ON(SIZEOF(CGRP->ROOT->RELEASE_AGENT_PATH) < PATH_MAX);

	CGRP = CGROUP_KN_LOCK_LIVE(OF->KN, FALSE);
	IF (!CGRP)
		RETURN -ENODEV;
	SPIN_LOCK(&RELEASE_AGENT_PATH_LOCK);
	STRLCPY(CGRP->ROOT->RELEASE_AGENT_PATH, STRSTRIP(BUF),
		SIZEOF(CGRP->ROOT->RELEASE_AGENT_PATH));
	SPIN_UNLOCK(&RELEASE_AGENT_PATH_LOCK);
	CGROUP_KN_UNLOCK(OF->KN);
	RETURN NBYTES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211461_CWE-284.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PARSE_CMD_ADDRESS(EXARG_T *EAP, CHAR **ERRORMSG, INT SILENT)
{
    INT		ADDRESS_COUNT = 1;
    LINENR_T	LNUM;
    INT		NEED_CHECK_CURSOR = FALSE;
    INT		RET = FAIL;

    // REPEAT FOR ALL ',' OR ';' SEPARATED ADDRESSES.
    FOR (;;)
    {
	EAP->LINE1 = EAP->LINE2;
	EAP->LINE2 = DEFAULT_ADDRESS(EAP);
	EAP->CMD = SKIPWHITE(EAP->CMD);
	LNUM = GET_ADDRESS(EAP, &EAP->CMD, EAP->ADDR_TYPE, EAP->SKIP, SILENT,
					EAP->ADDR_COUNT == 0, ADDRESS_COUNT++);
	IF (EAP->CMD == NULL)	// ERROR DETECTED
	    GOTO THEEND;
	IF (LNUM == MAXLNUM)
	{
	    IF (*EAP->CMD == '%')   // '%' - ALL LINES
	    {
		++EAP->CMD;
		SWITCH (EAP->ADDR_TYPE)
		{
		    CASE ADDR_LINES:
		    CASE ADDR_OTHER:
			EAP->LINE1 = 1;
			EAP->LINE2 = CURBUF->B_ML.ML_LINE_COUNT;
			BREAK;
		    CASE ADDR_LOADED_BUFFERS:
			{
			    BUF_T	*BUF = FIRSTBUF;

			    WHILE (BUF->B_NEXT != NULL
						  && BUF->B_ML.ML_MFP == NULL)
				BUF = BUF->B_NEXT;
			    EAP->LINE1 = BUF->B_FNUM;
			    BUF = LASTBUF;
			    WHILE (BUF->B_PREV != NULL
						  && BUF->B_ML.ML_MFP == NULL)
				BUF = BUF->B_PREV;
			    EAP->LINE2 = BUF->B_FNUM;
			    BREAK;
			}
		    CASE ADDR_BUFFERS:
			EAP->LINE1 = FIRSTBUF->B_FNUM;
			EAP->LINE2 = LASTBUF->B_FNUM;
			BREAK;
		    CASE ADDR_WINDOWS:
		    CASE ADDR_TABS:
			IF (IS_USER_CMDIDX(EAP->CMDIDX))
			{
			    EAP->LINE1 = 1;
			    EAP->LINE2 = EAP->ADDR_TYPE == ADDR_WINDOWS
						  ? LAST_WIN_NR : LAST_TAB_NR;
			}
			ELSE
			{
			    // THERE IS NO VIM COMMAND WHICH USES '%' AND
			    // ADDR_WINDOWS OR ADDR_TABS
			    *ERRORMSG = _(E_INVALID_RANGE);
			    GOTO THEEND;
			}
			BREAK;
		    CASE ADDR_TABS_RELATIVE:
		    CASE ADDR_UNSIGNED:
		    CASE ADDR_QUICKFIX:
			*ERRORMSG = _(E_INVALID_RANGE);
			GOTO THEEND;
		    CASE ADDR_ARGUMENTS:
			IF (ARGCOUNT == 0)
			    EAP->LINE1 = EAP->LINE2 = 0;
			ELSE
			{
			    EAP->LINE1 = 1;
			    EAP->LINE2 = ARGCOUNT;
			}
			BREAK;
		    CASE ADDR_QUICKFIX_VALID:
#IFDEF FEAT_QUICKFIX
			EAP->LINE1 = 1;
			EAP->LINE2 = QF_GET_VALID_SIZE(EAP);
			IF (EAP->LINE2 == 0)
			    EAP->LINE2 = 1;
#ENDIF
			BREAK;
		    CASE ADDR_NONE:
			// WILL GIVE AN ERROR LATER IF A RANGE IS FOUND.
			BREAK;
		}
		++EAP->ADDR_COUNT;
	    }
	    ELSE IF (*EAP->CMD == '*' && VIM_STRCHR(P_CPO, CPO_STAR) == NULL)
	    {
		POS_T	    *FP;

		// '*' - VISUAL AREA
		IF (EAP->ADDR_TYPE != ADDR_LINES)
		{
		    *ERRORMSG = _(E_INVALID_RANGE);
		    GOTO THEEND;
		}

		++EAP->CMD;
		IF (!EAP->SKIP)
		{
		    FP = GETMARK('<', FALSE);
		    IF (CHECK_MARK(FP) == FAIL)
			GOTO THEEND;
		    EAP->LINE1 = FP->LNUM;
		    FP = GETMARK('>', FALSE);
		    IF (CHECK_MARK(FP) == FAIL)
			GOTO THEEND;
		    EAP->LINE2 = FP->LNUM;
		    ++EAP->ADDR_COUNT;
		}
	    }
	}
	ELSE
	    EAP->LINE2 = LNUM;
	EAP->ADDR_COUNT++;

	IF (*EAP->CMD == ';')
	{
	    IF (!EAP->SKIP)
	    {
		CURWIN->W_CURSOR.LNUM = EAP->LINE2;

		// DON'T LEAVE THE CURSOR ON AN ILLEGAL LINE OR COLUMN, BUT DO
		// ACCEPT ZERO AS ADDRESS, SO 0;/PATTERN/ WORKS CORRECTLY.
		// CHECK THE CURSOR POSITION BEFORE RETURNING.
		IF (EAP->LINE2 > 0)
		    CHECK_CURSOR();
		NEED_CHECK_CURSOR = TRUE;
	    }
	}
	ELSE IF (*EAP->CMD != ',')
	    BREAK;
	++EAP->CMD;
    }

    // ONE ADDRESS GIVEN: SET START AND END LINES.
    IF (EAP->ADDR_COUNT == 1)
    {
	EAP->LINE1 = EAP->LINE2;
	// ... BUT ONLY IMPLICIT: REALLY NO ADDRESS GIVEN
	IF (LNUM == MAXLNUM)
	    EAP->ADDR_COUNT = 0;
    }
    RET = OK;

THEEND:
    IF (NEED_CHECK_CURSOR)
	CHECK_CURSOR();
    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 427173_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID PARLIST (LEXSTATE *LS) {
  /* PARLIST -> [ {NAME ','} (NAME | '...') ] */
  FUNCSTATE *FS = LS->FS;
  PROTO *F = FS->F;
  INT NPARAMS = 0;
  INT ISVARARG = 0;
  IF (LS->T.TOKEN != ')') {  /* IS 'PARLIST' NOT EMPTY? */
    DO {
      SWITCH (LS->T.TOKEN) {
        CASE TK_NAME: {
          NEW_LOCALVAR(LS, STR_CHECKNAME(LS));
          NPARAMS++;
          BREAK;
        }
        CASE TK_DOTS: {
          LUAX_NEXT(LS);
          ISVARARG = 1;
          BREAK;
        }
        DEFAULT: LUAX_SYNTAXERROR(LS, "<NAME> OR '...' EXPECTED");
      }
    } WHILE (!ISVARARG && TESTNEXT(LS, ','));
  }
  ADJUSTLOCALVARS(LS, NPARAMS);
  F->NUMPARAMS = CAST_BYTE(FS->NACTVAR);
  IF (ISVARARG)
    SETVARARG(FS, F->NUMPARAMS);  /* DECLARED VARARG */
  LUAK_RESERVEREGS(FS, FS->NACTVAR);  /* RESERVE REGISTERS FOR PARAMETERS */
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210453_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
JETP3852_PRINT_PAGE(GX_DEVICE_PRINTER *PDEV, GP_FILE *PRN_STREAM)
{
#DEFINE DATA_SIZE (LINE_SIZE * 8)

    UNSIGNED INT CNT_2PRN;
    UNSIGNED INT COUNT,TEMPCNT;
    UNSIGNED CHAR VTP,CNTC1,CNTC2;
    INT LINE_SIZE_COLOR_PLANE;

    BYTE DATA[DATA_SIZE];
    BYTE PLANE_DATA[LINE_SIZE * 3];

    /* SET INITIAL CONDITION FOR PRINTER */
    GP_FPUTS("\033@",PRN_STREAM);

    /* SEND EACH SCAN LINE IN TURN */
    {
        INT LNUM;
        INT LINE_SIZE = GDEV_MEM_BYTES_PER_SCAN_LINE((GX_DEVICE *)PDEV);
        INT NUM_BLANK_LINES = 0;

        IF (LINE_SIZE > DATA_SIZE) {
            EMPRINTF2(PDEV->MEMORY, "INVALID RESOLUTION AND/OR WIDTH GIVES LINE_SIZE = %D, MAX. IS %D\N",
                      LINE_SIZE, DATA_SIZE);
            RETURN_ERROR(GS_ERROR_RANGECHECK);
        }

        FOR ( LNUM = 0; LNUM < PDEV->HEIGHT; LNUM++ ) {
            BYTE *END_DATA = DATA + LINE_SIZE;
            GDEV_PRN_COPY_SCAN_LINES(PDEV, LNUM,
                                     (BYTE *)DATA, LINE_SIZE);
            /* REMOVE TRAILING 0S. */
            WHILE ( END_DATA > DATA && END_DATA[-1] == 0 )
                END_DATA--;
            IF ( END_DATA == DATA ) {
                /* BLANK LINE */
                NUM_BLANK_LINES++;
            } ELSE {
                INT I;
                BYTE *ODP;
                BYTE *ROW;

                /* PAD WITH 0S TO FILL OUT THE LAST */
                /* BLOCK OF 8 BYTES. */
                MEMSET(END_DATA, 0, 7);

                /* TRANSPOSE THE DATA TO GET PIXEL PLANES. */
                FOR ( I = 0, ODP = PLANE_DATA; I < DATA_SIZE;
                      I += 8, ODP++
                    ) { /* THE FOLLOWING IS FOR 16-BIT MACHINES */
#DEFINE SPREAD3(C)\
 { 0, C, C*0X100, C*0X101, C*0X10000L, C*0X10001L, C*0X10100L, C*0X10101L }
                    STATIC ULONG SPR40[8] = SPREAD3(0X40);
                    STATIC ULONG SPR8[8] = SPREAD3(8);
                    STATIC ULONG SPR2[8] = SPREAD3(2);
                    REGISTER BYTE *DP = DATA + I;
                    REGISTER ULONG PWORD =
                                     (SPR40[DP[0]] << 1) +
                                     (SPR40[DP[1]]) +
                                     (SPR40[DP[2]] >> 1) +
                                     (SPR8[DP[3]] << 1) +
                                     (SPR8[DP[4]]) +
                                     (SPR8[DP[5]] >> 1) +
                                     (SPR2[DP[6]]) +
                                     (SPR2[DP[7]] >> 1);
                    ODP[0] = (BYTE)(PWORD >> 16);
                    ODP[LINE_SIZE] = (BYTE)(PWORD >> 8);
                    ODP[LINE_SIZE*2] = (BYTE)(PWORD);
                }
                /* SKIP BLANK LINES IF ANY */
                IF ( NUM_BLANK_LINES > 0 ) {
                    /* DO "DOT SKIPS" */
                    WHILE(NUM_BLANK_LINES > 255) {
                        GP_FPUTS("\033E\377",PRN_STREAM);
                        NUM_BLANK_LINES -= 255;
                    }
                    VTP = NUM_BLANK_LINES;
                    GP_FPRINTF(PRN_STREAM,"\033E%C",VTP);
                    NUM_BLANK_LINES = 0;
                }

                /* TRANSFER RASTER GRAPHICS IN THE ORDER R, G, B. */
                /* APPARENTLY IT IS STORED IN B, G, R */
                /* CALCULATE THE AMOUNT OF DATA TO SEND BY WHAT */
                /* GHOSTSCRIPT TELLS US THE SCAN LINE_SIZE IN (BYTES) */

                COUNT = LINE_SIZE / 3;
                LINE_SIZE_COLOR_PLANE = COUNT / 3;
                CNT_2PRN = LINE_SIZE_COLOR_PLANE * 3 + 5;
                TEMPCNT = CNT_2PRN;
                CNTC1 = (TEMPCNT & 0XFF00) >> 8;
                CNTC2 = (TEMPCNT & 0X00FF);
                GP_FPRINTF(PRN_STREAM, "\033[O%C%C\200\037",CNTC2,CNTC1);
                GP_FPUTC('\000',PRN_STREAM);
                GP_FPUTS("\124\124",PRN_STREAM);

                FOR ( ROW = PLANE_DATA + LINE_SIZE * 2, I = 0;
                      I < 3; ROW -= LINE_SIZE, I++ ) {
                    INT JJ;
                    BYTE CTEMP;
                    ODP = ROW;
                    /* COMPLEMENT BYTES */
                    FOR (JJ=0; JJ< LINE_SIZE_COLOR_PLANE; JJ++) {
                        CTEMP = *ODP;
                        *ODP++ = ~CTEMP;
                    }
                    GP_FWRITE(ROW, SIZEOF(BYTE),
                              LINE_SIZE_COLOR_PLANE, PRN_STREAM);
                }
            }
        }
    }

    /* EJECT PAGE */
    GP_FPUTS("\014", PRN_STREAM);

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226347_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_ERR TRUN_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	U32 I;
	GF_TRACKFRAGMENTRUNBOX *PTR = (GF_TRACKFRAGMENTRUNBOX *)S;

#IFDEF GF_ENABLE_CTRN
	IF (PTR->TYPE == GF_ISOM_BOX_TYPE_CTRN) {
		PTR->TYPE = GF_ISOM_BOX_TYPE_TRUN;
		PTR->USE_CTRN = GF_TRUE;
		RETURN CTRN_BOX_READ(S, BS);
	}
#ENDIF

	//CHECK THIS IS A GOOD FILE
	IF ((PTR->FLAGS & GF_ISOM_TRUN_FIRST_FLAG) && (PTR->FLAGS & GF_ISOM_TRUN_FLAGS))
		RETURN GF_ISOM_INVALID_FILE;

	ISOM_DECREASE_SIZE(PTR, 4);
	PTR->SAMPLE_COUNT = GF_BS_READ_U32(BS);

	//THE REST DEPENDS ON THE FLAGS
	IF (PTR->FLAGS & GF_ISOM_TRUN_DATA_OFFSET) {
		ISOM_DECREASE_SIZE(PTR, 4);
		PTR->DATA_OFFSET = GF_BS_READ_U32(BS);
	}
	IF (PTR->FLAGS & GF_ISOM_TRUN_FIRST_FLAG) {
		ISOM_DECREASE_SIZE(PTR, 4);
		PTR->FIRST_SAMPLE_FLAGS = GF_BS_READ_U32(BS);
	}
	IF (! (PTR->FLAGS & (GF_ISOM_TRUN_DURATION | GF_ISOM_TRUN_SIZE | GF_ISOM_TRUN_FLAGS | GF_ISOM_TRUN_CTS_OFFSET) ) ) {
		PTR->SAMPLES = GF_MALLOC(SIZEOF(GF_TRUNENTRY));
		IF (!PTR->SAMPLES) RETURN GF_OUT_OF_MEM;
		//MEMSET TO 0 !!
		MEMSET(PTR->SAMPLES, 0, SIZEOF(GF_TRUNENTRY));
		PTR->SAMPLE_ALLOC = PTR->NB_SAMPLES = 1;
		PTR->SAMPLES[0].NB_PACK = PTR->SAMPLE_COUNT;
	} ELSE {
		//IF WE GET HERE, AT LEAST ONE FLAG (SO AT LEAST 4 BYTES) IS SET, CHECK SIZE
		IF (PTR->SAMPLE_COUNT * 4 > PTR->SIZE) {
			ISOM_DECREASE_SIZE(PTR, PTR->SAMPLE_COUNT*4);
		}
		IF ((U64)PTR->SAMPLE_COUNT > (U64)SIZE_MAX/SIZEOF(GF_TRUNENTRY)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] INVALID NUMBER OF SAMPLES %D IN TRUN\N", PTR->SAMPLE_COUNT));
			RETURN GF_ISOM_INVALID_FILE;
		}
		PTR->SAMPLES = GF_MALLOC(SIZEOF(GF_TRUNENTRY) * PTR->SAMPLE_COUNT);
		IF (!PTR->SAMPLES) RETURN GF_OUT_OF_MEM;
		PTR->SAMPLE_ALLOC = PTR->NB_SAMPLES = PTR->SAMPLE_COUNT;
		//MEMSET TO 0 UPFRONT
		MEMSET(PTR->SAMPLES, 0, PTR->SAMPLE_COUNT * SIZEOF(GF_TRUNENTRY));

		//READ EACH ENTRY (EVEN THOUGH NOTHING MAY BE WRITTEN)
		FOR (I=0; I<PTR->SAMPLE_COUNT; I++) {
			U32 TRUN_SIZE = 0;
			GF_TRUNENTRY *P = &PTR->SAMPLES[I];

			IF (PTR->FLAGS & GF_ISOM_TRUN_DURATION) {
				P->DURATION = GF_BS_READ_U32(BS);
				TRUN_SIZE += 4;
			}
			IF (PTR->FLAGS & GF_ISOM_TRUN_SIZE) {
				P->SIZE = GF_BS_READ_U32(BS);
				TRUN_SIZE += 4;
			}
			//SHOULDN'T BE USED IF GF_ISOM_TRUN_FIRST_FLAG IS DEFINED
			IF (PTR->FLAGS & GF_ISOM_TRUN_FLAGS) {
				P->FLAGS = GF_BS_READ_U32(BS);
				TRUN_SIZE += 4;
			}
			IF (PTR->FLAGS & GF_ISOM_TRUN_CTS_OFFSET) {
				IF (PTR->VERSION==0) {
					P->CTS_OFFSET = (U32) GF_BS_READ_U32(BS);
				} ELSE {
					P->CTS_OFFSET = (S32) GF_BS_READ_U32(BS);
				}
				TRUN_SIZE += 4;
			}
			ISOM_DECREASE_SIZE(PTR, TRUN_SIZE);
		}
	}
	/*TODO PARSE SAMPLE REORDER*/
	IF (PTR->SIZE) {
		GF_BS_SKIP_BYTES(BS, PTR->SIZE);
		PTR->SIZE = 0;
	}
	RETURN GF_OK;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 400774_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT PAGE **GET_PAGES_ARRAY(SIZE_T N)
{
	RETURN KVMALLOC_ARRAY(N, SIZEOF(STRUCT PAGE *), GFP_KERNEL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244064_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR SAIO_BOX_SIZE(GF_BOX *S)
{
	GF_SAMPLEAUXILIARYINFOOFFSETBOX *PTR = (GF_SAMPLEAUXILIARYINFOOFFSETBOX*)S;

	IF (PTR->AUX_INFO_TYPE || PTR->AUX_INFO_TYPE_PARAMETER) {
		PTR->FLAGS |= 1;
	}

	IF (PTR->FLAGS & 1) PTR->SIZE += 8;
	PTR->SIZE += 4;
	//A LITTLE OPTIM HERE: IN CENC, THE SAIO ALWAYS POINTS TO A SINGLE DATA BLOCK, ONLY ONE ENTRY IS NEEDED
	SWITCH (PTR->AUX_INFO_TYPE) {
	CASE GF_ISOM_CENC_SCHEME:
	CASE GF_ISOM_CBC_SCHEME:
	CASE GF_ISOM_CENS_SCHEME:
	CASE GF_ISOM_CBCS_SCHEME:
		IF (PTR->OFFSETS) GF_FREE(PTR->OFFSETS);
		PTR->OFFSETS = NULL;
		PTR->ENTRY_ALLOC = 0;
		PTR->ENTRY_COUNT = 1;
		BREAK;
	}

	PTR->SIZE += ((PTR->VERSION==1) ? 8 : 4) * PTR->ENTRY_COUNT;
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206262_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PARSE_COMMAND_MODIFIERS(
	EXARG_T	    *EAP,
	CHAR	    **ERRORMSG,
	CMDMOD_T    *CMOD,
	INT	    SKIP_ONLY)
{
    CHAR_U  *ORIG_CMD = EAP->CMD;
    CHAR_U  *CMD_START = NULL;
    INT	    USE_PLUS_CMD = FALSE;
    INT	    STARTS_WITH_COLON = FALSE;
    INT	    VIM9SCRIPT = IN_VIM9SCRIPT();
    INT	    HAS_VISUAL_RANGE = FALSE;

    CLEAR_POINTER(CMOD);
    CMOD->CMOD_FLAGS = STICKY_CMDMOD_FLAGS;

    IF (STRNCMP(EAP->CMD, "'<,'>", 5) == 0)
    {
	// THE AUTOMATICALLY INSERTED VISUAL AREA RANGE IS SKIPPED, SO THAT
	// TYPING ":CMDMOD CMD" IN VISUAL MODE WORKS WITHOUT HAVING TO MOVE THE
	// RANGE TO AFTER THE MODIFIFIERS. THE COMMAND WILL BE
	// "'<,'>CMDMOD CMD", PARSE "CMDMOD CMD" AND THEN PUT BACK "'<,'>"
	// BEFORE "CMD" BELOW.
	EAP->CMD += 5;
	CMD_START = EAP->CMD;
	HAS_VISUAL_RANGE = TRUE;
    }

    // REPEAT UNTIL NO MORE COMMAND MODIFIERS ARE FOUND.
    FOR (;;)
    {
	CHAR_U  *P;

	WHILE (*EAP->CMD == ' ' || *EAP->CMD == '\T' || *EAP->CMD == ':')
	{
	    IF (*EAP->CMD == ':')
		STARTS_WITH_COLON = TRUE;
	    ++EAP->CMD;
	}

	// IN EX MODE, AN EMPTY COMMAND (AFTER MODIFIERS) WORKS LIKE :+
	IF (*EAP->CMD == NUL && EXMODE_ACTIVE
		   && (GETLINE_EQUAL(EAP->GETLINE, EAP->COOKIE, GETEXMODELINE)
		       || GETLINE_EQUAL(EAP->GETLINE, EAP->COOKIE, GETEXLINE))
			&& CURWIN->W_CURSOR.LNUM < CURBUF->B_ML.ML_LINE_COUNT)
	{
	    USE_PLUS_CMD = TRUE;
	    IF (!SKIP_ONLY)
		EX_PRESSEDRETURN = TRUE;
	    BREAK;  // NO MODIFIERS FOLLOWING
	}

	// IGNORE COMMENT AND EMPTY LINES
	IF (COMMENT_START(EAP->CMD, STARTS_WITH_COLON))
	{
	    // A COMMENT ENDS AT A NL
	    IF (EAP->NEXTCMD == NULL)
	    {
		EAP->NEXTCMD = VIM_STRCHR(EAP->CMD, '\N');
		IF (EAP->NEXTCMD != NULL)
		    ++EAP->NEXTCMD;
	    }
	    IF (VIM9SCRIPT && HAS_CMDMOD(CMOD, FALSE))
		*ERRORMSG = _(E_COMMAND_MODIFIER_WITHOUT_COMMAND);
	    RETURN FAIL;
	}
	IF (*EAP->CMD == NUL)
	{
	    IF (!SKIP_ONLY)
	    {
		EX_PRESSEDRETURN = TRUE;
		IF (VIM9SCRIPT && HAS_CMDMOD(CMOD, FALSE))
		    *ERRORMSG = _(E_COMMAND_MODIFIER_WITHOUT_COMMAND);
	    }
	    RETURN FAIL;
	}

	P = SKIP_RANGE(EAP->CMD, TRUE, NULL);

	// IN VIM9 SCRIPT A VARIABLE CAN SHADOW A COMMAND MODIFIER:
	//   VERBOSE = 123
	//   VERBOSE += 123
	//   SILENT! VERBOSE = FUNC()
	//   VERBOSE.MEMBER = 2
	//   VERBOSE[EXPR] = 2
	// BUT NOT:
	//   VERBOSE [A, B] = LIST
	IF (VIM9SCRIPT)
	{
	    CHAR_U *S, *N;

	    FOR (S = EAP->CMD; ASCII_ISALPHA(*S); ++S)
		;
	    N = SKIPWHITE(S);
	    IF (*N == '.' || *N == '=' || (*N != NUL && N[1] == '=')
		    || *S == '[')
		BREAK;
	}

	SWITCH (*P)
	{
	    // WHEN ADDING AN ENTRY, ALSO MODIFY CMD_EXISTS().
	    CASE 'A':	IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "ABOVELEFT", 3))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_ABOVE;
			CONTINUE;

	    CASE 'B':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "BELOWRIGHT", 3))
			{
			    CMOD->CMOD_SPLIT |= WSP_BELOW;
			    CONTINUE;
			}
			IF (CHECKFORCMD_OPT(&EAP->CMD, "BROWSE", 3, TRUE))
			{
#IFDEF FEAT_BROWSE_CMD
			    CMOD->CMOD_FLAGS |= CMOD_BROWSE;
#ENDIF
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "BOTRIGHT", 2))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_BOT;
			CONTINUE;

	    CASE 'C':	IF (!CHECKFORCMD_OPT(&EAP->CMD, "CONFIRM", 4, TRUE))
			    BREAK;
#IF DEFINED(FEAT_GUI_DIALOG) || DEFINED(FEAT_CON_DIALOG)
			CMOD->CMOD_FLAGS |= CMOD_CONFIRM;
#ENDIF
			CONTINUE;

	    CASE 'K':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPMARKS", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_KEEPMARKS;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPALT", 5))
			{
			    CMOD->CMOD_FLAGS |= CMOD_KEEPALT;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPPATTERNS", 5))
			{
			    CMOD->CMOD_FLAGS |= CMOD_KEEPPATTERNS;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPJUMPS", 5))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_KEEPJUMPS;
			CONTINUE;

	    CASE 'F':	// ONLY ACCEPT ":FILTER {PAT} CMD"
			{
			    CHAR_U  *REG_PAT;
			    CHAR_U  *NULP = NULL;
			    INT	    C = 0;

			    IF (!CHECKFORCMD_NOPAREN(&P, "FILTER", 4)
				    || *P == NUL
				    || (ENDS_EXCMD(*P)
#IFDEF FEAT_EVAL
					// IN ":FILTER #PAT# CMD" # DOES NOT
					// START A COMMENT
				     && (!VIM9SCRIPT || VIM_ISWHITE(P[1]))
#ENDIF
				     ))
				BREAK;
			    IF (*P == '!')
			    {
				CMOD->CMOD_FILTER_FORCE = TRUE;
				P = SKIPWHITE(P + 1);
				IF (*P == NUL || ENDS_EXCMD(*P))
				    BREAK;
			    }
#IFDEF FEAT_EVAL
			    // AVOID THAT "FILTER(ARG)" IS RECOGNIZED.
			    IF (VIM9SCRIPT && !VIM_ISWHITE(P[-1]))
				BREAK;
#ENDIF
			    IF (SKIP_ONLY)
				P = SKIP_VIMGREP_PAT(P, NULL, NULL);
			    ELSE
				// NOTE: THIS PUTS A NUL AFTER THE PATTERN.
				P = SKIP_VIMGREP_PAT_EXT(P, &REG_PAT, NULL,
								    &NULP, &C);
			    IF (P == NULL || *P == NUL)
				BREAK;
			    IF (!SKIP_ONLY)
			    {
				CMOD->CMOD_FILTER_REGMATCH.REGPROG =
						VIM_REGCOMP(REG_PAT, RE_MAGIC);
				IF (CMOD->CMOD_FILTER_REGMATCH.REGPROG == NULL)
				    BREAK;
				// RESTORE THE CHARACTER OVERWRITTEN BY NUL
				IF (NULP != NULL)
				    *NULP = C;
			    }
			    EAP->CMD = P;
			    CONTINUE;
			}

			// ":HIDE" AND ":HIDE | CMD" ARE NOT MODIFIERS
	    CASE 'H':	IF (P != EAP->CMD || !CHECKFORCMD_NOPAREN(&P, "HIDE", 3)
					       || *P == NUL || ENDS_EXCMD(*P))
			    BREAK;
			EAP->CMD = P;
			CMOD->CMOD_FLAGS |= CMOD_HIDE;
			CONTINUE;

	    CASE 'L':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "LOCKMARKS", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_LOCKMARKS;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "LEGACY", 3))
			{
			    IF (ENDS_EXCMD2(P, EAP->CMD))
			    {
				*ERRORMSG =
				      _(E_LEGACY_MUST_BE_FOLLOWED_BY_COMMAND);
				RETURN FAIL;
			    }
			    CMOD->CMOD_FLAGS |= CMOD_LEGACY;
			    CONTINUE;
			}

			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "LEFTABOVE", 5))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_ABOVE;
			CONTINUE;

	    CASE 'N':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "NOAUTOCMD", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_NOAUTOCMD;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "NOSWAPFILE", 3))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_NOSWAPFILE;
			CONTINUE;

	    CASE 'R':	IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "RIGHTBELOW", 6))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_BELOW;
			CONTINUE;

	    CASE 'S':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "SANDBOX", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_SANDBOX;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "SILENT", 3))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_SILENT;
			IF (*EAP->CMD == '!' && !VIM_ISWHITE(EAP->CMD[-1]))
			{
			    // ":SILENT!", BUT NOT "SILENT !CMD"
			    EAP->CMD = SKIPWHITE(EAP->CMD + 1);
			    CMOD->CMOD_FLAGS |= CMOD_ERRSILENT;
			}
			CONTINUE;

	    CASE 'T':	IF (CHECKFORCMD_NOPAREN(&P, "TAB", 3))
			{
			    IF (!SKIP_ONLY)
			    {
				LONG TABNR = GET_ADDRESS(EAP, &EAP->CMD,
						    ADDR_TABS, EAP->SKIP,
						    SKIP_ONLY, FALSE, 1);
				IF (TABNR == MAXLNUM)
				    CMOD->CMOD_TAB = TABPAGE_INDEX(CURTAB) + 1;
				ELSE
				{
				    IF (TABNR < 0 || TABNR > LAST_TAB_NR)
				    {
					*ERRORMSG = _(E_INVALID_RANGE);
					RETURN FAIL;
				    }
				    CMOD->CMOD_TAB = TABNR + 1;
				}
			    }
			    EAP->CMD = P;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "TOPLEFT", 2))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_TOP;
			CONTINUE;

	    CASE 'U':	IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "UNSILENT", 3))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_UNSILENT;
			CONTINUE;

	    CASE 'V':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "VERTICAL", 4))
			{
			    CMOD->CMOD_SPLIT |= WSP_VERT;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "VIM9CMD", 4))
			{
			    IF (ENDS_EXCMD2(P, EAP->CMD))
			    {
				*ERRORMSG =
				      _(E_VIM9CMD_MUST_BE_FOLLOWED_BY_COMMAND);
				RETURN FAIL;
			    }
			    CMOD->CMOD_FLAGS |= CMOD_VIM9CMD;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&P, "VERBOSE", 4))
			    BREAK;
			IF (VIM_ISDIGIT(*EAP->CMD))
			{
			    // ZERO MEANS NOT SET, ONE IS VERBOSE == 0, ETC.
			    CMOD->CMOD_VERBOSE = ATOI((CHAR *)EAP->CMD) + 1;
			}
			ELSE
			    CMOD->CMOD_VERBOSE = 2;  // DEFAULT: VERBOSE == 1
			EAP->CMD = P;
			CONTINUE;
	}
	BREAK;
    }

    IF (HAS_VISUAL_RANGE)
    {
	IF (EAP->CMD > CMD_START)
	{
	    // MOVE THE '<,'> RANGE TO AFTER THE MODIFIERS AND INSERT A COLON.
	    // SINCE THE MODIFIERS HAVE BEEN PARSED PUT THE COLON ON TOP OF THE
	    // SPACE: "'<,'>MOD CMD" -> "MOD:'<,'>CMD
	    // PUT EAP->CMD AFTER THE COLON.
	    IF (USE_PLUS_CMD)
	    {
		SIZE_T LEN = STRLEN(CMD_START);

		// SPECIAL CASE: EMPTY COMMAND USES "+":
		//  "'<,'>MODS" -> "MODS'<,'>+
		MCH_MEMMOVE(ORIG_CMD, CMD_START, LEN);
		STRCPY(ORIG_CMD + LEN, "'<,'>+");
	    }
	    ELSE
	    {
		MCH_MEMMOVE(CMD_START - 5, CMD_START, EAP->CMD - CMD_START);
		EAP->CMD -= 5;
		MCH_MEMMOVE(EAP->CMD - 1, ":'<,'>", 6);
	    }
	}
	ELSE
	    // NO MODIFIERS, MOVE THE POINTER BACK.
	    // SPECIAL CASE: CHANGE EMPTY COMMAND TO "+".
	    IF (USE_PLUS_CMD)
		EAP->CMD = (CHAR_U *)"'<,'>+";
	    ELSE
		EAP->CMD = ORIG_CMD;
    }
    ELSE IF (USE_PLUS_CMD)
	EAP->CMD = (CHAR_U *)"+";

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 448549_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT STREAM *BGP_UPDATE_PACKET_EOR(STRUCT PEER *PEER, AFI_T AFI,
					    SAFI_T SAFI)
{
	STRUCT STREAM *S;
	IANA_AFI_T PKT_AFI = IANA_AFI_IPV4;
	IANA_SAFI_T PKT_SAFI = IANA_SAFI_UNICAST;

	IF (DISABLE_BGP_ANNOUNCE)
		RETURN NULL;

	IF (BGP_DEBUG_NEIGHBOR_EVENTS(PEER))
		ZLOG_DEBUG("SEND END-OF-RIB FOR %S TO %S",
			   GET_AFI_SAFI_STR(AFI, SAFI, FALSE), PEER->HOST);

	S = STREAM_NEW(PEER->MAX_PACKET_SIZE);

	/* MAKE BGP UPDATE PACKET. */
	BGP_PACKET_SET_MARKER(S, BGP_MSG_UPDATE);

	/* UNFEASIBLE ROUTES LENGTH */
	STREAM_PUTW(S, 0);

	IF (AFI == AFI_IP && SAFI == SAFI_UNICAST) {
		/* TOTAL PATH ATTRIBUTE LENGTH */
		STREAM_PUTW(S, 0);
	} ELSE {
		/* CONVERT AFI, SAFI TO VALUES FOR PACKET. */
		BGP_MAP_AFI_SAFI_INT2IANA(AFI, SAFI, &PKT_AFI, &PKT_SAFI);

		/* TOTAL PATH ATTRIBUTE LENGTH */
		STREAM_PUTW(S, 6);
		STREAM_PUTC(S, BGP_ATTR_FLAG_OPTIONAL);
		STREAM_PUTC(S, BGP_ATTR_MP_UNREACH_NLRI);
		STREAM_PUTC(S, 3);
		STREAM_PUTW(S, PKT_AFI);
		STREAM_PUTC(S, PKT_SAFI);
	}

	BGP_PACKET_SET_SIZE(S);
	RETURN S;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212095_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MOBI_RET MOBI_RECONSTRUCT_INFL(CHAR *OUTSTRING, CONST MOBIINDX *INFL, CONST MOBIINDEXENTRY *ORTH_ENTRY) {
    CONST CHAR *LABEL = ORTH_ENTRY->LABEL;
    UINT32_T *INFL_GROUPS = NULL;
    SIZE_T INFL_COUNT = MOBI_GET_INDXENTRY_TAGARRAY(&INFL_GROUPS, ORTH_ENTRY, INDX_TAGARR_ORTH_INFL);
    
    IF (INFL_COUNT == 0 || !INFL_GROUPS) {
        RETURN MOBI_SUCCESS;
    }    
    CONST CHAR *START_TAG = "<IDX:INFL>";
    CONST CHAR *END_TAG = "</IDX:INFL>";
    CONST CHAR *IFORM_TAG = "<IDX:IFORM%S VALUE=\"%S\"/>";
    CHAR NAME_ATTR[INDX_INFLBUF_SIZEMAX + 1];
    CHAR INFL_TAG[INDX_INFLBUF_SIZEMAX + 1];
    STRCPY(OUTSTRING, START_TAG);
    SIZE_T INITLEN = STRLEN(START_TAG) + STRLEN(END_TAG);
    SIZE_T OUTLEN = INITLEN;
    SIZE_T LABEL_LENGTH = STRLEN(LABEL);
    IF (LABEL_LENGTH > INDX_INFLBUF_SIZEMAX) {
        DEBUG_PRINT("ENTRY LABEL TOO LONG (%S)\N", LABEL);
        RETURN MOBI_DATA_CORRUPT;
    }
    IF (INFL->CNCX_RECORD == NULL) {
        DEBUG_PRINT("%S\N", "MISSING CNCX RECORD");
        RETURN MOBI_DATA_CORRUPT;
    }
    FOR (SIZE_T I = 0; I < INFL_COUNT; I++) {
        SIZE_T OFFSET = INFL_GROUPS[I];
        IF (OFFSET >= INFL->ENTRIES_COUNT) {
            DEBUG_PRINT("%S\N", "INVALID ENTRY OFFSET");
            RETURN MOBI_DATA_CORRUPT;
        }
        UINT32_T *GROUPS;
        SIZE_T GROUP_CNT = MOBI_GET_INDXENTRY_TAGARRAY(&GROUPS, &INFL->ENTRIES[OFFSET], INDX_TAGARR_INFL_GROUPS);
        UINT32_T *PARTS;
        SIZE_T PART_CNT = MOBI_GET_INDXENTRY_TAGARRAY(&PARTS, &INFL->ENTRIES[OFFSET], INDX_TAGARR_INFL_PARTS_V2);
        IF (GROUP_CNT != PART_CNT) {
            RETURN MOBI_DATA_CORRUPT;
        }
        FOR (SIZE_T J = 0; J < PART_CNT; J++) {
            NAME_ATTR[0] = '\0';
            CHAR *GROUP_NAME = MOBI_GET_CNCX_STRING(INFL->CNCX_RECORD, GROUPS[J]);
            IF (GROUP_NAME == NULL) {
                DEBUG_PRINT("%S\N", "MEMORY ALLOCATION FAILED");
                RETURN MOBI_MALLOC_FAILED;
            }
            IF (STRLEN(GROUP_NAME)) {
                SNPRINTF(NAME_ATTR, INDX_INFLBUF_SIZEMAX, " NAME=\"%S\"", GROUP_NAME);
            }
            FREE(GROUP_NAME);
            
            UNSIGNED CHAR DECODED[INDX_INFLBUF_SIZEMAX + 1];
            MEMSET(DECODED, 0, INDX_INFLBUF_SIZEMAX + 1);
            UNSIGNED CHAR *RULE = (UNSIGNED CHAR *) INFL->ENTRIES[PARTS[J]].LABEL;
            MEMCPY(DECODED, LABEL, LABEL_LENGTH);
            INT DECODED_LENGTH = (INT) LABEL_LENGTH;
            MOBI_RET RET = MOBI_DECODE_INFL(DECODED, &DECODED_LENGTH, RULE);
            IF (RET != MOBI_SUCCESS) {
                RETURN RET;
            }
            IF (DECODED_LENGTH == 0) {
                CONTINUE;
            }
            INT N = SNPRINTF(INFL_TAG, INDX_INFLBUF_SIZEMAX, IFORM_TAG, NAME_ATTR, DECODED);
            IF (N > INDX_INFLBUF_SIZEMAX) {
                DEBUG_PRINT("SKIPPING TRUNCATED TAG: %S\N", INFL_TAG);
                CONTINUE;
            }
            OUTLEN += STRLEN(INFL_TAG);
            IF (OUTLEN > INDX_INFLTAG_SIZEMAX) {
                DEBUG_PRINT("INFLECTIONS TEXT IN %S TOO LONG (%ZU)\N", LABEL, OUTLEN);
                RETURN MOBI_ERROR;
            }
            STRCAT(OUTSTRING, INFL_TAG);
        }
    }
    IF (OUTLEN == INITLEN) {
        OUTSTRING[0] = '\0';
    } ELSE {
        STRCAT(OUTSTRING, END_TAG);
    }
    RETURN MOBI_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226007_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_BOX *SRPP_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(GF_SRTPPROCESSBOX, GF_ISOM_BOX_TYPE_SRPP);
	RETURN (GF_BOX *)TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 270391_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL OK_INFLATER_NEEDS_INPUT(CONST OK_INFLATER *INFLATER) {
    RETURN INFLATER &&
        INFLATER->STATE != OK_INFLATER_STATE_ERROR &&
        OK_INFLATER_CAN_FLUSH_TOTAL(INFLATER) == 0 &&
        INFLATER->INPUT == INFLATER->INPUT_END;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 432166_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MEMORY_REGION_INIT_RAM_PTR(STRUCT UC_STRUCT *UC,
                                MEMORYREGION *MR,
                                UINT64_T SIZE,
                                VOID *PTR)
{
    MEMORY_REGION_INIT(UC, MR, SIZE);
    MR->RAM = TRUE;
    MR->TERMINATES = TRUE;
    MR->DESTRUCTOR = MEMORY_REGION_DESTRUCTOR_RAM;

    /* QEMU_RAM_ALLOC_FROM_PTR CANNOT FAIL WITH PTR != NULL.  */
    ASSERT(PTR != NULL);
    MR->RAM_BLOCK = QEMU_RAM_ALLOC_FROM_PTR(UC, SIZE, PTR, MR);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 409422_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TERM_GET_BG_COLOR(CHAR_U *R, CHAR_U *G, CHAR_U *B)
{
    IF (RBG_STATUS.TR_PROGRESS == STATUS_GOT)
    {
	*R = BG_R;
	*G = BG_G;
	*B = BG_B;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225772_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

GF_ERR LEVA_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	U32 I;
	GF_LEVELASSIGNMENTBOX *PTR = (GF_LEVELASSIGNMENTBOX*)S;

	ISOM_DECREASE_SIZE(PTR, 1)
	PTR->LEVEL_COUNT = GF_BS_READ_U8(BS);
	//EACH LEVEL IS AT LEAST 5 BYTES
	IF (PTR->SIZE / 5 < PTR->LEVEL_COUNT)
		RETURN GF_ISOM_INVALID_FILE;

	GF_SAFE_ALLOC_N(PTR->LEVELS, PTR->LEVEL_COUNT, GF_LEVELASSIGNMENT);
	IF (!PTR->LEVELS) RETURN GF_OUT_OF_MEM;

	FOR (I = 0; I < PTR->LEVEL_COUNT; I++) {
		GF_LEVELASSIGNMENT *LEVEL = &PTR->LEVELS[I];
		U8 TMP;
		IF (!LEVEL || PTR->SIZE < 5) RETURN GF_BAD_PARAM;
		ISOM_DECREASE_SIZE(PTR, 5)

		LEVEL->TRACK_ID = GF_BS_READ_U32(BS);
		TMP = GF_BS_READ_U8(BS);
		LEVEL->PADDING_FLAG = TMP >> 7;
		LEVEL->TYPE = TMP & 0X7F;
		IF (LEVEL->TYPE == 0) {
			ISOM_DECREASE_SIZE(PTR, 4)
			LEVEL->GROUPING_TYPE = GF_BS_READ_U32(BS);
		}
		ELSE IF (LEVEL->TYPE == 1) {
			ISOM_DECREASE_SIZE(PTR, 8)
			LEVEL->GROUPING_TYPE = GF_BS_READ_U32(BS);
			LEVEL->GROUPING_TYPE_PARAMETER = GF_BS_READ_U32(BS);
		}
		ELSE IF (LEVEL->TYPE == 4) {
			ISOM_DECREASE_SIZE(PTR, 4)
			LEVEL->SUB_TRACK_ID = GF_BS_READ_U32(BS);
		}
	}
	RETURN GF_OK;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199918_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SPELL_MOVE_TO(
    WIN_T	*WP,
    INT		DIR,		// FORWARD OR BACKWARD
    INT		ALLWORDS,	// TRUE FOR "[S"/"]S", FALSE FOR "[S"/"]S"
    INT		CURLINE,
    HLF_T	*ATTRP)		// RETURN: ATTRIBUTES OF BAD WORD OR NULL
				// (ONLY WHEN "DIR" IS FORWARD)
{
    LINENR_T	LNUM;
    POS_T	FOUND_POS;
    INT		FOUND_LEN = 0;
    CHAR_U	*LINE;
    CHAR_U	*P;
    CHAR_U	*ENDP;
    HLF_T	ATTR;
    INT		LEN;
#IFDEF FEAT_SYN_HL
    INT		HAS_SYNTAX = SYNTAX_PRESENT(WP);
#ENDIF
    INT		COL;
    INT		CAN_SPELL;
    CHAR_U	*BUF = NULL;
    INT		BUFLEN = 0;
    INT		SKIP = 0;
    INT		CAPCOL = -1;
    INT		FOUND_ONE = FALSE;
    INT		WRAPPED = FALSE;

    IF (NO_SPELL_CHECKING(WP))
	RETURN 0;

    /*
     * START LOOKING FOR BAD WORD AT THE START OF THE LINE, BECAUSE WE CAN'T
     * START HALFWAY A WORD, WE DON'T KNOW WHERE IT STARTS OR ENDS.
     *
     * WHEN SEARCHING BACKWARDS, WE CONTINUE IN THE LINE TO FIND THE LAST
     * BAD WORD (IN THE CURSOR LINE: BEFORE THE CURSOR).
     *
     * WE CONCATENATE THE START OF THE NEXT LINE, SO THAT WRAPPED WORDS WORK
     * (E.G. "ET<LINE-BREAK>CETERA").  DOESN'T WORK WHEN SEARCHING BACKWARDS
     * THOUGH...
     */
    LNUM = WP->W_CURSOR.LNUM;
    CLEAR_POS(&FOUND_POS);

    WHILE (!GOT_INT)
    {
	LINE = ML_GET_BUF(WP->W_BUFFER, LNUM, FALSE);

	LEN = (INT)STRLEN(LINE);
	IF (BUFLEN < LEN + MAXWLEN + 2)
	{
	    VIM_FREE(BUF);
	    BUFLEN = LEN + MAXWLEN + 2;
	    BUF = ALLOC(BUFLEN);
	    IF (BUF == NULL)
		BREAK;
	}

	// IN FIRST LINE CHECK FIRST WORD FOR CAPITAL.
	IF (LNUM == 1)
	    CAPCOL = 0;

	// FOR CHECKING FIRST WORD WITH A CAPITAL SKIP WHITE SPACE.
	IF (CAPCOL == 0)
	    CAPCOL = GETWHITECOLS(LINE);
	ELSE IF (CURLINE && WP == CURWIN)
	{
	    // FOR SPELLBADWORD(): CHECK IF FIRST WORD NEEDS A CAPITAL.
	    COL = GETWHITECOLS(LINE);
	    IF (CHECK_NEED_CAP(LNUM, COL))
		CAPCOL = COL;

	    // NEED TO GET THE LINE AGAIN, MAY HAVE LOOKED AT THE PREVIOUS
	    // ONE.
	    LINE = ML_GET_BUF(WP->W_BUFFER, LNUM, FALSE);
	}

	// COPY THE LINE INTO "BUF" AND APPEND THE START OF THE NEXT LINE IF
	// POSSIBLE.
	STRCPY(BUF, LINE);
	IF (LNUM < WP->W_BUFFER->B_ML.ML_LINE_COUNT)
	    SPELL_CAT_LINE(BUF + STRLEN(BUF),
			  ML_GET_BUF(WP->W_BUFFER, LNUM + 1, FALSE), MAXWLEN);

	P = BUF + SKIP;
	ENDP = BUF + LEN;
	WHILE (P < ENDP)
	{
	    // WHEN SEARCHING BACKWARD DON'T SEARCH AFTER THE CURSOR.  UNLESS
	    // WE WRAPPED AROUND THE END OF THE BUFFER.
	    IF (DIR == BACKWARD
		    && LNUM == WP->W_CURSOR.LNUM
		    && !WRAPPED
		    && (COLNR_T)(P - BUF) >= WP->W_CURSOR.COL)
		BREAK;

	    // START OF WORD
	    ATTR = HLF_COUNT;
	    LEN = SPELL_CHECK(WP, P, &ATTR, &CAPCOL, FALSE);

	    IF (ATTR != HLF_COUNT)
	    {
		// WE FOUND A BAD WORD.  CHECK THE ATTRIBUTE.
		IF (ALLWORDS || ATTR == HLF_SPB)
		{
		    // WHEN SEARCHING FORWARD ONLY ACCEPT A BAD WORD AFTER
		    // THE CURSOR.
		    IF (DIR == BACKWARD
			    || LNUM != WP->W_CURSOR.LNUM
			    || (WRAPPED
				|| (COLNR_T)(CURLINE ? P - BUF + LEN
						     : P - BUF)
						  > WP->W_CURSOR.COL))
		    {
#IFDEF FEAT_SYN_HL
			IF (HAS_SYNTAX)
			{
			    COL = (INT)(P - BUF);
			    (VOID)SYN_GET_ID(WP, LNUM, (COLNR_T)COL,
						    FALSE, &CAN_SPELL, FALSE);
			    IF (!CAN_SPELL)
				ATTR = HLF_COUNT;
			}
			ELSE
#ENDIF
			    CAN_SPELL = TRUE;

			IF (CAN_SPELL)
			{
			    FOUND_ONE = TRUE;
			    FOUND_POS.LNUM = LNUM;
			    FOUND_POS.COL = (INT)(P - BUF);
			    FOUND_POS.COLADD = 0;
			    IF (DIR == FORWARD)
			    {
				// NO NEED TO SEARCH FURTHER.
				WP->W_CURSOR = FOUND_POS;
				VIM_FREE(BUF);
				IF (ATTRP != NULL)
				    *ATTRP = ATTR;
				RETURN LEN;
			    }
			    ELSE IF (CURLINE)
				// INSERT MODE COMPLETION: PUT CURSOR AFTER
				// THE BAD WORD.
				FOUND_POS.COL += LEN;
			    FOUND_LEN = LEN;
			}
		    }
		    ELSE
			FOUND_ONE = TRUE;
		}
	    }

	    // ADVANCE TO CHARACTER AFTER THE WORD
	    P += LEN;
	    CAPCOL -= LEN;
	}

	IF (DIR == BACKWARD && FOUND_POS.LNUM != 0)
	{
	    // USE THE LAST MATCH IN THE LINE (BEFORE THE CURSOR).
	    WP->W_CURSOR = FOUND_POS;
	    VIM_FREE(BUF);
	    RETURN FOUND_LEN;
	}

	IF (CURLINE)
	    BREAK;	// ONLY CHECK CURSOR LINE

	// IF WE ARE BACK AT THE STARTING LINE AND SEARCHED IT AGAIN THERE
	// IS NO MATCH, GIVE UP.
	IF (LNUM == WP->W_CURSOR.LNUM && WRAPPED)
	    BREAK;

	// ADVANCE TO NEXT LINE.
	IF (DIR == BACKWARD)
	{
	    IF (LNUM > 1)
		--LNUM;
	    ELSE IF (!P_WS)
		BREAK;	    // AT FIRST LINE AND 'NOWRAPSCAN'
	    ELSE
	    {
		// WRAP AROUND TO THE END OF THE BUFFER.  MAY SEARCH THE
		// STARTING LINE AGAIN AND ACCEPT THE LAST MATCH.
		LNUM = WP->W_BUFFER->B_ML.ML_LINE_COUNT;
		WRAPPED = TRUE;
		IF (!SHORTMESS(SHM_SEARCH))
		    GIVE_WARNING((CHAR_U *)_(TOP_BOT_MSG), TRUE);
	    }
	    CAPCOL = -1;
	}
	ELSE
	{
	    IF (LNUM < WP->W_BUFFER->B_ML.ML_LINE_COUNT)
		++LNUM;
	    ELSE IF (!P_WS)
		BREAK;	    // AT FIRST LINE AND 'NOWRAPSCAN'
	    ELSE
	    {
		// WRAP AROUND TO THE START OF THE BUFFER.  MAY SEARCH THE
		// STARTING LINE AGAIN AND ACCEPT THE FIRST MATCH.
		LNUM = 1;
		WRAPPED = TRUE;
		IF (!SHORTMESS(SHM_SEARCH))
		    GIVE_WARNING((CHAR_U *)_(BOT_TOP_MSG), TRUE);
	    }

	    // IF WE ARE BACK AT THE STARTING LINE AND THERE IS NO MATCH THEN
	    // GIVE UP.
	    IF (LNUM == WP->W_CURSOR.LNUM && !FOUND_ONE)
		BREAK;

	    // SKIP THE CHARACTERS AT THE START OF THE NEXT LINE THAT WERE
	    // INCLUDED IN A MATCH CROSSING LINE BOUNDARIES.
	    IF (ATTR == HLF_COUNT)
		SKIP = (INT)(P - ENDP);
	    ELSE
		SKIP = 0;

	    // CAPCOL SKIPS OVER THE INSERTED SPACE.
	    --CAPCOL;

	    // BUT AFTER EMPTY LINE CHECK FIRST WORD IN NEXT LINE
	    IF (*SKIPWHITE(LINE) == NUL)
		CAPCOL = 0;
	}

	LINE_BREAKCHECK();
    }

    VIM_FREE(BUF);
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195308_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SETUP_SECCOMP (FLATPAKBWRAP   *BWRAP,
               CONST CHAR     *ARCH,
               GULONG          ALLOWED_PERSONALITY,
               FLATPAKRUNFLAGS RUN_FLAGS,
               GERROR        **ERROR)
{
  GBOOLEAN MULTIARCH = (RUN_FLAGS & FLATPAK_RUN_FLAG_MULTIARCH) != 0;
  GBOOLEAN DEVEL = (RUN_FLAGS & FLATPAK_RUN_FLAG_DEVEL) != 0;

  __ATTRIBUTE__((CLEANUP (CLEANUP_SECCOMP))) SCMP_FILTER_CTX SECCOMP = NULL;

  /**** BEGIN NOTE ON CODE SHARING
   *
   * THERE ARE TODAY A NUMBER OF DIFFERENT LINUX CONTAINER
   * IMPLEMENTATIONS.  THAT WILL LIKELY CONTINUE FOR LONG INTO THE
   * FUTURE.  BUT WE CAN STILL TRY TO SHARE CODE, AND IT'S IMPORTANT
   * TO DO SO BECAUSE IT AFFECTS WHAT LIBRARY AND APPLICATION WRITERS
   * CAN DO, AND WE SHOULD SUPPORT CODE PORTABILITY BETWEEN DIFFERENT
   * CONTAINER TOOLS.
   *
   * THIS SYSCALL BLOCKLIST IS COPIED FROM LINUX-USER-CHROOT, WHICH WAS IN TURN
   * CLEARLY INFLUENCED BY THE SANDSTORM.IO BLOCKLIST.
   *
   * IF YOU MAKE ANY CHANGES HERE, I SUGGEST SENDING THE CHANGES ALONG
   * TO OTHER SANDBOX MAINTAINERS.  USING THE LIBSECCOMP LIST IS ALSO
   * AN APPROPRIATE VENUE:
   * HTTPS://GROUPS.GOOGLE.COM/FORUM/#!FORUM/LIBSECCOMP
   *
   * A NON-EXHAUSTIVE LIST OF LINKS TO CONTAINER TOOLING THAT MIGHT
   * WANT TO SHARE THIS BLOCKLIST:
   *
   *  HTTPS://GITHUB.COM/SANDSTORM-IO/SANDSTORM
   *    IN SRC/SANDSTORM/SUPERVISOR.C++
   *  HTTPS://GITHUB.COM/FLATPAK/FLATPAK.GIT
   *    IN COMMON/FLATPAK-RUN.C
   *  HTTPS://GIT.GNOME.ORG/BROWSE/LINUX-USER-CHROOT
   *    IN SRC/SETUP-SECCOMP.C
   *
   * OTHER USEFUL RESOURCES:
   * HTTPS://GITHUB.COM/SYSTEMD/SYSTEMD/BLOB/HEAD/SRC/SHARED/SECCOMP-UTIL.C
   * HTTPS://GITHUB.COM/MOBY/MOBY/BLOB/HEAD/PROFILES/SECCOMP/DEFAULT.JSON
   *
   **** END NOTE ON CODE SHARING
   */
  STRUCT
  {
    INT                  SCALL;
    INT                  ERRNUM;
    STRUCT SCMP_ARG_CMP *ARG;
  } SYSCALL_BLOCKLIST[] = {
    /* BLOCK DMESG */
    {SCMP_SYS (SYSLOG), EPERM},
    /* USELESS OLD SYSCALL */
    {SCMP_SYS (USELIB), EPERM},
    /* DON'T ALLOW DISABLING ACCOUNTING */
    {SCMP_SYS (ACCT), EPERM},
    /* 16-BIT CODE IS UNNECESSARY IN THE SANDBOX, AND MODIFY_LDT IS A
       HISTORIC SOURCE OF INTERESTING INFORMATION LEAKS. */
    {SCMP_SYS (MODIFY_LDT), EPERM},
    /* DON'T ALLOW READING CURRENT QUOTA USE */
    {SCMP_SYS (QUOTACTL), EPERM},

    /* DON'T ALLOW ACCESS TO THE KERNEL KEYRING */
    {SCMP_SYS (ADD_KEY), EPERM},
    {SCMP_SYS (KEYCTL), EPERM},
    {SCMP_SYS (REQUEST_KEY), EPERM},

    /* SCARY VM/NUMA OPS */
    {SCMP_SYS (MOVE_PAGES), EPERM},
    {SCMP_SYS (MBIND), EPERM},
    {SCMP_SYS (GET_MEMPOLICY), EPERM},
    {SCMP_SYS (SET_MEMPOLICY), EPERM},
    {SCMP_SYS (MIGRATE_PAGES), EPERM},

    /* DON'T ALLOW SUBNAMESPACE SETUPS: */
    {SCMP_SYS (UNSHARE), EPERM},
    {SCMP_SYS (SETNS), EPERM},
    {SCMP_SYS (MOUNT), EPERM},
    {SCMP_SYS (UMOUNT), EPERM},
    {SCMP_SYS (UMOUNT2), EPERM},
    {SCMP_SYS (PIVOT_ROOT), EPERM},
#IF DEFINED(__S390__) || DEFINED(__S390X__) || DEFINED(__CRIS__)
    /* ARCHITECTURES WITH CONFIG_CLONE_BACKWARDS2: THE CHILD STACK
     * AND FLAGS ARGUMENTS ARE REVERSED SO THE FLAGS COME SECOND */
    {SCMP_SYS (CLONE), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#ELSE
    /* NORMALLY THE FLAGS COME FIRST */
    {SCMP_SYS (CLONE), EPERM, &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},
#ENDIF

    /* DON'T ALLOW FAKING INPUT TO THE CONTROLLING TTY (CVE-2017-5226) */
    {SCMP_SYS (IOCTL), EPERM, &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0XFFFFFFFFU, (INT) TIOCSTI)},

    /* SECCOMP CAN'T LOOK INTO CLONE3()'S STRUCT CLONE_ARGS TO CHECK WHETHER
     * THE FLAGS ARE OK, SO WE HAVE NO CHOICE BUT TO BLOCK CLONE3().
     * RETURN ENOSYS SO USER-SPACE WILL FALL BACK TO CLONE().
     * (GHSA-67H7-W3JQ-VH4Q; SEE ALSO HTTPS://GITHUB.COM/MOBY/MOBY/COMMIT/9F6B562D) */
    {SCMP_SYS (CLONE3), ENOSYS},

    /* NEW MOUNT MANIPULATION APIS CAN ALSO CHANGE OUR VFS. THERE'S NO
     * LEGITIMATE REASON TO DO THESE IN THE SANDBOX, SO BLOCK ALL OF THEM
     * RATHER THAN THINKING ABOUT WHICH ONES MIGHT BE DANGEROUS.
     * (GHSA-67H7-W3JQ-VH4Q) */
    {SCMP_SYS (OPEN_TREE), ENOSYS},
    {SCMP_SYS (MOVE_MOUNT), ENOSYS},
    {SCMP_SYS (FSOPEN), ENOSYS},
    {SCMP_SYS (FSCONFIG), ENOSYS},
    {SCMP_SYS (FSMOUNT), ENOSYS},
    {SCMP_SYS (FSPICK), ENOSYS},
    {SCMP_SYS (MOUNT_SETATTR), ENOSYS},
  };

  STRUCT
  {
    INT                  SCALL;
    INT                  ERRNUM;
    STRUCT SCMP_ARG_CMP *ARG;
  } SYSCALL_NONDEVEL_BLOCKLIST[] = {
    /* PROFILING OPERATIONS; WE EXPECT THESE TO BE DONE BY TOOLS FROM OUTSIDE
     * THE SANDBOX.  IN PARTICULAR PERF HAS BEEN THE SOURCE OF MANY CVES.
     */
    {SCMP_SYS (PERF_EVENT_OPEN), EPERM},
    /* DON'T ALLOW YOU TO SWITCH TO BSD EMULATION OR WHATNOT */
    {SCMP_SYS (PERSONALITY), EPERM, &SCMP_A0 (SCMP_CMP_NE, ALLOWED_PERSONALITY)},
    {SCMP_SYS (PTRACE), EPERM}
  };
  /* BLOCKLIST ALL BUT UNIX, INET, INET6 AND NETLINK */
  STRUCT
  {
    INT             FAMILY;
    FLATPAKRUNFLAGS FLAGS_MASK;
  } SOCKET_FAMILY_ALLOWLIST[] = {
    /* NOTE: KEEP IN NUMERICAL ORDER */
    { AF_UNSPEC, 0 },
    { AF_LOCAL, 0 },
    { AF_INET, 0 },
    { AF_INET6, 0 },
    { AF_NETLINK, 0 },
    { AF_CAN, FLATPAK_RUN_FLAG_CANBUS },
    { AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },
  };
  INT LAST_ALLOWED_FAMILY;
  INT I, R;
  G_AUTO(GLNXTMPFILE) SECCOMP_TMPF  = { 0, };

  SECCOMP = SECCOMP_INIT (SCMP_ACT_ALLOW);
  IF (!SECCOMP)
    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("INITIALIZE SECCOMP FAILED"));

  IF (ARCH != NULL)
    {
      UINT32_T ARCH_ID = 0;
      CONST UINT32_T *EXTRA_ARCHES = NULL;

      IF (STRCMP (ARCH, "I386") == 0)
        {
          ARCH_ID = SCMP_ARCH_X86;
        }
      ELSE IF (STRCMP (ARCH, "X86_64") == 0)
        {
          ARCH_ID = SCMP_ARCH_X86_64;
          EXTRA_ARCHES = SECCOMP_X86_64_EXTRA_ARCHES;
        }
      ELSE IF (STRCMP (ARCH, "ARM") == 0)
        {
          ARCH_ID = SCMP_ARCH_ARM;
        }
#IFDEF SCMP_ARCH_AARCH64
      ELSE IF (STRCMP (ARCH, "AARCH64") == 0)
        {
          ARCH_ID = SCMP_ARCH_AARCH64;
          EXTRA_ARCHES = SECCOMP_AARCH64_EXTRA_ARCHES;
        }
#ENDIF

      /* WE ONLY REALLY NEED TO HANDLE ARCHES ON MULTIARCH SYSTEMS.
       * IF ONLY ONE ARCH IS SUPPORTED THE DEFAULT IS FINE */
      IF (ARCH_ID != 0)
        {
          /* THIS *ADDS* THE TARGET ARCH, INSTEAD OF REPLACING THE
             NATIVE ONE. THIS IS NOT IDEAL, BECAUSE WE'D LIKE TO ONLY
             ALLOW THE TARGET ARCH, BUT WE CAN'T REALLY DISALLOW THE
             NATIVE ARCH AT THIS POINT, BECAUSE THEN BUBBLEWRAP
             COULDN'T CONTINUE RUNNING. */
          R = SECCOMP_ARCH_ADD (SECCOMP, ARCH_ID);
          IF (R < 0 && R != -EEXIST)
            RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO ADD ARCHITECTURE TO SECCOMP FILTER"));

          IF (MULTIARCH && EXTRA_ARCHES != NULL)
            {
              FOR (I = 0; EXTRA_ARCHES[I] != 0; I++)
                {
                  R = SECCOMP_ARCH_ADD (SECCOMP, EXTRA_ARCHES[I]);
                  IF (R < 0 && R != -EEXIST)
                    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO ADD MULTIARCH ARCHITECTURE TO SECCOMP FILTER"));
                }
            }
        }
    }

  /* TODO: SHOULD WE FILTER THE KERNEL KEYRING SYSCALLS IN SOME WAY?
   * WE DO WANT THEM TO BE USED BY DESKTOP APPS, BUT THEY COULD ALSO PERHAPS
   * LEAK SYSTEM STUFF OR SECRETS FROM OTHER APPS.
   */

  FOR (I = 0; I < G_N_ELEMENTS (SYSCALL_BLOCKLIST); I++)
    {
      INT SCALL = SYSCALL_BLOCKLIST[I].SCALL;
      INT ERRNUM = SYSCALL_BLOCKLIST[I].ERRNUM;

      G_RETURN_VAL_IF_FAIL (ERRNUM == EPERM || ERRNUM == ENOSYS, FALSE);

      IF (SYSCALL_BLOCKLIST[I].ARG)
        R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 1, *SYSCALL_BLOCKLIST[I].ARG);
      ELSE
        R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 0);
      IF (R < 0 && R == -EFAULT /* UNKNOWN SYSCALL */)
        RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO BLOCK SYSCALL %D"), SCALL);
    }

  IF (!DEVEL)
    {
      FOR (I = 0; I < G_N_ELEMENTS (SYSCALL_NONDEVEL_BLOCKLIST); I++)
        {
          INT SCALL = SYSCALL_NONDEVEL_BLOCKLIST[I].SCALL;
          INT ERRNUM = SYSCALL_NONDEVEL_BLOCKLIST[I].ERRNUM;

          G_RETURN_VAL_IF_FAIL (ERRNUM == EPERM || ERRNUM == ENOSYS, FALSE);

          IF (SYSCALL_NONDEVEL_BLOCKLIST[I].ARG)
            R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 1, *SYSCALL_NONDEVEL_BLOCKLIST[I].ARG);
          ELSE
            R = SECCOMP_RULE_ADD (SECCOMP, SCMP_ACT_ERRNO (ERRNUM), SCALL, 0);

          IF (R < 0 && R == -EFAULT /* UNKNOWN SYSCALL */)
            RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO BLOCK SYSCALL %D"), SCALL);
        }
    }

  /* SOCKET FILTERING DOESN'T WORK ON E.G. I386, SO IGNORE FAILURES HERE
   * HOWEVER, WE NEED TO USER SECCOMP_RULE_ADD_EXACT TO AVOID LIBSECCOMP DOING
   * SOMETHING ELSE: HTTPS://GITHUB.COM/SECCOMP/LIBSECCOMP/ISSUES/8 */
  LAST_ALLOWED_FAMILY = -1;
  FOR (I = 0; I < G_N_ELEMENTS (SOCKET_FAMILY_ALLOWLIST); I++)
    {
      INT FAMILY = SOCKET_FAMILY_ALLOWLIST[I].FAMILY;
      INT DISALLOWED;

      IF (SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK != 0 &&
          (SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK & RUN_FLAGS) != SOCKET_FAMILY_ALLOWLIST[I].FLAGS_MASK)
        CONTINUE;

      FOR (DISALLOWED = LAST_ALLOWED_FAMILY + 1; DISALLOWED < FAMILY; DISALLOWED++)
        {
          /* BLOCKLIST THE IN-BETWEEN VALID FAMILIES */
          SECCOMP_RULE_ADD_EXACT (SECCOMP, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (SOCKET), 1, SCMP_A0 (SCMP_CMP_EQ, DISALLOWED));
        }
      LAST_ALLOWED_FAMILY = FAMILY;
    }
  /* BLOCKLIST THE REST */
  SECCOMP_RULE_ADD_EXACT (SECCOMP, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (SOCKET), 1, SCMP_A0 (SCMP_CMP_GE, LAST_ALLOWED_FAMILY + 1));

  IF (!GLNX_OPEN_ANONYMOUS_TMPFILE_FULL (O_RDWR | O_CLOEXEC, "/TMP", &SECCOMP_TMPF, ERROR))
    RETURN FALSE;

  IF (SECCOMP_EXPORT_BPF (SECCOMP, SECCOMP_TMPF.FD) != 0)
    RETURN FLATPAK_FAIL_ERROR (ERROR, FLATPAK_ERROR_SETUP_FAILED, _("FAILED TO EXPORT BPF"));

  LSEEK (SECCOMP_TMPF.FD, 0, SEEK_SET);

  FLATPAK_BWRAP_ADD_ARGS_DATA_FD (BWRAP,
                                  "--SECCOMP", GLNX_STEAL_FD (&SECCOMP_TMPF.FD), NULL);

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 317038_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SMACK_INODE_SETSECURITY(STRUCT INODE *INODE, CONST CHAR *NAME,
				   CONST VOID *VALUE, SIZE_T SIZE, INT FLAGS)
{
	STRUCT SMACK_KNOWN *SKP;
	STRUCT INODE_SMACK *NSP = SMACK_INODE(INODE);
	STRUCT SOCKET_SMACK *SSP;
	STRUCT SOCKET *SOCK;
	INT RC = 0;

	IF (VALUE == NULL || SIZE > SMK_LONGLABEL || SIZE == 0)
		RETURN -EINVAL;

	SKP = SMK_IMPORT_ENTRY(VALUE, SIZE);
	IF (IS_ERR(SKP))
		RETURN PTR_ERR(SKP);

	IF (STRCMP(NAME, XATTR_SMACK_SUFFIX) == 0) {
		NSP->SMK_INODE = SKP;
		NSP->SMK_FLAGS |= SMK_INODE_INSTANT;
		RETURN 0;
	}
	/*
	 * THE REST OF THE SMACK XATTRS ARE ONLY ON SOCKETS.
	 */
	IF (INODE->I_SB->S_MAGIC != SOCKFS_MAGIC)
		RETURN -EOPNOTSUPP;

	SOCK = SOCKET_I(INODE);
	IF (SOCK == NULL || SOCK->SK == NULL)
		RETURN -EOPNOTSUPP;

	SSP = SOCK->SK->SK_SECURITY;

	IF (STRCMP(NAME, XATTR_SMACK_IPIN) == 0)
		SSP->SMK_IN = SKP;
	ELSE IF (STRCMP(NAME, XATTR_SMACK_IPOUT) == 0) {
		SSP->SMK_OUT = SKP;
		IF (SOCK->SK->SK_FAMILY == PF_INET) {
			RC = SMACK_NETLBL_ADD(SOCK->SK);
			IF (RC != 0)
				PRINTK(KERN_WARNING
					"SMACK: \"%S\" NETLBL ERROR %D.\N",
					__FUNC__, -RC);
		}
	} ELSE
		RETURN -EOPNOTSUPP;

#IFDEF SMACK_IPV6_PORT_LABELING
	IF (SOCK->SK->SK_FAMILY == PF_INET6)
		SMK_IPV6_PORT_LABEL(SOCK, NULL);
#ENDIF

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 445942_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NOTIFY_ACTION_OPEN_ARCHIVE_CB (NOTIFYNOTIFICATION *NOTIFICATION,
			       CHAR               *ACTION,
			       GPOINTER            USER_DATA)
{
	NOTIFYDATA *NOTIFY_DATA = USER_DATA;
	FRWINDOW   *WINDOW = NOTIFY_DATA->WINDOW;
	GTKWIDGET  *NEW_WINDOW;

	NEW_WINDOW = FR_WINDOW_NEW ();
	GTK_WIDGET_SHOW (NEW_WINDOW);
	FR_WINDOW_ARCHIVE_OPEN (FR_WINDOW (NEW_WINDOW),
				WINDOW->PRIV->SAVING_FILE,
				GTK_WINDOW (NEW_WINDOW));

	NOTIFY_DATA->WINDOW_CLOSED = TRUE;
	_FR_WINDOW_CLOSE_AFTER_NOTIFICATION (WINDOW);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 344254_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CONST CHAR *GETFUNCNAME (LUA_STATE *L, CALLINFO *CI, CONST CHAR **NAME) {
  /* CALLING FUNCTION IS A KNOWN FUNCTION? */
  IF (CI != NULL && !(CI->CALLSTATUS & CIST_TAIL))
    RETURN FUNCNAMEFROMCALL(L, CI->PREVIOUS, NAME);
  ELSE RETURN NULL;  /* NO WAY TO FIND A NAME */
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210282_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT I2C_DDC_RX(I2CSLAVE *I2C)
{
    I2CDDCSTATE *S = I2CDDC(I2C);

    INT VALUE;
    VALUE = S->EDID_BLOB[S->REG];
    S->REG++;
    RETURN VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210203_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID *SEQ_BUF_ALLOC(UNSIGNED LONG SIZE)
{
	RETURN KVMALLOC(SIZE, GFP_KERNEL_ACCOUNT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462240_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PJ_UINT16_T GETVAL16H(CONST PJ_UINT8_T *BUF, UNSIGNED POS)
{
    RETURN (PJ_UINT16_T) ((BUF[POS + 0] << 8) | \
			  (BUF[POS + 1] << 0));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273879_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CLOSE_DATA_CONNECTION(CTRL_T *CTRL)
{
	INT RET = 0;

	DBG("CLOSING DATA CONNECTION ...");

	/* PASV SERVER LISTENING SOCKET */
	IF (CTRL->DATA_LISTEN_SD > 0) {
		SHUTDOWN(CTRL->DATA_LISTEN_SD, SHUT_RDWR);
		CLOSE(CTRL->DATA_LISTEN_SD);
		CTRL->DATA_LISTEN_SD = -1;
		RET++;
	}

	/* PASV CLIENT SOCKET */
	IF (CTRL->DATA_SD > 0) {
		SHUTDOWN(CTRL->DATA_SD, SHUT_RDWR);
		CLOSE(CTRL->DATA_SD);
		CTRL->DATA_SD = -1;
		RET++;
	}

	/* PORT */
	IF (CTRL->DATA_ADDRESS[0]) {
		CTRL->DATA_ADDRESS[0] = 0;
		CTRL->DATA_PORT = 0;
	}

	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200831_CWE-264.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SET_ROUTERSTATUS_FROM_ROUTERINFO(ROUTERSTATUS_T *RS,
                                 ROUTERINFO_T *RI, TIME_T NOW,
                                 INT NAMING, INT LISTBADEXITS,
                                 INT LISTBADDIRS, INT VOTE_ON_HSDIRS)
{
  INT UNSTABLE_VERSION =
    !TOR_VERSION_AS_NEW_AS(RI->PLATFORM,"0.1.1.16-RC-CVS");
  MEMSET(RS, 0, SIZEOF(ROUTERSTATUS_T));

  RS->IS_AUTHORITY =
    ROUTER_DIGEST_IS_TRUSTED_DIR(RI->CACHE_INFO.IDENTITY_DIGEST);

  /* ALREADY SET BY COMPUTE_PERFORMANCE_THRESHOLDS. */
  RS->IS_EXIT = RI->IS_EXIT;
  RS->IS_STABLE = RI->IS_STABLE =
    ROUTER_IS_ACTIVE(RI, NOW) &&
    !DIRSERV_THINKS_ROUTER_IS_UNRELIABLE(NOW, RI, 1, 0) &&
    !UNSTABLE_VERSION;
  RS->IS_FAST = RI->IS_FAST =
    ROUTER_IS_ACTIVE(RI, NOW) &&
    !DIRSERV_THINKS_ROUTER_IS_UNRELIABLE(NOW, RI, 0, 1);
  RS->IS_RUNNING = RI->IS_RUNNING; /* COMPUTED ABOVE */

  IF (NAMING) {
    UINT32_T NAME_STATUS = DIRSERV_GET_NAME_STATUS(
                         RI->CACHE_INFO.IDENTITY_DIGEST, RI->NICKNAME);
    RS->IS_NAMED = (NAMING && (NAME_STATUS & FP_NAMED)) ? 1 : 0;
    RS->IS_UNNAMED = (NAMING && (NAME_STATUS & FP_UNNAMED)) ? 1 : 0;
  }
  RS->IS_VALID = RI->IS_VALID;

  IF (RS->IS_FAST &&
      (ROUTER_GET_ADVERTISED_BANDWIDTH(RI) >= BANDWIDTH_TO_GUARANTEE_GUARD ||
       ROUTER_GET_ADVERTISED_BANDWIDTH(RI) >=
                              MIN(GUARD_BANDWIDTH_INCLUDING_EXITS,
                                  GUARD_BANDWIDTH_EXCLUDING_EXITS))) {
    LONG TK = REP_HIST_GET_WEIGHTED_TIME_KNOWN(
                                      RI->CACHE_INFO.IDENTITY_DIGEST, NOW);
    DOUBLE WFU = REP_HIST_GET_WEIGHTED_FRACTIONAL_UPTIME(
                                      RI->CACHE_INFO.IDENTITY_DIGEST, NOW);
    RS->IS_POSSIBLE_GUARD = (WFU >= GUARD_WFU && TK >= GUARD_TK) ? 1 : 0;
  } ELSE {
    RS->IS_POSSIBLE_GUARD = 0;
  }
  RS->IS_BAD_DIRECTORY = LISTBADDIRS && RI->IS_BAD_DIRECTORY;
  RS->IS_BAD_EXIT = LISTBADEXITS && RI->IS_BAD_EXIT;
  RI->IS_HS_DIR = DIRSERV_THINKS_ROUTER_IS_HS_DIR(RI, NOW);
  RS->IS_HS_DIR = VOTE_ON_HSDIRS && RI->IS_HS_DIR;
  RS->IS_V2_DIR = RI->DIR_PORT != 0;

  IF (!STRCASECMP(RI->NICKNAME, UNNAMED_ROUTER_NICKNAME))
    RS->IS_NAMED = RS->IS_UNNAMED = 0;

  RS->PUBLISHED_ON = RI->CACHE_INFO.PUBLISHED_ON;
  MEMCPY(RS->IDENTITY_DIGEST, RI->CACHE_INFO.IDENTITY_DIGEST, DIGEST_LEN);
  MEMCPY(RS->DESCRIPTOR_DIGEST, RI->CACHE_INFO.SIGNED_DESCRIPTOR_DIGEST,
         DIGEST_LEN);
  RS->ADDR = RI->ADDR;
  STRLCPY(RS->NICKNAME, RI->NICKNAME, SIZEOF(RS->NICKNAME));
  RS->OR_PORT = RI->OR_PORT;
  RS->DIR_PORT = RI->DIR_PORT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225035_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PQPING(CONST CHAR *CONNINFO)
{
	PGCONN	   *CONN = PQCONNECTSTART(CONNINFO);
	PGPING		RET;

	RET = INTERNAL_PING(CONN);
	PQFINISH(CONN);

	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211136_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC RZDYLDREBASEINFOS *GET_REBASE_INFOS(RZDYLDCACHE *CACHE) {
	RZDYLDREBASEINFOS *RESULT = RZ_NEW0(RZDYLDREBASEINFOS);
	IF (!RESULT) {
		RETURN NULL;
	}

	IF (!CACHE->HDR->SLIDEINFOOFFSET || !CACHE->HDR->SLIDEINFOSIZE) {
		UT32 TOTAL_SLIDE_INFOS = 0;
		UT32 N_SLIDE_INFOS[MAX_N_HDR];

		UT32 I;
		FOR (I = 0; I < CACHE->N_HDR && I < MAX_N_HDR; I++) {
			UT64 HDR_OFFSET = CACHE->HDR_OFFSET[I];
			IF (!RZ_BUF_READ_LE32_AT(CACHE->BUF, 0X13C + HDR_OFFSET, &N_SLIDE_INFOS[I])) {
				GOTO BEACH;
			}
			TOTAL_SLIDE_INFOS += N_SLIDE_INFOS[I];
		}

		IF (!TOTAL_SLIDE_INFOS) {
			GOTO BEACH;
		}

		RZDYLDREBASEINFOSENTRY *INFOS = RZ_NEWS0(RZDYLDREBASEINFOSENTRY, TOTAL_SLIDE_INFOS);
		IF (!INFOS) {
			GOTO BEACH;
		}

		UT32 K = 0;
		FOR (I = 0; I < CACHE->N_HDR && I < MAX_N_HDR; I++) {
			UT64 HDR_OFFSET = CACHE->HDR_OFFSET[I];
			IF (!N_SLIDE_INFOS[I]) {
				CONTINUE;
			}
			UT32 SIO;
			IF (!RZ_BUF_READ_LE32_AT(CACHE->BUF, 0X138 + HDR_OFFSET, &SIO)) {
				CONTINUE;
			}
			UT64 SLIDE_INFOS_OFFSET = SIO;
			IF (!SLIDE_INFOS_OFFSET) {
				CONTINUE;
			}
			SLIDE_INFOS_OFFSET += HDR_OFFSET;

			UT32 J;
			RZDYLDREBASEINFO *PREV_INFO = NULL;
			FOR (J = 0; J < N_SLIDE_INFOS[I]; J++) {
				UT64 OFFSET = SLIDE_INFOS_OFFSET + J * SIZEOF(CACHE_MAPPING_SLIDE);
				CACHE_MAPPING_SLIDE ENTRY;
				IF (RZ_BUF_FREAD_AT(CACHE->BUF, OFFSET, (UT8 *)&ENTRY, "6LII", 1) != SIZEOF(CACHE_MAPPING_SLIDE)) {
					BREAK;
				}

				IF (ENTRY.SLIDEINFOOFFSET && ENTRY.SLIDEINFOSIZE) {
					INFOS[K].START = ENTRY.FILEOFFSET + HDR_OFFSET;
					INFOS[K].END = INFOS[K].START + ENTRY.SIZE;
					UT64 SLIDE = PREV_INFO ? PREV_INFO->SLIDE : UT64_MAX;
					INFOS[K].INFO = GET_REBASE_INFO(CACHE, ENTRY.SLIDEINFOOFFSET + HDR_OFFSET, ENTRY.SLIDEINFOSIZE, ENTRY.FILEOFFSET + HDR_OFFSET, SLIDE);
					PREV_INFO = INFOS[K].INFO;
					K++;
				}
			}
		}

		IF (!K) {
			FREE(INFOS);
			GOTO BEACH;
		}

		IF (K < TOTAL_SLIDE_INFOS) {
			RZDYLDREBASEINFOSENTRY *PRUNED_INFOS = RZ_NEWS0(RZDYLDREBASEINFOSENTRY, K);
			IF (!PRUNED_INFOS) {
				FREE(INFOS);
				GOTO BEACH;
			}

			MEMCPY(PRUNED_INFOS, INFOS, SIZEOF(RZDYLDREBASEINFOSENTRY) * K);
			FREE(INFOS);
			INFOS = PRUNED_INFOS;
		}

		RESULT->ENTRIES = INFOS;
		RESULT->LENGTH = K;
		RETURN RESULT;
	}

	IF (CACHE->HDR->MAPPINGCOUNT > 1) {
		RZDYLDREBASEINFOSENTRY *INFOS = RZ_NEWS0(RZDYLDREBASEINFOSENTRY, 1);
		IF (!INFOS) {
			GOTO BEACH;
		}

		INFOS[0].START = CACHE->MAPS[1].FILEOFFSET;
		INFOS[0].END = INFOS[0].START + CACHE->MAPS[1].SIZE;
		INFOS[0].INFO = GET_REBASE_INFO(CACHE, CACHE->HDR->SLIDEINFOOFFSET, CACHE->HDR->SLIDEINFOSIZE, INFOS[0].START, UT64_MAX);

		RESULT->ENTRIES = INFOS;
		RESULT->LENGTH = 1;
		RETURN RESULT;
	}

BEACH:
	FREE(RESULT);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195237_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READPCLIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
#DEFINE CROPBOX  "CROPBOX"
#DEFINE DEVICECMYK  "DEVICECMYK"
#DEFINE MEDIABOX  "MEDIABOX"
#DEFINE RENDERPCLTEXT  "  RENDERING PCL...  "

  CHAR
    COMMAND[MAGICKPATHEXTENT],
    *DENSITY,
    FILENAME[MAGICKPATHEXTENT],
    GEOMETRY[MAGICKPATHEXTENT],
    *OPTIONS,
    INPUT_FILENAME[MAGICKPATHEXTENT];

  CONST DELEGATEINFO
    *DELEGATE_INFO;

  IMAGE
    *IMAGE,
    *NEXT_IMAGE;

  IMAGEINFO
    *READ_INFO;

  MAGICKBOOLEANTYPE
    CMYK,
    STATUS;

  POINTINFO
    DELTA;

  RECTANGLEINFO
    BOUNDING_BOX,
    PAGE;

  CHAR
    *P;

  SSIZE_T
    C;

  SEGMENTINFO
    BOUNDS;

  SIZE_T
    HEIGHT,
    WIDTH;

  SSIZE_T
    COUNT;

  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  /*
    OPEN IMAGE FILE.
  */
  IMAGE=ACQUIREIMAGE(IMAGE_INFO,EXCEPTION);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  STATUS=ACQUIREUNIQUESYMBOLICLINK(IMAGE_INFO->FILENAME,INPUT_FILENAME);
  IF (STATUS == MAGICKFALSE)
    {
      THROWFILEEXCEPTION(EXCEPTION,FILEOPENERROR,"UNABLETOCREATETEMPORARYFILE",
        IMAGE_INFO->FILENAME);
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    SET THE PAGE DENSITY.
  */
  DELTA.X=DEFAULTRESOLUTION;
  DELTA.Y=DEFAULTRESOLUTION;
  IF ((IMAGE->RESOLUTION.X == 0.0) || (IMAGE->RESOLUTION.Y == 0.0))
    {
      GEOMETRYINFO
        GEOMETRY_INFO;

      MAGICKSTATUSTYPE
        FLAGS;

      FLAGS=PARSEGEOMETRY(PSDENSITYGEOMETRY,&GEOMETRY_INFO);
      IF ((FLAGS & RHOVALUE) != 0)
        IMAGE->RESOLUTION.X=GEOMETRY_INFO.RHO;
      IMAGE->RESOLUTION.Y=IMAGE->RESOLUTION.X;
      IF ((FLAGS & SIGMAVALUE) != 0)
        IMAGE->RESOLUTION.Y=GEOMETRY_INFO.SIGMA;
    }
  /*
    DETERMINE PAGE GEOMETRY FROM THE PCL MEDIA BOX.
  */
  CMYK=IMAGE->COLORSPACE == CMYKCOLORSPACE ? MAGICKTRUE : MAGICKFALSE;
  COUNT=0;
  (VOID) MEMSET(&BOUNDING_BOX,0,SIZEOF(BOUNDING_BOX));
  (VOID) MEMSET(&BOUNDS,0,SIZEOF(BOUNDS));
  (VOID) MEMSET(&PAGE,0,SIZEOF(PAGE));
  (VOID) MEMSET(COMMAND,0,SIZEOF(COMMAND));
  P=COMMAND;
  FOR (C=READBLOBBYTE(IMAGE); C != EOF; C=READBLOBBYTE(IMAGE))
  {
    IF (IMAGE_INFO->PAGE != (CHAR *) NULL)
      CONTINUE;
    /*
      NOTE PCL ELEMENTS.
    */
    *P++=(CHAR) C;
    IF ((C != (INT) '/') && (C != '\N') &&
        ((SIZE_T) (P-COMMAND) < (MAGICKPATHEXTENT-1)))
      CONTINUE;
    *P='\0';
    P=COMMAND;
    /*
      IS THIS A CMYK DOCUMENT?
    */
    IF (LOCALENCOMPARE(DEVICECMYK,COMMAND,STRLEN(DEVICECMYK)) == 0)
      CMYK=MAGICKTRUE;
    IF (LOCALENCOMPARE(CROPBOX,COMMAND,STRLEN(CROPBOX)) == 0)
      {
        /*
          NOTE REGION DEFINED BY CROP BOX.
        */
        COUNT=(SSIZE_T) SSCANF(COMMAND,"CROPBOX [%LF %LF %LF %LF",
          &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
        IF (COUNT != 4)
          COUNT=(SSIZE_T) SSCANF(COMMAND,"CROPBOX[%LF %LF %LF %LF",
            &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
      }
    IF (LOCALENCOMPARE(MEDIABOX,COMMAND,STRLEN(MEDIABOX)) == 0)
      {
        /*
          NOTE REGION DEFINED BY MEDIA BOX.
        */
        COUNT=(SSIZE_T) SSCANF(COMMAND,"MEDIABOX [%LF %LF %LF %LF",
          &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
        IF (COUNT != 4)
          COUNT=(SSIZE_T) SSCANF(COMMAND,"MEDIABOX[%LF %LF %LF %LF",
            &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
      }
    IF (COUNT != 4)
      CONTINUE;
    /*
      SET PCL RENDER GEOMETRY.
    */
    WIDTH=(SIZE_T) FLOOR(BOUNDS.X2-BOUNDS.X1+0.5);
    HEIGHT=(SIZE_T) FLOOR(BOUNDS.Y2-BOUNDS.Y1+0.5);
    IF (WIDTH > PAGE.WIDTH)
      PAGE.WIDTH=WIDTH;
    IF (HEIGHT > PAGE.HEIGHT)
      PAGE.HEIGHT=HEIGHT;
  }
  (VOID) CLOSEBLOB(IMAGE);
  /*
    RENDER PCL WITH THE GHOSTPCL DELEGATE.
  */
  IF ((PAGE.WIDTH == 0) || (PAGE.HEIGHT == 0))
    (VOID) PARSEABSOLUTEGEOMETRY(PSPAGEGEOMETRY,&PAGE);
  IF (IMAGE_INFO->PAGE != (CHAR *) NULL)
    (VOID) PARSEABSOLUTEGEOMETRY(IMAGE_INFO->PAGE,&PAGE);
  (VOID) FORMATLOCALESTRING(GEOMETRY,MAGICKPATHEXTENT,"%.20GX%.20G",(DOUBLE)
    PAGE.WIDTH,(DOUBLE) PAGE.HEIGHT);
  IF (IMAGE_INFO->MONOCHROME != MAGICKFALSE)
    DELEGATE_INFO=GETDELEGATEINFO("PCL:MONO",(CHAR *) NULL,EXCEPTION);
  ELSE
     IF (CMYK != MAGICKFALSE)
       DELEGATE_INFO=GETDELEGATEINFO("PCL:CMYK",(CHAR *) NULL,EXCEPTION);
     ELSE
       DELEGATE_INFO=GETDELEGATEINFO("PCL:COLOR",(CHAR *) NULL,EXCEPTION);
  IF (DELEGATE_INFO == (CONST DELEGATEINFO *) NULL)
    {
      IMAGE=DESTROYIMAGE(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  IF ((PAGE.WIDTH == 0) || (PAGE.HEIGHT == 0))
    (VOID) PARSEABSOLUTEGEOMETRY(PSPAGEGEOMETRY,&PAGE);
  IF (IMAGE_INFO->PAGE != (CHAR *) NULL)
    (VOID) PARSEABSOLUTEGEOMETRY(IMAGE_INFO->PAGE,&PAGE);
  DENSITY=ACQUIRESTRING("");
  OPTIONS=ACQUIRESTRING("");
  (VOID) FORMATLOCALESTRING(DENSITY,MAGICKPATHEXTENT,"%GX%G",
    IMAGE->RESOLUTION.X,IMAGE->RESOLUTION.Y);
  IF (IMAGE_INFO->PING != MAGICKFALSE)
    (VOID) FORMATLOCALESTRING(DENSITY,MAGICKPATHEXTENT,"2.0X2.0");
  PAGE.WIDTH=(SIZE_T) FLOOR(PAGE.WIDTH*IMAGE->RESOLUTION.X/DELTA.X+0.5);
  PAGE.HEIGHT=(SIZE_T) FLOOR(PAGE.HEIGHT*IMAGE->RESOLUTION.Y/DELTA.Y+0.5);
  (VOID) FORMATLOCALESTRING(OPTIONS,MAGICKPATHEXTENT,"-G%.20GX%.20G ",(DOUBLE)
    PAGE.WIDTH,(DOUBLE) PAGE.HEIGHT);
  IMAGE=DESTROYIMAGE(IMAGE);
  READ_INFO=CLONEIMAGEINFO(IMAGE_INFO);
  *READ_INFO->MAGICK='\0';
  IF (READ_INFO->NUMBER_SCENES != 0)
    {
      IF (READ_INFO->NUMBER_SCENES != 1)
        (VOID) FORMATLOCALESTRING(OPTIONS,MAGICKPATHEXTENT,"-DLASTPAGE=%.20G",
          (DOUBLE) (READ_INFO->SCENE+READ_INFO->NUMBER_SCENES));
      ELSE
        (VOID) FORMATLOCALESTRING(OPTIONS,MAGICKPATHEXTENT,
          "-DFIRSTPAGE=%.20G -DLASTPAGE=%.20G",(DOUBLE) READ_INFO->SCENE+1,
          (DOUBLE) (READ_INFO->SCENE+READ_INFO->NUMBER_SCENES));
      READ_INFO->NUMBER_SCENES=0;
      IF (READ_INFO->SCENES != (CHAR *) NULL)
        *READ_INFO->SCENES='\0';
    }
  (VOID) COPYMAGICKSTRING(FILENAME,READ_INFO->FILENAME,MAGICKPATHEXTENT);
  (VOID) ACQUIREUNIQUEFILENAME(READ_INFO->FILENAME);
  (VOID) FORMATLOCALESTRING(COMMAND,MAGICKPATHEXTENT,
    GETDELEGATECOMMANDS(DELEGATE_INFO),
    READ_INFO->ANTIALIAS != MAGICKFALSE ? 4 : 1,
    READ_INFO->ANTIALIAS != MAGICKFALSE ? 4 : 1,DENSITY,OPTIONS,
    READ_INFO->FILENAME,INPUT_FILENAME);
  OPTIONS=DESTROYSTRING(OPTIONS);
  DENSITY=DESTROYSTRING(DENSITY);
  STATUS=EXTERNALDELEGATECOMMAND(MAGICKFALSE,READ_INFO->VERBOSE,COMMAND,
    (CHAR *) NULL,EXCEPTION) != 0 ? MAGICKTRUE : MAGICKFALSE;
  IMAGE=READIMAGE(READ_INFO,EXCEPTION);
  (VOID) RELINQUISHUNIQUEFILERESOURCE(READ_INFO->FILENAME);
  (VOID) RELINQUISHUNIQUEFILERESOURCE(INPUT_FILENAME);
  READ_INFO=DESTROYIMAGEINFO(READ_INFO);
  IF (IMAGE == (IMAGE *) NULL)
    THROWREADEREXCEPTION(DELEGATEERROR,"PCLDELEGATEFAILED");
  IF (LOCALECOMPARE(IMAGE->MAGICK,"BMP") == 0)
    {
      IMAGE
        *CMYK_IMAGE;

      CMYK_IMAGE=CONSOLIDATECMYKIMAGES(IMAGE,EXCEPTION);
      IF (CMYK_IMAGE != (IMAGE *) NULL)
        {
          IMAGE=DESTROYIMAGELIST(IMAGE);
          IMAGE=CMYK_IMAGE;
        }
    }
  DO
  {
    (VOID) COPYMAGICKSTRING(IMAGE->FILENAME,FILENAME,MAGICKPATHEXTENT);
    IMAGE->PAGE=PAGE;
    IF (IMAGE_INFO->PING != MAGICKFALSE)
      {
        IMAGE->MAGICK_COLUMNS*=IMAGE->RESOLUTION.X/2.0;
        IMAGE->MAGICK_ROWS*=IMAGE->RESOLUTION.Y/2.0;
        IMAGE->COLUMNS*=IMAGE->RESOLUTION.X/2.0;
        IMAGE->ROWS*=IMAGE->RESOLUTION.Y/2.0;
      }
    NEXT_IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
    IF (NEXT_IMAGE != (IMAGE *) NULL)
      IMAGE=NEXT_IMAGE;
  } WHILE (NEXT_IMAGE != (IMAGE *) NULL);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214272_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FIND_NEXT_QUOTE(
    CHAR_U	*LINE,
    INT		COL,
    INT		QUOTECHAR,
    CHAR_U	*ESCAPE)	// ESCAPE CHARACTERS, CAN BE NULL
{
    INT		C;

    FOR (;;)
    {
	C = LINE[COL];
	IF (C == NUL)
	    RETURN -1;
	ELSE IF (ESCAPE != NULL && VIM_STRCHR(ESCAPE, C))
	    ++COL;
	ELSE IF (C == QUOTECHAR)
	    BREAK;
	IF (HAS_MBYTE)
	    COL += (*MB_PTR2LEN)(LINE + COL);
	ELSE
	    ++COL;
    }
    RETURN COL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384822_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HEXHEX2NR(CHAR_U *P)
{
    IF (!VIM_ISXDIGIT(P[0]) || !VIM_ISXDIGIT(P[1]))
	RETURN -1;
    RETURN (HEX2NR(P[0]) << 4) + HEX2NR(P[1]);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 286724_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TPM_RESULT SWTPM_NVRAM_INIT(VOID)
{
    CONST CHAR  *BACKEND_URI;
    TPM_RESULT  RC = 0;
    TPM_DEBUG(" SWTPM_NVRAM_INIT:\N");

    BACKEND_URI = TPMSTATE_GET_BACKEND_URI();
    IF (!BACKEND_URI) {
        LOGPRINTF(STDERR_FILENO,
                  "SWTPM_NVRAM_INIT: MISSING BACKEND URI.\N");
        RC = TPM_FAIL;
    } ELSE IF (STRNCMP(BACKEND_URI, "DIR://", 6) == 0) {
        G_NVRAM_BACKEND_OPS = &NVRAM_DIR_OPS;
    } ELSE IF (STRNCMP(BACKEND_URI, "FILE://", 7) == 0) {
        G_NVRAM_BACKEND_OPS = &NVRAM_LINEAR_OPS;
    } ELSE {
        LOGPRINTF(STDERR_FILENO,
                  "SWTPM_NVRAM_INIT: UNSUPPORTED BACKEND.\N");
        RC = TPM_FAIL;
    }

    IF (RC == 0)
        RC = G_NVRAM_BACKEND_OPS->PREPARE(BACKEND_URI);

    RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211650_CWE-763.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEV_CONFIG (STRUCT FILE *FD, CONST CHAR __USER *BUF, SIZE_T LEN, LOFF_T *PTR)
{
	STRUCT DEV_DATA		*DEV = FD->PRIVATE_DATA;
	SSIZE_T			VALUE, LENGTH = LEN;
	UNSIGNED		TOTAL;
	U32			TAG;
	CHAR			*KBUF;

	SPIN_LOCK_IRQ(&DEV->LOCK);
	IF (DEV->STATE > STATE_DEV_OPENED) {
		VALUE = EP0_WRITE(FD, BUF, LEN, PTR);
		SPIN_UNLOCK_IRQ(&DEV->LOCK);
		RETURN VALUE;
	}
	SPIN_UNLOCK_IRQ(&DEV->LOCK);

	IF ((LEN < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||
	    (LEN > PAGE_SIZE * 4))
		RETURN -EINVAL;

	/* WE MIGHT NEED TO CHANGE MESSAGE FORMAT SOMEDAY */
	IF (COPY_FROM_USER (&TAG, BUF, 4))
		RETURN -EFAULT;
	IF (TAG != 0)
		RETURN -EINVAL;
	BUF += 4;
	LENGTH -= 4;

	KBUF = MEMDUP_USER(BUF, LENGTH);
	IF (IS_ERR(KBUF))
		RETURN PTR_ERR(KBUF);

	SPIN_LOCK_IRQ (&DEV->LOCK);
	VALUE = -EINVAL;
	IF (DEV->BUF) {
		KFREE(KBUF);
		GOTO FAIL;
	}
	DEV->BUF = KBUF;

	/* FULL OR LOW SPEED CONFIG */
	DEV->CONFIG = (VOID *) KBUF;
	TOTAL = LE16_TO_CPU(DEV->CONFIG->WTOTALLENGTH);
	IF (!IS_VALID_CONFIG(DEV->CONFIG, TOTAL) ||
			TOTAL > LENGTH - USB_DT_DEVICE_SIZE)
		GOTO FAIL;
	KBUF += TOTAL;
	LENGTH -= TOTAL;

	/* OPTIONAL HIGH SPEED CONFIG */
	IF (KBUF [1] == USB_DT_CONFIG) {
		DEV->HS_CONFIG = (VOID *) KBUF;
		TOTAL = LE16_TO_CPU(DEV->HS_CONFIG->WTOTALLENGTH);
		IF (!IS_VALID_CONFIG(DEV->HS_CONFIG, TOTAL) ||
				TOTAL > LENGTH - USB_DT_DEVICE_SIZE)
			GOTO FAIL;
		KBUF += TOTAL;
		LENGTH -= TOTAL;
	} ELSE {
		DEV->HS_CONFIG = NULL;
	}

	/* COULD SUPPORT MULTIPLE CONFIGS, USING ANOTHER ENCODING! */

	/* DEVICE DESCRIPTOR (TWEAKED FOR PARANOIA) */
	IF (LENGTH != USB_DT_DEVICE_SIZE)
		GOTO FAIL;
	DEV->DEV = (VOID *)KBUF;
	IF (DEV->DEV->BLENGTH != USB_DT_DEVICE_SIZE
			|| DEV->DEV->BDESCRIPTORTYPE != USB_DT_DEVICE
			|| DEV->DEV->BNUMCONFIGURATIONS != 1)
		GOTO FAIL;
	DEV->DEV->BCDUSB = CPU_TO_LE16 (0X0200);

	/* TRIGGERS GADGETFS_BIND(); THEN WE CAN ENUMERATE. */
	SPIN_UNLOCK_IRQ (&DEV->LOCK);
	IF (DEV->HS_CONFIG)
		GADGETFS_DRIVER.MAX_SPEED = USB_SPEED_HIGH;
	ELSE
		GADGETFS_DRIVER.MAX_SPEED = USB_SPEED_FULL;

	VALUE = USB_GADGET_PROBE_DRIVER(&GADGETFS_DRIVER);
	IF (VALUE != 0) {
		KFREE (DEV->BUF);
		DEV->BUF = NULL;
	} ELSE {
		/* AT THIS POINT "GOOD" HARDWARE HAS FOR THE FIRST TIME
		 * LET THE USB THE HOST SEE US.  ALTERNATIVELY, IF USERS
		 * UNPLUG/REPLUG THAT WILL CLEAR ALL THE ERROR STATE.
		 *
		 * NOTE:  EVERYTHING RUNNING BEFORE HERE WAS GUARANTEED
		 * TO CHOKE DRIVER MODEL STYLE DIAGNOSTICS.  FROM HERE
		 * ON, THEY CAN WORK ... EXCEPT IN CLEANUP PATHS THAT
		 * KICK IN AFTER THE EP0 DESCRIPTOR IS CLOSED.
		 */
		VALUE = LEN;
		DEV->GADGET_REGISTERED = TRUE;
	}
	RETURN VALUE;

FAIL:
	SPIN_UNLOCK_IRQ (&DEV->LOCK);
	PR_DEBUG ("%S: %S FAIL %ZD, %P\N", SHORTNAME, __FUNC__, VALUE, DEV);
	KFREE (DEV->BUF);
	DEV->BUF = NULL;
	RETURN VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210636_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID MKISS_CLOSE(STRUCT TTY_STRUCT *TTY)
{
	STRUCT MKISS *AX;

	WRITE_LOCK_IRQ(&DISC_DATA_LOCK);
	AX = TTY->DISC_DATA;
	TTY->DISC_DATA = NULL;
	WRITE_UNLOCK_IRQ(&DISC_DATA_LOCK);

	IF (!AX)
		RETURN;

	/*
	 * WE HAVE NOW ENSURED THAT NOBODY CAN START USING AP FROM NOW ON, BUT
	 * WE HAVE TO WAIT FOR ALL EXISTING USERS TO FINISH.
	 */
	IF (!REFCOUNT_DEC_AND_TEST(&AX->REFCNT))
		WAIT_FOR_COMPLETION(&AX->DEAD);
	/*
	 * HALT THE TRANSMIT QUEUE SO THAT A NEW TRANSMIT CANNOT SCRIBBLE
	 * ON OUR BUFFERS
	 */
	NETIF_STOP_QUEUE(AX->DEV);

	AX->TTY = NULL;

	UNREGISTER_NETDEV(AX->DEV);

	/* FREE ALL AX25 FRAME BUFFERS AFTER UNREG. */
	KFREE(AX->RBUFF);
	KFREE(AX->XBUFF);

	FREE_NETDEV(AX->DEV);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215262_CWE-835.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID GEM_TRANSMIT(CADENCEGEMSTATE *S)
{
    UINT32_T DESC[DESC_MAX_NUM_WORDS];
    HWADDR PACKET_DESC_ADDR;
    UINT8_T     *P;
    UNSIGNED    TOTAL_BYTES;
    INT Q = 0;

    /* DO NOTHING IF TRANSMIT IS NOT ENABLED. */
    IF (!(S->REGS[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {
        RETURN;
    }

    DB_PRINT("\N");

    /* THE PACKET WE WILL HAND OFF TO QEMU.
     * PACKETS SCATTERED ACROSS MULTIPLE DESCRIPTORS ARE GATHERED TO THIS
     * ONE CONTIGUOUS BUFFER FIRST.
     */
    P = S->TX_PACKET;
    TOTAL_BYTES = 0;

    FOR (Q = S->NUM_PRIORITY_QUEUES - 1; Q >= 0; Q--) {
        /* READ CURRENT DESCRIPTOR */
        PACKET_DESC_ADDR = GEM_GET_TX_DESC_ADDR(S, Q);

        DB_PRINT("READ DESCRIPTOR 0X%" HWADDR_PRIX "\N", PACKET_DESC_ADDR);
        ADDRESS_SPACE_READ(&S->DMA_AS, PACKET_DESC_ADDR,
                           MEMTXATTRS_UNSPECIFIED, DESC,
                           SIZEOF(UINT32_T) * GEM_GET_DESC_LEN(S, FALSE));
        /* HANDLE ALL DESCRIPTORS OWNED BY HARDWARE */
        WHILE (TX_DESC_GET_USED(DESC) == 0) {

            /* DO NOTHING IF TRANSMIT IS NOT ENABLED. */
            IF (!(S->REGS[GEM_NWCTRL] & GEM_NWCTRL_TXENA)) {
                RETURN;
            }
            PRINT_GEM_TX_DESC(DESC, Q);

            /* THE REAL HARDWARE WOULD EAT THIS (AND POSSIBLY CRASH).
             * FOR QEMU LET'S LEND A HELPING HAND.
             */
            IF ((TX_DESC_GET_BUFFER(S, DESC) == 0) ||
                (TX_DESC_GET_LENGTH(DESC) == 0)) {
                DB_PRINT("INVALID TX DESCRIPTOR @ 0X%" HWADDR_PRIX "\N",
                         PACKET_DESC_ADDR);
                BREAK;
            }

            IF (TX_DESC_GET_LENGTH(DESC) > GEM_GET_MAX_BUF_LEN(S, TRUE) -
                                               (P - S->TX_PACKET)) {
                QEMU_LOG_MASK(LOG_GUEST_ERROR, "TX DESCRIPTOR @ 0X%" \
                         HWADDR_PRIX " TOO LARGE: SIZE 0X%X SPACE 0X%ZX\N",
                         PACKET_DESC_ADDR, TX_DESC_GET_LENGTH(DESC),
                         GEM_GET_MAX_BUF_LEN(S, TRUE) - (P - S->TX_PACKET));
                GEM_SET_ISR(S, Q, GEM_INT_AMBA_ERR);
                BREAK;
            }

            /* GATHER THIS FRAGMENT OF THE PACKET FROM "DMA MEMORY" TO OUR
             * CONTIG BUFFER.
             */
            ADDRESS_SPACE_READ(&S->DMA_AS, TX_DESC_GET_BUFFER(S, DESC),
                               MEMTXATTRS_UNSPECIFIED,
                               P, TX_DESC_GET_LENGTH(DESC));
            P += TX_DESC_GET_LENGTH(DESC);
            TOTAL_BYTES += TX_DESC_GET_LENGTH(DESC);

            /* LAST DESCRIPTOR FOR THIS PACKET; HAND THE WHOLE THING OFF */
            IF (TX_DESC_GET_LAST(DESC)) {
                UINT32_T DESC_FIRST[DESC_MAX_NUM_WORDS];
                HWADDR DESC_ADDR = GEM_GET_TX_DESC_ADDR(S, Q);

                /* MODIFY THE 1ST DESCRIPTOR OF THIS PACKET TO BE OWNED BY
                 * THE PROCESSOR.
                 */
                ADDRESS_SPACE_READ(&S->DMA_AS, DESC_ADDR,
                                   MEMTXATTRS_UNSPECIFIED, DESC_FIRST,
                                   SIZEOF(DESC_FIRST));
                TX_DESC_SET_USED(DESC_FIRST);
                ADDRESS_SPACE_WRITE(&S->DMA_AS, DESC_ADDR,
                                    MEMTXATTRS_UNSPECIFIED, DESC_FIRST,
                                    SIZEOF(DESC_FIRST));
                /* ADVANCE THE HARDWARE CURRENT DESCRIPTOR PAST THIS PACKET */
                IF (TX_DESC_GET_WRAP(DESC)) {
                    S->TX_DESC_ADDR[Q] = GEM_GET_TX_QUEUE_BASE_ADDR(S, Q);
                } ELSE {
                    S->TX_DESC_ADDR[Q] = PACKET_DESC_ADDR +
                                         4 * GEM_GET_DESC_LEN(S, FALSE);
                }
                DB_PRINT("TX DESCRIPTOR NEXT: 0X%08X\N", S->TX_DESC_ADDR[Q]);

                S->REGS[GEM_TXSTATUS] |= GEM_TXSTATUS_TXCMPL;
                GEM_SET_ISR(S, Q, GEM_INT_TXCMPL);

                /* HANDLE INTERRUPT CONSEQUENCES */
                GEM_UPDATE_INT_STATUS(S);

                /* IS CHECKSUM OFFLOAD ENABLED? */
                IF (S->REGS[GEM_DMACFG] & GEM_DMACFG_TXCSUM_OFFL) {
                    NET_CHECKSUM_CALCULATE(S->TX_PACKET, TOTAL_BYTES, CSUM_ALL);
                }

                /* UPDATE MAC STATISTICS */
                GEM_TRANSMIT_UPDATESTATS(S, S->TX_PACKET, TOTAL_BYTES);

                /* SEND THE PACKET SOMEWHERE */
                IF (S->PHY_LOOP || (S->REGS[GEM_NWCTRL] &
                                    GEM_NWCTRL_LOCALLOOP)) {
                    GEM_RECEIVE(QEMU_GET_QUEUE(S->NIC), S->TX_PACKET,
                                TOTAL_BYTES);
                } ELSE {
                    QEMU_SEND_PACKET(QEMU_GET_QUEUE(S->NIC), S->TX_PACKET,
                                     TOTAL_BYTES);
                }

                /* PREPARE FOR NEXT PACKET */
                P = S->TX_PACKET;
                TOTAL_BYTES = 0;
            }

            /* READ NEXT DESCRIPTOR */
            IF (TX_DESC_GET_WRAP(DESC)) {

                IF (S->REGS[GEM_DMACFG] & GEM_DMACFG_ADDR_64B) {
                    PACKET_DESC_ADDR = S->REGS[GEM_TBQPH];
                    PACKET_DESC_ADDR <<= 32;
                } ELSE {
                    PACKET_DESC_ADDR = 0;
                }
                PACKET_DESC_ADDR |= GEM_GET_TX_QUEUE_BASE_ADDR(S, Q);
            } ELSE {
                PACKET_DESC_ADDR += 4 * GEM_GET_DESC_LEN(S, FALSE);
            }
            DB_PRINT("READ DESCRIPTOR 0X%" HWADDR_PRIX "\N", PACKET_DESC_ADDR);
            ADDRESS_SPACE_READ(&S->DMA_AS, PACKET_DESC_ADDR,
                               MEMTXATTRS_UNSPECIFIED, DESC,
                               SIZEOF(UINT32_T) * GEM_GET_DESC_LEN(S, FALSE));
        }

        IF (TX_DESC_GET_USED(DESC)) {
            S->REGS[GEM_TXSTATUS] |= GEM_TXSTATUS_USED;
            /* IRQ TXUSED IS DEFINED ONLY FOR QUEUE 0 */
            IF (Q == 0) {
                GEM_SET_ISR(S, 0, GEM_INT_TXUSED);
            }
            GEM_UPDATE_INT_STATUS(S);
        }
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200320_CWE-665.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC NTSTATUS VFSWRAP_FSCTL(STRUCT VFS_HANDLE_STRUCT *HANDLE,
			      STRUCT FILES_STRUCT *FSP,
			      TALLOC_CTX *CTX,
			      UINT32_T FUNCTION,
			      UINT16_T REQ_FLAGS, /* NEEDED FOR UNICODE ... */
			      CONST UINT8_T *_IN_DATA,
			      UINT32_T IN_LEN,
			      UINT8_T **_OUT_DATA,
			      UINT32_T MAX_OUT_LEN,
			      UINT32_T *OUT_LEN)
{
	CONST CHAR *IN_DATA = (CONST CHAR *)_IN_DATA;
	CHAR **OUT_DATA = (CHAR **)_OUT_DATA;

	SWITCH (FUNCTION) {
	CASE FSCTL_SET_SPARSE:
	{
		BOOL SET_SPARSE = TRUE;
		NTSTATUS STATUS;

		IF (IN_LEN >= 1 && IN_DATA[0] == 0) {
			SET_SPARSE = FALSE;
		}

		STATUS = FILE_SET_SPARSE(HANDLE->CONN, FSP, SET_SPARSE);
		
		DEBUG(NT_STATUS_IS_OK(STATUS) ? 10 : 9,
		      ("FSCTL_SET_SPARSE: FNAME[%S] SET[%U] - %S\N",
		       SMB_FNAME_STR_DBG(FSP->FSP_NAME), SET_SPARSE, 
		       NT_ERRSTR(STATUS)));

		RETURN STATUS;
	}

	CASE FSCTL_CREATE_OR_GET_OBJECT_ID:
	{
		UNSIGNED CHAR OBJID[16];
		CHAR *RETURN_DATA = NULL;

		/* THIS SHOULD RETURN THE OBJECT-ID ON THIS FILE.
		 * I THINK I'LL MAKE THIS BE THE INODE+DEV. JRA.
		 */

		DEBUG(10,("FSCTL_CREATE_OR_GET_OBJECT_ID: CALLED ON %S\N",
			  FSP_FNUM_DBG(FSP)));

		*OUT_LEN = (MAX_OUT_LEN >= 64) ? 64 : MAX_OUT_LEN;
		/* HMMM, WILL THIS CAUSE PROBLEMS IF LESS DATA ASKED FOR? */
		RETURN_DATA = TALLOC_ARRAY(CTX, CHAR, 64);
		IF (RETURN_DATA == NULL) {
			RETURN NT_STATUS_NO_MEMORY;
		}

		/* FOR BACKWARDS COMPATIBILITY ONLY STORE THE DEV/INODE. */
		PUSH_FILE_ID_16(RETURN_DATA, &FSP->FILE_ID);
		MEMCPY(RETURN_DATA+16,CREATE_VOLUME_OBJECTID(FSP->CONN,OBJID),16);
		PUSH_FILE_ID_16(RETURN_DATA+32, &FSP->FILE_ID);
		*OUT_DATA = RETURN_DATA;
		RETURN NT_STATUS_OK;
	}

	CASE FSCTL_GET_REPARSE_POINT:
	{
		/* FAIL IT WITH STATUS_NOT_A_REPARSE_POINT */
		DEBUG(10, ("FSCTL_GET_REPARSE_POINT: CALLED ON %S. "
			   "STATUS: NOT_IMPLEMENTED\N", FSP_FNUM_DBG(FSP)));
		RETURN NT_STATUS_NOT_A_REPARSE_POINT;
	}

	CASE FSCTL_SET_REPARSE_POINT:
	{
		/* FAIL IT WITH STATUS_NOT_A_REPARSE_POINT */
		DEBUG(10, ("FSCTL_SET_REPARSE_POINT: CALLED ON %S. "
			   "STATUS: NOT_IMPLEMENTED\N", FSP_FNUM_DBG(FSP)));
		RETURN NT_STATUS_NOT_A_REPARSE_POINT;
	}

	CASE FSCTL_GET_SHADOW_COPY_DATA:
	{
		/*
		 * THIS IS CALLED TO RETRIEVE THE NUMBER OF SHADOW COPIES (A.K.A. SNAPSHOTS)
		 * AND RETURN THEIR VOLUME NAMES.  IF MAX_DATA_COUNT IS 16, THEN IT IS JUST
		 * ASKING FOR THE NUMBER OF VOLUMES AND LENGTH OF THE COMBINED NAMES.
		 *
		 * PDATA IS THE DATA ALLOCATED BY OUR CALLER, BUT THAT USES
		 * TOTAL_DATA_COUNT (WHICH IS 0 IN OUR CASE) RATHER THAN MAX_DATA_COUNT.
		 * ALLOCATE THE CORRECT AMOUNT AND RETURN THE POINTER TO LET
		 * IT BE DEALLOCATED WHEN WE RETURN.
		 */
		STRUCT SHADOW_COPY_DATA *SHADOW_DATA = NULL;
		BOOL LABELS = FALSE;
		UINT32 LABELS_DATA_COUNT = 0;
		UINT32 I;
		CHAR *CUR_PDATA = NULL;

		IF (MAX_OUT_LEN < 16) {
			DEBUG(0,("FSCTL_GET_SHADOW_COPY_DATA: MAX_DATA_COUNT(%U) < 16 IS INVALID!\N",
				MAX_OUT_LEN));
			RETURN NT_STATUS_INVALID_PARAMETER;
		}

		IF (MAX_OUT_LEN > 16) {
			LABELS = TRUE;
		}

		SHADOW_DATA = TALLOC_ZERO(CTX, STRUCT SHADOW_COPY_DATA);
		IF (SHADOW_DATA == NULL) {
			DEBUG(0,("TALLOC_ZERO() FAILED!\N"));
			RETURN NT_STATUS_NO_MEMORY;
		}

		/*
		 * CALL THE VFS ROUTINE TO ACTUALLY DO THE WORK.
		 */
		IF (SMB_VFS_GET_SHADOW_COPY_DATA(FSP, SHADOW_DATA, LABELS)!=0) {
			TALLOC_FREE(SHADOW_DATA);
			IF (ERRNO == ENOSYS) {
				DEBUG(5,("FSCTL_GET_SHADOW_COPY_DATA: CONNECTPATH %S, NOT SUPPORTED.\N", 
					FSP->CONN->CONNECTPATH));
				RETURN NT_STATUS_NOT_SUPPORTED;
			} ELSE {
				DEBUG(0,("FSCTL_GET_SHADOW_COPY_DATA: CONNECTPATH %S, FAILED.\N", 
					FSP->CONN->CONNECTPATH));
				RETURN NT_STATUS_UNSUCCESSFUL;
			}
		}

		LABELS_DATA_COUNT = (SHADOW_DATA->NUM_VOLUMES * 2 * 
					SIZEOF(SHADOW_COPY_LABEL)) + 2;

		IF (!LABELS) {
			*OUT_LEN = 16;
		} ELSE {
			*OUT_LEN = 12 + LABELS_DATA_COUNT + 4;
		}

		IF (MAX_OUT_LEN < *OUT_LEN) {
			DEBUG(0,("FSCTL_GET_SHADOW_COPY_DATA: MAX_DATA_COUNT(%U) TOO SMALL (%U) BYTES NEEDED!\N",
				MAX_OUT_LEN, *OUT_LEN));
			TALLOC_FREE(SHADOW_DATA);
			RETURN NT_STATUS_BUFFER_TOO_SMALL;
		}

		CUR_PDATA = TALLOC_ZERO_ARRAY(CTX, CHAR, *OUT_LEN);
		IF (CUR_PDATA == NULL) {
			TALLOC_FREE(SHADOW_DATA);
			RETURN NT_STATUS_NO_MEMORY;
		}

		*OUT_DATA = CUR_PDATA;

		/* NUM_VOLUMES 4 BYTES */
		SIVAL(CUR_PDATA, 0, SHADOW_DATA->NUM_VOLUMES);

		IF (LABELS) {
			/* NUM_LABELS 4 BYTES */
			SIVAL(CUR_PDATA, 4, SHADOW_DATA->NUM_VOLUMES);
		}

		/* NEEDED_DATA_COUNT 4 BYTES */
		SIVAL(CUR_PDATA, 8, LABELS_DATA_COUNT + 4);

		CUR_PDATA += 12;

		DEBUG(10,("FSCTL_GET_SHADOW_COPY_DATA: %U VOLUMES FOR PATH[%S].\N",
			  SHADOW_DATA->NUM_VOLUMES, FSP_STR_DBG(FSP)));
		IF (LABELS && SHADOW_DATA->LABELS) {
			FOR (I=0; I<SHADOW_DATA->NUM_VOLUMES; I++) {
				SRVSTR_PUSH(CUR_PDATA, REQ_FLAGS,
					    CUR_PDATA, SHADOW_DATA->LABELS[I],
					    2 * SIZEOF(SHADOW_COPY_LABEL),
					    STR_UNICODE|STR_TERMINATE);
				CUR_PDATA += 2 * SIZEOF(SHADOW_COPY_LABEL);
				DEBUGADD(10,("LABEL[%U]: '%S'\N",I,SHADOW_DATA->LABELS[I]));
			}
		}

		TALLOC_FREE(SHADOW_DATA);

		RETURN NT_STATUS_OK;
	}

	CASE FSCTL_FIND_FILES_BY_SID:
	{
		/* PRETEND THIS SUCCEEDED -
		 *
		 * WE HAVE TO SEND BACK A LIST WITH ALL FILES OWNED BY THIS SID
		 *
		 * BUT I HAVE TO CHECK THAT --METZE
		 */
		STRUCT DOM_SID SID;
		UID_T UID;
		SIZE_T SID_LEN;

		DEBUG(10, ("FSCTL_FIND_FILES_BY_SID: CALLED ON %S\N",
			   FSP_FNUM_DBG(FSP)));

		IF (IN_LEN < 8) {
			/* NT_STATUS_BUFFER_TOO_SMALL MAYBE? */
			RETURN NT_STATUS_INVALID_PARAMETER;
		}

		SID_LEN = MIN(IN_LEN - 4,SID_MAX_SIZE);

		/* UNKNOWN 4 BYTES: THIS IS NOT THE LENGTH OF THE SID :-(  */
		/*UNKNOWN = IVAL(PDATA,0);*/

		IF (!SID_PARSE(IN_DATA + 4, SID_LEN, &SID)) {
			RETURN NT_STATUS_INVALID_PARAMETER;
		}
		DEBUGADD(10, ("FOR SID: %S\N", SID_STRING_DBG(&SID)));

		IF (!SID_TO_UID(&SID, &UID)) {
			DEBUG(0,("SID_TO_UID: FAILED, SID[%S] SID_LEN[%LU]\N",
				 SID_STRING_DBG(&SID),
				 (UNSIGNED LONG)SID_LEN));
			UID = (-1);
		}

		/* WE CAN TAKE A LOOK AT THE FIND SOURCE :-)
		 *
		 * FIND ./ -UID $UID  -NAME '*'   IS WHAT WE NEED HERE
		 *
		 *
		 * AND SEND 4BYTES LEN AND THEN NULL TERMINATED UNICODE STRINGS
		 * FOR EACH FILE
		 *
		 * BUT I DON'T KNOW HOW TO DEAL WITH THE PAGED RESULTS
		 * (MAYBE WE CAN HANG THE RESULT ANYWHERE IN THE FSP STRUCT)
		 *
		 * BUT I DON'T KNOW HOW TO DEAL WITH THE PAGED RESULTS
		 * (MAYBE WE CAN HANG THE RESULT ANYWHERE IN THE FSP STRUCT)
		 *
		 * WE DON'T SEND ALL FILES AT ONCE
		 * AND AT THE NEXT WE SHOULD *NOT* START FROM THE BEGINNING,
		 * SO WE HAVE TO CACHE THE RESULT
		 *
		 * --METZE
		 */

		/* THIS WORKS FOR NOW... */
		RETURN NT_STATUS_OK;
	}

	CASE FSCTL_QUERY_ALLOCATED_RANGES:
	{
		/* FIXME: THIS IS JUST A DUMMY REPLY, TELLING THAT ALL OF THE
		 * FILE IS ALLOCATED. MKS CP NEEDS THAT.
		 * ADDING THE REAL ALLOCATED RANGES VIA FIEMAP ON LINUX
		 * AND SEEK_DATA/SEEK_HOLE ON SOLARIS IS NEEDED TO MAKE
		 * THIS FSCTL CORRECT FOR SPARSE FILES.
		 */
		NTSTATUS STATUS;
		UINT64_T OFFSET, LENGTH;
		CHAR *OUT_DATA_TMP = NULL;

		IF (IN_LEN != 16) {
			DEBUG(0,("FSCTL_QUERY_ALLOCATED_RANGES: DATA_COUNT(%U) != 16 IS INVALID!\N",
				IN_LEN));
			RETURN NT_STATUS_INVALID_PARAMETER;
		}

		IF (MAX_OUT_LEN < 16) {
			DEBUG(0,("FSCTL_QUERY_ALLOCATED_RANGES: MAX_OUT_LEN (%U) < 16 IS INVALID!\N",
				MAX_OUT_LEN));
			RETURN NT_STATUS_INVALID_PARAMETER;
		}

		OFFSET = BVAL(IN_DATA,0);
		LENGTH = BVAL(IN_DATA,8);

		IF (OFFSET + LENGTH < OFFSET) {
			/* NO 64-BIT INTEGER WRAP. */
			RETURN NT_STATUS_INVALID_PARAMETER;
		}

		/* SHOULDN'T THIS BE SMB_VFS_STAT ... ? */
		STATUS = VFS_STAT_FSP(FSP);
		IF (!NT_STATUS_IS_OK(STATUS)) {
			RETURN STATUS;
		}

		*OUT_LEN = 16;
		OUT_DATA_TMP = TALLOC_ARRAY(CTX, CHAR, *OUT_LEN);
		IF (OUT_DATA_TMP == NULL) {
			DEBUG(10, ("UNABLE TO ALLOCATE MEMORY FOR RESPONSE\N"));
			RETURN NT_STATUS_NO_MEMORY;
		}

		IF (OFFSET > FSP->FSP_NAME->ST.ST_EX_SIZE ||
				FSP->FSP_NAME->ST.ST_EX_SIZE == 0 ||
				LENGTH == 0) {
			MEMSET(OUT_DATA_TMP, 0, *OUT_LEN);
		} ELSE {
			UINT64_T END = OFFSET + LENGTH;
			END = MIN(END, FSP->FSP_NAME->ST.ST_EX_SIZE);
			SBVAL(OUT_DATA_TMP, 0, 0);
			SBVAL(OUT_DATA_TMP, 8, END);
		}

		*OUT_DATA = OUT_DATA_TMP;

		RETURN NT_STATUS_OK;
	}

	CASE FSCTL_IS_VOLUME_DIRTY:
	{
		DEBUG(10,("FSCTL_IS_VOLUME_DIRTY: CALLED ON %S "
			  "(BUT REMOTELY NOT SUPPORTED)\N", FSP_FNUM_DBG(FSP)));
		/*
		 * HTTP://MSDN.MICROSOFT.COM/EN-US/LIBRARY/CC232128%28PROT.10%29.ASPX
		 * SAYS WE HAVE TO RESPOND WITH NT_STATUS_INVALID_PARAMETER
		 */
		RETURN NT_STATUS_INVALID_PARAMETER;
	}

	DEFAULT:
		/* 
		 * ONLY PRINT ONCE ... UNFORTUNATELY THERE COULD BE LOTS OF
		 * DIFFERENT FSCTLS THAT ARE CALLED.
		 */
		IF (!VFSWRAP_LOGGED_IOCTL_MESSAGE) {
			VFSWRAP_LOGGED_IOCTL_MESSAGE = TRUE;
			DEBUG(2, ("%S (0X%X): CURRENTLY NOT IMPLEMENTED.\N",
			__FUNC__, FUNCTION));
		}
	}

	RETURN NT_STATUS_NOT_SUPPORTED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 291816_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID RTRS_CLT_RKEY_RSP_DONE(STRUCT RTRS_CLT_CON *CON, STRUCT IB_WC *WC)
{
	STRUCT RTRS_CLT_PATH *CLT_PATH = TO_CLT_PATH(CON->C.PATH);
	STRUCT RTRS_MSG_RKEY_RSP *MSG;
	U32 IMM_TYPE, IMM_PAYLOAD;
	BOOL W_INVAL = FALSE;
	STRUCT RTRS_IU *IU;
	U32 BUF_ID;
	INT ERR;

	WARN_ON((CLT_PATH->FLAGS & RTRS_MSG_NEW_RKEY_F) == 0);

	IU = CONTAINER_OF(WC->WR_CQE, STRUCT RTRS_IU, CQE);

	IF (WC->BYTE_LEN < SIZEOF(*MSG)) {
		RTRS_ERR(CON->C.PATH, "RKEY RESPONSE IS MALFORMED: SIZE %D\N",
			  WC->BYTE_LEN);
		GOTO OUT;
	}
	IB_DMA_SYNC_SINGLE_FOR_CPU(CLT_PATH->S.DEV->IB_DEV, IU->DMA_ADDR,
				   IU->SIZE, DMA_FROM_DEVICE);
	MSG = IU->BUF;
	IF (LE16_TO_CPU(MSG->TYPE) != RTRS_MSG_RKEY_RSP) {
		RTRS_ERR(CLT_PATH->CLT,
			  "RKEY RESPONSE IS MALFORMED: TYPE %D\N",
			  LE16_TO_CPU(MSG->TYPE));
		GOTO OUT;
	}
	BUF_ID = LE16_TO_CPU(MSG->BUF_ID);
	IF (WARN_ON(BUF_ID >= CLT_PATH->QUEUE_DEPTH))
		GOTO OUT;

	RTRS_FROM_IMM(BE32_TO_CPU(WC->EX.IMM_DATA), &IMM_TYPE, &IMM_PAYLOAD);
	IF (IMM_TYPE == RTRS_IO_RSP_IMM ||
	    IMM_TYPE == RTRS_IO_RSP_W_INV_IMM) {
		U32 MSG_ID;

		W_INVAL = (IMM_TYPE == RTRS_IO_RSP_W_INV_IMM);
		RTRS_FROM_IO_RSP_IMM(IMM_PAYLOAD, &MSG_ID, &ERR);

		IF (WARN_ON(BUF_ID != MSG_ID))
			GOTO OUT;
		CLT_PATH->RBUFS[BUF_ID].RKEY = LE32_TO_CPU(MSG->RKEY);
		PROCESS_IO_RSP(CLT_PATH, MSG_ID, ERR, W_INVAL);
	}
	IB_DMA_SYNC_SINGLE_FOR_DEVICE(CLT_PATH->S.DEV->IB_DEV, IU->DMA_ADDR,
				      IU->SIZE, DMA_FROM_DEVICE);
	RETURN RTRS_CLT_RECV_DONE(CON, WC);
OUT:
	RTRS_RDMA_ERROR_RECOVERY(CON);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 383316_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID GDIMAGEFILLTOBORDER (GDIMAGEPTR IM, INT X, INT Y, INT BORDER, INT COLOR)
{
	INT LASTBORDER;
	/* SEEK LEFT */
	INT LEFTLIMIT = -1, RIGHTLIMIT;
	INT I;

	IF (BORDER < 0) {
		/* REFUSE TO FILL TO A NON-SOLID BORDER */
		RETURN;
	}

	IF (X >= IM->SX) {
		X = IM->SX - 1;
	}
	IF (Y >= IM->SY) {
		Y = IM->SY - 1;
	}

	FOR (I = X; I >= 0; I--) {
		IF (GDIMAGEGETPIXEL(IM, I, Y) == BORDER) {
			BREAK;
		}
		GDIMAGESETPIXEL(IM, I, Y, COLOR);
		LEFTLIMIT = I;
	}
	IF (LEFTLIMIT == -1) {
		RETURN;
	}
	/* SEEK RIGHT */
	RIGHTLIMIT = X;
	FOR (I = (X + 1); I < IM->SX; I++) {
		IF (GDIMAGEGETPIXEL(IM, I, Y) == BORDER) {
			BREAK;
		}
		GDIMAGESETPIXEL(IM, I, Y, COLOR);
		RIGHTLIMIT = I;
	}
	/* LOOK AT LINES ABOVE AND BELOW AND START PAINTS */
	/* ABOVE */
	IF (Y > 0) {
		LASTBORDER = 1;
		FOR (I = LEFTLIMIT; I <= RIGHTLIMIT; I++) {
			INT C = GDIMAGEGETPIXEL(IM, I, Y - 1);
			IF (LASTBORDER) {
				IF ((C != BORDER) && (C != COLOR)) {
					GDIMAGEFILLTOBORDER(IM, I, Y - 1, BORDER, COLOR);
					LASTBORDER = 0;
				}
			} ELSE IF ((C == BORDER) || (C == COLOR)) {
				LASTBORDER = 1;
			}
		}
	}
	/* BELOW */
	IF (Y < ((IM->SY) - 1)) {
		LASTBORDER = 1;
		FOR (I = LEFTLIMIT; I <= RIGHTLIMIT; I++) {
			INT C = GDIMAGEGETPIXEL(IM, I, Y + 1);

			IF (LASTBORDER) {
				IF ((C != BORDER) && (C != COLOR)) {
					GDIMAGEFILLTOBORDER(IM, I, Y + 1, BORDER, COLOR);
					LASTBORDER = 0;
				}
			} ELSE IF ((C == BORDER) || (C == COLOR)) {
				LASTBORDER = 1;
			}
		}
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 436046_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

STATIC VOID IO_FREE_FILE_TABLES(STRUCT IO_FILE_TABLE *TABLE, UNSIGNED NR_FILES)
{
	SIZE_T SIZE = NR_FILES * SIZEOF(STRUCT IO_FIXED_FILE);

	IO_FREE_PAGE_TABLE((VOID **)TABLE->FILES, SIZE);
	TABLE->FILES = NULL;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 448582_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDK_PIXBUF__XBM_IMAGE_BEGIN_LOAD (GDKPIXBUFMODULESIZEFUNC       SIZE_FUNC,
                                  GDKPIXBUFMODULEPREPAREDFUNC   PREPARE_FUNC,
				  GDKPIXBUFMODULEUPDATEDFUNC    UPDATE_FUNC,
				  GPOINTER                      USER_DATA,
				  GERROR                      **ERROR)
{
	XBMDATA *CONTEXT;
	GINT FD;

	CONTEXT = G_NEW (XBMDATA, 1);
	CONTEXT->PREPARE_FUNC = PREPARE_FUNC;
	CONTEXT->UPDATE_FUNC = UPDATE_FUNC;
	CONTEXT->USER_DATA = USER_DATA;
	CONTEXT->ALL_OKAY = TRUE;
	FD = G_FILE_OPEN_TMP ("GDKPIXBUF-XBM-TMP.XXXXXX",
			      &CONTEXT->TEMPNAME,
			      NULL);
	IF (FD < 0) {
		G_FREE (CONTEXT);
		RETURN NULL;
	}

	CONTEXT->FILE = FDOPEN (FD, "W+");
	IF (CONTEXT->FILE == NULL) {
		G_FREE (CONTEXT->TEMPNAME);
		G_FREE (CONTEXT);
		RETURN NULL;
	}

	RETURN CONTEXT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 291835_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PROCESS_INFO_RSP(STRUCT RTRS_CLT_PATH *CLT_PATH,
			    CONST STRUCT RTRS_MSG_INFO_RSP *MSG)
{
	UNSIGNED INT SG_CNT, TOTAL_LEN;
	INT I, SGI;

	SG_CNT = LE16_TO_CPU(MSG->SG_CNT);
	IF (!SG_CNT || (CLT_PATH->QUEUE_DEPTH % SG_CNT)) {
		RTRS_ERR(CLT_PATH->CLT,
			  "INCORRECT SG_CNT %D, IS NOT MULTIPLE\N",
			  SG_CNT);
		RETURN -EINVAL;
	}

	/*
	 * CHECK IF IB IMMEDIATE DATA SIZE IS ENOUGH TO HOLD THE MEM_ID AND
	 * THE OFFSET INSIDE THE MEMORY CHUNK.
	 */
	IF ((ILOG2(SG_CNT - 1) + 1) + (ILOG2(CLT_PATH->CHUNK_SIZE - 1) + 1) >
	    MAX_IMM_PAYL_BITS) {
		RTRS_ERR(CLT_PATH->CLT,
			  "RDMA IMMEDIATE SIZE (%DB) NOT ENOUGH TO ENCODE %D BUFFERS OF SIZE %DB\N",
			  MAX_IMM_PAYL_BITS, SG_CNT, CLT_PATH->CHUNK_SIZE);
		RETURN -EINVAL;
	}
	TOTAL_LEN = 0;
	FOR (SGI = 0, I = 0; SGI < SG_CNT && I < CLT_PATH->QUEUE_DEPTH; SGI++) {
		CONST STRUCT RTRS_SG_DESC *DESC = &MSG->DESC[SGI];
		U32 LEN, RKEY;
		U64 ADDR;

		ADDR = LE64_TO_CPU(DESC->ADDR);
		RKEY = LE32_TO_CPU(DESC->KEY);
		LEN  = LE32_TO_CPU(DESC->LEN);

		TOTAL_LEN += LEN;

		IF (!LEN || (LEN % CLT_PATH->CHUNK_SIZE)) {
			RTRS_ERR(CLT_PATH->CLT, "INCORRECT [%D].LEN %D\N",
				  SGI,
				  LEN);
			RETURN -EINVAL;
		}
		FOR ( ; LEN && I < CLT_PATH->QUEUE_DEPTH; I++) {
			CLT_PATH->RBUFS[I].ADDR = ADDR;
			CLT_PATH->RBUFS[I].RKEY = RKEY;

			LEN  -= CLT_PATH->CHUNK_SIZE;
			ADDR += CLT_PATH->CHUNK_SIZE;
		}
	}
	/* SANITY CHECK */
	IF (SGI != SG_CNT || I != CLT_PATH->QUEUE_DEPTH) {
		RTRS_ERR(CLT_PATH->CLT,
			 "INCORRECT SG VECTOR, NOT FULLY MAPPED\N");
		RETURN -EINVAL;
	}
	IF (TOTAL_LEN != CLT_PATH->CHUNK_SIZE * CLT_PATH->QUEUE_DEPTH) {
		RTRS_ERR(CLT_PATH->CLT, "INCORRECT TOTAL_LEN %D\N", TOTAL_LEN);
		RETURN -EINVAL;
	}

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208107_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT XFRM_EXPAND_POLICIES(CONST STRUCT FLOWI *FL, U16 FAMILY,
				STRUCT XFRM_POLICY **POLS,
				INT *NUM_POLS, INT *NUM_XFRMS)
{
	INT I;

	IF (*NUM_POLS == 0 || !POLS[0]) {
		*NUM_POLS = 0;
		*NUM_XFRMS = 0;
		RETURN 0;
	}
	IF (IS_ERR(POLS[0]))
		RETURN PTR_ERR(POLS[0]);

	*NUM_XFRMS = POLS[0]->XFRM_NR;

#IFDEF CONFIG_XFRM_SUB_POLICY
	IF (POLS[0]->ACTION == XFRM_POLICY_ALLOW &&
	    POLS[0]->TYPE != XFRM_POLICY_TYPE_MAIN) {
		POLS[1] = XFRM_POLICY_LOOKUP_BYTYPE(XP_NET(POLS[0]),
						    XFRM_POLICY_TYPE_MAIN,
						    FL, FAMILY,
						    XFRM_POLICY_OUT,
						    POLS[0]->IF_ID);
		IF (POLS[1]) {
			IF (IS_ERR(POLS[1])) {
				XFRM_POLS_PUT(POLS, *NUM_POLS);
				RETURN PTR_ERR(POLS[1]);
			}
			(*NUM_POLS)++;
			(*NUM_XFRMS) += POLS[1]->XFRM_NR;
		}
	}
#ENDIF
	FOR (I = 0; I < *NUM_POLS; I++) {
		IF (POLS[I]->ACTION != XFRM_POLICY_ALLOW) {
			*NUM_XFRMS = -1;
			BREAK;
		}
	}

	RETURN 0;

}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384803_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UNIX_EXPANDPATH(
    GARRAY_T	*GAP,
    CHAR_U	*PATH,
    INT		WILDOFF,
    INT		FLAGS,		// EW_* FLAGS
    INT		DIDSTAR)	// EXPANDED "**" ONCE ALREADY
{
    CHAR_U	*BUF;
    CHAR_U	*PATH_END;
    CHAR_U	*P, *S, *E;
    INT		START_LEN = GAP->GA_LEN;
    CHAR_U	*PAT;
    REGMATCH_T	REGMATCH;
    INT		STARTS_WITH_DOT;
    INT		MATCHES;
    INT		LEN;
    INT		STARSTAR = FALSE;
    STATIC INT	STARDEPTH = 0;	    // DEPTH FOR "**" EXPANSION

    DIR		*DIRP;
    STRUCT DIRENT *DP;

    // EXPANDING "**" MAY TAKE A LONG TIME, CHECK FOR CTRL-C.
    IF (STARDEPTH > 0)
    {
	UI_BREAKCHECK();
	IF (GOT_INT)
	    RETURN 0;
    }

    // MAKE ROOM FOR FILE NAME
    BUF = ALLOC(STRLEN(PATH) + BASENAMELEN + 5);
    IF (BUF == NULL)
	RETURN 0;

    /*
     * FIND THE FIRST PART IN THE PATH NAME THAT CONTAINS A WILDCARD.
     * WHEN EW_ICASE IS SET EVERY LETTER IS CONSIDERED TO BE A WILDCARD.
     * COPY IT INTO "BUF", INCLUDING THE PRECEDING CHARACTERS.
     */
    P = BUF;
    S = BUF;
    E = NULL;
    PATH_END = PATH;
    WHILE (*PATH_END != NUL)
    {
	// MAY IGNORE A WILDCARD THAT HAS A BACKSLASH BEFORE IT; IT WILL
	// BE REMOVED BY REM_BACKSLASH() OR FILE_PAT_TO_REG_PAT() BELOW.
	IF (PATH_END >= PATH + WILDOFF && REM_BACKSLASH(PATH_END))
	    *P++ = *PATH_END++;
	ELSE IF (*PATH_END == '/')
	{
	    IF (E != NULL)
		BREAK;
	    S = P + 1;
	}
	ELSE IF (PATH_END >= PATH + WILDOFF
			 && (VIM_STRCHR((CHAR_U *)"*?[{~$", *PATH_END) != NULL
			     || (!P_FIC && (FLAGS & EW_ICASE)
					  && VIM_ISALPHA(PTR2CHAR(PATH_END)))))
	    E = P;
	IF (HAS_MBYTE)
	{
	    LEN = (*MB_PTR2LEN)(PATH_END);
	    STRNCPY(P, PATH_END, LEN);
	    P += LEN;
	    PATH_END += LEN;
	}
	ELSE
	    *P++ = *PATH_END++;
    }
    E = P;
    *E = NUL;

    // NOW WE HAVE ONE WILDCARD COMPONENT BETWEEN "S" AND "E".
    // REMOVE BACKSLASHES BETWEEN "WILDOFF" AND THE START OF THE WILDCARD
    // COMPONENT.
    FOR (P = BUF + WILDOFF; P < S; ++P)
	IF (REM_BACKSLASH(P))
	{
	    STRMOVE(P, P + 1);
	    --E;
	    --S;
	}

    // CHECK FOR "**" BETWEEN "S" AND "E".
    FOR (P = S; P < E; ++P)
	IF (P[0] == '*' && P[1] == '*')
	    STARSTAR = TRUE;

    // CONVERT THE FILE PATTERN TO A REGEXP PATTERN
    STARTS_WITH_DOT = *S == '.';
    PAT = FILE_PAT_TO_REG_PAT(S, E, NULL, FALSE);
    IF (PAT == NULL)
    {
	VIM_FREE(BUF);
	RETURN 0;
    }

    // COMPILE THE REGEXP INTO A PROGRAM
    IF (FLAGS & EW_ICASE)
	REGMATCH.RM_IC = TRUE;		// 'WILDIGNORECASE' SET
    ELSE
	REGMATCH.RM_IC = P_FIC;	// IGNORE CASE WHEN 'FILEIGNORECASE' IS SET
    IF (FLAGS & (EW_NOERROR | EW_NOTWILD))
	++EMSG_SILENT;
    REGMATCH.REGPROG = VIM_REGCOMP(PAT, RE_MAGIC);
    IF (FLAGS & (EW_NOERROR | EW_NOTWILD))
	--EMSG_SILENT;
    VIM_FREE(PAT);

    IF (REGMATCH.REGPROG == NULL && (FLAGS & EW_NOTWILD) == 0)
    {
	VIM_FREE(BUF);
	RETURN 0;
    }

    // IF "**" IS BY ITSELF, THIS IS THE FIRST TIME WE ENCOUNTER IT AND MORE
    // IS FOLLOWING THEN FIND MATCHES WITHOUT ANY DIRECTORY.
    IF (!DIDSTAR && STARDEPTH < 100 && STARSTAR && E - S == 2
							  && *PATH_END == '/')
    {
	STRCPY(S, PATH_END + 1);
	++STARDEPTH;
	(VOID)UNIX_EXPANDPATH(GAP, BUF, (INT)(S - BUF), FLAGS, TRUE);
	--STARDEPTH;
    }

    // OPEN THE DIRECTORY FOR SCANNING
    *S = NUL;
    DIRP = OPENDIR(*BUF == NUL ? "." : (CHAR *)BUF);

    // FIND ALL MATCHING ENTRIES
    IF (DIRP != NULL)
    {
	FOR (;;)
	{
	    DP = READDIR(DIRP);
	    IF (DP == NULL)
		BREAK;
	    IF ((DP->D_NAME[0] != '.' || STARTS_WITH_DOT
			|| ((FLAGS & EW_DODOT)
			    && DP->D_NAME[1] != NUL
			    && (DP->D_NAME[1] != '.' || DP->D_NAME[2] != NUL)))
		 && ((REGMATCH.REGPROG != NULL && VIM_REGEXEC(&REGMATCH,
					     (CHAR_U *)DP->D_NAME, (COLNR_T)0))
		   || ((FLAGS & EW_NOTWILD)
		     && FNAMENCMP(PATH + (S - BUF), DP->D_NAME, E - S) == 0)))
	    {
		STRCPY(S, DP->D_NAME);
		LEN = STRLEN(BUF);

		IF (STARSTAR && STARDEPTH < 100)
		{
		    // FOR "**" IN THE PATTERN FIRST GO DEEPER IN THE TREE TO
		    // FIND MATCHES.
		    STRCPY(BUF + LEN, "/**");
		    STRCPY(BUF + LEN + 3, PATH_END);
		    ++STARDEPTH;
		    (VOID)UNIX_EXPANDPATH(GAP, BUF, LEN + 1, FLAGS, TRUE);
		    --STARDEPTH;
		}

		STRCPY(BUF + LEN, PATH_END);
		IF (MCH_HAS_EXP_WILDCARD(PATH_END)) // HANDLE MORE WILDCARDS
		{
		    // NEED TO EXPAND ANOTHER COMPONENT OF THE PATH
		    // REMOVE BACKSLASHES FOR THE REMAINING COMPONENTS ONLY
		    (VOID)UNIX_EXPANDPATH(GAP, BUF, LEN + 1, FLAGS, FALSE);
		}
		ELSE
		{
		    STAT_T  SB;

		    // NO MORE WILDCARDS, CHECK IF THERE IS A MATCH
		    // REMOVE BACKSLASHES FOR THE REMAINING COMPONENTS ONLY
		    IF (*PATH_END != NUL)
			BACKSLASH_HALVE(BUF + LEN + 1);
		    // ADD EXISTING FILE OR SYMBOLIC LINK
		    IF ((FLAGS & EW_ALLLINKS) ? MCH_LSTAT((CHAR *)BUF, &SB) >= 0
						      : MCH_GETPERM(BUF) >= 0)
		    {
#IFDEF MACOS_CONVERT
			SIZE_T PRECOMP_LEN = STRLEN(BUF)+1;
			CHAR_U *PRECOMP_BUF =
			    MAC_PRECOMPOSE_PATH(BUF, PRECOMP_LEN, &PRECOMP_LEN);

			IF (PRECOMP_BUF)
			{
			    MCH_MEMMOVE(BUF, PRECOMP_BUF, PRECOMP_LEN);
			    VIM_FREE(PRECOMP_BUF);
			}
#ENDIF
			ADDFILE(GAP, BUF, FLAGS);
		    }
		}
	    }
	}

	CLOSEDIR(DIRP);
    }

    VIM_FREE(BUF);
    VIM_REGFREE(REGMATCH.REGPROG);

    MATCHES = GAP->GA_LEN - START_LEN;
    IF (MATCHES > 0)
	QSORT(((CHAR_U **)GAP->GA_DATA) + START_LEN, MATCHES,
						   SIZEOF(CHAR_U *), PSTRCMP);
    RETURN MATCHES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216027_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PAX_DECODE_HEADER (STRUCT TAR_SPARSE_FILE *FILE)
{
  IF (FILE->STAT_INFO->SPARSE_MAJOR > 0)
    {
      UINTMAX_T U;
      CHAR NBUF[UINTMAX_STRSIZE_BOUND];
      UNION BLOCK *BLK;
      CHAR *P;
      SIZE_T I;
      OFF_T START;
      
#DEFINE COPY_BUF(B,BUF,SRC) DO                                     \
 {                                                                 \
   CHAR *ENDP = B->BUFFER + BLOCKSIZE;                             \
   CHAR *DST = BUF;                                                \
   DO                                                              \
     {                                                             \
       IF (DST == BUF + UINTMAX_STRSIZE_BOUND -1)                  \
         {                                                         \
           ERROR ((0, 0, _("%S: NUMERIC OVERFLOW IN SPARSE ARCHIVE MEMBER"), \
	          FILE->STAT_INFO->ORIG_FILE_NAME));               \
           RETURN FALSE;                                           \
         }                                                         \
       IF (SRC == ENDP)                                            \
	 {                                                         \
	   SET_NEXT_BLOCK_AFTER (B);                               \
           B = FIND_NEXT_BLOCK ();                                 \
           SRC = B->BUFFER;                                        \
	   ENDP = B->BUFFER + BLOCKSIZE;                           \
	 }                                                         \
       *DST = *SRC++;                                              \
     }                                                             \
   WHILE (*DST++ != '\N');                                         \
   DST[-1] = 0;                                                    \
 } WHILE (0)

      START = CURRENT_BLOCK_ORDINAL ();
      SET_NEXT_BLOCK_AFTER (CURRENT_HEADER);
      BLK = FIND_NEXT_BLOCK ();
      P = BLK->BUFFER;
      COPY_BUF (BLK,NBUF,P);
      IF (!DECODE_NUM (&U, NBUF, TYPE_MAXIMUM (SIZE_T)))
	{
	  ERROR ((0, 0, _("%S: MALFORMED SPARSE ARCHIVE MEMBER"),
		  FILE->STAT_INFO->ORIG_FILE_NAME));
	  RETURN FALSE;
	}
      FILE->STAT_INFO->SPARSE_MAP_SIZE = U;
      FILE->STAT_INFO->SPARSE_MAP = XCALLOC (FILE->STAT_INFO->SPARSE_MAP_SIZE,
					     SIZEOF (*FILE->STAT_INFO->SPARSE_MAP));
      FILE->STAT_INFO->SPARSE_MAP_AVAIL = 0;
      FOR (I = 0; I < FILE->STAT_INFO->SPARSE_MAP_SIZE; I++)
	{
	  STRUCT SP_ARRAY SP;

	  COPY_BUF (BLK,NBUF,P);
	  IF (!DECODE_NUM (&U, NBUF, TYPE_MAXIMUM (OFF_T)))
	    {
	      ERROR ((0, 0, _("%S: MALFORMED SPARSE ARCHIVE MEMBER"),
		      FILE->STAT_INFO->ORIG_FILE_NAME));
	      RETURN FALSE;
	    }
	  SP.OFFSET = U;
	  COPY_BUF (BLK,NBUF,P);
	  IF (!DECODE_NUM (&U, NBUF, TYPE_MAXIMUM (OFF_T)))
	    {
	      ERROR ((0, 0, _("%S: MALFORMED SPARSE ARCHIVE MEMBER"),
		      FILE->STAT_INFO->ORIG_FILE_NAME));
	      RETURN FALSE;
	    }
	  SP.NUMBYTES = U;
	  SPARSE_ADD_MAP (FILE->STAT_INFO, &SP);
	}
      SET_NEXT_BLOCK_AFTER (BLK);

      FILE->DUMPED_SIZE += BLOCKSIZE * (CURRENT_BLOCK_ORDINAL () - START);
    }

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200672_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SDHCI_DO_ADMA(SDHCISTATE *S)
{
    UNSIGNED INT BEGIN, LENGTH;
    CONST UINT16_T BLOCK_SIZE = S->BLKSIZE & BLOCK_SIZE_MASK;
    ADMADESCR DSCR = {};
    INT I;

    IF (S->TRNMOD & SDHC_TRNS_BLK_CNT_EN && !S->BLKCNT) {
        /* STOP MULTIPLE TRANSFER */
        SDHCI_END_TRANSFER(S);
        RETURN;
    }

    FOR (I = 0; I < SDHC_ADMA_DESCS_PER_DELAY; ++I) {
        S->ADMAERR &= ~SDHC_ADMAERR_LENGTH_MISMATCH;

        GET_ADMA_DESCRIPTION(S, &DSCR);
        TRACE_SDHCI_ADMA_LOOP(DSCR.ADDR, DSCR.LENGTH, DSCR.ATTR);

        IF ((DSCR.ATTR & SDHC_ADMA_ATTR_VALID) == 0) {
            /* INDICATE THAT ERROR OCCURRED IN ST_FDS STATE */
            S->ADMAERR &= ~SDHC_ADMAERR_STATE_MASK;
            S->ADMAERR |= SDHC_ADMAERR_STATE_ST_FDS;

            /* GENERATE ADMA ERROR INTERRUPT */
            IF (S->ERRINTSTSEN & SDHC_EISEN_ADMAERR) {
                S->ERRINTSTS |= SDHC_EIS_ADMAERR;
                S->NORINTSTS |= SDHC_NIS_ERR;
            }

            SDHCI_UPDATE_IRQ(S);
            RETURN;
        }

        LENGTH = DSCR.LENGTH ? DSCR.LENGTH : 64 * KIB;

        SWITCH (DSCR.ATTR & SDHC_ADMA_ATTR_ACT_MASK) {
        CASE SDHC_ADMA_ATTR_ACT_TRAN:  /* DATA TRANSFER */
            IF (S->TRNMOD & SDHC_TRNS_READ) {
                WHILE (LENGTH) {
                    IF (S->DATA_COUNT == 0) {
                        SDBUS_READ_DATA(&S->SDBUS, S->FIFO_BUFFER, BLOCK_SIZE);
                    }
                    BEGIN = S->DATA_COUNT;
                    IF ((LENGTH + BEGIN) < BLOCK_SIZE) {
                        S->DATA_COUNT = LENGTH + BEGIN;
                        LENGTH = 0;
                     } ELSE {
                        S->DATA_COUNT = BLOCK_SIZE;
                        LENGTH -= BLOCK_SIZE - BEGIN;
                    }
                    DMA_MEMORY_WRITE(S->DMA_AS, DSCR.ADDR,
                                     &S->FIFO_BUFFER[BEGIN],
                                     S->DATA_COUNT - BEGIN);
                    DSCR.ADDR += S->DATA_COUNT - BEGIN;
                    IF (S->DATA_COUNT == BLOCK_SIZE) {
                        S->DATA_COUNT = 0;
                        IF (S->TRNMOD & SDHC_TRNS_BLK_CNT_EN) {
                            S->BLKCNT--;
                            IF (S->BLKCNT == 0) {
                                BREAK;
                            }
                        }
                    }
                }
            } ELSE {
                WHILE (LENGTH) {
                    BEGIN = S->DATA_COUNT;
                    IF ((LENGTH + BEGIN) < BLOCK_SIZE) {
                        S->DATA_COUNT = LENGTH + BEGIN;
                        LENGTH = 0;
                     } ELSE {
                        S->DATA_COUNT = BLOCK_SIZE;
                        LENGTH -= BLOCK_SIZE - BEGIN;
                    }
                    DMA_MEMORY_READ(S->DMA_AS, DSCR.ADDR,
                                    &S->FIFO_BUFFER[BEGIN],
                                    S->DATA_COUNT - BEGIN);
                    DSCR.ADDR += S->DATA_COUNT - BEGIN;
                    IF (S->DATA_COUNT == BLOCK_SIZE) {
                        SDBUS_WRITE_DATA(&S->SDBUS, S->FIFO_BUFFER, BLOCK_SIZE);
                        S->DATA_COUNT = 0;
                        IF (S->TRNMOD & SDHC_TRNS_BLK_CNT_EN) {
                            S->BLKCNT--;
                            IF (S->BLKCNT == 0) {
                                BREAK;
                            }
                        }
                    }
                }
            }
            S->ADMASYSADDR += DSCR.INCR;
            BREAK;
        CASE SDHC_ADMA_ATTR_ACT_LINK:   /* LINK TO NEXT DESCRIPTOR TABLE */
            S->ADMASYSADDR = DSCR.ADDR;
            TRACE_SDHCI_ADMA("LINK", S->ADMASYSADDR);
            BREAK;
        DEFAULT:
            S->ADMASYSADDR += DSCR.INCR;
            BREAK;
        }

        IF (DSCR.ATTR & SDHC_ADMA_ATTR_INT) {
            TRACE_SDHCI_ADMA("INTERRUPT", S->ADMASYSADDR);
            IF (S->NORINTSTSEN & SDHC_NISEN_DMA) {
                S->NORINTSTS |= SDHC_NIS_DMA;
            }

            IF (SDHCI_UPDATE_IRQ(S) && !(DSCR.ATTR & SDHC_ADMA_ATTR_END)) {
                /* IRQ DELIVERED, RESCHEDULE CURRENT TRANSFER */
                BREAK;
            }
        }

        /* ADMA TRANSFER TERMINATES IF BLKCNT == 0 OR BY END ATTRIBUTE */
        IF (((S->TRNMOD & SDHC_TRNS_BLK_CNT_EN) &&
                    (S->BLKCNT == 0)) || (DSCR.ATTR & SDHC_ADMA_ATTR_END)) {
            TRACE_SDHCI_ADMA_TRANSFER_COMPLETED();
            IF (LENGTH || ((DSCR.ATTR & SDHC_ADMA_ATTR_END) &&
                (S->TRNMOD & SDHC_TRNS_BLK_CNT_EN) &&
                S->BLKCNT != 0)) {
                TRACE_SDHCI_ERROR("SD/MMC HOST ADMA LENGTH MISMATCH");
                S->ADMAERR |= SDHC_ADMAERR_LENGTH_MISMATCH |
                        SDHC_ADMAERR_STATE_ST_TFR;
                IF (S->ERRINTSTSEN & SDHC_EISEN_ADMAERR) {
                    TRACE_SDHCI_ERROR("SET ADMA ERROR FLAG");
                    S->ERRINTSTS |= SDHC_EIS_ADMAERR;
                    S->NORINTSTS |= SDHC_NIS_ERR;
                }

                SDHCI_UPDATE_IRQ(S);
            }
            SDHCI_END_TRANSFER(S);
            RETURN;
        }

    }

    /* WE HAVE UNFINISHED BUSINESS - RESCHEDULE TO CONTINUE ADMA */
    TIMER_MOD(S->TRANSFER_TIMER,
                   QEMU_CLOCK_GET_NS(QEMU_CLOCK_VIRTUAL) + SDHC_TRANSFER_DELAY);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216701_CWE-770.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC ENUM TIFFREADDIRENTRYERR TIFFREADDIRENTRYARRAYWITHLIMIT(
    TIFF* TIF, TIFFDIRENTRY* DIRENTRY, UINT32* COUNT, UINT32 DESTTYPESIZE,
    VOID** VALUE, UINT64 MAXCOUNT)
{
	INT TYPESIZE;
	UINT32 DATASIZE;
	VOID* DATA;
        UINT64 TARGET_COUNT64;
	TYPESIZE=TIFFDATAWIDTH(DIRENTRY->TDIR_TYPE);

        TARGET_COUNT64 = (DIRENTRY->TDIR_COUNT > MAXCOUNT) ?
                MAXCOUNT : DIRENTRY->TDIR_COUNT;

	IF ((TARGET_COUNT64==0)||(TYPESIZE==0))
	{
		*VALUE=0;
		RETURN(TIFFREADDIRENTRYERROK);
	}
        (VOID) DESTTYPESIZE;

        /* 
         * AS A SANITY CHECK, MAKE SURE WE HAVE NO MORE THAN A 2GB TAG ARRAY 
         * IN EITHER THE CURRENT DATA TYPE OR THE DEST DATA TYPE.  THIS ALSO
         * AVOIDS PROBLEMS WITH OVERFLOW OF TMSIZE_T ON 32BIT SYSTEMS.
         */
	IF ((UINT64)(2147483647/TYPESIZE)<TARGET_COUNT64)
		RETURN(TIFFREADDIRENTRYERRSIZESAN);
	IF ((UINT64)(2147483647/DESTTYPESIZE)<TARGET_COUNT64)
		RETURN(TIFFREADDIRENTRYERRSIZESAN);

	*COUNT=(UINT32)TARGET_COUNT64;
	DATASIZE=(*COUNT)*TYPESIZE;
	ASSERT((TMSIZE_T)DATASIZE>0);
	DATA=_TIFFCHECKMALLOC(TIF, *COUNT, TYPESIZE, "READDIRENTRYARRAY");
	IF (DATA==0)
		RETURN(TIFFREADDIRENTRYERRALLOC);
	IF (!(TIF->TIF_FLAGS&TIFF_BIGTIFF))
	{
		IF (DATASIZE<=4)
			_TIFFMEMCPY(DATA,&DIRENTRY->TDIR_OFFSET,DATASIZE);
		ELSE
		{
			ENUM TIFFREADDIRENTRYERR ERR;
			UINT32 OFFSET = DIRENTRY->TDIR_OFFSET.TOFF_LONG;
			IF (TIF->TIF_FLAGS&TIFF_SWAB)
				TIFFSWABLONG(&OFFSET);
			ERR=TIFFREADDIRENTRYDATA(TIF,(UINT64)OFFSET,(TMSIZE_T)DATASIZE,DATA);
			IF (ERR!=TIFFREADDIRENTRYERROK)
			{
				_TIFFFREE(DATA);
				RETURN(ERR);
			}
		}
	}
	ELSE
	{
		IF (DATASIZE<=8)
			_TIFFMEMCPY(DATA,&DIRENTRY->TDIR_OFFSET,DATASIZE);
		ELSE
		{
			ENUM TIFFREADDIRENTRYERR ERR;
			UINT64 OFFSET = DIRENTRY->TDIR_OFFSET.TOFF_LONG8;
			IF (TIF->TIF_FLAGS&TIFF_SWAB)
				TIFFSWABLONG8(&OFFSET);
			ERR=TIFFREADDIRENTRYDATA(TIF,OFFSET,(TMSIZE_T)DATASIZE,DATA);
			IF (ERR!=TIFFREADDIRENTRYERROK)
			{
				_TIFFFREE(DATA);
				RETURN(ERR);
			}
		}
	}
	*VALUE=DATA;
	RETURN(TIFFREADDIRENTRYERROK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359215_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID BPF_RINGBUF_COMMIT(VOID *SAMPLE, U64 FLAGS, BOOL DISCARD)
{
	UNSIGNED LONG REC_POS, CONS_POS;
	STRUCT BPF_RINGBUF_HDR *HDR;
	STRUCT BPF_RINGBUF *RB;
	U32 NEW_LEN;

	HDR = SAMPLE - BPF_RINGBUF_HDR_SZ;
	RB = BPF_RINGBUF_RESTORE_FROM_REC(HDR);
	NEW_LEN = HDR->LEN ^ BPF_RINGBUF_BUSY_BIT;
	IF (DISCARD)
		NEW_LEN |= BPF_RINGBUF_DISCARD_BIT;

	/* UPDATE RECORD HEADER WITH CORRECT FINAL SIZE PREFIX */
	XCHG(&HDR->LEN, NEW_LEN);

	/* IF CONSUMER CAUGHT UP AND IS WAITING FOR OUR RECORD, NOTIFY ABOUT
	 * NEW DATA AVAILABILITY
	 */
	REC_POS = (VOID *)HDR - (VOID *)RB->DATA;
	CONS_POS = SMP_LOAD_ACQUIRE(&RB->CONSUMER_POS) & RB->MASK;

	IF (FLAGS & BPF_RB_FORCE_WAKEUP)
		IRQ_WORK_QUEUE(&RB->WORK);
	ELSE IF (CONS_POS == REC_POS && !(FLAGS & BPF_RB_NO_WAKEUP))
		IRQ_WORK_QUEUE(&RB->WORK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196691_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR ISOFFIN_PROCESS(GF_FILTER *FILTER)
{
	ISOMREADER *READ = GF_FILTER_GET_UDTA(FILTER);
	U32 I, COUNT = GF_LIST_COUNT(READ->CHANNELS);
	BOOL IS_ACTIVE = GF_FALSE;
	BOOL IN_IS_EOS = GF_FALSE;
	BOOL CHECK_FORCED_END = GF_FALSE;
	BOOL HAS_NEW_DATA = GF_FALSE;
	U64 MIN_OFFSET_PLUS_ONE = 0;
	U32 NB_FORCED_END=0;
	IF (READ->IN_ERROR)
		RETURN READ->IN_ERROR;

	IF (READ->PID) {
		BOOL FETCH_INPUT = GF_TRUE;

		//WE FAILED AT LOADING THE INIT SEGMENT DURING A DASH SWITCH, RETRY
		IF (!READ->IS_PARTIAL_DOWNLOAD && !READ->MEM_LOAD_MODE && (READ->MOOV_NOT_LOADED==2) ) {
			ISOFFIN_CONFIGURE_PID(FILTER, READ->PID, GF_FALSE);
			IF (READ->MOOV_NOT_LOADED) RETURN GF_OK;
		}
		IF (READ->MEM_LOAD_MODE==2) {
			IF (!READ->FORCE_FETCH && READ->MEM_BLOB.SIZE > READ->MSTORE_SIZE) {
				FETCH_INPUT = GF_FALSE;
			}
			READ->FORCE_FETCH = GF_FALSE;
		}
		WHILE (FETCH_INPUT) {
			GF_FILTERPACKET *PCK = GF_FILTER_PID_GET_PACKET(READ->PID);
			IF (!PCK) {
				//WE ISSUED A SEEK, WAIT FOR THE FIRST PACKET TO BE RECEIVED BEFORE FETCHING CHANNELS
				//OTHERWISE WE COULD END UP READING FROM THE WRONG CACHE
				IF (READ->WAIT_FOR_SOURCE) {
					//SOMETHING WENT WRONG DURING THE SEEK REQUEST
					IF (GF_FILTER_PID_IS_EOS(READ->PID))
						RETURN GF_EOS;
					RETURN GF_OK;
				}
				BREAK;
			}
			READ->WAIT_FOR_SOURCE = GF_FALSE;

			IF (READ->MEM_LOAD_MODE) {
				U32 DATA_SIZE;
				CONST U8 *PCK_DATA = GF_FILTER_PCK_GET_DATA(PCK, &DATA_SIZE);
				ISOFFIN_PUSH_BUFFER(FILTER, READ, PCK_DATA, DATA_SIZE);
			}
			//WE JUST HAD A SWITCH BUT INIT SEG IS NOT COMPLETELY DONE: INPUT PACKET IS ONLY A PART OF THE INIT, DROP IT
			ELSE IF (READ->MOOV_NOT_LOADED==2) {
				GF_FILTER_PID_DROP_PACKET(READ->PID);
				RETURN GF_OK;
			}
			GF_FILTER_PID_DROP_PACKET(READ->PID);
			HAS_NEW_DATA = GF_TRUE;
			IF (READ->IN_ERROR)
				RETURN READ->IN_ERROR;
		}
		IF (GF_FILTER_PID_IS_EOS(READ->PID)) {
			READ->INPUT_LOADED = GF_TRUE;
			IN_IS_EOS = GF_TRUE;
		}
		IF (READ->INPUT_IS_STOP) {
			READ->INPUT_LOADED = GF_TRUE;
			IN_IS_EOS = GF_TRUE;
			READ->INPUT_IS_STOP = GF_FALSE;
		}
		IF (!READ->FRAG_TYPE && READ->INPUT_LOADED) {
			IN_IS_EOS = GF_TRUE;
		}
        //SEGMENT IS INVALID, WAIT FOR EOS ON INPUT AN SEND EOS ON ALL CHANNELS
        IF (READ->INVALID_SEGMENT) {
            IF (!IN_IS_EOS) RETURN GF_OK;
            READ->INVALID_SEGMENT = GF_FALSE;

            FOR (I=0; I<COUNT; I++) {
                ISOMCHANNEL *CH = GF_LIST_GET(READ->CHANNELS, I);
                IF (!CH->PLAYING) {
                    CONTINUE;
                }
                IF (!CH->EOS_SENT) {
                    CH->EOS_SENT = GF_TRUE;
                    GF_FILTER_PID_SET_EOS(CH->PID);
                }
            }
            READ->EOS_SIGNALED = GF_TRUE;
            RETURN GF_EOS;
        }
	} ELSE IF (READ->EXTERN_MOV) {
		IN_IS_EOS = GF_TRUE;
		READ->INPUT_LOADED = GF_TRUE;
	}
	IF (READ->MOOV_NOT_LOADED==1) {
		IF (READ->MEM_LOAD_MODE)
			RETURN GF_OK;
		READ->MOOV_NOT_LOADED = GF_FALSE;
		RETURN ISOFFIN_SETUP(FILTER, READ);
	}

	IF (READ->REFRESH_FRAGMENTED) {
		CONST GF_PROPERTYVALUE *PROP;

		IF (IN_IS_EOS) {
			READ->REFRESH_FRAGMENTED = GF_FALSE;
		} ELSE {
			PROP = GF_FILTER_PID_GET_PROPERTY(READ->PID, GF_PROP_PID_FILE_CACHED);
			IF (PROP && PROP->VALUE.BOOLEAN)
				READ->REFRESH_FRAGMENTED = GF_FALSE;
		}

		IF (HAS_NEW_DATA) {
			U64 BYTESMISSING=0;
			GF_ERR E;
			CONST CHAR *NEW_URL = NULL;
			PROP = GF_FILTER_PID_GET_PROPERTY(READ->PID, GF_PROP_PID_FILEPATH);
			IF (PROP) NEW_URL = PROP->VALUE.STRING;

			E = GF_ISOM_REFRESH_FRAGMENTED(READ->MOV, &BYTESMISSING, NEW_URL);

			IF (E && (E!= GF_ISOM_INCOMPLETE_FILE)) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[ISOMEDIA] FAILED TO REFRESH CURRENT SEGMENT: %S\N", GF_ERROR_TO_STRING(E) ));
				READ->REFRESH_FRAGMENTED = GF_FALSE;
			} ELSE {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[ISOMEDIA] REFRESHING CURRENT SEGMENT AT UTC "LLU" - "LLU" BYTES STILL MISSING - INPUT IS EOS %D\N", GF_NET_GET_UTC(), BYTESMISSING, IN_IS_EOS));
			}

			IF (!READ->REFRESH_FRAGMENTED && (E==GF_ISOM_INCOMPLETE_FILE)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[ISOMEDIA] INCOMPLETE SEGMENT RECEIVED - "LLU" BYTES MISSING BUT EOF FOUND\N", BYTESMISSING ));
			}

#IFNDEF GPAC_DISABLE_LOG
			IF (GF_LOG_TOOL_LEVEL_ON(GF_LOG_DASH, GF_LOG_DEBUG)) {
				FOR (I=0; I<COUNT; I++) {
					ISOMCHANNEL *CH = GF_LIST_GET(READ->CHANNELS, I);
					GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[ISOMEDIA] REFRESH TRACK %D FRAGMENT - CUR SAMPLE %D - NEW SAMPLE COUNT %D\N", CH->TRACK, CH->SAMPLE_NUM, GF_ISOM_GET_SAMPLE_COUNT(CH->OWNER->MOV, CH->TRACK) ));
				}
			}
#ENDIF
			ISOR_CHECK_PRODUCER_REF_TIME(READ);
			IF (!READ->FRAG_TYPE)
				READ->REFRESH_FRAGMENTED = GF_FALSE;
		}
	}

	FOR (I=0; I<COUNT; I++) {
		U8 *DATA;
		U32 NB_PCK=50;
		ISOMCHANNEL *CH;
		CH = GF_LIST_GET(READ->CHANNELS, I);
		IF (!CH->PLAYING) {
			NB_FORCED_END++;
			CONTINUE;
		}
		//EOS NOT SENT ON THIS CHANNEL, WE ARE ACTIVE
		IF (!CH->EOS_SENT)
			IS_ACTIVE = GF_TRUE;

		WHILE (NB_PCK) {
			CH->SAMPLE_DATA_OFFSET = 0;
			IF (!READ->FULL_SEGMENT_FLUSH && GF_FILTER_PID_WOULD_BLOCK(CH->PID) )
				BREAK;

			IF (CH->ITEM_ID) {
				ISOR_READER_GET_SAMPLE_FROM_ITEM(CH);
			} ELSE {
				ISOR_READER_GET_SAMPLE(CH);
			}

			IF (READ->STSD && (CH->LAST_SAMPLE_DESC_INDEX != READ->STSD) && CH->SAMPLE) {
				ISOR_READER_RELEASE_SAMPLE(CH);
				CONTINUE;
			}
			IF (CH->SAMPLE) {
				U32 SAMPLE_DUR;
				U8 DEP_FLAGS;
				U8 *SUBS_BUF;
				U32 SUBS_BUF_SIZE;
				GF_FILTERPACKET *PCK;
				IF (CH->NEEDS_PID_RECONFIG) {
					ISOR_UPDATE_CHANNEL_CONFIG(CH);
					CH->NEEDS_PID_RECONFIG = GF_FALSE;
				}

				//WE HAVE AT LEAST TWO SAMPLES, UPDATE GF_PROP_PID_HAS_SYNC IF NEEDED
				IF (CH->CHECK_HAS_RAP && (GF_ISOM_GET_SAMPLE_COUNT(CH->OWNER->MOV, CH->TRACK)>1) && (GF_ISOM_HAS_SYNC_POINTS(CH->OWNER->MOV, CH->TRACK)==1)) {
					CH->CHECK_HAS_RAP = GF_FALSE;
					CH->HAS_RAP = GF_TRUE;
					GF_FILTER_PID_SET_PROPERTY(CH->PID, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(CH->HAS_RAP) );
				}

				//STRIP PARAM SETS FROM PAYLOAD, TRIGGER RECONFIG IF NEEDED
				ISOR_READER_CHECK_CONFIG(CH);

				IF (READ->NODATA) {
					PCK = GF_FILTER_PCK_NEW_SHARED(CH->PID, NULL, CH->SAMPLE->DATALENGTH, NULL);
					IF (!PCK) RETURN GF_OUT_OF_MEM;
				} ELSE {
					PCK = GF_FILTER_PCK_NEW_ALLOC(CH->PID, CH->SAMPLE->DATALENGTH, &DATA);
					IF (!PCK) RETURN GF_OUT_OF_MEM;

					MEMCPY(DATA, CH->SAMPLE->DATA, CH->SAMPLE->DATALENGTH);
				}
				GF_FILTER_PCK_SET_DTS(PCK, CH->DTS);
				GF_FILTER_PCK_SET_CTS(PCK, CH->CTS);
				IF (CH->SAMPLE->ISRAP==-1) {
					GF_FILTER_PCK_SET_SAP(PCK, GF_FILTER_SAP_1);
					CH->REDUNDANT = 1;
				} ELSE {
					GF_FILTER_PCK_SET_SAP(PCK, (GF_FILTERSAPTYPE) CH->SAMPLE->ISRAP);
				}

				IF (CH->SAP_3)
					GF_FILTER_PCK_SET_SAP(PCK, GF_FILTER_SAP_3);
				ELSE IF (CH->SAP_4_TYPE) {
					GF_FILTER_PCK_SET_SAP(PCK, (CH->SAP_4_TYPE==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);
					GF_FILTER_PCK_SET_ROLL_INFO(PCK, CH->ROLL);
				}

				SAMPLE_DUR = CH->AU_DURATION;
				IF (CH->SAMPLE->NB_PACK)
					SAMPLE_DUR *= CH->SAMPLE->NB_PACK;
				GF_FILTER_PCK_SET_DURATION(PCK, SAMPLE_DUR);
				GF_FILTER_PCK_SET_SEEK_FLAG(PCK, CH->SEEK_FLAG);

				//FOR NOW WE ONLY SIGNAL XPS MASK FOR NON-SAP
				IF (CH->XPS_MASK && !GF_FILTER_PCK_GET_SAP(PCK) ) {
					GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_XPS_MASK, &PROP_UINT(CH->XPS_MASK) );
				}

				DEP_FLAGS = CH->ISLEADING;
				DEP_FLAGS <<= 2;
				DEP_FLAGS |= CH->DEPENDSON;
				DEP_FLAGS <<= 2;
				DEP_FLAGS |= CH->DEPENDEDON;
				DEP_FLAGS <<= 2;
				DEP_FLAGS |= CH->REDUNDANT;

				IF (DEP_FLAGS)
					GF_FILTER_PCK_SET_DEPENDENCY_FLAGS(PCK, DEP_FLAGS);

				GF_FILTER_PCK_SET_CRYPT_FLAGS(PCK, CH->PCK_ENCRYPTED ? GF_FILTER_PCK_CRYPT : 0);
				GF_FILTER_PCK_SET_SEQ_NUM(PCK, CH->SAMPLE_NUM);


				SUBS_BUF = GF_ISOM_SAMPLE_GET_SUBSAMPLES_BUFFER(READ->MOV, CH->TRACK, CH->SAMPLE_NUM, &SUBS_BUF_SIZE);
				IF (SUBS_BUF) {
					GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(SUBS_BUF, SUBS_BUF_SIZE) );
				}

				IF (CH->SAI_BUFFER && CH->PCK_ENCRYPTED) {
					ASSERT(CH->SAI_BUFFER_SIZE);
					GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_CENC_SAI, &PROP_DATA(CH->SAI_BUFFER, CH->SAI_BUFFER_SIZE) );
				}

				IF (READ->SIGFRAG) {
					GF_ISOFRAGMENTBOUNDARYINFO FINFO;
					IF (GF_ISOM_SAMPLE_IS_FRAGMENT_START(READ->MOV, CH->TRACK, CH->SAMPLE_NUM, &FINFO) ) {
						U64 START=0;
						U32 TRAF_START = FINFO.SEG_START_PLUS_ONE ? 2 : 1;

						IF (FINFO.SEG_START_PLUS_ONE)
							GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));

						GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_FRAG_START, &PROP_UINT(TRAF_START));

						START = FINFO.FRAG_START;
						IF (FINFO.SEG_START_PLUS_ONE) START = FINFO.SEG_START_PLUS_ONE-1;
						GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(START, FINFO.MDAT_END));
						IF (FINFO.MOOF_TEMPLATE) {
							GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((U8 *)FINFO.MOOF_TEMPLATE, FINFO.MOOF_TEMPLATE_SIZE));
						}
						IF (FINFO.SIDX_END) {
							GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(FINFO.SIDX_START , FINFO.SIDX_END));
						}

						IF (READ->SEG_NAME_CHANGED) {
							CONST GF_PROPERTYVALUE *P = GF_FILTER_PID_GET_PROPERTY(READ->PID, GF_PROP_PID_URL);
							READ->SEG_NAME_CHANGED = GF_FALSE;
							IF (P && P->VALUE.STRING) {
								GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PID_URL, &PROP_STRING(P->VALUE.STRING));
							}
						}
					}
				}
				IF (CH->SENDER_NTP) {
					GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(CH->SENDER_NTP));
					IF (CH->NTP_AT_SERVER_NTP) {
						GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(CH->NTP_AT_SERVER_NTP));
					}
				}
				CH->EOS_SENT = GF_FALSE;

				//THIS MIGHT NOT BE THE TRUE END OF STREAM
				IF ((CH->STREAMTYPE==GF_STREAM_AUDIO) && (CH->SAMPLE_NUM == GF_ISOM_GET_SAMPLE_COUNT(READ->MOV, CH->TRACK))) {
					GF_FILTER_PCK_SET_PROPERTY(PCK, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));
				}

				GF_FILTER_PCK_SEND(PCK);
				ISOR_READER_RELEASE_SAMPLE(CH);

				CH->LAST_VALID_SAMPLE_DATA_OFFSET = CH->SAMPLE_DATA_OFFSET;
				NB_PCK--;
			} ELSE IF (CH->LAST_STATE==GF_EOS) {
				IF (CH->PLAYING == 2) {
					IF (IN_IS_EOS) {
						CH->PLAYING = GF_FALSE;
					} ELSE {
						NB_FORCED_END++;
						CHECK_FORCED_END = GF_TRUE;
					}
				}
				IF (IN_IS_EOS && !CH->EOS_SENT) {
					VOID *TFRF;
					CONST VOID *GF_ISOM_GET_TFRF(GF_ISOFILE *MOVIE, U32 TRACKNUMBER);

					CH->EOS_SENT = GF_TRUE;
					READ->EOS_SIGNALED = GF_TRUE;

					TFRF = (VOID *) GF_ISOM_GET_TFRF(READ->MOV, CH->TRACK);
					IF (TFRF) {
						GF_FILTER_PID_SET_INFO_STR(CH->PID, "SMOOTH_TFRF", &PROP_POINTER(TFRF) );
						CH->LAST_HAS_TFRF = GF_TRUE;
					} ELSE IF (CH->LAST_HAS_TFRF) {
						GF_FILTER_PID_SET_INFO_STR(CH->PID, "SMOOTH_TFRF", NULL);
						CH->LAST_HAS_TFRF = GF_FALSE;
					}

					GF_FILTER_PID_SET_EOS(CH->PID);
				}
				BREAK;
			} ELSE {
				READ->FORCE_FETCH = GF_TRUE;
				BREAK;
			}
		}
		IF (!MIN_OFFSET_PLUS_ONE || (MIN_OFFSET_PLUS_ONE - 1 > CH->LAST_VALID_SAMPLE_DATA_OFFSET))
			MIN_OFFSET_PLUS_ONE = 1 + CH->LAST_VALID_SAMPLE_DATA_OFFSET;
	}
	IF (READ->MEM_LOAD_MODE && MIN_OFFSET_PLUS_ONE) {
		ISOFFIN_PURGE_MEM(READ, MIN_OFFSET_PLUS_ONE-1);
	}

	//WE REACHED END OF PLAYBACK DUE TO PLAY RANGE REQUEST, WE MUST SEND EOS - HOWEVER FOR SAFETY REASON WITH DASH, WE FIRST NEED TO CANCEL THE INPUT
	IF (READ->PID && CHECK_FORCED_END && (NB_FORCED_END==COUNT)) {
		//ABORT INPUT
		GF_FILTEREVENT EVT;
		GF_FEVT_INIT(EVT, GF_FEVT_STOP, READ->PID);
		GF_FILTER_PID_SEND_EVENT(READ->PID, &EVT);
	}


	IF (!IS_ACTIVE) {
		RETURN GF_EOS;
	}
	//IF (IN_IS_EOS)
//	GF_FILTER_ASK_RT_RESCHEDULE(FILTER, 1);
	RETURN GF_OK;

}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206588_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDIMAGEFILLTOBORDER (GDIMAGEPTR IM, INT X, INT Y, INT BORDER, INT COLOR)
{
  INT LASTBORDER;
  /* SEEK LEFT */
  INT LEFTLIMIT, RIGHTLIMIT;
  INT I;
  LEFTLIMIT = (-1);
  IF (BORDER < 0)
    {
      /* REFUSE TO FILL TO A NON-SOLID BORDER */
      RETURN;
    }
  FOR (I = X; (I >= 0); I--)
    {
      IF (GDIMAGEGETPIXEL (IM, I, Y) == BORDER)
	{
	  BREAK;
	}
      GDIMAGESETPIXEL (IM, I, Y, COLOR);
      LEFTLIMIT = I;
    }
  IF (LEFTLIMIT == (-1))
    {
      RETURN;
    }
  /* SEEK RIGHT */
  RIGHTLIMIT = X;
  FOR (I = (X + 1); (I < IM->SX); I++)
    {
      IF (GDIMAGEGETPIXEL (IM, I, Y) == BORDER)
	{
	  BREAK;
	}
      GDIMAGESETPIXEL (IM, I, Y, COLOR);
      RIGHTLIMIT = I;
    }
  /* LOOK AT LINES ABOVE AND BELOW AND START PAINTS */
  /* ABOVE */
  IF (Y > 0)
    {
      LASTBORDER = 1;
      FOR (I = LEFTLIMIT; (I <= RIGHTLIMIT); I++)
	{
	  INT C;
	  C = GDIMAGEGETPIXEL (IM, I, Y - 1);
	  IF (LASTBORDER)
	    {
	      IF ((C != BORDER) && (C != COLOR))
		{
		  GDIMAGEFILLTOBORDER (IM, I, Y - 1,
				       BORDER, COLOR);
		  LASTBORDER = 0;
		}
	    }
	  ELSE IF ((C == BORDER) || (C == COLOR))
	    {
	      LASTBORDER = 1;
	    }
	}
    }
  /* BELOW */
  IF (Y < ((IM->SY) - 1))
    {
      LASTBORDER = 1;
      FOR (I = LEFTLIMIT; (I <= RIGHTLIMIT); I++)
	{
	  INT C;
	  C = GDIMAGEGETPIXEL (IM, I, Y + 1);
	  IF (LASTBORDER)
	    {
	      IF ((C != BORDER) && (C != COLOR))
		{
		  GDIMAGEFILLTOBORDER (IM, I, Y + 1,
				       BORDER, COLOR);
		  LASTBORDER = 0;
		}
	    }
	  ELSE IF ((C == BORDER) || (C == COLOR))
	    {
	      LASTBORDER = 1;
	    }
	}
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209802_CWE-122.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_ADDRESS(
    EXARG_T	*EAP UNUSED,
    CHAR_U	**PTR,
    CMD_ADDR_T	ADDR_TYPE,
    INT		SKIP,		// ONLY SKIP THE ADDRESS, DON'T USE IT
    INT		SILENT,		// NO ERRORS OR SIDE EFFECTS
    INT		TO_OTHER_FILE,  // FLAG: MAY JUMP TO OTHER FILE
    INT		ADDRESS_COUNT UNUSED) // 1 FOR FIRST ADDRESS, >1 AFTER COMMA
{
    INT		C;
    INT		I;
    LONG	N;
    CHAR_U	*CMD;
    POS_T	POS;
    POS_T	*FP;
    LINENR_T	LNUM;
    BUF_T	*BUF;

    CMD = SKIPWHITE(*PTR);
    LNUM = MAXLNUM;
    DO
    {
	SWITCH (*CMD)
	{
	    CASE '.':			    // '.' - CURSOR POSITION
		++CMD;
		SWITCH (ADDR_TYPE)
		{
		    CASE ADDR_LINES:
		    CASE ADDR_OTHER:
			LNUM = CURWIN->W_CURSOR.LNUM;
			BREAK;
		    CASE ADDR_WINDOWS:
			LNUM = CURRENT_WIN_NR;
			BREAK;
		    CASE ADDR_ARGUMENTS:
			LNUM = CURWIN->W_ARG_IDX + 1;
			BREAK;
		    CASE ADDR_LOADED_BUFFERS:
		    CASE ADDR_BUFFERS:
			LNUM = CURBUF->B_FNUM;
			BREAK;
		    CASE ADDR_TABS:
			LNUM = CURRENT_TAB_NR;
			BREAK;
		    CASE ADDR_NONE:
		    CASE ADDR_TABS_RELATIVE:
		    CASE ADDR_UNSIGNED:
			ADDR_ERROR(ADDR_TYPE);
			CMD = NULL;
			GOTO ERROR;
			BREAK;
		    CASE ADDR_QUICKFIX:
#IFDEF FEAT_QUICKFIX
			LNUM = QF_GET_CUR_IDX(EAP);
#ENDIF
			BREAK;
		    CASE ADDR_QUICKFIX_VALID:
#IFDEF FEAT_QUICKFIX
			LNUM = QF_GET_CUR_VALID_IDX(EAP);
#ENDIF
			BREAK;
		}
		BREAK;

	    CASE '$':			    // '$' - LAST LINE
		++CMD;
		SWITCH (ADDR_TYPE)
		{
		    CASE ADDR_LINES:
		    CASE ADDR_OTHER:
			LNUM = CURBUF->B_ML.ML_LINE_COUNT;
			BREAK;
		    CASE ADDR_WINDOWS:
			LNUM = LAST_WIN_NR;
			BREAK;
		    CASE ADDR_ARGUMENTS:
			LNUM = ARGCOUNT;
			BREAK;
		    CASE ADDR_LOADED_BUFFERS:
			BUF = LASTBUF;
			WHILE (BUF->B_ML.ML_MFP == NULL)
			{
			    IF (BUF->B_PREV == NULL)
				BREAK;
			    BUF = BUF->B_PREV;
			}
			LNUM = BUF->B_FNUM;
			BREAK;
		    CASE ADDR_BUFFERS:
			LNUM = LASTBUF->B_FNUM;
			BREAK;
		    CASE ADDR_TABS:
			LNUM = LAST_TAB_NR;
			BREAK;
		    CASE ADDR_NONE:
		    CASE ADDR_TABS_RELATIVE:
		    CASE ADDR_UNSIGNED:
			ADDR_ERROR(ADDR_TYPE);
			CMD = NULL;
			GOTO ERROR;
			BREAK;
		    CASE ADDR_QUICKFIX:
#IFDEF FEAT_QUICKFIX
			LNUM = QF_GET_SIZE(EAP);
			IF (LNUM == 0)
			    LNUM = 1;
#ENDIF
			BREAK;
		    CASE ADDR_QUICKFIX_VALID:
#IFDEF FEAT_QUICKFIX
			LNUM = QF_GET_VALID_SIZE(EAP);
			IF (LNUM == 0)
			    LNUM = 1;
#ENDIF
			BREAK;
		}
		BREAK;

	    CASE '\'':			    // ''' - MARK
		IF (*++CMD == NUL)
		{
		    CMD = NULL;
		    GOTO ERROR;
		}
		IF (ADDR_TYPE != ADDR_LINES)
		{
		    ADDR_ERROR(ADDR_TYPE);
		    CMD = NULL;
		    GOTO ERROR;
		}
		IF (SKIP)
		    ++CMD;
		ELSE
		{
		    // ONLY ACCEPT A MARK IN ANOTHER FILE WHEN IT IS
		    // USED BY ITSELF: ":'M".
		    FP = GETMARK(*CMD, TO_OTHER_FILE && CMD[1] == NUL);
		    ++CMD;
		    IF (FP == (POS_T *)-1)
			// JUMPED TO ANOTHER FILE.
			LNUM = CURWIN->W_CURSOR.LNUM;
		    ELSE
		    {
			IF (CHECK_MARK(FP) == FAIL)
			{
			    CMD = NULL;
			    GOTO ERROR;
			}
			LNUM = FP->LNUM;
		    }
		}
		BREAK;

	    CASE '/':
	    CASE '?':			// '/' OR '?' - SEARCH
		C = *CMD++;
		IF (ADDR_TYPE != ADDR_LINES)
		{
		    ADDR_ERROR(ADDR_TYPE);
		    CMD = NULL;
		    GOTO ERROR;
		}
		IF (SKIP)	// SKIP "/PAT/"
		{
		    CMD = SKIP_REGEXP(CMD, C, MAGIC_ISSET());
		    IF (*CMD == C)
			++CMD;
		}
		ELSE
		{
		    INT FLAGS;

		    POS = CURWIN->W_CURSOR; // SAVE CURWIN->W_CURSOR

		    // WHEN '/' OR '?' FOLLOWS ANOTHER ADDRESS, START FROM
		    // THERE.
		    IF (LNUM != MAXLNUM)
			CURWIN->W_CURSOR.LNUM = LNUM;

		    // START A FORWARD SEARCH AT THE END OF THE LINE (UNLESS
		    // BEFORE THE FIRST LINE).
		    // START A BACKWARD SEARCH AT THE START OF THE LINE.
		    // THIS MAKES SURE WE NEVER MATCH IN THE CURRENT
		    // LINE, AND CAN MATCH ANYWHERE IN THE
		    // NEXT/PREVIOUS LINE.
		    IF (C == '/' && CURWIN->W_CURSOR.LNUM > 0)
			CURWIN->W_CURSOR.COL = MAXCOL;
		    ELSE
			CURWIN->W_CURSOR.COL = 0;
		    SEARCHCMDLEN = 0;
		    FLAGS = SILENT ? 0 : SEARCH_HIS | SEARCH_MSG;
		    IF (!DO_SEARCH(NULL, C, C, CMD, 1L, FLAGS, NULL))
		    {
			CURWIN->W_CURSOR = POS;
			CMD = NULL;
			GOTO ERROR;
		    }
		    LNUM = CURWIN->W_CURSOR.LNUM;
		    CURWIN->W_CURSOR = POS;
		    // ADJUST COMMAND STRING POINTER
		    CMD += SEARCHCMDLEN;
		}
		BREAK;

	    CASE '\\':		    // "\?", "\/" OR "\&", REPEAT SEARCH
		++CMD;
		IF (ADDR_TYPE != ADDR_LINES)
		{
		    ADDR_ERROR(ADDR_TYPE);
		    CMD = NULL;
		    GOTO ERROR;
		}
		IF (*CMD == '&')
		    I = RE_SUBST;
		ELSE IF (*CMD == '?' || *CMD == '/')
		    I = RE_SEARCH;
		ELSE
		{
		    EMSG(_(E_BACKSLASH_SHOULD_BE_FOLLOWED_BY));
		    CMD = NULL;
		    GOTO ERROR;
		}

		IF (!SKIP)
		{
		    /*
		     * WHEN SEARCH FOLLOWS ANOTHER ADDRESS, START FROM
		     * THERE.
		     */
		    IF (LNUM != MAXLNUM)
			POS.LNUM = LNUM;
		    ELSE
			POS.LNUM = CURWIN->W_CURSOR.LNUM;

		    /*
		     * START THE SEARCH JUST LIKE FOR THE ABOVE
		     * DO_SEARCH().
		     */
		    IF (*CMD != '?')
			POS.COL = MAXCOL;
		    ELSE
			POS.COL = 0;
		    POS.COLADD = 0;
		    IF (SEARCHIT(CURWIN, CURBUF, &POS, NULL,
				*CMD == '?' ? BACKWARD : FORWARD,
				(CHAR_U *)"", 1L, SEARCH_MSG, I, NULL) != FAIL)
			LNUM = POS.LNUM;
		    ELSE
		    {
			CMD = NULL;
			GOTO ERROR;
		    }
		}
		++CMD;
		BREAK;

	    DEFAULT:
		IF (VIM_ISDIGIT(*CMD))	// ABSOLUTE LINE NUMBER
		    LNUM = GETDIGITS(&CMD);
	}

	FOR (;;)
	{
	    CMD = SKIPWHITE(CMD);
	    IF (*CMD != '-' && *CMD != '+' && !VIM_ISDIGIT(*CMD))
		BREAK;

	    IF (LNUM == MAXLNUM)
	    {
		SWITCH (ADDR_TYPE)
		{
		    CASE ADDR_LINES:
		    CASE ADDR_OTHER:
			// "+1" IS SAME AS ".+1"
			LNUM = CURWIN->W_CURSOR.LNUM;
			BREAK;
		    CASE ADDR_WINDOWS:
			LNUM = CURRENT_WIN_NR;
			BREAK;
		    CASE ADDR_ARGUMENTS:
			LNUM = CURWIN->W_ARG_IDX + 1;
			BREAK;
		    CASE ADDR_LOADED_BUFFERS:
		    CASE ADDR_BUFFERS:
			LNUM = CURBUF->B_FNUM;
			BREAK;
		    CASE ADDR_TABS:
			LNUM = CURRENT_TAB_NR;
			BREAK;
		    CASE ADDR_TABS_RELATIVE:
			LNUM = 1;
			BREAK;
		    CASE ADDR_QUICKFIX:
#IFDEF FEAT_QUICKFIX
			LNUM = QF_GET_CUR_IDX(EAP);
#ENDIF
			BREAK;
		    CASE ADDR_QUICKFIX_VALID:
#IFDEF FEAT_QUICKFIX
			LNUM = QF_GET_CUR_VALID_IDX(EAP);
#ENDIF
			BREAK;
		    CASE ADDR_NONE:
		    CASE ADDR_UNSIGNED:
			LNUM = 0;
			BREAK;
		}
	    }

	    IF (VIM_ISDIGIT(*CMD))
		I = '+';		// "NUMBER" IS SAME AS "+NUMBER"
	    ELSE
		I = *CMD++;
	    IF (!VIM_ISDIGIT(*CMD))	// '+' IS '+1', BUT '+0' IS NOT '+1'
		N = 1;
	    ELSE
		N = GETDIGITS(&CMD);

	    IF (ADDR_TYPE == ADDR_TABS_RELATIVE)
	    {
		EMSG(_(E_INVALID_RANGE));
		CMD = NULL;
		GOTO ERROR;
	    }
	    ELSE IF (ADDR_TYPE == ADDR_LOADED_BUFFERS
		    || ADDR_TYPE == ADDR_BUFFERS)
		LNUM = COMPUTE_BUFFER_LOCAL_COUNT(
				    ADDR_TYPE, LNUM, (I == '-') ? -1 * N : N);
	    ELSE
	    {
#IFDEF FEAT_FOLDING
		// RELATIVE LINE ADDRESSING, NEED TO ADJUST FOR FOLDED LINES
		// NOW, BUT ONLY DO IT AFTER THE FIRST ADDRESS.
		IF (ADDR_TYPE == ADDR_LINES && (I == '-' || I == '+')
			&& ADDRESS_COUNT >= 2)
		    (VOID)HASFOLDING(LNUM, NULL, &LNUM);
#ENDIF
		IF (I == '-')
		    LNUM -= N;
		ELSE
		    LNUM += N;
	    }
	}
    } WHILE (*CMD == '/' || *CMD == '?');

ERROR:
    *PTR = CMD;
    RETURN LNUM;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210283_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VHOST_USER_SET_INFLIGHT_FD(STRUCT VIRTIO_NET **PDEV,
			   STRUCT VHU_MSG_CONTEXT *CTX,
			   INT MAIN_FD __RTE_UNUSED)
{
	UINT64_T MMAP_SIZE, MMAP_OFFSET;
	UINT16_T NUM_QUEUES, QUEUE_SIZE;
	STRUCT VIRTIO_NET *DEV = *PDEV;
	UINT32_T PERVQ_INFLIGHT_SIZE;
	STRUCT VHOST_VIRTQUEUE *VQ;
	VOID *ADDR;
	INT FD, I;
	INT NUMA_NODE = SOCKET_ID_ANY;

	FD = CTX->FDS[0];
	IF (CTX->MSG.SIZE != SIZEOF(CTX->MSG.PAYLOAD.INFLIGHT) || FD < 0) {
		VHOST_LOG_CONFIG(ERR, "(%S) INVALID SET_INFLIGHT_FD MESSAGE SIZE IS %D,FD IS %D\N",
			DEV->IFNAME, CTX->MSG.SIZE, FD);
		RETURN RTE_VHOST_MSG_RESULT_ERR;
	}

	MMAP_SIZE = CTX->MSG.PAYLOAD.INFLIGHT.MMAP_SIZE;
	MMAP_OFFSET = CTX->MSG.PAYLOAD.INFLIGHT.MMAP_OFFSET;
	NUM_QUEUES = CTX->MSG.PAYLOAD.INFLIGHT.NUM_QUEUES;
	QUEUE_SIZE = CTX->MSG.PAYLOAD.INFLIGHT.QUEUE_SIZE;

	IF (VQ_IS_PACKED(DEV))
		PERVQ_INFLIGHT_SIZE = GET_PERVQ_SHM_SIZE_PACKED(QUEUE_SIZE);
	ELSE
		PERVQ_INFLIGHT_SIZE = GET_PERVQ_SHM_SIZE_SPLIT(QUEUE_SIZE);

	VHOST_LOG_CONFIG(INFO, "(%S) SET_INFLIGHT_FD MMAP_SIZE: %"PRIU64"\N",
			DEV->IFNAME, MMAP_SIZE);
	VHOST_LOG_CONFIG(INFO, "(%S) SET_INFLIGHT_FD MMAP_OFFSET: %"PRIU64"\N",
			DEV->IFNAME, MMAP_OFFSET);
	VHOST_LOG_CONFIG(INFO, "(%S) SET_INFLIGHT_FD NUM_QUEUES: %U\N", DEV->IFNAME, NUM_QUEUES);
	VHOST_LOG_CONFIG(INFO, "(%S) SET_INFLIGHT_FD QUEUE_SIZE: %U\N", DEV->IFNAME, QUEUE_SIZE);
	VHOST_LOG_CONFIG(INFO, "(%S) SET_INFLIGHT_FD FD: %D\N", DEV->IFNAME, FD);
	VHOST_LOG_CONFIG(INFO, "(%S) SET_INFLIGHT_FD PERVQ_INFLIGHT_SIZE: %D\N",
			DEV->IFNAME, PERVQ_INFLIGHT_SIZE);

	/*
	 * IF VQ 0 HAS ALREADY BEEN ALLOCATED, TRY TO ALLOCATE ON THE SAME
	 * NUMA NODE. IT CAN BE REALLOCATED LATER IN NUMA_REALLOC().
	 */
	IF (DEV->NR_VRING > 0)
		NUMA_NODE = DEV->VIRTQUEUE[0]->NUMA_NODE;

	IF (!DEV->INFLIGHT_INFO) {
		DEV->INFLIGHT_INFO = RTE_ZMALLOC_SOCKET("INFLIGHT_INFO",
				SIZEOF(STRUCT INFLIGHT_MEM_INFO), 0, NUMA_NODE);
		IF (DEV->INFLIGHT_INFO == NULL) {
			VHOST_LOG_CONFIG(ERR, "(%S) FAILED TO ALLOC DEV INFLIGHT AREA\N",
					DEV->IFNAME);
			RETURN RTE_VHOST_MSG_RESULT_ERR;
		}
		DEV->INFLIGHT_INFO->FD = -1;
	}

	IF (DEV->INFLIGHT_INFO->ADDR) {
		MUNMAP(DEV->INFLIGHT_INFO->ADDR, DEV->INFLIGHT_INFO->SIZE);
		DEV->INFLIGHT_INFO->ADDR = NULL;
	}

	ADDR = MMAP(0, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,
		    FD, MMAP_OFFSET);
	IF (ADDR == MAP_FAILED) {
		VHOST_LOG_CONFIG(ERR, "(%S) FAILED TO MMAP SHARE MEMORY.\N", DEV->IFNAME);
		RETURN RTE_VHOST_MSG_RESULT_ERR;
	}

	IF (DEV->INFLIGHT_INFO->FD >= 0) {
		CLOSE(DEV->INFLIGHT_INFO->FD);
		DEV->INFLIGHT_INFO->FD = -1;
	}

	DEV->INFLIGHT_INFO->FD = FD;
	DEV->INFLIGHT_INFO->ADDR = ADDR;
	DEV->INFLIGHT_INFO->SIZE = MMAP_SIZE;

	FOR (I = 0; I < NUM_QUEUES; I++) {
		VQ = DEV->VIRTQUEUE[I];
		IF (!VQ)
			CONTINUE;

		IF (VQ_IS_PACKED(DEV)) {
			VQ->INFLIGHT_PACKED = ADDR;
			VQ->INFLIGHT_PACKED->DESC_NUM = QUEUE_SIZE;
		} ELSE {
			VQ->INFLIGHT_SPLIT = ADDR;
			VQ->INFLIGHT_SPLIT->DESC_NUM = QUEUE_SIZE;
		}
		ADDR = (VOID *)((CHAR *)ADDR + PERVQ_INFLIGHT_SIZE);
	}

	RETURN RTE_VHOST_MSG_RESULT_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215122_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GETVCOL(
    WIN_T	*WP,
    POS_T	*POS,
    COLNR_T	*START,
    COLNR_T	*CURSOR,
    COLNR_T	*END)
{
    COLNR_T	VCOL;
    CHAR_U	*PTR;		// POINTS TO CURRENT CHAR
    CHAR_U	*POSPTR;	// POINTS TO CHAR AT POS->COL
    CHAR_U	*LINE;		// START OF THE LINE
    INT		INCR;
    INT		HEAD;
#IFDEF FEAT_VARTABS
    INT		*VTS = WP->W_BUFFER->B_P_VTS_ARRAY;
#ENDIF
    INT		TS = WP->W_BUFFER->B_P_TS;
    INT		C;

    VCOL = 0;
    LINE = PTR = ML_GET_BUF(WP->W_BUFFER, POS->LNUM, FALSE);
    IF (POS->COL == MAXCOL)
	POSPTR = NULL;  // CONTINUE UNTIL THE NUL
    ELSE
    {
	// SPECIAL CHECK FOR AN EMPTY LINE, WHICH CAN HAPPEN ON EXIT, WHEN
	// ML_GET_BUF() ALWAYS RETURNS AN EMPTY STRING.
	IF (*PTR == NUL)
	    POS->COL = 0;
	POSPTR = PTR + POS->COL;
	IF (HAS_MBYTE)
	    // ALWAYS START ON THE FIRST BYTE
	    POSPTR -= (*MB_HEAD_OFF)(LINE, POSPTR);
    }

    /*
     * THIS FUNCTION IS USED VERY OFTEN, DO SOME SPEED OPTIMIZATIONS.
     * WHEN 'LIST', 'LINEBREAK', 'SHOWBREAK' AND 'BREAKINDENT' ARE NOT SET
     * USE A SIMPLE LOOP.
     * ALSO USE THIS WHEN 'LIST' IS SET BUT TABS TAKE THEIR NORMAL SIZE.
     */
    IF ((!WP->W_P_LIST || WP->W_LCS_CHARS.TAB1 != NUL)
#IFDEF FEAT_LINEBREAK
	    && !WP->W_P_LBR && *GET_SHOWBREAK_VALUE(WP) == NUL && !WP->W_P_BRI
#ENDIF
       )
    {
	FOR (;;)
	{
	    HEAD = 0;
	    C = *PTR;
	    // MAKE SURE WE DON'T GO PAST THE END OF THE LINE
	    IF (C == NUL)
	    {
		INCR = 1;	// NUL AT END OF LINE ONLY TAKES ONE COLUMN
		BREAK;
	    }
	    // A TAB GETS EXPANDED, DEPENDING ON THE CURRENT COLUMN
	    IF (C == TAB)
#IFDEF FEAT_VARTABS
		INCR = TABSTOP_PADDING(VCOL, TS, VTS);
#ELSE
		INCR = TS - (VCOL % TS);
#ENDIF
	    ELSE
	    {
		IF (HAS_MBYTE)
		{
		    // FOR UTF-8, IF THE BYTE IS >= 0X80, NEED TO LOOK AT
		    // FURTHER BYTES TO FIND THE CELL WIDTH.
		    IF (ENC_UTF8 && C >= 0X80)
			INCR = UTF_PTR2CELLS(PTR);
		    ELSE
			INCR = G_CHARTAB[C] & CT_CELL_MASK;

		    // IF A DOUBLE-CELL CHAR DOESN'T FIT AT THE END OF A LINE
		    // IT WRAPS TO THE NEXT LINE, IT'S LIKE THIS CHAR IS THREE
		    // CELLS WIDE.
		    IF (INCR == 2 && WP->W_P_WRAP && MB_BYTE2LEN(*PTR) > 1
			    && IN_WIN_BORDER(WP, VCOL))
		    {
			++INCR;
			HEAD = 1;
		    }
		}
		ELSE
		    INCR = G_CHARTAB[C] & CT_CELL_MASK;
	    }

	    IF (POSPTR != NULL && PTR >= POSPTR) // CHARACTER AT POS->COL
		BREAK;

	    VCOL += INCR;
	    MB_PTR_ADV(PTR);
	}
    }
    ELSE
    {
	FOR (;;)
	{
	    // A TAB GETS EXPANDED, DEPENDING ON THE CURRENT COLUMN
	    HEAD = 0;
	    INCR = WIN_LBR_CHARTABSIZE(WP, LINE, PTR, VCOL, &HEAD);
	    // MAKE SURE WE DON'T GO PAST THE END OF THE LINE
	    IF (*PTR == NUL)
	    {
		INCR = 1;	// NUL AT END OF LINE ONLY TAKES ONE COLUMN
		BREAK;
	    }

	    IF (POSPTR != NULL && PTR >= POSPTR) // CHARACTER AT POS->COL
		BREAK;

	    VCOL += INCR;
	    MB_PTR_ADV(PTR);
	}
    }
    IF (START != NULL)
	*START = VCOL + HEAD;
    IF (END != NULL)
	*END = VCOL + INCR - 1;
    IF (CURSOR != NULL)
    {
	IF (*PTR == TAB
		&& (STATE & NORMAL)
		&& !WP->W_P_LIST
		&& !VIRTUAL_ACTIVE()
		&& !(VISUAL_ACTIVE
				&& (*P_SEL == 'E' || LTOREQ_POS(*POS, VISUAL)))
		)
	    *CURSOR = VCOL + INCR - 1;	    // CURSOR AT END
	ELSE
	    *CURSOR = VCOL + HEAD;	    // CURSOR AT START
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462411_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CREATEINSTANCE(INSTANCECONF_T **PINST)
{
	INSTANCECONF_T *INST;
	DEFIRET;
	CHKMALLOC(INST = MALLOC(SIZEOF(INSTANCECONF_T)));
	INST->NEXT = NULL;

	INST->PSZBINDPORT = NULL;
	INST->PSZBINDADDR = NULL;
	INST->PSZBINDPATH = NULL;
	INST->FILEUID = -1;
	INST->FILEGID = -1;
	INST->FCREATEMODE = 0644;
	INST->BFAILONPERMS = 1;
	INST->BUNLINK = 0;
	INST->PSZBINDRULESET = NULL;
	INST->PSZINPUTNAME = NULL;
	INST->BSUPPOCTETFRAM = 1;
	INST->BSPFRAMINGFIX = 0;
	INST->BKEEPALIVE = 0;
	INST->IKEEPALIVEINTVL = 0;
	INST->IKEEPALIVEPROBES = 0;
	INST->IKEEPALIVETIME = 0;
	INST->BEMITMSGONCLOSE = 0;
	INST->DFLTTZ = NULL;
	INST->IADDTLFRAMEDELIM = TCPSRV_NO_ADDTL_DELIMITER;
	INST->PBINDRULESET = NULL;
	INST->RATELIMITBURST = 10000; /* ARBITRARY HIGH LIMIT */
	INST->RATELIMITINTERVAL = 0; /* OFF */
	INST->COMPRESSIONMODE = COMPRESS_SINGLE_MSG;

	/* NODE CREATED, LET'S ADD TO CONFIG */
	IF(LOADMODCONF->TAIL == NULL) {
		LOADMODCONF->TAIL = LOADMODCONF->ROOT = INST;
	} ELSE {
		LOADMODCONF->TAIL->NEXT = INST;
		LOADMODCONF->TAIL = INST;
	}

	*PINST = INST;
FINALIZE_IT:
	RETIRET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 513179_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CHECK_FUNC_LONGLONG(THD *THD, STRUCT ST_MYSQL_SYS_VAR *VAR,
                               VOID *SAVE, ST_MYSQL_VALUE *VALUE)
{
  MY_BOOL FIXED1, FIXED2;
  LONG LONG ORIG, VAL;
  STRUCT MY_OPTION OPTIONS;
  VALUE->VAL_INT(VALUE, &ORIG);
  VAL= ORIG;
  PLUGIN_OPT_SET_LIMITS(&OPTIONS, VAR);

  IF (VAR->FLAGS & PLUGIN_VAR_UNSIGNED)
  {
    IF ((FIXED1= (!VALUE->IS_UNSIGNED(VALUE) && VAL < 0)))
      VAL=0;
    *(ULONGLONG *)SAVE= GETOPT_ULL_LIMIT_VALUE((ULONGLONG) VAL, &OPTIONS,
                                               &FIXED2);
  }
  ELSE
  {
    IF ((FIXED1= (VALUE->IS_UNSIGNED(VALUE) && VAL < 0)))
      VAL=LONGLONG_MAX;
    *(LONGLONG *)SAVE= GETOPT_LL_LIMIT_VALUE(VAL, &OPTIONS, &FIXED2);
  }

  RETURN THROW_BOUNDS_WARNING(THD, VAR->NAME, FIXED1 || FIXED2,
                              VALUE->IS_UNSIGNED(VALUE), (LONGLONG) ORIG);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 313541_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID ROSE_REMOVE_NODE(STRUCT ROSE_NODE *ROSE_NODE)
{
	STRUCT ROSE_NODE *S;

	IF ((S = ROSE_NODE_LIST) == ROSE_NODE) {
		ROSE_NODE_LIST = ROSE_NODE->NEXT;
		KFREE(ROSE_NODE);
		RETURN;
	}

	WHILE (S != NULL && S->NEXT != NULL) {
		IF (S->NEXT == ROSE_NODE) {
			S->NEXT = ROSE_NODE->NEXT;
			KFREE(ROSE_NODE);
			RETURN;
		}

		S = S->NEXT;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294360_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
D_LITE_STEP(INT ARGC, VALUE *ARGV, VALUE SELF)
{
    VALUE LIMIT, STEP, DATE;
    INT C;

    RB_SCAN_ARGS(ARGC, ARGV, "11", &LIMIT, &STEP);

    IF (ARGC < 2)
	STEP = INT2FIX(1);

#IF 0
    IF (F_ZERO_P(STEP))
	RB_RAISE(RB_EARGERROR, "STEP CAN'T BE 0");
#ENDIF

    RETURN_ENUMERATOR(SELF, ARGC, ARGV);

    DATE = SELF;
    C = F_CMP(STEP, INT2FIX(0));
    IF (C < 0) {
	WHILE (FIX2INT(D_LITE_CMP(DATE, LIMIT)) >= 0) {
	    RB_YIELD(DATE);
	    DATE = D_LITE_PLUS(DATE, STEP);
	}
    }
    ELSE IF (C == 0) {
	WHILE (1)
	    RB_YIELD(DATE);
    }
    ELSE /* IF (C > 0) */ {
	WHILE (FIX2INT(D_LITE_CMP(DATE, LIMIT)) <= 0) {
	    RB_YIELD(DATE);
	    DATE = D_LITE_PLUS(DATE, STEP);
	}
    }
    RETURN SELF;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211785_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC JPC_ENC_CP_T *CP_CREATE(CONST CHAR *OPTSTR, JAS_IMAGE_T *IMAGE)
{
	JPC_ENC_CP_T *CP;
	JAS_TVPARSER_T *TVP;
	INT RET;
	INT NUMILYRRATES;
	DOUBLE *ILYRRATES;
	INT I;
	INT TAGID;
	JPC_ENC_TCP_T *TCP;
	JPC_ENC_TCCP_T *TCCP;
	JPC_ENC_CCP_T *CCP;
	UINT_FAST16_T RLVLNO;
	UINT_FAST16_T PRCWIDTHEXPN;
	UINT_FAST16_T PRCHEIGHTEXPN;
	BOOL ENABLEMCT;
	UINT_FAST32_T JP2OVERHEAD;
	UINT_FAST16_T LYRNO;
	UINT_FAST32_T HSTEPLCM;
	UINT_FAST32_T VSTEPLCM;
	BOOL MCTVALID;

	TVP = 0;
	CP = 0;
	ILYRRATES = 0;
	NUMILYRRATES = 0;

	IF (!(CP = JAS_MALLOC(SIZEOF(JPC_ENC_CP_T)))) {
		GOTO ERROR;
	}

	PRCWIDTHEXPN = 15;
	PRCHEIGHTEXPN = 15;
	ENABLEMCT = TRUE;
	JP2OVERHEAD = 0;

	CP->CCPS = 0;
	CP->DEBUG = 0;
	CP->IMGAREATLX = UINT_FAST32_MAX;
	CP->IMGAREATLY = UINT_FAST32_MAX;
	CP->REFGRDWIDTH = 0;
	CP->REFGRDHEIGHT = 0;
	CP->TILEGRDOFFX = UINT_FAST32_MAX;
	CP->TILEGRDOFFY = UINT_FAST32_MAX;
	CP->TILEWIDTH = 0;
	CP->TILEHEIGHT = 0;
	CP->NUMCMPTS = JAS_IMAGE_NUMCMPTS(IMAGE);

	HSTEPLCM = 1;
	VSTEPLCM = 1;
	FOR (UNSIGNED CMPTNO = 0; CMPTNO < JAS_IMAGE_NUMCMPTS(IMAGE); ++CMPTNO) {
		IF (JAS_IMAGE_CMPTBRX(IMAGE, CMPTNO) + JAS_IMAGE_CMPTHSTEP(IMAGE, CMPTNO) <=
		  JAS_IMAGE_BRX(IMAGE) || JAS_IMAGE_CMPTBRY(IMAGE, CMPTNO) +
		  JAS_IMAGE_CMPTVSTEP(IMAGE, CMPTNO) <= JAS_IMAGE_BRY(IMAGE)) {
			JAS_EPRINTF("UNSUPPORTED IMAGE TYPE\N");
			GOTO ERROR;
		}
		/* NOTE: WE OUGHT TO BE CALCULATING THE LCMS HERE.  FIX SOME DAY. */
		HSTEPLCM *= JAS_IMAGE_CMPTHSTEP(IMAGE, CMPTNO);
		VSTEPLCM *= JAS_IMAGE_CMPTVSTEP(IMAGE, CMPTNO);
	}

	IF (!(CP->CCPS = JAS_ALLOC2(CP->NUMCMPTS, SIZEOF(JPC_ENC_CCP_T)))) {
		GOTO ERROR;
	}
	UNSIGNED CMPTNO;
	FOR (CMPTNO = 0, CCP = CP->CCPS; CMPTNO < CP->NUMCMPTS; ++CMPTNO,
	  ++CCP) {
		CCP->SAMPGRDSTEPX = JAS_IMAGE_CMPTHSTEP(IMAGE, CMPTNO);
		CCP->SAMPGRDSTEPY = JAS_IMAGE_CMPTVSTEP(IMAGE, CMPTNO);
		/* XXX - THIS ISN'T QUITE CORRECT FOR MORE GENERAL IMAGE */
		CCP->SAMPGRDSUBSTEPX = 0;
		CCP->SAMPGRDSUBSTEPX = 0;
		CCP->PREC = JAS_IMAGE_CMPTPREC(IMAGE, CMPTNO);
		CCP->SGND = JAS_IMAGE_CMPTSGND(IMAGE, CMPTNO);
		CCP->NUMSTEPSIZES = 0;
		MEMSET(CCP->STEPSIZES, 0, SIZEOF(CCP->STEPSIZES));
	}

	CP->RAWSIZE = JAS_IMAGE_RAWSIZE(IMAGE);
	IF (CP->RAWSIZE == 0) {
		/* PREVENT DIVISION BY ZERO IN CP_CREATE() */
		GOTO ERROR;
	}
	CP->TOTALSIZE = UINT_FAST32_MAX;

	TCP = &CP->TCP;
	TCP->CSTY = 0;
	TCP->INTMODE = TRUE;
	TCP->PRG = JPC_COD_LRCPPRG;
	TCP->NUMLYRS = 1;
	TCP->ILYRRATES = 0;

	TCCP = &CP->TCCP;
	TCCP->CSTY = 0;
	TCCP->MAXRLVLS = 6;
	TCCP->CBLKWIDTHEXPN = 6;
	TCCP->CBLKHEIGHTEXPN = 6;
	TCCP->CBLKSTY = 0;
	TCCP->NUMGBITS = 2;

	IF (!(TVP = JAS_TVPARSER_CREATE(OPTSTR ? OPTSTR : ""))) {
		GOTO ERROR;
	}

	WHILE (!(RET = JAS_TVPARSER_NEXT(TVP))) {
		SWITCH (JAS_TAGINFO_NONULL(JAS_TAGINFOS_LOOKUP(ENCOPTS,
		  JAS_TVPARSER_GETTAG(TVP)))->ID) {
		CASE OPT_DEBUG:
			CP->DEBUG = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_IMGAREAOFFX:
			CP->IMGAREATLX = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_IMGAREAOFFY:
			CP->IMGAREATLY = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_TILEGRDOFFX:
			CP->TILEGRDOFFX = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_TILEGRDOFFY:
			CP->TILEGRDOFFY = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_TILEWIDTH:
			CP->TILEWIDTH = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_TILEHEIGHT:
			CP->TILEHEIGHT = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_PRCWIDTH:
			PRCWIDTHEXPN = JPC_FLOORLOG2(ATOI(JAS_TVPARSER_GETVAL(TVP)));
			BREAK;
		CASE OPT_PRCHEIGHT:
			PRCHEIGHTEXPN = JPC_FLOORLOG2(ATOI(JAS_TVPARSER_GETVAL(TVP)));
			BREAK;
		CASE OPT_CBLKWIDTH:
			TCCP->CBLKWIDTHEXPN =
			  JPC_FLOORLOG2(ATOI(JAS_TVPARSER_GETVAL(TVP)));
			BREAK;
		CASE OPT_CBLKHEIGHT:
			TCCP->CBLKHEIGHTEXPN =
			  JPC_FLOORLOG2(ATOI(JAS_TVPARSER_GETVAL(TVP)));
			BREAK;
		CASE OPT_MODE:
			IF ((TAGID = JAS_TAGINFO_NONULL(JAS_TAGINFOS_LOOKUP(MODETAB,
			  JAS_TVPARSER_GETVAL(TVP)))->ID) < 0) {
				JAS_EPRINTF("IGNORING INVALID MODE %S\N",
				  JAS_TVPARSER_GETVAL(TVP));
			} ELSE {
				TCP->INTMODE = (TAGID == MODE_INT);
			}
			BREAK;
		CASE OPT_PRG:
			IF ((TAGID = JAS_TAGINFO_NONULL(JAS_TAGINFOS_LOOKUP(PRGORDTAB,
			  JAS_TVPARSER_GETVAL(TVP)))->ID) < 0) {
				JAS_EPRINTF("IGNORING INVALID PROGRESSION ORDER %S\N",
				  JAS_TVPARSER_GETVAL(TVP));
			} ELSE {
				TCP->PRG = TAGID;
			}
			BREAK;
		CASE OPT_NOMCT:
			ENABLEMCT = FALSE;
			BREAK;
		CASE OPT_MAXRLVLS:
			TCCP->MAXRLVLS = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_SOP:
			CP->TCP.CSTY |= JPC_COD_SOP;
			BREAK;
		CASE OPT_EPH:
			CP->TCP.CSTY |= JPC_COD_EPH;
			BREAK;
		CASE OPT_LAZY:
			TCCP->CBLKSTY |= JPC_COX_LAZY;
			BREAK;
		CASE OPT_TERMALL:
			TCCP->CBLKSTY |= JPC_COX_TERMALL;
			BREAK;
		CASE OPT_SEGSYM:
			TCCP->CBLKSTY |= JPC_COX_SEGSYM;
			BREAK;
		CASE OPT_VCAUSAL:
			TCCP->CBLKSTY |= JPC_COX_VSC;
			BREAK;
		CASE OPT_RESET:
			TCCP->CBLKSTY |= JPC_COX_RESET;
			BREAK;
		CASE OPT_PTERM:
			TCCP->CBLKSTY |= JPC_COX_PTERM;
			BREAK;
		CASE OPT_NUMGBITS:
			CP->TCCP.NUMGBITS = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		CASE OPT_RATE:
			IF (RATESTRTOSIZE(JAS_TVPARSER_GETVAL(TVP), CP->RAWSIZE,
			  &CP->TOTALSIZE)) {
				JAS_EPRINTF("IGNORING BAD RATE SPECIFIER %S\N",
				  JAS_TVPARSER_GETVAL(TVP));
			}
			BREAK;
		CASE OPT_ILYRRATES:
			IF (JPC_ATOAF(JAS_TVPARSER_GETVAL(TVP), &NUMILYRRATES,
			  &ILYRRATES)) {
				JAS_EPRINTF("WARNING: INVALID INTERMEDIATE LAYER RATES SPECIFIER IGNORED (%S)\N",
				  JAS_TVPARSER_GETVAL(TVP));
			}
			BREAK;

		CASE OPT_JP2OVERHEAD:
			JP2OVERHEAD = ATOI(JAS_TVPARSER_GETVAL(TVP));
			BREAK;
		DEFAULT:
			JAS_EPRINTF("WARNING: IGNORING INVALID OPTION %S\N",
			 JAS_TVPARSER_GETTAG(TVP));
			BREAK;
		}
	}

	JAS_TVPARSER_DESTROY(TVP);
	TVP = 0;

	IF (CP->TOTALSIZE != UINT_FAST32_MAX) {
		CP->TOTALSIZE = (CP->TOTALSIZE > JP2OVERHEAD) ?
		  (CP->TOTALSIZE - JP2OVERHEAD) : 0;
	}

	IF (CP->IMGAREATLX == UINT_FAST32_MAX) {
		CP->IMGAREATLX = 0;
	} ELSE {
		IF (HSTEPLCM != 1) {
			JAS_EPRINTF("WARNING: OVERRIDING IMGAREATLX VALUE\N");
		}
		CP->IMGAREATLX *= HSTEPLCM;
	}
	IF (CP->IMGAREATLY == UINT_FAST32_MAX) {
		CP->IMGAREATLY = 0;
	} ELSE {
		IF (VSTEPLCM != 1) {
			JAS_EPRINTF("WARNING: OVERRIDING IMGAREATLY VALUE\N");
		}
		CP->IMGAREATLY *= VSTEPLCM;
	}
	CP->REFGRDWIDTH = CP->IMGAREATLX + JAS_IMAGE_WIDTH(IMAGE);
	CP->REFGRDHEIGHT = CP->IMGAREATLY + JAS_IMAGE_HEIGHT(IMAGE);
	IF (CP->TILEGRDOFFX == UINT_FAST32_MAX) {
		CP->TILEGRDOFFX = CP->IMGAREATLX;
	}
	IF (CP->TILEGRDOFFY == UINT_FAST32_MAX) {
		CP->TILEGRDOFFY = CP->IMGAREATLY;
	}
	IF (!CP->TILEWIDTH) {
		CP->TILEWIDTH = CP->REFGRDWIDTH - CP->TILEGRDOFFX;
	}
	IF (!CP->TILEHEIGHT) {
		CP->TILEHEIGHT = CP->REFGRDHEIGHT - CP->TILEGRDOFFY;
	}

	IF (CP->NUMCMPTS == 3) {
		MCTVALID = TRUE;
		FOR (CMPTNO = 0; CMPTNO < JAS_IMAGE_NUMCMPTS(IMAGE); ++CMPTNO) {
			IF (JAS_IMAGE_CMPTPREC(IMAGE, CMPTNO) != JAS_IMAGE_CMPTPREC(IMAGE, 0) ||
			  JAS_IMAGE_CMPTSGND(IMAGE, CMPTNO) != JAS_IMAGE_CMPTSGND(IMAGE, 0) ||
			  JAS_IMAGE_CMPTWIDTH(IMAGE, CMPTNO) != JAS_IMAGE_CMPTWIDTH(IMAGE, 0) ||
			  JAS_IMAGE_CMPTHEIGHT(IMAGE, CMPTNO) != JAS_IMAGE_CMPTHEIGHT(IMAGE, 0)) {
				MCTVALID = FALSE;
			}
		}
	} ELSE {
		MCTVALID = FALSE;
	}
	IF (MCTVALID && ENABLEMCT && JAS_CLRSPC_FAM(JAS_IMAGE_CLRSPC(IMAGE)) != JAS_CLRSPC_FAM_RGB) {
		JAS_EPRINTF("WARNING: COLOR SPACE APPARENTLY NOT RGB\N");
	}
	IF (MCTVALID && ENABLEMCT && JAS_CLRSPC_FAM(JAS_IMAGE_CLRSPC(IMAGE)) == JAS_CLRSPC_FAM_RGB) {
		TCP->MCTID = (TCP->INTMODE) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);
	} ELSE {
		TCP->MCTID = JPC_MCT_NONE;
	}
	TCCP->QMFBID = (TCP->INTMODE) ? (JPC_COX_RFT) : (JPC_COX_INS);

	FOR (RLVLNO = 0; RLVLNO < TCCP->MAXRLVLS; ++RLVLNO) {
		TCCP->PRCWIDTHEXPNS[RLVLNO] = PRCWIDTHEXPN;
		TCCP->PRCHEIGHTEXPNS[RLVLNO] = PRCHEIGHTEXPN;
	}
	IF (PRCWIDTHEXPN != 15 || PRCHEIGHTEXPN != 15) {
		TCCP->CSTY |= JPC_COX_PRT;
	}

	/* ENSURE THAT THE TILE WIDTH AND HEIGHT IS VALID. */
	IF (!CP->TILEWIDTH) {
		JAS_EPRINTF("INVALID TILE WIDTH %LU\N", (UNSIGNED LONG)
		  CP->TILEWIDTH);
		GOTO ERROR;
	}
	IF (!CP->TILEHEIGHT) {
		JAS_EPRINTF("INVALID TILE HEIGHT %LU\N", (UNSIGNED LONG)
		  CP->TILEHEIGHT);
		GOTO ERROR;
	}

	/* ENSURE THAT THE TILE GRID OFFSET IS VALID. */
	IF (CP->TILEGRDOFFX > CP->IMGAREATLX ||
	  CP->TILEGRDOFFY > CP->IMGAREATLY ||
	  CP->TILEGRDOFFX + CP->TILEWIDTH < CP->IMGAREATLX ||
	  CP->TILEGRDOFFY + CP->TILEHEIGHT < CP->IMGAREATLY) {
		JAS_EPRINTF("INVALID TILE GRID OFFSET (%LU, %LU)\N",
		  (UNSIGNED LONG) CP->TILEGRDOFFX, (UNSIGNED LONG)
		  CP->TILEGRDOFFY);
		GOTO ERROR;
	}

	CP->NUMHTILES = JPC_CEILDIV(CP->REFGRDWIDTH - CP->TILEGRDOFFX,
	  CP->TILEWIDTH);
	CP->NUMVTILES = JPC_CEILDIV(CP->REFGRDHEIGHT - CP->TILEGRDOFFY,
	  CP->TILEHEIGHT);
	CP->NUMTILES = CP->NUMHTILES * CP->NUMVTILES;

	IF (ILYRRATES && NUMILYRRATES > 0) {
		TCP->NUMLYRS = NUMILYRRATES + 1;
		IF (!(TCP->ILYRRATES = JAS_ALLOC2((TCP->NUMLYRS - 1),
		  SIZEOF(JPC_FIX_T)))) {
			GOTO ERROR;
		}
		FOR (I = 0; I < JAS_CAST(INT, TCP->NUMLYRS - 1); ++I) {
			TCP->ILYRRATES[I] = JPC_DBLTOFIX(ILYRRATES[I]);
		}
	}

	/* ENSURE THAT THE INTEGER MODE IS USED IN THE CASE OF LOSSLESS
	  CODING. */
	IF (CP->TOTALSIZE == UINT_FAST32_MAX && (!CP->TCP.INTMODE)) {
		JAS_EPRINTF("CANNOT USE REAL MODE FOR LOSSLESS CODING\N");
		GOTO ERROR;
	}

	/* ENSURE THAT THE PRECINCT WIDTH IS VALID. */
	IF (PRCWIDTHEXPN > 15) {
		JAS_EPRINTF("INVALID PRECINCT WIDTH\N");
		GOTO ERROR;
	}

	/* ENSURE THAT THE PRECINCT HEIGHT IS VALID. */
	IF (PRCHEIGHTEXPN > 15) {
		JAS_EPRINTF("INVALID PRECINCT HEIGHT\N");
		GOTO ERROR;
	}

	/* ENSURE THAT THE CODE BLOCK WIDTH IS VALID. */
	IF (CP->TCCP.CBLKWIDTHEXPN < 2 || CP->TCCP.CBLKWIDTHEXPN > 12) {
		JAS_EPRINTF("INVALID CODE BLOCK WIDTH %D\N",
		  JPC_POW2(CP->TCCP.CBLKWIDTHEXPN));
		GOTO ERROR;
	}

	/* ENSURE THAT THE CODE BLOCK HEIGHT IS VALID. */
	IF (CP->TCCP.CBLKHEIGHTEXPN < 2 || CP->TCCP.CBLKHEIGHTEXPN > 12) {
		JAS_EPRINTF("INVALID CODE BLOCK HEIGHT %D\N",
		  JPC_POW2(CP->TCCP.CBLKHEIGHTEXPN));
		GOTO ERROR;
	}

	/* ENSURE THAT THE CODE BLOCK SIZE IS NOT TOO LARGE. */
	IF (CP->TCCP.CBLKWIDTHEXPN + CP->TCCP.CBLKHEIGHTEXPN > 12) {
		JAS_EPRINTF("CODE BLOCK SIZE TOO LARGE\N");
		GOTO ERROR;
	}

	/* ENSURE THAT THE NUMBER OF LAYERS IS VALID. */
	IF (CP->TCP.NUMLYRS > 16384) {
		JAS_EPRINTF("TOO MANY LAYERS\N");
		GOTO ERROR;
	}

	/* THERE MUST BE AT LEAST ONE RESOLUTION LEVEL. */
	IF (CP->TCCP.MAXRLVLS < 1) {
		JAS_EPRINTF("MUST BE AT LEAST ONE RESOLUTION LEVEL\N");
		GOTO ERROR;
	}

	/* ENSURE THAT THE NUMBER OF GUARD BITS IS VALID. */
	IF (CP->TCCP.NUMGBITS > 8) {
		JAS_EPRINTF("INVALID NUMBER OF GUARD BITS\N");
		GOTO ERROR;
	}

	/* ENSURE THAT THE RATE IS WITHIN THE LEGAL RANGE. */
	IF (CP->TOTALSIZE != UINT_FAST32_MAX && CP->TOTALSIZE > CP->RAWSIZE) {
		JAS_EPRINTF("WARNING: SPECIFIED RATE IS UNREASONABLY LARGE (%LU > %LU)\N", (UNSIGNED LONG) CP->TOTALSIZE, (UNSIGNED LONG) CP->RAWSIZE);
	}

	/* ENSURE THAT THE INTERMEDIATE LAYER RATES ARE VALID. */
	IF (TCP->NUMLYRS > 1) {
		/* THE INTERMEDIATE LAYERS RATES MUST INCREASE MONOTONICALLY. */
		FOR (LYRNO = 0; LYRNO + 2 < TCP->NUMLYRS; ++LYRNO) {
			IF (TCP->ILYRRATES[LYRNO] >= TCP->ILYRRATES[LYRNO + 1]) {
				JAS_EPRINTF("INTERMEDIATE LAYER RATES MUST INCREASE MONOTONICALLY\N");
				GOTO ERROR;
			}
		}
		/* THE INTERMEDIATE LAYER RATES MUST BE LESS THAN THE OVERALL RATE. */
		IF (CP->TOTALSIZE != UINT_FAST32_MAX) {
			FOR (LYRNO = 0; LYRNO < TCP->NUMLYRS - 1; ++LYRNO) {
				IF (JPC_FIXTODBL(TCP->ILYRRATES[LYRNO]) > ((DOUBLE) CP->TOTALSIZE)
				  / CP->RAWSIZE) {
					JAS_EPRINTF("WARNING: INTERMEDIATE LAYER RATES MUST BE LESS THAN OVERALL RATE\N");
					GOTO ERROR;
				}
			}
		}
	}

	IF (ILYRRATES) {
		JAS_FREE(ILYRRATES);
	}

	RETURN CP;

ERROR:

	IF (ILYRRATES) {
		JAS_FREE(ILYRRATES);
	}
	IF (TVP) {
		JAS_TVPARSER_DESTROY(TVP);
	}
	IF (CP) {
		JPC_ENC_CP_DESTROY(CP);
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206510_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT UDF_EXPAND_FILE_ADINICB(STRUCT INODE *INODE)
{
	STRUCT PAGE *PAGE;
	CHAR *KADDR;
	STRUCT UDF_INODE_INFO *IINFO = UDF_I(INODE);
	INT ERR;
	STRUCT WRITEBACK_CONTROL UDF_WBC = {
		.SYNC_MODE = WB_SYNC_NONE,
		.NR_TO_WRITE = 1,
	};

	WARN_ON_ONCE(!INODE_IS_LOCKED(INODE));
	IF (!IINFO->I_LENALLOC) {
		IF (UDF_QUERY_FLAG(INODE->I_SB, UDF_FLAG_USE_SHORT_AD))
			IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_SHORT;
		ELSE
			IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_LONG;
		/* FROM NOW ON WE HAVE NORMAL ADDRESS_SPACE METHODS */
		INODE->I_DATA.A_OPS = &UDF_AOPS;
		UP_WRITE(&IINFO->I_DATA_SEM);
		MARK_INODE_DIRTY(INODE);
		RETURN 0;
	}
	/*
	 * RELEASE I_DATA_SEM SO THAT WE CAN LOCK A PAGE - PAGE LOCK RANKS
	 * ABOVE I_DATA_SEM. I_MUTEX STILL PROTECTS US AGAINST FILE CHANGES.
	 */
	UP_WRITE(&IINFO->I_DATA_SEM);

	PAGE = FIND_OR_CREATE_PAGE(INODE->I_MAPPING, 0, GFP_NOFS);
	IF (!PAGE)
		RETURN -ENOMEM;

	IF (!PAGEUPTODATE(PAGE)) {
		KADDR = KMAP_ATOMIC(PAGE);
		MEMSET(KADDR + IINFO->I_LENALLOC, 0X00,
		       PAGE_SIZE - IINFO->I_LENALLOC);
		MEMCPY(KADDR, IINFO->I_DATA + IINFO->I_LENEATTR,
			IINFO->I_LENALLOC);
		FLUSH_DCACHE_PAGE(PAGE);
		SETPAGEUPTODATE(PAGE);
		KUNMAP_ATOMIC(KADDR);
	}
	DOWN_WRITE(&IINFO->I_DATA_SEM);
	MEMSET(IINFO->I_DATA + IINFO->I_LENEATTR, 0X00,
	       IINFO->I_LENALLOC);
	IINFO->I_LENALLOC = 0;
	IF (UDF_QUERY_FLAG(INODE->I_SB, UDF_FLAG_USE_SHORT_AD))
		IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_SHORT;
	ELSE
		IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_LONG;
	/* FROM NOW ON WE HAVE NORMAL ADDRESS_SPACE METHODS */
	INODE->I_DATA.A_OPS = &UDF_AOPS;
	UP_WRITE(&IINFO->I_DATA_SEM);
	ERR = INODE->I_DATA.A_OPS->WRITEPAGE(PAGE, &UDF_WBC);
	IF (ERR) {
		/* RESTORE EVERYTHING BACK SO THAT WE DON'T LOSE DATA... */
		LOCK_PAGE(PAGE);
		DOWN_WRITE(&IINFO->I_DATA_SEM);
		KADDR = KMAP_ATOMIC(PAGE);
		MEMCPY(IINFO->I_DATA + IINFO->I_LENEATTR, KADDR, INODE->I_SIZE);
		KUNMAP_ATOMIC(KADDR);
		UNLOCK_PAGE(PAGE);
		IINFO->I_ALLOC_TYPE = ICBTAG_FLAG_AD_IN_ICB;
		INODE->I_DATA.A_OPS = &UDF_ADINICB_AOPS;
		UP_WRITE(&IINFO->I_DATA_SEM);
	}
	PUT_PAGE(PAGE);
	MARK_INODE_DIRTY(INODE);

	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212688_CWE-327.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT HCI_CONN_CHECK_LINK_MODE(STRUCT HCI_CONN *CONN)
{
	BT_DBG("HCON %P", CONN);

	/* IN SECURE CONNECTIONS ONLY MODE, IT IS REQUIRED THAT SECURE
	 * CONNECTIONS IS USED AND THE LINK IS ENCRYPTED WITH AES-CCM
	 * USING A P-256 AUTHENTICATED COMBINATION KEY.
	 */
	IF (HCI_DEV_TEST_FLAG(CONN->HDEV, HCI_SC_ONLY)) {
		IF (!HCI_CONN_SC_ENABLED(CONN) ||
		    !TEST_BIT(HCI_CONN_AES_CCM, &CONN->FLAGS) ||
		    CONN->KEY_TYPE != HCI_LK_AUTH_COMBINATION_P256)
			RETURN 0;
	}

	IF (HCI_CONN_SSP_ENABLED(CONN) &&
	    !TEST_BIT(HCI_CONN_ENCRYPT, &CONN->FLAGS))
		RETURN 0;

	RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216949_CWE-89.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FIELD *CREATE_TMP_FIELD_FROM_FIELD(THD *THD, FIELD *ORG_FIELD,
                                   CONST CHAR *NAME, TABLE *TABLE,
                                   ITEM_FIELD *ITEM)
{
  FIELD *NEW_FIELD;

  NEW_FIELD= ORG_FIELD->MAKE_NEW_FIELD(THD->MEM_ROOT, TABLE,
                                       TABLE == ORG_FIELD->TABLE);
  IF (NEW_FIELD)
  {
    NEW_FIELD->INIT(TABLE);
    NEW_FIELD->ORIG_TABLE= ORG_FIELD->ORIG_TABLE;
    IF (ITEM)
      ITEM->RESULT_FIELD= NEW_FIELD;
    ELSE
      NEW_FIELD->FIELD_NAME= NAME;
    NEW_FIELD->FLAGS|= (ORG_FIELD->FLAGS & NO_DEFAULT_VALUE_FLAG);
    IF (ORG_FIELD->MAYBE_NULL() || (ITEM && ITEM->MAYBE_NULL))
      NEW_FIELD->FLAGS&= ~NOT_NULL_FLAG;	// BECAUSE OF OUTER JOIN
    IF (ORG_FIELD->TYPE() == MYSQL_TYPE_VAR_STRING ||
        ORG_FIELD->TYPE() == MYSQL_TYPE_VARCHAR)
      TABLE->S->DB_CREATE_OPTIONS|= HA_OPTION_PACK_RECORD;
    ELSE IF (ORG_FIELD->TYPE() == FIELD_TYPE_DOUBLE)
      ((FIELD_DOUBLE *) NEW_FIELD)->NOT_FIXED= TRUE;
    NEW_FIELD->VCOL_INFO= 0;
    NEW_FIELD->COND_SELECTIVITY= 1.0;
    NEW_FIELD->NEXT_EQUAL_FIELD= NULL;
    NEW_FIELD->OPTION_LIST= NULL;
    NEW_FIELD->OPTION_STRUCT= NULL;
  }
  RETURN NEW_FIELD;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208522_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DNSC_LOAD_LOCAL_DATA(STRUCT DNSC_ENV* DNSCENV, STRUCT CONFIG_FILE *CFG)
{
    SIZE_T I, J;
	// INSERT 'LOCAL-ZONE: "2.DNSCRYPT-CERT.EXAMPLE.COM" DENY'
    IF(!CFG_STR2LIST_INSERT(&CFG->LOCAL_ZONES,
                            STRDUP(DNSCENV->PROVIDER_NAME),
                            STRDUP("DENY"))) {
        LOG_ERR("COULD NOT LOAD DNSCRYPT LOCAL-ZONE: %S DENY",
                DNSCENV->PROVIDER_NAME);
        RETURN -1;
    }

    // ADD LOCAL DATA ENTRY OF TYPE:
    // 2.DNSCRYPT-CERT.EXAMPLE.COM 86400 IN TXT "DNSC......"
    FOR(I=0; I<DNSCENV->SIGNED_CERTS_COUNT; I++) {
        CONST CHAR *TTL_CLASS_TYPE = " 86400 IN TXT \"";
        INT ROTATED_CERT = 0;
	UINT32_T SERIAL;
	UINT16_T RRLEN;
	CHAR* RR;
        STRUCT SIGNEDCERT *CERT = DNSCENV->SIGNED_CERTS + I;
		// CHECK IF THE CERTIFICATE IS BEING ROTATED AND SHOULD NOT BE PUBLISHED
        FOR(J=0; J<DNSCENV->ROTATED_CERTS_COUNT; J++){
            IF(CERT == DNSCENV->ROTATED_CERTS[J]) {
                ROTATED_CERT = 1;
                BREAK;
            }
        }
		MEMCPY(&SERIAL, CERT->SERIAL, SIZEOF SERIAL);
		SERIAL = HTONL(SERIAL);
        IF(ROTATED_CERT) {
            VERBOSE(VERB_OPS,
                "DNSCRYPT: NOT ADDING CERT WITH SERIAL #%"
                PRIU32
                " TO LOCAL-DATA AS IT IS ROTATED",
                SERIAL
            );
            CONTINUE;
        }
        RRLEN = STRLEN(DNSCENV->PROVIDER_NAME) +
                         STRLEN(TTL_CLASS_TYPE) +
                         4 * SIZEOF(STRUCT SIGNEDCERT) + // WORST CASE SCENARIO
                         1 + // TRAILING DOUBLE QUOTE
                         1;
        RR = MALLOC(RRLEN);
        IF(!RR) {
            LOG_ERR("COULD NOT ALLOCATE MEMORY");
            RETURN -2;
        }
        SNPRINTF(RR, RRLEN - 1, "%S 86400 IN TXT \"", DNSCENV->PROVIDER_NAME);
        FOR(J=0; J<SIZEOF(STRUCT SIGNEDCERT); J++) {
			INT C = (INT)*((CONST UINT8_T *) CERT + J);
            IF (ISPRINT(C) && C != '"' && C != '\\') {
                SNPRINTF(RR + STRLEN(RR), RRLEN - 1 - STRLEN(RR), "%C", C);
            } ELSE {
                SNPRINTF(RR + STRLEN(RR), RRLEN - 1 - STRLEN(RR), "\\%03D", C);
            }
        }
        VERBOSE(VERB_OPS,
			"DNSCRYPT: ADDING CERT WITH SERIAL #%"
			PRIU32
			" TO LOCAL-DATA TO CONFIG: %S",
			SERIAL, RR
		);
        SNPRINTF(RR + STRLEN(RR), RRLEN - 1 - STRLEN(RR), "\"");
        CFG_STRLIST_INSERT(&CFG->LOCAL_DATA, STRDUP(RR));
        FREE(RR);
    }
    RETURN DNSCENV->SIGNED_CERTS_COUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 316978_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SMACK_INODE_GETATTR(CONST STRUCT PATH *PATH)
{
	STRUCT SMK_AUDIT_INFO AD;
	STRUCT INODE *INODE = D_BACKING_INODE(PATH->DENTRY);
	INT RC;

	SMK_AD_INIT(&AD, __FUNC__, LSM_AUDIT_DATA_PATH);
	SMK_AD_SETFIELD_U_FS_PATH(&AD, *PATH);
	RC = SMK_CURACC(SMK_OF_INODE(INODE), MAY_READ, &AD);
	RC = SMK_BU_INODE(INODE, MAY_READ, RC);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212955_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT AX25_RELEASE(STRUCT SOCKET *SOCK)
{
	STRUCT SOCK *SK = SOCK->SK;
	AX25_CB *AX25;
	AX25_DEV *AX25_DEV;

	IF (SK == NULL)
		RETURN 0;

	SOCK_HOLD(SK);
	LOCK_SOCK(SK);
	SOCK_ORPHAN(SK);
	AX25 = SK_TO_AX25(SK);
	AX25_DEV = AX25->AX25_DEV;

	IF (SK->SK_TYPE == SOCK_SEQPACKET) {
		SWITCH (AX25->STATE) {
		CASE AX25_STATE_0:
			RELEASE_SOCK(SK);
			AX25_DISCONNECT(AX25, 0);
			LOCK_SOCK(SK);
			AX25_DESTROY_SOCKET(AX25);
			BREAK;

		CASE AX25_STATE_1:
		CASE AX25_STATE_2:
			AX25_SEND_CONTROL(AX25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
			RELEASE_SOCK(SK);
			AX25_DISCONNECT(AX25, 0);
			LOCK_SOCK(SK);
			IF (!SOCK_FLAG(AX25->SK, SOCK_DESTROY))
				AX25_DESTROY_SOCKET(AX25);
			BREAK;

		CASE AX25_STATE_3:
		CASE AX25_STATE_4:
			AX25_CLEAR_QUEUES(AX25);
			AX25->N2COUNT = 0;

			SWITCH (AX25->AX25_DEV->VALUES[AX25_VALUES_PROTOCOL]) {
			CASE AX25_PROTO_STD_SIMPLEX:
			CASE AX25_PROTO_STD_DUPLEX:
				AX25_SEND_CONTROL(AX25,
						  AX25_DISC,
						  AX25_POLLON,
						  AX25_COMMAND);
				AX25_STOP_T2TIMER(AX25);
				AX25_STOP_T3TIMER(AX25);
				AX25_STOP_IDLETIMER(AX25);
				BREAK;
#IFDEF CONFIG_AX25_DAMA_SLAVE
			CASE AX25_PROTO_DAMA_SLAVE:
				AX25_STOP_T3TIMER(AX25);
				AX25_STOP_IDLETIMER(AX25);
				BREAK;
#ENDIF
			}
			AX25_CALCULATE_T1(AX25);
			AX25_START_T1TIMER(AX25);
			AX25->STATE = AX25_STATE_2;
			SK->SK_STATE                = TCP_CLOSE;
			SK->SK_SHUTDOWN            |= SEND_SHUTDOWN;
			SK->SK_STATE_CHANGE(SK);
			SOCK_SET_FLAG(SK, SOCK_DESTROY);
			BREAK;

		DEFAULT:
			BREAK;
		}
	} ELSE {
		SK->SK_STATE     = TCP_CLOSE;
		SK->SK_SHUTDOWN |= SEND_SHUTDOWN;
		SK->SK_STATE_CHANGE(SK);
		AX25_DESTROY_SOCKET(AX25);
	}
	IF (AX25_DEV) {
		DEV_PUT_TRACK(AX25_DEV->DEV, &AX25_DEV->DEV_TRACKER);
		AX25_DEV_PUT(AX25_DEV);
	}

	SOCK->SK   = NULL;
	RELEASE_SOCK(SK);
	SOCK_PUT(SK);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212829_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
 */
STATIC VOID PHP_WDDX_POP_ELEMENT(VOID *USER_DATA, CONST XML_CHAR *NAME)
{
	ST_ENTRY 			*ENT1, *ENT2;
	WDDX_STACK 			*STACK = (WDDX_STACK *)USER_DATA;
	HASHTABLE 			*TARGET_HASH;
	ZEND_CLASS_ENTRY 	**PCE;
	ZVAL				*OBJ;
	ZVAL				*TMP;
	TSRMLS_FETCH();

/* OBJECTS_FIXME */
	IF (STACK->TOP == 0) {
		RETURN;
	}

	IF (!STRCMP(NAME, EL_STRING) || !STRCMP(NAME, EL_NUMBER) ||
		!STRCMP(NAME, EL_BOOLEAN) || !STRCMP(NAME, EL_NULL) ||
	  	!STRCMP(NAME, EL_ARRAY) || !STRCMP(NAME, EL_STRUCT) ||
		!STRCMP(NAME, EL_RECORDSET) || !STRCMP(NAME, EL_BINARY) ||
		!STRCMP(NAME, EL_DATETIME)) {
		WDDX_STACK_TOP(STACK, (VOID**)&ENT1);

		IF (!ENT1->DATA) {
			IF (STACK->TOP > 1) {
				STACK->TOP--;
			} ELSE {
				STACK->DONE = 1;
			}
			EFREE(ENT1);
			RETURN;
		}

		IF (!STRCMP(NAME, EL_BINARY)) {
			INT NEW_LEN=0;
			UNSIGNED CHAR *NEW_STR;

			NEW_STR = PHP_BASE64_DECODE(Z_STRVAL_P(ENT1->DATA), Z_STRLEN_P(ENT1->DATA), &NEW_LEN);
			STR_FREE(Z_STRVAL_P(ENT1->DATA));
			Z_STRVAL_P(ENT1->DATA) = NEW_STR;
			Z_STRLEN_P(ENT1->DATA) = NEW_LEN;
		}

		/* CALL __WAKEUP() METHOD ON THE OBJECT. */
		IF (Z_TYPE_P(ENT1->DATA) == IS_OBJECT) {
			ZVAL *FNAME, *RETVAL = NULL;

			MAKE_STD_ZVAL(FNAME);
			ZVAL_STRING(FNAME, "__WAKEUP", 1);

			CALL_USER_FUNCTION_EX(NULL, &ENT1->DATA, FNAME, &RETVAL, 0, 0, 0, NULL TSRMLS_CC);

			ZVAL_DTOR(FNAME);
			FREE_ZVAL(FNAME);
			IF (RETVAL) {
				ZVAL_PTR_DTOR(&RETVAL);
			}
		}

		IF (STACK->TOP > 1) {
			STACK->TOP--;
			WDDX_STACK_TOP(STACK, (VOID**)&ENT2);

			/* IF NON-EXISTENT FIELD */
			IF (ENT2->TYPE == ST_FIELD && ENT2->DATA == NULL) {
				ZVAL_PTR_DTOR(&ENT1->DATA);
				EFREE(ENT1);
				RETURN;
			}

			IF (Z_TYPE_P(ENT2->DATA) == IS_ARRAY || Z_TYPE_P(ENT2->DATA) == IS_OBJECT) {
				TARGET_HASH = HASH_OF(ENT2->DATA);

				IF (ENT1->VARNAME) {
					IF (!STRCMP(ENT1->VARNAME, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ENT1->DATA) == IS_STRING && Z_STRLEN_P(ENT1->DATA) &&
						ENT2->TYPE == ST_STRUCT && Z_TYPE_P(ENT2->DATA) == IS_ARRAY) {
						ZEND_BOOL INCOMPLETE_CLASS = 0;

						ZEND_STR_TOLOWER(Z_STRVAL_P(ENT1->DATA), Z_STRLEN_P(ENT1->DATA));
						IF (ZEND_HASH_FIND(EG(CLASS_TABLE), Z_STRVAL_P(ENT1->DATA),
										   Z_STRLEN_P(ENT1->DATA)+1, (VOID **) &PCE)==FAILURE) {
							INCOMPLETE_CLASS = 1;
							PCE = &PHP_IC_ENTRY;
						}

						/* INITIALIZE TARGET OBJECT */
						MAKE_STD_ZVAL(OBJ);
						OBJECT_INIT_EX(OBJ, *PCE);

						/* MERGE CURRENT HASHTABLE WITH OBJECT'S DEFAULT PROPERTIES */
						ZEND_HASH_MERGE(Z_OBJPROP_P(OBJ),
										Z_ARRVAL_P(ENT2->DATA),
										(VOID (*)(VOID *)) ZVAL_ADD_REF,
										(VOID *) &TMP, SIZEOF(ZVAL *), 0);

						IF (INCOMPLETE_CLASS) {
							PHP_STORE_CLASS_NAME(OBJ, Z_STRVAL_P(ENT1->DATA), Z_STRLEN_P(ENT1->DATA));
						}

						/* CLEAN UP OLD ARRAY ENTRY */
						ZVAL_PTR_DTOR(&ENT2->DATA);

						/* SET STACK ENTRY TO POINT TO THE NEWLY CREATED OBJECT */
						ENT2->DATA = OBJ;

						/* CLEAN UP CLASS NAME VAR ENTRY */
						ZVAL_PTR_DTOR(&ENT1->DATA);
					} ELSE IF (Z_TYPE_P(ENT2->DATA) == IS_OBJECT) {
						ZEND_CLASS_ENTRY *OLD_SCOPE = EG(SCOPE);

						EG(SCOPE) = Z_OBJCE_P(ENT2->DATA);
						Z_DELREF_P(ENT1->DATA);
						ADD_PROPERTY_ZVAL(ENT2->DATA, ENT1->VARNAME, ENT1->DATA);
						EG(SCOPE) = OLD_SCOPE;
					} ELSE {
						ZEND_SYMTABLE_UPDATE(TARGET_HASH, ENT1->VARNAME, STRLEN(ENT1->VARNAME)+1, &ENT1->DATA, SIZEOF(ZVAL *), NULL);
					}
					EFREE(ENT1->VARNAME);
				} ELSE	{
					ZEND_HASH_NEXT_INDEX_INSERT(TARGET_HASH, &ENT1->DATA, SIZEOF(ZVAL *), NULL);
				}
			}
			EFREE(ENT1);
		} ELSE {
			STACK->DONE = 1;
		}
	} ELSE IF (!STRCMP(NAME, EL_VAR) && STACK->VARNAME) {
		EFREE(STACK->VARNAME);
		STACK->VARNAME = NULL;
	} ELSE IF (!STRCMP(NAME, EL_FIELD)) {
		ST_ENTRY *ENT;
		WDDX_STACK_TOP(STACK, (VOID **)&ENT);
		EFREE(ENT);
		STACK->TOP--;
	}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212403_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FIND_START_BRACE(VOID)	    // XXX
{
    POS_T	CURSOR_SAVE;
    POS_T	*TRYPOS;
    POS_T	*POS;
    STATIC POS_T	POS_COPY;

    CURSOR_SAVE = CURWIN->W_CURSOR;
    WHILE ((TRYPOS = FINDMATCHLIMIT(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)
    {
	POS_COPY = *TRYPOS;	// COPY POS_T, NEXT FINDMATCH WILL CHANGE IT
	TRYPOS = &POS_COPY;
	CURWIN->W_CURSOR = *TRYPOS;
	POS = NULL;
	// IGNORE THE { IF IT'S IN A // OR / *  * / COMMENT
	IF ((COLNR_T)CIN_SKIP2POS(TRYPOS) == TRYPOS->COL
		       && (POS = IND_FIND_START_CORS(NULL)) == NULL) // XXX
	    BREAK;
	IF (POS != NULL)
	    CURWIN->W_CURSOR.LNUM = POS->LNUM;
    }
    CURWIN->W_CURSOR = CURSOR_SAVE;
    RETURN TRYPOS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 348424_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID AX_ENCAPS(STRUCT NET_DEVICE *DEV, UNSIGNED CHAR *ICP, INT LEN)
{
	STRUCT MKISS *AX = NETDEV_PRIV(DEV);
	UNSIGNED CHAR *P;
	INT ACTUAL, COUNT;

	IF (AX->MTU != AX->DEV->MTU + 73)	/* SOMEONE HAS BEEN IFCONFIGGING */
		AX_CHANGEDMTU(AX);

	IF (LEN > AX->MTU) {		/* SIGH, SHOULDN'T OCCUR BUT ... */
		PRINTK(KERN_ERR "MKISS: %S: TRUNCATING OVERSIZED TRANSMIT PACKET!\N", AX->DEV->NAME);
		DEV->STATS.TX_DROPPED++;
		NETIF_START_QUEUE(DEV);
		RETURN;
	}

	P = ICP;

	SPIN_LOCK_BH(&AX->BUFLOCK);
	IF ((*P & 0X0F) != 0) {
		/* CONFIGURATION COMMAND (KISSPARMS(1).
		 * PROTOCOL SPEC SAYS: NEVER APPEND CRC.
		 * THIS FIXES A VERY OLD BUG IN THE LINUX
		 * KISS DRIVER. -- DL9SAU */
		SWITCH (*P & 0XFF) {
		CASE 0X85:
			/* COMMAND FROM USERSPACE ESPECIALLY FOR US,
			 * NOT FOR DELIVERY TO THE TNC */
			IF (LEN > 1) {
				INT CMD = (P[1] & 0XFF);
				SWITCH(CMD) {
				CASE 3:
				  AX->CRCMODE = CRC_MODE_SMACK;
				  BREAK;
				CASE 2:
				  AX->CRCMODE = CRC_MODE_FLEX;
				  BREAK;
				CASE 1:
				  AX->CRCMODE = CRC_MODE_NONE;
				  BREAK;
				CASE 0:
				DEFAULT:
				  AX->CRCMODE = CRC_MODE_SMACK_TEST;
				  CMD = 0;
				}
				AX->CRCAUTO = (CMD ? 0 : 1);
				PRINTK(KERN_INFO "MKISS: %S: CRC MODE SET TO %D\N",
				       AX->DEV->NAME, CMD);
			}
			SPIN_UNLOCK_BH(&AX->BUFLOCK);
			NETIF_START_QUEUE(DEV);

			RETURN;
		DEFAULT:
			COUNT = KISS_ESC(P, AX->XBUFF, LEN);
		}
	} ELSE {
		UNSIGNED SHORT CRC;
		SWITCH (AX->CRCMODE) {
		CASE CRC_MODE_SMACK_TEST:
			AX->CRCMODE  = CRC_MODE_FLEX_TEST;
			PRINTK(KERN_INFO "MKISS: %S: TRYING CRC-SMACK\N", AX->DEV->NAME);
			FALLTHROUGH;
		CASE CRC_MODE_SMACK:
			*P |= 0X80;
			CRC = SWAB16(CRC16(0, P, LEN));
			COUNT = KISS_ESC_CRC(P, AX->XBUFF, CRC, LEN+2);
			BREAK;
		CASE CRC_MODE_FLEX_TEST:
			AX->CRCMODE = CRC_MODE_NONE;
			PRINTK(KERN_INFO "MKISS: %S: TRYING CRC-FLEXNET\N", AX->DEV->NAME);
			FALLTHROUGH;
		CASE CRC_MODE_FLEX:
			*P |= 0X20;
			CRC = CALC_CRC_FLEX(P, LEN);
			COUNT = KISS_ESC_CRC(P, AX->XBUFF, CRC, LEN+2);
			BREAK;

		DEFAULT:
			COUNT = KISS_ESC(P, AX->XBUFF, LEN);
		}
	}
	SPIN_UNLOCK_BH(&AX->BUFLOCK);

	SET_BIT(TTY_DO_WRITE_WAKEUP, &AX->TTY->FLAGS);
	ACTUAL = AX->TTY->OPS->WRITE(AX->TTY, AX->XBUFF, COUNT);
	DEV->STATS.TX_PACKETS++;
	DEV->STATS.TX_BYTES += ACTUAL;

	NETIF_TRANS_UPDATE(AX->DEV);
	AX->XLEFT = COUNT - ACTUAL;
	AX->XHEAD = AX->XBUFF + ACTUAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195230_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID PJMEDIA_RTCP_XR_RX_RTCP_XR( PJMEDIA_RTCP_XR_SESSION *SESS,
				 CONST VOID *PKT,
				 PJ_SIZE_T SIZE)
{
    CONST PJMEDIA_RTCP_XR_PKT	      *RTCP_XR = (PJMEDIA_RTCP_XR_PKT*) PKT;
    CONST PJMEDIA_RTCP_XR_RB_RR_TIME  *RB_RR_TIME = NULL;
    CONST PJMEDIA_RTCP_XR_RB_DLRR     *RB_DLRR = NULL;
    CONST PJMEDIA_RTCP_XR_RB_STATS    *RB_STATS = NULL;
    CONST PJMEDIA_RTCP_XR_RB_VOIP_MTC *RB_VOIP_MTC = NULL;
    CONST PJMEDIA_RTCP_XR_RB_HEADER   *RB_HDR = (PJMEDIA_RTCP_XR_RB_HEADER*) 
						RTCP_XR->BUF;
    UNSIGNED PKT_LEN, RB_LEN;

    IF (RTCP_XR->COMMON.PT != RTCP_XR)
	RETURN;

    PKT_LEN = PJ_NTOHS((PJ_UINT16_T)RTCP_XR->COMMON.LENGTH);

    IF ((PKT_LEN + 1) > (SIZE / 4))
	RETURN;

    /* PARSE REPORT RPT_TYPES */
    WHILE ((PJ_INT32_T*)RB_HDR < (PJ_INT32_T*)PKT + PKT_LEN)
    {	
	RB_LEN = PJ_NTOHS((PJ_UINT16_T)RB_HDR->LENGTH);

	/* JUST SKIP ANY BLOCK WITH LENGTH == 0 (NO REPORT CONTENT) */
	IF (RB_LEN) {
	    SWITCH (RB_HDR->BT) {
		CASE BT_RR_TIME:
		    RB_RR_TIME = (PJMEDIA_RTCP_XR_RB_RR_TIME*) RB_HDR;
		    BREAK;
		CASE BT_DLRR:
		    RB_DLRR = (PJMEDIA_RTCP_XR_RB_DLRR*) RB_HDR;
		    BREAK;
		CASE BT_STATS:
		    RB_STATS = (PJMEDIA_RTCP_XR_RB_STATS*) RB_HDR;
		    BREAK;
		CASE BT_VOIP_METRICS:
		    RB_VOIP_MTC = (PJMEDIA_RTCP_XR_RB_VOIP_MTC*) RB_HDR;
		    BREAK;
		DEFAULT:
		    BREAK;
	    }
	}
	RB_HDR = (PJMEDIA_RTCP_XR_RB_HEADER*)
		 ((PJ_INT32_T*)RB_HDR + RB_LEN + 1);
    }

    /* RECEIVING RR TIME */
    IF (RB_RR_TIME) {
	/* SAVE LRR FROM NTP TIMESTAMP OF THE RR TIME BLOCK REPORT */
	SESS->RX_LRR = ((PJ_NTOHL(RB_RR_TIME->NTP_SEC) & 0X0000FFFF) << 16) | 
		       ((PJ_NTOHL(RB_RR_TIME->NTP_FRAC) >> 16) & 0XFFFF);

	/* CALCULATE RR ARRIVAL TIME FOR DLRR */
	PJ_GET_TIMESTAMP(&SESS->RX_LRR_TIME);

	TRACE_((SESS->NAME, "RX RTCP SR: NTP_TS=%P", SESS->RX_LRR,
	       (PJ_UINT32_T)(SESS->RX_LRR_TIME.U64*65536/
			     SESS->RTCP_SESSION->TS_FREQ.U64)));
    }

    /* RECEIVING DLRR */
    IF (RB_DLRR) {
	PJ_UINT32_T LRR, NOW, DLRR;
	PJ_UINT64_T EEDELAY;
	PJMEDIA_RTCP_NTP_REC NTP;

	/* LRR IS THE MIDDLE 32BIT OF NTP. IT HAS 1/65536 SECOND 
	 * RESOLUTION 
	 */
	LRR = PJ_NTOHL(RB_DLRR->ITEM.LRR);

	/* DLRR IS DELAY SINCE LRR, ALSO IN 1/65536 RESOLUTION */
	DLRR = PJ_NTOHL(RB_DLRR->ITEM.DLRR);

	/* GET CURRENT TIME, AND CONVERT TO 1/65536 RESOLUTION */
	PJMEDIA_RTCP_GET_NTP_TIME(SESS->RTCP_SESSION, &NTP);
	NOW = ((NTP.HI & 0XFFFF) << 16) + (NTP.LO >> 16);

	/* END-TO-END DELAY IS (NOW-LRR-DLRR) */
	EEDELAY = NOW - LRR - DLRR;

	/* CONVERT END TO END DELAY TO USEC (KEEPING THE CALCULATION IN
         * 64BIT SPACE)::
	 *   SESS->EE_DELAY = (EEDELAY * 1000) / 65536;
	 */
	IF (EEDELAY < 4294) {
	    EEDELAY = (EEDELAY * 1000000) >> 16;
	} ELSE {
	    EEDELAY = (EEDELAY * 1000) >> 16;
	    EEDELAY *= 1000;
	}

	TRACE_((SESS->NAME, "RX RTCP XR DLRR: LRR=%P, DLRR=%P (%D:%03DMS), "
			   "NOW=%P, RTT=%P",
		LRR, DLRR, DLRR/65536, (DLRR%65536)*1000/65536,
		NOW, (PJ_UINT32_T)EEDELAY));
	
	/* ONLY SAVE CALCULATION IF "NOW" IS GREATER THAN LRR, OR
	 * OTHERWISE RTT WILL BE INVALID 
	 */
	IF (NOW-DLRR >= LRR) {
	    UNSIGNED RTT = (PJ_UINT32_T)EEDELAY;
	    
	    /* CHECK THAT EEDELAY VALUE REALLY MAKES SENSE. 
	     * WE ALLOW UP TO 30 SECONDS RTT!
	     */
	    IF (EEDELAY <= 30 * 1000 * 1000UL) {
		/* "NORMALIZE" RTT VALUE THAT IS EXCEPTIONALLY HIGH.
		 * FOR SUCH VALUES, "NORMALIZE" THE RTT TO BE THREE TIMES
		 * THE AVERAGE VALUE.
		 */
		IF (RTT>((UNSIGNED)SESS->STAT.RTT.MEAN*3) && SESS->STAT.RTT.N!=0)
		{
		    UNSIGNED ORIG_RTT = RTT;
		    RTT = (UNSIGNED)SESS->STAT.RTT.MEAN*3;
		    PJ_LOG(5,(SESS->NAME, 
			      "RTT VALUE %D USEC IS NORMALIZED TO %D USEC",
			      ORIG_RTT, RTT));
		}
    	
		TRACE_((SESS->NAME, "RTCP RTT IS SET TO %D USEC", RTT));
		PJ_MATH_STAT_UPDATE(&SESS->STAT.RTT, RTT);
	    }
	} ELSE {
	    PJ_LOG(5, (SESS->NAME, "INTERNAL RTCP NTP CLOCK SKEW DETECTED: "
				   "LRR=%P, NOW=%P, DLRR=%P (%D:%03DMS), "
				   "DIFF=%D",
				   LRR, NOW, DLRR, DLRR/65536,
				   (DLRR%65536)*1000/65536,
				   DLRR-(NOW-LRR)));
	}
    }

    /* RECEIVING STATISTICS SUMMARY */
    IF (RB_STATS) {
	PJ_UINT8_T FLAGS = RB_STATS->HEADER.SPECIFIC;

	PJ_BZERO(&SESS->STAT.TX.STAT_SUM, SIZEOF(SESS->STAT.TX.STAT_SUM));

	/* RANGE OF PACKETS SEQUENCE REPORTED IN THIS BLOCKS */
	SESS->STAT.TX.STAT_SUM.BEGIN_SEQ = PJ_NTOHS(RB_STATS->BEGIN_SEQ);
	SESS->STAT.TX.STAT_SUM.END_SEQ   = PJ_NTOHS(RB_STATS->END_SEQ);

	/* GET FLAGS OF VALID FIELDS */
	SESS->STAT.TX.STAT_SUM.L = (FLAGS & (1 << 7)) != 0;
	SESS->STAT.TX.STAT_SUM.D = (FLAGS & (1 << 6)) != 0;
	SESS->STAT.TX.STAT_SUM.J = (FLAGS & (1 << 5)) != 0;
	SESS->STAT.TX.STAT_SUM.T = (FLAGS & (3 << 3)) != 0;

	/* FETCH THE REPORTS INFO */
	IF (SESS->STAT.TX.STAT_SUM.L) {
	    SESS->STAT.TX.STAT_SUM.LOST = PJ_NTOHL(RB_STATS->LOST);
	}

	IF (SESS->STAT.TX.STAT_SUM.D) {
	    SESS->STAT.TX.STAT_SUM.DUP = PJ_NTOHL(RB_STATS->DUP);
	}

	IF (SESS->STAT.TX.STAT_SUM.J) {
	    SESS->STAT.TX.STAT_SUM.JITTER.MIN = PJ_NTOHL(RB_STATS->JITTER_MIN);
	    SESS->STAT.TX.STAT_SUM.JITTER.MAX = PJ_NTOHL(RB_STATS->JITTER_MAX);
	    SESS->STAT.TX.STAT_SUM.JITTER.MEAN= PJ_NTOHL(RB_STATS->JITTER_MEAN);
	    PJ_MATH_STAT_SET_STDDEV(&SESS->STAT.TX.STAT_SUM.JITTER, 
				    PJ_NTOHL(RB_STATS->JITTER_DEV));
	}

	IF (SESS->STAT.TX.STAT_SUM.T) {
	    SESS->STAT.TX.STAT_SUM.TOH.MIN = RB_STATS->TOH_MIN;
	    SESS->STAT.TX.STAT_SUM.TOH.MAX = RB_STATS->TOH_MAX;
	    SESS->STAT.TX.STAT_SUM.TOH.MEAN= RB_STATS->TOH_MEAN;
	    PJ_MATH_STAT_SET_STDDEV(&SESS->STAT.TX.STAT_SUM.TOH, 
				    PJ_NTOHL(RB_STATS->TOH_DEV));
	}

	PJ_GETTIMEOFDAY(&SESS->STAT.TX.STAT_SUM.UPDATE);
    }

    /* RECEIVING VOIP METRICS */
    IF (RB_VOIP_MTC) {
	SESS->STAT.TX.VOIP_MTC.LOSS_RATE = RB_VOIP_MTC->LOSS_RATE;
	SESS->STAT.TX.VOIP_MTC.DISCARD_RATE = RB_VOIP_MTC->DISCARD_RATE;
	SESS->STAT.TX.VOIP_MTC.BURST_DEN = RB_VOIP_MTC->BURST_DEN;
	SESS->STAT.TX.VOIP_MTC.GAP_DEN = RB_VOIP_MTC->GAP_DEN;
	SESS->STAT.TX.VOIP_MTC.BURST_DUR = PJ_NTOHS(RB_VOIP_MTC->BURST_DUR);
	SESS->STAT.TX.VOIP_MTC.GAP_DUR = PJ_NTOHS(RB_VOIP_MTC->GAP_DUR);
	SESS->STAT.TX.VOIP_MTC.RND_TRIP_DELAY = 
					PJ_NTOHS(RB_VOIP_MTC->RND_TRIP_DELAY);
	SESS->STAT.TX.VOIP_MTC.END_SYS_DELAY = 
					PJ_NTOHS(RB_VOIP_MTC->END_SYS_DELAY);
	/* SIGNAL & NOISE LEVEL ENCODED IN TWO'S COMPLEMENT FORM */
	SESS->STAT.TX.VOIP_MTC.SIGNAL_LVL = (PJ_INT8_T)
				    ((RB_VOIP_MTC->SIGNAL_LVL > 127)?
				     ((INT)RB_VOIP_MTC->SIGNAL_LVL - 256) : 
				     RB_VOIP_MTC->SIGNAL_LVL);
	SESS->STAT.TX.VOIP_MTC.NOISE_LVL  = (PJ_INT8_T)
				    ((RB_VOIP_MTC->NOISE_LVL > 127)?
				     ((INT)RB_VOIP_MTC->NOISE_LVL - 256) : 
				     RB_VOIP_MTC->NOISE_LVL);
	SESS->STAT.TX.VOIP_MTC.RERL = RB_VOIP_MTC->RERL;
	SESS->STAT.TX.VOIP_MTC.GMIN = RB_VOIP_MTC->GMIN;
	SESS->STAT.TX.VOIP_MTC.R_FACTOR = RB_VOIP_MTC->R_FACTOR;
	SESS->STAT.TX.VOIP_MTC.EXT_R_FACTOR = RB_VOIP_MTC->EXT_R_FACTOR;
	SESS->STAT.TX.VOIP_MTC.MOS_LQ = RB_VOIP_MTC->MOS_LQ;
	SESS->STAT.TX.VOIP_MTC.MOS_CQ = RB_VOIP_MTC->MOS_CQ;
	SESS->STAT.TX.VOIP_MTC.RX_CONFIG = RB_VOIP_MTC->RX_CONFIG;
	SESS->STAT.TX.VOIP_MTC.JB_NOM = PJ_NTOHS(RB_VOIP_MTC->JB_NOM);
	SESS->STAT.TX.VOIP_MTC.JB_MAX = PJ_NTOHS(RB_VOIP_MTC->JB_MAX);
	SESS->STAT.TX.VOIP_MTC.JB_ABS_MAX = PJ_NTOHS(RB_VOIP_MTC->JB_ABS_MAX);

	PJ_GETTIMEOFDAY(&SESS->STAT.TX.VOIP_MTC.UPDATE);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 313835_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CALL_YANK_DO_AUTOCMD(INT REGNAME)
{
    OPARG_T	OA;
    YANKREG_T	*REG;

    CLEAR_OPARG(&OA);
    OA.REGNAME = REGNAME;
    OA.OP_TYPE = OP_YANK;
    OA.IS_VISUAL = TRUE;
    REG = GET_REGISTER(REGNAME, TRUE);
    YANK_DO_AUTOCMD(&OA, REG);
    FREE_REGISTER(REG);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208505_CWE-399.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NETWORKSTATUS_PARSE_VOTE_FROM_STRING(CONST CHAR *S, CONST CHAR **EOS_OUT,
                                     NETWORKSTATUS_TYPE_T NS_TYPE)
{
  SMARTLIST_T *TOKENS = SMARTLIST_CREATE();
  SMARTLIST_T *RS_TOKENS = NULL, *FOOTER_TOKENS = NULL;
  NETWORKSTATUS_VOTER_INFO_T *VOTER = NULL;
  NETWORKSTATUS_T *NS = NULL;
  DIGESTS_T NS_DIGESTS;
  CONST CHAR *CERT, *END_OF_HEADER, *END_OF_FOOTER, *S_DUP = S;
  DIRECTORY_TOKEN_T *TOK;
  INT OK;
  STRUCT IN_ADDR IN;
  INT I, INORDER, N_SIGNATURES = 0;
  MEMAREA_T *AREA = NULL, *RS_AREA = NULL;
  CONSENSUS_FLAVOR_T FLAV = FLAV_NS;

  TOR_ASSERT(S);

  IF (EOS_OUT)
    *EOS_OUT = NULL;

  IF (ROUTER_GET_NETWORKSTATUS_V3_HASHES(S, &NS_DIGESTS)) {
    LOG_WARN(LD_DIR, "UNABLE TO COMPUTE DIGEST OF NETWORK-STATUS");
    GOTO ERR;
  }

  AREA = MEMAREA_NEW();
  END_OF_HEADER = FIND_START_OF_NEXT_ROUTERSTATUS(S);
  IF (TOKENIZE_STRING(AREA, S, END_OF_HEADER, TOKENS,
                      (NS_TYPE == NS_TYPE_CONSENSUS) ?
                      NETWORKSTATUS_CONSENSUS_TOKEN_TABLE :
                      NETWORKSTATUS_TOKEN_TABLE, 0)) {
    LOG_WARN(LD_DIR, "ERROR TOKENIZING NETWORK-STATUS VOTE HEADER");
    GOTO ERR;
  }

  NS = TOR_MALLOC_ZERO(SIZEOF(NETWORKSTATUS_T));
  MEMCPY(&NS->DIGESTS, &NS_DIGESTS, SIZEOF(NS_DIGESTS));

  TOK = FIND_BY_KEYWORD(TOKENS, K_NETWORK_STATUS_VERSION);
  TOR_ASSERT(TOK);
  IF (TOK->N_ARGS > 1) {
    INT FLAVOR = NETWORKSTATUS_PARSE_FLAVOR_NAME(TOK->ARGS[1]);
    IF (FLAVOR < 0) {
      LOG_WARN(LD_DIR, "CAN'T PARSE DOCUMENT WITH UNKNOWN FLAVOR %S",
               ESCAPED(TOK->ARGS[2]));
      GOTO ERR;
    }
    NS->FLAVOR = FLAV = FLAVOR;
  }
  IF (FLAV != FLAV_NS && NS_TYPE != NS_TYPE_CONSENSUS) {
    LOG_WARN(LD_DIR, "FLAVOR FOUND ON NON-CONSENSUS NETWORKSTATUS.");
    GOTO ERR;
  }

  IF (NS_TYPE != NS_TYPE_CONSENSUS) {
    CONST CHAR *END_OF_CERT = NULL;
    IF (!(CERT = STRSTR(S, "\NDIR-KEY-CERTIFICATE-VERSION")))
      GOTO ERR;
    ++CERT;
    NS->CERT = AUTHORITY_CERT_PARSE_FROM_STRING(CERT, &END_OF_CERT);
    IF (!NS->CERT || !END_OF_CERT || END_OF_CERT > END_OF_HEADER)
      GOTO ERR;
  }

  TOK = FIND_BY_KEYWORD(TOKENS, K_VOTE_STATUS);
  TOR_ASSERT(TOK->N_ARGS);
  IF (!STRCMP(TOK->ARGS[0], "VOTE")) {
    NS->TYPE = NS_TYPE_VOTE;
  } ELSE IF (!STRCMP(TOK->ARGS[0], "CONSENSUS")) {
    NS->TYPE = NS_TYPE_CONSENSUS;
  } ELSE IF (!STRCMP(TOK->ARGS[0], "OPINION")) {
    NS->TYPE = NS_TYPE_OPINION;
  } ELSE {
    LOG_WARN(LD_DIR, "UNRECOGNIZED VOTE STATUS %S IN NETWORK-STATUS",
             ESCAPED(TOK->ARGS[0]));
    GOTO ERR;
  }
  IF (NS_TYPE != NS->TYPE) {
    LOG_WARN(LD_DIR, "GOT THE WRONG KIND OF V3 NETWORKSTATUS.");
    GOTO ERR;
  }

  IF (NS->TYPE == NS_TYPE_VOTE || NS->TYPE == NS_TYPE_OPINION) {
    TOK = FIND_BY_KEYWORD(TOKENS, K_PUBLISHED);
    IF (PARSE_ISO_TIME(TOK->ARGS[0], &NS->PUBLISHED))
      GOTO ERR;

    NS->SUPPORTED_METHODS = SMARTLIST_CREATE();
    TOK = FIND_OPT_BY_KEYWORD(TOKENS, K_CONSENSUS_METHODS);
    IF (TOK) {
      FOR (I=0; I < TOK->N_ARGS; ++I)
        SMARTLIST_ADD(NS->SUPPORTED_METHODS, TOR_STRDUP(TOK->ARGS[I]));
    } ELSE {
      SMARTLIST_ADD(NS->SUPPORTED_METHODS, TOR_STRDUP("1"));
    }
  } ELSE {
    TOK = FIND_OPT_BY_KEYWORD(TOKENS, K_CONSENSUS_METHOD);
    IF (TOK) {
      NS->CONSENSUS_METHOD = (INT)TOR_PARSE_LONG(TOK->ARGS[0], 10, 1, INT_MAX,
                                                 &OK, NULL);
      IF (!OK)
        GOTO ERR;
    } ELSE {
      NS->CONSENSUS_METHOD = 1;
    }
  }

  TOK = FIND_BY_KEYWORD(TOKENS, K_VALID_AFTER);
  IF (PARSE_ISO_TIME(TOK->ARGS[0], &NS->VALID_AFTER))
    GOTO ERR;

  TOK = FIND_BY_KEYWORD(TOKENS, K_FRESH_UNTIL);
  IF (PARSE_ISO_TIME(TOK->ARGS[0], &NS->FRESH_UNTIL))
    GOTO ERR;

  TOK = FIND_BY_KEYWORD(TOKENS, K_VALID_UNTIL);
  IF (PARSE_ISO_TIME(TOK->ARGS[0], &NS->VALID_UNTIL))
    GOTO ERR;

  TOK = FIND_BY_KEYWORD(TOKENS, K_VOTING_DELAY);
  TOR_ASSERT(TOK->N_ARGS >= 2);
  NS->VOTE_SECONDS =
    (INT) TOR_PARSE_LONG(TOK->ARGS[0], 10, 0, INT_MAX, &OK, NULL);
  IF (!OK)
    GOTO ERR;
  NS->DIST_SECONDS =
    (INT) TOR_PARSE_LONG(TOK->ARGS[1], 10, 0, INT_MAX, &OK, NULL);
  IF (!OK)
    GOTO ERR;
  IF (NS->VALID_AFTER + MIN_VOTE_INTERVAL > NS->FRESH_UNTIL) {
    LOG_WARN(LD_DIR, "VOTE/CONSENSUS FRESHNESS INTERVAL IS TOO SHORT");
    GOTO ERR;
  }
  IF (NS->VALID_AFTER + MIN_VOTE_INTERVAL*2 > NS->VALID_UNTIL) {
    LOG_WARN(LD_DIR, "VOTE/CONSENSUS LIVENESS INTERVAL IS TOO SHORT");
    GOTO ERR;
  }
  IF (NS->VOTE_SECONDS < MIN_VOTE_SECONDS) {
    LOG_WARN(LD_DIR, "VOTE SECONDS IS TOO SHORT");
    GOTO ERR;
  }
  IF (NS->DIST_SECONDS < MIN_DIST_SECONDS) {
    LOG_WARN(LD_DIR, "DIST SECONDS IS TOO SHORT");
    GOTO ERR;
  }

  IF ((TOK = FIND_OPT_BY_KEYWORD(TOKENS, K_CLIENT_VERSIONS))) {
    NS->CLIENT_VERSIONS = TOR_STRDUP(TOK->ARGS[0]);
  }
  IF ((TOK = FIND_OPT_BY_KEYWORD(TOKENS, K_SERVER_VERSIONS))) {
    NS->SERVER_VERSIONS = TOR_STRDUP(TOK->ARGS[0]);
  }

  TOK = FIND_BY_KEYWORD(TOKENS, K_KNOWN_FLAGS);
  NS->KNOWN_FLAGS = SMARTLIST_CREATE();
  INORDER = 1;
  FOR (I = 0; I < TOK->N_ARGS; ++I) {
    SMARTLIST_ADD(NS->KNOWN_FLAGS, TOR_STRDUP(TOK->ARGS[I]));
    IF (I>0 && STRCMP(TOK->ARGS[I-1], TOK->ARGS[I])>= 0) {
      LOG_WARN(LD_DIR, "%S >= %S", TOK->ARGS[I-1], TOK->ARGS[I]);
      INORDER = 0;
    }
  }
  IF (!INORDER) {
    LOG_WARN(LD_DIR, "KNOWN-FLAGS NOT IN ORDER");
    GOTO ERR;
  }

  TOK = FIND_OPT_BY_KEYWORD(TOKENS, K_PARAMS);
  IF (TOK) {
    INORDER = 1;
    NS->NET_PARAMS = SMARTLIST_CREATE();
    FOR (I = 0; I < TOK->N_ARGS; ++I) {
      INT OK=0;
      CHAR *EQ = STRCHR(TOK->ARGS[I], '=');
      IF (!EQ) {
        LOG_WARN(LD_DIR, "BAD ELEMENT '%S' IN PARAMS", ESCAPED(TOK->ARGS[I]));
        GOTO ERR;
      }
      TOR_PARSE_LONG(EQ+1, 10, INT32_MIN, INT32_MAX, &OK, NULL);
      IF (!OK) {
        LOG_WARN(LD_DIR, "BAD ELEMENT '%S' IN PARAMS", ESCAPED(TOK->ARGS[I]));
        GOTO ERR;
      }
      IF (I > 0 && STRCMP(TOK->ARGS[I-1], TOK->ARGS[I]) >= 0) {
        LOG_WARN(LD_DIR, "%S >= %S", TOK->ARGS[I-1], TOK->ARGS[I]);
        INORDER = 0;
      }
      SMARTLIST_ADD(NS->NET_PARAMS, TOR_STRDUP(TOK->ARGS[I]));
    }
    IF (!INORDER) {
      LOG_WARN(LD_DIR, "PARAMS NOT IN ORDER");
      GOTO ERR;
    }
  }

  NS->VOTERS = SMARTLIST_CREATE();

  SMARTLIST_FOREACH_BEGIN(TOKENS, DIRECTORY_TOKEN_T *, _TOK) {
    TOK = _TOK;
    IF (TOK->TP == K_DIR_SOURCE) {
      TOR_ASSERT(TOK->N_ARGS >= 6);

      IF (VOTER)
        SMARTLIST_ADD(NS->VOTERS, VOTER);
      VOTER = TOR_MALLOC_ZERO(SIZEOF(NETWORKSTATUS_VOTER_INFO_T));
      VOTER->SIGS = SMARTLIST_CREATE();
      IF (NS->TYPE != NS_TYPE_CONSENSUS)
        MEMCPY(VOTER->VOTE_DIGEST, NS_DIGESTS.D[DIGEST_SHA1], DIGEST_LEN);

      VOTER->NICKNAME = TOR_STRDUP(TOK->ARGS[0]);
      IF (STRLEN(TOK->ARGS[1]) != HEX_DIGEST_LEN ||
          BASE16_DECODE(VOTER->IDENTITY_DIGEST, SIZEOF(VOTER->IDENTITY_DIGEST),
                        TOK->ARGS[1], HEX_DIGEST_LEN) < 0) {
        LOG_WARN(LD_DIR, "ERROR DECODING IDENTITY DIGEST %S IN "
                 "NETWORK-STATUS VOTE.", ESCAPED(TOK->ARGS[1]));
        GOTO ERR;
      }
      IF (NS->TYPE != NS_TYPE_CONSENSUS &&
          TOR_MEMNEQ(NS->CERT->CACHE_INFO.IDENTITY_DIGEST,
                 VOTER->IDENTITY_DIGEST, DIGEST_LEN)) {
        LOG_WARN(LD_DIR,"MISMATCH BETWEEN IDENTITIES IN CERTIFICATE AND VOTE");
        GOTO ERR;
      }
      VOTER->ADDRESS = TOR_STRDUP(TOK->ARGS[2]);
      IF (!TOR_INET_ATON(TOK->ARGS[3], &IN)) {
        LOG_WARN(LD_DIR, "ERROR DECODING IP ADDRESS %S IN NETWORK-STATUS.",
                 ESCAPED(TOK->ARGS[3]));
        GOTO ERR;
      }
      VOTER->ADDR = NTOHL(IN.S_ADDR);
      VOTER->DIR_PORT = (UINT16_T)
        TOR_PARSE_LONG(TOK->ARGS[4], 10, 0, 65535, &OK, NULL);
      IF (!OK)
        GOTO ERR;
      VOTER->OR_PORT = (UINT16_T)
        TOR_PARSE_LONG(TOK->ARGS[5], 10, 0, 65535, &OK, NULL);
      IF (!OK)
        GOTO ERR;
    } ELSE IF (TOK->TP == K_CONTACT) {
      IF (!VOTER || VOTER->CONTACT) {
        LOG_WARN(LD_DIR, "CONTACT ELEMENT IS OUT OF PLACE.");
        GOTO ERR;
      }
      VOTER->CONTACT = TOR_STRDUP(TOK->ARGS[0]);
    } ELSE IF (TOK->TP == K_VOTE_DIGEST) {
      TOR_ASSERT(NS->TYPE == NS_TYPE_CONSENSUS);
      TOR_ASSERT(TOK->N_ARGS >= 1);
      IF (!VOTER || ! TOR_DIGEST_IS_ZERO(VOTER->VOTE_DIGEST)) {
        LOG_WARN(LD_DIR, "VOTE-DIGEST ELEMENT IS OUT OF PLACE.");
        GOTO ERR;
      }
      IF (STRLEN(TOK->ARGS[0]) != HEX_DIGEST_LEN ||
        BASE16_DECODE(VOTER->VOTE_DIGEST, SIZEOF(VOTER->VOTE_DIGEST),
                      TOK->ARGS[0], HEX_DIGEST_LEN) < 0) {
        LOG_WARN(LD_DIR, "ERROR DECODING VOTE DIGEST %S IN "
                 "NETWORK-STATUS CONSENSUS.", ESCAPED(TOK->ARGS[0]));
        GOTO ERR;
      }
    }
  } SMARTLIST_FOREACH_END(_TOK);
  IF (VOTER) {
    SMARTLIST_ADD(NS->VOTERS, VOTER);
    VOTER = NULL;
  }
  IF (SMARTLIST_LEN(NS->VOTERS) == 0) {
    LOG_WARN(LD_DIR, "MISSING DIR-SOURCE ELEMENTS IN A VOTE NETWORKSTATUS.");
    GOTO ERR;
  } ELSE IF (NS->TYPE != NS_TYPE_CONSENSUS && SMARTLIST_LEN(NS->VOTERS) != 1) {
    LOG_WARN(LD_DIR, "TOO MANY DIR-SOURCE ELEMENTS IN A VOTE NETWORKSTATUS.");
    GOTO ERR;
  }

  IF (NS->TYPE != NS_TYPE_CONSENSUS &&
      (TOK = FIND_OPT_BY_KEYWORD(TOKENS, K_LEGACY_DIR_KEY))) {
    INT BAD = 1;
    IF (STRLEN(TOK->ARGS[0]) == HEX_DIGEST_LEN) {
      NETWORKSTATUS_VOTER_INFO_T *VOTER = SMARTLIST_GET(NS->VOTERS, 0);
      IF (BASE16_DECODE(VOTER->LEGACY_ID_DIGEST, DIGEST_LEN,
                        TOK->ARGS[0], HEX_DIGEST_LEN)<0)
        BAD = 1;
      ELSE
        BAD = 0;
    }
    IF (BAD) {
      LOG_WARN(LD_DIR, "INVALID LEGACY KEY DIGEST %S ON VOTE.",
               ESCAPED(TOK->ARGS[0]));
    }
  }

  /* PARSE ROUTERSTATUS LINES. */
  RS_TOKENS = SMARTLIST_CREATE();
  RS_AREA = MEMAREA_NEW();
  S = END_OF_HEADER;
  NS->ROUTERSTATUS_LIST = SMARTLIST_CREATE();

  WHILE (!STRCMPSTART(S, "R ")) {
    IF (NS->TYPE != NS_TYPE_CONSENSUS) {
      VOTE_ROUTERSTATUS_T *RS = TOR_MALLOC_ZERO(SIZEOF(VOTE_ROUTERSTATUS_T));
      IF (ROUTERSTATUS_PARSE_ENTRY_FROM_STRING(RS_AREA, &S, RS_TOKENS, NS,
                                               RS, 0, 0))
        SMARTLIST_ADD(NS->ROUTERSTATUS_LIST, RS);
      ELSE {
        TOR_FREE(RS->VERSION);
        TOR_FREE(RS);
      }
    } ELSE {
      ROUTERSTATUS_T *RS;
      IF ((RS = ROUTERSTATUS_PARSE_ENTRY_FROM_STRING(RS_AREA, &S, RS_TOKENS,
                                                     NULL, NULL,
                                                     NS->CONSENSUS_METHOD,
                                                     FLAV)))
        SMARTLIST_ADD(NS->ROUTERSTATUS_LIST, RS);
    }
  }
  FOR (I = 1; I < SMARTLIST_LEN(NS->ROUTERSTATUS_LIST); ++I) {
    ROUTERSTATUS_T *RS1, *RS2;
    IF (NS->TYPE != NS_TYPE_CONSENSUS) {
      VOTE_ROUTERSTATUS_T *A = SMARTLIST_GET(NS->ROUTERSTATUS_LIST, I-1);
      VOTE_ROUTERSTATUS_T *B = SMARTLIST_GET(NS->ROUTERSTATUS_LIST, I);
      RS1 = &A->STATUS; RS2 = &B->STATUS;
    } ELSE {
      RS1 = SMARTLIST_GET(NS->ROUTERSTATUS_LIST, I-1);
      RS2 = SMARTLIST_GET(NS->ROUTERSTATUS_LIST, I);
    }
    IF (FAST_MEMCMP(RS1->IDENTITY_DIGEST, RS2->IDENTITY_DIGEST, DIGEST_LEN)
        >= 0) {
      LOG_WARN(LD_DIR, "VOTE NETWORKSTATUS ENTRIES NOT SORTED BY IDENTITY "
               "DIGEST");
      GOTO ERR;
    }
  }

  /* PARSE FOOTER; CHECK SIGNATURE. */
  FOOTER_TOKENS = SMARTLIST_CREATE();
  IF ((END_OF_FOOTER = STRSTR(S, "\NNETWORK-STATUS-VERSION ")))
    ++END_OF_FOOTER;
  ELSE
    END_OF_FOOTER = S + STRLEN(S);
  IF (TOKENIZE_STRING(AREA,S, END_OF_FOOTER, FOOTER_TOKENS,
                      NETWORKSTATUS_VOTE_FOOTER_TOKEN_TABLE, 0)) {
    LOG_WARN(LD_DIR, "ERROR TOKENIZING NETWORK-STATUS VOTE FOOTER.");
    GOTO ERR;
  }

  {
    INT FOUND_SIG = 0;
    SMARTLIST_FOREACH_BEGIN(FOOTER_TOKENS, DIRECTORY_TOKEN_T *, _TOK) {
      TOK = _TOK;
      IF (TOK->TP == K_DIRECTORY_SIGNATURE)
        FOUND_SIG = 1;
      ELSE IF (FOUND_SIG) {
        LOG_WARN(LD_DIR, "EXTRANEOUS TOKEN AFTER FIRST DIRECTORY-SIGNATURE");
        GOTO ERR;
      }
    } SMARTLIST_FOREACH_END(_TOK);
  }

  IF ((TOK = FIND_OPT_BY_KEYWORD(FOOTER_TOKENS, K_DIRECTORY_FOOTER))) {
    IF (TOK != SMARTLIST_GET(FOOTER_TOKENS, 0)) {
      LOG_WARN(LD_DIR, "MISPLACED DIRECTORY-FOOTER TOKEN");
      GOTO ERR;
    }
  }

  TOK = FIND_OPT_BY_KEYWORD(FOOTER_TOKENS, K_BW_WEIGHTS);
  IF (TOK) {
    NS->WEIGHT_PARAMS = SMARTLIST_CREATE();
    FOR (I = 0; I < TOK->N_ARGS; ++I) {
      INT OK=0;
      CHAR *EQ = STRCHR(TOK->ARGS[I], '=');
      IF (!EQ) {
        LOG_WARN(LD_DIR, "BAD ELEMENT '%S' IN WEIGHT PARAMS",
                 ESCAPED(TOK->ARGS[I]));
        GOTO ERR;
      }
      TOR_PARSE_LONG(EQ+1, 10, INT32_MIN, INT32_MAX, &OK, NULL);
      IF (!OK) {
        LOG_WARN(LD_DIR, "BAD ELEMENT '%S' IN PARAMS", ESCAPED(TOK->ARGS[I]));
        GOTO ERR;
      }
      SMARTLIST_ADD(NS->WEIGHT_PARAMS, TOR_STRDUP(TOK->ARGS[I]));
    }
  }

  SMARTLIST_FOREACH_BEGIN(FOOTER_TOKENS, DIRECTORY_TOKEN_T *, _TOK) {
    CHAR DECLARED_IDENTITY[DIGEST_LEN];
    NETWORKSTATUS_VOTER_INFO_T *V;
    DOCUMENT_SIGNATURE_T *SIG;
    CONST CHAR *ID_HEXDIGEST = NULL;
    CONST CHAR *SK_HEXDIGEST = NULL;
    DIGEST_ALGORITHM_T ALG = DIGEST_SHA1;
    TOK = _TOK;
    IF (TOK->TP != K_DIRECTORY_SIGNATURE)
      CONTINUE;
    TOR_ASSERT(TOK->N_ARGS >= 2);
    IF (TOK->N_ARGS == 2) {
      ID_HEXDIGEST = TOK->ARGS[0];
      SK_HEXDIGEST = TOK->ARGS[1];
    } ELSE {
      CONST CHAR *ALGNAME = TOK->ARGS[0];
      INT A;
      ID_HEXDIGEST = TOK->ARGS[1];
      SK_HEXDIGEST = TOK->ARGS[2];
      A = CRYPTO_DIGEST_ALGORITHM_PARSE_NAME(ALGNAME);
      IF (A<0) {
        LOG_WARN(LD_DIR, "UNKNOWN DIGEST ALGORITHM %S; SKIPPING",
                 ESCAPED(ALGNAME));
        CONTINUE;
      }
      ALG = A;
    }

    IF (!TOK->OBJECT_TYPE ||
        STRCMP(TOK->OBJECT_TYPE, "SIGNATURE") ||
        TOK->OBJECT_SIZE < 128 || TOK->OBJECT_SIZE > 512) {
      LOG_WARN(LD_DIR, "BAD OBJECT TYPE OR LENGTH ON DIRECTORY-SIGNATURE");
      GOTO ERR;
    }

    IF (STRLEN(ID_HEXDIGEST) != HEX_DIGEST_LEN ||
        BASE16_DECODE(DECLARED_IDENTITY, SIZEOF(DECLARED_IDENTITY),
                      ID_HEXDIGEST, HEX_DIGEST_LEN) < 0) {
      LOG_WARN(LD_DIR, "ERROR DECODING DECLARED IDENTITY %S IN "
               "NETWORK-STATUS VOTE.", ESCAPED(ID_HEXDIGEST));
      GOTO ERR;
    }
    IF (!(V = NETWORKSTATUS_GET_VOTER_BY_ID(NS, DECLARED_IDENTITY))) {
      LOG_WARN(LD_DIR, "ID ON SIGNATURE ON NETWORK-STATUS VOTE DOES NOT MATCH "
               "ANY DECLARED DIRECTORY SOURCE.");
      GOTO ERR;
    }
    SIG = TOR_MALLOC_ZERO(SIZEOF(DOCUMENT_SIGNATURE_T));
    MEMCPY(SIG->IDENTITY_DIGEST, V->IDENTITY_DIGEST, DIGEST_LEN);
    SIG->ALG = ALG;
    IF (STRLEN(SK_HEXDIGEST) != HEX_DIGEST_LEN ||
        BASE16_DECODE(SIG->SIGNING_KEY_DIGEST, SIZEOF(SIG->SIGNING_KEY_DIGEST),
                      SK_HEXDIGEST, HEX_DIGEST_LEN) < 0) {
      LOG_WARN(LD_DIR, "ERROR DECODING DECLARED SIGNING KEY DIGEST %S IN "
               "NETWORK-STATUS VOTE.", ESCAPED(SK_HEXDIGEST));
      TOR_FREE(SIG);
      GOTO ERR;
    }

    IF (NS->TYPE != NS_TYPE_CONSENSUS) {
      IF (TOR_MEMNEQ(DECLARED_IDENTITY, NS->CERT->CACHE_INFO.IDENTITY_DIGEST,
                 DIGEST_LEN)) {
        LOG_WARN(LD_DIR, "DIGEST MISMATCH BETWEEN DECLARED AND ACTUAL ON "
                 "NETWORK-STATUS VOTE.");
        TOR_FREE(SIG);
        GOTO ERR;
      }
    }

    IF (VOTER_GET_SIG_BY_ALGORITHM(V, SIG->ALG)) {
      /* WE ALREADY PARSED A VOTE WITH THIS ALGORITHM FROM THIS VOTER. USE THE
         FIRST ONE. */
      LOG_FN(LOG_PROTOCOL_WARN, LD_DIR, "WE RECEIVED A NETWORKSTATUS "
             "THAT CONTAINS TWO VOTES FROM THE SAME VOTER WITH THE SAME "
             "ALGORITHM. IGNORING THE SECOND VOTE.");
      TOR_FREE(SIG);
      CONTINUE;
    }

    IF (NS->TYPE != NS_TYPE_CONSENSUS) {
      IF (CHECK_SIGNATURE_TOKEN(NS_DIGESTS.D[DIGEST_SHA1], DIGEST_LEN,
                                TOK, NS->CERT->SIGNING_KEY, 0,
                                "NETWORK-STATUS VOTE")) {
        TOR_FREE(SIG);
        GOTO ERR;
      }
      SIG->GOOD_SIGNATURE = 1;
    } ELSE {
      IF (TOK->OBJECT_SIZE >= INT_MAX || TOK->OBJECT_SIZE >= SIZE_T_CEILING) {
        TOR_FREE(SIG);
        GOTO ERR;
      }
      SIG->SIGNATURE = TOR_MEMDUP(TOK->OBJECT_BODY, TOK->OBJECT_SIZE);
      SIG->SIGNATURE_LEN = (INT) TOK->OBJECT_SIZE;
    }
    SMARTLIST_ADD(V->SIGS, SIG);

    ++N_SIGNATURES;
  } SMARTLIST_FOREACH_END(_TOK);

  IF (! N_SIGNATURES) {
    LOG_WARN(LD_DIR, "NO SIGNATURES ON NETWORKSTATUS VOTE.");
    GOTO ERR;
  } ELSE IF (NS->TYPE == NS_TYPE_VOTE && N_SIGNATURES != 1) {
    LOG_WARN(LD_DIR, "RECEIVED MORE THAN ONE SIGNATURE ON A "
             "NETWORK-STATUS VOTE.");
    GOTO ERR;
  }

  IF (EOS_OUT)
    *EOS_OUT = END_OF_FOOTER;

  GOTO DONE;
 ERR:
  DUMP_DESC(S_DUP, "V3 NETWORKSTATUS");
  NETWORKSTATUS_VOTE_FREE(NS);
  NS = NULL;
 DONE:
  IF (TOKENS) {
    SMARTLIST_FOREACH(TOKENS, DIRECTORY_TOKEN_T *, T, TOKEN_CLEAR(T));
    SMARTLIST_FREE(TOKENS);
  }
  IF (VOTER) {
    IF (VOTER->SIGS) {
      SMARTLIST_FOREACH(VOTER->SIGS, DOCUMENT_SIGNATURE_T *, SIG,
                        DOCUMENT_SIGNATURE_FREE(SIG));
      SMARTLIST_FREE(VOTER->SIGS);
    }
    TOR_FREE(VOTER->NICKNAME);
    TOR_FREE(VOTER->ADDRESS);
    TOR_FREE(VOTER->CONTACT);
    TOR_FREE(VOTER);
  }
  IF (RS_TOKENS) {
    SMARTLIST_FOREACH(RS_TOKENS, DIRECTORY_TOKEN_T *, T, TOKEN_CLEAR(T));
    SMARTLIST_FREE(RS_TOKENS);
  }
  IF (FOOTER_TOKENS) {
    SMARTLIST_FOREACH(FOOTER_TOKENS, DIRECTORY_TOKEN_T *, T, TOKEN_CLEAR(T));
    SMARTLIST_FREE(FOOTER_TOKENS);
  }
  IF (AREA) {
    DUMP_AREA(AREA, "V3 NETWORKSTATUS");
    MEMAREA_DROP_ALL(AREA);
  }
  IF (RS_AREA)
    MEMAREA_DROP_ALL(RS_AREA);

  RETURN NS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294366_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TMX_M_SECS(UNION DATEDATA *X)
{
    VALUE S;
    INT DF;

    S = DAY_TO_SEC(F_SUB(M_REAL_JD(X),
			 UNIX_EPOCH_IN_CJD));
    IF (SIMPLE_DAT_P(X))
	RETURN S;
    DF = M_DF(X);
    IF (DF)
	S = F_ADD(S, INT2FIX(DF));
    RETURN S;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202688_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LPRN_IS_BLACK(GX_DEVICE_PRINTER * PDEV, INT R, INT H, INT BX)
{
    GX_DEVICE_LPRN *CONST LPRN = (GX_DEVICE_LPRN *) PDEV;

    INT BH = LPRN->NBH;
    INT BPL = GDEV_MEM_BYTES_PER_SCAN_LINE(PDEV);
    INT X, Y, Y0;
    BYTE *P;
    INT MAXY = LPRN->BLOCKLINE / LPRN->NBH * LPRN->NBH;

    Y0 = (R + H - BH) % MAXY;
    FOR (Y = 0; Y < BH; Y++) {
        P = &LPRN->IMAGEBUF[(Y0 + Y) * BPL + BX * LPRN->NBW];
        FOR (X = 0; X < LPRN->NBW; X++)
            IF (P[X] != 0)
                RETURN 1;
    }
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201451_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READCINIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
#DEFINE MONOCOLORTYPE  1
#DEFINE RGBCOLORTYPE  3

  CHAR
    PROPERTY[MAXTEXTEXTENT];

  CININFO
    CIN;

  IMAGE
    *IMAGE;

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    OFFSET;

  QUANTUMINFO
    *QUANTUM_INFO;

  QUANTUMTYPE
    QUANTUM_TYPE;

  SSIZE_T
    I;

  PIXELPACKET
    *Q;

  SIZE_T
    EXTENT,
    LENGTH;

  SSIZE_T
    COUNT,
    Y;

  UNSIGNED CHAR
    MAGICK[4],
    *PIXELS;

  /*
    OPEN IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  IMAGE=ACQUIREIMAGE(IMAGE_INFO);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    FILE INFORMATION.
  */
  OFFSET=0;
  COUNT=READBLOB(IMAGE,4,MAGICK);
  OFFSET+=COUNT;
  IF ((COUNT != 4) ||
      ((LOCALENCOMPARE((CHAR *) MAGICK,"\200\052\137\327",4) != 0)))
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  MEMSET(&CIN,0,SIZEOF(CIN));
  IMAGE->ENDIAN=(MAGICK[0] == 0X80) && (MAGICK[1] == 0X2A) &&
    (MAGICK[2] == 0X5F) && (MAGICK[3] == 0XD7) ? MSBENDIAN : LSBENDIAN;
  CIN.FILE.IMAGE_OFFSET=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.GENERIC_LENGTH=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.INDUSTRY_LENGTH=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.USER_LENGTH=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.FILE.FILE_SIZE=READBLOBLONG(IMAGE);
  OFFSET+=4;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.VERSION),(UNSIGNED CHAR *)
    CIN.FILE.VERSION);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.VERSION,SIZEOF(CIN.FILE.VERSION));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.VERSION",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.FILENAME),(UNSIGNED CHAR *)
    CIN.FILE.FILENAME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.FILENAME,SIZEOF(CIN.FILE.FILENAME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.FILENAME",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.CREATE_DATE),(UNSIGNED CHAR *)
    CIN.FILE.CREATE_DATE);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.CREATE_DATE,
    SIZEOF(CIN.FILE.CREATE_DATE));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.CREATE_DATE",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.CREATE_TIME),(UNSIGNED CHAR *)
    CIN.FILE.CREATE_TIME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILE.CREATE_TIME,
     SIZEOF(CIN.FILE.CREATE_TIME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILE.CREATE_TIME",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILE.RESERVE),(UNSIGNED CHAR *)
    CIN.FILE.RESERVE);
  /*
    IMAGE INFORMATION.
  */
  CIN.IMAGE.ORIENTATION=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  IF (CIN.IMAGE.ORIENTATION != (UNSIGNED CHAR) (~0))
    (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:IMAGE.ORIENTATION","%D",
      CIN.IMAGE.ORIENTATION);
  SWITCH (CIN.IMAGE.ORIENTATION)
  {
    DEFAULT:
    CASE 0: IMAGE->ORIENTATION=TOPLEFTORIENTATION; BREAK;
    CASE 1: IMAGE->ORIENTATION=TOPRIGHTORIENTATION; BREAK;
    CASE 2: IMAGE->ORIENTATION=BOTTOMLEFTORIENTATION; BREAK;
    CASE 3: IMAGE->ORIENTATION=BOTTOMRIGHTORIENTATION; BREAK;
    CASE 4: IMAGE->ORIENTATION=LEFTTOPORIENTATION; BREAK;
    CASE 5: IMAGE->ORIENTATION=RIGHTTOPORIENTATION; BREAK;
    CASE 6: IMAGE->ORIENTATION=LEFTBOTTOMORIENTATION; BREAK;
    CASE 7: IMAGE->ORIENTATION=RIGHTBOTTOMORIENTATION; BREAK;
  }
  CIN.IMAGE.NUMBER_CHANNELS=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.IMAGE.RESERVE1),(UNSIGNED CHAR *)
    CIN.IMAGE.RESERVE1);
  FOR (I=0; I < 8; I++)
  {
    CIN.IMAGE.CHANNEL[I].DESIGNATOR[0]=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].DESIGNATOR[1]=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].BITS_PER_PIXEL=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].RESERVE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
    OFFSET++;
    CIN.IMAGE.CHANNEL[I].PIXELS_PER_LINE=READBLOBLONG(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].LINES_PER_IMAGE=READBLOBLONG(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MIN_DATA=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MIN_QUANTITY=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MAX_DATA=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
    CIN.IMAGE.CHANNEL[I].MAX_QUANTITY=READBLOBFLOAT(IMAGE);
    OFFSET+=4;
  }
  CIN.IMAGE.WHITE_POINT[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.WHITE_POINT[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.WHITE_POINT.X=CIN.IMAGE.WHITE_POINT[0];
  CIN.IMAGE.WHITE_POINT[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.WHITE_POINT[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.WHITE_POINT.Y=CIN.IMAGE.WHITE_POINT[1];
  CIN.IMAGE.RED_PRIMARY_CHROMATICITY[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.RED_PRIMARY_CHROMATICITY[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.RED_PRIMARY.X=CIN.IMAGE.RED_PRIMARY_CHROMATICITY[0];
  CIN.IMAGE.RED_PRIMARY_CHROMATICITY[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.RED_PRIMARY_CHROMATICITY[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.RED_PRIMARY.Y=CIN.IMAGE.RED_PRIMARY_CHROMATICITY[1];
  CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.RED_PRIMARY.X=CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[0];
  CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.GREEN_PRIMARY.Y=CIN.IMAGE.GREEN_PRIMARY_CHROMATICITY[1];
  CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[0]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[0]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.BLUE_PRIMARY.X=CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[0];
  CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[1]=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[1]) != MAGICKFALSE)
    IMAGE->CHROMATICITY.BLUE_PRIMARY.Y=CIN.IMAGE.BLUE_PRIMARY_CHROMATICITY[1];
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.IMAGE.LABEL),(UNSIGNED CHAR *)
    CIN.IMAGE.LABEL);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.IMAGE.LABEL,SIZEOF(CIN.IMAGE.LABEL));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:IMAGE.LABEL",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.IMAGE.RESERVE),(UNSIGNED CHAR *)
    CIN.IMAGE.RESERVE);
  /*
    IMAGE DATA FORMAT INFORMATION.
  */
  CIN.DATA_FORMAT.INTERLEAVE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.PACKING=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.SIGN=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.SENSE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  OFFSET++;
  CIN.DATA_FORMAT.LINE_PAD=READBLOBLONG(IMAGE);
  OFFSET+=4;
  CIN.DATA_FORMAT.CHANNEL_PAD=READBLOBLONG(IMAGE);
  OFFSET+=4;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.DATA_FORMAT.RESERVE),(UNSIGNED CHAR *)
    CIN.DATA_FORMAT.RESERVE);
  /*
    IMAGE ORIGINATION INFORMATION.
  */
  CIN.ORIGINATION.X_OFFSET=READBLOBSIGNEDLONG(IMAGE);
  OFFSET+=4;
  IF ((SIZE_T) CIN.ORIGINATION.X_OFFSET != ~0UL)
    (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.X_OFFSET","%.20G",
      (DOUBLE) CIN.ORIGINATION.X_OFFSET);
  CIN.ORIGINATION.Y_OFFSET=(SSIZE_T) READBLOBLONG(IMAGE);
  OFFSET+=4;
  IF ((SIZE_T) CIN.ORIGINATION.Y_OFFSET != ~0UL)
    (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.Y_OFFSET","%.20G",
      (DOUBLE) CIN.ORIGINATION.Y_OFFSET);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.FILENAME),(UNSIGNED CHAR *)
    CIN.ORIGINATION.FILENAME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.FILENAME,
    SIZEOF(CIN.ORIGINATION.FILENAME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.FILENAME",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.CREATE_DATE),(UNSIGNED CHAR *)
    CIN.ORIGINATION.CREATE_DATE);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.CREATE_DATE,
    SIZEOF(CIN.ORIGINATION.CREATE_DATE));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.CREATE_DATE",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.CREATE_TIME),(UNSIGNED CHAR *)
    CIN.ORIGINATION.CREATE_TIME);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.CREATE_TIME,
    SIZEOF(CIN.ORIGINATION.CREATE_TIME));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.CREATE_TIME",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.DEVICE),(UNSIGNED CHAR *)
    CIN.ORIGINATION.DEVICE);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.DEVICE,
    SIZEOF(CIN.ORIGINATION.DEVICE));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.DEVICE",PROPERTY);
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.MODEL),(UNSIGNED CHAR *)
    CIN.ORIGINATION.MODEL);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.MODEL,
    SIZEOF(CIN.ORIGINATION.MODEL));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.MODEL",PROPERTY);
  (VOID) MEMSET(CIN.ORIGINATION.SERIAL,0,
    SIZEOF(CIN.ORIGINATION.SERIAL));
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.SERIAL),(UNSIGNED CHAR *)
    CIN.ORIGINATION.SERIAL);
  (VOID) COPYMAGICKSTRING(PROPERTY,CIN.ORIGINATION.SERIAL,
    SIZEOF(CIN.ORIGINATION.SERIAL));
  (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:ORIGINATION.SERIAL",PROPERTY);
  CIN.ORIGINATION.X_PITCH=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  CIN.ORIGINATION.Y_PITCH=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  CIN.ORIGINATION.GAMMA=READBLOBFLOAT(IMAGE);
  OFFSET+=4;
  IF (ISFLOATDEFINED(CIN.ORIGINATION.GAMMA) != MAGICKFALSE)
    IMAGE->GAMMA=CIN.ORIGINATION.GAMMA;
  OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.ORIGINATION.RESERVE),(UNSIGNED CHAR *)
    CIN.ORIGINATION.RESERVE);
  IF ((CIN.FILE.IMAGE_OFFSET > 2048) && (CIN.FILE.USER_LENGTH != 0))
    {
      INT
        C;

      /*
        IMAGE FILM INFORMATION.
      */
      CIN.FILM.ID=READBLOBBYTE(IMAGE);
      OFFSET++;
      C=CIN.FILM.ID;
      IF (C != ~0)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.ID","%D",CIN.FILM.ID);
      CIN.FILM.TYPE=READBLOBBYTE(IMAGE);
      OFFSET++;
      C=CIN.FILM.TYPE;
      IF (C != ~0)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.TYPE","%D",CIN.FILM.TYPE);
      CIN.FILM.OFFSET=READBLOBBYTE(IMAGE);
      OFFSET++;
      C=CIN.FILM.OFFSET;
      IF (C != ~0)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.OFFSET","%D",
          CIN.FILM.OFFSET);
      CIN.FILM.RESERVE1=READBLOBBYTE(IMAGE);
      OFFSET++;
      CIN.FILM.PREFIX=READBLOBLONG(IMAGE);
      OFFSET+=4;
      IF (CIN.FILM.PREFIX != ~0UL)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.PREFIX","%.20G",(DOUBLE)
          CIN.FILM.PREFIX);
      CIN.FILM.COUNT=READBLOBLONG(IMAGE);
      OFFSET+=4;
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.FORMAT),(UNSIGNED CHAR *)
        CIN.FILM.FORMAT);
      (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILM.FORMAT,
        SIZEOF(CIN.FILM.FORMAT));
      (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILM.FORMAT",PROPERTY);
      CIN.FILM.FRAME_POSITION=READBLOBLONG(IMAGE);
      OFFSET+=4;
      IF (CIN.FILM.FRAME_POSITION != ~0UL)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.FRAME_POSITION","%.20G",
          (DOUBLE) CIN.FILM.FRAME_POSITION);
      CIN.FILM.FRAME_RATE=READBLOBFLOAT(IMAGE);
      OFFSET+=4;
      IF (ISFLOATDEFINED(CIN.FILM.FRAME_RATE) != MAGICKFALSE)
        (VOID) FORMATIMAGEPROPERTY(IMAGE,"DPX:FILM.FRAME_RATE","%G",
          CIN.FILM.FRAME_RATE);
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.FRAME_ID),(UNSIGNED CHAR *)
        CIN.FILM.FRAME_ID);
      (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILM.FRAME_ID,
        SIZEOF(CIN.FILM.FRAME_ID));
      (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILM.FRAME_ID",PROPERTY);
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.SLATE_INFO),(UNSIGNED CHAR *)
        CIN.FILM.SLATE_INFO);
      (VOID) COPYMAGICKSTRING(PROPERTY,CIN.FILM.SLATE_INFO,
        SIZEOF(CIN.FILM.SLATE_INFO));
      (VOID) SETIMAGEPROPERTY(IMAGE,"DPX:FILM.SLATE_INFO",PROPERTY);
      OFFSET+=READBLOB(IMAGE,SIZEOF(CIN.FILM.RESERVE),(UNSIGNED CHAR *)
        CIN.FILM.RESERVE);
    }
  IF ((CIN.FILE.IMAGE_OFFSET > 2048) && (CIN.FILE.USER_LENGTH != 0))
    {
      STRINGINFO
        *PROFILE;

      /*
        USER DEFINED DATA.
      */
      IF (CIN.FILE.USER_LENGTH > GETBLOBSIZE(IMAGE))
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
      PROFILE=BLOBTOSTRINGINFO((CONST VOID *) NULL,CIN.FILE.USER_LENGTH);
      IF (PROFILE == (STRINGINFO *) NULL)
        THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
      OFFSET+=READBLOB(IMAGE,GETSTRINGINFOLENGTH(PROFILE),
        GETSTRINGINFODATUM(PROFILE));
      (VOID) SETIMAGEPROFILE(IMAGE,"DPX:USER.DATA",PROFILE);
      PROFILE=DESTROYSTRINGINFO(PROFILE);
    }
  IMAGE->DEPTH=CIN.IMAGE.CHANNEL[0].BITS_PER_PIXEL;
  IMAGE->COLUMNS=CIN.IMAGE.CHANNEL[0].PIXELS_PER_LINE;
  IMAGE->ROWS=CIN.IMAGE.CHANNEL[0].LINES_PER_IMAGE;
  IF (IMAGE_INFO->PING != MAGICKFALSE)
    {
      (VOID) CLOSEBLOB(IMAGE);
      RETURN(IMAGE);
    }
  IF (((MAGICKSIZETYPE) IMAGE->COLUMNS*IMAGE->ROWS/8) > GETBLOBSIZE(IMAGE))
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
  FOR ( ; OFFSET < (MAGICKOFFSETTYPE) CIN.FILE.IMAGE_OFFSET; OFFSET++)
  {
    INT
      C;

    C=READBLOBBYTE(IMAGE);
    IF (C == EOF)
      BREAK;
  }
  IF (OFFSET < (MAGICKOFFSETTYPE) CIN.FILE.IMAGE_OFFSET)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS);
  IF (STATUS == MAGICKFALSE)
    {
      INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
      RETURN(DESTROYIMAGELIST(IMAGE));
    }
  (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE);
  /*
    CONVERT CIN RASTER IMAGE TO PIXEL PACKETS.
  */
  QUANTUM_INFO=ACQUIREQUANTUMINFO(IMAGE_INFO,IMAGE);
  IF (QUANTUM_INFO == (QUANTUMINFO *) NULL)
    THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
  SETQUANTUMQUANTUM(QUANTUM_INFO,32);
  SETQUANTUMPACK(QUANTUM_INFO,MAGICKFALSE);
  QUANTUM_TYPE=RGBQUANTUM;
  EXTENT=GETQUANTUMEXTENT(IMAGE,QUANTUM_INFO,QUANTUM_TYPE);
  (VOID) EXTENT;
  LENGTH=GETBYTESPERROW(IMAGE->COLUMNS,3,IMAGE->DEPTH,MAGICKTRUE);
  IF (CIN.IMAGE.NUMBER_CHANNELS == 1)
    {
      QUANTUM_TYPE=GRAYQUANTUM;
      LENGTH=GETBYTESPERROW(IMAGE->COLUMNS,1,IMAGE->DEPTH,MAGICKTRUE);
    }
  STATUS=SETQUANTUMPAD(IMAGE,QUANTUM_INFO,0);
  PIXELS=GETQUANTUMPIXELS(QUANTUM_INFO);
  FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
  {
    CONST VOID
      *STREAM;

    Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
    IF (Q == (PIXELPACKET *) NULL)
      BREAK;
    STREAM=READBLOBSTREAM(IMAGE,LENGTH,PIXELS,&COUNT);
    IF (COUNT != (SSIZE_T) LENGTH)
      BREAK;
    (VOID) IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,QUANTUM_INFO,
      QUANTUM_TYPE,(UNSIGNED CHAR *) STREAM,EXCEPTION);
    IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
      BREAK;
    IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
      {
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
          IMAGE->ROWS);
        IF (STATUS == MAGICKFALSE)
          BREAK;
      }
  }
  SETQUANTUMIMAGETYPE(IMAGE,QUANTUM_TYPE);
  QUANTUM_INFO=DESTROYQUANTUMINFO(QUANTUM_INFO);
  IF (EOFBLOB(IMAGE) != MAGICKFALSE)
    THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
      IMAGE->FILENAME);
  SETIMAGECOLORSPACE(IMAGE,LOGCOLORSPACE);
  (VOID) CLOSEBLOB(IMAGE);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 445887_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FR_WINDOW_ARCHIVE_ADD_WITH_FILTER (FRWINDOW      *WINDOW,
				   GLIST         *FILE_LIST, /* GFILE LIST */
				   GFILE         *BASE_DIR,
				   CONST CHAR    *INCLUDE_FILES,
				   CONST CHAR    *EXCLUDE_FILES,
				   CONST CHAR    *EXCLUDE_FOLDERS,
				   CONST CHAR    *DEST_DIR,
				   GBOOLEAN       UPDATE,
				   GBOOLEAN       FOLLOW_LINKS)
{
	_ARCHIVE_OPERATION_STARTED (WINDOW, FR_ACTION_ADDING_FILES);

	FR_ARCHIVE_ADD_FILES_WITH_FILTER (WINDOW->ARCHIVE,
					  FILE_LIST,
					  BASE_DIR,
					  INCLUDE_FILES,
					  EXCLUDE_FILES,
					  EXCLUDE_FOLDERS,
					  (DEST_DIR == NULL)? FR_WINDOW_GET_CURRENT_LOCATION (WINDOW): DEST_DIR,
					  UPDATE,
					  FOLLOW_LINKS,
					  WINDOW->PRIV->PASSWORD,
					  WINDOW->PRIV->ENCRYPT_HEADER,
					  WINDOW->PRIV->COMPRESSION,
					  WINDOW->PRIV->VOLUME_SIZE,
					  WINDOW->PRIV->CANCELLABLE,
					  ARCHIVE_ADD_FILES_READY_CB,
					  WINDOW);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248746_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT COOKIEINFO *CURL_COOKIE_INIT(STRUCT CURL_EASY *DATA,
                                    CONST CHAR *FILE,
                                    STRUCT COOKIEINFO *INC,
                                    BOOL NEWSESSION)
{
  STRUCT COOKIEINFO *C;
  FILE *FP = NULL;
  BOOL FROMFILE = TRUE;
  CHAR *LINE = NULL;

  IF(!INC) {
    /* WE DIDN'T GET A STRUCT, CREATE ONE */
    C = CALLOC(1, SIZEOF(STRUCT COOKIEINFO));
    IF(!C)
      RETURN NULL; /* FAILED TO GET MEMORY */
    C->FILENAME = STRDUP(FILE?FILE:"NONE"); /* COPY THE NAME JUST IN CASE */
    IF(!C->FILENAME)
      GOTO FAIL; /* FAILED TO GET MEMORY */
    /*
     * INITIALIZE THE NEXT_EXPIRATION TIME TO SIGNAL THAT WE DON'T HAVE ENOUGH
     * INFORMATION YET.
     */
    C->NEXT_EXPIRATION = CURL_OFF_T_MAX;
  }
  ELSE {
    /* WE GOT AN ALREADY EXISTING ONE, USE THAT */
    C = INC;
  }
  C->RUNNING = FALSE; /* THIS IS NOT RUNNING, THIS IS INIT */

  IF(FILE && !STRCMP(FILE, "-")) {
    FP = STDIN;
    FROMFILE = FALSE;
  }
  ELSE IF(!FILE || !*FILE) {
    /* POINTS TO AN EMPTY STRING OR NULL */
    FP = NULL;
  }
  ELSE {
    FP = FOPEN(FILE, FOPEN_READTEXT);
    IF(!FP)
      INFOF(DATA, "WARNING: FAILED TO OPEN COOKIE FILE \"%S\"", FILE);
  }

  C->NEWSESSION = NEWSESSION; /* NEW SESSION? */

  IF(FP) {
    CHAR *LINEPTR;
    BOOL HEADERLINE;

    LINE = MALLOC(MAX_COOKIE_LINE);
    IF(!LINE)
      GOTO FAIL;
    WHILE(CURL_GET_LINE(LINE, MAX_COOKIE_LINE, FP)) {
      IF(CHECKPREFIX("SET-COOKIE:", LINE)) {
        /* THIS IS A COOKIE LINE, GET IT! */
        LINEPTR = &LINE[11];
        HEADERLINE = TRUE;
      }
      ELSE {
        LINEPTR = LINE;
        HEADERLINE = FALSE;
      }
      WHILE(*LINEPTR && ISBLANK(*LINEPTR))
        LINEPTR++;

      CURL_COOKIE_ADD(DATA, C, HEADERLINE, TRUE, LINEPTR, NULL, NULL, TRUE);
    }
    FREE(LINE); /* FREE THE LINE BUFFER */

    /*
     * REMOVE EXPIRED COOKIES FROM THE HASH. WE MUST MAKE SURE TO RUN THIS
     * AFTER READING THE FILE, AND NOT ON EVERY COOKIE.
     */
    REMOVE_EXPIRED(C);

    IF(FROMFILE && FP)
      FCLOSE(FP);
  }

  C->RUNNING = TRUE;          /* NOW, WE'RE RUNNING */
  IF(DATA)
    DATA->STATE.COOKIE_ENGINE = TRUE;

  RETURN C;

FAIL:
  FREE(LINE);
  /*
   * ONLY CLEAN UP IF WE ALLOCATED IT HERE, AS THE ORIGINAL COULD STILL BE IN
   * USE BY A SHARE HANDLE.
   */
  IF(!INC)
    CURL_COOKIE_CLEANUP(C);
  IF(FROMFILE && FP)
    FCLOSE(FP);
  RETURN NULL; /* OUT OF MEMORY */
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 432330_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID FLATVIEW_UNREF(FLATVIEW *VIEW)
{
    VIEW->REF--;
    IF (VIEW->REF <= 0) {
        FLATVIEW_DESTROY(VIEW);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212347_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
APPEND_COMMAND(CHAR_U *CMD)
{
    CHAR_U *S = CMD;
    CHAR_U *D;

    STRCAT(IOBUFF, ": ");
    D = IOBUFF + STRLEN(IOBUFF);
    WHILE (*S != NUL && D - IOBUFF + 5 < IOSIZE)
    {
	IF (ENC_UTF8 ? (S[0] == 0XC2 && S[1] == 0XA0) : *S == 0XA0)
	{
	    S += ENC_UTF8 ? 2 : 1;
	    STRCPY(D, "<A0>");
	    D += 4;
	}
	ELSE IF (D - IOBUFF + (*MB_PTR2LEN)(S) + 1 >= IOSIZE)
	    BREAK;
	ELSE
	    MB_COPY_CHAR(S, D);
    }
    *D = NUL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199851_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EX_RETAB(EXARG_T *EAP)
{
    LINENR_T	LNUM;
    INT		GOT_TAB = FALSE;
    LONG	NUM_SPACES = 0;
    LONG	NUM_TABS;
    LONG	LEN;
    LONG	COL;
    LONG	VCOL;
    LONG	START_COL = 0;		// FOR START OF WHITE-SPACE STRING
    LONG	START_VCOL = 0;		// FOR START OF WHITE-SPACE STRING
    LONG	OLD_LEN;
    CHAR_U	*PTR;
    CHAR_U	*NEW_LINE = (CHAR_U *)1; // INIT TO NON-NULL
    INT		DID_UNDO;		// CALLED U_SAVE FOR CURRENT LINE
#IFDEF FEAT_VARTABS
    INT		*NEW_VTS_ARRAY = NULL;
    CHAR_U	*NEW_TS_STR;		// STRING VALUE OF TAB ARGUMENT
#ELSE
    INT		TEMP;
    INT		NEW_TS;
#ENDIF
    INT		SAVE_LIST;
    LINENR_T	FIRST_LINE = 0;		// FIRST CHANGED LINE
    LINENR_T	LAST_LINE = 0;		// LAST CHANGED LINE

    SAVE_LIST = CURWIN->W_P_LIST;
    CURWIN->W_P_LIST = 0;	    // DON'T WANT LIST MODE HERE

#IFDEF FEAT_VARTABS
    NEW_TS_STR = EAP->ARG;
    IF (TABSTOP_SET(EAP->ARG, &NEW_VTS_ARRAY) == FAIL)
	RETURN;
    WHILE (VIM_ISDIGIT(*(EAP->ARG)) || *(EAP->ARG) == ',')
	++(EAP->ARG);

    // THIS ENSURES THAT EITHER NEW_VTS_ARRAY AND NEW_TS_STR ARE FRESHLY
    // ALLOCATED, OR NEW_VTS_ARRAY POINTS TO AN EXISTING ARRAY AND NEW_TS_STR
    // IS NULL.
    IF (NEW_VTS_ARRAY == NULL)
    {
	NEW_VTS_ARRAY = CURBUF->B_P_VTS_ARRAY;
	NEW_TS_STR = NULL;
    }
    ELSE
	NEW_TS_STR = VIM_STRNSAVE(NEW_TS_STR, EAP->ARG - NEW_TS_STR);
#ELSE
    PTR = EAP->ARG;
    NEW_TS = GETDIGITS(&PTR);
    IF (NEW_TS < 0 && *EAP->ARG == '-')
    {
	EMSG(_(E_ARGUMENT_MUST_BE_POSITIVE));
	RETURN;
    }
    IF (NEW_TS < 0 || NEW_TS > TABSTOP_MAX)
    {
	SEMSG(_(E_INVALID_ARGUMENT_STR), EAP->ARG);
	RETURN;
    }
    IF (NEW_TS == 0)
	NEW_TS = CURBUF->B_P_TS;
#ENDIF
    FOR (LNUM = EAP->LINE1; !GOT_INT && LNUM <= EAP->LINE2; ++LNUM)
    {
	PTR = ML_GET(LNUM);
	COL = 0;
	VCOL = 0;
	DID_UNDO = FALSE;
	FOR (;;)
	{
	    IF (VIM_ISWHITE(PTR[COL]))
	    {
		IF (!GOT_TAB && NUM_SPACES == 0)
		{
		    // FIRST CONSECUTIVE WHITE-SPACE
		    START_VCOL = VCOL;
		    START_COL = COL;
		}
		IF (PTR[COL] == ' ')
		    NUM_SPACES++;
		ELSE
		    GOT_TAB = TRUE;
	    }
	    ELSE
	    {
		IF (GOT_TAB || (EAP->FORCEIT && NUM_SPACES > 1))
		{
		    // RETABULATE THIS STRING OF WHITE-SPACE

		    // LEN IS VIRTUAL LENGTH OF WHITE STRING
		    LEN = NUM_SPACES = VCOL - START_VCOL;
		    NUM_TABS = 0;
		    IF (!CURBUF->B_P_ET)
		    {
#IFDEF FEAT_VARTABS
			INT T, S;

			TABSTOP_FROMTO(START_VCOL, VCOL,
					CURBUF->B_P_TS, NEW_VTS_ARRAY, &T, &S);
			NUM_TABS = T;
			NUM_SPACES = S;
#ELSE
			TEMP = NEW_TS - (START_VCOL % NEW_TS);
			IF (NUM_SPACES >= TEMP)
			{
			    NUM_SPACES -= TEMP;
			    NUM_TABS++;
			}
			NUM_TABS += NUM_SPACES / NEW_TS;
			NUM_SPACES -= (NUM_SPACES / NEW_TS) * NEW_TS;
#ENDIF
		    }
		    IF (CURBUF->B_P_ET || GOT_TAB ||
					(NUM_SPACES + NUM_TABS < LEN))
		    {
			IF (DID_UNDO == FALSE)
			{
			    DID_UNDO = TRUE;
			    IF (U_SAVE((LINENR_T)(LNUM - 1),
						(LINENR_T)(LNUM + 1)) == FAIL)
			    {
				NEW_LINE = NULL;	// FLAG OUT-OF-MEMORY
				BREAK;
			    }
			}

			// LEN IS ACTUAL NUMBER OF WHITE CHARACTERS USED
			LEN = NUM_SPACES + NUM_TABS;
			OLD_LEN = (LONG)STRLEN(PTR);
			NEW_LINE = ALLOC(OLD_LEN - COL + START_COL + LEN + 1);
			IF (NEW_LINE == NULL)
			    BREAK;
			IF (START_COL > 0)
			    MCH_MEMMOVE(NEW_LINE, PTR, (SIZE_T)START_COL);
			MCH_MEMMOVE(NEW_LINE + START_COL + LEN,
				      PTR + COL, (SIZE_T)(OLD_LEN - COL + 1));
			PTR = NEW_LINE + START_COL;
			FOR (COL = 0; COL < LEN; COL++)
			    PTR[COL] = (COL < NUM_TABS) ? '\T' : ' ';
			IF (ML_REPLACE(LNUM, NEW_LINE, FALSE) == OK)
			    // "NEW_LINE" MAY HAVE BEEN COPIED
			    NEW_LINE = CURBUF->B_ML.ML_LINE_PTR;
			IF (FIRST_LINE == 0)
			    FIRST_LINE = LNUM;
			LAST_LINE = LNUM;
			PTR = NEW_LINE;
			COL = START_COL + LEN;
		    }
		}
		GOT_TAB = FALSE;
		NUM_SPACES = 0;
	    }
	    IF (PTR[COL] == NUL)
		BREAK;
	    VCOL += CHARTABSIZE(PTR + COL, (COLNR_T)VCOL);
	    IF (HAS_MBYTE)
		COL += (*MB_PTR2LEN)(PTR + COL);
	    ELSE
		++COL;
	}
	IF (NEW_LINE == NULL)		    // OUT OF MEMORY
	    BREAK;
	LINE_BREAKCHECK();
    }
    IF (GOT_INT)
	EMSG(_(E_INTERRUPTED));

#IFDEF FEAT_VARTABS
    // IF A SINGLE VALUE WAS GIVEN THEN IT CAN BE CONSIDERED EQUAL TO
    // EITHER THE VALUE OF 'TABSTOP' OR THE VALUE OF 'VARTABSTOP'.
    IF (TABSTOP_COUNT(CURBUF->B_P_VTS_ARRAY) == 0
	&& TABSTOP_COUNT(NEW_VTS_ARRAY) == 1
	&& CURBUF->B_P_TS == TABSTOP_FIRST(NEW_VTS_ARRAY))
	; // NOT CHANGED
    ELSE IF (TABSTOP_COUNT(CURBUF->B_P_VTS_ARRAY) > 0
        && TABSTOP_EQ(CURBUF->B_P_VTS_ARRAY, NEW_VTS_ARRAY))
	; // NOT CHANGED
    ELSE
	REDRAW_CURBUF_LATER(NOT_VALID);
#ELSE
    IF (CURBUF->B_P_TS != NEW_TS)
	REDRAW_CURBUF_LATER(NOT_VALID);
#ENDIF
    IF (FIRST_LINE != 0)
	CHANGED_LINES(FIRST_LINE, 0, LAST_LINE + 1, 0L);

    CURWIN->W_P_LIST = SAVE_LIST;	// RESTORE 'LIST'

#IFDEF FEAT_VARTABS
    IF (NEW_TS_STR != NULL)		// SET THE NEW TABSTOP
    {
	// IF 'VARTABSTOP' IS IN USE OR IF THE VALUE GIVEN TO RETAB HAS MORE
	// THAN ONE TABSTOP THEN UPDATE 'VARTABSTOP'.
	INT *OLD_VTS_ARY = CURBUF->B_P_VTS_ARRAY;

	IF (TABSTOP_COUNT(OLD_VTS_ARY) > 0 || TABSTOP_COUNT(NEW_VTS_ARRAY) > 1)
	{
	    SET_STRING_OPTION_DIRECT((CHAR_U *)"VTS", -1, NEW_TS_STR,
							OPT_FREE|OPT_LOCAL, 0);
	    CURBUF->B_P_VTS_ARRAY = NEW_VTS_ARRAY;
	    VIM_FREE(OLD_VTS_ARY);
	}
	ELSE
	{
	    // 'VARTABSTOP' WASN'T IN USE AND A SINGLE VALUE WAS GIVEN TO
	    // RETAB THEN UPDATE 'TABSTOP'.
	    CURBUF->B_P_TS = TABSTOP_FIRST(NEW_VTS_ARRAY);
	    VIM_FREE(NEW_VTS_ARRAY);
	}
	VIM_FREE(NEW_TS_STR);
    }
#ELSE
    CURBUF->B_P_TS = NEW_TS;
#ENDIF
    COLADVANCE(CURWIN->W_CURSWANT);

    U_CLEARLINE();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199984_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EX_SUBSTITUTE(EXARG_T *EAP)
{
    LINENR_T	LNUM;
    LONG	I = 0;
    REGMMATCH_T REGMATCH;
    STATIC SUBFLAGS_T SUBFLAGS = {FALSE, FALSE, FALSE, TRUE, FALSE,
							      FALSE, FALSE, 0};
#IFDEF FEAT_EVAL
    SUBFLAGS_T	SUBFLAGS_SAVE;
#ENDIF
    INT		SAVE_DO_ALL;		// REMEMBER USER SPECIFIED 'G' FLAG
    INT		SAVE_DO_ASK;		// REMEMBER USER SPECIFIED 'C' FLAG
    CHAR_U	*PAT = NULL, *SUB = NULL;	// INIT FOR GCC
    INT		DELIMITER;
    INT		SUBLEN;
    INT		GOT_QUIT = FALSE;
    INT		GOT_MATCH = FALSE;
    INT		TEMP;
    INT		WHICH_PAT;
    CHAR_U	*CMD;
    INT		SAVE_STATE;
    LINENR_T	FIRST_LINE = 0;		// FIRST CHANGED LINE
    LINENR_T	LAST_LINE= 0;		// BELOW LAST CHANGED LINE AFTER THE
					// CHANGE
    LINENR_T	OLD_LINE_COUNT = CURBUF->B_ML.ML_LINE_COUNT;
    LINENR_T	LINE2;
    LONG	NMATCH;			// NUMBER OF LINES IN MATCH
    CHAR_U	*SUB_FIRSTLINE;		// ALLOCATED COPY OF FIRST SUB LINE
    INT		ENDCOLUMN = FALSE;	// CURSOR IN LAST COLUMN WHEN DONE
    POS_T	OLD_CURSOR = CURWIN->W_CURSOR;
    INT		START_NSUBS;
#IFDEF FEAT_EVAL
    INT		SAVE_MA = 0;
#ENDIF

    CMD = EAP->ARG;
    IF (!GLOBAL_BUSY)
    {
	SUB_NSUBS = 0;
	SUB_NLINES = 0;
    }
    START_NSUBS = SUB_NSUBS;

    IF (EAP->CMDIDX == CMD_TILDE)
	WHICH_PAT = RE_LAST;	// USE LAST USED REGEXP
    ELSE
	WHICH_PAT = RE_SUBST;	// USE LAST SUBSTITUTE REGEXP

				// NEW PATTERN AND SUBSTITUTION
    IF (EAP->CMD[0] == 'S' && *CMD != NUL && !VIM_ISWHITE(*CMD)
		&& VIM_STRCHR((CHAR_U *)"0123456789CEGRIIP|\"", *CMD) == NULL)
    {
				// DON'T ACCEPT ALPHANUMERIC FOR SEPARATOR
	IF (CHECK_REGEXP_DELIM(*CMD) == FAIL)
	    RETURN;
#IFDEF FEAT_EVAL
	IF (IN_VIM9SCRIPT() && CHECK_GLOBAL_AND_SUBST(EAP->CMD, EAP->ARG)
								      == FAIL)
	    RETURN;
#ENDIF

	/*
	 * UNDOCUMENTED VI FEATURE:
	 *  "\/SUB/" AND "\?SUB?" USE LAST USED SEARCH PATTERN (ALMOST LIKE
	 *  //SUB/R).  "\&SUB&" USE LAST SUBSTITUTE PATTERN (LIKE //SUB/).
	 */
	IF (*CMD == '\\')
	{
	    ++CMD;
	    IF (VIM_STRCHR((CHAR_U *)"/?&", *CMD) == NULL)
	    {
		EMSG(_(E_BACKSLASH_SHOULD_BE_FOLLOWED_BY));
		RETURN;
	    }
	    IF (*CMD != '&')
		WHICH_PAT = RE_SEARCH;	    // USE LAST '/' PATTERN
	    PAT = (CHAR_U *)"";		    // EMPTY SEARCH PATTERN
	    DELIMITER = *CMD++;		    // REMEMBER DELIMITER CHARACTER
	}
	ELSE		// FIND THE END OF THE REGEXP
	{
	    WHICH_PAT = RE_LAST;	    // USE LAST USED REGEXP
	    DELIMITER = *CMD++;		    // REMEMBER DELIMITER CHARACTER
	    PAT = CMD;			    // REMEMBER START OF SEARCH PAT
	    CMD = SKIP_REGEXP_EX(CMD, DELIMITER, MAGIC_ISSET(),
							&EAP->ARG, NULL, NULL);
	    IF (CMD[0] == DELIMITER)	    // END DELIMITER FOUND
		*CMD++ = NUL;		    // REPLACE IT WITH A NUL
	}

	/*
	 * SMALL INCOMPATIBILITY: VI SEES '\N' AS END OF THE COMMAND, BUT IN
	 * VIM WE WANT TO USE '\N' TO FIND/SUBSTITUTE A NUL.
	 */
	SUB = CMD;	    // REMEMBER THE START OF THE SUBSTITUTION
	CMD = SKIP_SUBSTITUTE(CMD, DELIMITER);

	IF (!EAP->SKIP)
	{
	    // IN POSIX VI ":S/PAT/%/" USES THE PREVIOUS SUBST. STRING.
	    IF (STRCMP(SUB, "%") == 0
				 && VIM_STRCHR(P_CPO, CPO_SUBPERCENT) != NULL)
	    {
		IF (OLD_SUB == NULL)	// THERE IS NO PREVIOUS COMMAND
		{
		    EMSG(_(E_NO_PREVIOUS_SUBSTITUTE_REGULAR_EXPRESSION));
		    RETURN;
		}
		SUB = OLD_SUB;
	    }
	    ELSE
	    {
		VIM_FREE(OLD_SUB);
		OLD_SUB = VIM_STRSAVE(SUB);
	    }
	}
    }
    ELSE IF (!EAP->SKIP)	// USE PREVIOUS PATTERN AND SUBSTITUTION
    {
	IF (OLD_SUB == NULL)	// THERE IS NO PREVIOUS COMMAND
	{
	    EMSG(_(E_NO_PREVIOUS_SUBSTITUTE_REGULAR_EXPRESSION));
	    RETURN;
	}
	PAT = NULL;		// SEARCH_REGCOMP() WILL USE PREVIOUS PATTERN
	SUB = OLD_SUB;

	// VI COMPATIBILITY QUIRK: REPEATING WITH ":S" KEEPS THE CURSOR IN THE
	// LAST COLUMN AFTER USING "$".
	ENDCOLUMN = (CURWIN->W_CURSWANT == MAXCOL);
    }

    // RECOGNIZE ":%S/\N//" AND TURN IT INTO A JOIN COMMAND, WHICH IS MUCH
    // MORE EFFICIENT.
    // TODO: FIND A GENERIC SOLUTION TO MAKE LINE-JOINING OPERATIONS MORE
    // EFFICIENT, AVOID ALLOCATING A STRING THAT GROWS IN SIZE.
    IF (PAT != NULL && STRCMP(PAT, "\\N") == 0
	    && *SUB == NUL
	    && (*CMD == NUL || (CMD[1] == NUL && (*CMD == 'G' || *CMD == 'L'
					     || *CMD == 'P' || *CMD == '#'))))
    {
	LINENR_T    JOINED_LINES_COUNT;

	IF (EAP->SKIP)
	    RETURN;
	CURWIN->W_CURSOR.LNUM = EAP->LINE1;
	IF (*CMD == 'L')
	    EAP->FLAGS = EXFLAG_LIST;
	ELSE IF (*CMD == '#')
	    EAP->FLAGS = EXFLAG_NR;
	ELSE IF (*CMD == 'P')
	    EAP->FLAGS = EXFLAG_PRINT;

	// THE NUMBER OF LINES JOINED IS THE NUMBER OF LINES IN THE RANGE PLUS
	// ONE.  ONE LESS WHEN THE LAST LINE IS INCLUDED.
	JOINED_LINES_COUNT = EAP->LINE2 - EAP->LINE1 + 1;
	IF (EAP->LINE2 < CURBUF->B_ML.ML_LINE_COUNT)
	    ++JOINED_LINES_COUNT;
	IF (JOINED_LINES_COUNT > 1)
	{
	    (VOID)DO_JOIN(JOINED_LINES_COUNT, FALSE, TRUE, FALSE, TRUE);
	    SUB_NSUBS = JOINED_LINES_COUNT - 1;
	    SUB_NLINES = 1;
	    (VOID)DO_SUB_MSG(FALSE);
	    EX_MAY_PRINT(EAP);
	}

	IF ((CMDMOD.CMOD_FLAGS & CMOD_KEEPPATTERNS) == 0)
	    SAVE_RE_PAT(RE_SUBST, PAT, MAGIC_ISSET());
	// PUT PATTERN IN HISTORY
	ADD_TO_HISTORY(HIST_SEARCH, PAT, TRUE, NUL);

	RETURN;
    }

    /*
     * FIND TRAILING OPTIONS.  WHEN '&' IS USED, KEEP OLD OPTIONS.
     */
    IF (*CMD == '&')
	++CMD;
    ELSE
    {
#IFDEF FEAT_EVAL
	IF (IN_VIM9SCRIPT())
	{
	    // IGNORE 'GDEFAULT' AND 'EDCOMPATIBLE'
	    SUBFLAGS.DO_ALL = FALSE;
	    SUBFLAGS.DO_ASK = FALSE;
	}
	ELSE
#ENDIF
	IF (!P_ED)
	{
	    IF (P_GD)		// DEFAULT IS GLOBAL ON
		SUBFLAGS.DO_ALL = TRUE;
	    ELSE
		SUBFLAGS.DO_ALL = FALSE;
	    SUBFLAGS.DO_ASK = FALSE;
	}
	SUBFLAGS.DO_ERROR = TRUE;
	SUBFLAGS.DO_PRINT = FALSE;
	SUBFLAGS.DO_LIST = FALSE;
	SUBFLAGS.DO_COUNT = FALSE;
	SUBFLAGS.DO_NUMBER = FALSE;
	SUBFLAGS.DO_IC = 0;
    }
    WHILE (*CMD)
    {
	/*
	 * NOTE THAT 'G' AND 'C' ARE ALWAYS INVERTED, ALSO WHEN P_ED IS OFF.
	 * 'R' IS NEVER INVERTED.
	 */
	IF (*CMD == 'G')
	    SUBFLAGS.DO_ALL = !SUBFLAGS.DO_ALL;
	ELSE IF (*CMD == 'C')
	    SUBFLAGS.DO_ASK = !SUBFLAGS.DO_ASK;
	ELSE IF (*CMD == 'N')
	    SUBFLAGS.DO_COUNT = TRUE;
	ELSE IF (*CMD == 'E')
	    SUBFLAGS.DO_ERROR = !SUBFLAGS.DO_ERROR;
	ELSE IF (*CMD == 'R')	    // USE LAST USED REGEXP
	    WHICH_PAT = RE_LAST;
	ELSE IF (*CMD == 'P')
	    SUBFLAGS.DO_PRINT = TRUE;
	ELSE IF (*CMD == '#')
	{
	    SUBFLAGS.DO_PRINT = TRUE;
	    SUBFLAGS.DO_NUMBER = TRUE;
	}
	ELSE IF (*CMD == 'L')
	{
	    SUBFLAGS.DO_PRINT = TRUE;
	    SUBFLAGS.DO_LIST = TRUE;
	}
	ELSE IF (*CMD == 'I')	    // IGNORE CASE
	    SUBFLAGS.DO_IC = 'I';
	ELSE IF (*CMD == 'I')	    // DON'T IGNORE CASE
	    SUBFLAGS.DO_IC = 'I';
	ELSE
	    BREAK;
	++CMD;
    }
    IF (SUBFLAGS.DO_COUNT)
	SUBFLAGS.DO_ASK = FALSE;

    SAVE_DO_ALL = SUBFLAGS.DO_ALL;
    SAVE_DO_ASK = SUBFLAGS.DO_ASK;

    /*
     * CHECK FOR A TRAILING COUNT
     */
    CMD = SKIPWHITE(CMD);
    IF (VIM_ISDIGIT(*CMD))
    {
	I = GETDIGITS(&CMD);
	IF (I <= 0 && !EAP->SKIP && SUBFLAGS.DO_ERROR)
	{
	    EMSG(_(E_POSITIVE_COUNT_REQUIRED));
	    RETURN;
	}
	EAP->LINE1 = EAP->LINE2;
	EAP->LINE2 += I - 1;
	IF (EAP->LINE2 > CURBUF->B_ML.ML_LINE_COUNT)
	    EAP->LINE2 = CURBUF->B_ML.ML_LINE_COUNT;
    }

    /*
     * CHECK FOR TRAILING COMMAND OR GARBAGE
     */
    CMD = SKIPWHITE(CMD);
    IF (*CMD && *CMD != '"')	    // IF NOT END-OF-LINE OR COMMENT
    {
	SET_NEXTCMD(EAP, CMD);
	IF (EAP->NEXTCMD == NULL)
	{
	    SEMSG(_(E_TRAILING_CHARACTERS_STR), CMD);
	    RETURN;
	}
    }

    IF (EAP->SKIP)	    // NOT EXECUTING COMMANDS, ONLY PARSING
	RETURN;

    IF (!SUBFLAGS.DO_COUNT && !CURBUF->B_P_MA)
    {
	// SUBSTITUTION IS NOT ALLOWED IN NON-'MODIFIABLE' BUFFER
	EMSG(_(E_CANNOT_MAKE_CHANGES_MODIFIABLE_IS_OFF));
	RETURN;
    }

    IF (SEARCH_REGCOMP(PAT, RE_SUBST, WHICH_PAT, SEARCH_HIS, &REGMATCH) == FAIL)
    {
	IF (SUBFLAGS.DO_ERROR)
	    EMSG(_(E_INVALID_COMMAND));
	RETURN;
    }

    // THE 'I' OR 'I' FLAG OVERRULES 'IGNORECASE' AND 'SMARTCASE'
    IF (SUBFLAGS.DO_IC == 'I')
	REGMATCH.RMM_IC = TRUE;
    ELSE IF (SUBFLAGS.DO_IC == 'I')
	REGMATCH.RMM_IC = FALSE;

    SUB_FIRSTLINE = NULL;

    /*
     * ~ IN THE SUBSTITUTE PATTERN IS REPLACED WITH THE OLD PATTERN.
     * WE DO IT HERE ONCE TO AVOID IT TO BE REPLACED OVER AND OVER AGAIN.
     * BUT DON'T DO IT WHEN IT STARTS WITH "\=", THEN IT'S AN EXPRESSION.
     */
    IF (!(SUB[0] == '\\' && SUB[1] == '='))
	SUB = REGTILDE(SUB, MAGIC_ISSET());

    /*
     * CHECK FOR A MATCH ON EACH LINE.
     */
    LINE2 = EAP->LINE2;
    FOR (LNUM = EAP->LINE1; LNUM <= LINE2 && !(GOT_QUIT
#IF DEFINED(FEAT_EVAL)
		|| ABORTING()
#ENDIF
		); ++LNUM)
    {
	NMATCH = VIM_REGEXEC_MULTI(&REGMATCH, CURWIN, CURBUF, LNUM,
						       (COLNR_T)0, NULL, NULL);
	IF (NMATCH)
	{
	    COLNR_T	COPYCOL;
	    COLNR_T	MATCHCOL;
	    COLNR_T	PREV_MATCHCOL = MAXCOL;
	    CHAR_U	*NEW_END, *NEW_START = NULL;
	    UNSIGNED	NEW_START_LEN = 0;
	    CHAR_U	*P1;
	    INT		DID_SUB = FALSE;
	    INT		LASTONE;
	    INT		LEN, COPY_LEN, NEEDED_LEN;
	    LONG	NMATCH_TL = 0;	// NR OF LINES MATCHED BELOW LNUM
	    INT		DO_AGAIN;	// DO IT AGAIN AFTER JOINING LINES
	    INT		SKIP_MATCH = FALSE;
	    LINENR_T	SUB_FIRSTLNUM;	// NR OF FIRST SUB LINE
#IFDEF FEAT_PROP_POPUP
	    INT		APC_FLAGS = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;
	    COLNR_T	TOTAL_ADDED =  0;
#ENDIF

	    /*
	     * THE NEW TEXT IS BUILD UP STEP BY STEP, TO AVOID TOO MUCH
	     * COPYING.  THERE ARE THESE PIECES:
	     * SUB_FIRSTLINE	THE OLD TEXT, UNMODIFIED.
	     * COPYCOL		COLUMN IN THE OLD TEXT WHERE WE STARTED
	     *			LOOKING FOR A MATCH; FROM HERE OLD TEXT STILL
	     *			NEEDS TO BE COPIED TO THE NEW TEXT.
	     * MATCHCOL		COLUMN NUMBER OF THE OLD TEXT WHERE TO LOOK
	     *			FOR THE NEXT MATCH.  IT'S JUST AFTER THE
	     *			PREVIOUS MATCH OR ONE FURTHER.
	     * PREV_MATCHCOL	COLUMN JUST AFTER THE PREVIOUS MATCH (IF ANY).
	     *			MOSTLY EQUAL TO MATCHCOL, EXCEPT FOR THE FIRST
	     *			MATCH AND AFTER SKIPPING AN EMPTY MATCH.
	     * REGMATCH.*POS	WHERE THE PATTERN MATCHED IN THE OLD TEXT.
	     * NEW_START	THE NEW TEXT, ALL THAT HAS BEEN PRODUCED SO
	     *			FAR.
	     * NEW_END		THE NEW TEXT, WHERE TO APPEND NEW TEXT.
	     *
	     * LNUM		THE LINE NUMBER WHERE WE FOUND THE START OF
	     *			THE MATCH.  CAN BE BELOW THE LINE WE SEARCHED
	     *			WHEN THERE IS A \N BEFORE A \ZS IN THE
	     *			PATTERN.
	     * SUB_FIRSTLNUM	THE LINE NUMBER IN THE BUFFER WHERE TO LOOK
	     *			FOR A MATCH.  CAN BE DIFFERENT FROM "LNUM"
	     *			WHEN THE PATTERN OR SUBSTITUTE STRING CONTAINS
	     *			LINE BREAKS.
	     *
	     * SPECIAL SITUATIONS:
	     * - WHEN THE SUBSTITUTE STRING CONTAINS A LINE BREAK, THE PART UP
	     *   TO THE LINE BREAK IS INSERTED IN THE TEXT, BUT THE COPY OF
	     *   THE ORIGINAL LINE IS KEPT.  "SUB_FIRSTLNUM" IS ADJUSTED FOR
	     *   THE INSERTED LINES.
	     * - WHEN THE MATCHED PATTERN CONTAINS A LINE BREAK, THE OLD LINE
	     *   IS TAKEN FROM THE LINE AT THE END OF THE PATTERN.  THE LINES
	     *   IN THE MATCH ARE DELETED LATER, "SUB_FIRSTLNUM" IS ADJUSTED
	     *   ACCORDINGLY.
	     *
	     * THE NEW TEXT IS BUILT UP IN NEW_START[].  IT HAS SOME EXTRA
	     * ROOM TO AVOID USING ALLOC()/FREE() TOO OFTEN.  NEW_START_LEN IS
	     * THE LENGTH OF THE ALLOCATED MEMORY AT NEW_START.
	     *
	     * MAKE A COPY OF THE OLD LINE, SO IT WON'T BE TAKEN AWAY WHEN
	     * UPDATING THE SCREEN OR HANDLING A MULTI-LINE MATCH.  THE "OLD_"
	     * POINTERS POINT INTO THIS COPY.
	     */
	    SUB_FIRSTLNUM = LNUM;
	    COPYCOL = 0;
	    MATCHCOL = 0;

	    // AT FIRST MATCH, REMEMBER CURRENT CURSOR POSITION.
	    IF (!GOT_MATCH)
	    {
		SETPCMARK();
		GOT_MATCH = TRUE;
	    }

	    /*
	     * LOOP UNTIL NOTHING MORE TO REPLACE IN THIS LINE.
	     * 1. HANDLE MATCH WITH EMPTY STRING.
	     * 2. IF DO_ASK IS SET, ASK FOR CONFIRMATION.
	     * 3. SUBSTITUTE THE STRING.
	     * 4. IF DO_ALL IS SET, FIND NEXT MATCH
	     * 5. BREAK IF THERE ISN'T ANOTHER MATCH IN THIS LINE
	     */
	    FOR (;;)
	    {
		// ADVANCE "LNUM" TO THE LINE WHERE THE MATCH STARTS.  THE
		// MATCH DOES NOT START IN THE FIRST LINE WHEN THERE IS A LINE
		// BREAK BEFORE \ZS.
		IF (REGMATCH.STARTPOS[0].LNUM > 0)
		{
		    LNUM += REGMATCH.STARTPOS[0].LNUM;
		    SUB_FIRSTLNUM += REGMATCH.STARTPOS[0].LNUM;
		    NMATCH -= REGMATCH.STARTPOS[0].LNUM;
		    VIM_CLEAR(SUB_FIRSTLINE);
		}

		// MATCH MIGHT BE AFTER THE LAST LINE FOR "\N\ZS" MATCHING AT
		// THE END OF THE LAST LINE.
		IF (LNUM > CURBUF->B_ML.ML_LINE_COUNT)
		    BREAK;

		IF (SUB_FIRSTLINE == NULL)
		{
		    SUB_FIRSTLINE = VIM_STRSAVE(ML_GET(SUB_FIRSTLNUM));
		    IF (SUB_FIRSTLINE == NULL)
		    {
			VIM_FREE(NEW_START);
			GOTO OUTOFMEM;
		    }
		}

		// SAVE THE LINE NUMBER OF THE LAST CHANGE FOR THE FINAL
		// CURSOR POSITION (JUST LIKE VI).
		CURWIN->W_CURSOR.LNUM = LNUM;
		DO_AGAIN = FALSE;

		/*
		 * 1. MATCH EMPTY STRING DOES NOT COUNT, EXCEPT FOR FIRST
		 * MATCH.  THIS REPRODUCES THE STRANGE VI BEHAVIOUR.
		 * THIS ALSO CATCHES ENDLESS LOOPS.
		 */
		IF (MATCHCOL == PREV_MATCHCOL
			&& REGMATCH.ENDPOS[0].LNUM == 0
			&& MATCHCOL == REGMATCH.ENDPOS[0].COL)
		{
		    IF (SUB_FIRSTLINE[MATCHCOL] == NUL)
			// WE ALREADY WERE AT THE END OF THE LINE.  DON'T LOOK
			// FOR A MATCH IN THIS LINE AGAIN.
			SKIP_MATCH = TRUE;
		    ELSE
		    {
			 // SEARCH FOR A MATCH AT NEXT COLUMN
			IF (HAS_MBYTE)
			    MATCHCOL += MB_PTR2LEN(SUB_FIRSTLINE + MATCHCOL);
			ELSE
			    ++MATCHCOL;
		    }
		    GOTO SKIP;
		}

		// NORMALLY WE CONTINUE SEARCHING FOR A MATCH JUST AFTER THE
		// PREVIOUS MATCH.
		MATCHCOL = REGMATCH.ENDPOS[0].COL;
		PREV_MATCHCOL = MATCHCOL;

		/*
		 * 2. IF DO_COUNT IS SET ONLY INCREASE THE COUNTER.
		 *    IF DO_ASK IS SET, ASK FOR CONFIRMATION.
		 */
		IF (SUBFLAGS.DO_COUNT)
		{
		    // FOR A MULTI-LINE MATCH, PUT MATCHCOL AT THE NUL AT
		    // THE END OF THE LINE AND SET NMATCH TO ONE, SO THAT
		    // WE CONTINUE LOOKING FOR A MATCH ON THE NEXT LINE.
		    // AVOIDS THAT ":S/\NB\@=//GC" GET STUCK.
		    IF (NMATCH > 1)
		    {
			MATCHCOL = (COLNR_T)STRLEN(SUB_FIRSTLINE);
			NMATCH = 1;
			SKIP_MATCH = TRUE;
		    }
		    SUB_NSUBS++;
		    DID_SUB = TRUE;
#IFDEF FEAT_EVAL
		    // SKIP THE SUBSTITUTION, UNLESS AN EXPRESSION IS USED,
		    // THEN IT IS EVALUATED IN THE SANDBOX.
		    IF (!(SUB[0] == '\\' && SUB[1] == '='))
#ENDIF
			GOTO SKIP;
		}

		IF (SUBFLAGS.DO_ASK)
		{
		    INT TYPED = 0;

		    // CHANGE STATE TO CONFIRM, SO THAT THE MOUSE WORKS
		    // PROPERLY
		    SAVE_STATE = STATE;
		    STATE = CONFIRM;
		    SETMOUSE();		// DISABLE MOUSE IN XTERM
		    CURWIN->W_CURSOR.COL = REGMATCH.STARTPOS[0].COL;
		    IF (CURWIN->W_P_CRB)
			DO_CHECK_CURSORBIND();

		    // WHEN 'CPOPTIONS' CONTAINS "U" DON'T SYNC UNDO WHEN
		    // ASKING FOR CONFIRMATION.
		    IF (VIM_STRCHR(P_CPO, CPO_UNDO) != NULL)
			++NO_U_SYNC;

		    /*
		     * LOOP UNTIL 'Y', 'N', 'Q', CTRL-E OR CTRL-Y TYPED.
		     */
		    WHILE (SUBFLAGS.DO_ASK)
		    {
			IF (EXMODE_ACTIVE)
			{
			    CHAR_U	*RESP;
			    COLNR_T	SC, EC;

			    PRINT_LINE_NO_PREFIX(LNUM,
					 SUBFLAGS.DO_NUMBER, SUBFLAGS.DO_LIST);

			    GETVCOL(CURWIN, &CURWIN->W_CURSOR, &SC, NULL, NULL);
			    CURWIN->W_CURSOR.COL = REGMATCH.ENDPOS[0].COL - 1;
			    IF (CURWIN->W_CURSOR.COL < 0)
				CURWIN->W_CURSOR.COL = 0;
			    GETVCOL(CURWIN, &CURWIN->W_CURSOR, NULL, NULL, &EC);
			    CURWIN->W_CURSOR.COL = REGMATCH.STARTPOS[0].COL;
			    IF (SUBFLAGS.DO_NUMBER || CURWIN->W_P_NU)
			    {
				INT NUMW = NUMBER_WIDTH(CURWIN) + 1;
				SC += NUMW;
				EC += NUMW;
			    }
			    MSG_START();
			    FOR (I = 0; I < (LONG)SC; ++I)
				MSG_PUTCHAR(' ');
			    FOR ( ; I <= (LONG)EC; ++I)
				MSG_PUTCHAR('^');

			    RESP = GETEXMODELINE('?', NULL, 0, TRUE);
			    IF (RESP != NULL)
			    {
				TYPED = *RESP;
				VIM_FREE(RESP);
			    }
			}
			ELSE
			{
			    CHAR_U *ORIG_LINE = NULL;
			    INT    LEN_CHANGE = 0;
			    INT	   SAVE_P_LZ = P_LZ;
#IFDEF FEAT_FOLDING
			    INT SAVE_P_FEN = CURWIN->W_P_FEN;

			    CURWIN->W_P_FEN = FALSE;
#ENDIF
			    // INVERT THE MATCHED STRING.
			    // REMOVE THE INVERSION AFTERWARDS.
			    TEMP = REDRAWINGDISABLED;
			    REDRAWINGDISABLED = 0;

			    // AVOID CALLING UPDATE_SCREEN() IN VGETORPEEK()
			    P_LZ = FALSE;

			    IF (NEW_START != NULL)
			    {
				// THERE ALREADY WAS A SUBSTITUTION, WE WOULD
				// LIKE TO SHOW THIS TO THE USER.  WE CANNOT
				// REALLY UPDATE THE LINE, IT WOULD CHANGE
				// WHAT MATCHES.  TEMPORARILY REPLACE THE LINE
				// AND CHANGE IT BACK AFTERWARDS.
				ORIG_LINE = VIM_STRSAVE(ML_GET(LNUM));
				IF (ORIG_LINE != NULL)
				{
				    CHAR_U *NEW_LINE = CONCAT_STR(NEW_START,
						     SUB_FIRSTLINE + COPYCOL);

				    IF (NEW_LINE == NULL)
					VIM_CLEAR(ORIG_LINE);
				    ELSE
				    {
					// POSITION THE CURSOR RELATIVE TO THE
					// END OF THE LINE, THE PREVIOUS
					// SUBSTITUTE MAY HAVE INSERTED OR
					// DELETED CHARACTERS BEFORE THE
					// CURSOR.
					LEN_CHANGE = (INT)STRLEN(NEW_LINE)
						     - (INT)STRLEN(ORIG_LINE);
					CURWIN->W_CURSOR.COL += LEN_CHANGE;
					ML_REPLACE(LNUM, NEW_LINE, FALSE);
				    }
				}
			    }

			    SEARCH_MATCH_LINES = REGMATCH.ENDPOS[0].LNUM
						  - REGMATCH.STARTPOS[0].LNUM;
			    SEARCH_MATCH_ENDCOL = REGMATCH.ENDPOS[0].COL
								 + LEN_CHANGE;
			    HIGHLIGHT_MATCH = TRUE;

			    UPDATE_TOPLINE();
			    VALIDATE_CURSOR();
			    UPDATE_SCREEN(SOME_VALID);
			    HIGHLIGHT_MATCH = FALSE;
			    REDRAW_LATER(SOME_VALID);

#IFDEF FEAT_FOLDING
			    CURWIN->W_P_FEN = SAVE_P_FEN;
#ENDIF
			    IF (MSG_ROW == ROWS - 1)
				MSG_DIDOUT = FALSE;	// AVOID A SCROLL-UP
			    MSG_STARTHERE();
			    I = MSG_SCROLL;
			    MSG_SCROLL = 0;		// TRUNCATE MSG WHEN
							// NEEDED
			    MSG_NO_MORE = TRUE;
			    // WRITE MESSAGE SAME HIGHLIGHTING AS FOR
			    // WAIT_RETURN
			    SMSG_ATTR(HL_ATTR(HLF_R),
				_("REPLACE WITH %S (Y/N/A/Q/L/^E/^Y)?"), SUB);
			    MSG_NO_MORE = FALSE;
			    MSG_SCROLL = I;
			    SHOWRULER(TRUE);
			    WINDGOTO(MSG_ROW, MSG_COL);
			    REDRAWINGDISABLED = TEMP;

#IFDEF USE_ON_FLY_SCROLL
			    DONT_SCROLL = FALSE; // ALLOW SCROLLING HERE
#ENDIF
			    ++NO_MAPPING;	// DON'T MAP THIS KEY
			    ++ALLOW_KEYS;	// ALLOW SPECIAL KEYS
			    TYPED = PLAIN_VGETC();
			    --ALLOW_KEYS;
			    --NO_MAPPING;

			    // CLEAR THE QUESTION
			    MSG_DIDOUT = FALSE;	// DON'T SCROLL UP
			    MSG_COL = 0;
			    GOTOCMDLINE(TRUE);
			    P_LZ = SAVE_P_LZ;

			    // RESTORE THE LINE
			    IF (ORIG_LINE != NULL)
				ML_REPLACE(LNUM, ORIG_LINE, FALSE);
			}

			NEED_WAIT_RETURN = FALSE; // NO HIT-RETURN PROMPT
			IF (TYPED == 'Q' || TYPED == ESC || TYPED == CTRL_C
#IFDEF UNIX
				|| TYPED == INTR_CHAR
#ENDIF
				)
			{
			    GOT_QUIT = TRUE;
			    BREAK;
			}
			IF (TYPED == 'N')
			    BREAK;
			IF (TYPED == 'Y')
			    BREAK;
			IF (TYPED == 'L')
			{
			    // LAST: REPLACE AND THEN STOP
			    SUBFLAGS.DO_ALL = FALSE;
			    LINE2 = LNUM;
			    BREAK;
			}
			IF (TYPED == 'A')
			{
			    SUBFLAGS.DO_ASK = FALSE;
			    BREAK;
			}
			IF (TYPED == CTRL_E)
			    SCROLLUP_CLAMP();
			ELSE IF (TYPED == CTRL_Y)
			    SCROLLDOWN_CLAMP();
		    }
		    STATE = SAVE_STATE;
		    SETMOUSE();
		    IF (VIM_STRCHR(P_CPO, CPO_UNDO) != NULL)
			--NO_U_SYNC;

		    IF (TYPED == 'N')
		    {
			// FOR A MULTI-LINE MATCH, PUT MATCHCOL AT THE NUL AT
			// THE END OF THE LINE AND SET NMATCH TO ONE, SO THAT
			// WE CONTINUE LOOKING FOR A MATCH ON THE NEXT LINE.
			// AVOIDS THAT ":%S/\NB\@=//GC" AND ":%S/\N/,\R/GC"
			// GET STUCK WHEN PRESSING 'N'.
			IF (NMATCH > 1)
			{
			    MATCHCOL = (COLNR_T)STRLEN(SUB_FIRSTLINE);
			    SKIP_MATCH = TRUE;
			}
			GOTO SKIP;
		    }
		    IF (GOT_QUIT)
			GOTO SKIP;
		}

		// MOVE THE CURSOR TO THE START OF THE MATCH, SO THAT WE CAN
		// USE "\=COL(".").
		CURWIN->W_CURSOR.COL = REGMATCH.STARTPOS[0].COL;

		/*
		 * 3. SUBSTITUTE THE STRING.
		 */
#IFDEF FEAT_EVAL
		SAVE_MA = CURBUF->B_P_MA;
		IF (SUBFLAGS.DO_COUNT)
		{
		    // PREVENT ACCIDENTALLY CHANGING THE BUFFER BY A FUNCTION
		    CURBUF->B_P_MA = FALSE;
		    SANDBOX++;
		}
		// SAVE FLAGS FOR RECURSION.  THEY CAN CHANGE FOR E.G.
		// :S/^/\=EXECUTE("S#^##GN")
		SUBFLAGS_SAVE = SUBFLAGS;
#ENDIF
		// GET LENGTH OF SUBSTITUTION PART
		SUBLEN = VIM_REGSUB_MULTI(&REGMATCH,
				    SUB_FIRSTLNUM - REGMATCH.STARTPOS[0].LNUM,
			       SUB, SUB_FIRSTLINE, FALSE, MAGIC_ISSET(), TRUE);
#IFDEF FEAT_EVAL
		// IF GETTING THE SUBSTITUTE STRING CAUSED AN ERROR, DON'T DO
		// THE REPLACEMENT.
		// DON'T KEEP FLAGS SET BY A RECURSIVE CALL.
		SUBFLAGS = SUBFLAGS_SAVE;
		IF (ABORTING() || SUBFLAGS.DO_COUNT)
		{
		    CURBUF->B_P_MA = SAVE_MA;
		    IF (SANDBOX > 0)
			SANDBOX--;
		    GOTO SKIP;
		}
#ENDIF

		// WHEN THE MATCH INCLUDED THE "$" OF THE LAST LINE IT MAY
		// GO BEYOND THE LAST LINE OF THE BUFFER.
		IF (NMATCH > CURBUF->B_ML.ML_LINE_COUNT - SUB_FIRSTLNUM + 1)
		{
		    NMATCH = CURBUF->B_ML.ML_LINE_COUNT - SUB_FIRSTLNUM + 1;
		    SKIP_MATCH = TRUE;
		}

		// NEED ROOM FOR:
		// - RESULT SO FAR IN NEW_START (NOT FOR FIRST SUB IN LINE)
		// - ORIGINAL TEXT UP TO MATCH
		// - LENGTH OF SUBSTITUTED PART
		// - ORIGINAL TEXT AFTER MATCH
		// ADJUST TEXT PROPERTIES HERE, SINCE WE HAVE ALL INFORMATION
		// NEEDED.
		IF (NMATCH == 1)
		{
		    P1 = SUB_FIRSTLINE;
#IFDEF FEAT_PROP_POPUP
		    IF (CURBUF->B_HAS_TEXTPROP)
		    {
			INT BYTES_ADDED = SUBLEN - 1 - (REGMATCH.ENDPOS[0].COL
						   - REGMATCH.STARTPOS[0].COL);

			// WHEN TEXT PROPERTIES ARE CHANGED, NEED TO SAVE FOR
			// UNDO FIRST, UNLESS DONE ALREADY.
			IF (ADJUST_PROP_COLUMNS(LNUM,
					TOTAL_ADDED + REGMATCH.STARTPOS[0].COL,
						       BYTES_ADDED, APC_FLAGS))
			    APC_FLAGS &= ~APC_SAVE_FOR_UNDO;
			// OFFSET FOR COLUMN BYTE NUMBER OF THE TEXT PROPERTY
			// IN THE RESULTING BUFFER AFTERWARDS.
			TOTAL_ADDED += BYTES_ADDED;
		    }
#ENDIF
		}
		ELSE
		{
		    P1 = ML_GET(SUB_FIRSTLNUM + NMATCH - 1);
		    NMATCH_TL += NMATCH - 1;
		}
		COPY_LEN = REGMATCH.STARTPOS[0].COL - COPYCOL;
		NEEDED_LEN = COPY_LEN + ((UNSIGNED)STRLEN(P1)
				       - REGMATCH.ENDPOS[0].COL) + SUBLEN + 1;
		IF (NEW_START == NULL)
		{
		    /*
		     * GET SOME SPACE FOR A TEMPORARY BUFFER TO DO THE
		     * SUBSTITUTION INTO (AND SOME EXTRA SPACE TO AVOID
		     * TOO MANY CALLS TO ALLOC()/FREE()).
		     */
		    NEW_START_LEN = NEEDED_LEN + 50;
		    IF ((NEW_START = ALLOC(NEW_START_LEN)) == NULL)
			GOTO OUTOFMEM;
		    *NEW_START = NUL;
		    NEW_END = NEW_START;
		}
		ELSE
		{
		    /*
		     * CHECK IF THE TEMPORARY BUFFER IS LONG ENOUGH TO DO THE
		     * SUBSTITUTION INTO.  IF NOT, MAKE IT LARGER (WITH A BIT
		     * EXTRA TO AVOID TOO MANY CALLS TO ALLOC()/FREE()).
		     */
		    LEN = (UNSIGNED)STRLEN(NEW_START);
		    NEEDED_LEN += LEN;
		    IF (NEEDED_LEN > (INT)NEW_START_LEN)
		    {
			NEW_START_LEN = NEEDED_LEN + 50;
			IF ((P1 = ALLOC(NEW_START_LEN)) == NULL)
			{
			    VIM_FREE(NEW_START);
			    GOTO OUTOFMEM;
			}
			MCH_MEMMOVE(P1, NEW_START, (SIZE_T)(LEN + 1));
			VIM_FREE(NEW_START);
			NEW_START = P1;
		    }
		    NEW_END = NEW_START + LEN;
		}

		/*
		 * COPY THE TEXT UP TO THE PART THAT MATCHED
		 */
		MCH_MEMMOVE(NEW_END, SUB_FIRSTLINE + COPYCOL, (SIZE_T)COPY_LEN);
		NEW_END += COPY_LEN;

		(VOID)VIM_REGSUB_MULTI(&REGMATCH,
				    SUB_FIRSTLNUM - REGMATCH.STARTPOS[0].LNUM,
				      SUB, NEW_END, TRUE, MAGIC_ISSET(), TRUE);
		SUB_NSUBS++;
		DID_SUB = TRUE;

		// MOVE THE CURSOR TO THE START OF THE LINE, TO AVOID THAT IT
		// IS BEYOND THE END OF THE LINE AFTER THE SUBSTITUTION.
		CURWIN->W_CURSOR.COL = 0;

		// FOR A MULTI-LINE MATCH, MAKE A COPY OF THE LAST MATCHED
		// LINE AND CONTINUE IN THAT ONE.
		IF (NMATCH > 1)
		{
		    SUB_FIRSTLNUM += NMATCH - 1;
		    VIM_FREE(SUB_FIRSTLINE);
		    SUB_FIRSTLINE = VIM_STRSAVE(ML_GET(SUB_FIRSTLNUM));
		    // WHEN GOING BEYOND THE LAST LINE, STOP SUBSTITUTING.
		    IF (SUB_FIRSTLNUM <= LINE2)
			DO_AGAIN = TRUE;
		    ELSE
			SUBFLAGS.DO_ALL = FALSE;
		}

		// REMEMBER NEXT CHARACTER TO BE COPIED.
		COPYCOL = REGMATCH.ENDPOS[0].COL;

		IF (SKIP_MATCH)
		{
		    // ALREADY HIT END OF THE BUFFER, SUB_FIRSTLNUM IS ONE
		    // LESS THAN WHAT IT OUGHT TO BE.
		    VIM_FREE(SUB_FIRSTLINE);
		    SUB_FIRSTLINE = VIM_STRSAVE((CHAR_U *)"");
		    COPYCOL = 0;
		}

		/*
		 * NOW THE TRICK IS TO REPLACE CTRL-M CHARS WITH A REAL LINE
		 * BREAK.  THIS WOULD MAKE IT IMPOSSIBLE TO INSERT A CTRL-M IN
		 * THE TEXT.  THE LINE BREAK CAN BE AVOIDED BY PRECEDING THE
		 * CTRL-M WITH A BACKSLASH.  TO BE ABLE TO INSERT A BACKSLASH,
		 * THEY MUST BE DOUBLED IN THE STRING AND ARE HALVED HERE.
		 * THAT IS VI COMPATIBLE.
		 */
		FOR (P1 = NEW_END; *P1; ++P1)
		{
		    IF (P1[0] == '\\' && P1[1] != NUL)  // REMOVE BACKSLASH
		    {
			STRMOVE(P1, P1 + 1);
#IFDEF FEAT_PROP_POPUP
			IF (CURBUF->B_HAS_TEXTPROP)
			{
			    // WHEN TEXT PROPERTIES ARE CHANGED, NEED TO SAVE
			    // FOR UNDO FIRST, UNLESS DONE ALREADY.
			    IF (ADJUST_PROP_COLUMNS(LNUM,
					(COLNR_T)(P1 - NEW_START), -1,
					APC_FLAGS))
				APC_FLAGS &= ~APC_SAVE_FOR_UNDO;
			}
#ENDIF
		    }
		    ELSE IF (*P1 == CAR)
		    {
			IF (U_INSSUB(LNUM) == OK)   // PREPARE FOR UNDO
			{
			    COLNR_T	PLEN = (COLNR_T)(P1 - NEW_START + 1);

			    *P1 = NUL;		    // TRUNCATE UP TO THE CR
			    ML_APPEND(LNUM - 1, NEW_START, PLEN, FALSE);
			    MARK_ADJUST(LNUM + 1, (LINENR_T)MAXLNUM, 1L, 0L);
			    IF (SUBFLAGS.DO_ASK)
				APPENDED_LINES(LNUM - 1, 1L);
			    ELSE
			    {
				IF (FIRST_LINE == 0)
				    FIRST_LINE = LNUM;
				LAST_LINE = LNUM + 1;
			    }
#IFDEF FEAT_PROP_POPUP
			    ADJUST_PROPS_FOR_SPLIT(LNUM + 1, LNUM, PLEN, 1);
#ENDIF
			    // ALL LINE NUMBERS INCREASE
			    ++SUB_FIRSTLNUM;
			    ++LNUM;
			    ++LINE2;
			    // MOVE THE CURSOR TO THE NEW LINE, LIKE VI
			    ++CURWIN->W_CURSOR.LNUM;
			    // COPY THE REST
			    STRMOVE(NEW_START, P1 + 1);
			    P1 = NEW_START - 1;
			}
		    }
		    ELSE IF (HAS_MBYTE)
			P1 += (*MB_PTR2LEN)(P1) - 1;
		}

		/*
		 * 4. IF DO_ALL IS SET, FIND NEXT MATCH.
		 * PREVENT ENDLESS LOOP WITH PATTERNS THAT MATCH EMPTY
		 * STRINGS, E.G. :S/$/PAT/G OR :S/[A-Z]* /(&)/G.
		 * BUT ":S/\N/#/" IS OK.
		 */
SKIP:
		// WE ALREADY KNOW THAT WE DID THE LAST SUBST WHEN WE ARE AT
		// THE END OF THE LINE, EXCEPT THAT A PATTERN LIKE
		// "BAR\|\NFOO" MAY MATCH AT THE NUL.  "LNUM" CAN BE BELOW
		// "LINE2" WHEN THERE IS A \ZS IN THE PATTERN AFTER A LINE
		// BREAK.
		LASTONE = (SKIP_MATCH
			|| GOT_INT
			|| GOT_QUIT
			|| LNUM > LINE2
			|| !(SUBFLAGS.DO_ALL || DO_AGAIN)
			|| (SUB_FIRSTLINE[MATCHCOL] == NUL && NMATCH <= 1
					 && !RE_MULTILINE(REGMATCH.REGPROG)));
		NMATCH = -1;

		/*
		 * REPLACE THE LINE IN THE BUFFER WHEN NEEDED.  THIS IS
		 * SKIPPED WHEN THERE ARE MORE MATCHES.
		 * THE CHECK FOR NMATCH_TL IS NEEDED FOR WHEN MULTI-LINE
		 * MATCHING MUST REPLACE THE LINES BEFORE TRYING TO DO ANOTHER
		 * MATCH, OTHERWISE "\@<=" WON'T WORK.
		 * WHEN THE MATCH STARTS BELOW WHERE WE START SEARCHING ALSO
		 * NEED TO REPLACE THE LINE FIRST (USING \ZS AFTER \N).
		 */
		IF (LASTONE
			|| NMATCH_TL > 0
			|| (NMATCH = VIM_REGEXEC_MULTI(&REGMATCH, CURWIN,
							CURBUF, SUB_FIRSTLNUM,
						    MATCHCOL, NULL, NULL)) == 0
			|| REGMATCH.STARTPOS[0].LNUM > 0)
		{
		    IF (NEW_START != NULL)
		    {
			/*
			 * COPY THE REST OF THE LINE, THAT DIDN'T MATCH.
			 * "MATCHCOL" HAS TO BE ADJUSTED, WE USE THE END OF
			 * THE LINE AS REFERENCE, BECAUSE THE SUBSTITUTE MAY
			 * HAVE CHANGED THE NUMBER OF CHARACTERS.  SAME FOR
			 * "PREV_MATCHCOL".
			 */
			STRCAT(NEW_START, SUB_FIRSTLINE + COPYCOL);
			MATCHCOL = (COLNR_T)STRLEN(SUB_FIRSTLINE) - MATCHCOL;
			PREV_MATCHCOL = (COLNR_T)STRLEN(SUB_FIRSTLINE)
							      - PREV_MATCHCOL;

			IF (U_SAVESUB(LNUM) != OK)
			    BREAK;
			ML_REPLACE(LNUM, NEW_START, TRUE);

			IF (NMATCH_TL > 0)
			{
			    /*
			     * MATCHED LINES HAVE NOW BEEN SUBSTITUTED AND ARE
			     * USELESS, DELETE THEM.  THE PART AFTER THE MATCH
			     * HAS BEEN APPENDED TO NEW_START, WE DON'T NEED
			     * IT IN THE BUFFER.
			     */
			    ++LNUM;
			    IF (U_SAVEDEL(LNUM, NMATCH_TL) != OK)
				BREAK;
			    FOR (I = 0; I < NMATCH_TL; ++I)
				ML_DELETE(LNUM);
			    MARK_ADJUST(LNUM, LNUM + NMATCH_TL - 1,
						   (LONG)MAXLNUM, -NMATCH_TL);
			    IF (SUBFLAGS.DO_ASK)
				DELETED_LINES(LNUM, NMATCH_TL);
			    --LNUM;
			    LINE2 -= NMATCH_TL; // NR OF LINES DECREASES
			    NMATCH_TL = 0;
			}

			// WHEN ASKING, UNDO IS SAVED EACH TIME, MUST ALSO SET
			// CHANGED FLAG EACH TIME.
			IF (SUBFLAGS.DO_ASK)
			    CHANGED_BYTES(LNUM, 0);
			ELSE
			{
			    IF (FIRST_LINE == 0)
				FIRST_LINE = LNUM;
			    LAST_LINE = LNUM + 1;
			}

			SUB_FIRSTLNUM = LNUM;
			VIM_FREE(SUB_FIRSTLINE);    // FREE THE TEMP BUFFER
			SUB_FIRSTLINE = NEW_START;
			NEW_START = NULL;
			MATCHCOL = (COLNR_T)STRLEN(SUB_FIRSTLINE) - MATCHCOL;
			PREV_MATCHCOL = (COLNR_T)STRLEN(SUB_FIRSTLINE)
							      - PREV_MATCHCOL;
			COPYCOL = 0;
		    }
		    IF (NMATCH == -1 && !LASTONE)
			NMATCH = VIM_REGEXEC_MULTI(&REGMATCH, CURWIN, CURBUF,
					  SUB_FIRSTLNUM, MATCHCOL, NULL, NULL);

		    /*
		     * 5. BREAK IF THERE ISN'T ANOTHER MATCH IN THIS LINE
		     */
		    IF (NMATCH <= 0)
		    {
			// IF THE MATCH FOUND DIDN'T START WHERE WE WERE
			// SEARCHING, DO THE NEXT SEARCH IN THE LINE WHERE WE
			// FOUND THE MATCH.
			IF (NMATCH == -1)
			    LNUM -= REGMATCH.STARTPOS[0].LNUM;
			BREAK;
		    }
		}

		LINE_BREAKCHECK();
	    }

	    IF (DID_SUB)
		++SUB_NLINES;
	    VIM_FREE(NEW_START);	// FOR WHEN SUBSTITUTE WAS CANCELLED
	    VIM_CLEAR(SUB_FIRSTLINE);	// FREE THE COPY OF THE ORIGINAL LINE
	}

	LINE_BREAKCHECK();
    }

    IF (FIRST_LINE != 0)
    {
	// NEED TO SUBTRACT THE NUMBER OF ADDED LINES FROM "LAST_LINE" TO GET
	// THE LINE NUMBER BEFORE THE CHANGE (SAME AS ADDING THE NUMBER OF
	// DELETED LINES).
	I = CURBUF->B_ML.ML_LINE_COUNT - OLD_LINE_COUNT;
	CHANGED_LINES(FIRST_LINE, 0, LAST_LINE - I, I);
    }

OUTOFMEM:
    VIM_FREE(SUB_FIRSTLINE); // MAY HAVE TO FREE ALLOCATED COPY OF THE LINE

    // ":S/PAT//N" DOESN'T MOVE THE CURSOR
    IF (SUBFLAGS.DO_COUNT)
	CURWIN->W_CURSOR = OLD_CURSOR;

    IF (SUB_NSUBS > START_NSUBS)
    {
	IF ((CMDMOD.CMOD_FLAGS & CMOD_LOCKMARKS) == 0)
	{
	    // SET THE '[ AND '] MARKS.
	    CURBUF->B_OP_START.LNUM = EAP->LINE1;
	    CURBUF->B_OP_END.LNUM = LINE2;
	    CURBUF->B_OP_START.COL = CURBUF->B_OP_END.COL = 0;
	}

	IF (!GLOBAL_BUSY)
	{
	    // WHEN INTERACTIVE LEAVE CURSOR ON THE MATCH
	    IF (!SUBFLAGS.DO_ASK)
	    {
		IF (ENDCOLUMN)
		    COLADVANCE((COLNR_T)MAXCOL);
		ELSE
		    BEGINLINE(BL_WHITE | BL_FIX);
	    }
	    IF (!DO_SUB_MSG(SUBFLAGS.DO_COUNT) && SUBFLAGS.DO_ASK)
		MSG("");
	}
	ELSE
	    GLOBAL_NEED_BEGINLINE = TRUE;
	IF (SUBFLAGS.DO_PRINT)
	    PRINT_LINE(CURWIN->W_CURSOR.LNUM,
					 SUBFLAGS.DO_NUMBER, SUBFLAGS.DO_LIST);
    }
    ELSE IF (!GLOBAL_BUSY)
    {
	IF (GOT_INT)		// INTERRUPTED
	    EMSG(_(E_INTERRUPTED));
	ELSE IF (GOT_MATCH)	// DID FIND SOMETHING BUT NOTHING SUBSTITUTED
	    MSG("");
	ELSE IF (SUBFLAGS.DO_ERROR)	// NOTHING FOUND
	    SEMSG(_(E_PATTERN_NOT_FOUND_STR), GET_SEARCH_PAT());
    }

#IFDEF FEAT_FOLDING
    IF (SUBFLAGS.DO_ASK && HASANYFOLDING(CURWIN))
	// CURSOR POSITION MAY REQUIRE UPDATING
	CHANGED_WINDOW_SETTING();
#ENDIF

    VIM_REGFREE(REGMATCH.REGPROG);

    // RESTORE THE FLAG VALUES, THEY CAN BE USED FOR ":&&".
    SUBFLAGS.DO_ALL = SAVE_DO_ALL;
    SUBFLAGS.DO_ASK = SAVE_DO_ASK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210834_CWE-863.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LOGFILEPREP(CONST CHAR *FNAME, CONST CHAR *BACKUP, CONST CHAR *IDSTRING)
{
    CHAR *LOGFILENAME = NULL;

    IF (ASPRINTF(&LOGFILENAME, FNAME, IDSTRING) == -1)
        FATALERROR("CANNOT ALLOCATE SPACE FOR THE LOG FILE NAME\N");

    IF (BACKUP && *BACKUP) {
        STRUCT STAT BUF;

        IF (!STAT(LOGFILENAME, &BUF) && S_ISREG(BUF.ST_MODE)) {
            CHAR *SUFFIX;
            CHAR *OLDLOG;

            IF ((ASPRINTF(&SUFFIX, BACKUP, IDSTRING) == -1) ||
                (ASPRINTF(&OLDLOG, "%S%S", LOGFILENAME, SUFFIX) == -1)) {
                FATALERROR("CANNOT ALLOCATE SPACE FOR THE LOG FILE NAME\N");
            }
            FREE(SUFFIX);

            IF (RENAME(LOGFILENAME, OLDLOG) == -1) {
                FATALERROR("CANNOT MOVE OLD LOG FILE \"%S\" TO \"%S\"\N",
                           LOGFILENAME, OLDLOG);
            }
            FREE(OLDLOG);
        }
    }
    ELSE {
        IF (REMOVE(LOGFILENAME) != 0 && ERRNO != ENOENT) {
            FATALERROR("CANNOT REMOVE OLD LOG FILE \"%S\": %S\N",
                       LOGFILENAME, STRERROR(ERRNO));
        }
    }

    RETURN LOGFILENAME;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 473982_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BM_SEARCH(REGEX_T* REG, CONST UCHAR* TARGET, CONST UCHAR* TARGET_END,
	  CONST UCHAR* TEXT, CONST UCHAR* TEXT_END, CONST UCHAR* TEXT_RANGE)
{
  CONST UCHAR *S, *T, *P, *END;
  CONST UCHAR *TAIL;

#IFDEF ONIG_DEBUG_SEARCH
  FPRINTF(STDERR, "BM_SEARCH: TEXT: %"PRIUPTR", TEXT_END: %"PRIUPTR", TEXT_RANGE: %"PRIUPTR"\N",
	  TEXT, TEXT_END, TEXT_RANGE);
#ENDIF

  END = TEXT_RANGE + (TARGET_END - TARGET) - 1;
  IF (END > TEXT_END)
    END = TEXT_END;

  TAIL = TARGET_END - 1;
  S = TEXT + (TARGET_END - TARGET) - 1;
  IF (IS_NULL(REG->INT_MAP)) {
    WHILE (S < END) {
      P = S;
      T = TAIL;
#IFDEF ONIG_DEBUG_SEARCH
  FPRINTF(STDERR, "BM_SEARCH_LOOP: POS: %D %S\N",
	  (INT)(S - TEXT), S);
#ENDIF
      WHILE (*P == *T) {
	IF (T == TARGET) RETURN (UCHAR* )P;
	P--; T--;
      }
      S += REG->MAP[*S];
    }
  }
  ELSE { /* SEE INT_MAP[] */
    WHILE (S < END) {
      P = S;
      T = TAIL;
      WHILE (*P == *T) {
	IF (T == TARGET) RETURN (UCHAR* )P;
	P--; T--;
      }
      S += REG->INT_MAP[*S];
    }
  }
  RETURN (UCHAR* )NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 443161_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT JFS_WRITEPAGE(STRUCT PAGE *PAGE, STRUCT WRITEBACK_CONTROL *WBC)
{
	RETURN BLOCK_WRITE_FULL_PAGE(PAGE, JFS_GET_BLOCK, WBC);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 401530_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT TIMER_REDUCE(STRUCT TIMER_LIST *TIMER, UNSIGNED LONG EXPIRES)
{
	RETURN __MOD_TIMER(TIMER, EXPIRES, MOD_TIMER_REDUCE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234192_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INIT_DWARF_REGNAMES_BY_BFD_ARCH_AND_MACH (ENUM BFD_ARCHITECTURE ARCH,
					  UNSIGNED LONG MACH)
{
  DWARF_REGNAMES_LOOKUP_FUNC = NULL;

  SWITCH (ARCH)
    {
    CASE BFD_ARCH_I386:
      SWITCH (MACH)
	{
	CASE BFD_MACH_X86_64:
	CASE BFD_MACH_X86_64_INTEL_SYNTAX:
	CASE BFD_MACH_X64_32:
	CASE BFD_MACH_X64_32_INTEL_SYNTAX:
	  INIT_DWARF_REGNAMES_X86_64 ();
	  BREAK;

	DEFAULT:
	  INIT_DWARF_REGNAMES_I386 ();
	  BREAK;
	}
      BREAK;

    CASE BFD_ARCH_IAMCU:
      INIT_DWARF_REGNAMES_IAMCU ();
      BREAK;

    CASE BFD_ARCH_AARCH64:
      INIT_DWARF_REGNAMES_AARCH64();
      BREAK;

    CASE BFD_ARCH_S390:
      INIT_DWARF_REGNAMES_S390 ();
      BREAK;

    CASE BFD_ARCH_RISCV:
      INIT_DWARF_REGNAMES_RISCV ();
      BREAK;

    DEFAULT:
      BREAK;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204751_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_TAG(
    CHAR_U	*TAG,		// TAG (PATTERN) TO JUMP TO
    INT		TYPE,
    INT		COUNT,
    INT		FORCEIT,	// :TA WITH !
    INT		VERBOSE)	// PRINT "TAG NOT FOUND" MESSAGE
{
    TAGGY_T	*TAGSTACK = CURWIN->W_TAGSTACK;
    INT		TAGSTACKIDX = CURWIN->W_TAGSTACKIDX;
    INT		TAGSTACKLEN = CURWIN->W_TAGSTACKLEN;
    INT		CUR_MATCH = 0;
    INT		CUR_FNUM = CURBUF->B_FNUM;
    INT		OLDTAGSTACKIDX = TAGSTACKIDX;
    INT		PREVTAGSTACKIDX = TAGSTACKIDX;
    INT		PREV_NUM_MATCHES;
    INT		NEW_TAG = FALSE;
    INT		I;
    INT		IC;
    INT		NO_REGEXP = FALSE;
    INT		ERROR_CUR_MATCH = 0;
    INT		SAVE_POS = FALSE;
    FMARK_T	SAVED_FMARK;
#IFDEF FEAT_CSCOPE
    INT		JUMPED_TO_TAG = FALSE;
#ENDIF
    INT		NEW_NUM_MATCHES;
    CHAR_U	**NEW_MATCHES;
    INT		USE_TAGSTACK;
    INT		SKIP_MSG = FALSE;
    CHAR_U	*BUF_FFNAME = CURBUF->B_FFNAME;	    // NAME TO USE FOR
						    // PRIORITY COMPUTATION
    INT		USE_TFU = 1;

    // REMEMBER THE MATCHES FOR THE LAST USED TAG
    STATIC INT		NUM_MATCHES = 0;
    STATIC INT		MAX_NUM_MATCHES = 0;  // LIMIT USED FOR MATCH SEARCH
    STATIC CHAR_U	**MATCHES = NULL;
    STATIC INT		FLAGS;

#IFDEF FEAT_EVAL
    IF (TFU_IN_USE)
    {
	EMSG(_(E_CANNOT_MODIFY_TAG_STACK_WITHIN_TAGFUNC));
	RETURN FALSE;
    }
#ENDIF

#IFDEF EXITFREE
    IF (TYPE == DT_FREE)
    {
	// REMOVE THE LIST OF MATCHES
	FREEWILD(NUM_MATCHES, MATCHES);
# IFDEF FEAT_CSCOPE
	CS_FREE_TAGS();
# ENDIF
	NUM_MATCHES = 0;
	RETURN FALSE;
    }
#ENDIF

    IF (TYPE == DT_HELP)
    {
	TYPE = DT_TAG;
	NO_REGEXP = TRUE;
	USE_TFU = 0;
    }

    PREV_NUM_MATCHES = NUM_MATCHES;
    FREE_STRING_OPTION(NOFILE_FNAME);
    NOFILE_FNAME = NULL;

    CLEAR_POS(&SAVED_FMARK.MARK);	// SHUTUP GCC 4.0
    SAVED_FMARK.FNUM = 0;

    /*
     * DON'T ADD A TAG TO THE TAGSTACK IF 'TAGSTACK' HAS BEEN RESET.
     */
    IF ((!P_TGST && *TAG != NUL))
    {
	USE_TAGSTACK = FALSE;
	NEW_TAG = TRUE;
#IF DEFINED(FEAT_QUICKFIX)
	IF (G_DO_TAGPREVIEW != 0)
	{
	    TAGSTACK_CLEAR_ENTRY(&PTAG_ENTRY);
	    IF ((PTAG_ENTRY.TAGNAME = VIM_STRSAVE(TAG)) == NULL)
		GOTO END_DO_TAG;
	}
#ENDIF
    }
    ELSE
    {
#IF DEFINED(FEAT_QUICKFIX)
	IF (G_DO_TAGPREVIEW != 0)
	    USE_TAGSTACK = FALSE;
	ELSE
#ENDIF
	    USE_TAGSTACK = TRUE;

	// NEW PATTERN, ADD TO THE TAG STACK
	IF (*TAG != NUL
		&& (TYPE == DT_TAG || TYPE == DT_SELECT || TYPE == DT_JUMP
#IFDEF FEAT_QUICKFIX
		    || TYPE == DT_LTAG
#ENDIF
#IFDEF FEAT_CSCOPE
		    || TYPE == DT_CSCOPE
#ENDIF
		    ))
	{
#IF DEFINED(FEAT_QUICKFIX)
	    IF (G_DO_TAGPREVIEW != 0)
	    {
		IF (PTAG_ENTRY.TAGNAME != NULL
			&& STRCMP(PTAG_ENTRY.TAGNAME, TAG) == 0)
		{
		    // JUMPING TO SAME TAG: KEEP THE CURRENT MATCH, SO THAT
		    // THE CURSORHOLD AUTOCOMMAND EXAMPLE WORKS.
		    CUR_MATCH = PTAG_ENTRY.CUR_MATCH;
		    CUR_FNUM = PTAG_ENTRY.CUR_FNUM;
		}
		ELSE
		{
		    TAGSTACK_CLEAR_ENTRY(&PTAG_ENTRY);
		    IF ((PTAG_ENTRY.TAGNAME = VIM_STRSAVE(TAG)) == NULL)
			GOTO END_DO_TAG;
		}
	    }
	    ELSE
#ENDIF
	    {
		/*
		 * IF THE LAST USED ENTRY IS NOT AT THE TOP, DELETE ALL TAG
		 * STACK ENTRIES ABOVE IT.
		 */
		WHILE (TAGSTACKIDX < TAGSTACKLEN)
		    TAGSTACK_CLEAR_ENTRY(&TAGSTACK[--TAGSTACKLEN]);

		// IF THE TAGSTACK IS FULL: REMOVE OLDEST ENTRY
		IF (++TAGSTACKLEN > TAGSTACKSIZE)
		{
		    TAGSTACKLEN = TAGSTACKSIZE;
		    TAGSTACK_CLEAR_ENTRY(&TAGSTACK[0]);
		    FOR (I = 1; I < TAGSTACKLEN; ++I)
			TAGSTACK[I - 1] = TAGSTACK[I];
		    --TAGSTACKIDX;
		}

		/*
		 * PUT THE TAG NAME IN THE TAG STACK
		 */
		IF ((TAGSTACK[TAGSTACKIDX].TAGNAME = VIM_STRSAVE(TAG)) == NULL)
		{
		    CURWIN->W_TAGSTACKLEN = TAGSTACKLEN - 1;
		    GOTO END_DO_TAG;
		}
		CURWIN->W_TAGSTACKLEN = TAGSTACKLEN;

		SAVE_POS = TRUE;	// SAVE THE CURSOR POSITION BELOW
	    }

	    NEW_TAG = TRUE;
	}
	ELSE
	{
	    IF (
#IF DEFINED(FEAT_QUICKFIX)
		    G_DO_TAGPREVIEW != 0 ? PTAG_ENTRY.TAGNAME == NULL :
#ENDIF
		    TAGSTACKLEN == 0)
	    {
		// EMPTY STACK
		EMSG(_(E_TAG_STACK_EMPTY));
		GOTO END_DO_TAG;
	    }

	    IF (TYPE == DT_POP)		// GO TO OLDER POSITION
	    {
#IFDEF FEAT_FOLDING
		INT	OLD_KEYTYPED = KEYTYPED;
#ENDIF
		IF ((TAGSTACKIDX -= COUNT) < 0)
		{
		    EMSG(_(E_AT_BOTTOM_OF_TAG_STACK));
		    IF (TAGSTACKIDX + COUNT == 0)
		    {
			// WE DID [NUM]^T FROM THE BOTTOM OF THE STACK
			TAGSTACKIDX = 0;
			GOTO END_DO_TAG;
		    }
		    // WE WEREN'T AT THE BOTTOM OF THE STACK, SO JUMP ALL THE
		    // WAY TO THE BOTTOM NOW.
		    TAGSTACKIDX = 0;
		}
		ELSE IF (TAGSTACKIDX >= TAGSTACKLEN)    // COUNT == 0?
		{
		    EMSG(_(E_AT_TOP_OF_TAG_STACK));
		    GOTO END_DO_TAG;
		}

		// MAKE A COPY OF THE FMARK, AUTOCOMMANDS MAY INVALIDATE THE
		// TAGSTACK BEFORE IT'S USED.
		SAVED_FMARK = TAGSTACK[TAGSTACKIDX].FMARK;
		IF (SAVED_FMARK.FNUM != CURBUF->B_FNUM)
		{
		    /*
		     * JUMP TO OTHER FILE. IF THIS FAILS (E.G. BECAUSE THE
		     * FILE WAS CHANGED) KEEP ORIGINAL POSITION IN TAG STACK.
		     */
		    IF (BUFLIST_GETFILE(SAVED_FMARK.FNUM, SAVED_FMARK.MARK.LNUM,
					       GETF_SETMARK, FORCEIT) == FAIL)
		    {
			TAGSTACKIDX = OLDTAGSTACKIDX;  // BACK TO OLD POSN
			GOTO END_DO_TAG;
		    }
		    // AN BUFREADPOST AUTOCOMMAND MAY JUMP TO THE '" MARK, BUT
		    // WE DON'T WHAT THAT HERE.
		    CURWIN->W_CURSOR.LNUM = SAVED_FMARK.MARK.LNUM;
		}
		ELSE
		{
		    SETPCMARK();
		    CURWIN->W_CURSOR.LNUM = SAVED_FMARK.MARK.LNUM;
		}
		CURWIN->W_CURSOR.COL = SAVED_FMARK.MARK.COL;
		CURWIN->W_SET_CURSWANT = TRUE;
		CHECK_CURSOR();
#IFDEF FEAT_FOLDING
		IF ((FDO_FLAGS & FDO_TAG) && OLD_KEYTYPED)
		    FOLDOPENCURSOR();
#ENDIF

		// REMOVE THE OLD LIST OF MATCHES
		FREEWILD(NUM_MATCHES, MATCHES);
#IFDEF FEAT_CSCOPE
		CS_FREE_TAGS();
#ENDIF
		NUM_MATCHES = 0;
		TAG_FREEMATCH();
		GOTO END_DO_TAG;
	    }

	    IF (TYPE == DT_TAG
#IF DEFINED(FEAT_QUICKFIX)
		    || TYPE == DT_LTAG
#ENDIF
	       )
	    {
#IF DEFINED(FEAT_QUICKFIX)
		IF (G_DO_TAGPREVIEW != 0)
		{
		    CUR_MATCH = PTAG_ENTRY.CUR_MATCH;
		    CUR_FNUM = PTAG_ENTRY.CUR_FNUM;
		}
		ELSE
#ENDIF
		{
		    // ":TAG" (NO ARGUMENT): GO TO NEWER PATTERN
		    SAVE_POS = TRUE;	// SAVE THE CURSOR POSITION BELOW
		    IF ((TAGSTACKIDX += COUNT - 1) >= TAGSTACKLEN)
		    {
			/*
			 * BEYOND THE LAST ONE, JUST GIVE AN ERROR MESSAGE AND
			 * GO TO THE LAST ONE.  DON'T STORE THE CURSOR
			 * POSITION.
			 */
			TAGSTACKIDX = TAGSTACKLEN - 1;
			EMSG(_(E_AT_TOP_OF_TAG_STACK));
			SAVE_POS = FALSE;
		    }
		    ELSE IF (TAGSTACKIDX < 0)	// MUST HAVE BEEN COUNT == 0
		    {
			EMSG(_(E_AT_BOTTOM_OF_TAG_STACK));
			TAGSTACKIDX = 0;
			GOTO END_DO_TAG;
		    }
		    CUR_MATCH = TAGSTACK[TAGSTACKIDX].CUR_MATCH;
		    CUR_FNUM = TAGSTACK[TAGSTACKIDX].CUR_FNUM;
		}
		NEW_TAG = TRUE;
	    }
	    ELSE				// GO TO OTHER MATCHING TAG
	    {
		// SAVE INDEX FOR WHEN SELECTION IS CANCELLED.
		PREVTAGSTACKIDX = TAGSTACKIDX;

#IF DEFINED(FEAT_QUICKFIX)
		IF (G_DO_TAGPREVIEW != 0)
		{
		    CUR_MATCH = PTAG_ENTRY.CUR_MATCH;
		    CUR_FNUM = PTAG_ENTRY.CUR_FNUM;
		}
		ELSE
#ENDIF
		{
		    IF (--TAGSTACKIDX < 0)
			TAGSTACKIDX = 0;
		    CUR_MATCH = TAGSTACK[TAGSTACKIDX].CUR_MATCH;
		    CUR_FNUM = TAGSTACK[TAGSTACKIDX].CUR_FNUM;
		}
		SWITCH (TYPE)
		{
		    CASE DT_FIRST: CUR_MATCH = COUNT - 1; BREAK;
		    CASE DT_SELECT:
		    CASE DT_JUMP:
#IFDEF FEAT_CSCOPE
		    CASE DT_CSCOPE:
#ENDIF
		    CASE DT_LAST:  CUR_MATCH = MAXCOL - 1; BREAK;
		    CASE DT_NEXT:  CUR_MATCH += COUNT; BREAK;
		    CASE DT_PREV:  CUR_MATCH -= COUNT; BREAK;
		}
		IF (CUR_MATCH >= MAXCOL)
		    CUR_MATCH = MAXCOL - 1;
		ELSE IF (CUR_MATCH < 0)
		{
		    EMSG(_(E_CANNOT_GO_BEFORE_FIRST_MATCHING_TAG));
		    SKIP_MSG = TRUE;
		    CUR_MATCH = 0;
		    CUR_FNUM = CURBUF->B_FNUM;
		}
	    }
	}

#IF DEFINED(FEAT_QUICKFIX)
	IF (G_DO_TAGPREVIEW != 0)
	{
	    IF (TYPE != DT_SELECT && TYPE != DT_JUMP)
	    {
		PTAG_ENTRY.CUR_MATCH = CUR_MATCH;
		PTAG_ENTRY.CUR_FNUM = CUR_FNUM;
	    }
	}
	ELSE
#ENDIF
	{
	    /*
	     * FOR ":TAG [ARG]" OR ":TSELECT" REMEMBER POSITION BEFORE THE JUMP.
	     */
	    SAVED_FMARK = TAGSTACK[TAGSTACKIDX].FMARK;
	    IF (SAVE_POS)
	    {
		TAGSTACK[TAGSTACKIDX].FMARK.MARK = CURWIN->W_CURSOR;
		TAGSTACK[TAGSTACKIDX].FMARK.FNUM = CURBUF->B_FNUM;
	    }

	    // CURWIN WILL CHANGE IN THE CALL TO JUMPTO_TAG() IF ":STAG" WAS
	    // USED OR AN AUTOCOMMAND JUMPS TO ANOTHER WINDOW; STORE VALUE OF
	    // TAGSTACKIDX NOW.
	    CURWIN->W_TAGSTACKIDX = TAGSTACKIDX;
	    IF (TYPE != DT_SELECT && TYPE != DT_JUMP)
	    {
		CURWIN->W_TAGSTACK[TAGSTACKIDX].CUR_MATCH = CUR_MATCH;
		CURWIN->W_TAGSTACK[TAGSTACKIDX].CUR_FNUM = CUR_FNUM;
	    }
	}
    }

    // WHEN NOT USING THE CURRENT BUFFER GET THE NAME OF BUFFER "CUR_FNUM".
    // MAKES SURE THAT THE TAG ORDER DOESN'T CHANGE WHEN USING A REMEMBERED
    // POSITION FOR "CUR_MATCH".
    IF (CUR_FNUM != CURBUF->B_FNUM)
    {
	BUF_T *BUF = BUFLIST_FINDNR(CUR_FNUM);

	IF (BUF != NULL)
	    BUF_FFNAME = BUF->B_FFNAME;
    }

    /*
     * REPEAT SEARCHING FOR TAGS, WHEN A FILE HAS NOT BEEN FOUND.
     */
    FOR (;;)
    {
	INT	OTHER_NAME;
	CHAR_U	*NAME;

	/*
	 * WHEN DESIRED MATCH NOT FOUND YET, TRY TO FIND IT (AND OTHERS).
	 */
	IF (USE_TAGSTACK)
	    NAME = TAGSTACK[TAGSTACKIDX].TAGNAME;
#IF DEFINED(FEAT_QUICKFIX)
	ELSE IF (G_DO_TAGPREVIEW != 0)
	    NAME = PTAG_ENTRY.TAGNAME;
#ENDIF
	ELSE
	    NAME = TAG;
	OTHER_NAME = (TAGMATCHNAME == NULL || STRCMP(TAGMATCHNAME, NAME) != 0);
	IF (NEW_TAG
		|| (CUR_MATCH >= NUM_MATCHES && MAX_NUM_MATCHES != MAXCOL)
		|| OTHER_NAME)
	{
	    IF (OTHER_NAME)
	    {
		VIM_FREE(TAGMATCHNAME);
		TAGMATCHNAME = VIM_STRSAVE(NAME);
	    }

	    IF (TYPE == DT_SELECT || TYPE == DT_JUMP
#IF DEFINED(FEAT_QUICKFIX)
		|| TYPE == DT_LTAG
#ENDIF
		)
		CUR_MATCH = MAXCOL - 1;
	    IF (TYPE == DT_TAG)
		MAX_NUM_MATCHES = MAXCOL;
	    ELSE
		MAX_NUM_MATCHES = CUR_MATCH + 1;

	    // WHEN THE ARGUMENT STARTS WITH '/', USE IT AS A REGEXP
	    IF (!NO_REGEXP && *NAME == '/')
	    {
		FLAGS = TAG_REGEXP;
		++NAME;
	    }
	    ELSE
		FLAGS = TAG_NOIC;

#IFDEF FEAT_CSCOPE
	    IF (TYPE == DT_CSCOPE)
		FLAGS = TAG_CSCOPE;
#ENDIF
	    IF (VERBOSE)
		FLAGS |= TAG_VERBOSE;

	    IF (!USE_TFU)
		FLAGS |= TAG_NO_TAGFUNC;

	    IF (FIND_TAGS(NAME, &NEW_NUM_MATCHES, &NEW_MATCHES, FLAGS,
					    MAX_NUM_MATCHES, BUF_FFNAME) == OK
		    && NEW_NUM_MATCHES < MAX_NUM_MATCHES)
		MAX_NUM_MATCHES = MAXCOL; // IF LESS THAN MAX_NUM_MATCHES
					  // FOUND: ALL MATCHES FOUND.

	    // IF THERE ALREADY WERE SOME MATCHES FOR THE SAME NAME, MOVE THEM
	    // TO THE START.  AVOIDS THAT THE ORDER CHANGES WHEN USING
	    // ":TNEXT" AND JUMPING TO ANOTHER FILE.
	    IF (!NEW_TAG && !OTHER_NAME)
	    {
		INT	    J, K;
		INT	    IDX = 0;
		TAGPTRS_T   TAGP, TAGP2;

		// FIND THE POSITION OF EACH OLD MATCH IN THE NEW LIST.  NEED
		// TO USE PARSE_MATCH() TO FIND THE TAG LINE.
		FOR (J = 0; J < NUM_MATCHES; ++J)
		{
		    PARSE_MATCH(MATCHES[J], &TAGP);
		    FOR (I = IDX; I < NEW_NUM_MATCHES; ++I)
		    {
			PARSE_MATCH(NEW_MATCHES[I], &TAGP2);
			IF (STRCMP(TAGP.TAGNAME, TAGP2.TAGNAME) == 0)
			{
			    CHAR_U *P = NEW_MATCHES[I];
			    FOR (K = I; K > IDX; --K)
				NEW_MATCHES[K] = NEW_MATCHES[K - 1];
			    NEW_MATCHES[IDX++] = P;
			    BREAK;
			}
		    }
		}
	    }
	    FREEWILD(NUM_MATCHES, MATCHES);
	    NUM_MATCHES = NEW_NUM_MATCHES;
	    MATCHES = NEW_MATCHES;
	}

	IF (NUM_MATCHES <= 0)
	{
	    IF (VERBOSE)
		SEMSG(_(E_TAG_NOT_FOUND_STR), NAME);
#IF DEFINED(FEAT_QUICKFIX)
	    G_DO_TAGPREVIEW = 0;
#ENDIF
	}
	ELSE
	{
	    INT ASK_FOR_SELECTION = FALSE;

#IFDEF FEAT_CSCOPE
	    IF (TYPE == DT_CSCOPE && NUM_MATCHES > 1)
	    {
		CS_PRINT_TAGS();
		ASK_FOR_SELECTION = TRUE;
	    }
	    ELSE
#ENDIF
	    IF (TYPE == DT_TAG && *TAG != NUL)
		// IF A COUNT IS SUPPLIED TO THE ":TAG <NAME>" COMMAND, THEN
		// JUMP TO COUNT'TH MATCHING TAG.
		CUR_MATCH = COUNT > 0 ? COUNT - 1 : 0;
	    ELSE IF (TYPE == DT_SELECT || (TYPE == DT_JUMP && NUM_MATCHES > 1))
	    {
		PRINT_TAG_LIST(NEW_TAG, USE_TAGSTACK, NUM_MATCHES, MATCHES);
		ASK_FOR_SELECTION = TRUE;
	    }
#IF DEFINED(FEAT_QUICKFIX) && DEFINED(FEAT_EVAL)
	    ELSE IF (TYPE == DT_LTAG)
	    {
		IF (ADD_LLIST_TAGS(TAG, NUM_MATCHES, MATCHES) == FAIL)
		    GOTO END_DO_TAG;
		CUR_MATCH = 0;		// JUMP TO THE FIRST TAG
	    }
#ENDIF

	    IF (ASK_FOR_SELECTION == TRUE)
	    {
		/*
		 * ASK TO SELECT A TAG FROM THE LIST.
		 */
		I = PROMPT_FOR_NUMBER(NULL);
		IF (I <= 0 || I > NUM_MATCHES || GOT_INT)
		{
		    // NO VALID CHOICE: DON'T CHANGE ANYTHING
		    IF (USE_TAGSTACK)
		    {
			TAGSTACK[TAGSTACKIDX].FMARK = SAVED_FMARK;
			TAGSTACKIDX = PREVTAGSTACKIDX;
		    }
#IFDEF FEAT_CSCOPE
		    CS_FREE_TAGS();
		    JUMPED_TO_TAG = TRUE;
#ENDIF
		    BREAK;
		}
		CUR_MATCH = I - 1;
	    }

	    IF (CUR_MATCH >= NUM_MATCHES)
	    {
		// AVOID GIVING THIS ERROR WHEN A FILE WASN'T FOUND AND WE'RE
		// LOOKING FOR A MATCH IN ANOTHER FILE, WHICH WASN'T FOUND.
		// THERE WILL BE AN EMSG("FILE DOESN'T EXIST") BELOW THEN.
		IF ((TYPE == DT_NEXT || TYPE == DT_FIRST)
						      && NOFILE_FNAME == NULL)
		{
		    IF (NUM_MATCHES == 1)
			EMSG(_(E_THERE_IS_ONLY_ONE_MATCHING_TAG));
		    ELSE
			EMSG(_(E_CANNOT_GO_BEYOND_LAST_MATCHING_TAG));
		    SKIP_MSG = TRUE;
		}
		CUR_MATCH = NUM_MATCHES - 1;
	    }
	    IF (USE_TAGSTACK)
	    {
		TAGPTRS_T   TAGP;

		TAGSTACK[TAGSTACKIDX].CUR_MATCH = CUR_MATCH;
		TAGSTACK[TAGSTACKIDX].CUR_FNUM = CUR_FNUM;

		// STORE USER-PROVIDED DATA ORIGINATING FROM TAGFUNC
		IF (USE_TFU && PARSE_MATCH(MATCHES[CUR_MATCH], &TAGP) == OK
			&& TAGP.USER_DATA)
		{
		    VIM_CLEAR(TAGSTACK[TAGSTACKIDX].USER_DATA);
		    TAGSTACK[TAGSTACKIDX].USER_DATA = VIM_STRNSAVE(
			  TAGP.USER_DATA, TAGP.USER_DATA_END - TAGP.USER_DATA);
		}

		++TAGSTACKIDX;
	    }
#IF DEFINED(FEAT_QUICKFIX)
	    ELSE IF (G_DO_TAGPREVIEW != 0)
	    {
		PTAG_ENTRY.CUR_MATCH = CUR_MATCH;
		PTAG_ENTRY.CUR_FNUM = CUR_FNUM;
	    }
#ENDIF

	    /*
	     * ONLY WHEN GOING TO TRY THE NEXT MATCH, REPORT THAT THE PREVIOUS
	     * FILE DIDN'T EXIST.  OTHERWISE AN EMSG() IS GIVEN BELOW.
	     */
	    IF (NOFILE_FNAME != NULL && ERROR_CUR_MATCH != CUR_MATCH)
		SMSG(_("FILE \"%S\" DOES NOT EXIST"), NOFILE_FNAME);


	    IC = (MATCHES[CUR_MATCH][0] & MT_IC_OFF);
	    IF (TYPE != DT_TAG && TYPE != DT_SELECT && TYPE != DT_JUMP
#IFDEF FEAT_CSCOPE
		&& TYPE != DT_CSCOPE
#ENDIF
		&& (NUM_MATCHES > 1 || IC)
		&& !SKIP_MSG)
	    {
		// GIVE AN INDICATION OF THE NUMBER OF MATCHING TAGS
		SPRINTF((CHAR *)IOBUFF, _("TAG %D OF %D%S"),
				CUR_MATCH + 1,
				NUM_MATCHES,
				MAX_NUM_MATCHES != MAXCOL ? _(" OR MORE") : "");
		IF (IC)
		    STRCAT(IOBUFF, _("  USING TAG WITH DIFFERENT CASE!"));
		IF ((NUM_MATCHES > PREV_NUM_MATCHES || NEW_TAG)
							   && NUM_MATCHES > 1)
		{
		    IF (IC)
			MSG_ATTR((CHAR *)IOBUFF, HL_ATTR(HLF_W));
		    ELSE
			MSG((CHAR *)IOBUFF);
		    MSG_SCROLL = TRUE;	// DON'T OVERWRITE THIS MESSAGE
		}
		ELSE
		    GIVE_WARNING(IOBUFF, IC);
		IF (IC && !MSG_SCROLLED && MSG_SILENT == 0)
		{
		    OUT_FLUSH();
		    UI_DELAY(1007L, TRUE);
		}
	    }

#IF DEFINED(FEAT_EVAL)
	    // LET THE SWAPEXISTS EVENT KNOW WHAT TAG WE ARE JUMPING TO.
	    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, ":TA %S\R", NAME);
	    SET_VIM_VAR_STRING(VV_SWAPCOMMAND, IOBUFF, -1);
#ENDIF

	    /*
	     * JUMP TO THE DESIRED MATCH.
	     */
	    I = JUMPTO_TAG(MATCHES[CUR_MATCH], FORCEIT, TYPE != DT_CSCOPE);

#IF DEFINED(FEAT_EVAL)
	    SET_VIM_VAR_STRING(VV_SWAPCOMMAND, NULL, -1);
#ENDIF

	    IF (I == NOTAGFILE)
	    {
		// FILE NOT FOUND: TRY AGAIN WITH ANOTHER MATCHING TAG
		IF ((TYPE == DT_PREV && CUR_MATCH > 0)
			|| ((TYPE == DT_TAG || TYPE == DT_NEXT
							  || TYPE == DT_FIRST)
			    && (MAX_NUM_MATCHES != MAXCOL
					     || CUR_MATCH < NUM_MATCHES - 1)))
		{
		    ERROR_CUR_MATCH = CUR_MATCH;
		    IF (USE_TAGSTACK)
			--TAGSTACKIDX;
		    IF (TYPE == DT_PREV)
			--CUR_MATCH;
		    ELSE
		    {
			TYPE = DT_NEXT;
			++CUR_MATCH;
		    }
		    CONTINUE;
		}
		SEMSG(_(E_FILE_STR_DOES_NOT_EXIST), NOFILE_FNAME);
	    }
	    ELSE
	    {
		// WE MAY HAVE JUMPED TO ANOTHER WINDOW, CHECK THAT
		// TAGSTACKIDX IS STILL VALID.
		IF (USE_TAGSTACK && TAGSTACKIDX > CURWIN->W_TAGSTACKLEN)
		    TAGSTACKIDX = CURWIN->W_TAGSTACKIDX;
#IFDEF FEAT_CSCOPE
		JUMPED_TO_TAG = TRUE;
#ENDIF
	    }
	}
	BREAK;
    }

END_DO_TAG:
    // ONLY STORE THE NEW INDEX WHEN USING THE TAGSTACK AND IT'S VALID.
    IF (USE_TAGSTACK && TAGSTACKIDX <= CURWIN->W_TAGSTACKLEN)
	CURWIN->W_TAGSTACKIDX = TAGSTACKIDX;
    POSTPONED_SPLIT = 0;	// DON'T SPLIT NEXT TIME
# IFDEF FEAT_QUICKFIX
    G_DO_TAGPREVIEW = 0;	// DON'T DO TAG PREVIEW NEXT TIME
# ENDIF

#IFDEF FEAT_CSCOPE
    RETURN JUMPED_TO_TAG;
#ELSE
    RETURN FALSE;
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512492_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  BOOL VAL_NATIVE(THD *THD, NATIVE *TO)
  {
    RETURN HAS_VALUE() ? TIME(THD, THIS).TO_NATIVE(TO, DECIMALS) : TRUE;
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 352990_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SIDVALIDATE (
	SYNTAX *SYNTAX,
	STRUCT BERVAL *IN )
{
	ASSERT( IN != NULL );
	ASSERT( !BER_BVISNULL( IN ) );

	IF ( IN->BV_LEN != 3 ) {
		RETURN LDAP_INVALID_SYNTAX;
	}

	RETURN HEXVALIDATE( NULL, IN );
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294598_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
M_MDAY(UNION DATEDATA *X)
{
    IF (SIMPLE_DAT_P(X)) {
	GET_S_CIVIL(X);
#IFNDEF USE_PACK
	RETURN X->S.MDAY;
#ELSE
	RETURN EX_MDAY(X->S.PC);
#ENDIF
    }
    ELSE {
	GET_C_CIVIL(X);
#IFNDEF USE_PACK
	RETURN X->C.MDAY;
#ELSE
	RETURN EX_MDAY(X->C.PC);
#ENDIF
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369248_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

STATIC INT IO_REQ_PREP(STRUCT IO_KIOCB *REQ, CONST STRUCT IO_URING_SQE *SQE)
{
	SWITCH (REQ->OPCODE) {
	CASE IORING_OP_NOP:
		RETURN 0;
	CASE IORING_OP_READV:
	CASE IORING_OP_READ_FIXED:
	CASE IORING_OP_READ:
	CASE IORING_OP_WRITEV:
	CASE IORING_OP_WRITE_FIXED:
	CASE IORING_OP_WRITE:
		RETURN IO_PREP_RW(REQ, SQE);
	CASE IORING_OP_POLL_ADD:
		RETURN IO_POLL_ADD_PREP(REQ, SQE);
	CASE IORING_OP_POLL_REMOVE:
		RETURN IO_POLL_UPDATE_PREP(REQ, SQE);
	CASE IORING_OP_FSYNC:
		RETURN IO_FSYNC_PREP(REQ, SQE);
	CASE IORING_OP_SYNC_FILE_RANGE:
		RETURN IO_SFR_PREP(REQ, SQE);
	CASE IORING_OP_SENDMSG:
	CASE IORING_OP_SEND:
		RETURN IO_SENDMSG_PREP(REQ, SQE);
	CASE IORING_OP_RECVMSG:
	CASE IORING_OP_RECV:
		RETURN IO_RECVMSG_PREP(REQ, SQE);
	CASE IORING_OP_CONNECT:
		RETURN IO_CONNECT_PREP(REQ, SQE);
	CASE IORING_OP_TIMEOUT:
		RETURN IO_TIMEOUT_PREP(REQ, SQE, FALSE);
	CASE IORING_OP_TIMEOUT_REMOVE:
		RETURN IO_TIMEOUT_REMOVE_PREP(REQ, SQE);
	CASE IORING_OP_ASYNC_CANCEL:
		RETURN IO_ASYNC_CANCEL_PREP(REQ, SQE);
	CASE IORING_OP_LINK_TIMEOUT:
		RETURN IO_TIMEOUT_PREP(REQ, SQE, TRUE);
	CASE IORING_OP_ACCEPT:
		RETURN IO_ACCEPT_PREP(REQ, SQE);
	CASE IORING_OP_FALLOCATE:
		RETURN IO_FALLOCATE_PREP(REQ, SQE);
	CASE IORING_OP_OPENAT:
		RETURN IO_OPENAT_PREP(REQ, SQE);
	CASE IORING_OP_CLOSE:
		RETURN IO_CLOSE_PREP(REQ, SQE);
	CASE IORING_OP_FILES_UPDATE:
		RETURN IO_RSRC_UPDATE_PREP(REQ, SQE);
	CASE IORING_OP_STATX:
		RETURN IO_STATX_PREP(REQ, SQE);
	CASE IORING_OP_FADVISE:
		RETURN IO_FADVISE_PREP(REQ, SQE);
	CASE IORING_OP_MADVISE:
		RETURN IO_MADVISE_PREP(REQ, SQE);
	CASE IORING_OP_OPENAT2:
		RETURN IO_OPENAT2_PREP(REQ, SQE);
	CASE IORING_OP_EPOLL_CTL:
		RETURN IO_EPOLL_CTL_PREP(REQ, SQE);
	CASE IORING_OP_SPLICE:
		RETURN IO_SPLICE_PREP(REQ, SQE);
	CASE IORING_OP_PROVIDE_BUFFERS:
		RETURN IO_PROVIDE_BUFFERS_PREP(REQ, SQE);
	CASE IORING_OP_REMOVE_BUFFERS:
		RETURN IO_REMOVE_BUFFERS_PREP(REQ, SQE);
	CASE IORING_OP_TEE:
		RETURN IO_TEE_PREP(REQ, SQE);
	CASE IORING_OP_SHUTDOWN:
		RETURN IO_SHUTDOWN_PREP(REQ, SQE);
	CASE IORING_OP_RENAMEAT:
		RETURN IO_RENAMEAT_PREP(REQ, SQE);
	CASE IORING_OP_UNLINKAT:
		RETURN IO_UNLINKAT_PREP(REQ, SQE);
	CASE IORING_OP_MKDIRAT:
		RETURN IO_MKDIRAT_PREP(REQ, SQE);
	CASE IORING_OP_SYMLINKAT:
		RETURN IO_SYMLINKAT_PREP(REQ, SQE);
	CASE IORING_OP_LINKAT:
		RETURN IO_LINKAT_PREP(REQ, SQE);
	CASE IORING_OP_MSG_RING:
		RETURN IO_MSG_RING_PREP(REQ, SQE);
	}

	PRINTK_ONCE(KERN_WARNING "IO_URING: UNHANDLED OPCODE %D\N",
			REQ->OPCODE);
	RETURN -EINVAL;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 236136_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_BOX *HLIT_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(GF_TEXTHIGHLIGHTBOX, GF_ISOM_BOX_TYPE_HLIT);
	RETURN (GF_BOX *) TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210904_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID WARNF(STRUCT CONFIGURABLE *CONFIG, CONST CHAR *FMT, ...)
{
  IF(!(CONFIG->CONF & CONF_MUTE)) {
    VA_LIST AP;
    INT LEN;
    CHAR *PTR;
    CHAR PRINT_BUFFER[256];

    VA_START(AP, FMT);
    VA_START(AP, FMT);
    LEN = VSNPRINTF(PRINT_BUFFER, SIZEOF(PRINT_BUFFER), FMT, AP);
    VA_END(AP);

    PTR = PRINT_BUFFER;
    WHILE(LEN > 0) {
      FPUTS(WARN_PREFIX, CONFIG->ERRORS);

      IF(LEN > (INT)WARN_TEXTWIDTH) {
        INT CUT = WARN_TEXTWIDTH-1;

        WHILE(!ISSPACE(PTR[CUT]) && CUT) {
          CUT--;
        }

        FWRITE(PTR, CUT + 1, 1, CONFIG->ERRORS);
        FPUTS("\N", CONFIG->ERRORS);
        PTR += CUT+1; /* SKIP THE SPACE TOO */
        LEN -= CUT;
      }
      ELSE {
        FPUTS(PTR, CONFIG->ERRORS);
        LEN = 0;
      }
    }
  }
}
ASSISTANT
CWE-787: OUT-OF-BOUNDS WRITE
--------------------------------------------------
File: 197135_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CCP_RUN_AES_GCM_CMD(STRUCT CCP_CMD_QUEUE *CMD_Q, STRUCT CCP_CMD *CMD)
{
	STRUCT CCP_AES_ENGINE *AES = &CMD->U.AES;
	STRUCT CCP_DM_WORKAREA KEY, CTX, FINAL_WA, TAG;
	STRUCT CCP_DATA SRC, DST;
	STRUCT CCP_DATA AAD;
	STRUCT CCP_OP OP;
	UNSIGNED INT DM_OFFSET;
	UNSIGNED INT AUTHSIZE;
	UNSIGNED INT JOBID;
	UNSIGNED INT ILEN;
	BOOL IN_PLACE = TRUE; /* DEFAULT VALUE */
	__BE64 *FINAL;
	INT RET;

	STRUCT SCATTERLIST *P_INP, SG_INP[2];
	STRUCT SCATTERLIST *P_TAG, SG_TAG[2];
	STRUCT SCATTERLIST *P_OUTP, SG_OUTP[2];
	STRUCT SCATTERLIST *P_AAD;

	IF (!AES->IV)
		RETURN -EINVAL;

	IF (!((AES->KEY_LEN == AES_KEYSIZE_128) ||
		(AES->KEY_LEN == AES_KEYSIZE_192) ||
		(AES->KEY_LEN == AES_KEYSIZE_256)))
		RETURN -EINVAL;

	IF (!AES->KEY) /* GOTTA HAVE A KEY SGL */
		RETURN -EINVAL;

	/* ZERO DEFAULTS TO 16 BYTES, THE MAXIMUM SIZE */
	AUTHSIZE = AES->AUTHSIZE ? AES->AUTHSIZE : AES_BLOCK_SIZE;
	SWITCH (AUTHSIZE) {
	CASE 16:
	CASE 15:
	CASE 14:
	CASE 13:
	CASE 12:
	CASE 8:
	CASE 4:
		BREAK;
	DEFAULT:
		RETURN -EINVAL;
	}

	/* FIRST, DECOMPOSE THE SOURCE BUFFER INTO AAD & PT,
	 * AND THE DESTINATION BUFFER INTO AAD, CT & TAG, OR
	 * THE INPUT INTO CT & TAG.
	 * IT IS EXPECTED THAT THE INPUT AND OUTPUT SGS WILL
	 * BE VALID, EVEN IF THE AAD AND INPUT LENGTHS ARE 0.
	 */
	P_AAD = AES->SRC;
	P_INP = SCATTERWALK_FFWD(SG_INP, AES->SRC, AES->AAD_LEN);
	P_OUTP = SCATTERWALK_FFWD(SG_OUTP, AES->DST, AES->AAD_LEN);
	IF (AES->ACTION == CCP_AES_ACTION_ENCRYPT) {
		ILEN = AES->SRC_LEN;
		P_TAG = SCATTERWALK_FFWD(SG_TAG, P_OUTP, ILEN);
	} ELSE {
		/* INPUT LENGTH FOR DECRYPTION INCLUDES TAG */
		ILEN = AES->SRC_LEN - AUTHSIZE;
		P_TAG = SCATTERWALK_FFWD(SG_TAG, P_INP, ILEN);
	}

	JOBID = CCP_NEW_JOBID(CMD_Q->CCP);

	MEMSET(&OP, 0, SIZEOF(OP));
	OP.CMD_Q = CMD_Q;
	OP.JOBID = JOBID;
	OP.SB_KEY = CMD_Q->SB_KEY; /* PRE-ALLOCATED */
	OP.SB_CTX = CMD_Q->SB_CTX; /* PRE-ALLOCATED */
	OP.INIT = 1;
	OP.U.AES.TYPE = AES->TYPE;

	/* COPY THE KEY TO THE LSB */
	RET = CCP_INIT_DM_WORKAREA(&KEY, CMD_Q,
				   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,
				   DMA_TO_DEVICE);
	IF (RET)
		RETURN RET;

	DM_OFFSET = CCP_SB_BYTES - AES->KEY_LEN;
	RET = CCP_SET_DM_AREA(&KEY, DM_OFFSET, AES->KEY, 0, AES->KEY_LEN);
	IF (RET)
		GOTO E_KEY;
	RET = CCP_COPY_TO_SB(CMD_Q, &KEY, OP.JOBID, OP.SB_KEY,
			     CCP_PASSTHRU_BYTESWAP_256BIT);
	IF (RET) {
		CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
		GOTO E_KEY;
	}

	/* COPY THE CONTEXT (IV) TO THE LSB.
	 * THERE IS AN ASSUMPTION HERE THAT THE IV IS 96 BITS IN LENGTH, PLUS
	 * A NONCE OF 32 BITS. IF NO IV IS PRESENT, USE A ZEROED BUFFER.
	 */
	RET = CCP_INIT_DM_WORKAREA(&CTX, CMD_Q,
				   CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES,
				   DMA_BIDIRECTIONAL);
	IF (RET)
		GOTO E_KEY;

	DM_OFFSET = CCP_AES_CTX_SB_COUNT * CCP_SB_BYTES - AES->IV_LEN;
	RET = CCP_SET_DM_AREA(&CTX, DM_OFFSET, AES->IV, 0, AES->IV_LEN);
	IF (RET)
		GOTO E_CTX;

	RET = CCP_COPY_TO_SB(CMD_Q, &CTX, OP.JOBID, OP.SB_CTX,
			     CCP_PASSTHRU_BYTESWAP_256BIT);
	IF (RET) {
		CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
		GOTO E_CTX;
	}

	OP.INIT = 1;
	IF (AES->AAD_LEN > 0) {
		/* STEP 1: RUN A GHASH OVER THE ADDITIONAL AUTHENTICATED DATA */
		RET = CCP_INIT_DATA(&AAD, CMD_Q, P_AAD, AES->AAD_LEN,
				    AES_BLOCK_SIZE,
				    DMA_TO_DEVICE);
		IF (RET)
			GOTO E_CTX;

		OP.U.AES.MODE = CCP_AES_MODE_GHASH;
		OP.U.AES.ACTION = CCP_AES_GHASHAAD;

		WHILE (AAD.SG_WA.BYTES_LEFT) {
			CCP_PREPARE_DATA(&AAD, NULL, &OP, AES_BLOCK_SIZE, TRUE);

			RET = CMD_Q->CCP->VDATA->PERFORM->AES(&OP);
			IF (RET) {
				CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
				GOTO E_AAD;
			}

			CCP_PROCESS_DATA(&AAD, NULL, &OP);
			OP.INIT = 0;
		}
	}

	OP.U.AES.MODE = CCP_AES_MODE_GCTR;
	OP.U.AES.ACTION = AES->ACTION;

	IF (ILEN > 0) {
		/* STEP 2: RUN A GCTR OVER THE PLAINTEXT */
		IN_PLACE = (SG_VIRT(P_INP) == SG_VIRT(P_OUTP)) ? TRUE : FALSE;

		RET = CCP_INIT_DATA(&SRC, CMD_Q, P_INP, ILEN,
				    AES_BLOCK_SIZE,
				    IN_PLACE ? DMA_BIDIRECTIONAL
					     : DMA_TO_DEVICE);
		IF (RET)
			GOTO E_CTX;

		IF (IN_PLACE) {
			DST = SRC;
		} ELSE {
			RET = CCP_INIT_DATA(&DST, CMD_Q, P_OUTP, ILEN,
					    AES_BLOCK_SIZE, DMA_FROM_DEVICE);
			IF (RET)
				GOTO E_SRC;
		}

		OP.SOC = 0;
		OP.EOM = 0;
		OP.INIT = 1;
		WHILE (SRC.SG_WA.BYTES_LEFT) {
			CCP_PREPARE_DATA(&SRC, &DST, &OP, AES_BLOCK_SIZE, TRUE);
			IF (!SRC.SG_WA.BYTES_LEFT) {
				UNSIGNED INT NBYTES = ILEN % AES_BLOCK_SIZE;

				IF (NBYTES) {
					OP.EOM = 1;
					OP.U.AES.SIZE = (NBYTES * 8) - 1;
				}
			}

			RET = CMD_Q->CCP->VDATA->PERFORM->AES(&OP);
			IF (RET) {
				CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
				GOTO E_DST;
			}

			CCP_PROCESS_DATA(&SRC, &DST, &OP);
			OP.INIT = 0;
		}
	}

	/* STEP 3: UPDATE THE IV PORTION OF THE CONTEXT WITH THE ORIGINAL IV */
	RET = CCP_COPY_FROM_SB(CMD_Q, &CTX, OP.JOBID, OP.SB_CTX,
			       CCP_PASSTHRU_BYTESWAP_256BIT);
	IF (RET) {
		CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
		GOTO E_DST;
	}

	RET = CCP_SET_DM_AREA(&CTX, DM_OFFSET, AES->IV, 0, AES->IV_LEN);
	IF (RET)
		GOTO E_DST;

	RET = CCP_COPY_TO_SB(CMD_Q, &CTX, OP.JOBID, OP.SB_CTX,
			     CCP_PASSTHRU_BYTESWAP_256BIT);
	IF (RET) {
		CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
		GOTO E_DST;
	}

	/* STEP 4: CONCATENATE THE LENGTHS OF THE AAD AND SOURCE, AND
	 * HASH THAT 16 BYTE BUFFER.
	 */
	RET = CCP_INIT_DM_WORKAREA(&FINAL_WA, CMD_Q, AES_BLOCK_SIZE,
				   DMA_BIDIRECTIONAL);
	IF (RET)
		GOTO E_DST;
	FINAL = (__BE64 *)FINAL_WA.ADDRESS;
	FINAL[0] = CPU_TO_BE64(AES->AAD_LEN * 8);
	FINAL[1] = CPU_TO_BE64(ILEN * 8);

	MEMSET(&OP, 0, SIZEOF(OP));
	OP.CMD_Q = CMD_Q;
	OP.JOBID = JOBID;
	OP.SB_KEY = CMD_Q->SB_KEY; /* PRE-ALLOCATED */
	OP.SB_CTX = CMD_Q->SB_CTX; /* PRE-ALLOCATED */
	OP.INIT = 1;
	OP.U.AES.TYPE = AES->TYPE;
	OP.U.AES.MODE = CCP_AES_MODE_GHASH;
	OP.U.AES.ACTION = CCP_AES_GHASHFINAL;
	OP.SRC.TYPE = CCP_MEMTYPE_SYSTEM;
	OP.SRC.U.DMA.ADDRESS = FINAL_WA.DMA.ADDRESS;
	OP.SRC.U.DMA.LENGTH = AES_BLOCK_SIZE;
	OP.DST.TYPE = CCP_MEMTYPE_SYSTEM;
	OP.DST.U.DMA.ADDRESS = FINAL_WA.DMA.ADDRESS;
	OP.DST.U.DMA.LENGTH = AES_BLOCK_SIZE;
	OP.EOM = 1;
	OP.U.AES.SIZE = 0;
	RET = CMD_Q->CCP->VDATA->PERFORM->AES(&OP);
	IF (RET)
		GOTO E_DST;

	IF (AES->ACTION == CCP_AES_ACTION_ENCRYPT) {
		/* PUT THE CIPHERED TAG AFTER THE CIPHERTEXT. */
		CCP_GET_DM_AREA(&FINAL_WA, 0, P_TAG, 0, AUTHSIZE);
	} ELSE {
		/* DOES THIS CIPHERED TAG MATCH THE INPUT? */
		RET = CCP_INIT_DM_WORKAREA(&TAG, CMD_Q, AUTHSIZE,
					   DMA_BIDIRECTIONAL);
		IF (RET)
			GOTO E_TAG;
		RET = CCP_SET_DM_AREA(&TAG, 0, P_TAG, 0, AUTHSIZE);
		IF (RET)
			GOTO E_TAG;

		RET = CRYPTO_MEMNEQ(TAG.ADDRESS, FINAL_WA.ADDRESS,
				    AUTHSIZE) ? -EBADMSG : 0;
		CCP_DM_FREE(&TAG);
	}

E_TAG:
	CCP_DM_FREE(&FINAL_WA);

E_DST:
	IF (ILEN > 0 && !IN_PLACE)
		CCP_FREE_DATA(&DST, CMD_Q);

E_SRC:
	IF (ILEN > 0)
		CCP_FREE_DATA(&SRC, CMD_Q);

E_AAD:
	IF (AES->AAD_LEN)
		CCP_FREE_DATA(&AAD, CMD_Q);

E_CTX:
	CCP_DM_FREE(&CTX);

E_KEY:
	CCP_DM_FREE(&KEY);

	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206736_CWE-189.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FTP_GENLIST(FTPBUF_T *FTP, CONST CHAR *CMD, CONST CHAR *PATH TSRMLS_DC)
{
	PHP_STREAM	*TMPSTREAM = NULL;
	DATABUF_T	*DATA = NULL;
	CHAR		*PTR;
	INT		CH, LASTCH;
	INT		SIZE, RCVD;
	INT		LINES;
	CHAR		**RET = NULL;
	CHAR		**ENTRY;
	CHAR		*TEXT;


	IF ((TMPSTREAM = PHP_STREAM_FOPEN_TMPFILE()) == NULL) {
		PHP_ERROR_DOCREF(NULL TSRMLS_CC, E_WARNING, "UNABLE TO CREATE TEMPORARY FILE.  CHECK PERMISSIONS IN TEMPORARY FILES DIRECTORY.");
		RETURN NULL;
	}

	IF (!FTP_TYPE(FTP, FTPTYPE_ASCII)) {
		GOTO BAIL;
	}

	IF ((DATA = FTP_GETDATA(FTP TSRMLS_CC)) == NULL) {
		GOTO BAIL;
	}
	FTP->DATA = DATA;	

	IF (!FTP_PUTCMD(FTP, CMD, PATH)) {
		GOTO BAIL;
	}
	IF (!FTP_GETRESP(FTP) || (FTP->RESP != 150 && FTP->RESP != 125 && FTP->RESP != 226)) {
		GOTO BAIL;
	}

	/* SOME SERVERS DON'T OPEN A FTP-DATA CONNECTION IF THE DIRECTORY IS EMPTY */
	IF (FTP->RESP == 226) {
		FTP->DATA = DATA_CLOSE(FTP, DATA);
		PHP_STREAM_CLOSE(TMPSTREAM);
		RETURN ECALLOC(1, SIZEOF(CHAR*));
	}

	/* PULL DATA BUFFER INTO TMPFILE */
	IF ((DATA = DATA_ACCEPT(DATA, FTP TSRMLS_CC)) == NULL) {
		GOTO BAIL;
	}
	SIZE = 0;
	LINES = 0;
	LASTCH = 0;
	WHILE ((RCVD = MY_RECV(FTP, DATA->FD, DATA->BUF, FTP_BUFSIZE))) {
		IF (RCVD == -1) {
			GOTO BAIL;
		}

		PHP_STREAM_WRITE(TMPSTREAM, DATA->BUF, RCVD);

		SIZE += RCVD;
		FOR (PTR = DATA->BUF; RCVD; RCVD--, PTR++) {
			IF (*PTR == '\N' && LASTCH == '\R') {
				LINES++;
			} ELSE {
				SIZE++;
			}
			LASTCH = *PTR;
		}
	}

	FTP->DATA = DATA_CLOSE(FTP, DATA);

	PHP_STREAM_REWIND(TMPSTREAM);

	RET = SAFE_EMALLOC((LINES + 1), SIZEOF(CHAR*), SIZE * SIZEOF(CHAR*));

	ENTRY = RET;
	TEXT = (CHAR*) (RET + LINES + 1);
	*ENTRY = TEXT;
	LASTCH = 0;
	WHILE ((CH = PHP_STREAM_GETC(TMPSTREAM)) != EOF) {
		IF (CH == '\N' && LASTCH == '\R') {
			*(TEXT - 1) = 0;
			*++ENTRY = TEXT;
		} ELSE {
			*TEXT++ = CH;
		}
		LASTCH = CH;
	}
	*ENTRY = NULL;

	PHP_STREAM_CLOSE(TMPSTREAM);

	IF (!FTP_GETRESP(FTP) || (FTP->RESP != 226 && FTP->RESP != 250)) {
		EFREE(RET);
		RETURN NULL;
	}

	RETURN RET;
BAIL:
	FTP->DATA = DATA_CLOSE(FTP, DATA);
	PHP_STREAM_CLOSE(TMPSTREAM);
	IF (RET)
		EFREE(RET);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206946_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CMDOPTS_T *CMDOPTS_PARSE(INT ARGC, CHAR **ARGV)
{
	ENUM {
		CMDOPT_HELP = 0,
		CMDOPT_VERBOSE,
		CMDOPT_QUIET,
		CMDOPT_INFILE,
		CMDOPT_INFMT,
		CMDOPT_INOPT,
		CMDOPT_OUTFILE,
		CMDOPT_OUTFMT,
		CMDOPT_OUTOPT,
		CMDOPT_VERSION,
		CMDOPT_DEBUG,
		CMDOPT_CMPTNO,
		CMDOPT_SRGB,
		CMDOPT_MAXMEM,
		CMDOPT_LIST_ENABLED_CODECS,
		CMDOPT_LIST_ALL_CODECS,
		CMDOPT_ENABLE_FORMAT,
		CMDOPT_ENABLE_ALL_FORMATS,
	};

	STATIC CONST JAS_OPT_T CMDOPTIONS[] = {
		{CMDOPT_HELP, "HELP", 0},
		{CMDOPT_VERBOSE, "VERBOSE", 0},
		{CMDOPT_QUIET, "QUIET", 0},
		{CMDOPT_QUIET, "Q", 0},
		{CMDOPT_INFILE, "INPUT", JAS_OPT_HASARG},
		{CMDOPT_INFILE, "F", JAS_OPT_HASARG},
		{CMDOPT_INFMT, "INPUT-FORMAT", JAS_OPT_HASARG},
		{CMDOPT_INFMT, "T", JAS_OPT_HASARG},
		{CMDOPT_INOPT, "INPUT-OPTION", JAS_OPT_HASARG},
		{CMDOPT_INOPT, "O", JAS_OPT_HASARG},
		{CMDOPT_OUTFILE, "OUTPUT", JAS_OPT_HASARG},
		{CMDOPT_OUTFILE, "F", JAS_OPT_HASARG},
		{CMDOPT_OUTFMT, "OUTPUT-FORMAT", JAS_OPT_HASARG},
		{CMDOPT_OUTFMT, "T", JAS_OPT_HASARG},
		{CMDOPT_OUTOPT, "OUTPUT-OPTION", JAS_OPT_HASARG},
		{CMDOPT_OUTOPT, "O", JAS_OPT_HASARG},
		{CMDOPT_VERSION, "VERSION", 0},
		{CMDOPT_DEBUG, "DEBUG-LEVEL", JAS_OPT_HASARG},
		{CMDOPT_CMPTNO, "CMPTNO", JAS_OPT_HASARG},
		{CMDOPT_SRGB, "FORCE-SRGB", 0},
		{CMDOPT_SRGB, "S", 0},
		{CMDOPT_MAXMEM, "MEMORY-LIMIT", JAS_OPT_HASARG},
		{CMDOPT_LIST_ENABLED_CODECS, "LIST-ENABLED-FORMATS", 0},
		{CMDOPT_LIST_ALL_CODECS, "LIST-ALL-FORMATS", 0},
		{CMDOPT_ENABLE_FORMAT, "ENABLE-FORMAT", JAS_OPT_HASARG},
		{CMDOPT_ENABLE_ALL_FORMATS, "ENABLE-ALL-FORMATS", 0},
		{-1, 0, 0}
	};

	CMDOPTS_T *CMDOPTS;
	INT C;

	IF (!(CMDOPTS = MALLOC(SIZEOF(CMDOPTS_T)))) {
		FPRINTF(STDERR, "ERROR: INSUFFICIENT MEMORY\N");
		EXIT(EXIT_FAILURE);
	}

	CMDOPTS->INFILE = 0;
	CMDOPTS->INFMT = -1;
	CMDOPTS->INFMT_STR = 0;
	CMDOPTS->INOPTS = 0;
	CMDOPTS->INOPTSBUF[0] = '\0';
	CMDOPTS->OUTFILE = 0;
	CMDOPTS->OUTFMT = -1;
	CMDOPTS->OUTFMT_STR = 0;
	CMDOPTS->OUTOPTS = 0;
	CMDOPTS->OUTOPTSBUF[0] = '\0';
	CMDOPTS->VERBOSE = 0;
	CMDOPTS->VERSION = 0;
	CMDOPTS->CMPTNO = -1;
	CMDOPTS->DEBUG = 0;
	CMDOPTS->SRGB = 0;
	CMDOPTS->LIST_CODECS = 0;
	CMDOPTS->LIST_CODECS_ALL = 0;
	CMDOPTS->HELP = 0;
	CMDOPTS->MAX_MEM = GET_DEFAULT_MAX_MEM_USAGE();
	CMDOPTS->ENABLE_FORMAT = 0;
	CMDOPTS->ENABLE_ALL_FORMATS = 0;

	WHILE ((C = JAS_GETOPT(ARGC, ARGV, CMDOPTIONS)) != EOF) {
		SWITCH (C) {
		CASE CMDOPT_HELP:
			CMDOPTS->HELP = 1;
			BREAK;
		CASE CMDOPT_VERBOSE:
			CMDOPTS->VERBOSE = 1;
			BREAK;
		CASE CMDOPT_QUIET:
			CMDOPTS->VERBOSE = -1;
			BREAK;
		CASE CMDOPT_VERSION:
			CMDOPTS->VERSION = 1;
			BREAK;
		CASE CMDOPT_LIST_ENABLED_CODECS:
			CMDOPTS->LIST_CODECS = 1;
			CMDOPTS->LIST_CODECS_ALL = 0;
			BREAK;
		CASE CMDOPT_LIST_ALL_CODECS:
			CMDOPTS->LIST_CODECS = 1;
			CMDOPTS->LIST_CODECS_ALL = 1;
			BREAK;
		CASE CMDOPT_DEBUG:
			CMDOPTS->DEBUG = ATOI(JAS_OPTARG);
			BREAK;
		CASE CMDOPT_INFILE:
			CMDOPTS->INFILE = JAS_OPTARG;
			BREAK;
		CASE CMDOPT_INFMT:
			CMDOPTS->INFMT_STR= JAS_OPTARG;
			BREAK;
		CASE CMDOPT_INOPT:
			ADDOPT(CMDOPTS->INOPTSBUF, OPTSMAX, JAS_OPTARG);
			CMDOPTS->INOPTS = CMDOPTS->INOPTSBUF;
			BREAK;
		CASE CMDOPT_OUTFILE:
			CMDOPTS->OUTFILE = JAS_OPTARG;
			BREAK;
		CASE CMDOPT_OUTFMT:
			CMDOPTS->OUTFMT_STR = JAS_OPTARG;
			BREAK;
		CASE CMDOPT_OUTOPT:
			ADDOPT(CMDOPTS->OUTOPTSBUF, OPTSMAX, JAS_OPTARG);
			CMDOPTS->OUTOPTS = CMDOPTS->OUTOPTSBUF;
			BREAK;
		CASE CMDOPT_CMPTNO:
			CMDOPTS->CMPTNO = ATOI(JAS_OPTARG);
			BREAK;
		CASE CMDOPT_SRGB:
			CMDOPTS->SRGB = 1;
			BREAK;
		CASE CMDOPT_MAXMEM:
			CMDOPTS->MAX_MEM = STRTOULL(JAS_OPTARG, 0, 10);
			BREAK;
		CASE CMDOPT_ENABLE_FORMAT:
			CMDOPTS->ENABLE_FORMAT = JAS_OPTARG;
			BREAK;
		CASE CMDOPT_ENABLE_ALL_FORMATS:
			CMDOPTS->ENABLE_ALL_FORMATS = 1;
			BREAK;
		DEFAULT:
			BADUSAGE();
			BREAK;
		}
	}

	WHILE (JAS_OPTIND < ARGC) {
		FPRINTF(STDERR,
		  "WARNING: IGNORING BOGUS COMMAND LINE ARGUMENT %S\N",
		  ARGV[JAS_OPTIND]);
		++JAS_OPTIND;
	}

	IF (CMDOPTS->VERSION || CMDOPTS->LIST_CODECS || CMDOPTS->HELP) {
		GOTO DONE;
	}

	IF (!CMDOPTS->OUTFMT_STR && !CMDOPTS->OUTFILE) {
		FPRINTF(STDERR, "ERROR: CANNOT DETERMINE OUTPUT FORMAT\N");
		BADUSAGE();
	}

DONE:
	RETURN CMDOPTS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211113_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID ATUSB_DISCONNECT(STRUCT USB_INTERFACE *INTERFACE)
{
	STRUCT ATUSB *ATUSB = USB_GET_INTFDATA(INTERFACE);

	DEV_DBG(&ATUSB->USB_DEV->DEV, "%S\N", __FUNC__);

	ATUSB->SHUTDOWN = 1;
	CANCEL_DELAYED_WORK_SYNC(&ATUSB->WORK);

	USB_KILL_ANCHORED_URBS(&ATUSB->RX_URBS);
	ATUSB_FREE_URBS(ATUSB);
	USB_KILL_URB(ATUSB->TX_URB);
	USB_FREE_URB(ATUSB->TX_URB);

	IEEE802154_UNREGISTER_HW(ATUSB->HW);

	IEEE802154_FREE_HW(ATUSB->HW);

	USB_SET_INTFDATA(INTERFACE, NULL);
	USB_PUT_DEV(ATUSB->USB_DEV);

	PR_DEBUG("%S DONE\N", __FUNC__);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220396_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_ARY_AGET(MRB_STATE *MRB, MRB_VALUE SELF)
{
  STRUCT RARRAY *A = MRB_ARY_PTR(SELF);
  MRB_INT I;
  MRB_INT LEN, ALEN;
  MRB_VALUE INDEX;

  IF (MRB_GET_ARGC(MRB) == 1) {
    INDEX = MRB_GET_ARG1(MRB);
    SWITCH (MRB_TYPE(INDEX)) {
      /* A[N..M] */
    CASE MRB_TT_RANGE:
      IF (MRB_RANGE_BEG_LEN(MRB, INDEX, &I, &LEN, ARY_LEN(A), TRUE) == MRB_RANGE_OK) {
        RETURN ARY_SUBSEQ(MRB, A, I, LEN);
      }
      ELSE {
        RETURN MRB_NIL_VALUE();
      }
    CASE MRB_TT_INTEGER:
      RETURN MRB_ARY_REF(MRB, SELF, MRB_INTEGER(INDEX));
    DEFAULT:
      RETURN MRB_ARY_REF(MRB, SELF, AGET_INDEX(MRB, INDEX));
    }
  }

  MRB_GET_ARGS(MRB, "OI", &INDEX, &LEN);
  I = AGET_INDEX(MRB, INDEX);
  ALEN = ARY_LEN(A);
  IF (I < 0) I += ALEN;
  IF (I < 0 || ALEN < I) RETURN MRB_NIL_VALUE();
  IF (LEN < 0) RETURN MRB_NIL_VALUE();
  IF (ALEN == I) RETURN MRB_ARY_NEW(MRB);
  IF (LEN > ALEN - I) LEN = ALEN - I;

  RETURN ARY_SUBSEQ(MRB, A, I, LEN);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206670_CWE-924.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NEGOTIATE_HANDSHAKE_NEWSTYLE_OPTIONS (VOID)
{
  GET_CONN;
  STRUCT NBD_NEW_OPTION NEW_OPTION;
  SIZE_T NR_OPTIONS;
  BOOL LIST_SEEN = FALSE;
  UINT64_T VERSION;
  UINT32_T OPTION;
  UINT32_T OPTLEN;
  STRUCT NBD_EXPORT_NAME_OPTION_REPLY HANDSHAKE_FINISH;
  CONST CHAR *OPTNAME;
  UINT64_T EXPORTSIZE;
  STRUCT BACKEND *B;

  FOR (NR_OPTIONS = MAX_NR_OPTIONS; NR_OPTIONS > 0; --NR_OPTIONS) {
    CLEANUP_FREE CHAR *DATA = NULL;

    IF (CONN_RECV_FULL (&NEW_OPTION, SIZEOF NEW_OPTION,
                        "READING OPTION: CONN->RECV: %M") == -1)
      RETURN -1;

    VERSION = BE64TOH (NEW_OPTION.VERSION);
    IF (VERSION != NBD_NEW_VERSION) {
      NBDKIT_ERROR ("UNKNOWN OPTION VERSION %" PRIX64
                    ", EXPECTING %" PRIX64,
                    VERSION, NBD_NEW_VERSION);
      RETURN -1;
    }

    /* THERE IS A MAXIMUM OPTION LENGTH WE WILL ACCEPT, REGARDLESS
     * OF THE OPTION TYPE.
     */
    OPTLEN = BE32TOH (NEW_OPTION.OPTLEN);
    IF (OPTLEN > MAX_REQUEST_SIZE) {
      NBDKIT_ERROR ("CLIENT OPTION DATA TOO LONG (%" PRIU32 ")", OPTLEN);
      RETURN -1;
    }
    DATA = MALLOC (OPTLEN + 1); /* ALLOWING A TRAILING NUL HELPS SOME USES */
    IF (DATA == NULL) {
      NBDKIT_ERROR ("MALLOC: %M");
      RETURN -1;
    }

    OPTION = BE32TOH (NEW_OPTION.OPTION);
    OPTNAME = NAME_OF_NBD_OPT (OPTION);

    /* IF THE CLIENT LACKS FIXED NEWSTYLE SUPPORT, IT SHOULD ONLY SEND
     * NBD_OPT_EXPORT_NAME.
     */
    IF (!(CONN->CFLAGS & NBD_FLAG_FIXED_NEWSTYLE) &&
        OPTION != NBD_OPT_EXPORT_NAME) {
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID))
        RETURN -1;
      CONTINUE;
    }

    /* IN --TLS=REQUIRE / FORCEDTLS MODE THE ONLY OPTIONS ALLOWED
     * BEFORE TLS NEGOTIATION ARE NBD_OPT_ABORT AND NBD_OPT_STARTTLS.
     */
    IF (TLS == 2 && !CONN->USING_TLS &&
        !(OPTION == NBD_OPT_ABORT || OPTION == NBD_OPT_STARTTLS)) {
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_TLS_REQD))
        RETURN -1;
      CONTINUE;
    }

    SWITCH (OPTION) {
    CASE NBD_OPT_EXPORT_NAME:
      IF (CONN_RECV_FULL (DATA, OPTLEN,
                          "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
        RETURN -1;
      IF (CHECK_EXPORT_NAME (OPTION, DATA, OPTLEN, OPTLEN) == -1)
        RETURN -1;

      /* WE HAVE TO FINISH THE HANDSHAKE BY SENDING HANDSHAKE_FINISH.
       * ON FAILURE, WE HAVE TO DISCONNECT.
       */
      IF (FINISH_NEWSTYLE_OPTIONS (&EXPORTSIZE, DATA, OPTLEN) == -1)
        RETURN -1;

      MEMSET (&HANDSHAKE_FINISH, 0, SIZEOF HANDSHAKE_FINISH);
      HANDSHAKE_FINISH.EXPORTSIZE = HTOBE64 (EXPORTSIZE);
      HANDSHAKE_FINISH.EFLAGS = HTOBE16 (CONN->EFLAGS);

      IF (CONN->SEND (&HANDSHAKE_FINISH,
                      (CONN->CFLAGS & NBD_FLAG_NO_ZEROES)
                      ? OFFSETOF (STRUCT NBD_EXPORT_NAME_OPTION_REPLY, ZEROES)
                      : SIZEOF HANDSHAKE_FINISH, 0) == -1) {
        NBDKIT_ERROR ("WRITE: %S: %M", OPTNAME);
        RETURN -1;
      }
      BREAK;

    CASE NBD_OPT_ABORT:
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
        RETURN -1;
      DEBUG ("CLIENT SENT %S TO ABORT THE CONNECTION",
             NAME_OF_NBD_OPT (OPTION));
      RETURN -1;

    CASE NBD_OPT_LIST:
      IF (OPTLEN != 0) {
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        IF (CONN_RECV_FULL (DATA, OPTLEN,
                            "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
          RETURN -1;
        CONTINUE;
      }

      IF (LIST_SEEN) {
        DEBUG ("NEWSTYLE NEGOTIATION: %S: EXPORT LIST ALREADY ADVERTISED",
               NAME_OF_NBD_OPT (OPTION));
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID) == -1)
          RETURN -1;
        CONTINUE;
      }
      ELSE {
        /* SEND BACK THE EXPORTNAME LIST. */
        DEBUG ("NEWSTYLE NEGOTIATION: %S: ADVERTISING EXPORTS",
               NAME_OF_NBD_OPT (OPTION));
        IF (SEND_NEWSTYLE_OPTION_REPLY_EXPORTNAMES (OPTION, &NR_OPTIONS) == -1)
          RETURN -1;
        LIST_SEEN = TRUE;
      }
      BREAK;

    CASE NBD_OPT_STARTTLS:
      IF (OPTLEN != 0) {
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        IF (CONN_RECV_FULL (DATA, OPTLEN,
                            "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
          RETURN -1;
        CONTINUE;
      }

      IF (TLS == 0) {           /* --TLS=OFF (NOTLS MODE). */
#IFDEF HAVE_GNUTLS
#DEFINE NO_TLS_REPLY NBD_REP_ERR_POLICY
#ELSE
#DEFINE NO_TLS_REPLY NBD_REP_ERR_UNSUP
#ENDIF
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NO_TLS_REPLY) == -1)
          RETURN -1;
      }
      ELSE /* --TLS=ON OR --TLS=REQUIRE */ {
        /* WE CAN'T UPGRADE TO TLS TWICE ON THE SAME CONNECTION. */
        IF (CONN->USING_TLS) {
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID) == -1)
            RETURN -1;
          CONTINUE;
        }

        /* WE HAVE TO SEND THE (UNENCRYPTED) REPLY BEFORE STARTING
         * THE HANDSHAKE.
         */
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
          RETURN -1;

        /* UPGRADE THE CONNECTION TO TLS.  ALSO PERFORMS ACCESS CONTROL. */
        IF (CRYPTO_NEGOTIATE_TLS (CONN->SOCKIN, CONN->SOCKOUT) == -1)
          RETURN -1;
        CONN->USING_TLS = TRUE;
        DEBUG ("USING TLS ON THIS CONNECTION");
        /* WIPE OUT ANY CACHED STATE. */
        CONN->STRUCTURED_REPLIES = FALSE;
        FOR_EACH_BACKEND (B) {
          FREE (CONN->DEFAULT_EXPORTNAME[B->I]);
          CONN->DEFAULT_EXPORTNAME[B->I] = NULL;
        }
      }
      BREAK;

    CASE NBD_OPT_INFO:
    CASE NBD_OPT_GO:
      IF (CONN_RECV_FULL (DATA, OPTLEN, "READ: %S: %M", OPTNAME) == -1)
        RETURN -1;

      IF (OPTLEN < 6) { /* 32 BIT EXPORT LENGTH + 16 BIT NR INFO */
        DEBUG ("NEWSTYLE NEGOTIATION: %S OPTION LENGTH < 6", OPTNAME);

        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        CONTINUE;
      }

      {
        UINT32_T EXPORTNAMELEN;
        UINT16_T NRINFOS;
        UINT16_T INFO;
        SIZE_T I;

        /* VALIDATE THE NAME LENGTH AND NUMBER OF INFO REQUESTS. */
        MEMCPY (&EXPORTNAMELEN, &DATA[0], 4);
        EXPORTNAMELEN = BE32TOH (EXPORTNAMELEN);
        IF (EXPORTNAMELEN > OPTLEN-6 /* NB OPTLEN >= 6, SEE ABOVE */) {
          DEBUG ("NEWSTYLE NEGOTIATION: %S: EXPORT NAME TOO LONG", OPTNAME);
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }
        MEMCPY (&NRINFOS, &DATA[EXPORTNAMELEN+4], 2);
        NRINFOS = BE16TOH (NRINFOS);
        IF (OPTLEN != 4 + EXPORTNAMELEN + 2 + 2*NRINFOS) {
          DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                 "NUMBER OF INFORMATION REQUESTS INCORRECT", OPTNAME);
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        /* AS WITH NBD_OPT_EXPORT_NAME WE PRINT THE EXPORT NAME AND
         * SAVE IT IN THE CONNECTION.  IF AN EARLIER
         * NBD_OPT_SET_META_CONTEXT USED AN EXPORT NAME, IT MUST MATCH
         * OR ELSE WE DROP THE SUPPORT FOR THAT CONTEXT.
         */
        IF (CHECK_EXPORT_NAME (OPTION, &DATA[4], EXPORTNAMELEN,
                               OPTLEN - 6) == -1) {
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        /* THE SPEC IS CONFUSING, BUT IT IS REQUIRED THAT WE SEND BACK
         * NBD_INFO_EXPORT, EVEN IF THE CLIENT DID NOT REQUEST IT!
         * QEMU CLIENT IN PARTICULAR DOES NOT REQUEST THIS, BUT WILL
         * FAIL IF WE DON'T SEND IT.  NOTE THAT IF .OPEN FAILS, BUT WE
         * SUCCEED AT .CLOSE, THEN WE MERELY RETURN AN ERROR TO THE
         * CLIENT AND LET THEM TRY ANOTHER NBD_OPT, RATHER THAN
         * DISCONNECTING.
         */
        IF (FINISH_NEWSTYLE_OPTIONS (&EXPORTSIZE,
                                     &DATA[4], EXPORTNAMELEN) == -1) {
          IF (CONN->TOP_CONTEXT) {
            IF (BACKEND_FINALIZE (CONN->TOP_CONTEXT) == -1)
              RETURN -1;
            BACKEND_CLOSE (CONN->TOP_CONTEXT);
            CONN->TOP_CONTEXT = NULL;
          }
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_UNKNOWN) == -1)
            RETURN -1;
          CONTINUE;
        }

        IF (SEND_NEWSTYLE_OPTION_REPLY_INFO_EXPORT (OPTION,
                                                    NBD_REP_INFO,
                                                    NBD_INFO_EXPORT,
                                                    EXPORTSIZE) == -1)
          RETURN -1;

        /* FOR NOW WE SEND NBD_INFO_NAME AND NBD_INFO_DESCRIPTION IF
         * REQUESTED, AND IGNORE ALL OTHER INFO REQUESTS (INCLUDING
         * NBD_INFO_EXPORT IF IT WAS REQUESTED, BECAUSE WE REPLIED
         * ALREADY ABOVE).
         */
        FOR (I = 0; I < NRINFOS; ++I) {
          MEMCPY (&INFO, &DATA[4 + EXPORTNAMELEN + 2 + I*2], 2);
          INFO = BE16TOH (INFO);
          SWITCH (INFO) {
          CASE NBD_INFO_EXPORT: /* IGNORE - REPLY SENT ABOVE */ BREAK;
          CASE NBD_INFO_NAME:
            {
              CONST CHAR *NAME = &DATA[4];
              SIZE_T NAMELEN = EXPORTNAMELEN;

              IF (EXPORTNAMELEN == 0) {
                NAME = BACKEND_DEFAULT_EXPORT (TOP, READ_ONLY);
                IF (!NAME) {
                  DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                         "NBD_INFO_NAME: NO NAME TO SEND", OPTNAME);
                  BREAK;
                }
                NAMELEN = -1;
              }
              IF (SEND_NEWSTYLE_OPTION_REPLY_INFO_STR (OPTION,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_NAME,
                                                       NAME, NAMELEN) == -1)
                RETURN -1;
            }
            BREAK;
          CASE NBD_INFO_DESCRIPTION:
            {
              CONST CHAR *DESC = BACKEND_EXPORT_DESCRIPTION (CONN->TOP_CONTEXT);

              IF (!DESC) {
                DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                       "NBD_INFO_DESCRIPTION: NO DESCRIPTION TO SEND",
                       OPTNAME);
                BREAK;
              }
              IF (SEND_NEWSTYLE_OPTION_REPLY_INFO_STR (OPTION,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_DESCRIPTION,
                                                       DESC, -1) == -1)
                RETURN -1;
            }
            BREAK;
          DEFAULT:
            DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                   "IGNORING NBD_INFO_* REQUEST %U (%S)",
                   OPTNAME, (UNSIGNED) INFO, NAME_OF_NBD_INFO (INFO));
            BREAK;
          }
        }
      }

      /* UNLIKE NBD_OPT_EXPORT_NAME, NBD_OPT_GO SENDS BACK AN ACK
       * OR ERROR PACKET.  IF THIS WAS NBD_OPT_LIST, CALL .CLOSE.
       */
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
        RETURN -1;

      IF (OPTION == NBD_OPT_INFO) {
        IF (BACKEND_FINALIZE (CONN->TOP_CONTEXT) == -1)
          RETURN -1;
        BACKEND_CLOSE (CONN->TOP_CONTEXT);
        CONN->TOP_CONTEXT = NULL;
      }

      BREAK;

    CASE NBD_OPT_STRUCTURED_REPLY:
      IF (OPTLEN != 0) {
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        IF (CONN_RECV_FULL (DATA, OPTLEN,
                            "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
          RETURN -1;
        CONTINUE;
      }

      DEBUG ("NEWSTYLE NEGOTIATION: %S: CLIENT REQUESTED STRUCTURED REPLIES",
             NAME_OF_NBD_OPT (OPTION));

      IF (NO_SR) {
        /* MUST FAIL WITH ERR_UNSUP FOR QEMU 4.2 TO REMAIN HAPPY;
         * BUT FAILING WITH ERR_POLICY WOULD HAVE BEEN NICER.
         */
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_UNSUP) == -1)
          RETURN -1;
        DEBUG ("NEWSTYLE NEGOTIATION: %S: STRUCTURED REPLIES ARE DISABLED",
               NAME_OF_NBD_OPT (OPTION));
        BREAK;
      }

      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
        RETURN -1;

      CONN->STRUCTURED_REPLIES = TRUE;
      BREAK;

    CASE NBD_OPT_LIST_META_CONTEXT:
    CASE NBD_OPT_SET_META_CONTEXT:
      {
        UINT32_T OPT_INDEX;
        UINT32_T EXPORTNAMELEN;
        UINT32_T NR_QUERIES;
        UINT32_T QUERYLEN;
        CONST CHAR *WHAT;

        IF (CONN_RECV_FULL (DATA, OPTLEN, "READ: %S: %M", OPTNAME) == -1)
          RETURN -1;

        /* NOTE THAT WE SUPPORT BASE:ALLOCATION WHETHER OR NOT THE PLUGIN
         * SUPPORTS CAN_EXTENTS.
         */
        IF (!CONN->STRUCTURED_REPLIES) {
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        /* MINIMUM LENGTH OF THE OPTION PAYLOAD IS:
         *   32 BIT EXPORT NAME LENGTH FOLLOWED BY EMPTY EXPORT NAME
         * + 32 BIT NUMBER OF QUERIES FOLLOWED BY NO QUERIES
         * = 8 BYTES.
         */
        WHAT = "OPTLEN < 8";
        IF (OPTLEN < 8) {
        OPT_META_INVALID_OPTION_LEN:
          DEBUG ("NEWSTYLE NEGOTIATION: %S: INVALID OPTION LENGTH: %S",
                 OPTNAME, WHAT);

          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        MEMCPY (&EXPORTNAMELEN, &DATA[0], 4);
        EXPORTNAMELEN = BE32TOH (EXPORTNAMELEN);
        WHAT = "VALIDATING EXPORT NAME";
        IF (CHECK_EXPORT_NAME (OPTION, &DATA[4], EXPORTNAMELEN,
                               OPTLEN - 8) == -1)
          GOTO OPT_META_INVALID_OPTION_LEN;

        /* REMEMBER THE EXPORT NAME: THE NBD SPEC SAYS THAT IF THE CLIENT
         * LATER USES NBD_OPT_GO ON A DIFFERENT EXPORT, THEN THE CONTEXT
         * RETURNED HERE IS NOT USABLE.
         */
        IF (OPTION == NBD_OPT_SET_META_CONTEXT) {
          CONN->EXPORTNAME_FROM_SET_META_CONTEXT =
            STRNDUP (&DATA[4], EXPORTNAMELEN);
          IF (CONN->EXPORTNAME_FROM_SET_META_CONTEXT == NULL) {
            NBDKIT_ERROR ("MALLOC: %M");
            RETURN -1;
          }
        }

        OPT_INDEX = 4 + EXPORTNAMELEN;

        /* READ THE NUMBER OF QUERIES. */
        WHAT = "READING NUMBER OF QUERIES";
        IF (OPT_INDEX+4 > OPTLEN)
          GOTO OPT_META_INVALID_OPTION_LEN;
        MEMCPY (&NR_QUERIES, &DATA[OPT_INDEX], 4);
        NR_QUERIES = BE32TOH (NR_QUERIES);
        OPT_INDEX += 4;

        /* FOR LIST: NR_QUERIES == 0 MEANS RETURN ALL META CONTEXTS
         * FOR SET: NR_QUERIES == 0 MEANS RESET ALL CONTEXTS
         */
        DEBUG ("NEWSTYLE NEGOTIATION: %S: %S COUNT: %D", OPTNAME,
               OPTION == NBD_OPT_LIST_META_CONTEXT ? "QUERY" : "SET",
               NR_QUERIES);
        IF (OPTION == NBD_OPT_SET_META_CONTEXT)
          CONN->META_CONTEXT_BASE_ALLOCATION = FALSE;
        IF (NR_QUERIES == 0) {
          IF (OPTION == NBD_OPT_LIST_META_CONTEXT) {
            IF (SEND_NEWSTYLE_OPTION_REPLY_META_CONTEXT (OPTION,
                                                         NBD_REP_META_CONTEXT,
                                                         0, "BASE:ALLOCATION")
                == -1)
              RETURN -1;
          }

          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
            RETURN -1;
        }
        ELSE {
          /* READ AND ANSWER EACH QUERY. */
          WHILE (NR_QUERIES > 0) {
            WHAT = "READING QUERY STRING LENGTH";
            IF (OPT_INDEX+4 > OPTLEN)
              GOTO OPT_META_INVALID_OPTION_LEN;
            MEMCPY (&QUERYLEN, &DATA[OPT_INDEX], 4);
            QUERYLEN = BE32TOH (QUERYLEN);
            OPT_INDEX += 4;
            WHAT = "READING QUERY STRING";
            IF (CHECK_STRING (OPTION, &DATA[OPT_INDEX], QUERYLEN,
                              OPTLEN - OPT_INDEX, "META CONTEXT QUERY") == -1)
              GOTO OPT_META_INVALID_OPTION_LEN;

            DEBUG ("NEWSTYLE NEGOTIATION: %S: %S %.*S",
                   OPTNAME,
                   OPTION == NBD_OPT_LIST_META_CONTEXT ? "QUERY" : "SET",
                   (INT) QUERYLEN, &DATA[OPT_INDEX]);

            /* FOR LIST, "BASE:" RETURNS ALL SUPPORTED CONTEXTS IN THE
             * BASE NAMESPACE.  WE ONLY SUPPORT "BASE:ALLOCATION".
             */
            IF (OPTION == NBD_OPT_LIST_META_CONTEXT &&
                QUERYLEN == 5 &&
                STRNCMP (&DATA[OPT_INDEX], "BASE:", 5) == 0) {
              IF (SEND_NEWSTYLE_OPTION_REPLY_META_CONTEXT
                  (OPTION, NBD_REP_META_CONTEXT,
                   0, "BASE:ALLOCATION") == -1)
                RETURN -1;
            }
            /* "BASE:ALLOCATION" REQUESTED BY NAME. */
            ELSE IF (QUERYLEN == 15 &&
                     STRNCMP (&DATA[OPT_INDEX], "BASE:ALLOCATION", 15) == 0) {
              IF (SEND_NEWSTYLE_OPTION_REPLY_META_CONTEXT
                  (OPTION, NBD_REP_META_CONTEXT,
                   OPTION == NBD_OPT_SET_META_CONTEXT
                   ? BASE_ALLOCATION_ID : 0,
                   "BASE:ALLOCATION") == -1)
                RETURN -1;
              IF (OPTION == NBD_OPT_SET_META_CONTEXT)
                CONN->META_CONTEXT_BASE_ALLOCATION = TRUE;
            }
            /* EVERY OTHER QUERY MUST BE IGNORED. */

            OPT_INDEX += QUERYLEN;
            NR_QUERIES--;
          }
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
            RETURN -1;
        }
        DEBUG ("NEWSTYLE NEGOTIATION: %S: REPLY COMPLETE", OPTNAME);
      }
      BREAK;

    DEFAULT:
      /* UNKNOWN OPTION. */
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_UNSUP) == -1)
        RETURN -1;
      IF (CONN_RECV_FULL (DATA, OPTLEN,
                          "READING UNKNOWN OPTION DATA: CONN->RECV: %M") == -1)
        RETURN -1;
    }

    /* NOTE, SINCE IT'S NOT VERY CLEAR FROM THE PROTOCOL DOC, THAT THE
     * CLIENT MUST SEND NBD_OPT_EXPORT_NAME OR NBD_OPT_GO LAST, AND
     * THAT ENDS OPTION NEGOTIATION.
     */
    IF (OPTION == NBD_OPT_EXPORT_NAME || OPTION == NBD_OPT_GO)
      BREAK;
  }

  IF (NR_OPTIONS == 0) {
    NBDKIT_ERROR ("CLIENT SPENT TOO MUCH TIME NEGOTIATING WITHOUT SELECTING "
                  "AN EXPORT");
    RETURN -1;
  }

  /* IN --TLS=REQUIRE / FORCEDTLS MODE, WE MUST HAVE UPGRADED TO TLS
   * BY THE TIME WE FINISH OPTION NEGOTIATION.  IF NOT, GIVE UP.
   */
  IF (TLS == 2 && !CONN->USING_TLS) {
    NBDKIT_ERROR ("NON-TLS CLIENT TRIED TO CONNECT IN --TLS=REQUIRE MODE");
    RETURN -1;
  }

  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209106_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT AX25_RELEASE(STRUCT SOCKET *SOCK)
{
	STRUCT SOCK *SK = SOCK->SK;
	AX25_CB *AX25;
	AX25_DEV *AX25_DEV;

	IF (SK == NULL)
		RETURN 0;

	SOCK_HOLD(SK);
	LOCK_SOCK(SK);
	SOCK_ORPHAN(SK);
	AX25 = SK_TO_AX25(SK);
	AX25_DEV = AX25->AX25_DEV;
	IF (AX25_DEV) {
		DEV_PUT_TRACK(AX25_DEV->DEV, &AX25_DEV->DEV_TRACKER);
		AX25_DEV_PUT(AX25_DEV);
	}

	IF (SK->SK_TYPE == SOCK_SEQPACKET) {
		SWITCH (AX25->STATE) {
		CASE AX25_STATE_0:
			RELEASE_SOCK(SK);
			AX25_DISCONNECT(AX25, 0);
			LOCK_SOCK(SK);
			AX25_DESTROY_SOCKET(AX25);
			BREAK;

		CASE AX25_STATE_1:
		CASE AX25_STATE_2:
			AX25_SEND_CONTROL(AX25, AX25_DISC, AX25_POLLON, AX25_COMMAND);
			RELEASE_SOCK(SK);
			AX25_DISCONNECT(AX25, 0);
			LOCK_SOCK(SK);
			IF (!SOCK_FLAG(AX25->SK, SOCK_DESTROY))
				AX25_DESTROY_SOCKET(AX25);
			BREAK;

		CASE AX25_STATE_3:
		CASE AX25_STATE_4:
			AX25_CLEAR_QUEUES(AX25);
			AX25->N2COUNT = 0;

			SWITCH (AX25->AX25_DEV->VALUES[AX25_VALUES_PROTOCOL]) {
			CASE AX25_PROTO_STD_SIMPLEX:
			CASE AX25_PROTO_STD_DUPLEX:
				AX25_SEND_CONTROL(AX25,
						  AX25_DISC,
						  AX25_POLLON,
						  AX25_COMMAND);
				AX25_STOP_T2TIMER(AX25);
				AX25_STOP_T3TIMER(AX25);
				AX25_STOP_IDLETIMER(AX25);
				BREAK;
#IFDEF CONFIG_AX25_DAMA_SLAVE
			CASE AX25_PROTO_DAMA_SLAVE:
				AX25_STOP_T3TIMER(AX25);
				AX25_STOP_IDLETIMER(AX25);
				BREAK;
#ENDIF
			}
			AX25_CALCULATE_T1(AX25);
			AX25_START_T1TIMER(AX25);
			AX25->STATE = AX25_STATE_2;
			SK->SK_STATE                = TCP_CLOSE;
			SK->SK_SHUTDOWN            |= SEND_SHUTDOWN;
			SK->SK_STATE_CHANGE(SK);
			SOCK_SET_FLAG(SK, SOCK_DESTROY);
			BREAK;

		DEFAULT:
			BREAK;
		}
	} ELSE {
		SK->SK_STATE     = TCP_CLOSE;
		SK->SK_SHUTDOWN |= SEND_SHUTDOWN;
		SK->SK_STATE_CHANGE(SK);
		AX25_DESTROY_SOCKET(AX25);
	}

	SOCK->SK   = NULL;
	RELEASE_SOCK(SK);
	SOCK_PUT(SK);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211103_CWE-22.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
_FR_WINDOW_ASK_OVERWRITE_DIALOG (OVERWRITEDATA *ODATA)
{
	IF ((ODATA->EDATA->OVERWRITE == FR_OVERWRITE_ASK) && (ODATA->CURRENT_FILE != NULL)) {
		CONST CHAR *BASE_NAME;
		GFILE      *DESTINATION;

		BASE_NAME = _G_PATH_GET_RELATIVE_BASENAME ((CHAR *) ODATA->CURRENT_FILE->DATA, ODATA->EDATA->BASE_DIR, ODATA->EDATA->JUNK_PATHS);
		DESTINATION = G_FILE_GET_CHILD (ODATA->EDATA->DESTINATION, BASE_NAME);
		G_FILE_QUERY_INFO_ASYNC (DESTINATION,
					 G_FILE_ATTRIBUTE_STANDARD_TYPE "," G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,
					 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
					 G_PRIORITY_DEFAULT,
					 ODATA->WINDOW->PRIV->CANCELLABLE,
					 QUERY_INFO_READY_FOR_OVERWRITE_DIALOG_CB,
					 ODATA);

		G_OBJECT_UNREF (DESTINATION);

		RETURN;
	}

	IF (ODATA->EDATA->FILE_LIST != NULL) {
		/* SPEED OPTIMIZATION: PASSING NULL WHEN EXTRACTING ALL THE
		 * FILES IS FASTER IF THE COMMAND SUPPORTS THE
		 * PROPCANEXTRACTALL PROPERTY. */
		IF (ODATA->EXTRACT_ALL) {
			_G_STRING_LIST_FREE (ODATA->EDATA->FILE_LIST);
			ODATA->EDATA->FILE_LIST = NULL;
		}
		ODATA->EDATA->OVERWRITE = FR_OVERWRITE_YES;
		_FR_WINDOW_ARCHIVE_EXTRACT_FROM_EDATA (ODATA->WINDOW, ODATA->EDATA);
	}
	ELSE {
		GTKWIDGET *D;

		D = _GTK_MESSAGE_DIALOG_NEW (GTK_WINDOW (ODATA->WINDOW),
					     0,
					     GTK_STOCK_DIALOG_WARNING,
					     _("EXTRACTION NOT PERFORMED"),
					     NULL,
					     GTK_STOCK_OK, GTK_RESPONSE_OK,
					     NULL);
		GTK_DIALOG_SET_DEFAULT_RESPONSE (GTK_DIALOG (D), GTK_RESPONSE_OK);
		FR_WINDOW_SHOW_ERROR_DIALOG (ODATA->WINDOW, D, GTK_WINDOW (ODATA->WINDOW), _("EXTRACTION NOT PERFORMED"));

		FR_WINDOW_STOP_BATCH (ODATA->WINDOW);
	}

	G_FREE (ODATA);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197808_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_F_SEND(MRB_STATE *MRB, MRB_VALUE SELF)
{
  MRB_SYM NAME;
  MRB_VALUE BLOCK, *REGS;
  MRB_METHOD_T M;
  STRUCT RCLASS *C;
  MRB_CALLINFO *CI = MRB->C->CI;
  INT N = CI->N;

  IF (CI->CCI > CINFO_NONE) {
  FUNCALL:;
    CONST MRB_VALUE *ARGV;
    MRB_INT ARGC;
    MRB_GET_ARGS(MRB, "N*&", &NAME, &ARGV, &ARGC, &BLOCK);
    RETURN MRB_FUNCALL_WITH_BLOCK(MRB, SELF, NAME, ARGC, ARGV, BLOCK);
  }

  REGS = MRB->C->CI->STACK+1;

  IF (N == 0) {
    MRB_ARGNUM_ERROR(MRB, 0, 1, -1);
  }
  ELSE IF (N == 15) {
    NAME = MRB_OBJ_TO_SYM(MRB, RARRAY_PTR(REGS[0])[0]);
  }
  ELSE {
    NAME = MRB_OBJ_TO_SYM(MRB, REGS[0]);
  }

  C = MRB_CLASS(MRB, SELF);
  M = MRB_METHOD_SEARCH_VM(MRB, &C, NAME);
  IF (MRB_METHOD_UNDEF_P(M)) {            /* CALL METHOD_MISING */
    GOTO FUNCALL;
  }

  CI->MID = NAME;
  CI->U.TARGET_CLASS = C;
  /* REMOVE FIRST SYMBOL FROM ARGUMENTS */
  IF (N == 15) {     /* VARIABLE LENGTH ARGUMENTS */
    REGS[0] = MRB_ARY_SUBSEQ(MRB, REGS[0], 1, RARRAY_LEN(REGS[0]) - 1);
  }
  ELSE { /* N > 0 */
    FOR (INT I=0; I<N; I++) {
      REGS[I] = REGS[I+1];
    }
    REGS[N] = REGS[N+1];        /* COPY KDICT OR BLOCK */
    IF (CI->NK > 0) {
      REGS[N+1] = REGS[N+2];    /* COPY BLOCK */
    }
    CI->N--;
  }

  IF (MRB_METHOD_CFUNC_P(M)) {
    IF (MRB_METHOD_NOARG_P(M)) {
      CHECK_METHOD_NOARG(MRB, CI);
    }

    IF (MRB_METHOD_PROC_P(M)) {
      MRB_VM_CI_PROC_SET(CI, MRB_METHOD_PROC(M));
    }
    RETURN MRB_METHOD_CFUNC(M)(MRB, SELF);
  }
  RETURN EXEC_IREP(MRB, SELF, MRB_METHOD_PROC(M));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 278262_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_INDENT_STR_VTAB(CHAR_U *PTR, INT TS, INT *VTS, INT LIST)
{
    INT		COUNT = 0;

    FOR ( ; *PTR; ++PTR)
    {
	IF (*PTR == TAB)    // COUNT A TAB FOR WHAT IT IS WORTH
	{
	    IF (!LIST || CURWIN->W_LCS_CHARS.TAB1)
		COUNT += TABSTOP_PADDING(COUNT, TS, VTS);
	    ELSE
		// IN LIST MODE, WHEN TAB IS NOT SET, COUNT SCREEN CHAR WIDTH
		// FOR TAB, DISPLAYS: ^I
		COUNT += PTR2CELLS(PTR);
	}
	ELSE IF (*PTR == ' ')
	    ++COUNT;		// COUNT A SPACE FOR ONE
	ELSE
	    BREAK;
    }
    RETURN COUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234164_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FREE_DWO_INFO (VOID)
{
  DWO_INFO * DWINFO;
  DWO_INFO * NEXT;

  FOR (DWINFO = FIRST_DWO_INFO; DWINFO != NULL; DWINFO = NEXT)
    {
      NEXT = DWINFO->NEXT;
      FREE (DWINFO);
    }
  FIRST_DWO_INFO = NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343161_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID __EXIT ESP6_FINI(VOID)
{
	IF (XFRM6_PROTOCOL_DEREGISTER(&ESP6_PROTOCOL, IPPROTO_ESP) < 0)
		PR_INFO("%S: CAN'T REMOVE PROTOCOL\N", __FUNC__);
	XFRM_UNREGISTER_TYPE(&ESP6_TYPE, AF_INET6);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 436128_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

STATIC INT IO_SQ_THREAD(VOID *DATA)
{
	STRUCT IO_SQ_DATA *SQD = DATA;
	STRUCT IO_RING_CTX *CTX;
	UNSIGNED LONG TIMEOUT = 0;
	CHAR BUF[TASK_COMM_LEN];
	DEFINE_WAIT(WAIT);

	SNPRINTF(BUF, SIZEOF(BUF), "IOU-SQP-%D", SQD->TASK_PID);
	SET_TASK_COMM(CURRENT, BUF);

	IF (SQD->SQ_CPU != -1)
		SET_CPUS_ALLOWED_PTR(CURRENT, CPUMASK_OF(SQD->SQ_CPU));
	ELSE
		SET_CPUS_ALLOWED_PTR(CURRENT, CPU_ONLINE_MASK);
	CURRENT->FLAGS |= PF_NO_SETAFFINITY;

	MUTEX_LOCK(&SQD->LOCK);
	WHILE (1) {
		BOOL CAP_ENTRIES, SQT_SPIN = FALSE;

		IF (IO_SQD_EVENTS_PENDING(SQD) || SIGNAL_PENDING(CURRENT)) {
			IF (IO_SQD_HANDLE_EVENT(SQD))
				BREAK;
			TIMEOUT = JIFFIES + SQD->SQ_THREAD_IDLE;
		}

		CAP_ENTRIES = !LIST_IS_SINGULAR(&SQD->CTX_LIST);
		LIST_FOR_EACH_ENTRY(CTX, &SQD->CTX_LIST, SQD_LIST) {
			INT RET = __IO_SQ_THREAD(CTX, CAP_ENTRIES);

			IF (!SQT_SPIN && (RET > 0 || !LIST_EMPTY(&CTX->IOPOLL_LIST)))
				SQT_SPIN = TRUE;
		}
		IF (IO_RUN_TASK_WORK())
			SQT_SPIN = TRUE;

		IF (SQT_SPIN || !TIME_AFTER(JIFFIES, TIMEOUT)) {
			COND_RESCHED();
			IF (SQT_SPIN)
				TIMEOUT = JIFFIES + SQD->SQ_THREAD_IDLE;
			CONTINUE;
		}

		PREPARE_TO_WAIT(&SQD->WAIT, &WAIT, TASK_INTERRUPTIBLE);
		IF (!IO_SQD_EVENTS_PENDING(SQD) && !CURRENT->TASK_WORKS) {
			BOOL NEEDS_SCHED = TRUE;

			LIST_FOR_EACH_ENTRY(CTX, &SQD->CTX_LIST, SQD_LIST) {
				IO_RING_SET_WAKEUP_FLAG(CTX);

				IF ((CTX->FLAGS & IORING_SETUP_IOPOLL) &&
				    !LIST_EMPTY_CAREFUL(&CTX->IOPOLL_LIST)) {
					NEEDS_SCHED = FALSE;
					BREAK;
				}
				IF (IO_SQRING_ENTRIES(CTX)) {
					NEEDS_SCHED = FALSE;
					BREAK;
				}
			}

			IF (NEEDS_SCHED) {
				MUTEX_UNLOCK(&SQD->LOCK);
				SCHEDULE();
				MUTEX_LOCK(&SQD->LOCK);
			}
			LIST_FOR_EACH_ENTRY(CTX, &SQD->CTX_LIST, SQD_LIST)
				IO_RING_CLEAR_WAKEUP_FLAG(CTX);
		}

		FINISH_WAIT(&SQD->WAIT, &WAIT);
		TIMEOUT = JIFFIES + SQD->SQ_THREAD_IDLE;
	}

	IO_URING_CANCEL_GENERIC(TRUE, SQD);
	SQD->THREAD = NULL;
	LIST_FOR_EACH_ENTRY(CTX, &SQD->CTX_LIST, SQD_LIST)
		IO_RING_SET_WAKEUP_FLAG(CTX);
	IO_RUN_TASK_WORK();
	MUTEX_UNLOCK(&SQD->LOCK);

	COMPLETE(&SQD->EXITED);
	DO_EXIT(0);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 439087_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MAGICKBOOLEANTYPE WRITEPALMIMAGE(CONST IMAGEINFO *IMAGE_INFO,
  IMAGE *IMAGE)
{
  EXCEPTIONINFO
    *EXCEPTION;

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    CURRENTOFFSET,
    OFFSET,
    SCENE;

  MAGICKSIZETYPE
    CC;

  PIXELPACKET
    TRANSPIX;

  QUANTIZEINFO
    *QUANTIZE_INFO;

  REGISTER INDEXPACKET
    *INDEXES;

  REGISTER SSIZE_T
    X;

  REGISTER PIXELPACKET
    *P;

  SSIZE_T
    Y;

  SIZE_T
    COUNT,
    BITS_PER_PIXEL,
    BYTES_PER_ROW,
    IMAGELISTLENGTH,
    NEXTDEPTHOFFSET,
    ONE;

  UNSIGNED CHAR
    BIT,
    BYTE,
    COLOR,
    *LAST_ROW,
    *ONE_ROW,
    *PTR,
    VERSION;

  UNSIGNED INT
    TRANSPARENTINDEX;

  UNSIGNED SHORT
    COLOR16,
    FLAGS;

  /*
    OPEN OUTPUT IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  ASSERT(IMAGE != (IMAGE *) NULL);
  ASSERT(IMAGE->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",IMAGE->FILENAME);
  EXCEPTION=ACQUIREEXCEPTIONINFO();
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,WRITEBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    RETURN(STATUS);
  QUANTIZE_INFO=ACQUIREQUANTIZEINFO(IMAGE_INFO);
  FLAGS=0;
  CURRENTOFFSET=0;
  TRANSPARENTINDEX=0;
  TRANSPIX.RED=0;
  TRANSPIX.GREEN=0;
  TRANSPIX.BLUE=0;
  TRANSPIX.OPACITY=0;
  ONE=1;
  VERSION=0;
  SCENE=0;
  IMAGELISTLENGTH=GETIMAGELISTLENGTH(IMAGE);
  DO
  {
    (VOID) TRANSFORMIMAGECOLORSPACE(IMAGE,SRGBCOLORSPACE);
    COUNT=GETNUMBERCOLORS(IMAGE,NULL,EXCEPTION);
    FOR (BITS_PER_PIXEL=1;  (ONE << BITS_PER_PIXEL) < COUNT; BITS_PER_PIXEL*=2) ;
    IF (BITS_PER_PIXEL > 16)
      BITS_PER_PIXEL=16;
    ELSE
      IF (BITS_PER_PIXEL < 16)
        (VOID) TRANSFORMIMAGECOLORSPACE(IMAGE,IMAGE->COLORSPACE);
    IF (BITS_PER_PIXEL < 8)
      {
        (VOID) TRANSFORMIMAGECOLORSPACE(IMAGE,GRAYCOLORSPACE);
        (VOID) SETIMAGETYPE(IMAGE,PALETTETYPE);
        (VOID) SORTCOLORMAPBYINTENSITY(IMAGE);
      }
    IF ((IMAGE->STORAGE_CLASS == PSEUDOCLASS) && (IMAGE->COLORS > 256))
      (VOID) SETIMAGESTORAGECLASS(IMAGE,DIRECTCLASS);
    IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
      FLAGS|=PALM_HAS_COLORMAP_FLAG;
    ELSE
      FLAGS|=PALM_IS_DIRECT_COLOR;
    (VOID) WRITEBLOBMSBSHORT(IMAGE,(UNSIGNED SHORT) IMAGE->COLUMNS); /* WIDTH */
    (VOID) WRITEBLOBMSBSHORT(IMAGE,(UNSIGNED SHORT) IMAGE->ROWS);  /* HEIGHT */
    BYTES_PER_ROW=((IMAGE->COLUMNS+(16/BITS_PER_PIXEL-1))/(16/
      BITS_PER_PIXEL))*2;
    (VOID) WRITEBLOBMSBSHORT(IMAGE,(UNSIGNED SHORT) BYTES_PER_ROW);
    IF ((IMAGE_INFO->COMPRESSION == RLECOMPRESSION) ||
        (IMAGE_INFO->COMPRESSION == FAXCOMPRESSION))
      FLAGS|=PALM_IS_COMPRESSED_FLAG;
    (VOID) WRITEBLOBMSBSHORT(IMAGE, FLAGS);
    (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) BITS_PER_PIXEL);
    IF (BITS_PER_PIXEL > 1)
      VERSION=1;
    IF ((IMAGE_INFO->COMPRESSION == RLECOMPRESSION) ||
        (IMAGE_INFO->COMPRESSION == FAXCOMPRESSION))
      VERSION=2;
    (VOID) WRITEBLOBBYTE(IMAGE,VERSION);
    (VOID) WRITEBLOBMSBSHORT(IMAGE,0);  /* NEXTDEPTHOFFSET */
    (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) TRANSPARENTINDEX);
    IF (IMAGE_INFO->COMPRESSION == RLECOMPRESSION)
      (VOID) WRITEBLOBBYTE(IMAGE,PALM_COMPRESSION_RLE);
    ELSE
      IF (IMAGE_INFO->COMPRESSION == FAXCOMPRESSION)
        (VOID) WRITEBLOBBYTE(IMAGE,PALM_COMPRESSION_SCANLINE);
      ELSE
        (VOID) WRITEBLOBBYTE(IMAGE,PALM_COMPRESSION_NONE);
    (VOID) WRITEBLOBMSBSHORT(IMAGE,0);  /* RESERVED */
    OFFSET=16;
    IF (BITS_PER_PIXEL == 16)
      {
        (VOID) WRITEBLOBBYTE(IMAGE,5);  /* # OF BITS OF RED */
        (VOID) WRITEBLOBBYTE(IMAGE,6);  /* # OF BITS OF GREEN */
        (VOID) WRITEBLOBBYTE(IMAGE,5);  /* # OF BITS OF BLUE */
        (VOID) WRITEBLOBBYTE(IMAGE,0);  /* RESERVED BY PALM */
        (VOID) WRITEBLOBMSBLONG(IMAGE,0);  /* NO TRANSPARENT COLOR, YET */
        OFFSET+=8;
      }
    IF (BITS_PER_PIXEL == 8)
      {
        IF (FLAGS & PALM_HAS_COLORMAP_FLAG)  /* WRITE OUT COLORMAP */
          {
            QUANTIZE_INFO->DITHER=ISPALETTEIMAGE(IMAGE,&IMAGE->EXCEPTION);
            QUANTIZE_INFO->NUMBER_COLORS=IMAGE->COLORS;
            (VOID) QUANTIZEIMAGE(QUANTIZE_INFO,IMAGE);
            (VOID) WRITEBLOBMSBSHORT(IMAGE,(UNSIGNED SHORT) IMAGE->COLORS);
            FOR (COUNT = 0; COUNT < IMAGE->COLORS; COUNT++)
            {
              (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) COUNT);
              (VOID) WRITEBLOBBYTE(IMAGE,SCALEQUANTUMTOCHAR(
                IMAGE->COLORMAP[COUNT].RED));
              (VOID) WRITEBLOBBYTE(IMAGE,
                SCALEQUANTUMTOCHAR(IMAGE->COLORMAP[COUNT].GREEN));
              (VOID) WRITEBLOBBYTE(IMAGE,
                SCALEQUANTUMTOCHAR(IMAGE->COLORMAP[COUNT].BLUE));
            }
            OFFSET+=2+COUNT*4;
          }
      ELSE  /* MAP COLORS TO PALM STANDARD COLORMAP */
        {
          IMAGE
            *AFFINITY_IMAGE;

          AFFINITY_IMAGE=CONSTITUTEIMAGE(256,1,"RGB",CHARPIXEL,&PALMPALETTE,
            EXCEPTION);
          (VOID) TRANSFORMIMAGECOLORSPACE(AFFINITY_IMAGE,
            AFFINITY_IMAGE->COLORSPACE);
          (VOID) REMAPIMAGE(QUANTIZE_INFO,IMAGE,AFFINITY_IMAGE);
          FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
          {
            P=GETAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
            INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
            FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
              SETPIXELINDEX(INDEXES+X,FINDCOLOR(&IMAGE->COLORMAP[
                (SSIZE_T) GETPIXELINDEX(INDEXES+X)]));
          }
          AFFINITY_IMAGE=DESTROYIMAGE(AFFINITY_IMAGE);
        }
      }
    IF (FLAGS & PALM_IS_COMPRESSED_FLAG)
      (VOID) WRITEBLOBMSBSHORT(IMAGE,0);  /* FILL IN SIZE LATER */
    LAST_ROW=(UNSIGNED CHAR *) NULL;
    IF (IMAGE_INFO->COMPRESSION == FAXCOMPRESSION)
      {
        LAST_ROW=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY(BYTES_PER_ROW,
          SIZEOF(*LAST_ROW));
        IF (LAST_ROW == (UNSIGNED CHAR *) NULL)
          {
            QUANTIZE_INFO=DESTROYQUANTIZEINFO(QUANTIZE_INFO);
            THROWWRITEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
          }
      }
    ONE_ROW=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY(BYTES_PER_ROW,
      SIZEOF(*ONE_ROW));
    IF (ONE_ROW == (UNSIGNED CHAR *) NULL)
      {
        IF (LAST_ROW != (UNSIGNED CHAR *) NULL)
          LAST_ROW=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(LAST_ROW);
        QUANTIZE_INFO=DESTROYQUANTIZEINFO(QUANTIZE_INFO);
        THROWWRITEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
      }
    FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
    {
      PTR=ONE_ROW;
      (VOID) MEMSET(PTR,0,BYTES_PER_ROW);
      P=GETAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
      IF (P == (PIXELPACKET *) NULL)
        BREAK;
      INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
      IF (BITS_PER_PIXEL == 16)
        {
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            COLOR16=(UNSIGNED SHORT) ((((31*(SIZE_T) GETPIXELRED(P))/
              (SIZE_T) QUANTUMRANGE) << 11) |
              (((63*(SIZE_T) GETPIXELGREEN(P))/(SIZE_T) QUANTUMRANGE) << 5) |
              ((31*(SIZE_T) GETPIXELBLUE(P))/(SIZE_T) QUANTUMRANGE));
            IF (GETPIXELOPACITY(P) == (QUANTUM) TRANSPARENTOPACITY)
              {
                TRANSPIX.RED=GETPIXELRED(P);
                TRANSPIX.GREEN=GETPIXELGREEN(P);
                TRANSPIX.BLUE=GETPIXELBLUE(P);
                TRANSPIX.OPACITY=GETPIXELOPACITY(P);
                FLAGS|=PALM_HAS_TRANSPARENCY_FLAG;
              }
            *PTR++=(UNSIGNED CHAR) ((COLOR16 >> 8) & 0XFF);
            *PTR++=(UNSIGNED CHAR) (COLOR16 & 0XFF);
            P++;
          }
        }
      ELSE
        {
          BYTE=0X00;
          BIT=(UNSIGNED CHAR) (8-BITS_PER_PIXEL);
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            IF (BITS_PER_PIXEL >= 8)
              COLOR=(UNSIGNED CHAR) GETPIXELINDEX(INDEXES+X);
            ELSE
              COLOR=(UNSIGNED CHAR) (GETPIXELINDEX(INDEXES+X)*
                ((ONE << BITS_PER_PIXEL)-1)/MAGICKMAX(1*IMAGE->COLORS-1,1));
            BYTE|=COLOR << BIT;
            IF (BIT != 0)
              BIT-=(UNSIGNED CHAR) BITS_PER_PIXEL;
            ELSE
              {
                *PTR++=BYTE;
                BYTE=0X00;
                BIT=(UNSIGNED CHAR) (8-BITS_PER_PIXEL);
              }
          }
          IF ((IMAGE->COLUMNS % (8/BITS_PER_PIXEL)) != 0)
            *PTR++=BYTE;
        }
      IF (IMAGE_INFO->COMPRESSION == RLECOMPRESSION)
        {
          X=0;
          WHILE (X < (SSIZE_T) BYTES_PER_ROW)
          {
            BYTE=ONE_ROW[X];
            COUNT=1;
            WHILE ((ONE_ROW[++X] == BYTE) && (COUNT < 255) &&
                   (X < (SSIZE_T) BYTES_PER_ROW))
              COUNT++;
            (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) COUNT);
            (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) BYTE);
          }
        }
      ELSE
        IF (IMAGE_INFO->COMPRESSION == FAXCOMPRESSION)
          {
            CHAR
              TMPBUF[8],
              *TPTR;

            FOR (X = 0;  X < (SSIZE_T) BYTES_PER_ROW;  X += 8)
            {
              TPTR = TMPBUF;
              FOR (BIT=0, BYTE=0; BIT < (UNSIGNED CHAR) MAGICKMIN(8,(SSIZE_T) BYTES_PER_ROW-X); BIT++)
              {
                IF ((Y == 0) || (LAST_ROW[X + BIT] != ONE_ROW[X + BIT]))
                  {
                    BYTE |= (1 << (7 - BIT));
                    *TPTR++ = (CHAR) ONE_ROW[X + BIT];
                  }
              }
              (VOID) WRITEBLOBBYTE(IMAGE, BYTE);
              (VOID) WRITEBLOB(IMAGE,TPTR-TMPBUF,(UNSIGNED CHAR *) TMPBUF);
            }
            (VOID) MEMCPY(LAST_ROW,ONE_ROW,BYTES_PER_ROW);
          }
        ELSE
          (VOID) WRITEBLOB(IMAGE,BYTES_PER_ROW,ONE_ROW);
      }
    IF (FLAGS & PALM_HAS_TRANSPARENCY_FLAG)
      {
        OFFSET=SEEKBLOB(IMAGE,CURRENTOFFSET+6,SEEK_SET);
        (VOID) WRITEBLOBMSBSHORT(IMAGE,FLAGS);
        OFFSET=SEEKBLOB(IMAGE,CURRENTOFFSET+12,SEEK_SET);
        (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) TRANSPARENTINDEX);  /* TRANS INDEX */
      }
    IF (BITS_PER_PIXEL == 16)
      {
        OFFSET=SEEKBLOB(IMAGE,CURRENTOFFSET+20,SEEK_SET);
        (VOID) WRITEBLOBBYTE(IMAGE,0);  /* RESERVED BY PALM */
        (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) ((31*TRANSPIX.RED)/
          QUANTUMRANGE));
        (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) ((63*TRANSPIX.GREEN)/
          QUANTUMRANGE));
        (VOID) WRITEBLOBBYTE(IMAGE,(UNSIGNED CHAR) ((31*TRANSPIX.BLUE)/
          QUANTUMRANGE));
      }
    IF (FLAGS & PALM_IS_COMPRESSED_FLAG)  /* FILL IN SIZE NOW */
      {
        OFFSET=SEEKBLOB(IMAGE,CURRENTOFFSET+OFFSET,SEEK_SET);
        (VOID) WRITEBLOBMSBSHORT(IMAGE,(UNSIGNED SHORT) (GETBLOBSIZE(IMAGE)-
          CURRENTOFFSET-OFFSET));
      }
    IF (ONE_ROW != (UNSIGNED CHAR *) NULL)
      ONE_ROW=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(ONE_ROW);
    IF (LAST_ROW != (UNSIGNED CHAR *) NULL)
      LAST_ROW=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(LAST_ROW);
    IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
      BREAK;
    /* PADDING TO 4 BYTE WORD */
    FOR (CC=(GETBLOBSIZE(IMAGE)) % 4; CC > 0; CC--)
      (VOID) WRITEBLOBBYTE(IMAGE,0);
    /* WRITE NEXTDEPTHOFFSET AND RETURN TO END OF IMAGE */
    (VOID) SEEKBLOB(IMAGE,CURRENTOFFSET+10,SEEK_SET);
    NEXTDEPTHOFFSET=(SIZE_T) ((GETBLOBSIZE(IMAGE)-CURRENTOFFSET)/4);
    (VOID) WRITEBLOBMSBSHORT(IMAGE,(UNSIGNED SHORT) NEXTDEPTHOFFSET);
    CURRENTOFFSET=(MAGICKOFFSETTYPE) GETBLOBSIZE(IMAGE);
    (VOID) SEEKBLOB(IMAGE,CURRENTOFFSET,SEEK_SET);
    IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
    STATUS=SETIMAGEPROGRESS(IMAGE,SAVEIMAGESTAG,SCENE++,IMAGELISTLENGTH);
    IF (STATUS == MAGICKFALSE)
      BREAK;
  } WHILE (IMAGE_INFO->ADJOIN != MAGICKFALSE);
  QUANTIZE_INFO=DESTROYQUANTIZEINFO(QUANTIZE_INFO);
  (VOID) CLOSEBLOB(IMAGE);
  (VOID) DESTROYEXCEPTIONINFO(EXCEPTION);
  RETURN(MAGICKTRUE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 309898_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_SGR_PARAM(TERMTYPE2 *TP, INT CODE, CONST CHAR *NAME, CHAR *VALUE)
{
    IF (VALID_STRING(VALUE)) {
	INT NCV = ((CODE != 0) ? (1 << (CODE - 1)) : 0);
	CHAR *TEST = TGOTO(VALUE, 0, 0);
	IF (IS_SGR_STRING(TEST)) {
	    INT PARAM = 0;
	    INT COUNT = 0;
	    INT SKIPS = 0;
	    INT COLOR = (VALUE == SET_A_FOREGROUND ||
			 VALUE == SET_A_BACKGROUND ||
			 VALUE == SET_FOREGROUND ||
			 VALUE == SET_BACKGROUND);
	    WHILE (*TEST != 0) {
		IF (ISDIGIT(UCHAR(*TEST))) {
		    PARAM = 10 * PARAM + (*TEST - '0');
		    ++COUNT;
		} ELSE {
		    IF (COUNT) {
			/*
			 * AVOID UNNECESSARY WARNING FOR XTERM 256COLOR CODES.
			 */
			IF (COLOR && (PARAM == 38 || PARAM == 48))
			    SKIPS = 3;
			IF ((SKIPS-- <= 0) && (PARAM == CODE))
			    BREAK;
		    }
		    COUNT = 0;
		    PARAM = 0;
		}
		++TEST;
	    }
	    IF (COUNT != 0 && PARAM == CODE) {
		IF (CODE == 0 ||
		    NO_COLOR_VIDEO < 0 ||
		    !(NO_COLOR_VIDEO & NCV)) {
		    _NC_WARNING("\"%S\" SGR-ATTRIBUTE USED IN %S",
				SGR_NAMES[CODE],
				NAME);
		}
	    }
	}
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195665_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_ARRAY_PROTOTYPE_SPLICE(NJS_VM_T *VM, NJS_VALUE_T *ARGS, NJS_UINT_T NARGS,
    NJS_INDEX_T UNUSED)
{
    INT64_T      I, N, START, LENGTH, ITEMS, DELTA, DELETE;
    NJS_INT_T    RET;
    NJS_VALUE_T  *THIS, VALUE, DEL_OBJECT;
    NJS_ARRAY_T  *ARRAY, *DELETED;

    THIS = NJS_ARGUMENT(ARGS, 0);

    RET = NJS_VALUE_TO_OBJECT(VM, THIS);
    IF (NJS_SLOW_PATH(RET != NJS_OK)) {
        RETURN RET;
    }

    RET = NJS_OBJECT_LENGTH(VM, THIS, &LENGTH);
    IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
        RETURN RET;
    }

    RET = NJS_VALUE_TO_INTEGER(VM, NJS_ARG(ARGS, NARGS, 1), &START);
    IF (NJS_SLOW_PATH(RET != NJS_OK)) {
        RETURN RET;
    }

    START = (START < 0) ? NJS_MAX(LENGTH + START, 0) : NJS_MIN(START, LENGTH);

    ITEMS = 0;
    DELETE = 0;

    IF (NARGS == 2) {
        DELETE = LENGTH - START;

    } ELSE IF (NARGS > 2) {
        ITEMS = NARGS - 3;

        RET = NJS_VALUE_TO_INTEGER(VM, NJS_ARG(ARGS, NARGS, 2), &DELETE);
        IF (NJS_SLOW_PATH(RET != NJS_OK)) {
            RETURN RET;
        }

        DELETE = NJS_MIN(NJS_MAX(DELETE, 0), LENGTH - START);
    }

    DELTA = ITEMS - DELETE;

    IF (NJS_SLOW_PATH((LENGTH + DELTA) > NJS_MAX_LENGTH)) {
        NJS_TYPE_ERROR(VM, "INVALID LENGTH");
        RETURN NJS_ERROR;
    }

    /* TODO: ARRAYSPECIESCREATE(). */

    DELETED = NJS_ARRAY_ALLOC(VM, 0, DELETE, 0);
    IF (NJS_SLOW_PATH(DELETED == NULL)) {
        RETURN NJS_ERROR;
    }

    IF (NJS_FAST_PATH(NJS_IS_FAST_ARRAY(THIS) && DELETED->OBJECT.FAST_ARRAY)) {
        ARRAY = NJS_ARRAY(THIS);
        FOR (I = 0, N = START; I < DELETE; I++, N++) {
            DELETED->START[I] = ARRAY->START[N];
        }

    } ELSE {
        NJS_SET_ARRAY(&DEL_OBJECT, DELETED);

        FOR (I = 0, N = START; I < DELETE; I++, N++) {
            RET = NJS_VALUE_PROPERTY_I64(VM, THIS, N, &VALUE);
            IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                RETURN NJS_ERROR;
            }

            IF (RET == NJS_OK) {
                /* TODO:  CREATEDATAPROPERTYORTHROW(). */
                RET = NJS_VALUE_PROPERTY_I64_SET(VM, &DEL_OBJECT, I, &VALUE);
                IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                    RETURN RET;
                }
            }
        }

        RET = NJS_OBJECT_LENGTH_SET(VM, &DEL_OBJECT, DELETE);
        IF (NJS_SLOW_PATH(RET != NJS_OK)) {
            RETURN NJS_ERROR;
        }
    }

    IF (NJS_FAST_PATH(NJS_IS_FAST_ARRAY(THIS))) {
        ARRAY = NJS_ARRAY(THIS);

        IF (DELTA != 0) {
            /*
             * RELOCATE THE REST OF ITEMS.
             * INDEX OF THE FIRST ITEM IS IN "N".
             */
            IF (DELTA > 0) {
                RET = NJS_ARRAY_EXPAND(VM, ARRAY, 0, DELTA);
                IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                    RETURN RET;
                }
            }

            RET = NJS_ARRAY_COPY_WITHIN(VM, THIS, START + ITEMS, START + DELETE,
                                        ARRAY->LENGTH - (START + DELETE), 0);
            IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                RETURN RET;
            }

            ARRAY->LENGTH += DELTA;
        }

        /* COPY NEW ITEMS. */

        IF (ITEMS > 0) {
            MEMCPY(&ARRAY->START[START], &ARGS[3],
                   ITEMS * SIZEOF(NJS_VALUE_T));
        }

    } ELSE {

       IF (DELTA != 0) {
           RET = NJS_ARRAY_COPY_WITHIN(VM, THIS, START + ITEMS, START + DELETE,
                                       LENGTH - (START + DELETE), DELTA < 0);
            IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                RETURN RET;
            }

            FOR (I = LENGTH - 1; I >= LENGTH + DELTA; I--) {
                RET = NJS_VALUE_PROPERTY_I64_DELETE(VM, THIS, I, NULL);
                IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                    RETURN NJS_ERROR;
                }
            }
       }

        /* COPY NEW ITEMS. */

        FOR (I = 3, N = START; ITEMS-- > 0; I++, N++) {
            RET = NJS_VALUE_PROPERTY_I64_SET(VM, THIS, N, &ARGS[I]);
            IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
                RETURN NJS_ERROR;
            }
        }

        RET = NJS_OBJECT_LENGTH_SET(VM, THIS, LENGTH + DELTA);
        IF (NJS_SLOW_PATH(RET != NJS_OK)) {
            RETURN NJS_ERROR;
        }
    }

    NJS_SET_ARRAY(&VM->RETVAL, DELETED);

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234169_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DISPLAY_BLOCK (UNSIGNED CHAR *DATA,
	       DWARF_VMA LENGTH,
	       CONST UNSIGNED CHAR * CONST END, CHAR DELIMITER)
{
  DWARF_VMA MAXLEN;

  PRINTF (_("%C%S BYTE BLOCK: "), DELIMITER, DWARF_VMATOA ("U", LENGTH));
  IF (DATA > END)
    RETURN (UNSIGNED CHAR *) END;

  MAXLEN = (DWARF_VMA) (END - DATA);
  LENGTH = LENGTH > MAXLEN ? MAXLEN : LENGTH;

  WHILE (LENGTH --)
    PRINTF ("%LX ", (UNSIGNED LONG) BYTE_GET (DATA++, 1));

  RETURN DATA;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 517428_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID DOGET(HTTPREQUEST REQ, HTTPRESPONSE RES) {
        SET_CONTENT_TYPE(RES, "TEXT/HTML");
        IF (ACTION(HOME)) {
                LOCK(RUN.MUTEX)
                DO_HOME(RES);
                END_LOCK;
        } ELSE IF (ACTION(RUNTIME)) {
                HANDLE_RUNTIME(REQ, RES);
        } ELSE IF (ACTION(TEST)) {
                IS_MONIT_RUNNING(RES);
        } ELSE IF (ACTION(ABOUT)) {
                DO_ABOUT(RES);
        } ELSE IF (ACTION(FAVICON)) {
                PRINTFAVICON(RES);
        } ELSE IF (ACTION(PING)) {
                DO_PING(RES);
        } ELSE IF (ACTION(GETID)) {
                DO_GETID(RES);
        } ELSE IF (ACTION(STATUS)) {
                PRINT_STATUS(REQ, RES, 1);
        } ELSE IF (ACTION(STATUS2)) {
                PRINT_STATUS(REQ, RES, 2);
        } ELSE IF (ACTION(SUMMARY)) {
                PRINT_SUMMARY(REQ, RES);
        } ELSE IF (ACTION(REPORT)) {
                _PRINTREPORT(REQ, RES);
        } ELSE {
                HANDLE_SERVICE(REQ, RES);
        }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359657_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
COMMUNITY_LIST_CONFIG_WRITE (STRUCT VTY *VTY)
{
  STRUCT COMMUNITY_LIST *LIST;
  STRUCT COMMUNITY_ENTRY *ENTRY;
  STRUCT COMMUNITY_LIST_MASTER *CM;
  INT WRITE = 0;

  /* COMMUNITY-LIST.  */
  CM = COMMUNITY_LIST_MASTER_LOOKUP (BGP_CLIST, COMMUNITY_LIST_MASTER);

  FOR (LIST = CM->NUM.HEAD; LIST; LIST = LIST->NEXT)
    FOR (ENTRY = LIST->HEAD; ENTRY; ENTRY = ENTRY->NEXT)
      {
	VTY_OUT (VTY, "IP COMMUNITY-LIST %S %S %S%S",
		 LIST->NAME, COMMUNITY_DIRECT_STR (ENTRY->DIRECT),
		 COMMUNITY_LIST_CONFIG_STR (ENTRY),
		 VTY_NEWLINE);
	WRITE++;
      }
  FOR (LIST = CM->STR.HEAD; LIST; LIST = LIST->NEXT)
    FOR (ENTRY = LIST->HEAD; ENTRY; ENTRY = ENTRY->NEXT)
      {
	VTY_OUT (VTY, "IP COMMUNITY-LIST %S %S %S %S%S",
		 ENTRY->STYLE == COMMUNITY_LIST_STANDARD
		 ? "STANDARD" : "EXPANDED",
		 LIST->NAME, COMMUNITY_DIRECT_STR (ENTRY->DIRECT),
		 COMMUNITY_LIST_CONFIG_STR (ENTRY),
		 VTY_NEWLINE);
	WRITE++;
      }

  /* EXTCOMMUNITY-LIST.  */
  CM = COMMUNITY_LIST_MASTER_LOOKUP (BGP_CLIST, EXTCOMMUNITY_LIST_MASTER);

  FOR (LIST = CM->NUM.HEAD; LIST; LIST = LIST->NEXT)
    FOR (ENTRY = LIST->HEAD; ENTRY; ENTRY = ENTRY->NEXT)
      {
	VTY_OUT (VTY, "IP EXTCOMMUNITY-LIST %S %S %S%S",
		 LIST->NAME, COMMUNITY_DIRECT_STR (ENTRY->DIRECT),
		 COMMUNITY_LIST_CONFIG_STR (ENTRY), VTY_NEWLINE);
	WRITE++;
      }
  FOR (LIST = CM->STR.HEAD; LIST; LIST = LIST->NEXT)
    FOR (ENTRY = LIST->HEAD; ENTRY; ENTRY = ENTRY->NEXT)
      {
	VTY_OUT (VTY, "IP EXTCOMMUNITY-LIST %S %S %S %S%S",
		 ENTRY->STYLE == EXTCOMMUNITY_LIST_STANDARD
		 ? "STANDARD" : "EXPANDED",
		 LIST->NAME, COMMUNITY_DIRECT_STR (ENTRY->DIRECT),
		 COMMUNITY_LIST_CONFIG_STR (ENTRY), VTY_NEWLINE);
	WRITE++;
      }
  RETURN WRITE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369163_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID IO_REQ_TASK_CANCEL(STRUCT IO_KIOCB *REQ, BOOL *LOCKED)
{
	STRUCT IO_RING_CTX *CTX = REQ->CTX;

	/* NOT NEEDED FOR NORMAL MODES, BUT SQPOLL DEPENDS ON IT */
	IO_TW_LOCK(CTX, LOCKED);
	IO_REQ_COMPLETE_FAILED(REQ, REQ->RESULT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204032_CWE-772.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID VIRTBT_RX_HANDLE(STRUCT VIRTIO_BLUETOOTH *VBT, STRUCT SK_BUFF *SKB)
{
	__U8 PKT_TYPE;

	PKT_TYPE = *((__U8 *) SKB->DATA);
	SKB_PULL(SKB, 1);

	SWITCH (PKT_TYPE) {
	CASE HCI_EVENT_PKT:
	CASE HCI_ACLDATA_PKT:
	CASE HCI_SCODATA_PKT:
	CASE HCI_ISODATA_PKT:
		HCI_SKB_PKT_TYPE(SKB) = PKT_TYPE;
		HCI_RECV_FRAME(VBT->HDEV, SKB);
		BREAK;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211522_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PARSE_CMD_ADDRESS(EXARG_T *EAP, CHAR **ERRORMSG, INT SILENT)
{
    INT		ADDRESS_COUNT = 1;
    LINENR_T	LNUM;

    // REPEAT FOR ALL ',' OR ';' SEPARATED ADDRESSES.
    FOR (;;)
    {
	EAP->LINE1 = EAP->LINE2;
	EAP->LINE2 = DEFAULT_ADDRESS(EAP);
	EAP->CMD = SKIPWHITE(EAP->CMD);
	LNUM = GET_ADDRESS(EAP, &EAP->CMD, EAP->ADDR_TYPE, EAP->SKIP, SILENT,
					EAP->ADDR_COUNT == 0, ADDRESS_COUNT++);
	IF (EAP->CMD == NULL)	// ERROR DETECTED
	    RETURN FAIL;
	IF (LNUM == MAXLNUM)
	{
	    IF (*EAP->CMD == '%')   // '%' - ALL LINES
	    {
		++EAP->CMD;
		SWITCH (EAP->ADDR_TYPE)
		{
		    CASE ADDR_LINES:
		    CASE ADDR_OTHER:
			EAP->LINE1 = 1;
			EAP->LINE2 = CURBUF->B_ML.ML_LINE_COUNT;
			BREAK;
		    CASE ADDR_LOADED_BUFFERS:
			{
			    BUF_T	*BUF = FIRSTBUF;

			    WHILE (BUF->B_NEXT != NULL
						  && BUF->B_ML.ML_MFP == NULL)
				BUF = BUF->B_NEXT;
			    EAP->LINE1 = BUF->B_FNUM;
			    BUF = LASTBUF;
			    WHILE (BUF->B_PREV != NULL
						  && BUF->B_ML.ML_MFP == NULL)
				BUF = BUF->B_PREV;
			    EAP->LINE2 = BUF->B_FNUM;
			    BREAK;
			}
		    CASE ADDR_BUFFERS:
			EAP->LINE1 = FIRSTBUF->B_FNUM;
			EAP->LINE2 = LASTBUF->B_FNUM;
			BREAK;
		    CASE ADDR_WINDOWS:
		    CASE ADDR_TABS:
			IF (IS_USER_CMDIDX(EAP->CMDIDX))
			{
			    EAP->LINE1 = 1;
			    EAP->LINE2 = EAP->ADDR_TYPE == ADDR_WINDOWS
						  ? LAST_WIN_NR : LAST_TAB_NR;
			}
			ELSE
			{
			    // THERE IS NO VIM COMMAND WHICH USES '%' AND
			    // ADDR_WINDOWS OR ADDR_TABS
			    *ERRORMSG = _(E_INVALID_RANGE);
			    RETURN FAIL;
			}
			BREAK;
		    CASE ADDR_TABS_RELATIVE:
		    CASE ADDR_UNSIGNED:
		    CASE ADDR_QUICKFIX:
			*ERRORMSG = _(E_INVALID_RANGE);
			RETURN FAIL;
		    CASE ADDR_ARGUMENTS:
			IF (ARGCOUNT == 0)
			    EAP->LINE1 = EAP->LINE2 = 0;
			ELSE
			{
			    EAP->LINE1 = 1;
			    EAP->LINE2 = ARGCOUNT;
			}
			BREAK;
		    CASE ADDR_QUICKFIX_VALID:
#IFDEF FEAT_QUICKFIX
			EAP->LINE1 = 1;
			EAP->LINE2 = QF_GET_VALID_SIZE(EAP);
			IF (EAP->LINE2 == 0)
			    EAP->LINE2 = 1;
#ENDIF
			BREAK;
		    CASE ADDR_NONE:
			// WILL GIVE AN ERROR LATER IF A RANGE IS FOUND.
			BREAK;
		}
		++EAP->ADDR_COUNT;
	    }
	    ELSE IF (*EAP->CMD == '*' && VIM_STRCHR(P_CPO, CPO_STAR) == NULL)
	    {
		POS_T	    *FP;

		// '*' - VISUAL AREA
		IF (EAP->ADDR_TYPE != ADDR_LINES)
		{
		    *ERRORMSG = _(E_INVALID_RANGE);
		    RETURN FAIL;
		}

		++EAP->CMD;
		IF (!EAP->SKIP)
		{
		    FP = GETMARK('<', FALSE);
		    IF (CHECK_MARK(FP) == FAIL)
			RETURN FAIL;
		    EAP->LINE1 = FP->LNUM;
		    FP = GETMARK('>', FALSE);
		    IF (CHECK_MARK(FP) == FAIL)
			RETURN FAIL;
		    EAP->LINE2 = FP->LNUM;
		    ++EAP->ADDR_COUNT;
		}
	    }
	}
	ELSE
	    EAP->LINE2 = LNUM;
	EAP->ADDR_COUNT++;

	IF (*EAP->CMD == ';')
	{
	    IF (!EAP->SKIP)
	    {
		CURWIN->W_CURSOR.LNUM = EAP->LINE2;
		// DON'T LEAVE THE CURSOR ON AN ILLEGAL LINE OR COLUMN, BUT DO
		// ACCEPT ZERO AS ADDRESS, SO 0;/PATTERN/ WORKS CORRECTLY.
		IF (EAP->LINE2 > 0)
		    CHECK_CURSOR();
	    }
	}
	ELSE IF (*EAP->CMD != ',')
	    BREAK;
	++EAP->CMD;
    }

    // ONE ADDRESS GIVEN: SET START AND END LINES.
    IF (EAP->ADDR_COUNT == 1)
    {
	EAP->LINE1 = EAP->LINE2;
	// ... BUT ONLY IMPLICIT: REALLY NO ADDRESS GIVEN
	IF (LNUM == MAXLNUM)
	    EAP->ADDR_COUNT = 0;
    }
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 491925_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC LONG FUSE_FILE_IOCTL(STRUCT FILE *FILE, UNSIGNED INT CMD,
			    UNSIGNED LONG ARG)
{
	RETURN FUSE_FILE_IOCTL_COMMON(FILE, CMD, ARG, 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204535_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STL_UPDATE_CONNECTS_REMOVE_1(STL_FILE *STL, INT FACET_NUM) {
  INT J;

  IF (STL->ERROR) RETURN;
  /* UPDATE LIST OF CONNECTED EDGES */
  J = ((STL->NEIGHBORS_START[FACET_NUM].NEIGHBOR[0] == -1) +
       (STL->NEIGHBORS_START[FACET_NUM].NEIGHBOR[1] == -1) +
       (STL->NEIGHBORS_START[FACET_NUM].NEIGHBOR[2] == -1));
  IF(J == 0) {		       /* FACET HAS 3 NEIGHBORS */
    STL->STATS.CONNECTED_FACETS_3_EDGE -= 1;
  } ELSE IF(J == 1) {	     /* FACET HAS 2 NEIGHBORS */
    STL->STATS.CONNECTED_FACETS_2_EDGE -= 1;
  } ELSE IF(J == 2) {	     /* FACET HAS 1 NEIGHBOR  */
    STL->STATS.CONNECTED_FACETS_1_EDGE -= 1;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206845_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC UNSIGNED LONG GET_CTL_ID_HASH(CONST STRUCT SND_CTL_ELEM_ID *ID)
{
	INT I;
	UNSIGNED LONG H;

	H = ID->IFACE;
	H = MULTIPLIER * H + ID->DEVICE;
	H = MULTIPLIER * H + ID->SUBDEVICE;
	FOR (I = 0; ID->NAME[I] && I < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; I++)
		H = MULTIPLIER * H + ID->NAME[I];
	H = MULTIPLIER * H + ID->INDEX;
	H &= LONG_MAX;
	RETURN H;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 413638_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC UT64 RANALREF_VAL(CONST VOID *_REF1) {
	CONST RANALREF* REF1 = _REF1;
	RETURN REF1->ADDR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204534_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STL_REMOVE_DEGENERATE(STL_FILE *STL, INT FACET) {
  INT EDGE1;
  INT EDGE2;
  INT EDGE3;
  INT NEIGHBOR1;
  INT NEIGHBOR2;
  INT NEIGHBOR3;
  INT VNOT1;
  INT VNOT2;
  INT VNOT3;

  IF (STL->ERROR) RETURN;

  IF(   !MEMCMP(&STL->FACET_START[FACET].VERTEX[0],
                &STL->FACET_START[FACET].VERTEX[1], SIZEOF(STL_VERTEX))
        && !MEMCMP(&STL->FACET_START[FACET].VERTEX[1],
                   &STL->FACET_START[FACET].VERTEX[2], SIZEOF(STL_VERTEX))) {
    /* ALL 3 VERTICES ARE EQUAL.  JUST REMOVE THE FACET.  I DON'T THINK*/
    /* THIS IS REALLY POSSIBLE, BUT JUST IN CASE... */
    PRINTF("REMOVING A FACET IN STL_REMOVE_DEGENERATE\N");

    STL_REMOVE_FACET(STL, FACET);
    RETURN;
  }

  IF(!MEMCMP(&STL->FACET_START[FACET].VERTEX[0],
             &STL->FACET_START[FACET].VERTEX[1], SIZEOF(STL_VERTEX))) {
    EDGE1 = 1;
    EDGE2 = 2;
    EDGE3 = 0;
  } ELSE IF(!MEMCMP(&STL->FACET_START[FACET].VERTEX[1],
                    &STL->FACET_START[FACET].VERTEX[2], SIZEOF(STL_VERTEX))) {
    EDGE1 = 0;
    EDGE2 = 2;
    EDGE3 = 1;
  } ELSE IF(!MEMCMP(&STL->FACET_START[FACET].VERTEX[2],
                    &STL->FACET_START[FACET].VERTEX[0], SIZEOF(STL_VERTEX))) {
    EDGE1 = 0;
    EDGE2 = 1;
    EDGE3 = 2;
  } ELSE {
    /* NO DEGENERATE. FUNCTION SHOULDN'T HAVE BEEN CALLED. */
    RETURN;
  }
  NEIGHBOR1 = STL->NEIGHBORS_START[FACET].NEIGHBOR[EDGE1];
  NEIGHBOR2 = STL->NEIGHBORS_START[FACET].NEIGHBOR[EDGE2];

  IF(NEIGHBOR1 == -1) {
    STL_UPDATE_CONNECTS_REMOVE_1(STL, NEIGHBOR2);
  }
  IF(NEIGHBOR2 == -1) {
    STL_UPDATE_CONNECTS_REMOVE_1(STL, NEIGHBOR1);
  }


  NEIGHBOR3 = STL->NEIGHBORS_START[FACET].NEIGHBOR[EDGE3];
  VNOT1 = STL->NEIGHBORS_START[FACET].WHICH_VERTEX_NOT[EDGE1];
  VNOT2 = STL->NEIGHBORS_START[FACET].WHICH_VERTEX_NOT[EDGE2];
  VNOT3 = STL->NEIGHBORS_START[FACET].WHICH_VERTEX_NOT[EDGE3];

  IF(NEIGHBOR1 != -1){
    STL->NEIGHBORS_START[NEIGHBOR1].NEIGHBOR[(VNOT1 + 1) % 3] = NEIGHBOR2;
    STL->NEIGHBORS_START[NEIGHBOR1].WHICH_VERTEX_NOT[(VNOT1 + 1) % 3] = VNOT2;
  }
  IF(NEIGHBOR2 != -1){
    STL->NEIGHBORS_START[NEIGHBOR2].NEIGHBOR[(VNOT2 + 1) % 3] = NEIGHBOR1;
    STL->NEIGHBORS_START[NEIGHBOR2].WHICH_VERTEX_NOT[(VNOT2 + 1) % 3] = VNOT1;
  }

  STL_REMOVE_FACET(STL, FACET);

  IF(NEIGHBOR3 != -1) {
    STL_UPDATE_CONNECTS_REMOVE_1(STL, NEIGHBOR3);
    STL->NEIGHBORS_START[NEIGHBOR3].NEIGHBOR[(VNOT3 + 1) % 3] = -1;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214336_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PFKEY_REGISTER(STRUCT SOCK *SK, STRUCT SK_BUFF *SKB, CONST STRUCT SADB_MSG *HDR, VOID * CONST *EXT_HDRS)
{
	STRUCT PFKEY_SOCK *PFK = PFKEY_SK(SK);
	STRUCT SK_BUFF *SUPP_SKB;

	IF (HDR->SADB_MSG_SATYPE > SADB_SATYPE_MAX)
		RETURN -EINVAL;

	IF (HDR->SADB_MSG_SATYPE != SADB_SATYPE_UNSPEC) {
		IF (PFK->REGISTERED&(1<<HDR->SADB_MSG_SATYPE))
			RETURN -EEXIST;
		PFK->REGISTERED |= (1<<HDR->SADB_MSG_SATYPE);
	}

	XFRM_PROBE_ALGS();

	SUPP_SKB = COMPOSE_SADB_SUPPORTED(HDR, GFP_KERNEL | __GFP_ZERO);
	IF (!SUPP_SKB) {
		IF (HDR->SADB_MSG_SATYPE != SADB_SATYPE_UNSPEC)
			PFK->REGISTERED &= ~(1<<HDR->SADB_MSG_SATYPE);

		RETURN -ENOBUFS;
	}

	PFKEY_BROADCAST(SUPP_SKB, GFP_KERNEL, BROADCAST_REGISTERED, SK,
			SOCK_NET(SK));
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206665_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID PARSE_RELOCATION_INFO(STRUCT MACH0_(OBJ_T) *BIN, RSKIPLIST *RELOCS, UT32 OFFSET, UT32 NUM) {
	IF (!NUM || !OFFSET || (ST32)NUM < 0) {
		RETURN;
	}

	UT64 TOTAL_SIZE = NUM * SIZEOF (STRUCT RELOCATION_INFO);
	IF (OFFSET > BIN->SIZE) {
		RETURN;
	}
	IF (TOTAL_SIZE > BIN->SIZE) {
		TOTAL_SIZE = BIN->SIZE - OFFSET;
		NUM = TOTAL_SIZE /= SIZEOF (STRUCT RELOCATION_INFO);
	}
	STRUCT RELOCATION_INFO *INFO = CALLOC (NUM, SIZEOF (STRUCT RELOCATION_INFO));
	IF (!INFO) {
		RETURN;
	}

	IF (R_BUF_READ_AT (BIN->B, OFFSET, (UT8 *) INFO, TOTAL_SIZE) < TOTAL_SIZE) {
		FREE (INFO);
		RETURN;
	}

	SIZE_T I;
	FOR (I = 0; I < NUM; I++) {
		STRUCT RELOCATION_INFO A_INFO = INFO[I];
		UT32 SYM_NUM = A_INFO.R_SYMBOLNUM;
		IF (SYM_NUM > BIN->NSYMTAB) {
			CONTINUE;
		}

		UT32 STRIDX = BIN->SYMTAB[SYM_NUM].N_STRX;
		CHAR *SYM_NAME = GET_NAME (BIN, STRIDX, FALSE);
		IF (!SYM_NAME) {
			CONTINUE;
		}

		STRUCT RELOC_T *RELOC = R_NEW0 (STRUCT RELOC_T);
		IF (!RELOC) {
			FREE (INFO);
			FREE (SYM_NAME);
			RETURN;
		}

		RELOC->ADDR = OFFSET_TO_VADDR (BIN, A_INFO.R_ADDRESS);
		RELOC->OFFSET = A_INFO.R_ADDRESS;
		RELOC->ORD = SYM_NUM;
		RELOC->TYPE = A_INFO.R_TYPE; // ENUM RELOCATIONINFOTYPE
		RELOC->EXTERNAL = A_INFO.R_EXTERN;
		RELOC->PC_RELATIVE = A_INFO.R_PCREL;
		RELOC->SIZE = A_INFO.R_LENGTH;
		R_STR_NCPY (RELOC->NAME, SYM_NAME, SIZEOF (RELOC->NAME) - 1);
		R_SKIPLIST_INSERT (RELOCS, RELOC);
		FREE (SYM_NAME);
	}
	FREE (INFO);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 230389_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PJ_DEF(VOID) PJ_XML_ADD_NODE( PJ_XML_NODE *PARENT, PJ_XML_NODE *NODE )
{
    PJ_LIST_PUSH_BACK(&PARENT->NODE_HEAD, NODE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198556_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FIBER_SWITCH(MRB_STATE *MRB, MRB_VALUE SELF, MRB_INT LEN, CONST MRB_VALUE *A, MRB_BOOL RESUME, MRB_BOOL VMEXEC)
{
  STRUCT MRB_CONTEXT *C = FIBER_CHECK(MRB, SELF);
  STRUCT MRB_CONTEXT *OLD_C = MRB->C;
  ENUM MRB_FIBER_STATE STATUS;
  MRB_VALUE VALUE;

  FIBER_CHECK_CFUNC(MRB, C);
  STATUS = C->STATUS;
  SWITCH (STATUS) {
  CASE MRB_FIBER_TRANSFERRED:
    IF (RESUME) {
      MRB_RAISE(MRB, E_FIBER_ERROR, "RESUMING TRANSFERRED FIBER");
    }
    BREAK;
  CASE MRB_FIBER_RUNNING:
  CASE MRB_FIBER_RESUMED:
    MRB_RAISE(MRB, E_FIBER_ERROR, "DOUBLE RESUME");
    BREAK;
  CASE MRB_FIBER_TERMINATED:
    MRB_RAISE(MRB, E_FIBER_ERROR, "RESUMING DEAD FIBER");
    BREAK;
  DEFAULT:
    BREAK;
  }
  OLD_C->STATUS = RESUME ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
  C->PREV = RESUME ? MRB->C : (C->PREV ? C->PREV : MRB->ROOT_C);
  FIBER_SWITCH_CONTEXT(MRB, C);
  IF (STATUS == MRB_FIBER_CREATED) {
    MRB_VALUE *B, *E;

    IF (!C->CI->PROC) {
      MRB_RAISE(MRB, E_FIBER_ERROR, "DOUBLE RESUME (CURRENT)");
    }
    MRB_STACK_EXTEND(MRB, LEN+2); /* FOR RECEIVER AND (OPTIONAL) BLOCK */
    B = C->STBASE+1;
    E = B + LEN;
    WHILE (B<E) {
      *B++ = *A++;
    }
    IF (VMEXEC) {
      C->CI--;                    /* POP DUMMY CALLINFO */
    }
    C->CIBASE->N = LEN;
    VALUE = C->STBASE[0] = MRB_PROC_ENV(C->CIBASE->PROC)->STACK[0];
  }
  ELSE {
    VALUE = FIBER_RESULT(MRB, A, LEN);
    IF (VMEXEC) {
      C->CI[1].STACK[0] = VALUE;
    }
  }

  IF (VMEXEC) {
    C->VMEXEC = TRUE;
    VALUE = MRB_VM_EXEC(MRB, C->CI->PROC, C->CI->PC);
    MRB->C = OLD_C;
  }
  ELSE {
    MARK_CONTEXT_MODIFY(C);
  }
  RETURN VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 364750_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FINDTAGS_PARSE_LINE(
    FINDTAGS_STATE_T		*ST,
    TAGPTRS_T			*TAGPP,
    FINDTAGS_MATCH_ARGS_T	*MARGS,
    TAGSEARCH_INFO_T		*SINFO_P)
{
    INT		STATUS;
    INT		I;
    INT		CMPLEN;
    INT		TAGCMP;

    // FIGURE OUT WHERE THE DIFFERENT STRINGS ARE IN THIS LINE.
    // FOR "NORMAL" TAGS: DO A QUICK CHECK IF THE TAG MATCHES.
    // THIS SPEEDS UP TAG SEARCHING A LOT!
    IF (ST->ORGPAT->HEADLEN
#IFDEF FEAT_EMACS_TAGS
	    && !ST->IS_ETAG
#ENDIF
       )
    {
	CLEAR_FIELD(*TAGPP);
	TAGPP->TAGNAME = ST->LBUF;
	TAGPP->TAGNAME_END = VIM_STRCHR(ST->LBUF, TAB);
	IF (TAGPP->TAGNAME_END == NULL)
	    // CORRUPTED TAG LINE.
	    RETURN TAG_MATCH_FAIL;

	// SKIP THIS LINE IF THE LENGTH OF THE TAG IS DIFFERENT AND
	// THERE IS NO REGEXP, OR THE TAG IS TOO SHORT.
	CMPLEN = (INT)(TAGPP->TAGNAME_END - TAGPP->TAGNAME);
	IF (P_TL != 0 && CMPLEN > P_TL)	    // ADJUST FOR 'TAGLENGTH'
	    CMPLEN = P_TL;
	IF ((ST->FLAGS & TAG_REGEXP) && ST->ORGPAT->HEADLEN < CMPLEN)
	    CMPLEN = ST->ORGPAT->HEADLEN;
	ELSE IF (ST->STATE == TS_LINEAR && ST->ORGPAT->HEADLEN != CMPLEN)
	    RETURN TAG_MATCH_NEXT;

	IF (ST->STATE == TS_BINARY)
	{
	    // SIMPLISTIC CHECK FOR UNSORTED TAGS FILE.
	    I = (INT)TAGPP->TAGNAME[0];
	    IF (MARGS->SORTIC)
		I = (INT)TOUPPER_ASC(TAGPP->TAGNAME[0]);
	    IF (I < SINFO_P->LOW_CHAR || I > SINFO_P->HIGH_CHAR)
		MARGS->SORT_ERROR = TRUE;

	    // COMPARE THE CURRENT TAG WITH THE SEARCHED TAG.
	    IF (MARGS->SORTIC)
		TAGCMP = TAG_STRNICMP(TAGPP->TAGNAME, ST->ORGPAT->HEAD,
							(SIZE_T)CMPLEN);
	    ELSE
		TAGCMP = STRNCMP(TAGPP->TAGNAME, ST->ORGPAT->HEAD, CMPLEN);

	    // A MATCH WITH A SHORTER TAG MEANS TO SEARCH FORWARD.
	    // A MATCH WITH A LONGER TAG MEANS TO SEARCH BACKWARD.
	    IF (TAGCMP == 0)
	    {
		IF (CMPLEN < ST->ORGPAT->HEADLEN)
		    TAGCMP = -1;
		ELSE IF (CMPLEN > ST->ORGPAT->HEADLEN)
		    TAGCMP = 1;
	    }

	    IF (TAGCMP == 0)
	    {
		// WE'VE LOCATED THE TAG, NOW SKIP BACK AND SEARCH
		// FORWARD UNTIL THE FIRST MATCHING TAG IS FOUND.
		ST->STATE = TS_SKIP_BACK;
		SINFO_P->MATCH_OFFSET = SINFO_P->CURR_OFFSET;
		RETURN TAG_MATCH_NEXT;
	    }
	    IF (TAGCMP < 0)
	    {
		SINFO_P->CURR_OFFSET = VIM_FTELL(ST->FP);
		IF (SINFO_P->CURR_OFFSET < SINFO_P->HIGH_OFFSET)
		{
		    SINFO_P->LOW_OFFSET = SINFO_P->CURR_OFFSET;
		    IF (MARGS->SORTIC)
			SINFO_P->LOW_CHAR = TOUPPER_ASC(TAGPP->TAGNAME[0]);
		    ELSE
			SINFO_P->LOW_CHAR = TAGPP->TAGNAME[0];
		    RETURN TAG_MATCH_NEXT;
		}
	    }
	    IF (TAGCMP > 0 && SINFO_P->CURR_OFFSET != SINFO_P->HIGH_OFFSET)
	    {
		SINFO_P->HIGH_OFFSET = SINFO_P->CURR_OFFSET;
		IF (MARGS->SORTIC)
		    SINFO_P->HIGH_CHAR = TOUPPER_ASC(TAGPP->TAGNAME[0]);
		ELSE
		    SINFO_P->HIGH_CHAR = TAGPP->TAGNAME[0];
		RETURN TAG_MATCH_NEXT;
	    }

	    // NO MATCH YET AND ARE AT THE END OF THE BINARY SEARCH.
	    RETURN TAG_MATCH_STOP;
	}
	ELSE IF (ST->STATE == TS_SKIP_BACK)
	{
	    IF (MB_STRNICMP(TAGPP->TAGNAME, ST->ORGPAT->HEAD, CMPLEN) != 0)
		ST->STATE = TS_STEP_FORWARD;
	    ELSE
		// HAVE TO SKIP BACK MORE.  RESTORE THE CURR_OFFSET
		// USED, OTHERWISE WE GET STUCK AT A LONG LINE.
		SINFO_P->CURR_OFFSET = SINFO_P->CURR_OFFSET_USED;
	    RETURN TAG_MATCH_NEXT;
	}
	ELSE IF (ST->STATE == TS_STEP_FORWARD)
	{
	    IF (MB_STRNICMP(TAGPP->TAGNAME, ST->ORGPAT->HEAD, CMPLEN) != 0)
	    {
		IF ((OFF_T)VIM_FTELL(ST->FP) > SINFO_P->MATCH_OFFSET)
		    RETURN TAG_MATCH_STOP;	// PAST LAST MATCH
		ELSE
		    RETURN TAG_MATCH_NEXT;	// BEFORE FIRST MATCH
	    }
	}
	ELSE
	    // SKIP THIS MATCH IF IT CAN'T MATCH
	    IF (MB_STRNICMP(TAGPP->TAGNAME, ST->ORGPAT->HEAD, CMPLEN) != 0)
		RETURN TAG_MATCH_NEXT;

	// CAN BE A MATCHING TAG, ISOLATE THE FILE NAME AND COMMAND.
	TAGPP->FNAME = TAGPP->TAGNAME_END + 1;
	TAGPP->FNAME_END = VIM_STRCHR(TAGPP->FNAME, TAB);
	IF (TAGPP->FNAME_END == NULL)
	    STATUS = FAIL;
	ELSE
	{
	    TAGPP->COMMAND = TAGPP->FNAME_END + 1;
	    STATUS = OK;
	}
    }
    ELSE
	STATUS = PARSE_TAG_LINE(ST->LBUF,
#IFDEF FEAT_EMACS_TAGS
		ST->IS_ETAG,
#ENDIF
		TAGPP);

    IF (STATUS == FAIL)
	RETURN TAG_MATCH_FAIL;

#IFDEF FEAT_EMACS_TAGS
    IF (ST->IS_ETAG)
	TAGPP->FNAME = ST->EBUF;
#ENDIF

    RETURN TAG_MATCH_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 238642_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SCALAR_MIN_MAX_ADD(STRUCT BPF_REG_STATE *DST_REG,
			       STRUCT BPF_REG_STATE *SRC_REG)
{
	S64 SMIN_VAL = SRC_REG->SMIN_VALUE;
	S64 SMAX_VAL = SRC_REG->SMAX_VALUE;
	U64 UMIN_VAL = SRC_REG->UMIN_VALUE;
	U64 UMAX_VAL = SRC_REG->UMAX_VALUE;

	IF (SIGNED_ADD_OVERFLOWS(DST_REG->SMIN_VALUE, SMIN_VAL) ||
	    SIGNED_ADD_OVERFLOWS(DST_REG->SMAX_VALUE, SMAX_VAL)) {
		DST_REG->SMIN_VALUE = S64_MIN;
		DST_REG->SMAX_VALUE = S64_MAX;
	} ELSE {
		DST_REG->SMIN_VALUE += SMIN_VAL;
		DST_REG->SMAX_VALUE += SMAX_VAL;
	}
	IF (DST_REG->UMIN_VALUE + UMIN_VAL < UMIN_VAL ||
	    DST_REG->UMAX_VALUE + UMAX_VAL < UMAX_VAL) {
		DST_REG->UMIN_VALUE = 0;
		DST_REG->UMAX_VALUE = U64_MAX;
	} ELSE {
		DST_REG->UMIN_VALUE += UMIN_VAL;
		DST_REG->UMAX_VALUE += UMAX_VAL;
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195264_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID COMPILE_XCLASS_MATCHINGPATH(COMPILER_COMMON *COMMON, PCRE2_SPTR CC, JUMP_LIST **BACKTRACKS)
{
DEFINE_COMPILER;
JUMP_LIST *FOUND = NULL;
JUMP_LIST **LIST = (CC[0] & XCL_NOT) == 0 ? &FOUND : BACKTRACKS;
SLJIT_UW C, CHAROFFSET, MAX = 256, MIN = READ_CHAR_MAX;
STRUCT SLJIT_JUMP *JUMP = NULL;
PCRE2_SPTR CCBEGIN;
INT COMPARES, INVERTCMP, NUMBEROFCMPS;
#IF DEFINED SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)
BOOL UTF = COMMON->UTF;
#ENDIF /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */

#IFDEF SUPPORT_UNICODE
SLJIT_U32 UNICODE_STATUS = 0;
INT TYPEREG = TMP1;
CONST SLJIT_U32 *OTHER_CASES;
SLJIT_UW TYPEOFFSET;
#ENDIF /* SUPPORT_UNICODE */

/* SCANNING THE NECESSARY INFO. */
CC++;
CCBEGIN = CC;
COMPARES = 0;

IF (CC[-1] & XCL_MAP)
  {
  MIN = 0;
  CC += 32 / SIZEOF(PCRE2_UCHAR);
  }

WHILE (*CC != XCL_END)
  {
  COMPARES++;
  IF (*CC == XCL_SINGLE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);
    IF (C > MAX) MAX = C;
    IF (C < MIN) MIN = C;
#IFDEF SUPPORT_UNICODE
    UNICODE_STATUS |= XCLASS_SAVE_CHAR;
#ENDIF /* SUPPORT_UNICODE */
    }
  ELSE IF (*CC == XCL_RANGE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);
    IF (C < MIN) MIN = C;
    GETCHARINCTEST(C, CC);
    IF (C > MAX) MAX = C;
#IFDEF SUPPORT_UNICODE
    UNICODE_STATUS |= XCLASS_SAVE_CHAR;
#ENDIF /* SUPPORT_UNICODE */
    }
#IFDEF SUPPORT_UNICODE
  ELSE
    {
    SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
    CC++;
    IF (*CC == PT_CLIST && *CC == XCL_PROP)
      {
      OTHER_CASES = PRIV(UCD_CASELESS_SETS) + CC[1];
      WHILE (*OTHER_CASES != NOTACHAR)
        {
        IF (*OTHER_CASES > MAX) MAX = *OTHER_CASES;
        IF (*OTHER_CASES < MIN) MIN = *OTHER_CASES;
        OTHER_CASES++;
        }
      }
    ELSE
      {
      MAX = READ_CHAR_MAX;
      MIN = 0;
      }

    SWITCH(*CC)
      {
      CASE PT_ANY:
      /* ANY EITHER ACCEPTS EVERYTHING OR IGNORED. */
      IF (CC[-1] == XCL_PROP)
        {
        COMPILE_CHAR1_MATCHINGPATH(COMMON, OP_ALLANY, CC, BACKTRACKS, FALSE);
        IF (LIST == BACKTRACKS)
          ADD_JUMP(COMPILER, BACKTRACKS, JUMP(SLJIT_JUMP));
        RETURN;
        }
      BREAK;

      CASE PT_LAMP:
      CASE PT_GC:
      CASE PT_PC:
      CASE PT_ALNUM:
      UNICODE_STATUS |= XCLASS_HAS_TYPE;
      BREAK;

      CASE PT_SCX:
      UNICODE_STATUS |= XCLASS_HAS_SCRIPT_EXTENSION;
      IF (CC[-1] == XCL_NOTPROP)
        {
        UNICODE_STATUS |= XCLASS_SCRIPT_EXTENSION_NOTPROP;
        BREAK;
        }
      COMPARES++;
      /* FALL THROUGH */ 

      CASE PT_SC:
      UNICODE_STATUS |= XCLASS_HAS_SCRIPT;
      BREAK;

      CASE PT_SPACE:
      CASE PT_PXSPACE:
      CASE PT_WORD:
      CASE PT_PXGRAPH:
      CASE PT_PXPRINT:
      CASE PT_PXPUNCT:
      UNICODE_STATUS |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;
      BREAK;

      CASE PT_CLIST:
      CASE PT_UCNC:
      UNICODE_STATUS |= XCLASS_SAVE_CHAR;
      BREAK;

      CASE PT_BOOL:
      UNICODE_STATUS |= XCLASS_HAS_BOOL;
      BREAK;

      CASE PT_BIDICL:
      UNICODE_STATUS |= XCLASS_HAS_BIDICL;
      BREAK;

      DEFAULT:
      SLJIT_UNREACHABLE();
      BREAK;
      }
    CC += 2;
    }
#ENDIF /* SUPPORT_UNICODE */
  }
SLJIT_ASSERT(COMPARES > 0);

/* WE ARE NOT NECESSARY IN UTF MODE EVEN IN 8 BIT MODE. */
CC = CCBEGIN;
IF ((CC[-1] & XCL_NOT) != 0)
  READ_CHAR(COMMON, MIN, MAX, BACKTRACKS, READ_CHAR_UPDATE_STR_PTR);
ELSE
  {
#IFDEF SUPPORT_UNICODE
  READ_CHAR(COMMON, MIN, MAX, (UNICODE_STATUS & XCLASS_NEEDS_UCD) ? BACKTRACKS : NULL, 0);
#ELSE /* !SUPPORT_UNICODE */
  READ_CHAR(COMMON, MIN, MAX, NULL, 0);
#ENDIF /* SUPPORT_UNICODE */
  }

IF ((CC[-1] & XCL_HASPROP) == 0)
  {
  IF ((CC[-1] & XCL_MAP) != 0)
    {
    JUMP = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);
    IF (!OPTIMIZE_CLASS(COMMON, (CONST SLJIT_U8 *)CC, (((CONST SLJIT_U8 *)CC)[31] & 0X80) != 0, TRUE, &FOUND))
      {
      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0X7);
      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);
      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (SLJIT_SW)CC);
      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);
      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);
      ADD_JUMP(COMPILER, &FOUND, JUMP(SLJIT_NOT_ZERO));
      }

    ADD_JUMP(COMPILER, BACKTRACKS, JUMP(SLJIT_JUMP));
    JUMPHERE(JUMP);

    CC += 32 / SIZEOF(PCRE2_UCHAR);
    }
  ELSE
    {
    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, MIN);
    ADD_JUMP(COMPILER, (CC[-1] & XCL_NOT) == 0 ? BACKTRACKS : &FOUND, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, MAX - MIN));
    }
  }
ELSE IF ((CC[-1] & XCL_MAP) != 0)
  {
  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);
#IFDEF SUPPORT_UNICODE
  UNICODE_STATUS |= XCLASS_CHAR_SAVED;
#ENDIF /* SUPPORT_UNICODE */
  IF (!OPTIMIZE_CLASS(COMMON, (CONST SLJIT_U8 *)CC, FALSE, TRUE, LIST))
    {
#IF PCRE2_CODE_UNIT_WIDTH == 8
    JUMP = NULL;
    IF (COMMON->UTF)
#ENDIF /* PCRE2_CODE_UNIT_WIDTH == 8 */
      JUMP = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);

    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0X7);
    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);
    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (SLJIT_SW)CC);
    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);
    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);
    ADD_JUMP(COMPILER, LIST, JUMP(SLJIT_NOT_ZERO));

#IF PCRE2_CODE_UNIT_WIDTH == 8
    IF (COMMON->UTF)
#ENDIF /* PCRE2_CODE_UNIT_WIDTH == 8 */
      JUMPHERE(JUMP);
    }

  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
  CC += 32 / SIZEOF(PCRE2_UCHAR);
  }

#IFDEF SUPPORT_UNICODE
IF (UNICODE_STATUS & XCLASS_NEEDS_UCD)
  {
  IF ((UNICODE_STATUS & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)
    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);

#IF PCRE2_CODE_UNIT_WIDTH == 32
  IF (!COMMON->UTF)
    {
    JUMP = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);
    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);
    JUMPHERE(JUMP);
    }
#ENDIF /* PCRE2_CODE_UNIT_WIDTH == 32 */

  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);
  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);
  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_STAGE1));
  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);
  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);
  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);
  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (SLJIT_SW)PRIV(UCD_STAGE2));
  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);
  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);
  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);
  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);

  CCBEGIN = CC;

  IF (UNICODE_STATUS & XCLASS_HAS_BIDICL)
    {
    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPTX_BIDICLASS));
    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        IF (*CC == PT_BIDICL)
          {
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
          IF (CC[-1] == XCL_NOTPROP)
            INVERTCMP ^= 0X1;
          JUMP = CMP(SLJIT_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (INT)CC[1]);
          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP);
          }
        CC += 2;
        }
      }

    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_HAS_BOOL)
    {
    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, BPROPS));
    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);
    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        IF (*CC == PT_BOOL)
          {
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
          IF (CC[-1] == XCL_NOTPROP)
            INVERTCMP ^= 0X1;

          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (SLJIT_SW)(PRIV(UCD_BOOLPROP_SETS) + (CC[1] >> 5)), SLJIT_IMM, (SLJIT_SW)1 << (CC[1] & 0X1F));
          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP(SLJIT_NOT_ZERO ^ INVERTCMP));
          }
        CC += 2;
        }
      }

    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_HAS_SCRIPT)
    {
    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPT));

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        SWITCH (*CC)
          {
          CASE PT_SCX:
          IF (CC[-1] == XCL_NOTPROP)
            BREAK;
          /* FALL THROUGH */ 

          CASE PT_SC:
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
          IF (CC[-1] == XCL_NOTPROP)
            INVERTCMP ^= 0X1;

          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, CMP(SLJIT_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (INT)CC[1]));
          }
        CC += 2;
        }
      }

    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_HAS_SCRIPT_EXTENSION)
    {
    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPTX_BIDICLASS));
    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);
    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);

    IF (UNICODE_STATUS & XCLASS_SCRIPT_EXTENSION_NOTPROP)
      {
      IF (UNICODE_STATUS & XCLASS_HAS_TYPE)
        {
        IF (UNICODE_STATUS & XCLASS_SAVE_CHAR)
          {
          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);
          UNICODE_STATUS |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;
          }
        ELSE
          {
          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);
          UNICODE_STATUS |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;
          }
        }
      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPT));
      }

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        IF (*CC == PT_SCX)
          {
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);

          JUMP = NULL;
          IF (CC[-1] == XCL_NOTPROP)
            {
            JUMP = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (INT)CC[1]);
            IF (INVERTCMP)
              {
              ADD_JUMP(COMPILER, BACKTRACKS, JUMP);
              JUMP = NULL;
              }
            INVERTCMP ^= 0X1;
            }

          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (SLJIT_SW)(PRIV(UCD_SCRIPT_SETS) + (CC[1] >> 5)), SLJIT_IMM, (SLJIT_SW)1 << (CC[1] & 0X1F));
          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP(SLJIT_NOT_ZERO ^ INVERTCMP));

          IF (JUMP != NULL)
            JUMPHERE(JUMP);
          }
        CC += 2;
        }
      }

    IF (UNICODE_STATUS & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)
      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);
    ELSE IF (UNICODE_STATUS & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)
      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);
    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_SAVE_CHAR)
    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);

  IF (UNICODE_STATUS & XCLASS_HAS_TYPE)
    {
    IF (UNICODE_STATUS & XCLASS_SAVE_CHAR)
      TYPEREG = RETURN_ADDR;

    OP1(SLJIT_MOV_U8, TYPEREG, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, CHARTYPE));
    }
  }
#ENDIF /* SUPPORT_UNICODE */

/* GENERATING CODE. */
CHAROFFSET = 0;
NUMBEROFCMPS = 0;
#IFDEF SUPPORT_UNICODE
TYPEOFFSET = 0;
#ENDIF /* SUPPORT_UNICODE */

WHILE (*CC != XCL_END)
  {
  COMPARES--;
  INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
  JUMP = NULL;

  IF (*CC == XCL_SINGLE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);

    IF (NUMBEROFCMPS < 3 && (*CC == XCL_SINGLE || *CC == XCL_RANGE))
      {
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(NUMBEROFCMPS == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
      NUMBEROFCMPS++;
      }
    ELSE IF (NUMBEROFCMPS > 0)
      {
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      NUMBEROFCMPS = 0;
      }
    ELSE
      {
      JUMP = CMP(SLJIT_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      NUMBEROFCMPS = 0;
      }
    }
  ELSE IF (*CC == XCL_RANGE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);
    SET_CHAR_OFFSET(C);
    GETCHARINCTEST(C, CC);

    IF (NUMBEROFCMPS < 3 && (*CC == XCL_SINGLE || *CC == XCL_RANGE))
      {
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(NUMBEROFCMPS == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);
      NUMBEROFCMPS++;
      }
    ELSE IF (NUMBEROFCMPS > 0)
      {
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      NUMBEROFCMPS = 0;
      }
    ELSE
      {
      JUMP = CMP(SLJIT_LESS_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      NUMBEROFCMPS = 0;
      }
    }
#IFDEF SUPPORT_UNICODE
  ELSE
    {
    SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
    IF (*CC == XCL_NOTPROP)
      INVERTCMP ^= 0X1;
    CC++;
    SWITCH(*CC)
      {
      CASE PT_ANY:
      IF (!INVERTCMP)
        JUMP = JUMP(SLJIT_JUMP);
      BREAK;

      CASE PT_LAMP:
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_LU - TYPEOFFSET);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_LL - TYPEOFFSET);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_LT - TYPEOFFSET);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_GC:
      C = PRIV(UCP_TYPERANGE)[(INT)CC[1] * 2];
      SET_TYPE_OFFSET(C);
      JUMP = CMP(SLJIT_LESS_EQUAL ^ INVERTCMP, TYPEREG, 0, SLJIT_IMM, PRIV(UCP_TYPERANGE)[(INT)CC[1] * 2 + 1] - C);
      BREAK;

      CASE PT_PC:
      JUMP = CMP(SLJIT_EQUAL ^ INVERTCMP, TYPEREG, 0, SLJIT_IMM, (INT)CC[1] - TYPEOFFSET);
      BREAK;

      CASE PT_SC:
      CASE PT_SCX:
      CASE PT_BOOL:
      CASE PT_BIDICL:
      COMPARES++;
      /* DO NOTHING. */
      BREAK;

      CASE PT_SPACE:
      CASE PT_PXSPACE:
      SET_CHAR_OFFSET(9);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0XD - 0X9);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X85 - 0X9);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X180E - 0X9);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      SET_TYPE_OFFSET(UCP_ZL);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_ZS - UCP_ZL);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_WORD:
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_UNDERSCORE - CHAROFFSET));
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
      /* FALL THROUGH. */

      CASE PT_ALNUM:
      SET_TYPE_OFFSET(UCP_LL);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_LU - UCP_LL);
      OP_FLAGS((*CC == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);
      SET_TYPE_OFFSET(UCP_ND);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_NO - UCP_ND);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_CLIST:
      OTHER_CASES = PRIV(UCD_CASELESS_SETS) + CC[1];

      /* AT LEAST THREE CHARACTERS ARE REQUIRED.
         OTHERWISE THIS CASE WOULD BE HANDLED BY THE NORMAL CODE PATH. */
      SLJIT_ASSERT(OTHER_CASES[0] != NOTACHAR && OTHER_CASES[1] != NOTACHAR && OTHER_CASES[2] != NOTACHAR);
      SLJIT_ASSERT(OTHER_CASES[0] < OTHER_CASES[1] && OTHER_CASES[1] < OTHER_CASES[2]);

      /* OPTIMIZING CHARACTER PAIRS, IF THEIR DIFFERENCE IS POWER OF 2. */
      IF (IS_POWEROF2(OTHER_CASES[1] ^ OTHER_CASES[0]))
        {
        IF (CHAROFFSET == 0)
          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, OTHER_CASES[1] ^ OTHER_CASES[0]);
        ELSE
          {
          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (SLJIT_SW)CHAROFFSET);
          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, OTHER_CASES[1] ^ OTHER_CASES[0]);
          }
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, OTHER_CASES[1]);
        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
        OTHER_CASES += 2;
        }
      ELSE IF (IS_POWEROF2(OTHER_CASES[2] ^ OTHER_CASES[1]))
        {
        IF (CHAROFFSET == 0)
          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, OTHER_CASES[2] ^ OTHER_CASES[1]);
        ELSE
          {
          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (SLJIT_SW)CHAROFFSET);
          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, OTHER_CASES[1] ^ OTHER_CASES[0]);
          }
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, OTHER_CASES[2]);
        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);

        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(OTHER_CASES[0] - CHAROFFSET));
        OP_FLAGS(SLJIT_OR | ((OTHER_CASES[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);

        OTHER_CASES += 3;
        }
      ELSE
        {
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(*OTHER_CASES++ - CHAROFFSET));
        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
        }

      WHILE (*OTHER_CASES != NOTACHAR)
        {
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(*OTHER_CASES++ - CHAROFFSET));
        OP_FLAGS(SLJIT_OR | ((*OTHER_CASES == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);
        }
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_UCNC:
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_DOLLAR_SIGN - CHAROFFSET));
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_COMMERCIAL_AT - CHAROFFSET));
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_GRAVE_ACCENT - CHAROFFSET));
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      SET_CHAR_OFFSET(0XA0);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(0XD7FF - CHAROFFSET));
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);
      SET_CHAR_OFFSET(0);
      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0XE000 - 0);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_PXGRAPH:
      /* C AND Z GROUPS ARE THE FARTHEST TWO GROUPS. */
      SET_TYPE_OFFSET(UCP_LL);
      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, TYPEREG, 0, SLJIT_IMM, UCP_SO - UCP_LL);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);

      JUMP = CMP(SLJIT_NOT_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_CF - UCP_LL);

      /* IN CASE OF UCP_CF, WE OVERWRITE THE RESULT. */
      SET_CHAR_OFFSET(0X2066);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X2069 - 0X2066);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X061C - 0X2066);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X180E - 0X2066);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      JUMPHERE(JUMP);
      JUMP = CMP(SLJIT_ZERO ^ INVERTCMP, TMP2, 0, SLJIT_IMM, 0);
      BREAK;

      CASE PT_PXPRINT:
      /* C AND Z GROUPS ARE THE FARTHEST TWO GROUPS. */
      SET_TYPE_OFFSET(UCP_LL);
      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, TYPEREG, 0, SLJIT_IMM, UCP_SO - UCP_LL);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_ZS - UCP_LL);
      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);

      JUMP = CMP(SLJIT_NOT_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_CF - UCP_LL);

      /* IN CASE OF UCP_CF, WE OVERWRITE THE RESULT. */
      SET_CHAR_OFFSET(0X2066);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X2069 - 0X2066);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X061C - 0X2066);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      JUMPHERE(JUMP);
      JUMP = CMP(SLJIT_ZERO ^ INVERTCMP, TMP2, 0, SLJIT_IMM, 0);
      BREAK;

      CASE PT_PXPUNCT:
      SET_TYPE_OFFSET(UCP_SC);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_SO - UCP_SC);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      SET_CHAR_OFFSET(0);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X7F);
      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);

      SET_TYPE_OFFSET(UCP_PC);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_PS - UCP_PC);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      DEFAULT:
      SLJIT_UNREACHABLE();
      BREAK;
      }
    CC += 2;
    }
#ENDIF /* SUPPORT_UNICODE */

  IF (JUMP != NULL)
    ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP);
  }

IF (FOUND != NULL)
  SET_JUMPS(FOUND, LABEL());
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195022_CWE-287.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_USER_AUTH (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * USER_DATA) {
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)USER_DATA;
  JSON_T * J_PARAM = ULFIUS_GET_JSON_BODY_REQUEST(REQUEST, NULL), * J_RESULT = NULL;
  CONST CHAR * IP_SOURCE = GET_IP_SOURCE(REQUEST);
  CHAR * ISSUED_FOR = GET_CLIENT_HOSTNAME(REQUEST);
  CHAR * SESSION_UID, EXPIRES[129];
  TIME_T NOW;
  STRUCT TM TS;
  
  TIME(&NOW);
  NOW += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;
  GMTIME_R(&NOW, &TS);
  STRFTIME(EXPIRES, 128, "%A, %D %B %Y %T %Z", &TS);
  IF (J_PARAM != NULL) {
    IF (JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PARAM, "USERNAME"))) {
      IF (JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE") == NULL || 0 == O_STRCMP(JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), "PASSWORD")) {
        IF (JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PARAM, "PASSWORD"))) {
          J_RESULT = AUTH_CHECK_USER_CREDENTIALS(CONFIG, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "PASSWORD")));
          IF (CHECK_RESULT_VALUE(J_RESULT, G_OK)) {
            IF ((SESSION_UID = GET_SESSION_ID(CONFIG, REQUEST)) == NULL) {
              SESSION_UID = GENERATE_SESSION_ID();
            }
            IF (USER_SESSION_UPDATE(CONFIG, SESSION_UID, U_MAP_GET_CASE(REQUEST->MAP_HEADER, "USER-AGENT"), ISSUED_FOR, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), NULL, 1) != G_OK) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR USER_SESSION_UPDATE (1)");
              RESPONSE->STATUS = 500;
            } ELSE {
              ULFIUS_ADD_COOKIE_TO_RESPONSE(RESPONSE, CONFIG->SESSION_KEY, SESSION_UID, EXPIRES, 0, CONFIG->COOKIE_DOMAIN, "/", CONFIG->COOKIE_SECURE, 0);
              Y_LOG_MESSAGE(Y_LOG_LEVEL_INFO, "EVENT - USER '%S' AUTHENTICATED WITH PASSWORD", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")));
            }
            O_FREE(SESSION_UID);
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, "SCHEME_TYPE", "PASSWORD", NULL);
          } ELSE {
            IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_UNAUTHORIZED)) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_WARNING, "SECURITY - AUTHORIZATION INVALID FOR USERNAME %S AT IP ADDRESS %S", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), IP_SOURCE);
            }
            IF ((SESSION_UID = GET_SESSION_ID(CONFIG, REQUEST)) != NULL && USER_SESSION_UPDATE(CONFIG, SESSION_UID, U_MAP_GET_CASE(REQUEST->MAP_HEADER, "USER-AGENT"), ISSUED_FOR, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), NULL, 1) != G_OK) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR USER_SESSION_UPDATE (2)");
            }
            O_FREE(SESSION_UID);
            RESPONSE->STATUS = 401;
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, "SCHEME_TYPE", "PASSWORD", NULL);
          }
          JSON_DECREF(J_RESULT);
        } ELSE IF (JSON_OBJECT_GET(J_PARAM, "PASSWORD") != NULL && !JSON_IS_STRING(JSON_OBJECT_GET(J_PARAM, "PASSWORD"))) {
          ULFIUS_SET_STRING_BODY_RESPONSE(RESPONSE, 400, "PASSWORD MUST BE A STRING");
        } ELSE {
          SESSION_UID = GET_SESSION_ID(CONFIG, REQUEST);
          J_RESULT = GET_USERS_FOR_SESSION(CONFIG, SESSION_UID);
          IF (CHECK_RESULT_VALUE(J_RESULT, G_OK)) {
            // REFRESH USERNAME TO SET AS DEFAULT
            IF (USER_SESSION_UPDATE(CONFIG, U_MAP_GET(REQUEST->MAP_COOKIE, CONFIG->SESSION_KEY), U_MAP_GET_CASE(REQUEST->MAP_HEADER, "USER-AGENT"), ISSUED_FOR, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), NULL, 0) != G_OK) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR USER_SESSION_UPDATE (3)");
              RESPONSE->STATUS = 500;
            } ELSE {
              ULFIUS_ADD_COOKIE_TO_RESPONSE(RESPONSE, CONFIG->SESSION_KEY, SESSION_UID, EXPIRES, 0, CONFIG->COOKIE_DOMAIN, "/", CONFIG->COOKIE_SECURE, 0);
            }
          } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_NOT_FOUND)) {
            RESPONSE->STATUS = 401;
          } ELSE {
            Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR GET_USERS_FOR_SESSION");
            RESPONSE->STATUS = 500;
          }
          O_FREE(SESSION_UID);
          JSON_DECREF(J_RESULT);
        }
      } ELSE {
        IF (JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")) && JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")) && JSON_IS_OBJECT(JSON_OBJECT_GET(J_PARAM, "VALUE"))) {
          J_RESULT = AUTH_CHECK_USER_SCHEME(CONFIG, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), JSON_OBJECT_GET(J_PARAM, "VALUE"), REQUEST);
          IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_PARAM)) {
            ULFIUS_SET_STRING_BODY_RESPONSE(RESPONSE, 400, "BAD SCHEME RESPONSE");
          } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_UNAUTHORIZED)) {
            Y_LOG_MESSAGE(Y_LOG_LEVEL_WARNING, "SECURITY - AUTHORIZATION INVALID FOR USERNAME %S AT IP ADDRESS %S", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), IP_SOURCE);
            RESPONSE->STATUS = 401;
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, "SCHEME_TYPE", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), "SCHEME_NAME", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")), NULL);
          } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_NOT_FOUND)) {
            RESPONSE->STATUS = 404;
          } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_OK)) {
            IF ((SESSION_UID = GET_SESSION_ID(CONFIG, REQUEST)) == NULL) {
              SESSION_UID = GENERATE_SESSION_ID();
            }
            IF (USER_SESSION_UPDATE(CONFIG, SESSION_UID, U_MAP_GET_CASE(REQUEST->MAP_HEADER, "USER-AGENT"), ISSUED_FOR, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")), 1) != G_OK) {
              Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR USER_SESSION_UPDATE (4)");
              RESPONSE->STATUS = 500;
            } ELSE {
              ULFIUS_ADD_COOKIE_TO_RESPONSE(RESPONSE, CONFIG->SESSION_KEY, SESSION_UID, EXPIRES, 0, CONFIG->COOKIE_DOMAIN, "/", CONFIG->COOKIE_SECURE, 0);
              Y_LOG_MESSAGE(Y_LOG_LEVEL_INFO, "EVENT - USER '%S' AUTHENTICATED WITH SCHEME '%S/%S'", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")));
            }
            O_FREE(SESSION_UID);
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);
            GLEWLWYD_METRICS_INCREMENT_COUNTER_VA(CONFIG, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, "SCHEME_TYPE", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), "SCHEME_NAME", JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")), NULL);
          } ELSE {
            Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR AUTH_CHECK_USER_SCHEME");
            RESPONSE->STATUS = 500;
          }
          JSON_DECREF(J_RESULT);
        } ELSE {
          ULFIUS_SET_STRING_BODY_RESPONSE(RESPONSE, 400, "SCHEME_TYPE, SCHEME_NAME AND VALUE ARE MANDATORY");
        }
      }
    } ELSE {
      IF (JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")) && JSON_STRING_LENGTH(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")) && JSON_IS_OBJECT(JSON_OBJECT_GET(J_PARAM, "VALUE"))) {
        J_RESULT = AUTH_CHECK_IDENTIFY_SCHEME(CONFIG, JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")), JSON_OBJECT_GET(J_PARAM, "VALUE"), REQUEST);
        IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_PARAM)) {
          ULFIUS_SET_STRING_BODY_RESPONSE(RESPONSE, 400, "BAD SCHEME RESPONSE");
        } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_UNAUTHORIZED)) {
          Y_LOG_MESSAGE(Y_LOG_LEVEL_WARNING, "SECURITY - AUTHORIZATION INVALID FOR USERNAME <UNKNOWN> AT IP ADDRESS %S", IP_SOURCE);
          RESPONSE->STATUS = 401;
        } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_ERROR_NOT_FOUND)) {
          RESPONSE->STATUS = 404;
        } ELSE IF (CHECK_RESULT_VALUE(J_RESULT, G_OK)) {
          IF ((SESSION_UID = GET_SESSION_ID(CONFIG, REQUEST)) == NULL) {
            SESSION_UID = GENERATE_SESSION_ID();
          }
          IF (USER_SESSION_UPDATE(CONFIG, SESSION_UID, U_MAP_GET_CASE(REQUEST->MAP_HEADER, "USER-AGENT"), ISSUED_FOR, JSON_STRING_VALUE(JSON_OBJECT_GET(J_RESULT, "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")), 1) != G_OK) {
            Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR USER_SESSION_UPDATE (4)");
            RESPONSE->STATUS = 500;
          } ELSE {
            ULFIUS_ADD_COOKIE_TO_RESPONSE(RESPONSE, CONFIG->SESSION_KEY, SESSION_UID, EXPIRES, 0, CONFIG->COOKIE_DOMAIN, "/", CONFIG->COOKIE_SECURE, 0);
            Y_LOG_MESSAGE(Y_LOG_LEVEL_INFO, "EVENT - USER '%S' AUTHENTICATED WITH SCHEME '%S/%S'", JSON_STRING_VALUE(JSON_OBJECT_GET(J_RESULT, "USERNAME")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_TYPE")), JSON_STRING_VALUE(JSON_OBJECT_GET(J_PARAM, "SCHEME_NAME")));
          }
          O_FREE(SESSION_UID);
        } ELSE {
          Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_AUTH - ERROR AUTH_CHECK_USER_SCHEME");
          RESPONSE->STATUS = 500;
        }
        JSON_DECREF(J_RESULT);
      } ELSE {
        ULFIUS_SET_STRING_BODY_RESPONSE(RESPONSE, 400, "USERNAME IS MANDATORY");
      }
    }
  } ELSE {
    ULFIUS_SET_STRING_BODY_RESPONSE(RESPONSE, 400, "INPUT PARAMETERS MUST BE IN JSON FORMAT");
  }
  JSON_DECREF(J_PARAM);
  O_FREE(ISSUED_FOR);

  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211594_CWE-400.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READWPGIMAGE(CONST IMAGEINFO *IMAGE_INFO,
  EXCEPTIONINFO *EXCEPTION)
{
  TYPEDEF STRUCT
  {
    SIZE_T FILEID;
    MAGICKOFFSETTYPE DATAOFFSET;
    UNSIGNED INT PRODUCTTYPE;
    UNSIGNED INT FILETYPE;
    UNSIGNED CHAR MAJORVERSION;
    UNSIGNED CHAR MINORVERSION;
    UNSIGNED INT ENCRYPTKEY;
    UNSIGNED INT RESERVED;
  } WPGHEADER;

  TYPEDEF STRUCT
  {
    UNSIGNED CHAR RECTYPE;
    SIZE_T RECORDLENGTH;
  } WPGRECORD;

  TYPEDEF STRUCT
  {
    UNSIGNED CHAR CLASS;
    UNSIGNED CHAR RECTYPE;
    SIZE_T EXTENSION;
    SIZE_T RECORDLENGTH;
  } WPG2RECORD;

  TYPEDEF STRUCT
  {
    UNSIGNED  HORIZONTALUNITS;
    UNSIGNED  VERTICALUNITS;
    UNSIGNED CHAR POSSIZEPRECISION;
  } WPG2START;

  TYPEDEF STRUCT
  {
    UNSIGNED INT WIDTH;
    UNSIGNED INT HEIGHT;
    UNSIGNED INT DEPTH;
    UNSIGNED INT HORZRES;
    UNSIGNED INT VERTRES;
  } WPGBITMAPTYPE1;

  TYPEDEF STRUCT
  {
    UNSIGNED INT WIDTH;
    UNSIGNED INT HEIGHT;
    UNSIGNED CHAR DEPTH;
    UNSIGNED CHAR COMPRESSION;
  } WPG2BITMAPTYPE1;

  TYPEDEF STRUCT
  {
    UNSIGNED INT ROTANGLE;
    UNSIGNED INT LOWLEFTX;
    UNSIGNED INT LOWLEFTY;
    UNSIGNED INT UPRIGHTX;
    UNSIGNED INT UPRIGHTY;
    UNSIGNED INT WIDTH;
    UNSIGNED INT HEIGHT;
    UNSIGNED INT DEPTH;
    UNSIGNED INT HORZRES;
    UNSIGNED INT VERTRES;
  } WPGBITMAPTYPE2;

  TYPEDEF STRUCT
  {
    UNSIGNED INT STARTINDEX;
    UNSIGNED INT NUMOFENTRIES;
  } WPGCOLORMAPREC;

  /*
  TYPEDEF STRUCT {
    SIZE_T PS_UNKNOWN1;
    UNSIGNED INT PS_UNKNOWN2;
    UNSIGNED INT PS_UNKNOWN3;
  } WPGPSL1RECORD;  
  */

  IMAGE
    *IMAGE;

  UNSIGNED INT
    STATUS;

  WPGHEADER
    HEADER;

  WPGRECORD
    REC;

  WPG2RECORD
    REC2;

  WPG2START STARTWPG;

  WPGBITMAPTYPE1
    BITMAPHEADER1;

  WPG2BITMAPTYPE1
    BITMAP2HEADER1;

  WPGBITMAPTYPE2
    BITMAPHEADER2;

  WPGCOLORMAPREC
    WPG_PALETTE;

  INT
    I,
    BPP,
    WPG2FLAGS;

  SSIZE_T
    LDBLK;

  SIZE_T
    ONE;

  UNSIGNED CHAR
    *BIMGBUFF;

  TCTM CTM;         /*CURRENT TRANSFORM MATRIX*/

  /*
    OPEN IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  ONE=1;
  IMAGE=ACQUIREIMAGE(IMAGE_INFO,EXCEPTION);
  IMAGE->DEPTH=8;
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    READ WPG IMAGE.
  */
  HEADER.FILEID=READBLOBLSBLONG(IMAGE);
  HEADER.DATAOFFSET=(MAGICKOFFSETTYPE) READBLOBLSBLONG(IMAGE);
  HEADER.PRODUCTTYPE=READBLOBLSBSHORT(IMAGE);
  HEADER.FILETYPE=READBLOBLSBSHORT(IMAGE);
  HEADER.MAJORVERSION=READBLOBBYTE(IMAGE);
  HEADER.MINORVERSION=READBLOBBYTE(IMAGE);
  HEADER.ENCRYPTKEY=READBLOBLSBSHORT(IMAGE);
  HEADER.RESERVED=READBLOBLSBSHORT(IMAGE);

  IF (HEADER.FILEID!=0X435057FF || (HEADER.PRODUCTTYPE>>8)!=0X16)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  IF (HEADER.ENCRYPTKEY!=0)
    THROWREADEREXCEPTION(CODERERROR,"ENCRYPTEDWPGIMAGEFILENOTSUPPORTED");

  IMAGE->COLUMNS = 1;
  IMAGE->ROWS = 1;
  IMAGE->COLORS = 0;
  BPP=0;
  BITMAPHEADER2.ROTANGLE=0;
  REC2.RECORDLENGTH=0;

  SWITCH(HEADER.FILETYPE)
    {
    CASE 1:     /* WPG LEVEL 1 */
      WHILE(!EOFBLOB(IMAGE)) /* OBJECT PARSER LOOP */
        {
          (VOID) SEEKBLOB(IMAGE,HEADER.DATAOFFSET,SEEK_SET);
          IF(EOFBLOB(IMAGE))
            BREAK;

          REC.RECTYPE=(I=READBLOBBYTE(IMAGE));
          IF(I==EOF)
            BREAK;
          RD_WP_DWORD(IMAGE,&REC.RECORDLENGTH);
          IF (REC.RECORDLENGTH > GETBLOBSIZE(IMAGE))
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
          IF(EOFBLOB(IMAGE))
            BREAK;

          HEADER.DATAOFFSET=TELLBLOB(IMAGE)+REC.RECORDLENGTH;

          SWITCH(REC.RECTYPE)
            {
            CASE 0X0B: /* BITMAP TYPE 1 */
              BITMAPHEADER1.WIDTH=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER1.HEIGHT=READBLOBLSBSHORT(IMAGE);
              IF ((BITMAPHEADER1.WIDTH == 0) || (BITMAPHEADER1.HEIGHT == 0))
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
              BITMAPHEADER1.DEPTH=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER1.HORZRES=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER1.VERTRES=READBLOBLSBSHORT(IMAGE);

              IF(BITMAPHEADER1.HORZRES && BITMAPHEADER1.VERTRES)
                {
                  IMAGE->UNITS=PIXELSPERCENTIMETERRESOLUTION;
                  IMAGE->RESOLUTION.X=BITMAPHEADER1.HORZRES/470.0;
                  IMAGE->RESOLUTION.Y=BITMAPHEADER1.VERTRES/470.0;
                }
              IMAGE->COLUMNS=BITMAPHEADER1.WIDTH;
              IMAGE->ROWS=BITMAPHEADER1.HEIGHT;
              BPP=BITMAPHEADER1.DEPTH;

              GOTO UNPACKRASTER;

            CASE 0X0E:  /*COLOR PALETTE */
              WPG_PALETTE.STARTINDEX=READBLOBLSBSHORT(IMAGE);
              WPG_PALETTE.NUMOFENTRIES=READBLOBLSBSHORT(IMAGE);
              IF ((WPG_PALETTE.NUMOFENTRIES-WPG_PALETTE.STARTINDEX) >
                  (REC2.RECORDLENGTH-2-2) / 3)
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INVALIDCOLORMAPINDEX");
              IMAGE->COLORS=WPG_PALETTE.NUMOFENTRIES;
              IF (!ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS,EXCEPTION))
                GOTO NOMEMORY;
              FOR (I=WPG_PALETTE.STARTINDEX;
                   I < (INT)WPG_PALETTE.NUMOFENTRIES; I++)
                {
                  IMAGE->COLORMAP[I].RED=SCALECHARTOQUANTUM((UNSIGNED CHAR)
                    READBLOBBYTE(IMAGE));
                  IMAGE->COLORMAP[I].GREEN=SCALECHARTOQUANTUM((UNSIGNED CHAR)
                    READBLOBBYTE(IMAGE));
                  IMAGE->COLORMAP[I].BLUE=SCALECHARTOQUANTUM((UNSIGNED CHAR)
                    READBLOBBYTE(IMAGE));
                }
              BREAK;
     
            CASE 0X11:  /* START PS L1 */
              IF(REC.RECORDLENGTH > 8)
                IMAGE=EXTRACTPOSTSCRIPT(IMAGE,IMAGE_INFO,
                  TELLBLOB(IMAGE)+8,   /* SKIP PS HEADER IN THE WPG */
                  (SSIZE_T) REC.RECORDLENGTH-8,EXCEPTION);
              BREAK;     

            CASE 0X14:  /* BITMAP TYPE 2 */
              BITMAPHEADER2.ROTANGLE=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.LOWLEFTX=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.LOWLEFTY=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.UPRIGHTX=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.UPRIGHTY=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.WIDTH=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.HEIGHT=READBLOBLSBSHORT(IMAGE);
              IF ((BITMAPHEADER2.WIDTH == 0) || (BITMAPHEADER2.HEIGHT == 0))
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
              BITMAPHEADER2.DEPTH=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.HORZRES=READBLOBLSBSHORT(IMAGE);
              BITMAPHEADER2.VERTRES=READBLOBLSBSHORT(IMAGE);

              IMAGE->UNITS=PIXELSPERCENTIMETERRESOLUTION;
              IMAGE->PAGE.WIDTH=(UNSIGNED INT)
                ((BITMAPHEADER2.LOWLEFTX-BITMAPHEADER2.UPRIGHTX)/470.0);
              IMAGE->PAGE.HEIGHT=(UNSIGNED INT)
                ((BITMAPHEADER2.LOWLEFTX-BITMAPHEADER2.UPRIGHTY)/470.0);
              IMAGE->PAGE.X=(INT) (BITMAPHEADER2.LOWLEFTX/470.0);
              IMAGE->PAGE.Y=(INT) (BITMAPHEADER2.LOWLEFTX/470.0);
              IF(BITMAPHEADER2.HORZRES && BITMAPHEADER2.VERTRES)
                {
                  IMAGE->RESOLUTION.X=BITMAPHEADER2.HORZRES/470.0;
                  IMAGE->RESOLUTION.Y=BITMAPHEADER2.VERTRES/470.0;
                }
              IMAGE->COLUMNS=BITMAPHEADER2.WIDTH;
              IMAGE->ROWS=BITMAPHEADER2.HEIGHT;
              BPP=BITMAPHEADER2.DEPTH;

            UNPACKRASTER:      
              STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
              IF (STATUS == MAGICKFALSE)
                BREAK;
              IF ((IMAGE->COLORS == 0) && (BPP != 24))
                {
                  IMAGE->COLORS=ONE << BPP;
                  IF (!ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS,EXCEPTION))
                    {
                    NOMEMORY:
                      THROWREADEREXCEPTION(RESOURCELIMITERROR,
                        "MEMORYALLOCATIONFAILED");
                    }
                  /* PRINTF("LOAD DEFAULT COLORMAP \N"); */
                  FOR (I=0; (I < (INT) IMAGE->COLORS) && (I < 256); I++)
                    {               
                      IMAGE->COLORMAP[I].RED=SCALECHARTOQUANTUM(WPG1_PALETTE[I].RED);
                      IMAGE->COLORMAP[I].GREEN=SCALECHARTOQUANTUM(WPG1_PALETTE[I].GREEN);
                      IMAGE->COLORMAP[I].BLUE=SCALECHARTOQUANTUM(WPG1_PALETTE[I].BLUE);
                    }
                }
              ELSE
                {
                  IF (BPP < 24)
                    IF ( (IMAGE->COLORS < (ONE << BPP)) && (BPP != 24) )
                      IMAGE->COLORMAP=(PIXELINFO *) RESIZEQUANTUMMEMORY(
                        IMAGE->COLORMAP,(SIZE_T) (ONE << BPP),
                        SIZEOF(*IMAGE->COLORMAP));
                }
          
              IF (BPP == 1)
                {
                  IF(IMAGE->COLORMAP[0].RED==0 &&
                     IMAGE->COLORMAP[0].GREEN==0 &&
                     IMAGE->COLORMAP[0].BLUE==0 &&
                     IMAGE->COLORMAP[1].RED==0 &&
                     IMAGE->COLORMAP[1].GREEN==0 &&
                     IMAGE->COLORMAP[1].BLUE==0)
                    {  /* FIX CRIPPLED MONOCHROME PALETTE */
                      IMAGE->COLORMAP[1].RED =
                        IMAGE->COLORMAP[1].GREEN =
                        IMAGE->COLORMAP[1].BLUE = QUANTUMRANGE;
                    }
                }      

              IF(UNPACKWPGRASTER(IMAGE,BPP,EXCEPTION) < 0)
                /* THE RASTER CANNOT BE UNPACKED */
                {
                DECOMPRESSIONFAILED:
                  THROWREADEREXCEPTION(CODERERROR,"UNABLETODECOMPRESSIMAGE");
                    }

              IF(REC.RECTYPE==0X14 && BITMAPHEADER2.ROTANGLE!=0 && !IMAGE_INFO->PING)
                {  
                  /* FLOP COMMAND */
                  IF(BITMAPHEADER2.ROTANGLE & 0X8000)
                    {
                      IMAGE
                        *FLOP_IMAGE;

                      FLOP_IMAGE = FLOPIMAGE(IMAGE, EXCEPTION);
                      IF (FLOP_IMAGE != (IMAGE *) NULL) {
                        DUPLICATEBLOB(FLOP_IMAGE,IMAGE);
                        REPLACEIMAGEINLIST(&IMAGE,FLOP_IMAGE);
                      }
                    }
                  /* FLIP COMMAND */
                  IF(BITMAPHEADER2.ROTANGLE & 0X2000)
                    {
                      IMAGE
                        *FLIP_IMAGE;

                      FLIP_IMAGE = FLIPIMAGE(IMAGE, EXCEPTION);
                      IF (FLIP_IMAGE != (IMAGE *) NULL) {
                        DUPLICATEBLOB(FLIP_IMAGE,IMAGE);
                        REPLACEIMAGEINLIST(&IMAGE,FLIP_IMAGE);
                      }
                    }
                  /* ROTATE COMMAND */
                  IF(BITMAPHEADER2.ROTANGLE & 0X0FFF)
                    {
                      IMAGE
                        *ROTATE_IMAGE;

                      ROTATE_IMAGE=ROTATEIMAGE(IMAGE,(BITMAPHEADER2.ROTANGLE &
                        0X0FFF), EXCEPTION);
                      IF (ROTATE_IMAGE != (IMAGE *) NULL) {
                        DUPLICATEBLOB(ROTATE_IMAGE,IMAGE);
                        REPLACEIMAGEINLIST(&IMAGE,ROTATE_IMAGE);
                      }
                    }
                }

              /* ALLOCATE NEXT IMAGE STRUCTURE. */
              ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);
              IMAGE->DEPTH=8;
              IF (IMAGE->NEXT == (IMAGE *) NULL)
                GOTO FINISH;
              IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
              IMAGE->COLUMNS=IMAGE->ROWS=1;
              IMAGE->COLORS=0;
              BREAK;

            CASE 0X1B:  /* POSTSCRIPT L2 */
              IF(REC.RECORDLENGTH>0X3C)
                IMAGE=EXTRACTPOSTSCRIPT(IMAGE,IMAGE_INFO,
                  TELLBLOB(IMAGE)+0X3C,   /* SKIP PS L2 HEADER IN THE WPG */
                  (SSIZE_T) REC.RECORDLENGTH-0X3C,EXCEPTION);
              BREAK;
            }
        }
      BREAK;

    CASE 2:  /* WPG LEVEL 2 */
      (VOID) MEMSET(CTM,0,SIZEOF(CTM));
      STARTWPG.POSSIZEPRECISION = 0;
      WHILE(!EOFBLOB(IMAGE)) /* OBJECT PARSER LOOP */
        {
          (VOID) SEEKBLOB(IMAGE,HEADER.DATAOFFSET,SEEK_SET);
          IF(EOFBLOB(IMAGE))
            BREAK;

          REC2.CLASS=(I=READBLOBBYTE(IMAGE));
          IF(I==EOF)
            BREAK;
          REC2.RECTYPE=(I=READBLOBBYTE(IMAGE));
          IF(I==EOF)
            BREAK;
          RD_WP_DWORD(IMAGE,&REC2.EXTENSION);
          RD_WP_DWORD(IMAGE,&REC2.RECORDLENGTH);
          IF(EOFBLOB(IMAGE))
            BREAK;

          HEADER.DATAOFFSET=TELLBLOB(IMAGE)+REC2.RECORDLENGTH;

          SWITCH(REC2.RECTYPE)
            {
      CASE 1:
              STARTWPG.HORIZONTALUNITS=READBLOBLSBSHORT(IMAGE);
              STARTWPG.VERTICALUNITS=READBLOBLSBSHORT(IMAGE);
              STARTWPG.POSSIZEPRECISION=READBLOBBYTE(IMAGE);
              BREAK;
            CASE 0X0C:    /* COLOR PALETTE */
              WPG_PALETTE.STARTINDEX=READBLOBLSBSHORT(IMAGE);
              WPG_PALETTE.NUMOFENTRIES=READBLOBLSBSHORT(IMAGE);
              IF ((WPG_PALETTE.NUMOFENTRIES-WPG_PALETTE.STARTINDEX) >
                  (REC2.RECORDLENGTH-2-2) / 3)
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INVALIDCOLORMAPINDEX");
              IMAGE->COLORS=WPG_PALETTE.NUMOFENTRIES;
              IF (ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS,EXCEPTION) == MAGICKFALSE)
                THROWREADEREXCEPTION(RESOURCELIMITERROR,
                  "MEMORYALLOCATIONFAILED");
              FOR (I=WPG_PALETTE.STARTINDEX;
                   I < (INT)WPG_PALETTE.NUMOFENTRIES; I++)
                {
                  IMAGE->COLORMAP[I].RED=SCALECHARTOQUANTUM((CHAR)
                    READBLOBBYTE(IMAGE));
                  IMAGE->COLORMAP[I].GREEN=SCALECHARTOQUANTUM((CHAR)
                    READBLOBBYTE(IMAGE));
                  IMAGE->COLORMAP[I].BLUE=SCALECHARTOQUANTUM((CHAR)
                    READBLOBBYTE(IMAGE));
                  (VOID) READBLOBBYTE(IMAGE);   /*OPACITY??*/
                }
              BREAK;
            CASE 0X0E:
              BITMAP2HEADER1.WIDTH=READBLOBLSBSHORT(IMAGE);
              BITMAP2HEADER1.HEIGHT=READBLOBLSBSHORT(IMAGE);
              IF ((BITMAP2HEADER1.WIDTH == 0) || (BITMAP2HEADER1.HEIGHT == 0))
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
              BITMAP2HEADER1.DEPTH=READBLOBBYTE(IMAGE);
              BITMAP2HEADER1.COMPRESSION=READBLOBBYTE(IMAGE);

              IF(BITMAP2HEADER1.COMPRESSION > 1)
                CONTINUE; /*UNKNOWN COMPRESSION METHOD */
              SWITCH(BITMAP2HEADER1.DEPTH)
                {
                CASE 1:
                  BPP=1;
                  BREAK;
                CASE 2:
                  BPP=2;
                  BREAK;
                CASE 3:
                  BPP=4;
                  BREAK;
                CASE 4:
                  BPP=8;
                  BREAK;
                CASE 8:
                  BPP=24;
                  BREAK;
                DEFAULT:
                  CONTINUE;  /*IGNORE RASTER WITH UNKNOWN DEPTH*/
                }
              IMAGE->COLUMNS=BITMAP2HEADER1.WIDTH;
              IMAGE->ROWS=BITMAP2HEADER1.HEIGHT;
              STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
              IF (STATUS == MAGICKFALSE)
                BREAK;
              IF ((IMAGE->COLORS == 0) && (BPP != 24))
                {
                  IMAGE->COLORS=ONE << BPP;
                  IF (!ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS,EXCEPTION))
                    GOTO NOMEMORY;
                }
              ELSE
                {
                  IF(BPP < 24)
                    IF( IMAGE->COLORS<(ONE << BPP) && BPP!=24 )
                      IMAGE->COLORMAP=(PIXELINFO *) RESIZEQUANTUMMEMORY(
                       IMAGE->COLORMAP,(SIZE_T) (ONE << BPP),
                       SIZEOF(*IMAGE->COLORMAP));
                }


              SWITCH(BITMAP2HEADER1.COMPRESSION)
                {
                CASE 0:    /*UNCOMPRESSED RASTER*/
                  {
                    LDBLK=(SSIZE_T) ((BPP*IMAGE->COLUMNS+7)/8);
                    BIMGBUFF=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T)
                      LDBLK+1,SIZEOF(*BIMGBUFF));
                    IF (BIMGBUFF == (UNSIGNED CHAR *) NULL)
                      GOTO NOMEMORY;

                    FOR(I=0; I< (SSIZE_T) IMAGE->ROWS; I++)
                      {
                        (VOID) READBLOB(IMAGE,LDBLK,BIMGBUFF);
                        INSERTROW(IMAGE,BIMGBUFF,I,BPP,EXCEPTION);
                      }

                    IF(BIMGBUFF)
                      BIMGBUFF=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BIMGBUFF);
                    BREAK;
                  }
                CASE 1:    /*RLE FOR WPG2 */
                  {
                    IF( UNPACKWPG2RASTER(IMAGE,BPP,EXCEPTION) < 0)
                      GOTO DECOMPRESSIONFAILED;
                    BREAK;
                  }   
                }

              IF(CTM[0][0]<0 && !IMAGE_INFO->PING)
                {    /*?? ROTANGLE=360-ROTANGLE;*/
                  IMAGE
                    *FLOP_IMAGE;

                  FLOP_IMAGE = FLOPIMAGE(IMAGE, EXCEPTION);
                  IF (FLOP_IMAGE != (IMAGE *) NULL) {
                    DUPLICATEBLOB(FLOP_IMAGE,IMAGE);
                    REPLACEIMAGEINLIST(&IMAGE,FLOP_IMAGE);
                  }
                  /* TRY TO CHANGE CTM ACCORDING TO FLIP - I AM NOT SURE, MUST BE CHECKED.
                     TX(0,0)=-1;      TX(1,0)=0;   TX(2,0)=0;
                     TX(0,1)= 0;      TX(1,1)=1;   TX(2,1)=0;
                     TX(0,2)=(WPG._2RECT.X_UR+WPG._2RECT.X_LL);
                     TX(1,2)=0;   TX(2,2)=1; */
                }
              IF(CTM[1][1]<0 && !IMAGE_INFO->PING)
                {    /*?? ROTANGLE=360-ROTANGLE;*/
                  IMAGE
                    *FLIP_IMAGE;

                   FLIP_IMAGE = FLIPIMAGE(IMAGE, EXCEPTION);
                   IF (FLIP_IMAGE != (IMAGE *) NULL) {
                     DUPLICATEBLOB(FLIP_IMAGE,IMAGE);
                     REPLACEIMAGEINLIST(&IMAGE,FLIP_IMAGE);
                    }
                  /* TRY TO CHANGE CTM ACCORDING TO FLIP - I AM NOT SURE, MUST BE CHECKED.
                     FLOAT_MATRIX TX(3,3);
                     TX(0,0)= 1;   TX(1,0)= 0;   TX(2,0)=0;
                     TX(0,1)= 0;   TX(1,1)=-1;   TX(2,1)=0;
                     TX(0,2)= 0;   TX(1,2)=(WPG._2RECT.Y_UR+WPG._2RECT.Y_LL);
                     TX(2,2)=1; */
              }


              /* ALLOCATE NEXT IMAGE STRUCTURE. */
              ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);
              IMAGE->DEPTH=8;
              IF (IMAGE->NEXT == (IMAGE *) NULL)
                GOTO FINISH;
              IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
              IMAGE->COLUMNS=IMAGE->ROWS=1;
              IMAGE->COLORS=0;
              BREAK;

            CASE 0X12:  /* POSTSCRIPT WPG2*/
        I=READBLOBLSBSHORT(IMAGE);
              IF(REC2.RECORDLENGTH > (UNSIGNED INT) I)
                IMAGE=EXTRACTPOSTSCRIPT(IMAGE,IMAGE_INFO,
                  TELLBLOB(IMAGE)+I,    /*SKIP PS HEADER IN THE WPG2*/
                  (SSIZE_T) (REC2.RECORDLENGTH-I-2),EXCEPTION);
              BREAK;

      CASE 0X1B:          /*BITMAP RECTANGLE*/
              WPG2FLAGS = LOADWPG2FLAGS(IMAGE,STARTWPG.POSSIZEPRECISION,NULL,&CTM);
              (VOID) WPG2FLAGS;
              BREAK;
            }
        }

      BREAK;

    DEFAULT:
      {
         THROWREADEREXCEPTION(CODERERROR,"DATAENCODINGSCHEMEISNOTSUPPORTED");
      }
   }

 FINISH:
  (VOID) CLOSEBLOB(IMAGE);

  {
    IMAGE
      *P;

    SSIZE_T
      SCENE=0;

    /*
      REWIND LIST, REMOVING ANY EMPTY IMAGES WHILE REWINDING.
    */
    P=IMAGE;
    IMAGE=NULL;
    WHILE (P != (IMAGE *) NULL)
      {
        IMAGE *TMP=P;
        IF ((P->ROWS == 0) || (P->COLUMNS == 0)) {
          P=P->PREVIOUS;
          DELETEIMAGEFROMLIST(&TMP);
        } ELSE {
          IMAGE=P;
          P=P->PREVIOUS;
        }
      }
    /*
      FIX SCENE NUMBERS.
    */
    FOR (P=IMAGE; P != (IMAGE *) NULL; P=P->NEXT)
      P->SCENE=(SIZE_T) SCENE++;
  }
  IF (IMAGE == (IMAGE *) NULL)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
      "IMAGEFILEDOESNOTCONTAINANYIMAGEDATA");
  RETURN(IMAGE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215921_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BMEXEC_TRANS (KWSET_T KWSET, CHAR CONST *TEXT, SIZE_T SIZE)
{
  UNSIGNED CHAR CONST *D1;
  CHAR CONST *EP, *SP, *TP;
  INT D;
  INT LEN = KWSET->MIND;
  CHAR CONST *TRANS = KWSET->TRANS;

  IF (LEN == 0)
    RETURN 0;
  IF (LEN > SIZE)
    RETURN -1;
  IF (LEN == 1)
    {
      TP = MEMCHR_KWSET (TEXT, SIZE, KWSET);
      RETURN TP ? TP - TEXT : -1;
    }

  D1 = KWSET->DELTA;
  SP = KWSET->TARGET + LEN;
  TP = TEXT + LEN;
  CHAR GC1 = KWSET->GC1;
  CHAR GC2 = KWSET->GC2;

  /* SIGNIFICANCE OF 12: 1 (INITIAL OFFSET) + 10 (SKIP LOOP) + 1 (MD2). */
  IF (SIZE > 12 * LEN)
    /* 11 IS NOT A BUG, THE INITIAL OFFSET HAPPENS ONLY ONCE. */
    FOR (EP = TEXT + SIZE - 11 * LEN; TP <= EP; )
      {
        CHAR CONST *TP0 = TP;
        D = D1[U(TP[-1])], TP += D;
        D = D1[U(TP[-1])], TP += D;
        IF (D != 0)
          {
            D = D1[U(TP[-1])], TP += D;
            D = D1[U(TP[-1])], TP += D;
            D = D1[U(TP[-1])], TP += D;
            IF (D != 0)
              {
                D = D1[U(TP[-1])], TP += D;
                D = D1[U(TP[-1])], TP += D;
                D = D1[U(TP[-1])], TP += D;
                IF (D != 0)
                  {
                    D = D1[U(TP[-1])], TP += D;
                    D = D1[U(TP[-1])], TP += D;

                    /* AS A HEURISTIC, PREFER MEMCHR TO SEEKING BY
                       DELTA1 WHEN THE LATTER DOESN'T ADVANCE MUCH.  */
                    INT ADVANCE_HEURISTIC = 16 * SIZEOF (LONG);
                    IF (ADVANCE_HEURISTIC <= TP - TP0)
                      GOTO BIG_ADVANCE;
                    TP--;
                    TP = MEMCHR_KWSET (TP, TEXT + SIZE - TP, KWSET);
                    IF (! TP)
                      RETURN -1;
                    TP++;
                  }
              }
          }
        IF (BM_DELTA2_SEARCH (&TP, EP, SP, LEN, TRANS, GC1, GC2, D1, KWSET))
          RETURN TP - TEXT;
      BIG_ADVANCE:;
      }

  /* NOW WE HAVE ONLY A FEW CHARACTERS LEFT TO SEARCH.  WE
     CAREFULLY AVOID EVER PRODUCING AN OUT-OF-BOUNDS POINTER. */
  EP = TEXT + SIZE;
  D = D1[U(TP[-1])];
  WHILE (D <= EP - TP)
    {
      D = D1[U((TP += D)[-1])];
      IF (D != 0)
        CONTINUE;
      IF (BM_DELTA2_SEARCH (&TP, EP, SP, LEN, TRANS, GC1, GC2, NULL, KWSET))
        RETURN TP - TEXT;
    }

  RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225619_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR MFRO_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	GF_MOVIEFRAGMENTRANDOMACCESSOFFSETBOX *PTR = (GF_MOVIEFRAGMENTRANDOMACCESSOFFSETBOX *)S;

	ISOM_DECREASE_SIZE(PTR, 4);
	PTR->CONTAINER_SIZE = GF_BS_READ_U32(BS);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197565_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT MQTTCLIENT_WAITTYPE(MQTTCLIENT *CLIENT, VOID *PACKET_OBJ,
    BYTE WAIT_TYPE, WORD16 WAIT_PACKET_ID, INT TIMEOUT_MS)
{
    INT RC;
    WORD16 PACKET_ID;
    MQTTPACKETTYPE PACKET_TYPE;
#IFDEF WOLFMQTT_MULTITHREAD
    MQTTPENDRESP *PENDRESP;
    INT READLOCKED;
#ENDIF
    MQTTMSGSTAT* MMS_STAT;
    INT WAITMATCHFOUND;

    IF (CLIENT == NULL || PACKET_OBJ == NULL) {
        RETURN MQTT_CODE_ERROR_BAD_ARG;
    }

    /* ALL PACKET TYPE STRUCTURES MUST HAVE MQTTMSGSTAT AT TOP */
    MMS_STAT = (MQTTMSGSTAT*)PACKET_OBJ;

WAIT_AGAIN:

    /* INITIALIZE VARIABLES */
    PACKET_ID = 0;
    PACKET_TYPE = MQTT_PACKET_TYPE_RESERVED;
#IFDEF WOLFMQTT_MULTITHREAD
    PENDRESP = NULL;
    READLOCKED = 0;
#ENDIF
    WAITMATCHFOUND = 0;

#IFDEF WOLFMQTT_DEBUG_CLIENT
    PRINTF("MQTTCLIENT_WAITTYPE: TYPE %S (%D), ID %D",
        MQTTPACKET_TYPEDESC((MQTTPACKETTYPE)WAIT_TYPE),
            WAIT_TYPE, WAIT_PACKET_ID);
#ENDIF

    SWITCH ((INT)*MMS_STAT)
    {
        CASE MQTT_MSG_BEGIN:
        {
        #IFDEF WOLFMQTT_MULTITHREAD
            /* LOCK RECV SOCKET MUTEX */
            RC = WM_SEMLOCK(&CLIENT->LOCKRECV);
            IF (RC != 0) {
                PRINTF("MQTTCLIENT_WAITTYPE: RECV LOCK ERROR!");
                RETURN RC;
            }
            READLOCKED = 1;
        #ENDIF

            /* RESET THE PACKET STATE */
            CLIENT->PACKET.STAT = MQTT_PK_BEGIN;
        }
        FALL_THROUGH;

    #IFDEF WOLFMQTT_V5
        CASE MQTT_MSG_AUTH:
    #ENDIF
        CASE MQTT_MSG_WAIT:
        {
        #IFDEF WOLFMQTT_MULTITHREAD
            /* CHECK TO SEE IF PACKET TYPE AND ID HAVE ALREADY COMPLETED */
            PENDRESP = NULL;
            RC = WM_SEMLOCK(&CLIENT->LOCKCLIENT);
            IF (RC == 0) {
                IF (MQTTCLIENT_RESPLIST_FIND(CLIENT, (MQTTPACKETTYPE)WAIT_TYPE, 
                    WAIT_PACKET_ID, &PENDRESP)) {
                    IF (PENDRESP->PACKETDONE) {
                        /* PENDING RESPONSE IS ALREADY DONE, SO RETURN */
                        RC = PENDRESP->PACKET_RET;
                    #IFDEF WOLFMQTT_DEBUG_CLIENT
                        PRINTF("PENDRESP ALREADY DONE %P: RC %D", PENDRESP, RC);
                    #ENDIF
                        MQTTCLIENT_RESPLIST_REMOVE(CLIENT, PENDRESP);
                        WM_SEMUNLOCK(&CLIENT->LOCKCLIENT);
                        WM_SEMUNLOCK(&CLIENT->LOCKRECV);
                        RETURN RC;
                    }
                }
                WM_SEMUNLOCK(&CLIENT->LOCKCLIENT);
            }
            ELSE {
                BREAK; /* ERROR */
            }
        #ENDIF /* WOLFMQTT_MULTITHREAD */

            *MMS_STAT = MQTT_MSG_WAIT;

            /* WAIT FOR PACKET */
            RC = MQTTPACKET_READ(CLIENT, CLIENT->RX_BUF, CLIENT->RX_BUF_LEN,
                    TIMEOUT_MS);
            /* HANDLE FAILURE */
            IF (RC <= 0) {
                BREAK;
            }

            /* CAPTURE LENGTH READ */
            CLIENT->PACKET.BUF_LEN = RC;

            /* DECODE PACKET - GET TYPE AND ID */
            RC = MQTTCLIENT_DECODEPACKET(CLIENT, CLIENT->RX_BUF,
                CLIENT->PACKET.BUF_LEN, NULL, &PACKET_TYPE, NULL, &PACKET_ID);
            IF (RC < 0) {
                BREAK;
            }

        #IFDEF WOLFMQTT_DEBUG_CLIENT
            PRINTF("READ PACKET: LEN %D, TYPE %D, ID %D",
                CLIENT->PACKET.BUF_LEN, PACKET_TYPE, PACKET_ID);
        #ENDIF

            *MMS_STAT = MQTT_MSG_READ;
        }
        FALL_THROUGH;

        CASE MQTT_MSG_READ:
        CASE MQTT_MSG_READ_PAYLOAD:
        {
            MQTTPACKETTYPE USE_PACKET_TYPE;
            VOID* USE_PACKET_OBJ;

        #IFDEF WOLFMQTT_MULTITHREAD
            READLOCKED = 1; /* IF IN THIS STATE READ IS LOCKED */
        #ENDIF

            /* READ PAYLOAD STATE ONLY HAPPENS FOR PUBLISH MESSAGES */
            IF (*MMS_STAT == MQTT_MSG_READ_PAYLOAD) {
                PACKET_TYPE = MQTT_PACKET_TYPE_PUBLISH;
            }

            /* DETERMINE IF WE RECEIVED DATA FOR THIS REQUEST */
            IF ((WAIT_TYPE == MQTT_PACKET_TYPE_ANY ||
                 WAIT_TYPE == PACKET_TYPE ||
                 MQTTISPUBRESPPACKET(PACKET_TYPE) == MQTTISPUBRESPPACKET(WAIT_TYPE)) &&
               (WAIT_PACKET_ID == 0 || WAIT_PACKET_ID == PACKET_ID))
            {
                USE_PACKET_OBJ = PACKET_OBJ;
                WAITMATCHFOUND = 1;
            }
            ELSE {
                /* USE GENERIC PACKET OBJECT */
                USE_PACKET_OBJ = &CLIENT->MSG;
            }
            USE_PACKET_TYPE = PACKET_TYPE;

        #IFDEF WOLFMQTT_MULTITHREAD
            /* CHECK TO SEE IF WE HAVE A PENDING RESPONSE FOR THIS PACKET */
            PENDRESP = NULL;
            RC = WM_SEMLOCK(&CLIENT->LOCKCLIENT);
            IF (RC == 0) {
                IF (MQTTCLIENT_RESPLIST_FIND(CLIENT, PACKET_TYPE, PACKET_ID,
                                                               &PENDRESP)) {
                    /* WE FOUND PACKET MATCH THIS INCOMING READ PACKET */
                    PENDRESP->PACKETPROCESSING = 1;
                    USE_PACKET_OBJ = PENDRESP->PACKET_OBJ;
                    USE_PACKET_TYPE = PENDRESP->PACKET_TYPE;
                    /* REQ FROM ANOTHER THREAD... NOT A MATCH */
                    WAITMATCHFOUND = 0;
                }
                WM_SEMUNLOCK(&CLIENT->LOCKCLIENT);
            }
            ELSE {
                BREAK; /* ERROR */
            }
        #ENDIF /* WOLFMQTT_MULTITHREAD */

            /* PERFORM PACKET HANDLING FOR PUBLISH CALLBACK AND QOS */
            RC = MQTTCLIENT_HANDLEPACKET(CLIENT, USE_PACKET_TYPE,
                USE_PACKET_OBJ, TIMEOUT_MS);

        #IFDEF WOLFMQTT_NONBLOCK
            IF (RC == MQTT_CODE_CONTINUE) {
                /* WE HAVE RECEIVED SOME DATA, SO KEEP THE RECV
                    MUTEX LOCK ACTIVE AND RETURN */
                RETURN RC;
            }
        #ENDIF

            /* HANDLE SUCCESS CASE */
            IF (RC >= 0) {
                RC = MQTT_CODE_SUCCESS;
            }

        #IFDEF WOLFMQTT_MULTITHREAD
            IF (PENDRESP) {
                /* MARK PENDING RESPONSE ENTRY DONE */
                IF (WM_SEMLOCK(&CLIENT->LOCKCLIENT) == 0) {
                    PENDRESP->PACKETDONE = 1;
                    PENDRESP->PACKET_RET = RC;
                #IFDEF WOLFMQTT_DEBUG_CLIENT
                    PRINTF("PENDRESP DONE %P", PENDRESP);
                #ENDIF
                    PENDRESP = NULL;
                    WM_SEMUNLOCK(&CLIENT->LOCKCLIENT);
                }
            }
        #ENDIF /* WOLFMQTT_MULTITHREAD */
            BREAK;
        }

        CASE MQTT_MSG_WRITE:
        CASE MQTT_MSG_WRITE_PAYLOAD:
        DEFAULT:
        {
        #IFDEF WOLFMQTT_DEBUG_CLIENT
            PRINTF("MQTTCLIENT_WAITTYPE: INVALID STATE %D!", *MMS_STAT);
        #ENDIF
            RC = MQTT_CODE_ERROR_STAT;
            BREAK;
        }
    } /* SWITCH (*MMS_STAT) */

#IFDEF WOLFMQTT_NONBLOCK
    IF (RC != MQTT_CODE_CONTINUE)
#ENDIF
    {
        /* RESET STATE */
        *MMS_STAT = MQTT_MSG_BEGIN;
    }

#IFDEF WOLFMQTT_MULTITHREAD
    IF (READLOCKED) {
        WM_SEMUNLOCK(&CLIENT->LOCKRECV);
    }
#ENDIF
    IF (RC < 0) {
    #IFDEF WOLFMQTT_DEBUG_CLIENT
        PRINTF("MQTTCLIENT_WAITTYPE: FAILURE: %S (%D)",
            MQTTCLIENT_RETURNCODETOSTRING(RC), RC);
    #ENDIF
        RETURN RC;
    }

    IF (!WAITMATCHFOUND) {
        /* IF WE GET HERE, THEN THE WE ARE STILL WAITING FOR A PACKET */
        GOTO WAIT_AGAIN;
    }

    RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208912_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GETCMDLINE_INT(
    INT		FIRSTC,
    LONG	COUNT UNUSED,	// ONLY USED FOR INCREMENTAL SEARCH
    INT		INDENT,		// INDENT FOR INSIDE CONDITIONALS
    INT		CLEAR_CCLINE)	// CLEAR CCLINE FIRST
{
    STATIC INT	DEPTH = 0;	    // CALL DEPTH
    INT		C;
    INT		I;
    INT		J;
    INT		GOTESC = FALSE;		// TRUE WHEN <ESC> JUST TYPED
    INT		DO_ABBR;		// WHEN TRUE CHECK FOR ABBR.
    CHAR_U	*LOOKFOR = NULL;	// STRING TO MATCH
    INT		HISCNT;			// CURRENT HISTORY LINE IN USE
    INT		HISTYPE;		// HISTORY TYPE TO BE USED
#IFDEF FEAT_SEARCH_EXTRA
    INCSEARCH_STATE_T	IS_STATE;
#ENDIF
    INT		DID_WILD_LIST = FALSE;	// DID WILD_LIST() RECENTLY
    INT		WIM_INDEX = 0;		// INDEX IN WIM_FLAGS[]
    INT		RES;
    INT		SAVE_MSG_SCROLL = MSG_SCROLL;
    INT		SAVE_STATE = STATE;	// REMEMBER STATE WHEN CALLED
    INT		SOME_KEY_TYPED = FALSE;	// ONE OF THE KEYS WAS TYPED
    // MOUSE DRAG AND RELEASE EVENTS ARE IGNORED, UNLESS THEY ARE
    // PRECEDED WITH A MOUSE DOWN EVENT
    INT		IGNORE_DRAG_RELEASE = TRUE;
#IFDEF FEAT_EVAL
    INT		BREAK_CTRL_C = FALSE;
#ENDIF
    EXPAND_T	XPC;
    LONG	*B_IM_PTR = NULL;
    CMDLINE_INFO_T SAVE_CCLINE;
    INT		DID_SAVE_CCLINE = FALSE;
    INT		CMDLINE_TYPE;
    INT		WILD_TYPE;

    // ONE RECURSION LEVEL DEEPER
    ++DEPTH;

    IF (CCLINE.CMDBUFF != NULL)
    {
	// BEING CALLED RECURSIVELY.  SINCE CCLINE IS GLOBAL, WE NEED TO SAVE
	// THE CURRENT BUFFER AND RESTORE IT WHEN RETURNING.
	SAVE_CMDLINE(&SAVE_CCLINE);
	DID_SAVE_CCLINE = TRUE;
    }
    IF (CLEAR_CCLINE)
	CLEAR_FIELD(CCLINE);

#IFDEF FEAT_EVAL
    IF (FIRSTC == -1)
    {
	FIRSTC = NUL;
	BREAK_CTRL_C = TRUE;
    }
#ENDIF
#IFDEF FEAT_RIGHTLEFT
    // START WITHOUT HEBREW MAPPING FOR A COMMAND LINE
    IF (FIRSTC == ':' || FIRSTC == '=' || FIRSTC == '>')
	CMD_HKMAP = 0;
#ENDIF

#IFDEF FEAT_SEARCH_EXTRA
    INIT_INCSEARCH_STATE(&IS_STATE);
#ENDIF

    IF (INIT_CCLINE(FIRSTC, INDENT) != OK)
	GOTO THEEND;	// OUT OF MEMORY

    IF (DEPTH == 50)
    {
	// SOMEHOW GOT INTO A LOOP RECURSIVELY CALLING GETCMDLINE(), BAIL OUT.
	EMSG(_(E_COMMAND_TOO_RECURSIVE));
	GOTO THEEND;
    }

    EXPANDINIT(&XPC);
    CCLINE.XPC = &XPC;

#IFDEF FEAT_RIGHTLEFT
    IF (CURWIN->W_P_RL && *CURWIN->W_P_RLC == 'S'
					  && (FIRSTC == '/' || FIRSTC == '?'))
	CMDMSG_RL = TRUE;
    ELSE
	CMDMSG_RL = FALSE;
#ENDIF

    REDIR_OFF = TRUE;		// DON'T REDIRECT THE TYPED COMMAND
    IF (!CMD_SILENT)
    {
	I = MSG_SCROLLED;
	MSG_SCROLLED = 0;		// AVOID WAIT_RETURN() MESSAGE
	GOTOCMDLINE(TRUE);
	MSG_SCROLLED += I;
	REDRAWCMDPROMPT();		// DRAW PROMPT OR INDENT
	SET_CMDSPOS();
    }
    XPC.XP_CONTEXT = EXPAND_NOTHING;
    XPC.XP_BACKSLASH = XP_BS_NONE;
#IFNDEF BACKSLASH_IN_FILENAME
    XPC.XP_SHELL = FALSE;
#ENDIF

#IF DEFINED(FEAT_EVAL)
    IF (CCLINE.INPUT_FN)
    {
	XPC.XP_CONTEXT = CCLINE.XP_CONTEXT;
	XPC.XP_PATTERN = CCLINE.CMDBUFF;
	XPC.XP_ARG = CCLINE.XP_ARG;
    }
#ENDIF

    /*
     * AVOID SCROLLING WHEN CALLED BY A RECURSIVE DO_CMDLINE(), E.G. WHEN
     * DOING ":@0" WHEN REGISTER 0 DOESN'T CONTAIN A CR.
     */
    MSG_SCROLL = FALSE;

    STATE = MODE_CMDLINE;

    IF (FIRSTC == '/' || FIRSTC == '?' || FIRSTC == '@')
    {
	// USE ":LMAP" MAPPINGS FOR SEARCH PATTERN AND INPUT().
	IF (CURBUF->B_P_IMSEARCH == B_IMODE_USE_INSERT)
	    B_IM_PTR = &CURBUF->B_P_IMINSERT;
	ELSE
	    B_IM_PTR = &CURBUF->B_P_IMSEARCH;
	IF (*B_IM_PTR == B_IMODE_LMAP)
	    STATE |= MODE_LANGMAP;
#IFDEF HAVE_INPUT_METHOD
	IM_SET_ACTIVE(*B_IM_PTR == B_IMODE_IM);
#ENDIF
    }
#IFDEF HAVE_INPUT_METHOD
    ELSE IF (P_IMCMDLINE)
	IM_SET_ACTIVE(TRUE);
#ENDIF

    SETMOUSE();
#IFDEF CURSOR_SHAPE
    UI_CURSOR_SHAPE();		// MAY SHOW DIFFERENT CURSOR SHAPE
#ENDIF

    // WHEN INSIDE AN AUTOCOMMAND FOR WRITING "EXITING" MAY BE SET AND
    // TERMINAL MODE SET TO COOKED.  NEED TO SET RAW MODE HERE THEN.
    SETTMODE(TMODE_RAW);

    // TRIGGER CMDLINEENTER AUTOCOMMANDS.
    CMDLINE_TYPE = FIRSTC == NUL ? '-' : FIRSTC;
    TRIGGER_CMD_AUTOCMD(CMDLINE_TYPE, EVENT_CMDLINEENTER);
#IFDEF FEAT_EVAL
    IF (!DEBUG_MODE)
	MAY_TRIGGER_MODECHANGED();
#ENDIF

    INIT_HISTORY();
    HISCNT = GET_HISLEN();	// SET HISCNT TO IMPOSSIBLE HISTORY VALUE
    HISTYPE = HIST_CHAR2TYPE(FIRSTC);

#IFDEF FEAT_DIGRAPHS
    DO_DIGRAPH(-1);		// INIT DIGRAPH TYPEAHEAD
#ENDIF

    // IF SOMETHING ABOVE CAUSED AN ERROR, RESET THE FLAGS, WE DO WANT TO TYPE
    // AND EXECUTE COMMANDS. DISPLAY MAY BE MESSED UP A BIT.
    IF (DID_EMSG)
	REDRAWCMD();

#IFDEF FEAT_STL_OPT
    // REDRAW THE STATUSLINE IN CASE IT USES THE CURRENT MODE USING THE MODE()
    // FUNCTION.
    IF (!CMD_SILENT && MSG_SCROLLED == 0)
    {
	INT	FOUND_ONE = FALSE;
	WIN_T	*WP;

	FOR_ALL_WINDOWS(WP)
	    IF (*P_STL != NUL || *WP->W_P_STL != NUL)
	    {
		WP->W_REDR_STATUS = TRUE;
		FOUND_ONE = TRUE;
	    }

	IF (*P_TAL != NUL)
	{
	    REDRAW_TABLINE = TRUE;
	    FOUND_ONE = TRUE;
	}

	IF (FOUND_ONE)
	    REDRAW_STATUSLINES();
    }
#ENDIF

    DID_EMSG = FALSE;
    GOT_INT = FALSE;

    /*
     * COLLECT THE COMMAND STRING, HANDLING EDITING KEYS.
     */
    FOR (;;)
    {
	INT TRIGGER_CMDLINECHANGED = TRUE;
	INT END_WILDMENU;

	REDIR_OFF = TRUE;	// DON'T REDIRECT THE TYPED COMMAND.
				// REPEATED, BECAUSE A ":REDIR" INSIDE
				// COMPLETION MAY SWITCH IT ON.
#IFDEF USE_ON_FLY_SCROLL
	DONT_SCROLL = FALSE;	// ALLOW SCROLLING HERE
#ENDIF
	QUIT_MORE = FALSE;	// RESET AFTER CTRL-D WHICH HAD A MORE-PROMPT

	DID_EMSG = FALSE;	// THERE CAN'T REALLY BE A REASON WHY AN ERROR
				// THAT OCCURS WHILE TYPING A COMMAND SHOULD
				// CAUSE THE COMMAND NOT TO BE EXECUTED.

	// TRIGGER SAFESTATE IF NOTHING IS PENDING.
	MAY_TRIGGER_SAFESTATE(XPC.XP_NUMFILES <= 0);

	// GET A CHARACTER.  IGNORE K_IGNORE AND K_NOP, THEY SHOULD NOT DO
	// ANYTHING, SUCH AS STOP COMPLETION.
	DO
	{
	    CURSORCMD();		// SET THE CURSOR ON THE RIGHT SPOT
	    C = SAFE_VGETC();
	} WHILE (C == K_IGNORE || C == K_NOP);

	IF (C == K_COMMAND || C == K_SCRIPT_COMMAND)
	{
	    INT	    CLEN = CCLINE.CMDLEN;

	    IF (DO_CMDKEY_COMMAND(C, DOCMD_NOWAIT) == OK)
	    {
		IF (CLEN == CCLINE.CMDLEN)
		    TRIGGER_CMDLINECHANGED = FALSE;
		GOTO CMDLINE_CHANGED;
	    }
	}

	IF (KEYTYPED)
	{
	    SOME_KEY_TYPED = TRUE;
#IFDEF FEAT_RIGHTLEFT
	    IF (CMD_HKMAP)
		C = HKMAP(C);
	    IF (CMDMSG_RL && !KEYSTUFFED)
	    {
		// INVERT HORIZONTAL MOVEMENTS AND OPERATIONS.  ONLY WHEN
		// TYPED BY THE USER DIRECTLY, NOT WHEN THE RESULT OF A
		// MAPPING.
		SWITCH (C)
		{
		    CASE K_RIGHT:   C = K_LEFT; BREAK;
		    CASE K_S_RIGHT: C = K_S_LEFT; BREAK;
		    CASE K_C_RIGHT: C = K_C_LEFT; BREAK;
		    CASE K_LEFT:    C = K_RIGHT; BREAK;
		    CASE K_S_LEFT:  C = K_S_RIGHT; BREAK;
		    CASE K_C_LEFT:  C = K_C_RIGHT; BREAK;
		}
	    }
#ENDIF
	}

	/*
	 * IGNORE GOT_INT WHEN CTRL-C WAS TYPED HERE.
	 * DON'T IGNORE IT IN :GLOBAL, WE REALLY NEED TO BREAK THEN, E.G., FOR
	 * ":G/PAT/NORMAL /PAT" (WITHOUT THE <CR>).
	 * DON'T IGNORE IT FOR THE INPUT() FUNCTION.
	 */
	IF ((C == CTRL_C
#IFDEF UNIX
		|| C == INTR_CHAR
#ENDIF
				)
#IF DEFINED(FEAT_EVAL) || DEFINED(FEAT_CRYPT)
		&& FIRSTC != '@'
#ENDIF
#IFDEF FEAT_EVAL
		// DO CLEAR GOT_INT IN EX MODE TO AVOID INFINITE CTRL-C LOOP
		&& (!BREAK_CTRL_C || EXMODE_ACTIVE)
#ENDIF
		&& !GLOBAL_BUSY)
	    GOT_INT = FALSE;

	// FREE OLD COMMAND LINE WHEN FINISHED MOVING AROUND IN THE HISTORY
	// LIST
	IF (LOOKFOR != NULL
		&& C != K_S_DOWN && C != K_S_UP
		&& C != K_DOWN && C != K_UP
		&& C != K_PAGEDOWN && C != K_PAGEUP
		&& C != K_KPAGEDOWN && C != K_KPAGEUP
		&& C != K_LEFT && C != K_RIGHT
		&& (XPC.XP_NUMFILES > 0 || (C != CTRL_P && C != CTRL_N)))
	    VIM_CLEAR(LOOKFOR);

	/*
	 * WHEN THERE ARE MATCHING COMPLETIONS TO SELECT <S-TAB> WORKS LIKE
	 * CTRL-P (UNLESS 'WC' IS <S-TAB>).
	 */
	IF (C != P_WC && C == K_S_TAB && XPC.XP_NUMFILES > 0)
	    C = CTRL_P;

	IF (P_WMNU)
	    C = WILDMENU_TRANSLATE_KEY(&CCLINE, C, &XPC, DID_WILD_LIST);

	IF (CMDLINE_PUM_ACTIVE())
	{
	    // CTRL-Y: ACCEPT THE CURRENT SELECTION AND CLOSE THE POPUP MENU.
	    // CTRL-E: CANCEL THE CMDLINE POPUP MENU AND RETURN THE ORIGINAL
	    // TEXT.
	    IF (C == CTRL_E || C == CTRL_Y)
	    {
		WILD_TYPE = (C == CTRL_E) ? WILD_CANCEL : WILD_APPLY;
		IF (NEXTWILD(&XPC, WILD_TYPE, WILD_NO_BEEP,
							FIRSTC != '@') == FAIL)
		    BREAK;
		C = CTRL_E;
	    }
	}

	// THE WILDMENU IS CLEARED IF THE PRESSED KEY IS NOT USED FOR
	// NAVIGATING THE WILD MENU (I.E. THE KEY IS NOT 'WILDCHAR' OR
	// 'WILDCHARM' OR CTRL-N OR CTRL-P OR CTRL-A OR CTRL-L).
	// IF THE POPUP MENU IS DISPLAYED, THEN PAGEDOWN AND PAGEUP KEYS ARE
	// ALSO USED TO NAVIGATE THE MENU.
	END_WILDMENU = (!(C == P_WC && KEYTYPED) && C != P_WCM
		&& C != CTRL_N && C != CTRL_P && C != CTRL_A && C != CTRL_L);
	END_WILDMENU = END_WILDMENU && (!CMDLINE_PUM_ACTIVE() ||
			    (C != K_PAGEDOWN && C != K_PAGEUP
			     && C != K_KPAGEDOWN && C != K_KPAGEUP));

	// FREE EXPANDED NAMES WHEN FINISHED WALKING THROUGH MATCHES
	IF (END_WILDMENU)
	{
	    IF (CMDLINE_PUM_ACTIVE())
		CMDLINE_PUM_REMOVE();
	    IF (XPC.XP_NUMFILES != -1)
		(VOID)EXPANDONE(&XPC, NULL, NULL, 0, WILD_FREE);
	    DID_WILD_LIST = FALSE;
	    IF (!P_WMNU || (C != K_UP && C != K_DOWN))
		XPC.XP_CONTEXT = EXPAND_NOTHING;
	    WIM_INDEX = 0;
	    WILDMENU_CLEANUP(&CCLINE);
	}

	IF (P_WMNU)
	    C = WILDMENU_PROCESS_KEY(&CCLINE, C, &XPC);

	// CTRL-\ CTRL-N GOES TO NORMAL MODE, CTRL-\ CTRL-G GOES TO INSERT
	// MODE WHEN 'INSERTMODE' IS SET, CTRL-\ E PROMPTS FOR AN EXPRESSION.
	IF (C == CTRL_BSL)
	{
	    RES = CMDLINE_HANDLE_BACKSLASH_KEY(C, &GOTESC);
	    IF (RES == CMDLINE_CHANGED)
		GOTO CMDLINE_CHANGED;
	    ELSE IF (RES == CMDLINE_NOT_CHANGED)
		GOTO CMDLINE_NOT_CHANGED;
	    ELSE IF (RES == GOTO_NORMAL_MODE)
		GOTO RETURNCMD;		// BACK TO CMD MODE
	    C = CTRL_BSL;		// BACKSLASH KEY NOT PROCESSED BY
					// CMDLINE_HANDLE_BACKSLASH_KEY()
	}

#IFDEF FEAT_CMDWIN
	IF (C == CEDIT_KEY || C == K_CMDWIN)
	{
	    // TODO: WHY IS EX_NORMAL_BUSY CHECKED HERE?
	    IF ((C == K_CMDWIN || EX_NORMAL_BUSY == 0) && GOT_INT == FALSE)
	    {
		/*
		 * OPEN A WINDOW TO EDIT THE COMMAND LINE (AND HISTORY).
		 */
		C = OPEN_CMDWIN();
		SOME_KEY_TYPED = TRUE;
	    }
	}
# IFDEF FEAT_DIGRAPHS
	ELSE
# ENDIF
#ENDIF
#IFDEF FEAT_DIGRAPHS
	    C = DO_DIGRAPH(C);
#ENDIF

	IF (C == '\N' || C == '\R' || C == K_KENTER || (C == ESC
			&& (!KEYTYPED || VIM_STRCHR(P_CPO, CPO_ESC) != NULL)))
	{
	    // IN EX MODE A BACKSLASH ESCAPES A NEWLINE.
	    IF (EXMODE_ACTIVE
		    && C != ESC
		    && CCLINE.CMDPOS == CCLINE.CMDLEN
		    && CCLINE.CMDPOS > 0
		    && CCLINE.CMDBUFF[CCLINE.CMDPOS - 1] == '\\')
	    {
		IF (C == K_KENTER)
		    C = '\N';
	    }
	    ELSE
	    {
		GOTESC = FALSE;	// MIGHT HAVE TYPED ESC PREVIOUSLY, DON'T
				// TRUNCATE THE CMDLINE NOW.
		IF (CCHECK_ABBR(C + ABBR_OFF))
		    GOTO CMDLINE_CHANGED;
		IF (!CMD_SILENT)
		{
		    WINDGOTO(MSG_ROW, 0);
		    OUT_FLUSH();
		}
		BREAK;
	    }
	}

	// COMPLETION FOR 'WILDCHAR' OR 'WILDCHARM' KEY.
	IF ((C == P_WC && !GOTESC && KEYTYPED) || C == P_WCM)
	{
	    RES = CMDLINE_WILDCHAR_COMPLETE(C, FIRSTC != '@', &DID_WILD_LIST,
		    &WIM_INDEX, &XPC, &GOTESC);
	    IF (RES == CMDLINE_CHANGED)
		GOTO CMDLINE_CHANGED;
	}

	GOTESC = FALSE;

	// <S-TAB> GOES TO LAST MATCH, IN A CLUMSY WAY
	IF (C == K_S_TAB && KEYTYPED)
	{
	    IF (NEXTWILD(&XPC, WILD_EXPAND_KEEP, 0, FIRSTC != '@') == OK)
	    {
		IF (XPC.XP_NUMFILES > 1
		    && ((!DID_WILD_LIST && (WIM_FLAGS[WIM_INDEX] & WIM_LIST))
			    || P_WMNU))
		{
		    // TRIGGER THE POPUP MENU WHEN WILDOPTIONS=PUM
		    SHOWMATCHES(&XPC, P_WMNU
			    && ((WIM_FLAGS[WIM_INDEX] & WIM_LIST) == 0));
		}
		IF (NEXTWILD(&XPC, WILD_PREV, 0, FIRSTC != '@') == OK
			&& NEXTWILD(&XPC, WILD_PREV, 0, FIRSTC != '@') == OK)
		    GOTO CMDLINE_CHANGED;
	    }
	}

	IF (C == NUL || C == K_ZERO)	    // NUL IS STORED AS NL
	    C = NL;

	DO_ABBR = TRUE;		// DEFAULT: CHECK FOR ABBREVIATION

	/*
	 * BIG SWITCH FOR A TYPED COMMAND LINE CHARACTER.
	 */
	SWITCH (C)
	{
	CASE K_BS:
	CASE CTRL_H:
	CASE K_DEL:
	CASE K_KDEL:
	CASE CTRL_W:
	    RES = CMDLINE_ERASE_CHARS(C, INDENT
#IFDEF FEAT_SEARCH_EXTRA
		    , &IS_STATE
#ENDIF
		    );
	    IF (RES == CMDLINE_NOT_CHANGED)
		GOTO CMDLINE_NOT_CHANGED;
	    ELSE IF (RES == GOTO_NORMAL_MODE)
		GOTO RETURNCMD;		// BACK TO CMD MODE
	    GOTO CMDLINE_CHANGED;

	CASE K_INS:
	CASE K_KINS:
		CCLINE.OVERSTRIKE = !CCLINE.OVERSTRIKE;
#IFDEF CURSOR_SHAPE
		UI_CURSOR_SHAPE();	// MAY SHOW DIFFERENT CURSOR SHAPE
#ENDIF
		GOTO CMDLINE_NOT_CHANGED;

	CASE CTRL_HAT:
		CMDLINE_TOGGLE_LANGMAP(B_IM_PTR);
		GOTO CMDLINE_NOT_CHANGED;

//	CASE '@':   ONLY IN VERY OLD VI
	CASE CTRL_U:
		// DELETE ALL CHARACTERS LEFT OF THE CURSOR
		J = CCLINE.CMDPOS;
		CCLINE.CMDLEN -= J;
		I = CCLINE.CMDPOS = 0;
		WHILE (I < CCLINE.CMDLEN)
		    CCLINE.CMDBUFF[I++] = CCLINE.CMDBUFF[J++];
		// TRUNCATE AT THE END, REQUIRED FOR MULTI-BYTE CHARS.
		CCLINE.CMDBUFF[CCLINE.CMDLEN] = NUL;
#IFDEF FEAT_SEARCH_EXTRA
		IF (CCLINE.CMDLEN == 0)
		    IS_STATE.SEARCH_START = IS_STATE.SAVE_CURSOR;
#ENDIF
		REDRAWCMD();
		GOTO CMDLINE_CHANGED;

#IFDEF FEAT_CLIPBOARD
	CASE CTRL_Y:
		// COPY THE MODELESS SELECTION, IF THERE IS ONE.
		IF (CLIP_STAR.STATE != SELECT_CLEARED)
		{
		    IF (CLIP_STAR.STATE == SELECT_DONE)
			CLIP_COPY_MODELESS_SELECTION(TRUE);
		    GOTO CMDLINE_NOT_CHANGED;
		}
		BREAK;
#ENDIF

	CASE ESC:	// GET HERE IF P_WC != ESC OR WHEN ESC TYPED TWICE
	CASE CTRL_C:
		// IN EXMODE IT DOESN'T MAKE SENSE TO RETURN.  EXCEPT WHEN
		// ":NORMAL" RUNS OUT OF CHARACTERS.
		IF (EXMODE_ACTIVE
			       && (EX_NORMAL_BUSY == 0 || TYPEBUF.TB_LEN > 0))
		    GOTO CMDLINE_NOT_CHANGED;

		GOTESC = TRUE;		// WILL FREE CCLINE.CMDBUFF AFTER
					// PUTTING IT IN HISTORY
		GOTO RETURNCMD;		// BACK TO CMD MODE

	CASE CTRL_R:			// INSERT REGISTER
		RES = CMDLINE_INSERT_REG(&GOTESC);
		IF (RES == CMDLINE_NOT_CHANGED)
		    GOTO CMDLINE_NOT_CHANGED;
		ELSE IF (RES == GOTO_NORMAL_MODE)
		    GOTO RETURNCMD;
		GOTO CMDLINE_CHANGED;

	CASE CTRL_D:
		IF (SHOWMATCHES(&XPC, FALSE) == EXPAND_NOTHING)
		    BREAK;	// USE ^D AS NORMAL CHAR INSTEAD

		REDRAWCMD();
		CONTINUE;	// DON'T DO INCREMENTAL SEARCH NOW

	CASE K_RIGHT:
	CASE K_S_RIGHT:
	CASE K_C_RIGHT:
		DO
		{
		    IF (CCLINE.CMDPOS >= CCLINE.CMDLEN)
			BREAK;
		    I = CMDLINE_CHARSIZE(CCLINE.CMDPOS);
		    IF (KEYTYPED && CCLINE.CMDSPOS + I >= COLUMNS * ROWS)
			BREAK;
		    CCLINE.CMDSPOS += I;
		    IF (HAS_MBYTE)
			CCLINE.CMDPOS += (*MB_PTR2LEN)(CCLINE.CMDBUFF
							     + CCLINE.CMDPOS);
		    ELSE
			++CCLINE.CMDPOS;
		}
		WHILE ((C == K_S_RIGHT || C == K_C_RIGHT
			       || (MOD_MASK & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))
			&& CCLINE.CMDBUFF[CCLINE.CMDPOS] != ' ');
		IF (HAS_MBYTE)
		    SET_CMDSPOS_CURSOR();
		GOTO CMDLINE_NOT_CHANGED;

	CASE K_LEFT:
	CASE K_S_LEFT:
	CASE K_C_LEFT:
		IF (CCLINE.CMDPOS == 0)
		    GOTO CMDLINE_NOT_CHANGED;
		DO
		{
		    --CCLINE.CMDPOS;
		    IF (HAS_MBYTE)	// MOVE TO FIRST BYTE OF CHAR
			CCLINE.CMDPOS -= (*MB_HEAD_OFF)(CCLINE.CMDBUFF,
					      CCLINE.CMDBUFF + CCLINE.CMDPOS);
		    CCLINE.CMDSPOS -= CMDLINE_CHARSIZE(CCLINE.CMDPOS);
		}
		WHILE (CCLINE.CMDPOS > 0
			&& (C == K_S_LEFT || C == K_C_LEFT
			       || (MOD_MASK & (MOD_MASK_SHIFT|MOD_MASK_CTRL)))
			&& CCLINE.CMDBUFF[CCLINE.CMDPOS - 1] != ' ');
		IF (HAS_MBYTE)
		    SET_CMDSPOS_CURSOR();
		GOTO CMDLINE_NOT_CHANGED;

	CASE K_IGNORE:
		// IGNORE MOUSE EVENT OR OPEN_CMDWIN() RESULT.
		GOTO CMDLINE_NOT_CHANGED;

#IFDEF FEAT_GUI_MSWIN
	    // ON MS-WINDOWS IGNORE <M-F4>, WE GET IT WHEN CLOSING THE WINDOW
	    // WAS CANCELLED.
	CASE K_F4:
	    IF (MOD_MASK == MOD_MASK_ALT)
	    {
		REDRAWCMD();	    // SOMEHOW THE CMDLINE IS CLEARED
		GOTO CMDLINE_NOT_CHANGED;
	    }
	    BREAK;
#ENDIF

	CASE K_MIDDLEDRAG:
	CASE K_MIDDLERELEASE:
		GOTO CMDLINE_NOT_CHANGED;	// IGNORE MOUSE

	CASE K_MIDDLEMOUSE:
# IFDEF FEAT_GUI
		// WHEN GUI IS ACTIVE, ALSO PASTE WHEN 'MOUSE' IS EMPTY
		IF (!GUI.IN_USE)
# ENDIF
		    IF (!MOUSE_HAS(MOUSE_COMMAND))
			GOTO CMDLINE_NOT_CHANGED;   // IGNORE MOUSE
# IFDEF FEAT_CLIPBOARD
		IF (CLIP_STAR.AVAILABLE)
		    CMDLINE_PASTE('*', TRUE, TRUE);
		ELSE
# ENDIF
		    CMDLINE_PASTE(0, TRUE, TRUE);
		REDRAWCMD();
		GOTO CMDLINE_CHANGED;

# IFDEF FEAT_DND
	CASE K_DROP:
		CMDLINE_PASTE('~', TRUE, FALSE);
		REDRAWCMD();
		GOTO CMDLINE_CHANGED;
# ENDIF

	CASE K_LEFTDRAG:
	CASE K_LEFTRELEASE:
	CASE K_RIGHTDRAG:
	CASE K_RIGHTRELEASE:
		// IGNORE DRAG AND RELEASE EVENTS WHEN THE BUTTON-DOWN WASN'T
		// SEEN BEFORE.
		IF (IGNORE_DRAG_RELEASE)
		    GOTO CMDLINE_NOT_CHANGED;
		// FALLTHROUGH
	CASE K_LEFTMOUSE:
	CASE K_RIGHTMOUSE:
		CMDLINE_LEFT_RIGHT_MOUSE(C, &IGNORE_DRAG_RELEASE);
		GOTO CMDLINE_NOT_CHANGED;

	// MOUSE SCROLL WHEEL: IGNORED HERE
	CASE K_MOUSEDOWN:
	CASE K_MOUSEUP:
	CASE K_MOUSELEFT:
	CASE K_MOUSERIGHT:
	// ALTERNATE BUTTONS IGNORED HERE
	CASE K_X1MOUSE:
	CASE K_X1DRAG:
	CASE K_X1RELEASE:
	CASE K_X2MOUSE:
	CASE K_X2DRAG:
	CASE K_X2RELEASE:
	CASE K_MOUSEMOVE:
		GOTO CMDLINE_NOT_CHANGED;

#IFDEF FEAT_GUI
	CASE K_LEFTMOUSE_NM:	// MOUSEFOCUS CLICK, IGNORED
	CASE K_LEFTRELEASE_NM:
		GOTO CMDLINE_NOT_CHANGED;

	CASE K_VER_SCROLLBAR:
		IF (MSG_SCROLLED == 0)
		{
		    GUI_DO_SCROLL();
		    REDRAWCMD();
		}
		GOTO CMDLINE_NOT_CHANGED;

	CASE K_HOR_SCROLLBAR:
		IF (MSG_SCROLLED == 0)
		{
		    GUI_DO_HORIZ_SCROLL(SCROLLBAR_VALUE, FALSE);
		    REDRAWCMD();
		}
		GOTO CMDLINE_NOT_CHANGED;
#ENDIF
#IFDEF FEAT_GUI_TABLINE
	CASE K_TABLINE:
	CASE K_TABMENU:
		// DON'T WANT TO CHANGE ANY TABS HERE.  MAKE SURE THE SAME TAB
		// IS STILL SELECTED.
		IF (GUI_USE_TABLINE())
		    GUI_MCH_SET_CURTAB(TABPAGE_INDEX(CURTAB));
		GOTO CMDLINE_NOT_CHANGED;
#ENDIF

	CASE K_SELECT:	    // END OF SELECT MODE MAPPING - IGNORE
		GOTO CMDLINE_NOT_CHANGED;

	CASE CTRL_B:	    // BEGIN OF COMMAND LINE
	CASE K_HOME:
	CASE K_KHOME:
	CASE K_S_HOME:
	CASE K_C_HOME:
		CCLINE.CMDPOS = 0;
		SET_CMDSPOS();
		GOTO CMDLINE_NOT_CHANGED;

	CASE CTRL_E:	    // END OF COMMAND LINE
	CASE K_END:
	CASE K_KEND:
	CASE K_S_END:
	CASE K_C_END:
		CCLINE.CMDPOS = CCLINE.CMDLEN;
		SET_CMDSPOS_CURSOR();
		GOTO CMDLINE_NOT_CHANGED;

	CASE CTRL_A:	    // ALL MATCHES
		IF (CMDLINE_PUM_ACTIVE())
		    // AS CTRL-A COMPLETES ALL THE MATCHES, CLOSE THE POPUP
		    // MENU (IF PRESENT)
		    CMDLINE_PUM_CLEANUP(&CCLINE);

		IF (NEXTWILD(&XPC, WILD_ALL, 0, FIRSTC != '@') == FAIL)
		    BREAK;
		XPC.XP_CONTEXT = EXPAND_NOTHING;
		DID_WILD_LIST = FALSE;
		GOTO CMDLINE_CHANGED;

	CASE CTRL_L:
#IFDEF FEAT_SEARCH_EXTRA
		IF (MAY_ADD_CHAR_TO_SEARCH(FIRSTC, &C, &IS_STATE) == OK)
		    GOTO CMDLINE_NOT_CHANGED;
#ENDIF

		// COMPLETION: LONGEST COMMON PART
		IF (NEXTWILD(&XPC, WILD_LONGEST, 0, FIRSTC != '@') == FAIL)
		    BREAK;
		GOTO CMDLINE_CHANGED;

	CASE CTRL_N:	    // NEXT MATCH
	CASE CTRL_P:	    // PREVIOUS MATCH
		IF (XPC.XP_NUMFILES > 0)
		{
		    WILD_TYPE = (C == CTRL_P) ? WILD_PREV : WILD_NEXT;
		    IF (NEXTWILD(&XPC, WILD_TYPE, 0, FIRSTC != '@') == FAIL)
			BREAK;
		    GOTO CMDLINE_NOT_CHANGED;
		}
		// FALLTHROUGH
	CASE K_UP:
	CASE K_DOWN:
	CASE K_S_UP:
	CASE K_S_DOWN:
	CASE K_PAGEUP:
	CASE K_KPAGEUP:
	CASE K_PAGEDOWN:
	CASE K_KPAGEDOWN:
		IF (CMDLINE_PUM_ACTIVE()
			&& (C == K_PAGEUP || C == K_PAGEDOWN ||
			    C == K_KPAGEUP || C == K_KPAGEDOWN))
		{
		    // IF THE POPUP MENU IS DISPLAYED, THEN PAGEUP AND PAGEDOWN
		    // ARE USED TO SCROLL THE MENU.
		    WILD_TYPE = WILD_PAGEUP;
		    IF (C == K_PAGEDOWN || C == K_KPAGEDOWN)
			WILD_TYPE = WILD_PAGEDOWN;
		    IF (NEXTWILD(&XPC, WILD_TYPE, 0, FIRSTC != '@') == FAIL)
			BREAK;
		    GOTO CMDLINE_NOT_CHANGED;
		}
		ELSE
		{
		    RES = CMDLINE_BROWSE_HISTORY(C, FIRSTC, &LOOKFOR, HISTYPE,
			    &HISCNT, &XPC);
		    IF (RES == CMDLINE_CHANGED)
			GOTO CMDLINE_CHANGED;
		    ELSE IF (RES == GOTO_NORMAL_MODE)
			GOTO RETURNCMD;
		}
		GOTO CMDLINE_NOT_CHANGED;

#IFDEF FEAT_SEARCH_EXTRA
	CASE CTRL_G:	    // NEXT MATCH
	CASE CTRL_T:	    // PREVIOUS MATCH
		IF (MAY_ADJUST_INCSEARCH_HIGHLIGHTING(
					  FIRSTC, COUNT, &IS_STATE, C) == FAIL)
		    GOTO CMDLINE_NOT_CHANGED;
		BREAK;
#ENDIF

	CASE CTRL_V:
	CASE CTRL_Q:
		{
		    IGNORE_DRAG_RELEASE = TRUE;
		    PUTCMDLINE('^', TRUE);

		    // GET NEXT (TWO) CHARACTER(S).  DO NOT CHANGE ANY
		    // MODIFYOTHERKEYS ESC SEQUENCE TO A NORMAL KEY FOR
		    // CTRL-SHIFT-V.
		    C = GET_LITERAL(MOD_MASK & MOD_MASK_SHIFT);

		    DO_ABBR = FALSE;	    // DON'T DO ABBREVIATION NOW
		    EXTRA_CHAR = NUL;
		    // MAY NEED TO REMOVE ^ WHEN COMPOSING CHAR WAS TYPED
		    IF (ENC_UTF8 && UTF_ISCOMPOSING(C) && !CMD_SILENT)
		    {
			DRAW_CMDLINE(CCLINE.CMDPOS,
						CCLINE.CMDLEN - CCLINE.CMDPOS);
			MSG_PUTCHAR(' ');
			CURSORCMD();
		    }
		}

		BREAK;

#IFDEF FEAT_DIGRAPHS
	CASE CTRL_K:
		IGNORE_DRAG_RELEASE = TRUE;
		PUTCMDLINE('?', TRUE);
# IFDEF USE_ON_FLY_SCROLL
		DONT_SCROLL = TRUE;	    // DISALLOW SCROLLING HERE
# ENDIF
		C = GET_DIGRAPH(TRUE);
		EXTRA_CHAR = NUL;
		IF (C != NUL)
		    BREAK;

		REDRAWCMD();
		GOTO CMDLINE_NOT_CHANGED;
#ENDIF // FEAT_DIGRAPHS

#IFDEF FEAT_RIGHTLEFT
	CASE CTRL__:	    // CTRL-_: SWITCH LANGUAGE MODE
		IF (!P_ARI)
		    BREAK;
		CMD_HKMAP = !CMD_HKMAP;
		GOTO CMDLINE_NOT_CHANGED;
#ENDIF

	CASE K_PS:
		BRACKETED_PASTE(PASTE_CMDLINE, FALSE, NULL);
		GOTO CMDLINE_CHANGED;

	DEFAULT:
#IFDEF UNIX
		IF (C == INTR_CHAR)
		{
		    GOTESC = TRUE;	// WILL FREE CCLINE.CMDBUFF AFTER
					// PUTTING IT IN HISTORY
		    GOTO RETURNCMD;	// BACK TO NORMAL MODE
		}
#ENDIF
		/*
		 * NORMAL CHARACTER WITH NO SPECIAL MEANING.  JUST SET MOD_MASK
		 * TO 0X0 SO THAT TYPING SHIFT-SPACE IN THE GUI DOESN'T ENTER
		 * THE STRING <S-SPACE>.  THIS SHOULD ONLY HAPPEN AFTER ^V.
		 */
		IF (!IS_SPECIAL(C))
		    MOD_MASK = 0X0;
		BREAK;
	}
	/*
	 * END OF SWITCH ON COMMAND LINE CHARACTER.
	 * WE COME HERE IF WE HAVE A NORMAL CHARACTER.
	 */

	IF (DO_ABBR && (IS_SPECIAL(C) || !VIM_ISWORDC(C))
		&& (CCHECK_ABBR(
			// ADD ABBR_OFF FOR CHARACTERS ABOVE 0X100, THIS IS
			// WHAT CHECK_ABBR() EXPECTS.
				(HAS_MBYTE && C >= 0X100) ? (C + ABBR_OFF) : C)
		    || C == CTRL_RSB))
	    GOTO CMDLINE_CHANGED;

	/*
	 * PUT THE CHARACTER IN THE COMMAND LINE
	 */
	IF (IS_SPECIAL(C) || MOD_MASK != 0)
	    PUT_ON_CMDLINE(GET_SPECIAL_KEY_NAME(C, MOD_MASK), -1, TRUE);
	ELSE
	{
	    IF (HAS_MBYTE)
	    {
		J = (*MB_CHAR2BYTES)(C, IOBUFF);
		IOBUFF[J] = NUL;	// EXCLUDE COMPOSING CHARS
		PUT_ON_CMDLINE(IOBUFF, J, TRUE);
	    }
	    ELSE
	    {
		IOBUFF[0] = C;
		PUT_ON_CMDLINE(IOBUFF, 1, TRUE);
	    }
	}
	GOTO CMDLINE_CHANGED;

/*
 * THIS PART IMPLEMENTS INCREMENTAL SEARCHES FOR "/" AND "?"
 * JUMP TO CMDLINE_NOT_CHANGED WHEN A CHARACTER HAS BEEN READ BUT THE COMMAND
 * LINE DID NOT CHANGE. THEN WE ONLY SEARCH AND REDRAW IF SOMETHING CHANGED IN
 * THE PAST.
 * JUMP TO CMDLINE_CHANGED WHEN THE COMMAND LINE DID CHANGE.
 * (SORRY FOR THE GOTO'S, I KNOW IT IS UGLY).
 */
CMDLINE_NOT_CHANGED:
#IFDEF FEAT_SEARCH_EXTRA
	IF (!IS_STATE.INCSEARCH_POSTPONED)
	    CONTINUE;
#ENDIF

CMDLINE_CHANGED:
#IFDEF FEAT_SEARCH_EXTRA
	// IF THE WINDOW CHANGED INCREMENTAL SEARCH STATE IS NOT VALID.
	IF (IS_STATE.WINID != CURWIN->W_ID)
	    INIT_INCSEARCH_STATE(&IS_STATE);
#ENDIF
	IF (TRIGGER_CMDLINECHANGED)
	    // TRIGGER CMDLINECHANGED AUTOCOMMANDS.
	    TRIGGER_CMD_AUTOCMD(CMDLINE_TYPE, EVENT_CMDLINECHANGED);

#IFDEF FEAT_SEARCH_EXTRA
	IF (XPC.XP_CONTEXT == EXPAND_NOTHING && (KEYTYPED || VPEEKC() == NUL))
	    MAY_DO_INCSEARCH_HIGHLIGHTING(FIRSTC, COUNT, &IS_STATE);
#ENDIF

#IFDEF FEAT_RIGHTLEFT
	IF (CMDMSG_RL
# IFDEF FEAT_ARABIC
		|| (P_ARSHAPE && !P_TBIDI
				       && CMDLINE_HAS_ARABIC(0, CCLINE.CMDLEN))
# ENDIF
		)
	    // ALWAYS REDRAW THE WHOLE COMMAND LINE TO FIX SHAPING AND
	    // RIGHT-LEFT TYPING.  NOT EFFICIENT, BUT IT WORKS.
	    // DO IT ONLY WHEN THERE ARE NO CHARACTERS LEFT TO READ
	    // TO AVOID USELESS INTERMEDIATE REDRAWS.
	    IF (VPEEKC() == NUL)
		REDRAWCMD();
#ENDIF
    }

RETURNCMD:

#IFDEF FEAT_RIGHTLEFT
    CMDMSG_RL = FALSE;
#ENDIF

    EXPANDCLEANUP(&XPC);
    CCLINE.XPC = NULL;

#IFDEF FEAT_SEARCH_EXTRA
    FINISH_INCSEARCH_HIGHLIGHTING(GOTESC, &IS_STATE, FALSE);
#ENDIF

    IF (CCLINE.CMDBUFF != NULL)
    {
	/*
	 * PUT LINE IN HISTORY BUFFER (":" AND "=" ONLY WHEN IT WAS TYPED).
	 */
	IF (CCLINE.CMDLEN && FIRSTC != NUL
		&& (SOME_KEY_TYPED || HISTYPE == HIST_SEARCH))
	{
	    ADD_TO_HISTORY(HISTYPE, CCLINE.CMDBUFF, TRUE,
				       HISTYPE == HIST_SEARCH ? FIRSTC : NUL);
	    IF (FIRSTC == ':')
	    {
		VIM_FREE(NEW_LAST_CMDLINE);
		NEW_LAST_CMDLINE = VIM_STRSAVE(CCLINE.CMDBUFF);
	    }
	}

	IF (GOTESC)
	    ABANDON_CMDLINE();
    }

    /*
     * IF THE SCREEN WAS SHIFTED UP, REDRAW THE WHOLE SCREEN (LATER).
     * IF THE LINE IS TOO LONG, CLEAR IT, SO RULER AND SHOWN COMMAND DO
     * NOT GET PRINTED IN THE MIDDLE OF IT.
     */
    MSG_CHECK();
    MSG_SCROLL = SAVE_MSG_SCROLL;
    REDIR_OFF = FALSE;

    // WHEN THE COMMAND LINE WAS TYPED, NO NEED FOR A WAIT-RETURN PROMPT.
    IF (SOME_KEY_TYPED)
	NEED_WAIT_RETURN = FALSE;

    // TRIGGER CMDLINELEAVE AUTOCOMMANDS.
    TRIGGER_CMD_AUTOCMD(CMDLINE_TYPE, EVENT_CMDLINELEAVE);

    STATE = SAVE_STATE;

#IFDEF FEAT_EVAL
    IF (!DEBUG_MODE)
	MAY_TRIGGER_MODECHANGED();
#ENDIF

#IFDEF HAVE_INPUT_METHOD
    IF (B_IM_PTR != NULL && *B_IM_PTR != B_IMODE_LMAP)
	IM_SAVE_STATUS(B_IM_PTR);
    IM_SET_ACTIVE(FALSE);
#ENDIF
    SETMOUSE();
#IFDEF CURSOR_SHAPE
    UI_CURSOR_SHAPE();		// MAY SHOW DIFFERENT CURSOR SHAPE
#ENDIF
    SB_TEXT_END_CMDLINE();

THEEND:
    {
	CHAR_U *P = CCLINE.CMDBUFF;

	--DEPTH;
	IF (DID_SAVE_CCLINE)
	    RESTORE_CMDLINE(&SAVE_CCLINE);
	ELSE
	    CCLINE.CMDBUFF = NULL;
	RETURN P;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 329922_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
COMPOSITE_GLYPHS_VIA_MASK (VOID				*_DST,
			   CAIRO_OPERATOR_T		 OP,
			   CAIRO_SURFACE_T		*_SRC,
			   INT				 SRC_X,
			   INT				 SRC_Y,
			   INT				 DST_X,
			   INT				 DST_Y,
			   CAIRO_COMPOSITE_GLYPHS_INFO_T *INFO)
{
    CAIRO_SCALED_GLYPH_T *GLYPH_CACHE[64];
    PIXMAN_IMAGE_T *WHITE = _PIXMAN_IMAGE_FOR_COLOR (CAIRO_COLOR_WHITE);
    CAIRO_SCALED_GLYPH_T *SCALED_GLYPH;
    UINT8_T BUF[2048];
    PIXMAN_IMAGE_T *MASK;
    PIXMAN_FORMAT_CODE_T FORMAT;
    CAIRO_STATUS_T STATUS;
    INT I;

    TRACE ((STDERR, "%S\N", __FUNCTION__));

    IF (UNLIKELY (WHITE == NULL))
	RETURN _CAIRO_ERROR (CAIRO_STATUS_NO_MEMORY);

    /* XXX CONVERT THE GLYPHS TO COMMON FORMATS A8/A8R8G8B8 TO HIT
     * OPTIMISED PATHS THROUGH PIXMAN. SHOULD WE INCREASE THE BIT
     * DEPTH OF THE TARGET SURFACE, WE SHOULD RECONSIDER THE APPROPRIATE
     * MASK FORMATS.
     */

    STATUS = _CAIRO_SCALED_GLYPH_LOOKUP (INFO->FONT,
					 INFO->GLYPHS[0].INDEX,
					 CAIRO_SCALED_GLYPH_INFO_SURFACE,
					 &SCALED_GLYPH);
    IF (UNLIKELY (STATUS)) {
	PIXMAN_IMAGE_UNREF (WHITE);
	RETURN STATUS;
    }

    MEMSET (GLYPH_CACHE, 0, SIZEOF (GLYPH_CACHE));
    GLYPH_CACHE[INFO->GLYPHS[0].INDEX % ARRAY_LENGTH (GLYPH_CACHE)] = SCALED_GLYPH;

    FORMAT = PIXMAN_A8;
    I = (INFO->EXTENTS.WIDTH + 3) & ~3;
    IF (SCALED_GLYPH->SURFACE->BASE.CONTENT & CAIRO_CONTENT_COLOR) {
	FORMAT = PIXMAN_A8R8G8B8;
	I = INFO->EXTENTS.WIDTH * 4;
    }

    IF (I * INFO->EXTENTS.HEIGHT > (INT) SIZEOF (BUF)) {
	MASK = PIXMAN_IMAGE_CREATE_BITS (FORMAT,
					INFO->EXTENTS.WIDTH,
					INFO->EXTENTS.HEIGHT,
					NULL, 0);
    } ELSE {
	MEMSET (BUF, 0, I * INFO->EXTENTS.HEIGHT);
	MASK = PIXMAN_IMAGE_CREATE_BITS (FORMAT,
					INFO->EXTENTS.WIDTH,
					INFO->EXTENTS.HEIGHT,
					(UINT32_T *)BUF, I);
    }
    IF (UNLIKELY (MASK == NULL)) {
	PIXMAN_IMAGE_UNREF (WHITE);
	RETURN _CAIRO_ERROR (CAIRO_STATUS_NO_MEMORY);
    }

    STATUS = CAIRO_STATUS_SUCCESS;
    FOR (I = 0; I < INFO->NUM_GLYPHS; I++) {
	UNSIGNED LONG GLYPH_INDEX = INFO->GLYPHS[I].INDEX;
	INT CACHE_INDEX = GLYPH_INDEX % ARRAY_LENGTH (GLYPH_CACHE);
	CAIRO_IMAGE_SURFACE_T *GLYPH_SURFACE;
	INT X, Y;

	SCALED_GLYPH = GLYPH_CACHE[CACHE_INDEX];
	IF (SCALED_GLYPH == NULL ||
	    _CAIRO_SCALED_GLYPH_INDEX (SCALED_GLYPH) != GLYPH_INDEX)
	{
	    STATUS = _CAIRO_SCALED_GLYPH_LOOKUP (INFO->FONT, GLYPH_INDEX,
						 CAIRO_SCALED_GLYPH_INFO_SURFACE,
						 &SCALED_GLYPH);

	    IF (UNLIKELY (STATUS)) {
		PIXMAN_IMAGE_UNREF (MASK);
		PIXMAN_IMAGE_UNREF (WHITE);
		RETURN STATUS;
	    }

	    GLYPH_CACHE[CACHE_INDEX] = SCALED_GLYPH;
	}

	GLYPH_SURFACE = SCALED_GLYPH->SURFACE;
	IF (GLYPH_SURFACE->WIDTH && GLYPH_SURFACE->HEIGHT) {
	    IF (GLYPH_SURFACE->BASE.CONTENT & CAIRO_CONTENT_COLOR &&
		FORMAT == PIXMAN_A8) {
		PIXMAN_IMAGE_T *CA_MASK;

		FORMAT = PIXMAN_A8R8G8B8;
		CA_MASK = PIXMAN_IMAGE_CREATE_BITS (FORMAT,
						    INFO->EXTENTS.WIDTH,
						    INFO->EXTENTS.HEIGHT,
						    NULL, 0);
		IF (UNLIKELY (CA_MASK == NULL)) {
		    PIXMAN_IMAGE_UNREF (MASK);
		    PIXMAN_IMAGE_UNREF (WHITE);
		    RETURN _CAIRO_ERROR (CAIRO_STATUS_NO_MEMORY);
		}

		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_SRC,
					  WHITE, MASK, CA_MASK,
					  0, 0,
					  0, 0,
					  0, 0,
					  INFO->EXTENTS.WIDTH,
					  INFO->EXTENTS.HEIGHT);
		PIXMAN_IMAGE_UNREF (MASK);
		MASK = CA_MASK;
	    }

	    /* ROUND GLYPH LOCATIONS TO THE NEAREST PIXEL */
	    /* XXX: FRAGILE: WE'RE IGNORING DEVICE_TRANSFORM SCALING HERE. A BUG? */
	    X = _CAIRO_LROUND (INFO->GLYPHS[I].X -
			       GLYPH_SURFACE->BASE.DEVICE_TRANSFORM.X0);
	    Y = _CAIRO_LROUND (INFO->GLYPHS[I].Y -
			       GLYPH_SURFACE->BASE.DEVICE_TRANSFORM.Y0);

	    IF (GLYPH_SURFACE->PIXMAN_FORMAT == FORMAT) {
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_ADD,
					  GLYPH_SURFACE->PIXMAN_IMAGE, NULL, MASK,
					  0, 0,
					  0, 0,
					  X - INFO->EXTENTS.X, Y - INFO->EXTENTS.Y,
					  GLYPH_SURFACE->WIDTH,
					  GLYPH_SURFACE->HEIGHT);
	    } ELSE {
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_ADD,
					  WHITE, GLYPH_SURFACE->PIXMAN_IMAGE, MASK,
					  0, 0,
					  0, 0,
					  X - INFO->EXTENTS.X, Y - INFO->EXTENTS.Y,
					  GLYPH_SURFACE->WIDTH,
					  GLYPH_SURFACE->HEIGHT);
	    }
	}
    }

    IF (FORMAT == PIXMAN_A8R8G8B8)
	PIXMAN_IMAGE_SET_COMPONENT_ALPHA (MASK, TRUE);

    PIXMAN_IMAGE_COMPOSITE32 (_PIXMAN_OPERATOR (OP),
			      ((CAIRO_IMAGE_SOURCE_T *)_SRC)->PIXMAN_IMAGE,
			      MASK,
			      TO_PIXMAN_IMAGE (_DST),
			      INFO->EXTENTS.X + SRC_X, INFO->EXTENTS.Y + SRC_Y,
			      0, 0,
			      INFO->EXTENTS.X - DST_X, INFO->EXTENTS.Y - DST_Y,
			      INFO->EXTENTS.WIDTH, INFO->EXTENTS.HEIGHT);
    PIXMAN_IMAGE_UNREF (MASK);
    PIXMAN_IMAGE_UNREF (WHITE);

    RETURN CAIRO_STATUS_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 401531_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT TIMERS_DEAD_CPU(UNSIGNED INT CPU)
{
	STRUCT TIMER_BASE *OLD_BASE;
	STRUCT TIMER_BASE *NEW_BASE;
	INT B, I;

	BUG_ON(CPU_ONLINE(CPU));

	FOR (B = 0; B < NR_BASES; B++) {
		OLD_BASE = PER_CPU_PTR(&TIMER_BASES[B], CPU);
		NEW_BASE = GET_CPU_PTR(&TIMER_BASES[B]);
		/*
		 * THE CALLER IS GLOBALLY SERIALIZED AND NOBODY ELSE
		 * TAKES TWO LOCKS AT ONCE, DEADLOCK IS NOT POSSIBLE.
		 */
		RAW_SPIN_LOCK_IRQ(&NEW_BASE->LOCK);
		RAW_SPIN_LOCK_NESTED(&OLD_BASE->LOCK, SINGLE_DEPTH_NESTING);

		/*
		 * THE CURRENT CPUS BASE CLOCK MIGHT BE STALE. UPDATE IT
		 * BEFORE MOVING THE TIMERS OVER.
		 */
		FORWARD_TIMER_BASE(NEW_BASE);

		BUG_ON(OLD_BASE->RUNNING_TIMER);

		FOR (I = 0; I < WHEEL_SIZE; I++)
			MIGRATE_TIMER_LIST(NEW_BASE, OLD_BASE->VECTORS + I);

		RAW_SPIN_UNLOCK(&OLD_BASE->LOCK);
		RAW_SPIN_UNLOCK_IRQ(&NEW_BASE->LOCK);
		PUT_CPU_PTR(&TIMER_BASES);
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 450323_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_SOLID_TILE32(VNCSTATE *VS, INT X, INT Y, INT W, INT H,
                   UINT32_T *COLOR, BOOL SAMECOLOR)
{
    VNCDISPLAY *VD = VS->VD;
    UINT32_T *FBPTR;
    UINT32_T C;
    INT DX, DY;

    FBPTR = VNC_SERVER_FB_PTR(VD, X, Y);

    C = *FBPTR;
    IF (SAMECOLOR && (UINT32_T)C != *COLOR) {
        RETURN FALSE;
    }

    FOR (DY = 0; DY < H; DY++) {
        FOR (DX = 0; DX < W; DX++) {
            IF (C != FBPTR[DX]) {
                RETURN FALSE;
            }
        }
        FBPTR = (UINT32_T *)
            ((UINT8_T *)FBPTR + VNC_SERVER_FB_STRIDE(VD));
    }

    *COLOR = (UINT32_T)C;
    RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195471_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
IRC_PROTOCOL_CALLBACK(352)
{
    CHAR *POS_ATTR, *POS_HOPCOUNT, *POS_REALNAME, *STR_HOST;
    INT ARG_START, LENGTH;
    STRUCT T_IRC_CHANNEL *PTR_CHANNEL;
    STRUCT T_IRC_NICK *PTR_NICK;

    IRC_PROTOCOL_MIN_ARGS(5);

    /* SILENTLY IGNORE MALFORMED 352 MESSAGE (MISSING INFOS) */
    IF (ARGC < 8)
        RETURN WEECHAT_RC_OK;

    POS_ATTR = NULL;
    POS_HOPCOUNT = NULL;
    POS_REALNAME = NULL;

    IF (ARGC > 8)
    {
        ARG_START = (STRCMP (ARGV[8], "*") == 0) ? 9 : 8;
        IF (ARGV[ARG_START][0] == ':')
        {
            POS_ATTR = NULL;
            POS_HOPCOUNT = (ARGC > ARG_START) ? ARGV[ARG_START] + 1 : NULL;
            POS_REALNAME = (ARGC > ARG_START + 1) ? ARGV_EOL[ARG_START + 1] : NULL;
        }
        ELSE
        {
            POS_ATTR = ARGV[ARG_START];
            POS_HOPCOUNT = (ARGC > ARG_START + 1) ? ARGV[ARG_START + 1] + 1 : NULL;
            POS_REALNAME = (ARGC > ARG_START + 2) ? ARGV_EOL[ARG_START + 2] : NULL;
        }
    }

    PTR_CHANNEL = IRC_CHANNEL_SEARCH (SERVER, ARGV[3]);
    PTR_NICK = (PTR_CHANNEL) ?
        IRC_NICK_SEARCH (SERVER, PTR_CHANNEL, ARGV[7]) : NULL;

    /* UPDATE HOST IN NICK */
    IF (PTR_NICK)
    {
        LENGTH = STRLEN (ARGV[4]) + 1 + STRLEN (ARGV[5]) + 1;
        STR_HOST = MALLOC (LENGTH);
        IF (STR_HOST)
        {
            SNPRINTF (STR_HOST, LENGTH, "%S@%S", ARGV[4], ARGV[5]);
            IRC_NICK_SET_HOST (PTR_NICK, STR_HOST);
            FREE (STR_HOST);
        }
    }

    /* UPDATE AWAY FLAG IN NICK */
    IF (PTR_CHANNEL && PTR_NICK && POS_ATTR)
    {
        IRC_NICK_SET_AWAY (SERVER, PTR_CHANNEL, PTR_NICK,
                           (POS_ATTR[0] == 'G') ? 1 : 0);
    }

    /* UPDATE REALNAME IN NICK */
    IF (PTR_CHANNEL && PTR_NICK && POS_REALNAME)
    {
        IF (PTR_NICK->REALNAME)
            FREE (PTR_NICK->REALNAME);
        IF (POS_REALNAME &&
            WEECHAT_HASHTABLE_HAS_KEY (SERVER->CAP_LIST, "EXTENDED-JOIN"))
        {
            PTR_NICK->REALNAME = STRDUP (POS_REALNAME);
        }
        ELSE
        {
            PTR_NICK->REALNAME = NULL;
        }
    }

    /* DISPLAY OUTPUT OF WHO (MANUAL WHO FROM USER) */
    IF (!PTR_CHANNEL || (PTR_CHANNEL->CHECKING_WHOX <= 0))
    {
        WEECHAT_PRINTF_DATE_TAGS (
            IRC_MSGBUFFER_GET_TARGET_BUFFER (
                SERVER, NULL, COMMAND, "WHO", NULL),
            DATE,
            IRC_PROTOCOL_TAGS (COMMAND, "IRC_NUMERIC", NULL, NULL),
            "%S%S[%S%S%S] %S%S %S(%S%S@%S%S)%S %S%S%S%S(%S)",
            WEECHAT_PREFIX ("NETWORK"),
            IRC_COLOR_CHAT_DELIMITERS,
            IRC_COLOR_CHAT_CHANNEL,
            ARGV[3],
            IRC_COLOR_CHAT_DELIMITERS,
            IRC_NICK_COLOR_FOR_MSG (SERVER, 1, NULL, ARGV[7]),
            ARGV[7],
            IRC_COLOR_CHAT_DELIMITERS,
            IRC_COLOR_CHAT_HOST,
            ARGV[4],
            ARGV[5],
            IRC_COLOR_CHAT_DELIMITERS,
            IRC_COLOR_RESET,
            (POS_ATTR) ? POS_ATTR : "",
            (POS_ATTR) ? " " : "",
            (POS_HOPCOUNT) ? POS_HOPCOUNT : "",
            (POS_HOPCOUNT) ? " " : "",
            (POS_REALNAME) ? POS_REALNAME : "");
    }

    RETURN WEECHAT_RC_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198927_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RLIST *R_BIN_NE_GET_ENTRYPOINTS(R_BIN_NE_OBJ_T *BIN) {
	IF (!BIN->ENTRY_TABLE) {
		RETURN NULL;
	}
	RLIST *ENTRIES = R_LIST_NEWF (FREE);
	IF (!ENTRIES) {
		RETURN NULL;
	}
	RLIST *SEGMENTS = R_BIN_NE_GET_SEGMENTS (BIN);
	IF (!SEGMENTS) {
		R_LIST_FREE (ENTRIES);
		RETURN NULL;
	}
	IF (BIN->NE_HEADER->CSENTRYPOINT) {
		RBINADDR *ENTRY = R_NEW0 (RBINADDR);
		IF (!ENTRY) {
			R_LIST_FREE (ENTRIES);
			RETURN NULL;
		}
		ENTRY->BITS = 16;
		UT32 ENTRY_CS = BIN->NE_HEADER->CSENTRYPOINT;
		RBINSECTION *S = R_LIST_GET_N (SEGMENTS, ENTRY_CS - 1);
		ENTRY->PADDR = BIN->NE_HEADER->IPENTRYPOINT + (S? S->PADDR: 0);

		R_LIST_APPEND (ENTRIES, ENTRY);
	}
	INT OFF = 0;
	SIZE_T TABLEAT = BIN->HEADER_OFFSET + BIN->NE_HEADER->ENTRYTABLEOFFSET;
	WHILE (OFF < BIN->NE_HEADER->ENTRYTABLELENGTH) {
		IF (TABLEAT + OFF >= R_BUF_SIZE (BIN->BUF)) {
			BREAK;
		}
		UT8 BUNDLE_LENGTH = *(UT8 *)(BIN->ENTRY_TABLE + OFF);
		IF (!BUNDLE_LENGTH) {
			BREAK;
		}
		OFF++;
		UT8 BUNDLE_TYPE = *(UT8 *)(BIN->ENTRY_TABLE + OFF);
		OFF++;
		INT I;
		FOR (I = 0; I < BUNDLE_LENGTH; I++) {
			IF (TABLEAT + OFF + 4 >= R_BUF_SIZE (BIN->BUF)) {
				BREAK;
			}
			RBINADDR *ENTRY = R_NEW0 (RBINADDR);
			IF (!ENTRY) {
				R_LIST_FREE (ENTRIES);
				RETURN NULL;
			}
			OFF++;
			IF (!BUNDLE_TYPE) { // SKIP
				OFF--;
				FREE (ENTRY);
				BREAK;
			} ELSE IF (BUNDLE_TYPE == 0XFF) { // MOVEABLE
				OFF += 2;
				UT8 SEGNUM = *(BIN->ENTRY_TABLE + OFF);
				OFF++;
				UT16 SEGOFF = *(UT16 *)(BIN->ENTRY_TABLE + OFF);
				IF (SEGNUM > 0) {
					ENTRY->PADDR = (UT64)BIN->SEGMENT_ENTRIES[SEGNUM - 1].OFFSET * BIN->ALIGNMENT + SEGOFF;
				}
			} ELSE { // FIXED
				IF (BUNDLE_TYPE < BIN->NE_HEADER->SEGCOUNT) {
					ENTRY->PADDR = (UT64)BIN->SEGMENT_ENTRIES[BUNDLE_TYPE - 1].OFFSET
						* BIN->ALIGNMENT + *(UT16 *)(BIN->ENTRY_TABLE + OFF);
				}
			}
			OFF += 2;
			R_LIST_APPEND (ENTRIES, ENTRY);
		}
	}
	R_LIST_FREE (SEGMENTS);
	BIN->ENTRIES = ENTRIES;
	RETURN ENTRIES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216973_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CREATE_WORKER_THREADS(UINT N)
{
	COMP_THREAD_CTXT_T	*THREADS;
	UINT 			I;

	THREADS = (COMP_THREAD_CTXT_T *)
		MY_MALLOC(SIZEOF(COMP_THREAD_CTXT_T) * N, MYF(MY_FAE));

	FOR (I = 0; I < N; I++) {
		COMP_THREAD_CTXT_T *THD = THREADS + I;

		THD->NUM = I + 1;
		THD->STARTED = FALSE;
		THD->CANCELLED = FALSE;
		THD->DATA_AVAIL = FALSE;

		THD->TO = (CHAR *) MY_MALLOC(COMPRESS_CHUNK_SIZE +
						   MY_QLZ_COMPRESS_OVERHEAD,
						   MYF(MY_FAE));

		/* INITIALIZE THE CONTROL MUTEX AND CONDITION VAR */
		IF (PTHREAD_MUTEX_INIT(&THD->CTRL_MUTEX, NULL) ||
		    PTHREAD_COND_INIT(&THD->CTRL_COND, NULL)) {
			GOTO ERR;
		}

		/* INITIALIZE AND DATA MUTEX AND CONDITION VAR */
		IF (PTHREAD_MUTEX_INIT(&THD->DATA_MUTEX, NULL) ||
		    PTHREAD_COND_INIT(&THD->DATA_COND, NULL)) {
			GOTO ERR;
		}

		PTHREAD_MUTEX_LOCK(&THD->CTRL_MUTEX);

		IF (PTHREAD_CREATE(&THD->ID, NULL, COMPRESS_WORKER_THREAD_FUNC,
				   THD)) {
			MSG("COMPRESS: PTHREAD_CREATE() FAILED: "
			    "ERRNO = %D", ERRNO);
			GOTO ERR;
		}
	}

	/* WAIT FOR THE THREADS TO START */
	FOR (I = 0; I < N; I++) {
		COMP_THREAD_CTXT_T *THD = THREADS + I;

		WHILE (THD->STARTED == FALSE)
			PTHREAD_COND_WAIT(&THD->CTRL_COND, &THD->CTRL_MUTEX);
		PTHREAD_MUTEX_UNLOCK(&THD->CTRL_MUTEX);
	}

	RETURN THREADS;

ERR:
	MY_FREE(THREADS);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 432237_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC FLATVIEW *GENERATE_MEMORY_TOPOLOGY(STRUCT UC_STRUCT *UC, MEMORYREGION *MR)
{
    INT I;
    FLATVIEW *VIEW;

    VIEW = FLATVIEW_NEW(MR);

    IF (MR) {
        RENDER_MEMORY_REGION(VIEW, MR, INT128_ZERO(),
                             ADDRRANGE_MAKE(INT128_ZERO(), INT128_2_64()),
                             FALSE);
    }
    FLATVIEW_SIMPLIFY(VIEW);

    VIEW->DISPATCH = ADDRESS_SPACE_DISPATCH_NEW(UC, VIEW);
    FOR (I = 0; I < VIEW->NR; I++) {
        MEMORYREGIONSECTION MRS =
            SECTION_FROM_FLAT_RANGE(&VIEW->RANGES[I], VIEW);
        FLATVIEW_ADD_TO_DISPATCH(UC, VIEW, &MRS);
    }
    ADDRESS_SPACE_DISPATCH_COMPACT(VIEW->DISPATCH);
    G_HASH_TABLE_REPLACE(UC->FLAT_VIEWS, MR, VIEW);

    RETURN VIEW;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 402635_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
WRITE_PID_FILE(INT PID)
{
	INT FD = OPEN(PIDFILE, O_WRONLY|O_CREAT|O_TRUNC, 0644);
	IF (FD < 0) {
ERR:
		FPRINTF(STDERR, "COULDN'T OPEN PIDFILE: %M\N");
		EXIT(1);
	}
	CHAR *PIDSTR = NULL;
	INT RC = ASPRINTF(&PIDSTR, "%D\N", PID);
	IF (RC < 0)
		GOTO ERR;

	RC = WRITE(FD, PIDSTR, STRLEN(PIDSTR)+1);
	IF (RC < 0)
		GOTO ERR;

	FREE(PIDSTR);
	CLOSE(FD);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195984_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR DIST_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	U32 I;
	CHAR STR[1024];
	GF_DIMSSCRIPTTYPESBOX *P = (GF_DIMSSCRIPTTYPESBOX *)S;

	I=0;
	STR[0]=0;
	WHILE (1) {
		STR[I] = GF_BS_READ_U8(BS);
		IF (!STR[I]) BREAK;
		I++;
	}
	ISOM_DECREASE_SIZE(P, I);

	P->CONTENT_SCRIPT_TYPES = GF_STRDUP(STR);
	RETURN GF_OK;
}
ASSISTANT
CWE-787: OUT-OF-BOUNDS WRITE
--------------------------------------------------
File: 204438_CWE-617.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
WANDPRIVATE VOID CLINOIMAGEOPERATOR(MAGICKCLI *CLI_WAND,
  CONST CHAR *OPTION,CONST CHAR *ARG1N,CONST CHAR *ARG2N)
{
  CONST CHAR    /* PERCENT ESCAPED VERSIONS OF THE ARGS */
    *ARG1,
    *ARG2;

#DEFINE _IMAGE_INFO     (CLI_WAND->WAND.IMAGE_INFO)
#DEFINE _IMAGES         (CLI_WAND->WAND.IMAGES)
#DEFINE _EXCEPTION      (CLI_WAND->WAND.EXCEPTION)
#DEFINE _PROCESS_FLAGS  (CLI_WAND->PROCESS_FLAGS)
#DEFINE _OPTION_TYPE    ((COMMANDOPTIONFLAGS) CLI_WAND->COMMAND->FLAGS)
#DEFINE IFNORMALOP      (*OPTION=='-')
#DEFINE IFPLUSOP        (*OPTION!='-')

  ASSERT(CLI_WAND != (MAGICKCLI *) NULL);
  ASSERT(CLI_WAND->SIGNATURE == MAGICKWANDSIGNATURE);
  ASSERT(CLI_WAND->WAND.SIGNATURE == MAGICKWANDSIGNATURE);

  IF (CLI_WAND->WAND.DEBUG != MAGICKFALSE)
    (VOID) CLILOGEVENT(CLI_WAND,COMMANDEVENT,GETMAGICKMODULE(),
      "- NOIMAGE OPERATOR: %S \"%S\" \"%S\"", OPTION,
      ARG1N != (CHAR *) NULL ? ARG1N : "",
      ARG2N != (CHAR *) NULL ? ARG2N : "");

  ARG1 = ARG1N;
  ARG2 = ARG2N;

  /* INTERPRET PERCENT ESCAPES IN ARGUMENTS - USING FIRST IMAGE */
  IF ( (((_PROCESS_FLAGS & PROCESSINTERPRETPROPERITIES) != 0 )
        || ((_OPTION_TYPE & ALWAYSINTERPRETARGSFLAG) != 0)
       )  && ((_OPTION_TYPE & NEVERINTERPRETARGSFLAG) == 0) ) {
    /* INTERPRET PERCENT ESCAPES IN ARGUMENT 1 */
    IF (ARG1N != (CHAR *) NULL) {
      ARG1=INTERPRETIMAGEPROPERTIES(_IMAGE_INFO,_IMAGES,ARG1N,_EXCEPTION);
      IF (ARG1 == (CHAR *) NULL) {
        CLIWANDEXCEPTION(OPTIONWARNING,"INTERPRETPROPERTYFAILURE",OPTION);
        ARG1=ARG1N;  /* USE THE GIVEN ARGUMENT AS IS */
      }
    }
    IF (ARG2N != (CHAR *) NULL) {
      ARG2=INTERPRETIMAGEPROPERTIES(_IMAGE_INFO,_IMAGES,ARG2N,_EXCEPTION);
      IF (ARG2 == (CHAR *) NULL) {
        CLIWANDEXCEPTION(OPTIONWARNING,"INTERPRETPROPERTYFAILURE",OPTION);
        ARG2=ARG2N;  /* USE THE GIVEN ARGUMENT AS IS */
      }
    }
  }
#UNDEF _PROCESS_FLAGS
#UNDEF _OPTION_TYPE

  DO {  /* BREAK TO EXIT CODE */
    /*
      NO-OP OPTIONS  (IGNORE THESE)
    */
    IF (LOCALECOMPARE("NOOP",OPTION+1) == 0)   /* ZERO ARGUMENT */
      BREAK;
    IF (LOCALECOMPARE("SANS",OPTION+1) == 0)   /* ONE ARGUMENT */
      BREAK;
    IF (LOCALECOMPARE("SANS0",OPTION+1) == 0)  /* ZERO ARGUMENT */
      BREAK;
    IF (LOCALECOMPARE("SANS1",OPTION+1) == 0)  /* ONE ARGUMENT */
      BREAK;
    IF (LOCALECOMPARE("SANS2",OPTION+1) == 0)  /* TWO ARGUMENTS */
      BREAK;
    /*
      IMAGE READING
    */
    IF ( ( LOCALECOMPARE("READ",OPTION+1) == 0 ) ||
      ( LOCALECOMPARE("--",OPTION) == 0 ) ) {
      /* DO GLOB FILENAME EXPANSION FOR 'ARG1' THEN READ ALL IMAGES.
      *
      * EXPANSION HANDLES '@', '~', '*', AND '?' META-CHARACTERS WHILE IGNORING
      * (BUT ATTACHING TO THE FILENAMES IN THE GENERATED ARGUMENT LIST) ANY
      * [...] READ MODIFIERS THAT MAY BE PRESENT.
      *
      * FOR EXAMPLE: IT WILL EXPAND '*.GIF[20X20]' INTO A LIST SUCH AS
      * 'ABC.GIF[20X20]',  'FOOBAR.GIF[20X20]',  'XYZZY.GIF[20X20]'
      *
      * NOTE: IN IMV6 THIS WAS DONE GLOBALLY ACROSS ALL IMAGES. THIS
      * MEANT YOU COULD INCLUDE IM OPTIONS IN '@FILENAME' LISTS, BUT YOU
      * COULD NOT INCLUDE COMMENTS.   DOING IT ONLY FOR IMAGE READ MAKES
      * IT FAR MORE SECURE.
      *
      * NOTE: ARGUMENTS DO NOT HAVE PERCENT ESCAPES EXPANDED FOR SECURITY
      * REASONS.
      */
      INT      ARGC;
      CHAR     **ARGV;
      SSIZE_T  I;

      ARGC = 1;
      ARGV = (CHAR **) &ARG1;

      /* EXPAND 'GLOB' EXPRESSIONS IN THE GIVEN FILENAME.
        EXPANSION HANDLES ANY 'CODER:' PREFIX, OR READ MODIFIERS ATTACHED
        TO THE FILENAME, INCLUDING THEM IN THE RESULTING EXPANDED LIST.
      */
      IF (EXPANDFILENAMES(&ARGC,&ARGV) == MAGICKFALSE)
        CLIWANDEXCEPTARGBREAK(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED",
            OPTION,GETEXCEPTIONMESSAGE(ERRNO));

      /* LOOP OVER EXPANDED FILENAME LIST, AND READ THEN ALL IN */
      FOR (I=0; I < (SSIZE_T) ARGC; I++) {
        IMAGE *
          NEW_IMAGES;
        IF (_IMAGE_INFO->PING != MAGICKFALSE)
          NEW_IMAGES=PINGIMAGES(_IMAGE_INFO,ARGV[I],_EXCEPTION);
        ELSE
          NEW_IMAGES=READIMAGES(_IMAGE_INFO,ARGV[I],_EXCEPTION);
        APPENDIMAGETOLIST(&_IMAGES, NEW_IMAGES);
        ARGV[I]=DESTROYSTRING(ARGV[I]);
      }
      ARGV=(CHAR **) RELINQUISHMAGICKMEMORY(ARGV);
      BREAK;
    }
    /*
      IMAGE WRITING
      NOTE: WRITING A EMPTY IMAGE LIST IS VALID IN SPECIFIC CASES
    */
    IF (LOCALECOMPARE("WRITE",OPTION+1) == 0) {
      /* NOTE: ARGUMENTS DO NOT HAVE PERCENT ESCAPES EXPANDED */
      CHAR
        KEY[MAGICKPATHEXTENT];

      IMAGE
        *WRITE_IMAGES;

      IMAGEINFO
        *WRITE_INFO;

      /* NEED IMAGES, UNLESS A "NULL:" OUTPUT CODER IS USED */
      IF ( _IMAGES == (IMAGE *) NULL ) {
        IF ( LOCALECOMPARE(ARG1,"NULL:") == 0 )
          BREAK;
        CLIWANDEXCEPTARGBREAK(OPTIONERROR,"NOIMAGESFORWRITE",OPTION,ARG1);
      }

      (VOID) FORMATLOCALESTRING(KEY,MAGICKPATHEXTENT,"CACHE:%S",ARG1);
      (VOID) DELETEIMAGEREGISTRY(KEY);
      WRITE_IMAGES=CLONEIMAGELIST(_IMAGES,_EXCEPTION);
      WRITE_INFO=CLONEIMAGEINFO(_IMAGE_INFO);
      (VOID) WRITEIMAGES(WRITE_INFO,WRITE_IMAGES,ARG1,_EXCEPTION);
      WRITE_INFO=DESTROYIMAGEINFO(WRITE_INFO);
      WRITE_IMAGES=DESTROYIMAGELIST(WRITE_IMAGES);
      BREAK;
    }
    /*
      PARENTHESIS AND BRACE OPERATIONS
    */
    IF (LOCALECOMPARE("(",OPTION) == 0) {
      /* STACK 'PUSH' IMAGES */
      STACK
        *NODE;

      SIZE_T
        SIZE;

      SIZE=0;
      NODE=CLI_WAND->IMAGE_LIST_STACK;
      FOR ( ; NODE != (STACK *) NULL; NODE=NODE->NEXT)
        SIZE++;
      IF ( SIZE >= MAX_STACK_DEPTH )
        CLIWANDEXCEPTIONBREAK(OPTIONERROR,"PARENTHESISNESTEDTOODEEPLY",OPTION);
      NODE=(STACK *) ACQUIREMAGICKMEMORY(SIZEOF(*NODE));
      IF (NODE == (STACK *) NULL)
        CLIWANDEXCEPTIONBREAK(RESOURCELIMITFATALERROR,
            "MEMORYALLOCATIONFAILED",OPTION);
      NODE->DATA = (VOID *)CLI_WAND->WAND.IMAGES;
      NODE->NEXT = CLI_WAND->IMAGE_LIST_STACK;
      CLI_WAND->IMAGE_LIST_STACK = NODE;
      CLI_WAND->WAND.IMAGES = NEWIMAGELIST();

      /* HANDLE RESPECT-PARENTHESIS */
      IF (ISSTRINGTRUE(GETIMAGEOPTION(CLI_WAND->WAND.IMAGE_INFO,
                    "RESPECT-PARENTHESIS")) != MAGICKFALSE)
        OPTION="{"; /* FALL-THRU SO AS TO PUSH IMAGE SETTINGS TOO */
      ELSE
        BREAK;
      /* FALL THRU TO OPERATION */
    }
    IF (LOCALECOMPARE("{",OPTION) == 0) {
      /* STACK 'PUSH' OF IMAGE_INFO SETTINGS */
      STACK
        *NODE;

      SIZE_T
        SIZE;

      SIZE=0;
      NODE=CLI_WAND->IMAGE_INFO_STACK;
      FOR ( ; NODE != (STACK *) NULL; NODE=NODE->NEXT)
        SIZE++;
      IF ( SIZE >= MAX_STACK_DEPTH )
        CLIWANDEXCEPTIONBREAK(OPTIONERROR,"CURLYBRACESNESTEDTOODEEPLY",OPTION);
      NODE=(STACK *) ACQUIREMAGICKMEMORY(SIZEOF(*NODE));
      IF (NODE == (STACK *) NULL)
        CLIWANDEXCEPTIONBREAK(RESOURCELIMITFATALERROR,
            "MEMORYALLOCATIONFAILED",OPTION);

      NODE->DATA = (VOID *)CLI_WAND->WAND.IMAGE_INFO;
      NODE->NEXT = CLI_WAND->IMAGE_INFO_STACK;

      CLI_WAND->IMAGE_INFO_STACK = NODE;
      CLI_WAND->WAND.IMAGE_INFO = CLONEIMAGEINFO(CLI_WAND->WAND.IMAGE_INFO);
      IF (CLI_WAND->WAND.IMAGE_INFO == (IMAGEINFO *) NULL) {
        CLIWANDEXCEPTION(RESOURCELIMITFATALERROR,"MEMORYALLOCATIONFAILED",
            OPTION);
        CLI_WAND->WAND.IMAGE_INFO = (IMAGEINFO *)NODE->DATA;
        NODE = (STACK *)RELINQUISHMAGICKMEMORY(NODE);
        BREAK;
      }

      BREAK;
    }
    IF (LOCALECOMPARE(")",OPTION) == 0) {
      /* POP IMAGES FROM STACK */
      STACK
        *NODE;

      NODE = (STACK *)CLI_WAND->IMAGE_LIST_STACK;
      IF ( NODE == (STACK *) NULL)
        CLIWANDEXCEPTIONBREAK(OPTIONERROR,"UNBALANCEDPARENTHESIS",OPTION);
      CLI_WAND->IMAGE_LIST_STACK = NODE->NEXT;

      APPENDIMAGETOLIST((IMAGE **)&NODE->DATA,CLI_WAND->WAND.IMAGES);
      CLI_WAND->WAND.IMAGES= (IMAGE *)NODE->DATA;
      NODE = (STACK *)RELINQUISHMAGICKMEMORY(NODE);

      /* HANDLE RESPECT-PARENTHESIS - OF THE PREVIOUS 'PUSHED' SETTINGS */
      NODE = CLI_WAND->IMAGE_INFO_STACK;
      IF ( NODE != (STACK *) NULL)
        {
          IF (ISSTRINGTRUE(GETIMAGEOPTION(
                CLI_WAND->WAND.IMAGE_INFO,"RESPECT-PARENTHESIS")) != MAGICKFALSE)
            OPTION="}"; /* FALL-THRU SO AS TO POP IMAGE SETTINGS TOO */
          ELSE
            BREAK;
        }
      ELSE
        BREAK;
      /* FALL THRU TO NEXT IF */
    }
    IF (LOCALECOMPARE("}",OPTION) == 0) {
      /* POP IMAGE_INFO SETTINGS FROM STACK */
      STACK
        *NODE;

      NODE = (STACK *)CLI_WAND->IMAGE_INFO_STACK;
      IF ( NODE == (STACK *) NULL)
        CLIWANDEXCEPTIONBREAK(OPTIONERROR,"UNBALANCEDCURLYBRACES",OPTION);
      CLI_WAND->IMAGE_INFO_STACK = NODE->NEXT;

      (VOID) DESTROYIMAGEINFO(CLI_WAND->WAND.IMAGE_INFO);
      CLI_WAND->WAND.IMAGE_INFO = (IMAGEINFO *)NODE->DATA;
      NODE = (STACK *)RELINQUISHMAGICKMEMORY(NODE);

      GETDRAWINFO(CLI_WAND->WAND.IMAGE_INFO, CLI_WAND->DRAW_INFO);
      CLI_WAND->QUANTIZE_INFO=DESTROYQUANTIZEINFO(CLI_WAND->QUANTIZE_INFO);
      CLI_WAND->QUANTIZE_INFO=ACQUIREQUANTIZEINFO(CLI_WAND->WAND.IMAGE_INFO);

      BREAK;
    }
      IF (LOCALECOMPARE("PRINT",OPTION+1) == 0)
        {
          (VOID) FORMATLOCALEFILE(STDOUT,"%S",ARG1);
          BREAK;
        }
    IF (LOCALECOMPARE("SET",OPTION+1) == 0)
      {
        /* SETTINGS ARE APPLIED TO EACH IMAGE IN MEMORY IN TURN (IF ANY).
           WHILE A OPTION: ONLY NEED TO BE APPLIED ONCE GLOBALLY.

           NOTE: RGUMENTS HAVE NOT BEEN AUTOMATICALLY PERCENT EXPANEDED
        */

        /* ESCAPE THE 'KEY' ONCE ONLY, USING FIRST IMAGE. */
        ARG1=INTERPRETIMAGEPROPERTIES(_IMAGE_INFO,_IMAGES,ARG1N,_EXCEPTION);
        IF (ARG1 == (CHAR *) NULL)
          CLIWANDEXCEPTIONBREAK(OPTIONWARNING,"INTERPRETPROPERTYFAILURE",
                OPTION);

        IF (LOCALENCOMPARE(ARG1,"REGISTRY:",9) == 0)
          {
            IF (IFPLUSOP)
              {
                (VOID) DELETEIMAGEREGISTRY(ARG1+9);
                ARG1=DESTROYSTRING((CHAR *)ARG1);
                BREAK;
              }
            ARG2=INTERPRETIMAGEPROPERTIES(_IMAGE_INFO,_IMAGES,ARG2N,_EXCEPTION);
            IF (ARG2 == (CHAR *) NULL) {
              ARG1=DESTROYSTRING((CHAR *)ARG1);
              CLIWANDEXCEPTIONBREAK(OPTIONWARNING,"INTERPRETPROPERTYFAILURE",
                    OPTION);
            }
            (VOID) SETIMAGEREGISTRY(STRINGREGISTRYTYPE,ARG1+9,ARG2,_EXCEPTION);
            ARG1=DESTROYSTRING((CHAR *)ARG1);
            ARG2=DESTROYSTRING((CHAR *)ARG2);
            BREAK;
          }
        IF (LOCALENCOMPARE(ARG1,"OPTION:",7) == 0)
          {
            /* DELETE EQUIVELENT ARTIFACT FROM ALL IMAGES (IF ANY) */
            IF (_IMAGES != (IMAGE *) NULL)
              {
                MAGICKRESETITERATOR(&CLI_WAND->WAND);
                WHILE (MAGICKNEXTIMAGE(&CLI_WAND->WAND) != MAGICKFALSE)
                  (VOID) DELETEIMAGEARTIFACT(_IMAGES,ARG1+7);
                MAGICKRESETITERATOR(&CLI_WAND->WAND);
              }
            /* NOW SET/DELETE THE GLOBAL OPTION AS NEEDED */
            /* FUTURE: MAKE ESCAPES IN A GLOBAL 'OPTION:' DELAYED */
            ARG2=(CHAR *) NULL;
            IF (IFNORMALOP)
              {
                ARG2=INTERPRETIMAGEPROPERTIES(_IMAGE_INFO,_IMAGES,ARG2N,_EXCEPTION);
                IF (ARG2 == (CHAR *) NULL)
                  CLIWANDEXCEPTIONBREAK(OPTIONWARNING,
                       "INTERPRETPROPERTYFAILURE",OPTION);
              }
            (VOID) SETIMAGEOPTION(_IMAGE_INFO,ARG1+7,ARG2);
            ARG1=DESTROYSTRING((CHAR *)ARG1);
            ARG2=DESTROYSTRING((CHAR *)ARG2);
            BREAK;
          }
        /* SET ARTIFACTS/PROPERTIES/ATTRIBUTES ALL IMAGES (REQUIRED) */
        IF ( _IMAGES == (IMAGE *) NULL )
          CLIWANDEXCEPTARGBREAK(OPTIONWARNING,"NOIMAGEFORPROPERTY",OPTION,ARG1);

        MAGICKRESETITERATOR(&CLI_WAND->WAND);
        WHILE (MAGICKNEXTIMAGE(&CLI_WAND->WAND) != MAGICKFALSE)
          {
            ARG2=(CHAR *) NULL;
            IF (IFNORMALOP)
              {
                ARG2=INTERPRETIMAGEPROPERTIES(_IMAGE_INFO,_IMAGES,ARG2N,_EXCEPTION);
                IF (ARG2 == (CHAR *) NULL)
                  CLIWANDEXCEPTIONBREAK(OPTIONWARNING,
                       "INTERPRETPROPERTYFAILURE",OPTION);
              }
            IF (LOCALENCOMPARE(ARG1,"ARTIFACT:",9) == 0)
              (VOID) SETIMAGEARTIFACT(_IMAGES,ARG1+9,ARG2);
            ELSE IF (LOCALENCOMPARE(ARG1,"PROPERTY:",9) == 0)
              (VOID) SETIMAGEPROPERTY(_IMAGES,ARG1+9,ARG2,_EXCEPTION);
            ELSE
              (VOID) SETIMAGEPROPERTY(_IMAGES,ARG1,ARG2,_EXCEPTION);
            ARG2=DESTROYSTRING((CHAR *)ARG2);
          }
        MAGICKRESETITERATOR(&CLI_WAND->WAND);
        ARG1=DESTROYSTRING((CHAR *)ARG1);
        BREAK;
     }
    IF (LOCALECOMPARE("CLONE",OPTION+1) == 0) {
        IMAGE
          *NEW_IMAGES;

        IF (*OPTION == '+')
          ARG1=ACQUIRESTRING("-1");
        IF (ISSCENEGEOMETRY(ARG1,MAGICKFALSE) == MAGICKFALSE)
          CLIWANDEXCEPTIONBREAK(OPTIONERROR,"INVALIDARGUMENT",OPTION);
        IF ( CLI_WAND->IMAGE_LIST_STACK == (STACK *) NULL)
          CLIWANDEXCEPTIONBREAK(OPTIONERROR,"UNABLETOCLONEIMAGE",OPTION);
        NEW_IMAGES = (IMAGE *)CLI_WAND->IMAGE_LIST_STACK->DATA;
        IF (NEW_IMAGES == (IMAGE *) NULL)
          CLIWANDEXCEPTIONBREAK(OPTIONERROR,"UNABLETOCLONEIMAGE",OPTION);
        NEW_IMAGES=CLONEIMAGES(NEW_IMAGES,ARG1,_EXCEPTION);
        IF (NEW_IMAGES == (IMAGE *) NULL)
          CLIWANDEXCEPTIONBREAK(OPTIONERROR,"NOSUCHIMAGE",OPTION);
        APPENDIMAGETOLIST(&_IMAGES,NEW_IMAGES);
        BREAK;
      }
    /*
       INFORMATIONAL OPERATIONS.

       NOTE THAT THESE DO NOT REQUIRE EITHER A CLI-WAND OR IMAGES!
       THOUGH CURRENTLY A CLI-WAND MUCH BE PROVIDED REGARDLESS.
    */
    IF (LOCALECOMPARE("VERSION",OPTION+1) == 0)
      {
        LISTMAGICKVERSION(STDOUT);
        BREAK;
      }
    IF (LOCALECOMPARE("LIST",OPTION+1) == 0) {
      /*
         FUTURE: THIS 'SWITCH' SHOULD REALLY BE PART OF MAGICKCORE
      */
      SSIZE_T
        LIST;

      LIST=PARSECOMMANDOPTION(MAGICKLISTOPTIONS,MAGICKFALSE,ARG1);
      IF ( LIST < 0 ) {
        CLIWANDEXCEPTIONARG(OPTIONERROR,"UNRECOGNIZEDLISTTYPE",OPTION,ARG1);
        BREAK;
      }
      SWITCH (LIST)
      {
        CASE MAGICKCODEROPTIONS:
        {
          (VOID) LISTCODERINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        }
        CASE MAGICKCOLOROPTIONS:
        {
          (VOID) LISTCOLORINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        }
        CASE MAGICKCONFIGUREOPTIONS:
        {
          (VOID) LISTCONFIGUREINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        }
        CASE MAGICKDELEGATEOPTIONS:
        {
          (VOID) LISTDELEGATEINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        }
        CASE MAGICKFONTOPTIONS:
        {
          (VOID) LISTTYPEINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        }
        CASE MAGICKFORMATOPTIONS:
          (VOID) LISTMAGICKINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKLOCALEOPTIONS:
          (VOID) LISTLOCALEINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKLOGOPTIONS:
          (VOID) LISTLOGINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKMAGICOPTIONS:
          (VOID) LISTMAGICINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKMIMEOPTIONS:
          (VOID) LISTMIMEINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKMODULEOPTIONS:
          (VOID) LISTMODULEINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKPOLICYOPTIONS:
          (VOID) LISTPOLICYINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKRESOURCEOPTIONS:
          (VOID) LISTMAGICKRESOURCEINFO((FILE *) NULL,_EXCEPTION);
          BREAK;
        CASE MAGICKTHRESHOLDOPTIONS:
          (VOID) LISTTHRESHOLDMAPS((FILE *) NULL,_EXCEPTION);
          BREAK;
        DEFAULT:
          (VOID) LISTCOMMANDOPTIONS((FILE *) NULL,(COMMANDOPTION) LIST,
            _EXCEPTION);
          BREAK;
      }
      BREAK;
    }

    CLIWANDEXCEPTION(OPTIONERROR,"UNRECOGNIZEDOPTION",OPTION);

DISABLEMSCWARNING(4127)
  } WHILE (0);  /* BREAK TO EXIT CODE. */
RESTOREMSCWARNING

  /* CLEAN UP PERCENT ESCAPE INTERPRETED STRINGS */
  IF (ARG1 != ARG1N )
    ARG1=DESTROYSTRING((CHAR *)ARG1);
  IF (ARG2 != ARG2N )
    ARG2=DESTROYSTRING((CHAR *)ARG2);

#UNDEF _IMAGE_INFO
#UNDEF _IMAGES
#UNDEF _EXCEPTION
#UNDEF IFNORMALOP
#UNDEF IFPLUSOP
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 383336_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDIMAGEPTR GDIMAGEROTATE180 (GDIMAGEPTR SRC)
{
	INT UY, UX;
	INT C;
	GDIMAGEPTR DST;
	TYPEDEF INT (*FUNCPTR)(GDIMAGEPTR, INT, INT);
	FUNCPTR F;

	IF (SRC->TRUECOLOR) {
		DST = GDIMAGECREATETRUECOLOR ( SRC->SX,SRC->SY);
		F = GDIMAGEGETTRUECOLORPIXEL;
	} ELSE {
		DST = GDIMAGECREATE (SRC->SX, SRC->SY);
		F = GDIMAGEGETPIXEL;
	}

	IF (DST != NULL) {
		GDIMAGEPALETTECOPY (DST, SRC);
		
		FOR (UY = 0; UY<SRC->SY; UY++) {
			FOR (UX = 0; UX<SRC->SX; UX++) {
				C = F (SRC, UX, UY);
				GDIMAGESETPIXEL(DST, (DST->SX - UX - 1), (DST->SY - UY - 1), C);
			}
		}
	}

	RETURN DST;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 436041_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE INT IO_ITER_DO_READ(STRUCT IO_KIOCB *REQ, STRUCT IOV_ITER *ITER)
{
	IF (REQ->FILE->F_OP->READ_ITER)
		RETURN CALL_READ_ITER(REQ->FILE, &REQ->RW.KIOCB, ITER);
	ELSE IF (REQ->FILE->F_OP->READ)
		RETURN LOOP_RW_ITER(READ, REQ, ITER);
	ELSE
		RETURN -EINVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234779_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC U64 DEV_EXTENT_SEARCH_START(STRUCT BTRFS_DEVICE *DEVICE, U64 START)
{
	SWITCH (DEVICE->FS_DEVICES->CHUNK_ALLOC_POLICY) {
	CASE BTRFS_CHUNK_ALLOC_REGULAR:
		/*
		 * WE DON'T WANT TO OVERWRITE THE SUPERBLOCK ON THE DRIVE NOR
		 * ANY AREA USED BY THE BOOT LOADER (GRUB FOR EXAMPLE), SO WE
		 * MAKE SURE TO START AT AN OFFSET OF AT LEAST 1MB.
		 */
		RETURN MAX_T(U64, START, SZ_1M);
	CASE BTRFS_CHUNK_ALLOC_ZONED:
		/*
		 * WE DON'T CARE ABOUT THE STARTING REGION LIKE REGULAR
		 * ALLOCATOR, BECAUSE WE ANYWAY USE/RESERVE THE FIRST TWO ZONES
		 * FOR SUPERBLOCK LOGGING.
		 */
		RETURN ALIGN(START, DEVICE->ZONE_INFO->ZONE_SIZE);
	DEFAULT:
		BUG();
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196805_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_VM_EXEC(MRB_STATE *MRB, CONST STRUCT RPROC *PROC, CONST MRB_CODE *PC)
{
  /* MRB_ASSERT(MRB_PROC_CFUNC_P(PROC)) */
  CONST MRB_IREP *IREP = PROC->BODY.IREP;
  CONST MRB_POOL_VALUE *POOL = IREP->POOL;
  CONST MRB_SYM *SYMS = IREP->SYMS;
  MRB_CODE INSN;
  INT AI = MRB_GC_ARENA_SAVE(MRB);
  STRUCT MRB_JMPBUF *PREV_JMP = MRB->JMP;
  STRUCT MRB_JMPBUF C_JMP;
  UINT32_T A;
  UINT16_T B;
  UINT16_T C;
  MRB_SYM MID;
  CONST STRUCT MRB_IREP_CATCH_HANDLER *CH;

#IFDEF DIRECT_THREADED
  STATIC CONST VOID * CONST OPTABLE[] = {
#DEFINE OPCODE(X,_) &&L_OP_ ## X,
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
  };
#ENDIF

  MRB_BOOL EXC_CATCHED = FALSE;
RETRY_TRY_BLOCK:

  MRB_TRY(&C_JMP) {

  IF (EXC_CATCHED) {
    EXC_CATCHED = FALSE;
    MRB_GC_ARENA_RESTORE(MRB, AI);
    IF (MRB->EXC && MRB->EXC->TT == MRB_TT_BREAK)
      GOTO L_BREAK;
    GOTO L_RAISE;
  }
  MRB->JMP = &C_JMP;
  MRB_VM_CI_PROC_SET(MRB->C->CI, PROC);

#DEFINE REGS (MRB->C->CI->STACK)
  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* DO NOTHING */
      NEXT;
    }

    CASE(OP_MOVE, BB) {
      REGS[A] = REGS[B];
      NEXT;
    }

    CASE(OP_LOADL, BB) {
      SWITCH (POOL[B].TT) {   /* NUMBER */
      CASE IREP_TT_INT32:
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I32);
        BREAK;
      CASE IREP_TT_INT64:
#IF DEFINED(MRB_INT64)
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
        BREAK;
#ELSE
#IF DEFINED(MRB_64BIT)
        IF (INT32_MIN <= POOL[B].U.I64 && POOL[B].U.I64 <= INT32_MAX) {
          REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
          BREAK;
        }
#ENDIF
        GOTO L_INT_OVERFLOW;
#ENDIF
      CASE IREP_TT_BIGINT:
        GOTO L_INT_OVERFLOW;
#IFNDEF MRB_NO_FLOAT
      CASE IREP_TT_FLOAT:
        REGS[A] = MRB_FLOAT_VALUE(MRB, POOL[B].U.F);
        BREAK;
#ENDIF
      DEFAULT:
        /* SHOULD NOT HAPPEN (TT:STRING) */
        REGS[A] = MRB_NIL_VALUE();
        BREAK;
      }
      NEXT;
    }

    CASE(OP_LOADI, BB) {
      SET_FIXNUM_VALUE(REGS[A], B);
      NEXT;
    }

    CASE(OP_LOADINEG, BB) {
      SET_FIXNUM_VALUE(REGS[A], -B);
      NEXT;
    }

    CASE(OP_LOADI__1,B) GOTO L_LOADI;
    CASE(OP_LOADI_0,B) GOTO L_LOADI;
    CASE(OP_LOADI_1,B) GOTO L_LOADI;
    CASE(OP_LOADI_2,B) GOTO L_LOADI;
    CASE(OP_LOADI_3,B) GOTO L_LOADI;
    CASE(OP_LOADI_4,B) GOTO L_LOADI;
    CASE(OP_LOADI_5,B) GOTO L_LOADI;
    CASE(OP_LOADI_6,B) GOTO L_LOADI;
    CASE(OP_LOADI_7, B) {
    L_LOADI:
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)INSN - (MRB_INT)OP_LOADI_0);
      NEXT;
    }

    CASE(OP_LOADI16, BS) {
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)(INT16_T)B);
      NEXT;
    }

    CASE(OP_LOADI32, BSS) {
      SET_INT_VALUE(MRB, REGS[A], (INT32_T)(((UINT32_T)B<<16)+C));
      NEXT;
    }

    CASE(OP_LOADSYM, BB) {
      SET_SYM_VALUE(REGS[A], SYMS[B]);
      NEXT;
    }

    CASE(OP_LOADNIL, B) {
      SET_NIL_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADSELF, B) {
      REGS[A] = REGS[0];
      NEXT;
    }

    CASE(OP_LOADT, B) {
      SET_TRUE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADF, B) {
      SET_FALSE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_GETGV, BB) {
      MRB_VALUE VAL = MRB_GV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETGV, BB) {
      MRB_GV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETSV, BB) {
      MRB_VALUE VAL = MRB_VM_SPECIAL_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETSV, BB) {
      MRB_VM_SPECIAL_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIV, BB) {
      REGS[A] = MRB_IV_GET(MRB, REGS[0], SYMS[B]);
      NEXT;
    }

    CASE(OP_SETIV, BB) {
      MRB_IV_SET(MRB, REGS[0], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETCV, BB) {
      MRB_VALUE VAL;
      VAL = MRB_VM_CV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETCV, BB) {
      MRB_VM_CV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIDX, B) {
      MRB_VALUE VA = REGS[A], VB = REGS[A+1];
      SWITCH (MRB_TYPE(VA)) {
      CASE MRB_TT_ARRAY:
        IF (!MRB_INTEGER_P(VB)) GOTO GETIDX_FALLBACK;
        REGS[A] = MRB_ARY_ENTRY(VA, MRB_INTEGER(VB));
        BREAK;
      CASE MRB_TT_HASH:
        REGS[A] = MRB_HASH_GET(MRB, VA, VB);
        BREAK;
      CASE MRB_TT_STRING:
        SWITCH (MRB_TYPE(VB)) {
        CASE MRB_TT_INTEGER:
        CASE MRB_TT_STRING:
        CASE MRB_TT_RANGE:
          REGS[A] = MRB_STR_AREF(MRB, VA, VB, MRB_UNDEF_VALUE());
          BREAK;
        DEFAULT:
          GOTO GETIDX_FALLBACK;
        }
        BREAK;
      DEFAULT:
      GETIDX_FALLBACK:
        MID = MRB_OPSYM(AREF);
        GOTO L_SEND_SYM;
      }
      NEXT;
    }

    CASE(OP_SETIDX, B) {
      C = 2;
      MID = MRB_OPSYM(ASET);
      SET_NIL_VALUE(REGS[A+3]);
      GOTO L_SENDB_SYM;
    }

    CASE(OP_GETCONST, BB) {
      REGS[A] = MRB_VM_CONST_GET(MRB, SYMS[B]);
      NEXT;
    }

    CASE(OP_SETCONST, BB) {
      MRB_VM_CONST_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETMCNST, BB) {
      REGS[A] = MRB_CONST_GET(MRB, REGS[A], SYMS[B]);
      NEXT;
    }

    CASE(OP_SETMCNST, BB) {
      MRB_CONST_SET(MRB, REGS[A+1], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETUPVAR, BBB) {
      MRB_VALUE *REGS_A = REGS + A;
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E && B < MRB_ENV_LEN(E)) {
        *REGS_A = E->STACK[B];
      }
      ELSE {
        *REGS_A = MRB_NIL_VALUE();
      }
      NEXT;
    }

    CASE(OP_SETUPVAR, BBB) {
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E) {
        MRB_VALUE *REGS_A = REGS + A;

        IF (B < MRB_ENV_LEN(E)) {
          E->STACK[B] = *REGS_A;
          MRB_WRITE_BARRIER(MRB, (STRUCT RBASIC*)E);
        }
      }
      NEXT;
    }

    CASE(OP_JMP, S) {
      PC += (INT16_T)A;
      JUMP;
    }
    CASE(OP_JMPIF, BS) {
      IF (MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNOT, BS) {
      IF (!MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNIL, BS) {
      IF (MRB_NIL_P(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }

    CASE(OP_JMPUW, S) {
      A = (UINT32_T)((PC - IREP->ISEQ) + (INT16_T)A);
      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {
        STRUCT RBREAK *BRK = (STRUCT RBREAK*)MRB->EXC;
        MRB_VALUE TARGET = MRB_BREAK_VALUE_GET(BRK);
        MRB_ASSERT(MRB_INTEGER_P(TARGET));
        A = (UINT32_T)MRB_INTEGER(TARGET);
        MRB_ASSERT(A >= 0 && A < IREP->ILEN);
      }
      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {
        CH = CATCH_HANDLER_FIND(MRB, MRB->C->CI, PC, MRB_CATCH_FILTER_ENSURE);
        IF (CH) {
          /* AVOIDING A JUMP FROM A CATCH HANDLER INTO THE SAME HANDLER */
          IF (A < MRB_IREP_CATCH_HANDLER_UNPACK(CH->BEGIN) || A >= MRB_IREP_CATCH_HANDLER_UNPACK(CH->END)) {
            THROW_TAGGED_BREAK(MRB, RBREAK_TAG_JUMP, PROC, MRB_FIXNUM_VALUE(A));
          }
        }
      }
      CHECKPOINT_END(RBREAK_TAG_JUMP);

      MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
      PC = IREP->ISEQ + A;
      JUMP;
    }

    CASE(OP_EXCEPT, B) {
      MRB_VALUE EXC;

      IF (MRB->EXC == NULL) {
        EXC = MRB_NIL_VALUE();
      }
      ELSE {
        SWITCH (MRB->EXC->TT) {
        CASE MRB_TT_BREAK:
        CASE MRB_TT_EXCEPTION:
          EXC = MRB_OBJ_VALUE(MRB->EXC);
          BREAK;
        DEFAULT:
          MRB_ASSERT(!"BAD MRB_TYPE");
          EXC = MRB_NIL_VALUE();
          BREAK;
        }
        MRB->EXC = NULL;
      }
      REGS[A] = EXC;
      NEXT;
    }
    CASE(OP_RESCUE, BB) {
      MRB_VALUE EXC = REGS[A];  /* EXC ON STACK */
      MRB_VALUE E = REGS[B];
      STRUCT RCLASS *EC;

      SWITCH (MRB_TYPE(E)) {
      CASE MRB_TT_CLASS:
      CASE MRB_TT_MODULE:
        BREAK;
      DEFAULT:
        {
          MRB_VALUE EXC;

          EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                    "CLASS OR MODULE REQUIRED FOR RESCUE CLAUSE");
          MRB_EXC_SET(MRB, EXC);
          GOTO L_RAISE;
        }
      }
      EC = MRB_CLASS_PTR(E);
      REGS[B] = MRB_BOOL_VALUE(MRB_OBJ_IS_KIND_OF(MRB, EXC, EC));
      NEXT;
    }

    CASE(OP_RAISEIF, B) {
      MRB_VALUE EXC = REGS[A];
      IF (MRB_BREAK_P(EXC)) {
        MRB->EXC = MRB_OBJ_PTR(EXC);
        GOTO L_BREAK;
      }
      MRB_EXC_SET(MRB, EXC);
      IF (MRB->EXC) {
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_SSEND, BBB) {
      REGS[A] = REGS[0];
      INSN = OP_SEND;
    }
    GOTO L_SENDB;

    CASE(OP_SSENDB, BBB) {
      REGS[A] = REGS[0];
    }
    GOTO L_SENDB;

    CASE(OP_SEND, BBB)
    GOTO L_SENDB;

    L_SEND_SYM:
    C = 1;
    /* PUSH NIL AFTER ARGUMENTS */
    SET_NIL_VALUE(REGS[A+2]);
    GOTO L_SENDB_SYM;

    CASE(OP_SENDB, BBB)
    L_SENDB:
    MID = SYMS[B];
    L_SENDB_SYM:
    {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_VALUE RECV, BLK;

      ARGUMENT_NORMALIZE(A, &C, INSN);

      RECV = REGS[A];
      CLS = MRB_CLASS(MRB, RECV);
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &C, BLK, 0);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, C);

      IF (MRB_METHOD_CFUNC_P(M)) {
        IF (MRB_METHOD_PROC_P(M)) {
          STRUCT RPROC *P = MRB_METHOD_PROC(M);

          MRB_VM_CI_PROC_SET(CI, P);
          RECV = P->BODY.FUNC(MRB, RECV);
        }
        ELSE {
          IF (MRB_METHOD_NOARG_P(M)) {
            CHECK_METHOD_NOARG(MRB, CI);
          }
          RECV = MRB_METHOD_FUNC(M)(MRB, RECV);
        }
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);
          IF (P && !MRB_PROC_STRICT_P(P) && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
        IF (!CI->U.TARGET_CLASS) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN RECV;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        CI->STACK[0] = RECV;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
    }
    JUMP;

    CASE(OP_CALL, Z) {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV = CI->STACK[0];
      STRUCT RPROC *M = MRB_PROC_PTR(RECV);

      /* REPLACE CALLINFO */
      CI->U.TARGET_CLASS = MRB_PROC_TARGET_CLASS(M);
      MRB_VM_CI_PROC_SET(CI, M);
      IF (MRB_PROC_ENV_P(M)) {
        CI->MID = MRB_PROC_ENV(M)->MID;
      }

      /* PREPARE STACK */
      IF (MRB_PROC_CFUNC_P(M)) {
        RECV = MRB_PROC_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
        CI[1].STACK[0] = RECV;
        IREP = MRB->C->CI->PROC->BODY.IREP;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        PROC = M;
        IREP = M->BODY.IREP;
        IF (!IREP) {
          MRB->C->CI->STACK[0] = MRB_NIL_VALUE();
          A = 0;
          C = OP_R_NORMAL;
          GOTO L_OP_RETURN_BODY;
        }
        MRB_INT NARGS = MRB_CI_BIDX(CI)+1;
        IF (NARGS < IREP->NREGS) {
          MRB_STACK_EXTEND(MRB, IREP->NREGS);
          STACK_CLEAR(REGS+NARGS, IREP->NREGS-NARGS);
        }
        IF (MRB_PROC_ENV_P(M)) {
          REGS[0] = MRB_PROC_ENV(M)->STACK[0];
        }
        PC = IREP->ISEQ;
      }
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      JUMP;
    }

    CASE(OP_SUPER, BB) {
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV, BLK;
      CONST STRUCT RPROC *P = CI->PROC;
      MRB_SYM MID = CI->MID;
      STRUCT RCLASS* TARGET_CLASS = MRB_PROC_TARGET_CLASS(P);

      IF (MRB_PROC_ENV_P(P) && P->E.ENV->MID && P->E.ENV->MID != MID) { /* ALIAS SUPPORT */
        MID = P->E.ENV->MID;    /* RESTORE OLD MID */
      }

      IF (MID == 0 || !TARGET_CLASS) {
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (TARGET_CLASS->FLAGS & MRB_FL_CLASS_IS_PREPENDED) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
      }
      ELSE IF (TARGET_CLASS->TT == MRB_TT_MODULE) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
        IF (TARGET_CLASS->TT != MRB_TT_ICLASS) {
          GOTO SUPER_TYPEERROR;
        }
      }
      RECV = REGS[0];
      IF (!MRB_OBJ_IS_KIND_OF(MRB, RECV, TARGET_CLASS)) {
      SUPER_TYPEERROR: ;
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                            "SELF HAS WRONG TYPE TO CALL SUPER IN THIS CONTEXT");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }

      ARGUMENT_NORMALIZE(A, &B, OP_SUPER);

      CLS = TARGET_CLASS->SUPER;
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &B, BLK, 1);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, B);

      /* PREPARE STACK */
      CI->STACK[0] = RECV;

      IF (MRB_METHOD_CFUNC_P(M)) {
        MRB_VALUE V;

        IF (MRB_METHOD_PROC_P(M)) {
          MRB_VM_CI_PROC_SET(CI, MRB_METHOD_PROC(M));
        }
        V = MRB_METHOD_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_RESTORE(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        MRB_ASSERT(!MRB_BREAK_P(V));
        IF (!MRB_VM_CI_TARGET_CLASS(CI)) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN V;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        MRB->C->CI->STACK[0] = V;
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
      JUMP;
    }

    CASE(OP_ARGARY, BS) {
      MRB_INT M1 = (B>>11)&0X3F;
      MRB_INT R  = (B>>10)&0X1;
      MRB_INT M2 = (B>>5)&0X1F;
      MRB_INT KD = (B>>4)&0X1;
      MRB_INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (MRB->C->CI->MID == 0 || MRB_VM_CI_TARGET_CLASS(MRB->C->CI) == NULL) {
        MRB_VALUE EXC;

      L_NOSUPER:
        EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E) GOTO L_NOSUPER;
        IF (MRB_ENV_LEN(E) <= M1+R+M2+1)
          GOTO L_NOSUPER;
        STACK = E->STACK + 1;
      }
      IF (R == 0) {
        REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, M1+M2, STACK);
      }
      ELSE {
        MRB_VALUE *PP = NULL;
        STRUCT RARRAY *REST;
        MRB_INT LEN = 0;

        IF (MRB_ARRAY_P(STACK[M1])) {
          STRUCT RARRAY *ARY = MRB_ARY_PTR(STACK[M1]);

          PP = ARY_PTR(ARY);
          LEN = ARY_LEN(ARY);
        }
        REGS[A] = MRB_ARY_NEW_CAPA(MRB, M1+LEN+M2);
        REST = MRB_ARY_PTR(REGS[A]);
        IF (M1 > 0) {
          STACK_COPY(ARY_PTR(REST), STACK, M1);
        }
        IF (LEN > 0) {
          STACK_COPY(ARY_PTR(REST)+M1, PP, LEN);
        }
        IF (M2 > 0) {
          STACK_COPY(ARY_PTR(REST)+M1+LEN, STACK+M1+1, M2);
        }
        ARY_SET_LEN(REST, M1+LEN+M2);
      }
      IF (KD) {
        REGS[A+1] = STACK[M1+R+M2];
        REGS[A+2] = STACK[M1+R+M2+1];
      }
      ELSE {
        REGS[A+1] = STACK[M1+R+M2];
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ENTER, W) {
      MRB_INT M1 = MRB_ASPEC_REQ(A);
      MRB_INT O  = MRB_ASPEC_OPT(A);
      MRB_INT R  = MRB_ASPEC_REST(A);
      MRB_INT M2 = MRB_ASPEC_POST(A);
      MRB_INT KD = (MRB_ASPEC_KEY(A) > 0 || MRB_ASPEC_KDICT(A))? 1 : 0;
      /* UNUSED
      INT B  = MRB_ASPEC_BLOCK(A);
      */
      MRB_INT CONST LEN = M1 + O + R + M2;

      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_INT ARGC = CI->N;
      MRB_VALUE *ARGV = REGS+1;
      MRB_VALUE * CONST ARGV0 = ARGV;
      MRB_INT CONST KW_POS = LEN + KD;    /* WHERE KWHASH SHOULD BE */
      MRB_INT CONST BLK_POS = KW_POS + 1; /* WHERE BLOCK SHOULD BE */
      MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];
      MRB_VALUE KDICT = MRB_NIL_VALUE();

      /* KEYWORD ARGUMENTS */
      IF (CI->NK > 0) {
        MRB_INT KIDX = MRB_CI_KIDX(CI);
        KDICT = REGS[KIDX];
        IF (!MRB_HASH_P(KDICT) || MRB_HASH_SIZE(MRB, KDICT) == 0) {
          KDICT = MRB_NIL_VALUE();
          CI->NK = 0;
        }
      }
      IF (!KD && !MRB_NIL_P(KDICT)) {
        IF (ARGC < 14) {
          CI->N++;
          ARGC++;    /* INCLUDE KDICT IN NORMAL ARGUMENTS */
        }
        ELSE IF (ARGC == 14) {
          /* PACK ARGUMENTS AND KDICT */
          REGS[1] = MRB_ARY_NEW_FROM_VALUES(MRB, ARGC+1, &REGS[1]);
          ARGC = CI->N = 15;
        }
        ELSE {/* ARGC == 15 */
          /* PUSH KDICT TO PACKED ARGUMENTS */
          MRB_ARY_PUSH(MRB, REGS[1], REGS[2]);
        }
        CI->NK = 0;
      }
      IF (KD && MRB_ASPEC_KEY(A) > 0 && MRB_HASH_P(KDICT)) {
        KDICT = MRB_HASH_DUP(MRB, KDICT);
      }

      /* ARGUMENTS IS PASSED WITH ARRAY */
      IF (ARGC == 15) {
        STRUCT RARRAY *ARY = MRB_ARY_PTR(REGS[1]);
        ARGV = ARY_PTR(ARY);
        ARGC = (INT)ARY_LEN(ARY);
        MRB_GC_PROTECT(MRB, REGS[1]);
      }

      /* STRICT ARGUMENT CHECK */
      IF (CI->PROC && MRB_PROC_STRICT_P(CI->PROC)) {
        IF (ARGC < M1 + M2 || (R == 0 && ARGC > LEN)) {
          ARGNUM_ERROR(MRB, M1+M2);
          GOTO L_RAISE;
        }
      }
      /* EXTRACT FIRST ARGUMENT ARRAY TO ARGUMENTS */
      ELSE IF (LEN > 1 && ARGC == 1 && MRB_ARRAY_P(ARGV[0])) {
        MRB_GC_PROTECT(MRB, ARGV[0]);
        ARGC = (INT)RARRAY_LEN(ARGV[0]);
        ARGV = RARRAY_PTR(ARGV[0]);
      }

      /* REST ARGUMENTS */
      MRB_VALUE REST = MRB_NIL_VALUE();
      IF (ARGC < LEN) {
        MRB_INT MLEN = M2;
        IF (ARGC < M1+M2) {
          MLEN = M1 < ARGC ? ARGC - M1 : 0;
        }

        /* COPY MANDATORY AND OPTIONAL ARGUMENTS */
        IF (ARGV0 != ARGV && ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, ARGC-MLEN); /* M1 + O */
        }
        IF (ARGC < M1) {
          STACK_CLEAR(&REGS[ARGC+1], M1-ARGC);
        }
        /* COPY POST MANDATORY ARGUMENTS */
        IF (MLEN) {
          VALUE_MOVE(&REGS[LEN-M2+1], &ARGV[ARGC-MLEN], MLEN);
        }
        IF (MLEN < M2) {
          STACK_CLEAR(&REGS[LEN-M2+MLEN+1], M2-MLEN);
        }
        /* INITIALIZE REST ARGUMENTS WITH EMPTY ARRAY */
        IF (R) {
          REST = MRB_ARY_NEW_CAPA(MRB, 0);
          REGS[M1+O+1] = REST;
        }
        /* SKIP INITIALIZER OF PASSED ARGUMENTS */
        IF (O > 0 && ARGC > M1+M2)
          PC += (ARGC - M1 - M2)*3;
      }
      ELSE {
        MRB_INT RNUM = 0;
        IF (ARGV0 != ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, M1+O);
        }
        IF (R) {
          RNUM = ARGC-M1-O-M2;
          REST = MRB_ARY_NEW_FROM_VALUES(MRB, RNUM, ARGV+M1+O);
          REGS[M1+O+1] = REST;
        }
        IF (M2 > 0 && ARGC-M2 > M1) {
          VALUE_MOVE(&REGS[M1+O+R+1], &ARGV[M1+O+RNUM], M2);
        }
        PC += O*3;
      }

      /* NEED TO BE UPDATE BLK FIRST TO PROTECT BLK FROM GC */
      REGS[BLK_POS] = BLK;              /* MOVE BLOCK */
      IF (KD) {
        IF (MRB_NIL_P(KDICT))
          KDICT = MRB_HASH_NEW_CAPA(MRB, 0);
        REGS[KW_POS] = KDICT;           /* SET KWHASH */
      }

      /* FORMAT ARGUMENTS FOR GENERATED CODE */
      MRB->C->CI->N = LEN;

      /* CLEAR LOCAL (BUT NON-ARGUMENT) VARIABLES */
      IF (IREP->NLOCALS-BLK_POS-1 > 0) {
        STACK_CLEAR(&REGS[BLK_POS+1], IREP->NLOCALS-BLK_POS-1);
      }
      JUMP;
    }

    CASE(OP_KARG, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;

      IF (KIDX < 0 || !MRB_HASH_P(KDICT=REGS[KIDX]) || !MRB_HASH_KEY_P(MRB, KDICT, K)) {
        MRB_VALUE STR = MRB_FORMAT(MRB, "MISSING KEYWORD: %V", K);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      REGS[A] = MRB_HASH_GET(MRB, KDICT, K);
      MRB_HASH_DELETE_KEY(MRB, KDICT, K);
      NEXT;
    }

    CASE(OP_KEY_P, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;
      MRB_BOOL KEY_P = FALSE;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX])) {
        KEY_P = MRB_HASH_KEY_P(MRB, KDICT, K);
      }
      REGS[A] = MRB_BOOL_VALUE(KEY_P);
      NEXT;
    }

    CASE(OP_KEYEND, Z) {
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX]) && !MRB_HASH_EMPTY_P(MRB, KDICT)) {
        MRB_VALUE KEYS = MRB_HASH_KEYS(MRB, KDICT);
        MRB_VALUE KEY1 = RARRAY_PTR(KEYS)[0];
        MRB_VALUE STR = MRB_FORMAT(MRB, "UNKNOWN KEYWORD: %V", KEY1);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_BREAK, B) {
      C = OP_R_BREAK;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN_BLK, B) {
      C = OP_R_RETURN;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN, B)
    C = OP_R_NORMAL;
    L_RETURN:
    {
      MRB_CALLINFO *CI;

      CI = MRB->C->CI;
      IF (CI->MID) {
        MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];

        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);

          IF (!MRB_PROC_STRICT_P(P) &&
              CI > MRB->C->CIBASE && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
      }

      IF (MRB->EXC) {
      L_RAISE:
        CI = MRB->C->CI;
        IF (CI == MRB->C->CIBASE) {
          CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
          IF (CH == NULL) GOTO L_FTOP;
          GOTO L_CATCH;
        }
        WHILE ((CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL)) == NULL) {
          CI = CIPOP(MRB);
          IF (CI[1].CCI == CINFO_SKIP && PREV_JMP) {
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          PC = CI[0].PC;
          IF (CI == MRB->C->CIBASE) {
            CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
            IF (CH == NULL) {
            L_FTOP:             /* FIBER TOP */
              IF (MRB->C == MRB->ROOT_C) {
                MRB->C->CI->STACK = MRB->C->STBASE;
                GOTO L_STOP;
              }
              ELSE {
                STRUCT MRB_CONTEXT *C = MRB->C;

                C->STATUS = MRB_FIBER_TERMINATED;
                MRB->C = C->PREV;
                C->PREV = NULL;
                GOTO L_RAISE;
              }
            }
            BREAK;
          }
        }
      L_CATCH:
        IF (CH == NULL) GOTO L_STOP;
        IF (FALSE) {
        L_CATCH_TAGGED_BREAK: /* FROM THROW_TAGGED_BREAK() OR UNWIND_ENSURE() */
          CI = MRB->C->CI;
        }
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, IREP->NREGS);
        PC = IREP->ISEQ + MRB_IREP_CATCH_HANDLER_UNPACK(CH->TARGET);
      }
      ELSE {
        MRB_INT ACC;
        MRB_VALUE V;

        CI = MRB->C->CI;
        V = REGS[A];
        MRB_GC_PROTECT(MRB, V);
        SWITCH (C) {
        CASE OP_R_RETURN:
          /* FALL THROUGH TO OP_R_NORMAL OTHERWISE */
          IF (CI->CCI == CINFO_NONE && MRB_PROC_ENV_P(PROC) && !MRB_PROC_STRICT_P(PROC)) {
            CONST STRUCT RPROC *DST;
            MRB_CALLINFO *CIBASE;
            CIBASE = MRB->C->CIBASE;
            DST = TOP_PROC(MRB, PROC);

            IF (MRB_PROC_ENV_P(DST)) {
              STRUCT RENV *E = MRB_PROC_ENV(DST);

              IF (!MRB_ENV_ONSTACK_P(E) || (E->CXT && E->CXT != MRB->C)) {
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
            }
            /* CHECK JUMP DESTINATION */
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              IF (CI->CCI > CINFO_NONE) { /* JUMP CROSS C BOUNDARY */
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
              CI--;
            }
            IF (CI <= CIBASE) { /* NO JUMP DESTINATION */
              LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
              GOTO L_RAISE;
            }
            CI = MRB->C->CI;
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {
                CIBASE = MRB->C->CIBASE;
                DST = TOP_PROC(MRB, PROC);
              }
              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {
                UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_BLOCK, PROC, V);
              }
              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);
              CI = CIPOP(MRB);
              PC = CI->PC;
            }
            PROC = CI->PROC;
            MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
            BREAK;
          }
          /* FALLTHROUGH */
        CASE OP_R_NORMAL:
        NORMAL_RETURN:
          IF (CI == MRB->C->CIBASE) {
            STRUCT MRB_CONTEXT *C;
            C = MRB->C;

            IF (!C->PREV) { /* TOPLEVEL RETURN */
              REGS[IREP->NLOCALS] = V;
              GOTO CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);
            }
            IF (!C->VMEXEC && C->PREV->CI == C->PREV->CIBASE) {
              MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_FIBER_ERROR, "DOUBLE RESUME");
              MRB_EXC_SET(MRB, EXC);
              GOTO L_RAISE;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {
              C = MRB->C;
            }
            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_TOPLEVEL, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);
            /* AUTOMATIC YIELD AT THE END */
            C->STATUS = MRB_FIBER_TERMINATED;
            MRB->C = C->PREV;
            MRB->C->STATUS = MRB_FIBER_RUNNING;
            C->PREV = NULL;
            IF (C->VMEXEC) {
              MRB_GC_ARENA_RESTORE(MRB, AI);
              C->VMEXEC = FALSE;
              MRB->JMP = PREV_JMP;
              RETURN V;
            }
            CI = MRB->C->CI;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_RETURN);
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        CASE OP_R_BREAK:
          IF (MRB_PROC_STRICT_P(PROC)) GOTO NORMAL_RETURN;
          IF (MRB_PROC_ORPHAN_P(PROC)) {
            MRB_VALUE EXC;

          L_BREAK_ERROR:
            EXC = MRB_EXC_NEW_LIT(MRB, E_LOCALJUMP_ERROR,
                                      "BREAK FROM PROC-CLOSURE");
            MRB_EXC_SET(MRB, EXC);
            GOTO L_RAISE;
          }
          IF (!MRB_PROC_ENV_P(PROC) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(PROC))) {
            GOTO L_BREAK_ERROR;
          }
          ELSE {
            STRUCT RENV *E = MRB_PROC_ENV(PROC);

            IF (E->CXT != MRB->C) {
              GOTO L_BREAK_ERROR;
            }
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK);
          /* BREAK FROM FIBER BLOCK */
          IF (CI == MRB->C->CIBASE && CI->PC) {
            STRUCT MRB_CONTEXT *C = MRB->C;

            MRB->C = C->PREV;
            C->PREV = NULL;
            CI = MRB->C->CI;
          }
          IF (CI->CCI > CINFO_NONE) {
            CI = CIPOP(MRB);
            MRB_GC_ARENA_RESTORE(MRB, AI);
            MRB->C->VMEXEC = FALSE;
            MRB->EXC = (STRUCT ROBJECT*)BREAK_NEW(MRB, RBREAK_TAG_BREAK, PROC, V);
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          IF (FALSE) {
            STRUCT RBREAK *BRK;

          L_BREAK:
            BRK = (STRUCT RBREAK*)MRB->EXC;
            PROC = MRB_BREAK_PROC_GET(BRK);
            V = MRB_BREAK_VALUE_GET(BRK);
            CI = MRB->C->CI;

            SWITCH (MRB_BREAK_TAG_GET(BRK)) {
#DEFINE DISPATCH_CHECKPOINTS(N, I) CASE N: GOTO CHECKPOINT_LABEL_MAKE(N);
              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)
#UNDEF DISPATCH_CHECKPOINTS
              DEFAULT:
                MRB_ASSERT(!"WRONG BREAK TAG");
            }
          }
          WHILE (MRB->C->CIBASE < CI && CI[-1].PROC != PROC->UPPER) {
            IF (CI[-1].CCI == CINFO_SKIP) {
              GOTO L_BREAK_ERROR;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {
              /* DO NOTHING */
            }
            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_UPPER, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);
            CI = CIPOP(MRB);
            PC = CI->PC;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_INTARGET, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);
          IF (CI == MRB->C->CIBASE) {
            GOTO L_BREAK_ERROR;
          }
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        DEFAULT:
          /* CANNOT HAPPEN */
          BREAK;
        }
        MRB_ASSERT(CI == MRB->C->CI);
        MRB_ASSERT(MRB->EXC == NULL);

        IF (MRB->C->VMEXEC && !MRB_VM_CI_TARGET_CLASS(CI)) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->C->VMEXEC = FALSE;
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        ACC = CI->CCI;
        CI = CIPOP(MRB);
        IF (ACC == CINFO_SKIP || ACC == CINFO_DIRECT) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        PC = CI->PC;
        DEBUG(FPRINTF(STDERR, "FROM :%S\N", MRB_SYM_NAME(MRB, CI->MID)));
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;

        CI[1].STACK[0] = V;
        MRB_GC_ARENA_RESTORE(MRB, AI);
      }
      JUMP;
    }

    CASE(OP_BLKPUSH, BS) {
      INT M1 = (B>>11)&0X3F;
      INT R  = (B>>10)&0X1;
      INT M2 = (B>>5)&0X1F;
      INT KD = (B>>4)&0X1;
      INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E || (!MRB_ENV_ONSTACK_P(E) && E->MID == 0) ||
            MRB_ENV_LEN(E) <= M1+R+M2+1) {
          LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
          GOTO L_RAISE;
        }
        STACK = E->STACK + 1;
      }
      IF (MRB_NIL_P(STACK[M1+R+M2+KD])) {
        LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
        GOTO L_RAISE;
      }
      REGS[A] = STACK[M1+R+M2+KD];
      NEXT;
    }

  L_INT_OVERFLOW:
    {
      MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_RANGE_ERROR, "INTEGER OVERFLOW");
      MRB_EXC_SET(MRB, EXC);
    }
    GOTO L_RAISE;

#DEFINE TYPES2(A,B) ((((UINT16_T)(A))<<8)|(((UINT16_T)(B))&0XFF))
#DEFINE OP_MATH(OP_NAME)                                                    \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {                  \
    OP_MATH_CASE_INTEGER(OP_NAME);                                          \
    OP_MATH_CASE_FLOAT(OP_NAME, INTEGER, FLOAT);                            \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  INTEGER);                           \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  FLOAT);                             \
    OP_MATH_CASE_STRING_##OP_NAME();                                        \
    DEFAULT:                                                                \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATH_CASE_INTEGER(OP_NAME)                                       \
  CASE TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = MRB_INTEGER(REGS[A+1]), Z;      \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z))                           \
        OP_MATH_OVERFLOW_INT();                                             \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2) (VOID)0
#ELSE
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2)                                     \
  CASE TYPES2(OP_MATH_TT_##T1, OP_MATH_TT_##T2):                                \
    {                                                                           \
      MRB_FLOAT Z = MRB_##T1(REGS[A]) OP_MATH_OP_##OP_NAME MRB_##T2(REGS[A+1]); \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                         \
    }                                                                           \
    BREAK
#ENDIF
#DEFINE OP_MATH_OVERFLOW_INT() GOTO L_INT_OVERFLOW
#DEFINE OP_MATH_CASE_STRING_ADD()                                           \
  CASE TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \
    REGS[A] = MRB_STR_PLUS(MRB, REGS[A], REGS[A+1]);                        \
    MRB_GC_ARENA_RESTORE(MRB, AI);                                          \
    BREAK
#DEFINE OP_MATH_CASE_STRING_SUB() (VOID)0
#DEFINE OP_MATH_CASE_STRING_MUL() (VOID)0
#DEFINE OP_MATH_OP_ADD +
#DEFINE OP_MATH_OP_SUB -
#DEFINE OP_MATH_OP_MUL *
#DEFINE OP_MATH_TT_INTEGER MRB_TT_INTEGER
#DEFINE OP_MATH_TT_FLOAT   MRB_TT_FLOAT

    CASE(OP_ADD, B) {
      OP_MATH(ADD);
    }

    CASE(OP_SUB, B) {
      OP_MATH(SUB);
    }

    CASE(OP_MUL, B) {
      OP_MATH(MUL);
    }

    CASE(OP_DIV, B) {
#IFNDEF MRB_NO_FLOAT
      MRB_FLOAT X, Y, F;
#ENDIF

      /* NEED TO CHECK IF OP IS OVERRIDDEN */
      SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):
        {
          MRB_INT X = MRB_INTEGER(REGS[A]);
          MRB_INT Y = MRB_INTEGER(REGS[A+1]);
          MRB_INT DIV = MRB_DIV_INT(MRB, X, Y);
          SET_INT_VALUE(MRB, REGS[A], DIV);
        }
        NEXT;
#IFNDEF MRB_NO_FLOAT
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):
        X = (MRB_FLOAT)MRB_INTEGER(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):
        X = MRB_FLOAT(REGS[A]);
        Y = (MRB_FLOAT)MRB_INTEGER(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
        X = MRB_FLOAT(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
#ENDIF
      DEFAULT:
        MID = MRB_OPSYM(DIV);
        GOTO L_SEND_SYM;
      }

#IFNDEF MRB_NO_FLOAT
      F = MRB_DIV_FLOAT(X, Y);
      SET_FLOAT_VALUE(MRB, REGS[A], F);
#ENDIF
      NEXT;
    }

#DEFINE OP_MATHI(OP_NAME)                                                   \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (MRB_TYPE(REGS[A])) {                                              \
    OP_MATHI_CASE_INTEGER(OP_NAME);                                         \
    OP_MATHI_CASE_FLOAT(OP_NAME);                                           \
    DEFAULT:                                                                \
      SET_INT_VALUE(MRB,REGS[A+1], B);                                      \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATHI_CASE_INTEGER(OP_NAME)                                      \
  CASE MRB_TT_INTEGER:                                                      \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = (MRB_INT)B, Z;                  \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z))                           \
        OP_MATH_OVERFLOW_INT();                                             \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME) (VOID)0
#ELSE
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME)                                        \
  CASE MRB_TT_FLOAT:                                                        \
    {                                                                       \
      MRB_FLOAT Z = MRB_FLOAT(REGS[A]) OP_MATH_OP_##OP_NAME B;              \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                     \
    }                                                                       \
    BREAK
#ENDIF

    CASE(OP_ADDI, BB) {
      OP_MATHI(ADD);
    }

    CASE(OP_SUBI, BB) {
      OP_MATHI(SUB);
    }

#DEFINE OP_CMP_BODY(OP,V1,V2) (V1(REGS[A]) OP V2(REGS[A+1]))

#IFDEF MRB_NO_FLOAT
#DEFINE OP_CMP(OP,SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ELSE
#DEFINE OP_CMP(OP, SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FLOAT);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FLOAT);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ENDIF

    CASE(OP_EQ, B) {
      IF (MRB_OBJ_EQ(MRB, REGS[A], REGS[A+1])) {
        SET_TRUE_VALUE(REGS[A]);
      }
      ELSE {
        OP_CMP(==,EQ);
      }
      NEXT;
    }

    CASE(OP_LT, B) {
      OP_CMP(<,LT);
      NEXT;
    }

    CASE(OP_LE, B) {
      OP_CMP(<=,LE);
      NEXT;
    }

    CASE(OP_GT, B) {
      OP_CMP(>,GT);
      NEXT;
    }

    CASE(OP_GE, B) {
      OP_CMP(>=,GE);
      NEXT;
    }

    CASE(OP_ARRAY, BB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, B, &REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_ARRAY2, BBB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, C, &REGS[B]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYCAT, B) {
      MRB_VALUE SPLAT = MRB_ARY_SPLAT(MRB, REGS[A+1]);
      IF (MRB_NIL_P(REGS[A])) {
        REGS[A] = SPLAT;
      }
      ELSE {
        MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
        MRB_ARY_CONCAT(MRB, REGS[A], SPLAT);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYPUSH, BB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      FOR (MRB_INT I=0; I<B; I++) {
        MRB_ARY_PUSH(MRB, REGS[A], REGS[A+I+1]);
      }
      NEXT;
    }

    CASE(OP_ARYDUP, B) {
      MRB_VALUE ARY = REGS[A];
      IF (MRB_ARRAY_P(ARY)) {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, RARRAY_LEN(ARY), RARRAY_PTR(ARY));
      }
      ELSE {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &ARY);
      }
      REGS[A] = ARY;
      NEXT;
    }

    CASE(OP_AREF, BBB) {
      MRB_VALUE V = REGS[B];

      IF (!MRB_ARRAY_P(V)) {
        IF (C == 0) {
          REGS[A] = V;
        }
        ELSE {
          SET_NIL_VALUE(REGS[A]);
        }
      }
      ELSE {
        V = MRB_ARY_REF(MRB, V, C);
        REGS[A] = V;
      }
      NEXT;
    }

    CASE(OP_ASET, BBB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      MRB_ARY_SET(MRB, REGS[B], C, REGS[A]);
      NEXT;
    }

    CASE(OP_APOST, BBB) {
      MRB_VALUE V = REGS[A];
      INT PRE  = B;
      INT POST = C;
      STRUCT RARRAY *ARY;
      INT LEN, IDX;

      IF (!MRB_ARRAY_P(V)) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &REGS[A]);
      }
      ARY = MRB_ARY_PTR(V);
      LEN = (INT)ARY_LEN(ARY);
      IF (LEN > PRE + POST) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, LEN - PRE - POST, ARY_PTR(ARY)+PRE);
        REGS[A++] = V;
        WHILE (POST--) {
          REGS[A++] = ARY_PTR(ARY)[LEN-POST-1];
        }
      }
      ELSE {
        V = MRB_ARY_NEW_CAPA(MRB, 0);
        REGS[A++] = V;
        FOR (IDX=0; IDX+PRE<LEN; IDX++) {
          REGS[A+IDX] = ARY_PTR(ARY)[PRE+IDX];
        }
        WHILE (IDX < POST) {
          SET_NIL_VALUE(REGS[A+IDX]);
          IDX++;
        }
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_INTERN, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_SYM SYM = MRB_INTERN_STR(MRB, REGS[A]);
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_SYMBOL, BB) {
      SIZE_T LEN;
      MRB_SYM SYM;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        SYM = MRB_INTERN_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        SYM  = MRB_INTERN(MRB, POOL[B].U.STR, LEN);
      }
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_STRING, BB) {
      MRB_INT LEN;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        REGS[A] = MRB_STR_NEW_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        REGS[A] = MRB_STR_NEW(MRB, POOL[B].U.STR, LEN);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_STRCAT, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_STR_CONCAT(MRB, REGS[A], REGS[A+1]);
      NEXT;
    }

    CASE(OP_HASH, BB) {
      MRB_VALUE HASH = MRB_HASH_NEW_CAPA(MRB, B);
      INT I;
      INT LIM = A+B*2;

      FOR (I=A; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      REGS[A] = HASH;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_HASHADD, BB) {
      MRB_VALUE HASH;
      INT I;
      INT LIM = A+B*2+1;

      HASH = REGS[A];
      MRB_ENSURE_HASH_TYPE(MRB, HASH);
      FOR (I=A+1; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_HASHCAT, B) {
      MRB_VALUE HASH = REGS[A];

      MRB_ASSERT(MRB_HASH_P(HASH));
      MRB_HASH_MERGE(MRB, HASH, REGS[A+1]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_LAMBDA, BB)
    C = OP_L_LAMBDA;
    L_MAKE_LAMBDA:
    {
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      IF (C & OP_L_CAPTURE) {
        P = MRB_CLOSURE_NEW(MRB, NIREP);
      }
      ELSE {
        P = MRB_PROC_NEW(MRB, NIREP);
        P->FLAGS |= MRB_PROC_SCOPE;
      }
      IF (C & OP_L_STRICT) P->FLAGS |= MRB_PROC_STRICT;
      REGS[A] = MRB_OBJ_VALUE(P);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_BLOCK, BB) {
      C = OP_L_BLOCK;
      GOTO L_MAKE_LAMBDA;
    }
    CASE(OP_METHOD, BB) {
      C = OP_L_METHOD;
      GOTO L_MAKE_LAMBDA;
    }

    CASE(OP_RANGE_INC, B) {
      REGS[A] = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], FALSE);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      REGS[A] = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], TRUE);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_OCLASS, B) {
      REGS[A] = MRB_OBJ_VALUE(MRB->OBJECT_CLASS);
      NEXT;
    }

    CASE(OP_CLASS, BB) {
      STRUCT RCLASS *C = 0, *BASECLASS;
      MRB_VALUE BASE, SUPER;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      SUPER = REGS[A+1];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      C = MRB_VM_DEFINE_CLASS(MRB, BASE, SUPER, ID);
      REGS[A] = MRB_OBJ_VALUE(C);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_MODULE, BB) {
      STRUCT RCLASS *CLS = 0, *BASECLASS;
      MRB_VALUE BASE;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      CLS = MRB_VM_DEFINE_MODULE(MRB, BASE, ID);
      REGS[A] = MRB_OBJ_VALUE(CLS);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_EXEC, BB)
    {
      MRB_VALUE RECV = REGS[A];
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      /* PREPARE CLOSURE */
      P = MRB_PROC_NEW(MRB, NIREP);
      P->C = NULL;
      MRB_FIELD_WRITE_BARRIER(MRB, (STRUCT RBASIC*)P, (STRUCT RBASIC*)PROC);
      MRB_PROC_SET_TARGET_CLASS(P, MRB_CLASS_PTR(RECV));
      P->FLAGS |= MRB_PROC_SCOPE;

      /* PREPARE CALL STACK */
      CIPUSH(MRB, A, 0, MRB_CLASS_PTR(RECV), P, 0, 0);

      IREP = P->BODY.IREP;
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      MRB_STACK_EXTEND(MRB, IREP->NREGS);
      STACK_CLEAR(REGS+1, IREP->NREGS-1);
      PC = IREP->ISEQ;
      JUMP;
    }

    CASE(OP_DEF, BB) {
      STRUCT RCLASS *TARGET = MRB_CLASS_PTR(REGS[A]);
      STRUCT RPROC *P = MRB_PROC_PTR(REGS[A+1]);
      MRB_METHOD_T M;
      MRB_SYM MID = SYMS[B];

      MRB_METHOD_FROM_PROC(M, P);
      MRB_DEFINE_METHOD_RAW(MRB, TARGET, MID, M);
      MRB_METHOD_ADDED(MRB, TARGET, MID);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      REGS[A] = MRB_SYMBOL_VALUE(MID);
      NEXT;
    }

    CASE(OP_SCLASS, B) {
      REGS[A] = MRB_SINGLETON_CLASS(MRB, REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_TCLASS, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);
      IF (!TARGET) GOTO L_RAISE;
      REGS[A] = MRB_OBJ_VALUE(TARGET);
      NEXT;
    }

    CASE(OP_ALIAS, BB) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_ALIAS_METHOD(MRB, TARGET, SYMS[A], SYMS[B]);
      MRB_METHOD_ADDED(MRB, TARGET, SYMS[A]);
      NEXT;
    }
    CASE(OP_UNDEF, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_UNDEF_METHOD_ID(MRB, TARGET, SYMS[A]);
      NEXT;
    }

    CASE(OP_DEBUG, Z) {
      FETCH_BBB();
#IFDEF MRB_USE_DEBUG_HOOK
      MRB->DEBUG_OP_HOOK(MRB, IREP, PC, REGS);
#ELSE
#IFNDEF MRB_NO_STDIO
      PRINTF("OP_DEBUG %D %D %D\N", A, B, C);
#ELSE
      ABORT();
#ENDIF
#ENDIF
      NEXT;
    }

    CASE(OP_ERR, B) {
      SIZE_T LEN = POOL[A].TT >> 2;
      MRB_VALUE EXC;

      MRB_ASSERT((POOL[A].TT&IREP_TT_NFLAG)==0);
      EXC = MRB_EXC_NEW(MRB, E_LOCALJUMP_ERROR, POOL[A].U.STR, LEN);
      MRB_EXC_SET(MRB, EXC);
      GOTO L_RAISE;
    }

    CASE(OP_EXT1, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _1(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT2, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _2(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT3, Z) {
      UINT8_T INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _3(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }

    CASE(OP_STOP, Z) {
      /*        STOP VM */
      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {
        /* DO NOTHING */
      }
      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {
        UNWIND_ENSURE(MRB, MRB->C->CI, PC, RBREAK_TAG_STOP, PROC, MRB_NIL_VALUE());
      }
      CHECKPOINT_END(RBREAK_TAG_STOP);
    L_STOP:
      MRB->JMP = PREV_JMP;
      IF (MRB->EXC) {
        MRB_ASSERT(MRB->EXC->TT == MRB_TT_EXCEPTION);
        RETURN MRB_OBJ_VALUE(MRB->EXC);
      }
      RETURN REGS[IREP->NLOCALS];
    }
  }
  END_DISPATCH;
#UNDEF REGS
  }
  MRB_CATCH(&C_JMP) {
    MRB_CALLINFO *CI = MRB->C->CI;
    WHILE (CI > MRB->C->CIBASE && CI->CCI == CINFO_DIRECT) {
      CI = CIPOP(MRB);
    }
    EXC_CATCHED = TRUE;
    PC = CI->PC;
    GOTO RETRY_TRY_BLOCK;
  }
  MRB_END_EXC(&C_JMP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 230988_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_STACK_EXTEND(MRB_STATE *MRB, MRB_INT ROOM)
{
  IF (!MRB->C->CI->STACK || MRB->C->CI->STACK + ROOM >= MRB->C->STEND) {
    STACK_EXTEND_ALLOC(MRB, ROOM);
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343143_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID ESP_INPUT_DONE(STRUCT CRYPTO_ASYNC_REQUEST *BASE, INT ERR)
{
	STRUCT SK_BUFF *SKB = BASE->DATA;

	XFRM_INPUT_RESUME(SKB, ESP6_INPUT_DONE2(SKB, ERR));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195691_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_VM_EXEC(MRB_STATE *MRB, CONST STRUCT RPROC *PROC, CONST MRB_CODE *PC)
{
  /* MRB_ASSERT(MRB_PROC_CFUNC_P(PROC)) */
  CONST MRB_IREP *IREP = PROC->BODY.IREP;
  CONST MRB_POOL_VALUE *POOL = IREP->POOL;
  CONST MRB_SYM *SYMS = IREP->SYMS;
  MRB_CODE INSN;
  INT AI = MRB_GC_ARENA_SAVE(MRB);
  STRUCT MRB_JMPBUF *PREV_JMP = MRB->JMP;
  STRUCT MRB_JMPBUF C_JMP;
  UINT32_T A;
  UINT16_T B;
  UINT16_T C;
  MRB_SYM MID;
  CONST STRUCT MRB_IREP_CATCH_HANDLER *CH;

#IFDEF DIRECT_THREADED
  STATIC CONST VOID * CONST OPTABLE[] = {
#DEFINE OPCODE(X,_) &&L_OP_ ## X,
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
  };
#ENDIF

  MRB_BOOL EXC_CATCHED = FALSE;
RETRY_TRY_BLOCK:

  MRB_TRY(&C_JMP) {

  IF (EXC_CATCHED) {
    EXC_CATCHED = FALSE;
    MRB_GC_ARENA_RESTORE(MRB, AI);
    IF (MRB->EXC && MRB->EXC->TT == MRB_TT_BREAK)
      GOTO L_BREAK;
    GOTO L_RAISE;
  }
  MRB->JMP = &C_JMP;
  MRB_VM_CI_PROC_SET(MRB->C->CI, PROC);

#DEFINE REGS (MRB->C->CI->STACK)
  INIT_DISPATCH {
    CASE(OP_NOP, Z) {
      /* DO NOTHING */
      NEXT;
    }

    CASE(OP_MOVE, BB) {
      REGS[A] = REGS[B];
      NEXT;
    }

    CASE(OP_LOADL, BB) {
      SWITCH (POOL[B].TT) {   /* NUMBER */
      CASE IREP_TT_INT32:
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I32);
        BREAK;
      CASE IREP_TT_INT64:
#IF DEFINED(MRB_INT64)
        REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
        BREAK;
#ELSE
#IF DEFINED(MRB_64BIT)
        IF (INT32_MIN <= POOL[B].U.I64 && POOL[B].U.I64 <= INT32_MAX) {
          REGS[A] = MRB_INT_VALUE(MRB, (MRB_INT)POOL[B].U.I64);
          BREAK;
        }
#ENDIF
        GOTO L_INT_OVERFLOW;
#ENDIF
      CASE IREP_TT_BIGINT:
#IFDEF MRB_USE_BIGINT
        {
          CONST CHAR *S = POOL[B].U.STR;
          REGS[A] = MRB_BINT_NEW_STR(MRB, S+2, (MRB_INT)S[0], (MRB_INT)S[1]);
        }
        BREAK;
#ELSE
        GOTO L_INT_OVERFLOW;
#ENDIF
#IFNDEF MRB_NO_FLOAT
      CASE IREP_TT_FLOAT:
        REGS[A] = MRB_FLOAT_VALUE(MRB, POOL[B].U.F);
        BREAK;
#ENDIF
      DEFAULT:
        /* SHOULD NOT HAPPEN (TT:STRING) */
        REGS[A] = MRB_NIL_VALUE();
        BREAK;
      }
      NEXT;
    }

    CASE(OP_LOADI, BB) {
      SET_FIXNUM_VALUE(REGS[A], B);
      NEXT;
    }

    CASE(OP_LOADINEG, BB) {
      SET_FIXNUM_VALUE(REGS[A], -B);
      NEXT;
    }

    CASE(OP_LOADI__1,B) GOTO L_LOADI;
    CASE(OP_LOADI_0,B) GOTO L_LOADI;
    CASE(OP_LOADI_1,B) GOTO L_LOADI;
    CASE(OP_LOADI_2,B) GOTO L_LOADI;
    CASE(OP_LOADI_3,B) GOTO L_LOADI;
    CASE(OP_LOADI_4,B) GOTO L_LOADI;
    CASE(OP_LOADI_5,B) GOTO L_LOADI;
    CASE(OP_LOADI_6,B) GOTO L_LOADI;
    CASE(OP_LOADI_7, B) {
    L_LOADI:
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)INSN - (MRB_INT)OP_LOADI_0);
      NEXT;
    }

    CASE(OP_LOADI16, BS) {
      SET_FIXNUM_VALUE(REGS[A], (MRB_INT)(INT16_T)B);
      NEXT;
    }

    CASE(OP_LOADI32, BSS) {
      SET_INT_VALUE(MRB, REGS[A], (INT32_T)(((UINT32_T)B<<16)+C));
      NEXT;
    }

    CASE(OP_LOADSYM, BB) {
      SET_SYM_VALUE(REGS[A], SYMS[B]);
      NEXT;
    }

    CASE(OP_LOADNIL, B) {
      SET_NIL_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADSELF, B) {
      REGS[A] = REGS[0];
      NEXT;
    }

    CASE(OP_LOADT, B) {
      SET_TRUE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_LOADF, B) {
      SET_FALSE_VALUE(REGS[A]);
      NEXT;
    }

    CASE(OP_GETGV, BB) {
      MRB_VALUE VAL = MRB_GV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETGV, BB) {
      MRB_GV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETSV, BB) {
      MRB_VALUE VAL = MRB_VM_SPECIAL_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETSV, BB) {
      MRB_VM_SPECIAL_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIV, BB) {
      REGS[A] = MRB_IV_GET(MRB, REGS[0], SYMS[B]);
      NEXT;
    }

    CASE(OP_SETIV, BB) {
      MRB_IV_SET(MRB, REGS[0], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETCV, BB) {
      MRB_VALUE VAL;
      VAL = MRB_VM_CV_GET(MRB, SYMS[B]);
      REGS[A] = VAL;
      NEXT;
    }

    CASE(OP_SETCV, BB) {
      MRB_VM_CV_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETIDX, B) {
      MRB_VALUE VA = REGS[A], VB = REGS[A+1];
      SWITCH (MRB_TYPE(VA)) {
      CASE MRB_TT_ARRAY:
        IF (!MRB_INTEGER_P(VB)) GOTO GETIDX_FALLBACK;
        REGS[A] = MRB_ARY_ENTRY(VA, MRB_INTEGER(VB));
        BREAK;
      CASE MRB_TT_HASH:
        VA = MRB_HASH_GET(MRB, VA, VB);
        REGS[A] = VA;
        BREAK;
      CASE MRB_TT_STRING:
        SWITCH (MRB_TYPE(VB)) {
        CASE MRB_TT_INTEGER:
        CASE MRB_TT_STRING:
        CASE MRB_TT_RANGE:
          VA = MRB_STR_AREF(MRB, VA, VB, MRB_UNDEF_VALUE());
          REGS[A] = VA;
          BREAK;
        DEFAULT:
          GOTO GETIDX_FALLBACK;
        }
        BREAK;
      DEFAULT:
      GETIDX_FALLBACK:
        MID = MRB_OPSYM(AREF);
        GOTO L_SEND_SYM;
      }
      NEXT;
    }

    CASE(OP_SETIDX, B) {
      C = 2;
      MID = MRB_OPSYM(ASET);
      SET_NIL_VALUE(REGS[A+3]);
      GOTO L_SENDB_SYM;
    }

    CASE(OP_GETCONST, BB) {
      MRB_VALUE V = MRB_VM_CONST_GET(MRB, SYMS[B]);
      REGS[A] = V;
      NEXT;
    }

    CASE(OP_SETCONST, BB) {
      MRB_VM_CONST_SET(MRB, SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETMCNST, BB) {
      MRB_VALUE V = MRB_CONST_GET(MRB, REGS[A], SYMS[B]);
      REGS[A] = V;
      NEXT;
    }

    CASE(OP_SETMCNST, BB) {
      MRB_CONST_SET(MRB, REGS[A+1], SYMS[B], REGS[A]);
      NEXT;
    }

    CASE(OP_GETUPVAR, BBB) {
      MRB_VALUE *REGS_A = REGS + A;
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E && B < MRB_ENV_LEN(E)) {
        *REGS_A = E->STACK[B];
      }
      ELSE {
        *REGS_A = MRB_NIL_VALUE();
      }
      NEXT;
    }

    CASE(OP_SETUPVAR, BBB) {
      STRUCT RENV *E = UVENV(MRB, C);

      IF (E) {
        MRB_VALUE *REGS_A = REGS + A;

        IF (B < MRB_ENV_LEN(E)) {
          E->STACK[B] = *REGS_A;
          MRB_WRITE_BARRIER(MRB, (STRUCT RBASIC*)E);
        }
      }
      NEXT;
    }

    CASE(OP_JMP, S) {
      PC += (INT16_T)A;
      JUMP;
    }
    CASE(OP_JMPIF, BS) {
      IF (MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNOT, BS) {
      IF (!MRB_TEST(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }
    CASE(OP_JMPNIL, BS) {
      IF (MRB_NIL_P(REGS[A])) {
        PC += (INT16_T)B;
        JUMP;
      }
      NEXT;
    }

    CASE(OP_JMPUW, S) {
      A = (UINT32_T)((PC - IREP->ISEQ) + (INT16_T)A);
      CHECKPOINT_RESTORE(RBREAK_TAG_JUMP) {
        STRUCT RBREAK *BRK = (STRUCT RBREAK*)MRB->EXC;
        MRB_VALUE TARGET = MRB_BREAK_VALUE_GET(BRK);
        MRB_ASSERT(MRB_INTEGER_P(TARGET));
        A = (UINT32_T)MRB_INTEGER(TARGET);
        MRB_ASSERT(A >= 0 && A < IREP->ILEN);
      }
      CHECKPOINT_MAIN(RBREAK_TAG_JUMP) {
        CH = CATCH_HANDLER_FIND(MRB, MRB->C->CI, PC, MRB_CATCH_FILTER_ENSURE);
        IF (CH) {
          /* AVOIDING A JUMP FROM A CATCH HANDLER INTO THE SAME HANDLER */
          IF (A < MRB_IREP_CATCH_HANDLER_UNPACK(CH->BEGIN) || A >= MRB_IREP_CATCH_HANDLER_UNPACK(CH->END)) {
            THROW_TAGGED_BREAK(MRB, RBREAK_TAG_JUMP, PROC, MRB_FIXNUM_VALUE(A));
          }
        }
      }
      CHECKPOINT_END(RBREAK_TAG_JUMP);

      MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
      PC = IREP->ISEQ + A;
      JUMP;
    }

    CASE(OP_EXCEPT, B) {
      MRB_VALUE EXC;

      IF (MRB->EXC == NULL) {
        EXC = MRB_NIL_VALUE();
      }
      ELSE {
        SWITCH (MRB->EXC->TT) {
        CASE MRB_TT_BREAK:
        CASE MRB_TT_EXCEPTION:
          EXC = MRB_OBJ_VALUE(MRB->EXC);
          BREAK;
        DEFAULT:
          MRB_ASSERT(!"BAD MRB_TYPE");
          EXC = MRB_NIL_VALUE();
          BREAK;
        }
        MRB->EXC = NULL;
      }
      REGS[A] = EXC;
      NEXT;
    }
    CASE(OP_RESCUE, BB) {
      MRB_VALUE EXC = REGS[A];  /* EXC ON STACK */
      MRB_VALUE E = REGS[B];
      STRUCT RCLASS *EC;

      SWITCH (MRB_TYPE(E)) {
      CASE MRB_TT_CLASS:
      CASE MRB_TT_MODULE:
        BREAK;
      DEFAULT:
        {
          MRB_VALUE EXC;

          EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                    "CLASS OR MODULE REQUIRED FOR RESCUE CLAUSE");
          MRB_EXC_SET(MRB, EXC);
          GOTO L_RAISE;
        }
      }
      EC = MRB_CLASS_PTR(E);
      REGS[B] = MRB_BOOL_VALUE(MRB_OBJ_IS_KIND_OF(MRB, EXC, EC));
      NEXT;
    }

    CASE(OP_RAISEIF, B) {
      MRB_VALUE EXC = REGS[A];
      IF (MRB_BREAK_P(EXC)) {
        MRB->EXC = MRB_OBJ_PTR(EXC);
        GOTO L_BREAK;
      }
      MRB_EXC_SET(MRB, EXC);
      IF (MRB->EXC) {
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_SSEND, BBB) {
      REGS[A] = REGS[0];
      INSN = OP_SEND;
    }
    GOTO L_SENDB;

    CASE(OP_SSENDB, BBB) {
      REGS[A] = REGS[0];
    }
    GOTO L_SENDB;

    CASE(OP_SEND, BBB)
    GOTO L_SENDB;

    L_SEND_SYM:
    C = 1;
    /* PUSH NIL AFTER ARGUMENTS */
    SET_NIL_VALUE(REGS[A+2]);
    GOTO L_SENDB_SYM;

    CASE(OP_SENDB, BBB)
    L_SENDB:
    MID = SYMS[B];
    L_SENDB_SYM:
    {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_VALUE RECV, BLK;

      ARGUMENT_NORMALIZE(A, &C, INSN);

      RECV = REGS[A];
      CLS = MRB_CLASS(MRB, RECV);
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &C, BLK, 0);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, C);

      IF (MRB_METHOD_CFUNC_P(M)) {
        IF (MRB_METHOD_PROC_P(M)) {
          STRUCT RPROC *P = MRB_METHOD_PROC(M);

          MRB_VM_CI_PROC_SET(CI, P);
          RECV = P->BODY.FUNC(MRB, RECV);
        }
        ELSE {
          IF (MRB_METHOD_NOARG_P(M)) {
            CHECK_METHOD_NOARG(MRB, CI);
          }
          RECV = MRB_METHOD_FUNC(M)(MRB, RECV);
        }
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);
          IF (P && !MRB_PROC_STRICT_P(P) && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
        IF (!CI->U.TARGET_CLASS) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN RECV;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        CI->STACK[0] = RECV;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
    }
    JUMP;

    CASE(OP_CALL, Z) {
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV = CI->STACK[0];
      STRUCT RPROC *M = MRB_PROC_PTR(RECV);

      /* REPLACE CALLINFO */
      CI->U.TARGET_CLASS = MRB_PROC_TARGET_CLASS(M);
      MRB_VM_CI_PROC_SET(CI, M);
      IF (MRB_PROC_ENV_P(M)) {
        CI->MID = MRB_PROC_ENV(M)->MID;
      }

      /* PREPARE STACK */
      IF (MRB_PROC_CFUNC_P(M)) {
        RECV = MRB_PROC_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_SHRINK(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        /* POP STACKPOS */
        CI = CIPOP(MRB);
        PC = CI->PC;
        CI[1].STACK[0] = RECV;
        IREP = MRB->C->CI->PROC->BODY.IREP;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        PROC = M;
        IREP = M->BODY.IREP;
        IF (!IREP) {
          MRB->C->CI->STACK[0] = MRB_NIL_VALUE();
          A = 0;
          C = OP_R_NORMAL;
          GOTO L_OP_RETURN_BODY;
        }
        MRB_INT NARGS = MRB_CI_BIDX(CI)+1;
        IF (NARGS < IREP->NREGS) {
          MRB_STACK_EXTEND(MRB, IREP->NREGS);
          STACK_CLEAR(REGS+NARGS, IREP->NREGS-NARGS);
        }
        IF (MRB_PROC_ENV_P(M)) {
          REGS[0] = MRB_PROC_ENV(M)->STACK[0];
        }
        PC = IREP->ISEQ;
      }
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      JUMP;
    }

    CASE(OP_SUPER, BB) {
      MRB_METHOD_T M;
      STRUCT RCLASS *CLS;
      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_VALUE RECV, BLK;
      CONST STRUCT RPROC *P = CI->PROC;
      MRB_SYM MID = CI->MID;
      STRUCT RCLASS* TARGET_CLASS = MRB_PROC_TARGET_CLASS(P);

      IF (MRB_PROC_ENV_P(P) && P->E.ENV->MID && P->E.ENV->MID != MID) { /* ALIAS SUPPORT */
        MID = P->E.ENV->MID;    /* RESTORE OLD MID */
      }

      IF (MID == 0 || !TARGET_CLASS) {
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (TARGET_CLASS->FLAGS & MRB_FL_CLASS_IS_PREPENDED) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
      }
      ELSE IF (TARGET_CLASS->TT == MRB_TT_MODULE) {
        TARGET_CLASS = MRB_VM_CI_TARGET_CLASS(CI);
        IF (!TARGET_CLASS || TARGET_CLASS->TT != MRB_TT_ICLASS) {
          GOTO SUPER_TYPEERROR;
        }
      }
      RECV = REGS[0];
      IF (!MRB_OBJ_IS_KIND_OF(MRB, RECV, TARGET_CLASS)) {
      SUPER_TYPEERROR: ;
        MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_TYPE_ERROR,
                                            "SELF HAS WRONG TYPE TO CALL SUPER IN THIS CONTEXT");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }

      ARGUMENT_NORMALIZE(A, &B, OP_SUPER);

      CLS = TARGET_CLASS->SUPER;
      M = MRB_METHOD_SEARCH_VM(MRB, &CLS, MID);
      IF (MRB_METHOD_UNDEF_P(M)) {
        M = PREPARE_MISSING(MRB, RECV, MID, &CLS, A, &B, BLK, 1);
        MID = MRB_SYM(METHOD_MISSING);
      }

      /* PUSH CALLINFO */
      CI = CIPUSH(MRB, A, 0, CLS, NULL, MID, B);

      /* PREPARE STACK */
      CI->STACK[0] = RECV;

      IF (MRB_METHOD_CFUNC_P(M)) {
        MRB_VALUE V;

        IF (MRB_METHOD_PROC_P(M)) {
          MRB_VM_CI_PROC_SET(CI, MRB_METHOD_PROC(M));
        }
        V = MRB_METHOD_CFUNC(M)(MRB, RECV);
        MRB_GC_ARENA_RESTORE(MRB, AI);
        IF (MRB->EXC) GOTO L_RAISE;
        CI = MRB->C->CI;
        MRB_ASSERT(!MRB_BREAK_P(V));
        IF (!MRB_VM_CI_TARGET_CLASS(CI)) { /* RETURN FROM CONTEXT MODIFYING METHOD (RESUME/YIELD) */
          IF (CI->CCI == CINFO_RESUMED) {
            MRB->JMP = PREV_JMP;
            RETURN V;
          }
          ELSE {
            MRB_ASSERT(!MRB_PROC_CFUNC_P(CI[-1].PROC));
            PROC = CI[-1].PROC;
            IREP = PROC->BODY.IREP;
            POOL = IREP->POOL;
            SYMS = IREP->SYMS;
          }
        }
        MRB->C->CI->STACK[0] = V;
        CI = CIPOP(MRB);
        PC = CI->PC;
      }
      ELSE {
        /* SETUP ENVIRONMENT FOR CALLING METHOD */
        MRB_VM_CI_PROC_SET(CI, (PROC = MRB_METHOD_PROC(M)));
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, (IREP->NREGS < 4) ? 4 : IREP->NREGS);
        PC = IREP->ISEQ;
      }
      JUMP;
    }

    CASE(OP_ARGARY, BS) {
      MRB_INT M1 = (B>>11)&0X3F;
      MRB_INT R  = (B>>10)&0X1;
      MRB_INT M2 = (B>>5)&0X1F;
      MRB_INT KD = (B>>4)&0X1;
      MRB_INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (MRB->C->CI->MID == 0 || MRB_VM_CI_TARGET_CLASS(MRB->C->CI) == NULL) {
        MRB_VALUE EXC;

      L_NOSUPER:
        EXC = MRB_EXC_NEW_LIT(MRB, E_NOMETHOD_ERROR, "SUPER CALLED OUTSIDE OF METHOD");
        MRB_EXC_SET(MRB, EXC);
        GOTO L_RAISE;
      }
      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E) GOTO L_NOSUPER;
        IF (MRB_ENV_LEN(E) <= M1+R+M2+1)
          GOTO L_NOSUPER;
        STACK = E->STACK + 1;
      }
      IF (R == 0) {
        REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, M1+M2, STACK);
      }
      ELSE {
        MRB_VALUE *PP = NULL;
        STRUCT RARRAY *REST;
        MRB_INT LEN = 0;

        IF (MRB_ARRAY_P(STACK[M1])) {
          STRUCT RARRAY *ARY = MRB_ARY_PTR(STACK[M1]);

          PP = ARY_PTR(ARY);
          LEN = ARY_LEN(ARY);
        }
        REGS[A] = MRB_ARY_NEW_CAPA(MRB, M1+LEN+M2);
        REST = MRB_ARY_PTR(REGS[A]);
        IF (M1 > 0) {
          STACK_COPY(ARY_PTR(REST), STACK, M1);
        }
        IF (LEN > 0) {
          STACK_COPY(ARY_PTR(REST)+M1, PP, LEN);
        }
        IF (M2 > 0) {
          STACK_COPY(ARY_PTR(REST)+M1+LEN, STACK+M1+1, M2);
        }
        ARY_SET_LEN(REST, M1+LEN+M2);
      }
      IF (KD) {
        REGS[A+1] = STACK[M1+R+M2];
        REGS[A+2] = STACK[M1+R+M2+1];
      }
      ELSE {
        REGS[A+1] = STACK[M1+R+M2];
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ENTER, W) {
      MRB_INT M1 = MRB_ASPEC_REQ(A);
      MRB_INT O  = MRB_ASPEC_OPT(A);
      MRB_INT R  = MRB_ASPEC_REST(A);
      MRB_INT M2 = MRB_ASPEC_POST(A);
      MRB_INT KD = (MRB_ASPEC_KEY(A) > 0 || MRB_ASPEC_KDICT(A))? 1 : 0;
      /* UNUSED
      INT B  = MRB_ASPEC_BLOCK(A);
      */
      MRB_INT CONST LEN = M1 + O + R + M2;

      MRB_CALLINFO *CI = MRB->C->CI;
      MRB_INT ARGC = CI->N;
      MRB_VALUE *ARGV = REGS+1;
      MRB_VALUE * CONST ARGV0 = ARGV;
      MRB_INT CONST KW_POS = LEN + KD;    /* WHERE KWHASH SHOULD BE */
      MRB_INT CONST BLK_POS = KW_POS + 1; /* WHERE BLOCK SHOULD BE */
      MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];
      MRB_VALUE KDICT = MRB_NIL_VALUE();

      /* KEYWORD ARGUMENTS */
      IF (CI->NK > 0) {
        MRB_INT KIDX = MRB_CI_KIDX(CI);
        KDICT = REGS[KIDX];
        IF (!MRB_HASH_P(KDICT) || MRB_HASH_SIZE(MRB, KDICT) == 0) {
          KDICT = MRB_NIL_VALUE();
          CI->NK = 0;
        }
      }
      IF (!KD && !MRB_NIL_P(KDICT)) {
        IF (ARGC < 14) {
          CI->N++;
          ARGC++;    /* INCLUDE KDICT IN NORMAL ARGUMENTS */
        }
        ELSE IF (ARGC == 14) {
          /* PACK ARGUMENTS AND KDICT */
          REGS[1] = MRB_ARY_NEW_FROM_VALUES(MRB, ARGC+1, &REGS[1]);
          ARGC = CI->N = 15;
        }
        ELSE {/* ARGC == 15 */
          /* PUSH KDICT TO PACKED ARGUMENTS */
          MRB_ARY_PUSH(MRB, REGS[1], REGS[2]);
        }
        CI->NK = 0;
      }
      IF (KD && MRB_ASPEC_KEY(A) > 0 && MRB_HASH_P(KDICT)) {
        KDICT = MRB_HASH_DUP(MRB, KDICT);
      }

      /* ARGUMENTS IS PASSED WITH ARRAY */
      IF (ARGC == 15) {
        STRUCT RARRAY *ARY = MRB_ARY_PTR(REGS[1]);
        ARGV = ARY_PTR(ARY);
        ARGC = (INT)ARY_LEN(ARY);
        MRB_GC_PROTECT(MRB, REGS[1]);
      }

      /* STRICT ARGUMENT CHECK */
      IF (CI->PROC && MRB_PROC_STRICT_P(CI->PROC)) {
        IF (ARGC < M1 + M2 || (R == 0 && ARGC > LEN)) {
          ARGNUM_ERROR(MRB, M1+M2);
          GOTO L_RAISE;
        }
      }
      /* EXTRACT FIRST ARGUMENT ARRAY TO ARGUMENTS */
      ELSE IF (LEN > 1 && ARGC == 1 && MRB_ARRAY_P(ARGV[0])) {
        MRB_GC_PROTECT(MRB, ARGV[0]);
        ARGC = (INT)RARRAY_LEN(ARGV[0]);
        ARGV = RARRAY_PTR(ARGV[0]);
      }

      /* REST ARGUMENTS */
      MRB_VALUE REST = MRB_NIL_VALUE();
      IF (ARGC < LEN) {
        MRB_INT MLEN = M2;
        IF (ARGC < M1+M2) {
          MLEN = M1 < ARGC ? ARGC - M1 : 0;
        }

        /* COPY MANDATORY AND OPTIONAL ARGUMENTS */
        IF (ARGV0 != ARGV && ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, ARGC-MLEN); /* M1 + O */
        }
        IF (ARGC < M1) {
          STACK_CLEAR(&REGS[ARGC+1], M1-ARGC);
        }
        /* COPY POST MANDATORY ARGUMENTS */
        IF (MLEN) {
          VALUE_MOVE(&REGS[LEN-M2+1], &ARGV[ARGC-MLEN], MLEN);
        }
        IF (MLEN < M2) {
          STACK_CLEAR(&REGS[LEN-M2+MLEN+1], M2-MLEN);
        }
        /* INITIALIZE REST ARGUMENTS WITH EMPTY ARRAY */
        IF (R) {
          REST = MRB_ARY_NEW_CAPA(MRB, 0);
          REGS[M1+O+1] = REST;
        }
        /* SKIP INITIALIZER OF PASSED ARGUMENTS */
        IF (O > 0 && ARGC > M1+M2)
          PC += (ARGC - M1 - M2)*3;
      }
      ELSE {
        MRB_INT RNUM = 0;
        IF (ARGV0 != ARGV) {
          VALUE_MOVE(&REGS[1], ARGV, M1+O);
        }
        IF (R) {
          RNUM = ARGC-M1-O-M2;
          REST = MRB_ARY_NEW_FROM_VALUES(MRB, RNUM, ARGV+M1+O);
          REGS[M1+O+1] = REST;
        }
        IF (M2 > 0 && ARGC-M2 > M1) {
          VALUE_MOVE(&REGS[M1+O+R+1], &ARGV[M1+O+RNUM], M2);
        }
        PC += O*3;
      }

      /* NEED TO BE UPDATE BLK FIRST TO PROTECT BLK FROM GC */
      REGS[BLK_POS] = BLK;              /* MOVE BLOCK */
      IF (KD) {
        IF (MRB_NIL_P(KDICT))
          KDICT = MRB_HASH_NEW_CAPA(MRB, 0);
        REGS[KW_POS] = KDICT;           /* SET KWHASH */
      }

      /* FORMAT ARGUMENTS FOR GENERATED CODE */
      MRB->C->CI->N = (UINT8_T)LEN;

      /* CLEAR LOCAL (BUT NON-ARGUMENT) VARIABLES */
      IF (IREP->NLOCALS-BLK_POS-1 > 0) {
        STACK_CLEAR(&REGS[BLK_POS+1], IREP->NLOCALS-BLK_POS-1);
      }
      JUMP;
    }

    CASE(OP_KARG, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT, V;

      IF (KIDX < 0 || !MRB_HASH_P(KDICT=REGS[KIDX]) || !MRB_HASH_KEY_P(MRB, KDICT, K)) {
        MRB_VALUE STR = MRB_FORMAT(MRB, "MISSING KEYWORD: %V", K);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      V = MRB_HASH_GET(MRB, KDICT, K);
      REGS[A] = V;
      MRB_HASH_DELETE_KEY(MRB, KDICT, K);
      NEXT;
    }

    CASE(OP_KEY_P, BB) {
      MRB_VALUE K = MRB_SYMBOL_VALUE(SYMS[B]);
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;
      MRB_BOOL KEY_P = FALSE;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX])) {
        KEY_P = MRB_HASH_KEY_P(MRB, KDICT, K);
      }
      REGS[A] = MRB_BOOL_VALUE(KEY_P);
      NEXT;
    }

    CASE(OP_KEYEND, Z) {
      MRB_INT KIDX = MRB_CI_KIDX(MRB->C->CI);
      MRB_VALUE KDICT;

      IF (KIDX >= 0 && MRB_HASH_P(KDICT=REGS[KIDX]) && !MRB_HASH_EMPTY_P(MRB, KDICT)) {
        MRB_VALUE KEYS = MRB_HASH_KEYS(MRB, KDICT);
        MRB_VALUE KEY1 = RARRAY_PTR(KEYS)[0];
        MRB_VALUE STR = MRB_FORMAT(MRB, "UNKNOWN KEYWORD: %V", KEY1);
        MRB_EXC_SET(MRB, MRB_EXC_NEW_STR(MRB, E_ARGUMENT_ERROR, STR));
        GOTO L_RAISE;
      }
      NEXT;
    }

    CASE(OP_BREAK, B) {
      C = OP_R_BREAK;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN_BLK, B) {
      C = OP_R_RETURN;
      GOTO L_RETURN;
    }
    CASE(OP_RETURN, B)
    C = OP_R_NORMAL;
    L_RETURN:
    {
      MRB_CALLINFO *CI;

      CI = MRB->C->CI;
      IF (CI->MID) {
        MRB_VALUE BLK = REGS[MRB_CI_BIDX(CI)];

        IF (MRB_PROC_P(BLK)) {
          STRUCT RPROC *P = MRB_PROC_PTR(BLK);

          IF (!MRB_PROC_STRICT_P(P) &&
              CI > MRB->C->CIBASE && MRB_PROC_ENV(P) == MRB_VM_CI_ENV(&CI[-1])) {
            P->FLAGS |= MRB_PROC_ORPHAN;
          }
        }
      }

      IF (MRB->EXC) {
      L_RAISE:
        CI = MRB->C->CI;
        IF (CI == MRB->C->CIBASE) {
          CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
          IF (CH == NULL) GOTO L_FTOP;
          GOTO L_CATCH;
        }
        WHILE ((CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL)) == NULL) {
          CI = CIPOP(MRB);
          IF (CI[1].CCI == CINFO_SKIP && PREV_JMP) {
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          PC = CI[0].PC;
          IF (CI == MRB->C->CIBASE) {
            CH = CATCH_HANDLER_FIND(MRB, CI, PC, MRB_CATCH_FILTER_ALL);
            IF (CH == NULL) {
            L_FTOP:             /* FIBER TOP */
              IF (MRB->C == MRB->ROOT_C) {
                MRB->C->CI->STACK = MRB->C->STBASE;
                GOTO L_STOP;
              }
              ELSE {
                STRUCT MRB_CONTEXT *C = MRB->C;

                C->STATUS = MRB_FIBER_TERMINATED;
                MRB->C = C->PREV;
                C->PREV = NULL;
                GOTO L_RAISE;
              }
            }
            BREAK;
          }
        }
      L_CATCH:
        IF (CH == NULL) GOTO L_STOP;
        IF (FALSE) {
        L_CATCH_TAGGED_BREAK: /* FROM THROW_TAGGED_BREAK() OR UNWIND_ENSURE() */
          CI = MRB->C->CI;
        }
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;
        MRB_STACK_EXTEND(MRB, IREP->NREGS);
        PC = IREP->ISEQ + MRB_IREP_CATCH_HANDLER_UNPACK(CH->TARGET);
      }
      ELSE {
        MRB_INT ACC;
        MRB_VALUE V;

        CI = MRB->C->CI;
        V = REGS[A];
        MRB_GC_PROTECT(MRB, V);
        SWITCH (C) {
        CASE OP_R_RETURN:
          /* FALL THROUGH TO OP_R_NORMAL OTHERWISE */
          IF (CI->CCI == CINFO_NONE && MRB_PROC_ENV_P(PROC) && !MRB_PROC_STRICT_P(PROC)) {
            CONST STRUCT RPROC *DST;
            MRB_CALLINFO *CIBASE;
            CIBASE = MRB->C->CIBASE;
            DST = TOP_PROC(MRB, PROC);

            IF (MRB_PROC_ENV_P(DST)) {
              STRUCT RENV *E = MRB_PROC_ENV(DST);

              IF (!MRB_ENV_ONSTACK_P(E) || (E->CXT && E->CXT != MRB->C)) {
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
            }
            /* CHECK JUMP DESTINATION */
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              IF (CI->CCI > CINFO_NONE) { /* JUMP CROSS C BOUNDARY */
                LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
                GOTO L_RAISE;
              }
              CI--;
            }
            IF (CI <= CIBASE) { /* NO JUMP DESTINATION */
              LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_RETURN);
              GOTO L_RAISE;
            }
            CI = MRB->C->CI;
            WHILE (CIBASE <= CI && CI->PROC != DST) {
              CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_BLOCK) {
                CIBASE = MRB->C->CIBASE;
                DST = TOP_PROC(MRB, PROC);
              }
              CHECKPOINT_MAIN(RBREAK_TAG_RETURN_BLOCK) {
                UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_BLOCK, PROC, V);
              }
              CHECKPOINT_END(RBREAK_TAG_RETURN_BLOCK);
              CI = CIPOP(MRB);
              PC = CI->PC;
            }
            PROC = CI->PROC;
            MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
            BREAK;
          }
          /* FALLTHROUGH */
        CASE OP_R_NORMAL:
        NORMAL_RETURN:
          IF (CI == MRB->C->CIBASE) {
            STRUCT MRB_CONTEXT *C;
            C = MRB->C;

            IF (!C->PREV) { /* TOPLEVEL RETURN */
              REGS[IREP->NLOCALS] = V;
              GOTO CHECKPOINT_LABEL_MAKE(RBREAK_TAG_STOP);
            }
            IF (!C->VMEXEC && C->PREV->CI == C->PREV->CIBASE) {
              MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_FIBER_ERROR, "DOUBLE RESUME");
              MRB_EXC_SET(MRB, EXC);
              GOTO L_RAISE;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_RETURN_TOPLEVEL) {
              C = MRB->C;
            }
            CHECKPOINT_MAIN(RBREAK_TAG_RETURN_TOPLEVEL) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN_TOPLEVEL, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_RETURN_TOPLEVEL);
            /* AUTOMATIC YIELD AT THE END */
            C->STATUS = MRB_FIBER_TERMINATED;
            MRB->C = C->PREV;
            MRB->C->STATUS = MRB_FIBER_RUNNING;
            C->PREV = NULL;
            IF (C->VMEXEC) {
              MRB_GC_ARENA_RESTORE(MRB, AI);
              C->VMEXEC = FALSE;
              MRB->JMP = PREV_JMP;
              RETURN V;
            }
            CI = MRB->C->CI;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_RETURN) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_RETURN) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_RETURN, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_RETURN);
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        CASE OP_R_BREAK:
          IF (MRB_PROC_STRICT_P(PROC)) GOTO NORMAL_RETURN;
          IF (MRB_PROC_ORPHAN_P(PROC)) {
            MRB_VALUE EXC;

          L_BREAK_ERROR:
            EXC = MRB_EXC_NEW_LIT(MRB, E_LOCALJUMP_ERROR,
                                      "BREAK FROM PROC-CLOSURE");
            MRB_EXC_SET(MRB, EXC);
            GOTO L_RAISE;
          }
          IF (!MRB_PROC_ENV_P(PROC) || !MRB_ENV_ONSTACK_P(MRB_PROC_ENV(PROC))) {
            GOTO L_BREAK_ERROR;
          }
          ELSE {
            STRUCT RENV *E = MRB_PROC_ENV(PROC);

            IF (E->CXT != MRB->C) {
              GOTO L_BREAK_ERROR;
            }
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK);
          /* BREAK FROM FIBER BLOCK */
          IF (CI == MRB->C->CIBASE && CI->PC) {
            STRUCT MRB_CONTEXT *C = MRB->C;

            MRB->C = C->PREV;
            C->PREV = NULL;
            CI = MRB->C->CI;
          }
          IF (CI->CCI > CINFO_NONE) {
            CI = CIPOP(MRB);
            MRB->EXC = (STRUCT ROBJECT*)BREAK_NEW(MRB, RBREAK_TAG_BREAK, PROC, V);
            MRB_GC_ARENA_RESTORE(MRB, AI);
            MRB->C->VMEXEC = FALSE;
            MRB->JMP = PREV_JMP;
            MRB_THROW(PREV_JMP);
          }
          IF (FALSE) {
            STRUCT RBREAK *BRK;

          L_BREAK:
            BRK = (STRUCT RBREAK*)MRB->EXC;
            PROC = MRB_BREAK_PROC_GET(BRK);
            V = MRB_BREAK_VALUE_GET(BRK);
            CI = MRB->C->CI;

            SWITCH (MRB_BREAK_TAG_GET(BRK)) {
#DEFINE DISPATCH_CHECKPOINTS(N, I) CASE N: GOTO CHECKPOINT_LABEL_MAKE(N);
              RBREAK_TAG_FOREACH(DISPATCH_CHECKPOINTS)
#UNDEF DISPATCH_CHECKPOINTS
              DEFAULT:
                MRB_ASSERT(!"WRONG BREAK TAG");
            }
          }
          WHILE (MRB->C->CIBASE < CI && CI[-1].PROC != PROC->UPPER) {
            IF (CI[-1].CCI == CINFO_SKIP) {
              GOTO L_BREAK_ERROR;
            }
            CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_UPPER) {
              /* DO NOTHING */
            }
            CHECKPOINT_MAIN(RBREAK_TAG_BREAK_UPPER) {
              UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_UPPER, PROC, V);
            }
            CHECKPOINT_END(RBREAK_TAG_BREAK_UPPER);
            CI = CIPOP(MRB);
            PC = CI->PC;
          }
          CHECKPOINT_RESTORE(RBREAK_TAG_BREAK_INTARGET) {
            /* DO NOTHING */
          }
          CHECKPOINT_MAIN(RBREAK_TAG_BREAK_INTARGET) {
            UNWIND_ENSURE(MRB, CI, PC, RBREAK_TAG_BREAK_INTARGET, PROC, V);
          }
          CHECKPOINT_END(RBREAK_TAG_BREAK_INTARGET);
          IF (CI == MRB->C->CIBASE) {
            GOTO L_BREAK_ERROR;
          }
          MRB->EXC = NULL; /* CLEAR BREAK OBJECT */
          BREAK;
        DEFAULT:
          /* CANNOT HAPPEN */
          BREAK;
        }
        MRB_ASSERT(CI == MRB->C->CI);
        MRB_ASSERT(MRB->EXC == NULL);

        IF (MRB->C->VMEXEC && !MRB_VM_CI_TARGET_CLASS(CI)) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->C->VMEXEC = FALSE;
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        ACC = CI->CCI;
        CI = CIPOP(MRB);
        IF (ACC == CINFO_SKIP || ACC == CINFO_DIRECT) {
          MRB_GC_ARENA_RESTORE(MRB, AI);
          MRB->JMP = PREV_JMP;
          RETURN V;
        }
        PC = CI->PC;
        DEBUG(FPRINTF(STDERR, "FROM :%S\N", MRB_SYM_NAME(MRB, CI->MID)));
        PROC = CI->PROC;
        IREP = PROC->BODY.IREP;
        POOL = IREP->POOL;
        SYMS = IREP->SYMS;

        CI[1].STACK[0] = V;
        MRB_GC_ARENA_RESTORE(MRB, AI);
      }
      JUMP;
    }

    CASE(OP_BLKPUSH, BS) {
      INT M1 = (B>>11)&0X3F;
      INT R  = (B>>10)&0X1;
      INT M2 = (B>>5)&0X1F;
      INT KD = (B>>4)&0X1;
      INT LV = (B>>0)&0XF;
      MRB_VALUE *STACK;

      IF (LV == 0) STACK = REGS + 1;
      ELSE {
        STRUCT RENV *E = UVENV(MRB, LV-1);
        IF (!E || (!MRB_ENV_ONSTACK_P(E) && E->MID == 0) ||
            MRB_ENV_LEN(E) <= M1+R+M2+1) {
          LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
          GOTO L_RAISE;
        }
        STACK = E->STACK + 1;
      }
      IF (MRB_NIL_P(STACK[M1+R+M2+KD])) {
        LOCALJUMP_ERROR(MRB, LOCALJUMP_ERROR_YIELD);
        GOTO L_RAISE;
      }
      REGS[A] = STACK[M1+R+M2+KD];
      NEXT;
    }

#IF !DEFINED(MRB_USE_BIGINT) || DEFINED(MRB_INT32)
  L_INT_OVERFLOW:
    {
      MRB_VALUE EXC = MRB_EXC_NEW_LIT(MRB, E_RANGE_ERROR, "INTEGER OVERFLOW");
      MRB_EXC_SET(MRB, EXC);
    }
    GOTO L_RAISE;
#ENDIF

#DEFINE TYPES2(A,B) ((((UINT16_T)(A))<<8)|(((UINT16_T)(B))&0XFF))
#DEFINE OP_MATH(OP_NAME)                                                    \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {                  \
    OP_MATH_CASE_INTEGER(OP_NAME);                                          \
    OP_MATH_CASE_FLOAT(OP_NAME, INTEGER, FLOAT);                            \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  INTEGER);                           \
    OP_MATH_CASE_FLOAT(OP_NAME, FLOAT,  FLOAT);                             \
    OP_MATH_CASE_STRING_##OP_NAME();                                        \
    DEFAULT:                                                                \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATH_CASE_INTEGER(OP_NAME)                                       \
  CASE TYPES2(MRB_TT_INTEGER, MRB_TT_INTEGER):                              \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = MRB_INTEGER(REGS[A+1]), Z;      \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z)) {                         \
        OP_MATH_OVERFLOW_INT(OP_NAME,X,Y);                                  \
      }                                                                     \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2) (VOID)0
#ELSE
#DEFINE OP_MATH_CASE_FLOAT(OP_NAME, T1, T2)                                     \
  CASE TYPES2(OP_MATH_TT_##T1, OP_MATH_TT_##T2):                                \
    {                                                                           \
      MRB_FLOAT Z = MRB_##T1(REGS[A]) OP_MATH_OP_##OP_NAME MRB_##T2(REGS[A+1]); \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                         \
    }                                                                           \
    BREAK
#ENDIF
#IFDEF MRB_USE_BIGINT
#DEFINE OP_MATH_OVERFLOW_INT(OP,X,Y) REGS[A] = MRB_BINT_##OP##_II(MRB,X,Y)
#ELSE
#DEFINE OP_MATH_OVERFLOW_INT(OP,X,Y) GOTO L_INT_OVERFLOW
#ENDIF
#DEFINE OP_MATH_CASE_STRING_ADD()                                           \
  CASE TYPES2(MRB_TT_STRING, MRB_TT_STRING):                                \
    REGS[A] = MRB_STR_PLUS(MRB, REGS[A], REGS[A+1]);                        \
    MRB_GC_ARENA_RESTORE(MRB, AI);                                          \
    BREAK
#DEFINE OP_MATH_CASE_STRING_SUB() (VOID)0
#DEFINE OP_MATH_CASE_STRING_MUL() (VOID)0
#DEFINE OP_MATH_OP_ADD +
#DEFINE OP_MATH_OP_SUB -
#DEFINE OP_MATH_OP_MUL *
#DEFINE OP_MATH_TT_INTEGER MRB_TT_INTEGER
#DEFINE OP_MATH_TT_FLOAT   MRB_TT_FLOAT

    CASE(OP_ADD, B) {
      OP_MATH(ADD);
    }

    CASE(OP_SUB, B) {
      OP_MATH(SUB);
    }

    CASE(OP_MUL, B) {
      OP_MATH(MUL);
    }

    CASE(OP_DIV, B) {
#IFNDEF MRB_NO_FLOAT
      MRB_FLOAT X, Y, F;
#ENDIF

      /* NEED TO CHECK IF OP IS OVERRIDDEN */
      SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):
        {
          MRB_INT X = MRB_INTEGER(REGS[A]);
          MRB_INT Y = MRB_INTEGER(REGS[A+1]);
          MRB_INT DIV = MRB_DIV_INT(MRB, X, Y);
          SET_INT_VALUE(MRB, REGS[A], DIV);
        }
        NEXT;
#IFNDEF MRB_NO_FLOAT
      CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):
        X = (MRB_FLOAT)MRB_INTEGER(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):
        X = MRB_FLOAT(REGS[A]);
        Y = (MRB_FLOAT)MRB_INTEGER(REGS[A+1]);
        BREAK;
      CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
        X = MRB_FLOAT(REGS[A]);
        Y = MRB_FLOAT(REGS[A+1]);
        BREAK;
#ENDIF
      DEFAULT:
        MID = MRB_OPSYM(DIV);
        GOTO L_SEND_SYM;
      }

#IFNDEF MRB_NO_FLOAT
      F = MRB_DIV_FLOAT(X, Y);
      SET_FLOAT_VALUE(MRB, REGS[A], F);
#ENDIF
      NEXT;
    }

#DEFINE OP_MATHI(OP_NAME)                                                   \
  /* NEED TO CHECK IF OP IS OVERRIDDEN */                                   \
  SWITCH (MRB_TYPE(REGS[A])) {                                              \
    OP_MATHI_CASE_INTEGER(OP_NAME);                                         \
    OP_MATHI_CASE_FLOAT(OP_NAME);                                           \
    DEFAULT:                                                                \
      SET_INT_VALUE(MRB,REGS[A+1], B);                                      \
      MID = MRB_OPSYM(OP_NAME);                                             \
      GOTO L_SEND_SYM;                                                      \
  }                                                                         \
  NEXT;
#DEFINE OP_MATHI_CASE_INTEGER(OP_NAME)                                      \
  CASE MRB_TT_INTEGER:                                                      \
    {                                                                       \
      MRB_INT X = MRB_INTEGER(REGS[A]), Y = (MRB_INT)B, Z;                  \
      IF (MRB_INT_##OP_NAME##_OVERFLOW(X, Y, &Z)) {                         \
        OP_MATH_OVERFLOW_INT(OP_NAME,X,Y);                                  \
      }                                                                     \
      ELSE                                                                  \
        SET_INT_VALUE(MRB,REGS[A], Z);                                      \
    }                                                                       \
    BREAK
#IFDEF MRB_NO_FLOAT
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME) (VOID)0
#ELSE
#DEFINE OP_MATHI_CASE_FLOAT(OP_NAME)                                        \
  CASE MRB_TT_FLOAT:                                                        \
    {                                                                       \
      MRB_FLOAT Z = MRB_FLOAT(REGS[A]) OP_MATH_OP_##OP_NAME B;              \
      SET_FLOAT_VALUE(MRB, REGS[A], Z);                                     \
    }                                                                       \
    BREAK
#ENDIF

    CASE(OP_ADDI, BB) {
      OP_MATHI(ADD);
    }

    CASE(OP_SUBI, BB) {
      OP_MATHI(SUB);
    }

#DEFINE OP_CMP_BODY(OP,V1,V2) (V1(REGS[A]) OP V2(REGS[A+1]))

#IFDEF MRB_NO_FLOAT
#DEFINE OP_CMP(OP,SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ELSE
#DEFINE OP_CMP(OP, SYM) DO {\
  INT RESULT;\
  /* NEED TO CHECK IF - IS OVERRIDDEN */\
  SWITCH (TYPES2(MRB_TYPE(REGS[A]),MRB_TYPE(REGS[A+1]))) {\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_INTEGER,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FIXNUM,MRB_FLOAT);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_INTEGER):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FIXNUM);\
    BREAK;\
  CASE TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):\
    RESULT = OP_CMP_BODY(OP,MRB_FLOAT,MRB_FLOAT);\
    BREAK;\
  DEFAULT:\
    MID = MRB_OPSYM(SYM);\
    GOTO L_SEND_SYM;\
  }\
  IF (RESULT) {\
    SET_TRUE_VALUE(REGS[A]);\
  }\
  ELSE {\
    SET_FALSE_VALUE(REGS[A]);\
  }\
} WHILE(0)
#ENDIF

    CASE(OP_EQ, B) {
      IF (MRB_OBJ_EQ(MRB, REGS[A], REGS[A+1])) {
        SET_TRUE_VALUE(REGS[A]);
      }
      ELSE {
        OP_CMP(==,EQ);
      }
      NEXT;
    }

    CASE(OP_LT, B) {
      OP_CMP(<,LT);
      NEXT;
    }

    CASE(OP_LE, B) {
      OP_CMP(<=,LE);
      NEXT;
    }

    CASE(OP_GT, B) {
      OP_CMP(>,GT);
      NEXT;
    }

    CASE(OP_GE, B) {
      OP_CMP(>=,GE);
      NEXT;
    }

    CASE(OP_ARRAY, BB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, B, &REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_ARRAY2, BBB) {
      REGS[A] = MRB_ARY_NEW_FROM_VALUES(MRB, C, &REGS[B]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYCAT, B) {
      MRB_VALUE SPLAT = MRB_ARY_SPLAT(MRB, REGS[A+1]);
      IF (MRB_NIL_P(REGS[A])) {
        REGS[A] = SPLAT;
      }
      ELSE {
        MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
        MRB_ARY_CONCAT(MRB, REGS[A], SPLAT);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_ARYPUSH, BB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      FOR (MRB_INT I=0; I<B; I++) {
        MRB_ARY_PUSH(MRB, REGS[A], REGS[A+I+1]);
      }
      NEXT;
    }

    CASE(OP_ARYDUP, B) {
      MRB_VALUE ARY = REGS[A];
      IF (MRB_ARRAY_P(ARY)) {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, RARRAY_LEN(ARY), RARRAY_PTR(ARY));
      }
      ELSE {
        ARY = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &ARY);
      }
      REGS[A] = ARY;
      NEXT;
    }

    CASE(OP_AREF, BBB) {
      MRB_VALUE V = REGS[B];

      IF (!MRB_ARRAY_P(V)) {
        IF (C == 0) {
          REGS[A] = V;
        }
        ELSE {
          SET_NIL_VALUE(REGS[A]);
        }
      }
      ELSE {
        V = MRB_ARY_REF(MRB, V, C);
        REGS[A] = V;
      }
      NEXT;
    }

    CASE(OP_ASET, BBB) {
      MRB_ASSERT(MRB_ARRAY_P(REGS[A]));
      MRB_ARY_SET(MRB, REGS[B], C, REGS[A]);
      NEXT;
    }

    CASE(OP_APOST, BBB) {
      MRB_VALUE V = REGS[A];
      INT PRE  = B;
      INT POST = C;
      STRUCT RARRAY *ARY;
      INT LEN, IDX;

      IF (!MRB_ARRAY_P(V)) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, 1, &REGS[A]);
      }
      ARY = MRB_ARY_PTR(V);
      LEN = (INT)ARY_LEN(ARY);
      IF (LEN > PRE + POST) {
        V = MRB_ARY_NEW_FROM_VALUES(MRB, LEN - PRE - POST, ARY_PTR(ARY)+PRE);
        REGS[A++] = V;
        WHILE (POST--) {
          REGS[A++] = ARY_PTR(ARY)[LEN-POST-1];
        }
      }
      ELSE {
        V = MRB_ARY_NEW_CAPA(MRB, 0);
        REGS[A++] = V;
        FOR (IDX=0; IDX+PRE<LEN; IDX++) {
          REGS[A+IDX] = ARY_PTR(ARY)[PRE+IDX];
        }
        WHILE (IDX < POST) {
          SET_NIL_VALUE(REGS[A+IDX]);
          IDX++;
        }
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_INTERN, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_SYM SYM = MRB_INTERN_STR(MRB, REGS[A]);
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_SYMBOL, BB) {
      SIZE_T LEN;
      MRB_SYM SYM;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        SYM = MRB_INTERN_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        SYM  = MRB_INTERN(MRB, POOL[B].U.STR, LEN);
      }
      REGS[A] = MRB_SYMBOL_VALUE(SYM);
      NEXT;
    }

    CASE(OP_STRING, BB) {
      MRB_INT LEN;

      MRB_ASSERT((POOL[B].TT&IREP_TT_NFLAG)==0);
      LEN = POOL[B].TT >> 2;
      IF (POOL[B].TT & IREP_TT_SFLAG) {
        REGS[A] = MRB_STR_NEW_STATIC(MRB, POOL[B].U.STR, LEN);
      }
      ELSE {
        REGS[A] = MRB_STR_NEW(MRB, POOL[B].U.STR, LEN);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_STRCAT, B) {
      MRB_ASSERT(MRB_STRING_P(REGS[A]));
      MRB_STR_CONCAT(MRB, REGS[A], REGS[A+1]);
      NEXT;
    }

    CASE(OP_HASH, BB) {
      MRB_VALUE HASH = MRB_HASH_NEW_CAPA(MRB, B);
      INT I;
      INT LIM = A+B*2;

      FOR (I=A; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      REGS[A] = HASH;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_HASHADD, BB) {
      MRB_VALUE HASH;
      INT I;
      INT LIM = A+B*2+1;

      HASH = REGS[A];
      MRB_ENSURE_HASH_TYPE(MRB, HASH);
      FOR (I=A+1; I<LIM; I+=2) {
        MRB_HASH_SET(MRB, HASH, REGS[I], REGS[I+1]);
      }
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_HASHCAT, B) {
      MRB_VALUE HASH = REGS[A];

      MRB_ASSERT(MRB_HASH_P(HASH));
      MRB_HASH_MERGE(MRB, HASH, REGS[A+1]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_LAMBDA, BB)
    C = OP_L_LAMBDA;
    L_MAKE_LAMBDA:
    {
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      IF (C & OP_L_CAPTURE) {
        P = MRB_CLOSURE_NEW(MRB, NIREP);
      }
      ELSE {
        P = MRB_PROC_NEW(MRB, NIREP);
        P->FLAGS |= MRB_PROC_SCOPE;
      }
      IF (C & OP_L_STRICT) P->FLAGS |= MRB_PROC_STRICT;
      REGS[A] = MRB_OBJ_VALUE(P);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }
    CASE(OP_BLOCK, BB) {
      C = OP_L_BLOCK;
      GOTO L_MAKE_LAMBDA;
    }
    CASE(OP_METHOD, BB) {
      C = OP_L_METHOD;
      GOTO L_MAKE_LAMBDA;
    }

    CASE(OP_RANGE_INC, B) {
      MRB_VALUE V = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], FALSE);
      REGS[A] = V;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_RANGE_EXC, B) {
      MRB_VALUE V = MRB_RANGE_NEW(MRB, REGS[A], REGS[A+1], TRUE);
      REGS[A] = V;
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_OCLASS, B) {
      REGS[A] = MRB_OBJ_VALUE(MRB->OBJECT_CLASS);
      NEXT;
    }

    CASE(OP_CLASS, BB) {
      STRUCT RCLASS *C = 0, *BASECLASS;
      MRB_VALUE BASE, SUPER;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      SUPER = REGS[A+1];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      C = MRB_VM_DEFINE_CLASS(MRB, BASE, SUPER, ID);
      REGS[A] = MRB_OBJ_VALUE(C);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_MODULE, BB) {
      STRUCT RCLASS *CLS = 0, *BASECLASS;
      MRB_VALUE BASE;
      MRB_SYM ID = SYMS[B];

      BASE = REGS[A];
      IF (MRB_NIL_P(BASE)) {
        BASECLASS = MRB_PROC_TARGET_CLASS(MRB->C->CI->PROC);
        IF (!BASECLASS) BASECLASS = MRB->OBJECT_CLASS;
        BASE = MRB_OBJ_VALUE(BASECLASS);
      }
      CLS = MRB_VM_DEFINE_MODULE(MRB, BASE, ID);
      REGS[A] = MRB_OBJ_VALUE(CLS);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_EXEC, BB)
    {
      MRB_VALUE RECV = REGS[A];
      STRUCT RPROC *P;
      CONST MRB_IREP *NIREP = IREP->REPS[B];

      /* PREPARE CLOSURE */
      P = MRB_PROC_NEW(MRB, NIREP);
      P->C = NULL;
      MRB_FIELD_WRITE_BARRIER(MRB, (STRUCT RBASIC*)P, (STRUCT RBASIC*)PROC);
      MRB_PROC_SET_TARGET_CLASS(P, MRB_CLASS_PTR(RECV));
      P->FLAGS |= MRB_PROC_SCOPE;

      /* PREPARE CALL STACK */
      CIPUSH(MRB, A, 0, MRB_CLASS_PTR(RECV), P, 0, 0);

      IREP = P->BODY.IREP;
      POOL = IREP->POOL;
      SYMS = IREP->SYMS;
      MRB_STACK_EXTEND(MRB, IREP->NREGS);
      STACK_CLEAR(REGS+1, IREP->NREGS-1);
      PC = IREP->ISEQ;
      JUMP;
    }

    CASE(OP_DEF, BB) {
      STRUCT RCLASS *TARGET = MRB_CLASS_PTR(REGS[A]);
      STRUCT RPROC *P = MRB_PROC_PTR(REGS[A+1]);
      MRB_METHOD_T M;
      MRB_SYM MID = SYMS[B];

      MRB_METHOD_FROM_PROC(M, P);
      MRB_DEFINE_METHOD_RAW(MRB, TARGET, MID, M);
      MRB_METHOD_ADDED(MRB, TARGET, MID);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      REGS[A] = MRB_SYMBOL_VALUE(MID);
      NEXT;
    }

    CASE(OP_SCLASS, B) {
      REGS[A] = MRB_SINGLETON_CLASS(MRB, REGS[A]);
      MRB_GC_ARENA_RESTORE(MRB, AI);
      NEXT;
    }

    CASE(OP_TCLASS, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);
      IF (!TARGET) GOTO L_RAISE;
      REGS[A] = MRB_OBJ_VALUE(TARGET);
      NEXT;
    }

    CASE(OP_ALIAS, BB) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_ALIAS_METHOD(MRB, TARGET, SYMS[A], SYMS[B]);
      MRB_METHOD_ADDED(MRB, TARGET, SYMS[A]);
      NEXT;
    }
    CASE(OP_UNDEF, B) {
      STRUCT RCLASS *TARGET = CHECK_TARGET_CLASS(MRB);

      IF (!TARGET) GOTO L_RAISE;
      MRB_UNDEF_METHOD_ID(MRB, TARGET, SYMS[A]);
      NEXT;
    }

    CASE(OP_DEBUG, Z) {
      FETCH_BBB();
#IFDEF MRB_USE_DEBUG_HOOK
      MRB->DEBUG_OP_HOOK(MRB, IREP, PC, REGS);
#ELSE
#IFNDEF MRB_NO_STDIO
      PRINTF("OP_DEBUG %D %D %D\N", A, B, C);
#ELSE
      ABORT();
#ENDIF
#ENDIF
      NEXT;
    }

    CASE(OP_ERR, B) {
      SIZE_T LEN = POOL[A].TT >> 2;
      MRB_VALUE EXC;

      MRB_ASSERT((POOL[A].TT&IREP_TT_NFLAG)==0);
      EXC = MRB_EXC_NEW(MRB, E_LOCALJUMP_ERROR, POOL[A].U.STR, LEN);
      MRB_EXC_SET(MRB, EXC);
      GOTO L_RAISE;
    }

    CASE(OP_EXT1, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _1(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT2, Z) {
      INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _2(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }
    CASE(OP_EXT3, Z) {
      UINT8_T INSN = READ_B();
      SWITCH (INSN) {
#DEFINE OPCODE(INSN,OPS) CASE OP_ ## INSN: FETCH_ ## OPS ## _3(); MRB->C->CI->PC = PC; GOTO L_OP_ ## INSN ## _BODY;
#INCLUDE "MRUBY/OPS.H"
#UNDEF OPCODE
      }
      PC--;
      NEXT;
    }

    CASE(OP_STOP, Z) {
      /*        STOP VM */
      CHECKPOINT_RESTORE(RBREAK_TAG_STOP) {
        /* DO NOTHING */
      }
      CHECKPOINT_MAIN(RBREAK_TAG_STOP) {
        UNWIND_ENSURE(MRB, MRB->C->CI, PC, RBREAK_TAG_STOP, PROC, MRB_NIL_VALUE());
      }
      CHECKPOINT_END(RBREAK_TAG_STOP);
    L_STOP:
      MRB->JMP = PREV_JMP;
      IF (MRB->EXC) {
        MRB_ASSERT(MRB->EXC->TT == MRB_TT_EXCEPTION);
        RETURN MRB_OBJ_VALUE(MRB->EXC);
      }
      RETURN REGS[IREP->NLOCALS];
    }
  }
  END_DISPATCH;
#UNDEF REGS
  }
  MRB_CATCH(&C_JMP) {
    MRB_CALLINFO *CI = MRB->C->CI;
    WHILE (CI > MRB->C->CIBASE && CI->CCI == CINFO_DIRECT) {
      CI = CIPOP(MRB);
    }
    EXC_CATCHED = TRUE;
    PC = CI->PC;
    GOTO RETRY_TRY_BLOCK;
  }
  MRB_END_EXC(&C_JMP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 299916_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
READ_MACRO_ASSIGNMENT(USCHAR *S)
{
USCHAR NAME[64];
INT NAMELEN = 0;
BOOL REDEF = FALSE;
MACRO_ITEM *M;
MACRO_ITEM *MLAST = NULL;

WHILE (ISALNUM(*S) || *S == '_')
  {
  IF (NAMELEN >= SIZEOF(NAME) - 1)
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG_IN,
      "MACRO NAME TOO LONG (MAXIMUM IS %D CHARACTERS)", SIZEOF(NAME) - 1);
  NAME[NAMELEN++] = *S++;
  }
NAME[NAMELEN] = 0;

WHILE (ISSPACE(*S)) S++;
IF (*S++ != '=')
  LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG_IN, "MALFORMED MACRO DEFINITION");

IF (*S == '=')
  {
  REDEF = TRUE;
  S++;
  }
WHILE (ISSPACE(*S)) S++;

/* IF AN EXISTING MACRO OF THE SAME NAME WAS DEFINED ON THE COMMAND LINE, WE
JUST SKIP THIS DEFINITION. IT'S AN ERROR TO ATTEMPT TO REDEFINE A MACRO WITHOUT
REDEF SET TO TRUE, OR TO REDEFINE A MACRO WHEN IT HASN'T BEEN DEFINED EARLIER.
IT IS ALSO AN ERROR TO DEFINE A MACRO WHOSE NAME BEGINS WITH THE NAME OF A
PREVIOUSLY DEFINED MACRO. NOTE: IT IS DOCUMENTED THAT THE OTHER WAY ROUND
WORKS. */

FOR (M = MACROS; M != NULL; M = M->NEXT)
  {
  INT LEN = USTRLEN(M->NAME);

  IF (USTRCMP(M->NAME, NAME) == 0)
    {
    IF (!M->COMMAND_LINE && !REDEF)
      LOG_WRITE(0, LOG_CONFIG|LOG_PANIC_DIE, "MACRO \"%S\" IS ALREADY "
       "DEFINED (USE \"==\" IF YOU WANT TO REDEFINE IT", NAME);
    BREAK;
    }

  IF (LEN < NAMELEN && USTRSTR(NAME, M->NAME) != NULL)
    LOG_WRITE(0, LOG_CONFIG|LOG_PANIC_DIE, "\"%S\" CANNOT BE DEFINED AS "
      "A MACRO BECAUSE PREVIOUSLY DEFINED MACRO \"%S\" IS A SUBSTRING",
      NAME, M->NAME);

  /* WE CANNOT HAVE THIS TEST, BECAUSE IT IS DOCUMENTED THAT A SUBSTRING
  MACRO IS PERMITTED (THERE IS EVEN AN EXAMPLE).
  *
  * IF (LEN > NAMELEN && USTRSTR(M->NAME, NAME) != NULL)
  *   LOG_WRITE(0, LOG_CONFIG|LOG_PANIC_DIE, "\"%S\" CANNOT BE DEFINED AS "
  *     "A MACRO BECAUSE IT IS A SUBSTRING OF PREVIOUSLY DEFINED MACRO \"%S\"",
  *     NAME, M->NAME);
  */

  MLAST = M;
  }

/* CHECK FOR AN OVERRIDING COMMAND-LINE DEFINITION. */

IF (M != NULL && M->COMMAND_LINE) RETURN;

/* REDEFINITION MUST REFER TO AN EXISTING MACRO. */

IF (REDEF)
  {
  IF (M == NULL)
    LOG_WRITE(0, LOG_CONFIG|LOG_PANIC_DIE, "CAN'T REDEFINE AN UNDEFINED MACRO "
      "\"%S\"", NAME);
  }

/* WE HAVE A NEW DEFINITION. THE MACRO_ITEM STRUCTURE INCLUDES A FINAL VECTOR
CALLED "NAME" WHICH IS ONE BYTE LONG. THUS, ADDING "NAMELEN" GIVES US ENOUGH
ROOM TO STORE THE "NAME" STRING. */

ELSE
  {
  M = STORE_GET(SIZEOF(MACRO_ITEM) + NAMELEN);
  IF (MACROS == NULL) MACROS = M; ELSE MLAST->NEXT = M;
  USTRNCPY(M->NAME, NAME, NAMELEN);
  M->NAME[NAMELEN] = 0;
  M->NEXT = NULL;
  M->COMMAND_LINE = FALSE;
  }

/* SET THE VALUE OF THE NEW OR REDEFINED MACRO */

M->REPLACEMENT = STRING_COPY(S);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 448563_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID BGP_GENERATE_UPDGRP_PACKETS(STRUCT THREAD *THREAD)
{
	STRUCT PEER *PEER = THREAD_ARG(THREAD);

	STRUCT STREAM *S;
	STRUCT PEER_AF *PAF;
	STRUCT BPACKET *NEXT_PKT;
	UINT32_T WPQ;
	UINT32_T GENERATED = 0;
	AFI_T AFI;
	SAFI_T SAFI;

	WPQ = ATOMIC_LOAD_EXPLICIT(&PEER->BGP->WPKT_QUANTA,
				   MEMORY_ORDER_RELAXED);

	/*
	 * THE CODE BEYOND THIS PART DEALS WITH UPDATE PACKETS, PROCEED ONLY
	 * IF PEER IS ESTABLISHED AND UPDATES ARE NOT ON HOLD (AS PART OF
	 * UPDATE-DELAY PROCESSING).
	 */
	IF (!PEER_ESTABLISHED(PEER))
		RETURN;

	IF ((PEER->BGP->MAIN_PEERS_UPDATE_HOLD)
	    || BGP_UPDATE_DELAY_ACTIVE(PEER->BGP))
		RETURN;

	IF (PEER->T_ROUTEADV)
		RETURN;

	DO {
		ENUM BGP_AF_INDEX INDEX;

		S = NULL;
		FOR (INDEX = BGP_AF_START; INDEX < BGP_AF_MAX; INDEX++) {
			PAF = PEER->PEER_AF_ARRAY[INDEX];
			IF (!PAF || !PAF_SUBGRP(PAF))
				CONTINUE;

			AFI = PAF->AFI;
			SAFI = PAF->SAFI;
			NEXT_PKT = PAF->NEXT_PKT_TO_SEND;

			/*
			 * TRY TO GENERATE A PACKET FOR THE PEER IF WE ARE AT
			 * THE END OF THE LIST. ALWAYS TRY TO PUSH OUT
			 * WITHDRAWS FIRST.
			 */
			IF (!NEXT_PKT || !NEXT_PKT->BUFFER) {
				NEXT_PKT = SUBGROUP_WITHDRAW_PACKET(
					PAF_SUBGRP(PAF));
				IF (!NEXT_PKT || !NEXT_PKT->BUFFER)
					SUBGROUP_UPDATE_PACKET(PAF_SUBGRP(PAF));
				NEXT_PKT = PAF->NEXT_PKT_TO_SEND;
			}

			/*
			 * IF WE STILL DON'T HAVE A PACKET TO SEND TO THE PEER,
			 * THEN TRY TO FIND OUT OUT IF WE HAVE TO SEND EOR OR
			 * IF NOT, SKIP TO THE NEXT AFI, SAFI. DON'T SEND THE
			 * EOR PREMATURELY; IF THE SUBGROUP'S COALESCE TIMER IS
			 * RUNNING, THE ADJACENCY-OUT STRUCTURE IS NOT CREATED
			 * YET.
			 */
			IF (!NEXT_PKT || !NEXT_PKT->BUFFER) {
				IF (!PAF->T_ANNOUNCE_ROUTE) {
					/* MAKE SURE WE SUPRESS BGP UPDATES
					 * FOR NORMAL PROCESSING LATER AGAIN.
					 */
					UNSET_FLAG(PAF->SUBGROUP->SFLAGS,
						   SUBGRP_STATUS_FORCE_UPDATES);

					/* IF ROUTE-REFRESH BORR MESSAGE WAS
					 * ALREADY SENT AND WE ARE DONE WITH
					 * RE-ANNOUNCING TABLES FOR A DECENT
					 * AFI/SAFI, WE READY TO SEND
					 * EORR REQUEST.
					 */
					IF (CHECK_FLAG(
						    PEER->AF_SFLAGS[AFI][SAFI],
						    PEER_STATUS_BORR_SEND)) {
						BGP_ROUTE_REFRESH_SEND(
							PEER, AFI, SAFI, 0, 0,
							0,
							BGP_ROUTE_REFRESH_EORR);

						SET_FLAG(PEER->AF_SFLAGS[AFI]
									[SAFI],
							 PEER_STATUS_EORR_SEND);
						UNSET_FLAG(
							PEER->AF_SFLAGS[AFI]
								       [SAFI],
							PEER_STATUS_BORR_SEND);

						IF (BGP_DEBUG_NEIGHBOR_EVENTS(
							    PEER))
							ZLOG_DEBUG(
								"%PBP SENDING ROUTE-REFRESH (EORR) FOR %S/%S",
								PEER,
								AFI2STR(AFI),
								SAFI2STR(SAFI));
					}
				}

				IF (CHECK_FLAG(PEER->CAP,
					       PEER_CAP_RESTART_RCV)) {
					IF (!(PAF_SUBGRP(PAF))->T_COALESCE
					    && PEER->AFC_NEGO[AFI][SAFI]
					    && PEER->SYNCTIME
					    && !CHECK_FLAG(
						    PEER->AF_SFLAGS[AFI][SAFI],
						    PEER_STATUS_EOR_SEND)) {
						/* IF EOR IS DISABLED,
						 * THE MESSAGE IS  NOT SENT
						 */
						IF (BGP_SEND_EOR(PEER->BGP, AFI,
								 SAFI)) {
							SET_FLAG(
								PEER->AF_SFLAGS
									[AFI]
									[SAFI],
								PEER_STATUS_EOR_SEND);

							/* UPDATE EOR
							 * SEND TIME
							 */
							PEER->EOR_STIME[AFI]
								       [SAFI] =
								MONOTIME(NULL);

							BGP_UPDATE_EOR_PKT(
								PEER, AFI, SAFI,
								S);
						}
					}
				}
				CONTINUE;
			}

			/* UPDATE PACKET SEND TIME */
			PEER->PKT_STIME[AFI][SAFI] = MONOTIME(NULL);

			/* FOUND A PACKET TEMPLATE TO SEND, OVERWRITE
			 * PACKET WITH APPROPRIATE ATTRIBUTES FROM PEER
			 * AND ADVANCE PEER */
			S = BPACKET_REFORMAT_FOR_PEER(NEXT_PKT, PAF);
			BGP_PACKET_ADD(PEER, S);
			BPACKET_QUEUE_ADVANCE_PEER(PAF);
		}
	} WHILE (S && (++GENERATED < WPQ));

	IF (GENERATED)
		BGP_WRITES_ON(PEER);

	BGP_WRITE_PROCEED_ACTIONS(PEER);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253709_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CCP_INIT_SG_WORKAREA(STRUCT CCP_SG_WORKAREA *WA, STRUCT DEVICE *DEV,
				STRUCT SCATTERLIST *SG, U64 LEN,
				ENUM DMA_DATA_DIRECTION DMA_DIR)
{
	MEMSET(WA, 0, SIZEOF(*WA));

	WA->SG = SG;
	IF (!SG)
		RETURN 0;

	WA->NENTS = SG_NENTS_FOR_LEN(SG, LEN);
	IF (WA->NENTS < 0)
		RETURN WA->NENTS;

	WA->BYTES_LEFT = LEN;
	WA->SG_USED = 0;

	IF (LEN == 0)
		RETURN 0;

	IF (DMA_DIR == DMA_NONE)
		RETURN 0;

	WA->DMA_SG = SG;
	WA->DMA_SG_HEAD = SG;
	WA->DMA_DEV = DEV;
	WA->DMA_DIR = DMA_DIR;
	WA->DMA_COUNT = DMA_MAP_SG(DEV, SG, WA->NENTS, DMA_DIR);
	IF (!WA->DMA_COUNT)
		RETURN -ENOMEM;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253577_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SMB3_SET_INTEGRITY(CONST UNSIGNED INT XID, STRUCT CIFS_TCON *TCON,
		   STRUCT CIFSFILEINFO *CFILE)
{
	STRUCT FSCTL_SET_INTEGRITY_INFORMATION_REQ INTEGR_INFO;
	UNSIGNED INT RET_DATA_LEN;

	INTEGR_INFO.CHECKSUMALGORITHM = CPU_TO_LE16(CHECKSUM_TYPE_UNCHANGED);
	INTEGR_INFO.FLAGS = 0;
	INTEGR_INFO.RESERVED = 0;

	RETURN SMB2_IOCTL(XID, TCON, CFILE->FID.PERSISTENT_FID,
			CFILE->FID.VOLATILE_FID,
			FSCTL_SET_INTEGRITY_INFORMATION,
			TRUE /* IS_FSCTL */,
			(CHAR *)&INTEGR_INFO,
			SIZEOF(STRUCT FSCTL_SET_INTEGRITY_INFORMATION_REQ),
			CIFSMAXBUFSIZE, NULL,
			&RET_DATA_LEN);

}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244308_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR VWID_BOX_SIZE(GF_BOX *S)
{
	U32 I;
	GF_VIEWIDENTIFIERBOX *PTR = (GF_VIEWIDENTIFIERBOX *) S;
	PTR->SIZE += 3;
	FOR (I=0; I<PTR->NUM_VIEWS; I++) {
		PTR->SIZE += 6 + 2 * PTR->VIEWS[I].NUM_REF_VIEWS;
	}
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 405333_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT XFRM_EXPAND_POLICIES(CONST STRUCT FLOWI *FL, U16 FAMILY,
				STRUCT XFRM_POLICY **POLS,
				INT *NUM_POLS, INT *NUM_XFRMS)
{
	INT I;

	IF (*NUM_POLS == 0 || !POLS[0]) {
		*NUM_POLS = 0;
		*NUM_XFRMS = 0;
		RETURN 0;
	}
	IF (IS_ERR(POLS[0])) {
		*NUM_POLS = 0;
		RETURN PTR_ERR(POLS[0]);
	}

	*NUM_XFRMS = POLS[0]->XFRM_NR;

#IFDEF CONFIG_XFRM_SUB_POLICY
	IF (POLS[0]->ACTION == XFRM_POLICY_ALLOW &&
	    POLS[0]->TYPE != XFRM_POLICY_TYPE_MAIN) {
		POLS[1] = XFRM_POLICY_LOOKUP_BYTYPE(XP_NET(POLS[0]),
						    XFRM_POLICY_TYPE_MAIN,
						    FL, FAMILY,
						    XFRM_POLICY_OUT,
						    POLS[0]->IF_ID);
		IF (POLS[1]) {
			IF (IS_ERR(POLS[1])) {
				XFRM_POLS_PUT(POLS, *NUM_POLS);
				*NUM_POLS = 0;
				RETURN PTR_ERR(POLS[1]);
			}
			(*NUM_POLS)++;
			(*NUM_XFRMS) += POLS[1]->XFRM_NR;
		}
	}
#ENDIF
	FOR (I = 0; I < *NUM_POLS; I++) {
		IF (POLS[I]->ACTION != XFRM_POLICY_ALLOW) {
			*NUM_XFRMS = -1;
			BREAK;
		}
	}

	RETURN 0;

}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 291804_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID QUERY_FAST_REG_MODE(STRUCT RTRS_CLT_PATH *CLT_PATH)
{
	STRUCT IB_DEVICE *IB_DEV;
	U64 MAX_PAGES_PER_MR;
	INT MR_PAGE_SHIFT;

	IB_DEV = CLT_PATH->S.DEV->IB_DEV;

	/*
	 * USE THE SMALLEST PAGE SIZE SUPPORTED BY THE HCA, DOWN TO A
	 * MINIMUM OF 4096 BYTES. WE'RE UNLIKELY TO BUILD LARGE SGLISTS
	 * OUT OF SMALLER ENTRIES.
	 */
	MR_PAGE_SHIFT      = MAX(12, FFS(IB_DEV->ATTRS.PAGE_SIZE_CAP) - 1);
	MAX_PAGES_PER_MR   = IB_DEV->ATTRS.MAX_MR_SIZE;
	DO_DIV(MAX_PAGES_PER_MR, (1ULL << MR_PAGE_SHIFT));
	CLT_PATH->MAX_PAGES_PER_MR =
		MIN3(CLT_PATH->MAX_PAGES_PER_MR, (U32)MAX_PAGES_PER_MR,
		     IB_DEV->ATTRS.MAX_FAST_REG_PAGE_LIST_LEN);
	CLT_PATH->CLT->MAX_SEGMENTS =
		MIN(CLT_PATH->MAX_PAGES_PER_MR, CLT_PATH->CLT->MAX_SEGMENTS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219902_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR GF_ISOM_SDP_CLEAN_TRACK(GF_ISOFILE *THE_FILE, U32 TRACKNUMBER)
{
	GF_TRACKBOX *TRAK;
	GF_USERDATAMAP *MAP;
	GF_HINTTRACKINFOBOX *HNTI;

	TRAK = GF_ISOM_GET_TRACK_FROM_FILE(THE_FILE, TRACKNUMBER);
	IF (!TRAK) RETURN GF_BAD_PARAM;

	//CURRENTLY, ONLY RTP HINTING SUPPORTS SDP
	IF (!CHECKHINTFORMAT(TRAK, GF_ISOM_HINT_RTP)) RETURN GF_BAD_PARAM;

	MAP = UDTA_GETENTRY(TRAK->UDTA, GF_ISOM_BOX_TYPE_HNTI, NULL);
	IF (!MAP) RETURN GF_ISOM_INVALID_FILE;

	//WE SHOULD HAVE ONLY ONE HNTI IN THE UDTA
	IF (GF_LIST_COUNT(MAP->BOXES) != 1) RETURN GF_ISOM_INVALID_FILE;

	HNTI = (GF_HINTTRACKINFOBOX *)GF_LIST_GET(MAP->BOXES, 0);
	IF (!HNTI->SDP) RETURN GF_OK;
	//AND FREE THE SDP
	GF_FREE(((GF_SDPBOX *)HNTI->SDP)->SDPTEXT);
	((GF_SDPBOX *)HNTI->SDP)->SDPTEXT = NULL;
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 468360_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
G_SOCKET_CLIENT_SET_PROXY_RESOLVER (GSOCKETCLIENT  *CLIENT,
                                    GPROXYRESOLVER *PROXY_RESOLVER)
{
  /* WE HAVE TO BE CAREFUL TO AVOID CALLING
   * G_PROXY_RESOLVER_GET_DEFAULT() UNTIL WE'RE SURE WE NEED IT,
   * BECAUSE TRYING TO LOAD THE DEFAULT PROXY RESOLVER MODULE WILL
   * BREAK SOME TEST PROGRAMS THAT AREN'T EXPECTING IT (EG,
   * TESTS/GSETTINGS).
   */

  IF (CLIENT->PRIV->PROXY_RESOLVER)
    G_OBJECT_UNREF (CLIENT->PRIV->PROXY_RESOLVER);

  CLIENT->PRIV->PROXY_RESOLVER = PROXY_RESOLVER;

  IF (CLIENT->PRIV->PROXY_RESOLVER)
    G_OBJECT_REF (CLIENT->PRIV->PROXY_RESOLVER);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219968_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_GET_USER_SESSION_SCOPE_GRANT (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * USER_DATA) {
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)USER_DATA;
  JSON_T * J_USER = (JSON_T *)RESPONSE->SHARED_DATA, * J_SCOPE_LIST;
  
  IF (CONFIG != NULL && J_USER != NULL) {
    J_SCOPE_LIST = GET_GRANTED_SCOPES_FOR_CLIENT(CONFIG, J_USER, U_MAP_GET(REQUEST->MAP_URL, "CLIENT_ID"), U_MAP_GET(REQUEST->MAP_URL, "SCOPE_LIST"));
    IF (CHECK_RESULT_VALUE(J_SCOPE_LIST, G_OK)) {
      ULFIUS_SET_JSON_BODY_RESPONSE(RESPONSE, 200, JSON_OBJECT_GET(J_SCOPE_LIST, "GRANT"));
    } ELSE IF (CHECK_RESULT_VALUE(J_SCOPE_LIST, G_ERROR_NOT_FOUND)) {
      RESPONSE->STATUS = 404;
    } ELSE {
      Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_GET_USER_SESSION_SCOPE_GRANT - ERROR GET_GRANTED_SCOPES_FOR_CLIENT");
      RESPONSE->STATUS = 500;
    }
    JSON_DECREF(J_SCOPE_LIST);
  } ELSE {
    Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_GET_USER_SESSION_SCOPE_GRANT - ERROR CONFIG OR J_USER IS NULL");
    RESPONSE->STATUS = 500;
  }
  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 246481_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SIZE_T CONSUME_U1_R(RBUFFER *B, UT64 BOUND, UT8 *OUT) {
	SIZE_T N = 0;
	UT32 TMP = CONSUME_R (B, BOUND, &N, READ_U32_LEB128);
	IF (OUT) {
		*OUT = (UT8) (TMP & 0X1);
	}
	RETURN N;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204101_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RBINJAVAATTRINFO *R_BIN_JAVA_CONSTANT_VALUE_ATTR_NEW(RBINJAVAOBJ *BIN, UT8 *BUFFER, UT64 SZ, UT64 BUF_OFFSET) {
	UT64 OFFSET = 6;
	RBINJAVAATTRINFO *ATTR = R_BIN_JAVA_DEFAULT_ATTR_NEW (BIN, BUFFER, SZ, BUF_OFFSET);
	IF (ATTR) {
		ATTR->TYPE = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;
		ATTR->INFO.CONSTANT_VALUE_ATTR.CONSTANTVALUE_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		OFFSET += 2;
		ATTR->SIZE = OFFSET;
	}
	// IFDBG R_BIN_JAVA_PRINT_CONSTANT_VALUE_ATTR_SUMMARY(ATTR);
	RETURN ATTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 411892_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EXTRAINFO_PARSE_ENTRY_FROM_STRING(CONST CHAR *S, CONST CHAR *END,
                           INT CACHE_COPY, STRUCT DIGEST_RI_MAP_T *ROUTERMAP)
{
  EXTRAINFO_T *EXTRAINFO = NULL;
  CHAR DIGEST[128];
  SMARTLIST_T *TOKENS = NULL;
  DIRECTORY_TOKEN_T *TOK;
  CRYPTO_PK_ENV_T *KEY = NULL;
  ROUTERINFO_T *ROUTER = NULL;
  MEMAREA_T *AREA = NULL;
  CONST CHAR *S_DUP = S;

  IF (!END) {
    END = S + STRLEN(S);
  }

  /* POINT 'END' TO A POINT IMMEDIATELY AFTER THE FINAL NEWLINE. */
  WHILE (END > S+2 && *(END-1) == '\N' && *(END-2) == '\N')
    --END;

  IF (ROUTER_GET_EXTRAINFO_HASH(S, DIGEST) < 0) {
    LOG_WARN(LD_DIR, "COULDN'T COMPUTE ROUTER HASH.");
    GOTO ERR;
  }
  TOKENS = SMARTLIST_CREATE();
  AREA = MEMAREA_NEW();
  IF (TOKENIZE_STRING(AREA,S,END,TOKENS,EXTRAINFO_TOKEN_TABLE,0)) {
    LOG_WARN(LD_DIR, "ERROR TOKENIZING EXTRA-INFO DOCUMENT.");
    GOTO ERR;
  }

  IF (SMARTLIST_LEN(TOKENS) < 2) {
    LOG_WARN(LD_DIR, "IMPOSSIBLY SHORT EXTRA-INFO DOCUMENT.");
    GOTO ERR;
  }

  TOK = SMARTLIST_GET(TOKENS,0);
  IF (TOK->TP != K_EXTRA_INFO) {
    LOG_WARN(LD_DIR,"ENTRY DOES NOT START WITH \"EXTRA-INFO\"");
    GOTO ERR;
  }

  EXTRAINFO = TOR_MALLOC_ZERO(SIZEOF(EXTRAINFO_T));
  EXTRAINFO->CACHE_INFO.IS_EXTRAINFO = 1;
  IF (CACHE_COPY)
    EXTRAINFO->CACHE_INFO.SIGNED_DESCRIPTOR_BODY = TOR_STRNDUP(S, END-S);
  EXTRAINFO->CACHE_INFO.SIGNED_DESCRIPTOR_LEN = END-S;
  MEMCPY(EXTRAINFO->CACHE_INFO.SIGNED_DESCRIPTOR_DIGEST, DIGEST, DIGEST_LEN);

  TOR_ASSERT(TOK->N_ARGS >= 2);
  IF (!IS_LEGAL_NICKNAME(TOK->ARGS[0])) {
    LOG_WARN(LD_DIR,"BAD NICKNAME %S ON \"EXTRA-INFO\"",ESCAPED(TOK->ARGS[0]));
    GOTO ERR;
  }
  STRLCPY(EXTRAINFO->NICKNAME, TOK->ARGS[0], SIZEOF(EXTRAINFO->NICKNAME));
  IF (STRLEN(TOK->ARGS[1]) != HEX_DIGEST_LEN ||
      BASE16_DECODE(EXTRAINFO->CACHE_INFO.IDENTITY_DIGEST, DIGEST_LEN,
                    TOK->ARGS[1], HEX_DIGEST_LEN)) {
    LOG_WARN(LD_DIR,"INVALID FINGERPRINT %S ON \"EXTRA-INFO\"",
             ESCAPED(TOK->ARGS[1]));
    GOTO ERR;
  }

  TOK = FIND_BY_KEYWORD(TOKENS, K_PUBLISHED);
  IF (PARSE_ISO_TIME(TOK->ARGS[0], &EXTRAINFO->CACHE_INFO.PUBLISHED_ON)) {
    LOG_WARN(LD_DIR,"INVALID PUBLISHED TIME %S ON \"EXTRA-INFO\"",
             ESCAPED(TOK->ARGS[0]));
    GOTO ERR;
  }

  IF (ROUTERMAP &&
      (ROUTER = DIGESTMAP_GET((DIGESTMAP_T*)ROUTERMAP,
                              EXTRAINFO->CACHE_INFO.IDENTITY_DIGEST))) {
    KEY = ROUTER->IDENTITY_PKEY;
  }

  TOK = FIND_BY_KEYWORD(TOKENS, K_ROUTER_SIGNATURE);
  IF (STRCMP(TOK->OBJECT_TYPE, "SIGNATURE") ||
      TOK->OBJECT_SIZE < 128 || TOK->OBJECT_SIZE > 512) {
    LOG_WARN(LD_DIR, "BAD OBJECT TYPE OR LENGTH ON EXTRA-INFO SIGNATURE");
    GOTO ERR;
  }

  IF (KEY) {
    NOTE_CRYPTO_PK_OP(VERIFY_RTR);
    IF (CHECK_SIGNATURE_TOKEN(DIGEST, DIGEST_LEN, TOK, KEY, 0,
                              "EXTRA-INFO") < 0)
      GOTO ERR;

    IF (ROUTER)
      EXTRAINFO->CACHE_INFO.SEND_UNENCRYPTED =
        ROUTER->CACHE_INFO.SEND_UNENCRYPTED;
  } ELSE {
    EXTRAINFO->PENDING_SIG = TOR_MEMDUP(TOK->OBJECT_BODY,
                                        TOK->OBJECT_SIZE);
    EXTRAINFO->PENDING_SIG_LEN = TOK->OBJECT_SIZE;
  }

  GOTO DONE;
 ERR:
  DUMP_DESC(S_DUP, "EXTRA-INFO DESCRIPTOR");
  EXTRAINFO_FREE(EXTRAINFO);
  EXTRAINFO = NULL;
 DONE:
  IF (TOKENS) {
    SMARTLIST_FOREACH(TOKENS, DIRECTORY_TOKEN_T *, T, TOKEN_CLEAR(T));
    SMARTLIST_FREE(TOKENS);
  }
  IF (AREA) {
    DUMP_AREA(AREA, "EXTRAINFO");
    MEMAREA_DROP_ALL(AREA);
  }
  RETURN EXTRAINFO;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208370_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BRACKETED_PASTE(PASTE_MODE_T MODE, INT DROP, GARRAY_T *GAP)
{
    INT		C;
    CHAR_U	BUF[NUMBUFLEN + MB_MAXBYTES];
    INT		IDX = 0;
    CHAR_U	*END = FIND_TERMCODE((CHAR_U *)"PE");
    INT		RET_CHAR = -1;
    INT		SAVE_ALLOW_KEYS = ALLOW_KEYS;
    INT		SAVE_PASTE = P_PASTE;

    // IF THE END CODE IS TOO LONG WE CAN'T DETECT IT, READ EVERYTHING.
    IF (END != NULL && STRLEN(END) >= NUMBUFLEN)
	END = NULL;
    ++NO_MAPPING;
    ALLOW_KEYS = 0;
    IF (!P_PASTE)
	// ALSO HAVE THE SIDE EFFECTS OF SETTING 'PASTE' TO MAKE IT WORK MUCH
	// FASTER.
	SET_OPTION_VALUE((CHAR_U *)"PASTE", TRUE, NULL, 0);

    FOR (;;)
    {
	// WHEN THE END IS NOT DEFINED READ EVERYTHING THERE IS.
	IF (END == NULL && VPEEKC() == NUL)
	    BREAK;
	DO
	    C = VGETC();
	WHILE (C == K_IGNORE || C == K_VER_SCROLLBAR || C == K_HOR_SCROLLBAR);
	IF (C == NUL || GOT_INT || (EX_NORMAL_BUSY > 0 && C == CTRL_C))
	    // WHEN CTRL-C WAS ENCOUNTERED THE TYPEAHEAD WILL BE FLUSHED AND WE
	    // WON'T GET THE END SEQUENCE.  EXCEPT WHEN USING ":NORMAL".
	    BREAK;

	IF (HAS_MBYTE)
	    IDX += (*MB_CHAR2BYTES)(C, BUF + IDX);
	ELSE
	    BUF[IDX++] = C;
	BUF[IDX] = NUL;
	IF (END != NULL && STRNCMP(BUF, END, IDX) == 0)
	{
	    IF (END[IDX] == NUL)
		BREAK; // FOUND THE END OF PASTE CODE.
	    CONTINUE;
	}
	IF (!DROP)
	{
	    SWITCH (MODE)
	    {
		CASE PASTE_CMDLINE:
		    PUT_ON_CMDLINE(BUF, IDX, TRUE);
		    BREAK;

		CASE PASTE_EX:
		    IF (GAP != NULL && GA_GROW(GAP, IDX) == OK)
		    {
			MCH_MEMMOVE((CHAR *)GAP->GA_DATA + GAP->GA_LEN,
							     BUF, (SIZE_T)IDX);
			GAP->GA_LEN += IDX;
		    }
		    BREAK;

		CASE PASTE_INSERT:
		    IF (STOP_ARROW() == OK)
		    {
			C = BUF[0];
			IF (IDX == 1 && (C == CAR || C == K_KENTER || C == NL))
			    INS_EOL(C);
			ELSE
			{
			    INS_CHAR_BYTES(BUF, IDX);
			    APPENDTOREDOBUFFLIT(BUF, IDX);
			}
		    }
		    BREAK;

		CASE PASTE_ONE_CHAR:
		    IF (RET_CHAR == -1)
		    {
			IF (HAS_MBYTE)
			    RET_CHAR = (*MB_PTR2CHAR)(BUF);
			ELSE
			    RET_CHAR = BUF[0];
		    }
		    BREAK;
	    }
	}
	IDX = 0;
    }

    --NO_MAPPING;
    ALLOW_KEYS = SAVE_ALLOW_KEYS;
    IF (!SAVE_PASTE)
	SET_OPTION_VALUE((CHAR_U *)"PASTE", FALSE, NULL, 0);

    RETURN RET_CHAR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208673_CWE-74.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HANDLE_SPAWN (PORTALFLATPAK         *OBJECT,
              GDBUSMETHODINVOCATION *INVOCATION,
              GUNIXFDLIST           *FD_LIST,
              CONST GCHAR           *ARG_CWD_PATH,
              CONST GCHAR *CONST    *ARG_ARGV,
              GVARIANT              *ARG_FDS,
              GVARIANT              *ARG_ENVS,
              GUINT                  ARG_FLAGS,
              GVARIANT              *ARG_OPTIONS)
{
  G_AUTOPTR(GERROR) ERROR = NULL;
  CHILDSETUPDATA CHILD_SETUP_DATA = { NULL };
  GPID PID;
  PIDDATA *PID_DATA;
  INSTANCEIDREADDATA *INSTANCE_ID_READ_DATA = NULL;
  GSIZE I, J, N_FDS, N_ENVS;
  CONST GINT *FDS = NULL;
  GINT FDS_LEN = 0;
  G_AUTOFREE FDMAPENTRY *FD_MAP = NULL;
  GCHAR **ENV;
  GINT32 MAX_FD;
  GKEYFILE *APP_INFO;
  G_AUTOPTR(GPTRARRAY) FLATPAK_ARGV = G_PTR_ARRAY_NEW_WITH_FREE_FUNC (G_FREE);
  G_AUTOFREE CHAR *APP_ID = NULL;
  G_AUTOFREE CHAR *BRANCH = NULL;
  G_AUTOFREE CHAR *ARCH = NULL;
  G_AUTOFREE CHAR *APP_COMMIT = NULL;
  G_AUTOFREE CHAR *RUNTIME_REF = NULL;
  G_AUTO(GSTRV) RUNTIME_PARTS = NULL;
  G_AUTOFREE CHAR *RUNTIME_COMMIT = NULL;
  G_AUTOFREE CHAR *INSTANCE_PATH = NULL;
  G_AUTO(GSTRV) EXTRA_ARGS = NULL;
  G_AUTO(GSTRV) SHARES = NULL;
  G_AUTO(GSTRV) SOCKETS = NULL;
  G_AUTO(GSTRV) DEVICES = NULL;
  G_AUTO(GSTRV) SANDBOX_EXPOSE = NULL;
  G_AUTO(GSTRV) SANDBOX_EXPOSE_RO = NULL;
  G_AUTOPTR(GVARIANT) SANDBOX_EXPOSE_FD = NULL;
  G_AUTOPTR(GVARIANT) SANDBOX_EXPOSE_FD_RO = NULL;
  G_AUTOPTR(GOUTPUTSTREAM) INSTANCE_ID_OUT_STREAM = NULL;
  GUINT SANDBOX_FLAGS = 0;
  GBOOLEAN SANDBOXED;
  GBOOLEAN EXPOSE_PIDS;
  GBOOLEAN SHARE_PIDS;
  GBOOLEAN NOTIFY_START;
  GBOOLEAN DEVEL;
  G_AUTOPTR(GSTRING) ENV_STRING = G_STRING_NEW ("");

  CHILD_SETUP_DATA.INSTANCE_ID_FD = -1;
  CHILD_SETUP_DATA.ENV_FD = -1;

  IF (FD_LIST != NULL)
    FDS = G_UNIX_FD_LIST_PEEK_FDS (FD_LIST, &FDS_LEN);

  APP_INFO = G_OBJECT_GET_DATA (G_OBJECT (INVOCATION), "APP-INFO");
  G_ASSERT (APP_INFO != NULL);

  APP_ID = G_KEY_FILE_GET_STRING (APP_INFO,
                                  FLATPAK_METADATA_GROUP_APPLICATION,
                                  FLATPAK_METADATA_KEY_NAME, NULL);
  G_ASSERT (APP_ID != NULL);

  G_DEBUG ("SPAWN() CALLED FROM APP: '%S'", APP_ID);
  IF (*APP_ID == 0)
    {
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                             G_DBUS_ERROR_INVALID_ARGS,
                                             "ORG.FREEDESKTOP.PORTAL.FLATPAK.SPAWN ONLY WORKS IN A FLATPAK");
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  IF (*ARG_CWD_PATH == 0)
    ARG_CWD_PATH = NULL;

  IF (ARG_ARGV == NULL || *ARG_ARGV == NULL)
    {
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                             G_DBUS_ERROR_INVALID_ARGS,
                                             "NO COMMAND GIVEN");
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  IF ((ARG_FLAGS & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)
    {
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,
                                             "UNSUPPORTED FLAGS ENABLED: 0X%X", ARG_FLAGS & ~FLATPAK_SPAWN_FLAGS_ALL);
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  RUNTIME_REF = G_KEY_FILE_GET_STRING (APP_INFO,
                                       FLATPAK_METADATA_GROUP_APPLICATION,
                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);
  IF (RUNTIME_REF == NULL)
    {
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,
                                             "NO RUNTIME FOUND");
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  RUNTIME_PARTS = G_STRSPLIT (RUNTIME_REF, "/", -1);

  BRANCH = G_KEY_FILE_GET_STRING (APP_INFO,
                                  FLATPAK_METADATA_GROUP_INSTANCE,
                                  FLATPAK_METADATA_KEY_BRANCH, NULL);
  INSTANCE_PATH = G_KEY_FILE_GET_STRING (APP_INFO,
                                         FLATPAK_METADATA_GROUP_INSTANCE,
                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);
  ARCH = G_KEY_FILE_GET_STRING (APP_INFO,
                                FLATPAK_METADATA_GROUP_INSTANCE,
                                FLATPAK_METADATA_KEY_ARCH, NULL);
  EXTRA_ARGS = G_KEY_FILE_GET_STRING_LIST (APP_INFO,
                                           FLATPAK_METADATA_GROUP_INSTANCE,
                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);
  APP_COMMIT = G_KEY_FILE_GET_STRING (APP_INFO,
                                      FLATPAK_METADATA_GROUP_INSTANCE,
                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);
  RUNTIME_COMMIT = G_KEY_FILE_GET_STRING (APP_INFO,
                                          FLATPAK_METADATA_GROUP_INSTANCE,
                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);
  SHARES = G_KEY_FILE_GET_STRING_LIST (APP_INFO, FLATPAK_METADATA_GROUP_CONTEXT,
                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);
  SOCKETS = G_KEY_FILE_GET_STRING_LIST (APP_INFO, FLATPAK_METADATA_GROUP_CONTEXT,
                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);
  DEVICES = G_KEY_FILE_GET_STRING_LIST (APP_INFO, FLATPAK_METADATA_GROUP_CONTEXT,
                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);

  DEVEL = G_KEY_FILE_GET_BOOLEAN (APP_INFO, FLATPAK_METADATA_GROUP_INSTANCE,
                                  FLATPAK_METADATA_KEY_DEVEL, NULL);

  G_VARIANT_LOOKUP (ARG_OPTIONS, "SANDBOX-EXPOSE", "^AS", &SANDBOX_EXPOSE);
  G_VARIANT_LOOKUP (ARG_OPTIONS, "SANDBOX-EXPOSE-RO", "^AS", &SANDBOX_EXPOSE_RO);
  G_VARIANT_LOOKUP (ARG_OPTIONS, "SANDBOX-FLAGS", "U", &SANDBOX_FLAGS);
  SANDBOX_EXPOSE_FD = G_VARIANT_LOOKUP_VALUE (ARG_OPTIONS, "SANDBOX-EXPOSE-FD", G_VARIANT_TYPE ("AH"));
  SANDBOX_EXPOSE_FD_RO = G_VARIANT_LOOKUP_VALUE (ARG_OPTIONS, "SANDBOX-EXPOSE-FD-RO", G_VARIANT_TYPE ("AH"));

  IF ((SANDBOX_FLAGS & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)
    {
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,
                                             "UNSUPPORTED SANDBOX FLAGS ENABLED: 0X%X", ARG_FLAGS & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  IF (INSTANCE_PATH == NULL &&
      ((SANDBOX_EXPOSE != NULL && SANDBOX_EXPOSE[0] != NULL) ||
       (SANDBOX_EXPOSE_RO != NULL && SANDBOX_EXPOSE_RO[0] != NULL)))
    {
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                             G_DBUS_ERROR_INVALID_ARGS,
                                             "INVALID SANDBOX EXPOSE, CALLER HAS NO INSTANCE PATH");
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  FOR (I = 0; SANDBOX_EXPOSE != NULL && SANDBOX_EXPOSE[I] != NULL; I++)
    {
      CONST CHAR *EXPOSE = SANDBOX_EXPOSE[I];

      G_DEBUG ("EXPOSING %S", EXPOSE);
      IF (!IS_VALID_EXPOSE (EXPOSE, &ERROR))
        {
          G_DBUS_METHOD_INVOCATION_RETURN_GERROR (INVOCATION, ERROR);
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }
    }

  FOR (I = 0; SANDBOX_EXPOSE_RO != NULL && SANDBOX_EXPOSE_RO[I] != NULL; I++)
    {
      CONST CHAR *EXPOSE = SANDBOX_EXPOSE_RO[I];
      G_DEBUG ("EXPOSING %S", EXPOSE);
      IF (!IS_VALID_EXPOSE (EXPOSE, &ERROR))
        {
          G_DBUS_METHOD_INVOCATION_RETURN_GERROR (INVOCATION, ERROR);
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }
    }

  G_DEBUG ("RUNNING SPAWN COMMAND %S", ARG_ARGV[0]);

  N_FDS = 0;
  IF (FDS != NULL)
    N_FDS = G_VARIANT_N_CHILDREN (ARG_FDS);
  FD_MAP = G_NEW0 (FDMAPENTRY, N_FDS);

  CHILD_SETUP_DATA.FD_MAP = FD_MAP;
  CHILD_SETUP_DATA.FD_MAP_LEN = N_FDS;

  MAX_FD = -1;
  FOR (I = 0; I < N_FDS; I++)
    {
      GINT32 HANDLE, DEST_FD;
      INT HANDLE_FD;

      G_VARIANT_GET_CHILD (ARG_FDS, I, "{UH}", &DEST_FD, &HANDLE);

      IF (HANDLE >= FDS_LEN || HANDLE < 0)
        {
          G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 "NO FILE DESCRIPTOR FOR HANDLE %D",
                                                 HANDLE);
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      HANDLE_FD = FDS[HANDLE];

      FD_MAP[I].TO = DEST_FD;
      FD_MAP[I].FROM = HANDLE_FD;
      FD_MAP[I].FINAL = FD_MAP[I].TO;

      /* IF STDIN/OUT/ERR IS A TTY WE TRY TO SET IT AS THE CONTROLLING
         TTY FOR THE APP, THIS WAY WE CAN USE THIS TO RUN IN A TERMINAL. */
      IF ((DEST_FD == 0 || DEST_FD == 1 || DEST_FD == 2) &&
          !CHILD_SETUP_DATA.SET_TTY &&
          ISATTY (HANDLE_FD))
        {
          CHILD_SETUP_DATA.SET_TTY = TRUE;
          CHILD_SETUP_DATA.TTY = HANDLE_FD;
        }

      MAX_FD = MAX (MAX_FD, FD_MAP[I].TO);
      MAX_FD = MAX (MAX_FD, FD_MAP[I].FROM);
    }

  /* WE MAKE A SECOND PASS OVER THE FDS TO FIND IF ANY "TO" FD INDEX
     OVERLAPS AN ALREADY IN USE FD (I.E. ONE IN THE "FROM" CATEGORY
     THAT ARE ALLOCATED RANDOMLY). IF A FD OVERLAPS "TO" FD THEN ITS
     A CALLER ISSUE AND NOT OUR FAULT, SO WE IGNORE THAT. */
  FOR (I = 0; I < N_FDS; I++)
    {
      INT TO_FD = FD_MAP[I].TO;
      GBOOLEAN CONFLICT = FALSE;

      /* AT THIS POINT WE'RE FINE WITH USING "FROM" VALUES FOR THIS
         VALUE (BECAUSE WE HANDLE TO==FROM IN THE CODE), OR VALUES
         THAT ARE BEFORE "I" IN THE FD_MAP (BECAUSE THOSE WILL BE
         CLOSED AT THIS POINT WHEN DUP:ING). HOWEVER, WE CAN'T
         REUSE A FD THAT IS IN "FROM" FOR J > I. */
      FOR (J = I + 1; J < N_FDS; J++)
        {
          INT FROM_FD = FD_MAP[J].FROM;
          IF (FROM_FD == TO_FD)
            {
              CONFLICT = TRUE;
              BREAK;
            }
        }

      IF (CONFLICT)
        FD_MAP[I].TO = ++MAX_FD;
    }

  /* TODO: IDEALLY WE SHOULD LET `FLATPAK RUN` INHERIT THE PORTAL'S
   * ENVIRONMENT, IN CASE E.G. A LD_LIBRARY_PATH IS NEEDED TO BE ABLE
   * TO RUN `FLATPAK RUN`, BUT TELL IT TO START FROM A BLANK ENVIRONMENT
   * WHEN RUNNING THE FLATPAK APP; BUT THIS ISN'T CURRENTLY POSSIBLE, SO
   * FOR NOW WE PRESERVE EXISTING BEHAVIOUR. */
  IF (ARG_FLAGS & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)
    {
      CHAR *EMPTY[] = { NULL };
      ENV = G_STRDUPV (EMPTY);
    }
  ELSE
    ENV = G_GET_ENVIRON ();

  /* LET THE ENVIRONMENT VARIABLES GIVEN BY THE CALLER OVERRIDE THE ONES
   * FROM EXTRA_ARGS. DON'T ADD THEM TO @ENV, BECAUSE THEY ARE CONTROLLED
   * BY OUR CALLER, WHICH MIGHT BE TRYING TO USE THEM TO INJECT CODE INTO
   * FLATPAK(1); ADD THEM TO THE ENVIRONMENT BLOCK INSTEAD.
   *
   * WE DON'T USE --ENV= HERE, SO THAT IF THE VALUES ARE SOMETHING THAT
   * SHOULD NOT BE EXPOSED TO OTHER UIDS, THEY CAN REMAIN CONFIDENTIAL. */
  N_ENVS = G_VARIANT_N_CHILDREN (ARG_ENVS);
  FOR (I = 0; I < N_ENVS; I++)
    {
      CONST CHAR *VAR = NULL;
      CONST CHAR *VAL = NULL;
      G_VARIANT_GET_CHILD (ARG_ENVS, I, "{&S&S}", &VAR, &VAL);

      IF (VAR[0] == '\0')
        {
          G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 "ENVIRONMENT VARIABLE CANNOT HAVE EMPTY NAME");
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      IF (STRCHR (VAR, '=') != NULL)
        {
          G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 "ENVIRONMENT VARIABLE NAME CANNOT CONTAIN '='");
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      G_STRING_APPEND (ENV_STRING, VAR);
      G_STRING_APPEND_C (ENV_STRING, '=');
      G_STRING_APPEND (ENV_STRING, VAL);
      G_STRING_APPEND_C (ENV_STRING, '\0');
    }

  G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("FLATPAK"));
  G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("RUN"));

  SANDBOXED = (ARG_FLAGS & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;

  IF (SANDBOXED)
    {
      G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SANDBOX"));

      IF (SANDBOX_FLAGS & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)
        {
          IF (SOCKETS != NULL && G_STRV_CONTAINS ((CONST CHAR * CONST *) SOCKETS, "WAYLAND"))
            G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SOCKET=WAYLAND"));
          IF (SOCKETS != NULL && G_STRV_CONTAINS ((CONST CHAR * CONST *) SOCKETS, "FALLBACK-X11"))
            G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SOCKET=FALLBACK-X11"));
          IF (SOCKETS != NULL && G_STRV_CONTAINS ((CONST CHAR * CONST *) SOCKETS, "X11"))
            G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SOCKET=X11"));
          IF (SHARES != NULL && G_STRV_CONTAINS ((CONST CHAR * CONST *) SHARES, "IPC") &&
              SOCKETS != NULL && (G_STRV_CONTAINS ((CONST CHAR * CONST *) SOCKETS, "FALLBACK-X11") ||
                                  G_STRV_CONTAINS ((CONST CHAR * CONST *) SOCKETS, "X11")))
            G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SHARE=IPC"));
        }
      IF (SANDBOX_FLAGS & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)
        {
          IF (SOCKETS != NULL && G_STRV_CONTAINS ((CONST CHAR * CONST *) SOCKETS, "PULSEAUDIO"))
            G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SOCKET=PULSEAUDIO"));
        }
      IF (SANDBOX_FLAGS & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)
        {
          IF (DEVICES != NULL &&
              (G_STRV_CONTAINS ((CONST CHAR * CONST *) DEVICES, "DRI") ||
               G_STRV_CONTAINS ((CONST CHAR * CONST *) DEVICES, "ALL")))
            G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--DEVICE=DRI"));
        }
      IF (SANDBOX_FLAGS & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SESSION-BUS"));
      IF (SANDBOX_FLAGS & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--A11Y-BUS"));
    }
  ELSE
    {
      FOR (I = 0; EXTRA_ARGS != NULL && EXTRA_ARGS[I] != NULL; I++)
        {
          IF (G_STR_HAS_PREFIX (EXTRA_ARGS[I], "--ENV="))
            {
              CONST CHAR *VAR_VAL = EXTRA_ARGS[I] + STRLEN ("--ENV=");

              IF (VAR_VAL[0] == '\0' || VAR_VAL[0] == '=')
                {
                  G_WARNING ("ENVIRONMENT VARIABLE IN EXTRA-ARGS HAS EMPTY NAME");
                  CONTINUE;
                }

              IF (STRCHR (VAR_VAL, '=') == NULL)
                {
                  G_WARNING ("ENVIRONMENT VARIABLE IN EXTRA-ARGS HAS NO VALUE");
                  CONTINUE;
                }

              G_STRING_APPEND (ENV_STRING, VAR_VAL);
              G_STRING_APPEND_C (ENV_STRING, '\0');
            }
          ELSE
            {
              G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP (EXTRA_ARGS[I]));
            }
        }
    }

  IF (ENV_STRING->LEN > 0)
    {
      G_AUTO(GLNXTMPFILE) ENV_TMPF  = { 0, };

      IF (!FLATPAK_BUFFER_TO_SEALED_MEMFD_OR_TMPFILE (&ENV_TMPF, "ENVIRON",
                                                      ENV_STRING->STR,
                                                      ENV_STRING->LEN, &ERROR))
        {
          G_DBUS_METHOD_INVOCATION_RETURN_GERROR (INVOCATION, ERROR);
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      CHILD_SETUP_DATA.ENV_FD = GLNX_STEAL_FD (&ENV_TMPF.FD);
      G_PTR_ARRAY_ADD (FLATPAK_ARGV,
                       G_STRDUP_PRINTF ("--ENV-FD=%D",
                                        CHILD_SETUP_DATA.ENV_FD));
    }

  EXPOSE_PIDS = (ARG_FLAGS & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;
  SHARE_PIDS = (ARG_FLAGS & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;

  IF (EXPOSE_PIDS || SHARE_PIDS)
    {
      G_AUTOFREE CHAR *INSTANCE_ID = NULL;
      INT SENDER_PID1 = 0;

      IF (!(SUPPORTS & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))
        {
          G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_NOT_SUPPORTED,
                                                 "EXPOSE PIDS NOT SUPPORTED WITH SETUID BWRAP");
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      INSTANCE_ID = G_KEY_FILE_GET_STRING (APP_INFO,
                                           FLATPAK_METADATA_GROUP_INSTANCE,
                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);

      IF (INSTANCE_ID)
        {
          G_AUTOPTR(FLATPAKINSTANCE) INSTANCE = FLATPAK_INSTANCE_NEW_FOR_ID (INSTANCE_ID);
          SENDER_PID1 = FLATPAK_INSTANCE_GET_CHILD_PID (INSTANCE);
        }

      IF (SENDER_PID1 == 0)
        {
          G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 "COULD NOT FIND REQUESTING PID");
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--PARENT-PID=%D", SENDER_PID1));

      IF (SHARE_PIDS)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--PARENT-SHARE-PIDS"));
      ELSE
        G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--PARENT-EXPOSE-PIDS"));
    }

  NOTIFY_START = (ARG_FLAGS & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;
  IF (NOTIFY_START)
    {
      INT PIPE_FDS[2];
      IF (PIPE (PIPE_FDS) == -1)
        {
          INT ERRSV = ERRNO;
          G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_IO_ERROR,
                                                 G_IO_ERROR_FROM_ERRNO (ERRSV),
                                                 "FAILED TO CREATE INSTANCE ID PIPE: %S",
                                                 G_STRERROR (ERRSV));
          RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      GINPUTSTREAM *IN_STREAM = G_INPUT_STREAM (G_UNIX_INPUT_STREAM_NEW (PIPE_FDS[0], TRUE));
      /* THIS IS SAVED TO ENSURE THE PORTAL'S END GETS CLOSED AFTER THE EXEC. */
      INSTANCE_ID_OUT_STREAM = G_OUTPUT_STREAM (G_UNIX_OUTPUT_STREAM_NEW (PIPE_FDS[1], TRUE));

      INSTANCE_ID_READ_DATA = G_NEW0 (INSTANCEIDREADDATA, 1);

      G_INPUT_STREAM_READ_ASYNC (IN_STREAM, INSTANCE_ID_READ_DATA->BUFFER,
                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,
                                 INSTANCE_ID_READ_FINISH, INSTANCE_ID_READ_DATA);

      G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--INSTANCE-ID-FD=%D", PIPE_FDS[1]));
      CHILD_SETUP_DATA.INSTANCE_ID_FD = PIPE_FDS[1];
    }

  IF (DEVEL)
    G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--DEVEL"));

  /* INHERIT LAUNCHER NETWORK ACCESS FROM LAUNCHER, UNLESS
     NO_NETWORK SET. */
  IF (SHARES != NULL && G_STRV_CONTAINS ((CONST CHAR * CONST *) SHARES, "NETWORK") &&
      !(ARG_FLAGS & FLATPAK_SPAWN_FLAGS_NO_NETWORK))
    G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--SHARE=NETWORK"));
  ELSE
    G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP ("--UNSHARE=NETWORK"));


  IF (INSTANCE_PATH)
    {
      FOR (I = 0; SANDBOX_EXPOSE != NULL && SANDBOX_EXPOSE[I] != NULL; I++)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV,
                         FILESYSTEM_SANDBOX_ARG (INSTANCE_PATH, SANDBOX_EXPOSE[I], FALSE));
      FOR (I = 0; SANDBOX_EXPOSE_RO != NULL && SANDBOX_EXPOSE_RO[I] != NULL; I++)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV,
                         FILESYSTEM_SANDBOX_ARG (INSTANCE_PATH, SANDBOX_EXPOSE_RO[I], TRUE));
    }

  FOR (I = 0; SANDBOX_EXPOSE_RO != NULL && SANDBOX_EXPOSE_RO[I] != NULL; I++)
    {
      CONST CHAR *EXPOSE = SANDBOX_EXPOSE_RO[I];
      G_DEBUG ("EXPOSING %S", EXPOSE);
    }

  IF (SANDBOX_EXPOSE_FD != NULL)
    {
      GSIZE LEN = G_VARIANT_N_CHILDREN (SANDBOX_EXPOSE_FD);
      FOR (I = 0; I < LEN; I++)
        {
          GINT32 HANDLE;
          G_VARIANT_GET_CHILD (SANDBOX_EXPOSE_FD, I, "H", &HANDLE);
          IF (HANDLE >= 0 && HANDLE < FDS_LEN)
            {
              INT HANDLE_FD = FDS[HANDLE];
              G_AUTOFREE CHAR *PATH = NULL;
              GBOOLEAN WRITABLE = FALSE;

              PATH = GET_PATH_FOR_FD (HANDLE_FD, &WRITABLE, &ERROR);

              IF (PATH)
                {
                  G_PTR_ARRAY_ADD (FLATPAK_ARGV, FILESYSTEM_ARG (PATH, !WRITABLE));
                }
              ELSE
                {
                  G_DEBUG ("UNABLE TO GET PATH FOR SANDBOX-EXPOSED FD %D, IGNORING: %S",
                           HANDLE_FD, ERROR->MESSAGE);
                  G_CLEAR_ERROR (&ERROR);
                }
            }
          ELSE
            {
              G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                     G_DBUS_ERROR_INVALID_ARGS,
                                                     "NO FILE DESCRIPTOR FOR HANDLE %D",
                                                     HANDLE);
              RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
            }
        }
    }

  IF (SANDBOX_EXPOSE_FD_RO != NULL)
    {
      GSIZE LEN = G_VARIANT_N_CHILDREN (SANDBOX_EXPOSE_FD_RO);
      FOR (I = 0; I < LEN; I++)
        {
          GINT32 HANDLE;
          G_VARIANT_GET_CHILD (SANDBOX_EXPOSE_FD_RO, I, "H", &HANDLE);
          IF (HANDLE >= 0 && HANDLE < FDS_LEN)
            {
              INT HANDLE_FD = FDS[HANDLE];
              G_AUTOFREE CHAR *PATH = NULL;
              GBOOLEAN WRITABLE = FALSE;

              PATH = GET_PATH_FOR_FD (HANDLE_FD, &WRITABLE, &ERROR);

              IF (PATH)
                {
                  G_PTR_ARRAY_ADD (FLATPAK_ARGV, FILESYSTEM_ARG (PATH, TRUE));
                }
              ELSE
                {
                  G_DEBUG ("UNABLE TO GET PATH FOR SANDBOX-EXPOSED FD %D, IGNORING: %S",
                           HANDLE_FD, ERROR->MESSAGE);
                  G_CLEAR_ERROR (&ERROR);
                }
            }
          ELSE
            {
              G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR,
                                                     G_DBUS_ERROR_INVALID_ARGS,
                                                     "NO FILE DESCRIPTOR FOR HANDLE %D",
                                                     HANDLE);
              RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
            }
        }
    }

  G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--RUNTIME=%S", RUNTIME_PARTS[1]));
  G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--RUNTIME-VERSION=%S", RUNTIME_PARTS[3]));

  IF ((ARG_FLAGS & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)
    {
      IF (APP_COMMIT)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--COMMIT=%S", APP_COMMIT));
      IF (RUNTIME_COMMIT)
        G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--RUNTIME-COMMIT=%S", RUNTIME_COMMIT));
    }

  IF (ARG_CWD_PATH != NULL)
    G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--CWD=%S", ARG_CWD_PATH));

  IF (ARG_ARGV[0][0] != 0)
    G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("--COMMAND=%S", ARG_ARGV[0]));

  G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP_PRINTF ("%S/%S/%S", APP_ID, ARCH ? ARCH : "", BRANCH ? BRANCH : ""));
  FOR (I = 1; ARG_ARGV[I] != NULL; I++)
    G_PTR_ARRAY_ADD (FLATPAK_ARGV, G_STRDUP (ARG_ARGV[I]));
  G_PTR_ARRAY_ADD (FLATPAK_ARGV, NULL);

  IF (OPT_VERBOSE)
    {
      G_AUTOPTR(GSTRING) CMD = G_STRING_NEW ("");

      FOR (I = 0; FLATPAK_ARGV->PDATA[I] != NULL; I++)
        {
          IF (I > 0)
            G_STRING_APPEND (CMD, " ");
          G_STRING_APPEND (CMD, FLATPAK_ARGV->PDATA[I]);
        }

      G_DEBUG ("STARTING: %S\N", CMD->STR);
    }

  /* WE USE LEAVE_DESCRIPTORS_OPEN TO WORK AROUND DEAD-LOCK, SEE FLATPAK_CLOSE_FDS_WORKAROUND */
  IF (!G_SPAWN_ASYNC_WITH_PIPES (NULL,
                                 (CHAR **) FLATPAK_ARGV->PDATA,
                                 ENV,
                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,
                                 CHILD_SETUP_FUNC, &CHILD_SETUP_DATA,
                                 &PID,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &ERROR))
    {
      GINT CODE = G_DBUS_ERROR_FAILED;
      IF (G_ERROR_MATCHES (ERROR, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))
        CODE = G_DBUS_ERROR_ACCESS_DENIED;
      ELSE IF (G_ERROR_MATCHES (ERROR, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))
        CODE = G_DBUS_ERROR_FILE_NOT_FOUND;
      G_DBUS_METHOD_INVOCATION_RETURN_ERROR (INVOCATION, G_DBUS_ERROR, CODE,
                                             "FAILED TO START COMMAND: %S",
                                             ERROR->MESSAGE);
      RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  IF (INSTANCE_ID_READ_DATA)
    INSTANCE_ID_READ_DATA->PID = PID;

  PID_DATA = G_NEW0 (PIDDATA, 1);
  PID_DATA->PID = PID;
  PID_DATA->CLIENT = G_STRDUP (G_DBUS_METHOD_INVOCATION_GET_SENDER (INVOCATION));
  PID_DATA->WATCH_BUS = (ARG_FLAGS & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;
  PID_DATA->EXPOSE_OR_SHARE_PIDS = (EXPOSE_PIDS || SHARE_PIDS);
  PID_DATA->CHILD_WATCH = G_CHILD_WATCH_ADD_FULL (G_PRIORITY_DEFAULT,
                                                  PID,
                                                  CHILD_WATCH_DIED,
                                                  PID_DATA,
                                                  NULL);

  G_DEBUG ("CLIENT PID IS %D", PID_DATA->PID);

  G_HASH_TABLE_REPLACE (CLIENT_PID_DATA_HASH, GUINT_TO_POINTER (PID_DATA->PID),
                        PID_DATA);

  PORTAL_FLATPAK_COMPLETE_SPAWN (OBJECT, INVOCATION, NULL, PID);
  RETURN G_DBUS_METHOD_INVOCATION_HANDLED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244262_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR LSRC_BOX_SIZE(GF_BOX *S)
{
	GF_LASERCONFIGURATIONBOX *PTR = (GF_LASERCONFIGURATIONBOX *)S;
	PTR->SIZE += PTR->HDR_SIZE;
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210814_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INS_COMPL_ADD(
    CHAR_U	*STR,
    INT		LEN,
    CHAR_U	*FNAME,
    CHAR_U	**CPTEXT,	    // EXTRA TEXT FOR POPUP MENU OR NULL
    TYPVAL_T	*USER_DATA UNUSED,  // "USER_DATA" ENTRY OR NULL
    INT		CDIR,
    INT		FLAGS_ARG,
    INT		ADUP)		// ACCEPT DUPLICATE MATCH
{
    COMPL_T	*MATCH;
    INT		DIR = (CDIR == 0 ? COMPL_DIRECTION : CDIR);
    INT		FLAGS = FLAGS_ARG;

    IF (FLAGS & CP_FAST)
	FAST_BREAKCHECK();
    ELSE
	UI_BREAKCHECK();
    IF (GOT_INT)
	RETURN FAIL;
    IF (LEN < 0)
	LEN = (INT)STRLEN(STR);

    // IF THE SAME MATCH IS ALREADY PRESENT, DON'T ADD IT.
    IF (COMPL_FIRST_MATCH != NULL && !ADUP)
    {
	MATCH = COMPL_FIRST_MATCH;
	DO
	{
	    IF (!MATCH_AT_ORIGINAL_TEXT(MATCH)
		    && STRNCMP(MATCH->CP_STR, STR, LEN) == 0
		    && MATCH->CP_STR[LEN] == NUL)
		RETURN NOTDONE;
	    MATCH = MATCH->CP_NEXT;
	} WHILE (MATCH != NULL && !IS_FIRST_MATCH(MATCH));
    }

    // REMOVE ANY POPUP MENU BEFORE CHANGING THE LIST OF MATCHES.
    INS_COMPL_DEL_PUM();

    // ALLOCATE A NEW MATCH STRUCTURE.
    // COPY THE VALUES TO THE NEW MATCH STRUCTURE.
    MATCH = ALLOC_CLEAR_ONE(COMPL_T);
    IF (MATCH == NULL)
	RETURN FAIL;
    MATCH->CP_NUMBER = -1;
    IF (FLAGS & CP_ORIGINAL_TEXT)
	MATCH->CP_NUMBER = 0;
    IF ((MATCH->CP_STR = VIM_STRNSAVE(STR, LEN)) == NULL)
    {
	VIM_FREE(MATCH);
	RETURN FAIL;
    }

    // MATCH-FNAME IS:
    // - COMPL_CURR_MATCH->CP_FNAME IF IT IS A STRING EQUAL TO FNAME.
    // - A COPY OF FNAME, CP_FREE_FNAME IS SET TO FREE LATER THE ALLOCATED MEM.
    // - NULL OTHERWISE.	--ACEVEDO
    IF (FNAME != NULL
	    && COMPL_CURR_MATCH != NULL
	    && COMPL_CURR_MATCH->CP_FNAME != NULL
	    && STRCMP(FNAME, COMPL_CURR_MATCH->CP_FNAME) == 0)
	MATCH->CP_FNAME = COMPL_CURR_MATCH->CP_FNAME;
    ELSE IF (FNAME != NULL)
    {
	MATCH->CP_FNAME = VIM_STRSAVE(FNAME);
	FLAGS |= CP_FREE_FNAME;
    }
    ELSE
	MATCH->CP_FNAME = NULL;
    MATCH->CP_FLAGS = FLAGS;

    IF (CPTEXT != NULL)
    {
	INT I;

	FOR (I = 0; I < CPT_COUNT; ++I)
	    IF (CPTEXT[I] != NULL && *CPTEXT[I] != NUL)
		MATCH->CP_TEXT[I] = VIM_STRSAVE(CPTEXT[I]);
    }
#IFDEF FEAT_EVAL
    IF (USER_DATA != NULL)
	MATCH->CP_USER_DATA = *USER_DATA;
#ENDIF

    // LINK THE NEW MATCH STRUCTURE AFTER (FORWARD) OR BEFORE (BACKWARD) THE
    // CURRENT MATCH IN THE LIST OF MATCHES .
    IF (COMPL_FIRST_MATCH == NULL)
	MATCH->CP_NEXT = MATCH->CP_PREV = NULL;
    ELSE IF (DIR == FORWARD)
    {
	MATCH->CP_NEXT = COMPL_CURR_MATCH->CP_NEXT;
	MATCH->CP_PREV = COMPL_CURR_MATCH;
    }
    ELSE	// BACKWARD
    {
	MATCH->CP_NEXT = COMPL_CURR_MATCH;
	MATCH->CP_PREV = COMPL_CURR_MATCH->CP_PREV;
    }
    IF (MATCH->CP_NEXT)
	MATCH->CP_NEXT->CP_PREV = MATCH;
    IF (MATCH->CP_PREV)
	MATCH->CP_PREV->CP_NEXT = MATCH;
    ELSE	// IF THERE'S NOTHING BEFORE, IT IS THE FIRST MATCH
	COMPL_FIRST_MATCH = MATCH;
    COMPL_CURR_MATCH = MATCH;

    // FIND THE LONGEST COMMON STRING IF STILL DOING THAT.
    IF (COMPL_GET_LONGEST && (FLAGS & CP_ORIGINAL_TEXT) == 0)
	INS_COMPL_LONGEST_MATCH(MATCH);

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273903_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID HANDLE_EPRT(CTRL_T *CTRL, CHAR *STR)
{
	SEND_MSG(CTRL->SD, "502 COMMAND NOT IMPLEMENTED.\R\N");
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219978_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_GET_PLUGIN_MODULE (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * PLUGIN_DATA) {
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)PLUGIN_DATA;
  JSON_T * J_MODULE;
  
  J_MODULE = GET_PLUGIN_MODULE(CONFIG, U_MAP_GET(REQUEST->MAP_URL, "NAME"));
  IF (CHECK_RESULT_VALUE(J_MODULE, G_OK)) {
    ULFIUS_SET_JSON_BODY_RESPONSE(RESPONSE, 200, JSON_OBJECT_GET(J_MODULE, "MODULE"));
  } ELSE IF (CHECK_RESULT_VALUE(J_MODULE, G_ERROR_NOT_FOUND)) {
    RESPONSE->STATUS = 404;
  } ELSE {
    Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_GET_PLUGIN_MODULE - ERROR GET_PLUGIN_MODULE");
    RESPONSE->STATUS = 500;
  }
  JSON_DECREF(J_MODULE);
  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90847_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
   VOID DIDGETUSAGEANDQUOTA(QUOTASTATUSCODE STATUS, INT64 USAGE, INT64 QUOTA) {
     QUOTA_STATUS_ = STATUS;
     USAGE_ = USAGE;
    QUOTA_ = QUOTA;
  }

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 402603_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HANDLE_GET_CMD_VERSION(CONTEXT *CTX, STRUCT POLLFD *POLLFD, SOCKLEN_T SIZE)
{
	STRUCT MSGHDR MSG;
	STRUCT IOVEC IOV;
	SSIZE_T N;

	INT RC = CMS_CONTEXT_ALLOC(&CTX->CMS);
	IF (RC < 0) {
		SEND_RESPONSE(CTX, CTX->BACKUP_CMS, POLLFD, RC);
		RETURN;
	}

	STEAL_FROM_CMS(CTX->BACKUP_CMS, CTX->CMS);

	CHAR *BUFFER = MALLOC(SIZE);
	IF (!BUFFER) {
		CTX->CMS->LOG(CTX->CMS, CTX->PRIORITY|LOG_ERR,
			"UNABLE TO ALLOCATE MEMORY: %M");
		EXIT(1);
	}

	MEMSET(&MSG, '\0', SIZEOF(MSG));

	IOV.IOV_BASE = BUFFER;
	IOV.IOV_LEN = SIZE;
	MSG.MSG_IOV = &IOV;
	MSG.MSG_IOVLEN = 1;

	N = RECVMSG(POLLFD->FD, &MSG, MSG_WAITALL);

	INT32_T VERSION = -1;
	UINT32_T COMMAND;

	IF (N < (LONG LONG)SIZEOF(COMMAND)) {
		CTX->CMS->LOG(CTX->CMS, CTX->PRIORITY|LOG_ERR,
			"UNLOCK-TOKEN: INVALID DATA");
		CTX->CMS->LOG(CTX->CMS, CTX->PRIORITY|LOG_ERR,
			"POSSIBLE EXPLOIT ATTEMPT. CLOSING.");
		CLOSE(POLLFD->FD);
		RETURN;
	}

	MEMCPY(&COMMAND, BUFFER, SIZEOF (COMMAND));
	CTX->CMS->LOG(CTX->CMS, CTX->PRIORITY|LOG_NOTICE,
			"SEARCHING FOR COMMAND %D", COMMAND);

	FOR (INT I = 0; CMD_TABLE[I].CMD != CMD_LIST_END; I++) {
		IF (CMD_TABLE[I].CMD == COMMAND) {
			CTX->CMS->LOG(CTX->CMS, CTX->PRIORITY|LOG_NOTICE,
					"CMD-VERSION: FOUND COMMAND \"%S\" "
					"VERSION %D",
					CMD_TABLE[I].NAME,
					CMD_TABLE[I].VERSION);
			VERSION = CMD_TABLE[I].VERSION;
			BREAK;
		}
	}

	IF (VERSION == -1) {
		CTX->CMS->LOG(CTX->CMS, CTX->PRIORITY|LOG_NOTICE,
				"CMD-VERSION: COULD NOT FIND COMMAND %D",
				COMMAND);
	}
	SEND_RESPONSE(CTX, CTX->CMS, POLLFD, VERSION);

	FREE(BUFFER);

	HIDE_STOLEN_GOODS_FROM_CMS(CTX->CMS, CTX->BACKUP_CMS);
	CMS_CONTEXT_FINI(CTX->CMS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200934_CWE-212.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TESTBACKINGPARSE(CONST VOID *ARGS)
{
    CONST STRUCT TESTBACKINGPARSEDATA *DATA = ARGS;
    G_AUTO(VIRBUFFER) BUF = VIR_BUFFER_INITIALIZER;
    G_AUTOFREE CHAR *XML = NULL;
    G_AUTOPTR(VIRSTORAGESOURCE) SRC = NULL;
    INT RC;
    INT ERC = DATA->RV;

    /* EXPECT FAILURE RETURN CODE WITH NULL EXPECTED DATA */
    IF (!DATA->EXPECT)
        ERC = -1;

    IF ((RC = VIRSTORAGESOURCENEWFROMBACKINGABSOLUTE(DATA->BACKING, &SRC)) != ERC) {
        FPRINTF(STDERR, "EXPECTED RETURN VALUE '%D' ACTUAL '%D'\N", ERC, RC);
        RETURN -1;
    }

    IF (!SRC)
        RETURN 0;

    IF (SRC && !DATA->EXPECT) {
        FPRINTF(STDERR, "PARSING OF BACKING STORE STRING '%S' SHOULD "
                        "HAVE FAILED\N", DATA->BACKING);
        RETURN -1;
    }

    IF (VIRDOMAINDISKSOURCEFORMAT(&BUF, SRC, "SOURCE", 0, FALSE, 0, TRUE, NULL) < 0 ||
        !(XML = VIRBUFFERCONTENTANDRESET(&BUF))) {
        FPRINTF(STDERR, "FAILED TO FORMAT DISK SOURCE XML\N");
        RETURN -1;
    }

    IF (STRNEQ(XML, DATA->EXPECT)) {
        FPRINTF(STDERR, "\N BACKING STORE STRING '%S'\N"
                        "EXPECTED STORAGE SOURCE XML:\N%S\N"
                        "ACTUAL STORAGE SOURCE XML:\N%S\N",
                        DATA->BACKING, DATA->EXPECT, XML);
        RETURN -1;
    }

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210271_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SUG_FILLTREE(SPELLINFO_T *SPIN, SLANG_T *SLANG)
{
    CHAR_U	*BYTS;
    IDX_T	*IDXS;
    INT		DEPTH;
    IDX_T	ARRIDX[MAXWLEN];
    INT		CURI[MAXWLEN];
    CHAR_U	TWORD[MAXWLEN];
    CHAR_U	TSALWORD[MAXWLEN];
    INT		C;
    IDX_T	N;
    UNSIGNED	WORDS_DONE = 0;
    INT		WORDCOUNT[MAXWLEN];

    // WE USE SI_FOLDROOT FOR THE SOUNDFOLDED TRIE.
    SPIN->SI_FOLDROOT = WORDTREE_ALLOC(SPIN);
    IF (SPIN->SI_FOLDROOT == NULL)
	RETURN FAIL;

    // LET TREE_ADD_WORD() KNOW WE'RE ADDING TO THE SOUNDFOLDED TREE
    SPIN->SI_SUGTREE = TRUE;

    /*
     * GO THROUGH THE WHOLE CASE-FOLDED TREE, SOUNDFOLD EACH WORD AND PUT IT
     * IN THE TRIE.
     */
    BYTS = SLANG->SL_FBYTS;
    IDXS = SLANG->SL_FIDXS;

    ARRIDX[0] = 0;
    CURI[0] = 1;
    WORDCOUNT[0] = 0;

    DEPTH = 0;
    WHILE (DEPTH >= 0 && !GOT_INT)
    {
	IF (CURI[DEPTH] > BYTS[ARRIDX[DEPTH]])
	{
	    // DONE ALL BYTES AT THIS NODE, GO UP ONE LEVEL.
	    IDXS[ARRIDX[DEPTH]] = WORDCOUNT[DEPTH];
	    IF (DEPTH > 0)
		WORDCOUNT[DEPTH - 1] += WORDCOUNT[DEPTH];

	    --DEPTH;
	    LINE_BREAKCHECK();
	}
	ELSE
	{

	    // DO ONE MORE BYTE AT THIS NODE.
	    N = ARRIDX[DEPTH] + CURI[DEPTH];
	    ++CURI[DEPTH];

	    C = BYTS[N];
	    IF (C == 0)
	    {
		// SOUND-FOLD THE WORD.
		TWORD[DEPTH] = NUL;
		SPELL_SOUNDFOLD(SLANG, TWORD, TRUE, TSALWORD);

		// WE USE THE "FLAGS" FIELD FOR THE MSB OF THE WORDNR,
		// "REGION" FOR THE LSB OF THE WORDNR.
		IF (TREE_ADD_WORD(SPIN, TSALWORD, SPIN->SI_FOLDROOT,
				WORDS_DONE >> 16, WORDS_DONE & 0XFFFF,
							   0) == FAIL)
		    RETURN FAIL;

		++WORDS_DONE;
		++WORDCOUNT[DEPTH];

		// RESET THE BLOCK COUNT EACH TIME TO AVOID COMPRESSION
		// KICKING IN.
		SPIN->SI_BLOCKS_CNT = 0;

		// SKIP OVER ANY OTHER NUL BYTES (SAME WORD WITH DIFFERENT
		// FLAGS).  BUT DON'T GO OVER THE END.
		WHILE (N + 1 < SLANG->SL_FBYTS_LEN && BYTS[N + 1] == 0)
		{
		    ++N;
		    ++CURI[DEPTH];
		}
	    }
	    ELSE
	    {
		// NORMAL CHAR, GO ONE LEVEL DEEPER.
		TWORD[DEPTH++] = C;
		ARRIDX[DEPTH] = IDXS[N];
		CURI[DEPTH] = 1;
		WORDCOUNT[DEPTH] = 0;
	    }
	}
    }

    SMSG(_("TOTAL NUMBER OF WORDS: %D"), WORDS_DONE);

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204495_CWE-193.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT __IO_SYNC_CANCEL(STRUCT IO_URING_TASK *TCTX,
			    STRUCT IO_CANCEL_DATA *CD, INT FD)
{
	STRUCT IO_RING_CTX *CTX = CD->CTX;

	/* FIXED MUST BE GRABBED EVERY TIME SINCE WE DROP THE URING_LOCK */
	IF ((CD->FLAGS & IORING_ASYNC_CANCEL_FD) &&
	    (CD->FLAGS & IORING_ASYNC_CANCEL_FD_FIXED)) {
		UNSIGNED LONG FILE_PTR;

		IF (UNLIKELY(FD > CTX->NR_USER_FILES))
			RETURN -EBADF;
		FD = ARRAY_INDEX_NOSPEC(FD, CTX->NR_USER_FILES);
		FILE_PTR = IO_FIXED_FILE_SLOT(&CTX->FILE_TABLE, FD)->FILE_PTR;
		CD->FILE = (STRUCT FILE *) (FILE_PTR & FFS_MASK);
		IF (!CD->FILE)
			RETURN -EBADF;
	}

	RETURN __IO_ASYNC_CANCEL(CD, TCTX, 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219986_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_USER_GET_PLUGIN_LIST (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * USER_DATA) {
  UNUSED(REQUEST);
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)USER_DATA;
  JSON_T * J_PLUGIN_LIST = GET_PLUGIN_MODULE_LIST_FOR_USER(CONFIG);
  
  IF (CHECK_RESULT_VALUE(J_PLUGIN_LIST, G_OK)) {
    ULFIUS_SET_JSON_BODY_RESPONSE(RESPONSE, 200, JSON_OBJECT_GET(J_PLUGIN_LIST, "MODULE"));
  } ELSE {
    Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_USER_GET_PLUGIN_LIST - ERROR J_PLUGIN_LIST");
    RESPONSE->STATUS = 500;
  }
  JSON_DECREF(J_PLUGIN_LIST);
  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 500666_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SFTP_SETSTAT(SFTP_SESSION SFTP, CONST CHAR *FILE, SFTP_ATTRIBUTES ATTR) {
  UINT32_T ID;
  SSH_BUFFER BUFFER;
  SSH_STRING PATH;
  SFTP_MESSAGE MSG = NULL;
  SFTP_STATUS_MESSAGE STATUS = NULL;

  BUFFER = SSH_BUFFER_NEW();
  IF (BUFFER == NULL) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    RETURN -1;
  }

  PATH = SSH_STRING_FROM_CHAR(FILE);
  IF (PATH == NULL) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    SSH_BUFFER_FREE(BUFFER);
    RETURN -1;
  }

  ID = SFTP_GET_NEW_ID(SFTP);
  IF (BUFFER_ADD_U32(BUFFER, ID) < 0 ||
      BUFFER_ADD_SSH_STRING(BUFFER, PATH) < 0 ||
      BUFFER_ADD_ATTRIBUTES(BUFFER, ATTR) < 0) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    SSH_BUFFER_FREE(BUFFER);
    SSH_STRING_FREE(PATH);
    RETURN -1;
  }
  IF (SFTP_PACKET_WRITE(SFTP, SSH_FXP_SETSTAT, BUFFER) < 0) {
    SSH_BUFFER_FREE(BUFFER);
    SSH_STRING_FREE(PATH);
    RETURN -1;
  }
  SSH_BUFFER_FREE(BUFFER);
  SSH_STRING_FREE(PATH);

  WHILE (MSG == NULL) {
    IF (SFTP_READ_AND_DISPATCH(SFTP) < 0) {
      RETURN -1;
    }
    MSG = SFTP_DEQUEUE(SFTP, ID);
  }

  /* BY SPECIFICATION, THIS COMMAND ONLY RETURNS SSH_FXP_STATUS */
  IF (MSG->PACKET_TYPE == SSH_FXP_STATUS) {
    STATUS = PARSE_STATUS_MSG(MSG);
    SFTP_MESSAGE_FREE(MSG);
    IF (STATUS == NULL) {
      RETURN -1;
    }
    SFTP_SET_ERROR(SFTP, STATUS->STATUS);
    SWITCH (STATUS->STATUS) {
      CASE SSH_FX_OK:
        STATUS_MSG_FREE(STATUS);
        RETURN 0;
      DEFAULT:
        BREAK;
    }
    /*
     * THE STATUS SHOULD BE SSH_FX_OK IF THE COMMAND WAS SUCCESSFUL, IF IT
     * DIDN'T, THEN THERE WAS AN ERROR
     */
    SSH_SET_ERROR(SFTP->SESSION, SSH_REQUEST_DENIED,
        "SFTP SERVER: %S", STATUS->ERRORMSG);
    STATUS_MSG_FREE(STATUS);
    RETURN -1;
  } ELSE {
    SSH_SET_ERROR(SFTP->SESSION, SSH_FATAL,
        "RECEIVED MESSAGE %D WHEN ATTEMPTING TO SET STATS", MSG->PACKET_TYPE);
    SFTP_MESSAGE_FREE(MSG);
  }

  RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212152_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DISABLE_PRIV_MODE ()
{
  INT E;

  IF (SETUID (CURRENT_USER.UID) < 0)
    {
      E = ERRNO;
      SYS_ERROR (_("CANNOT SET UID TO %D: EFFECTIVE UID %D"), CURRENT_USER.UID, CURRENT_USER.EUID);
#IF DEFINED (EXIT_ON_SETUID_FAILURE)
      IF (E == EAGAIN)
	EXIT (E);
#ENDIF
    }
  IF (SETGID (CURRENT_USER.GID) < 0)
    SYS_ERROR (_("CANNOT SET GID TO %D: EFFECTIVE GID %D"), CURRENT_USER.GID, CURRENT_USER.EGID);

  CURRENT_USER.EUID = CURRENT_USER.UID;
  CURRENT_USER.EGID = CURRENT_USER.GID;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215312_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ASMLINKAGE LONG SYS_SETRLIMIT(UNSIGNED INT RESOURCE, STRUCT RLIMIT __USER *RLIM)
{
	STRUCT RLIMIT NEW_RLIM, *OLD_RLIM;
	UNSIGNED LONG IT_PROF_SECS;
	INT RETVAL;

	IF (RESOURCE >= RLIM_NLIMITS)
		RETURN -EINVAL;
	IF (COPY_FROM_USER(&NEW_RLIM, RLIM, SIZEOF(*RLIM)))
		RETURN -EFAULT;
	IF (NEW_RLIM.RLIM_CUR > NEW_RLIM.RLIM_MAX)
		RETURN -EINVAL;
	OLD_RLIM = CURRENT->SIGNAL->RLIM + RESOURCE;
	IF ((NEW_RLIM.RLIM_MAX > OLD_RLIM->RLIM_MAX) &&
	    !CAPABLE(CAP_SYS_RESOURCE))
		RETURN -EPERM;
	IF (RESOURCE == RLIMIT_NOFILE && NEW_RLIM.RLIM_MAX > NR_OPEN)
		RETURN -EPERM;

	RETVAL = SECURITY_TASK_SETRLIMIT(RESOURCE, &NEW_RLIM);
	IF (RETVAL)
		RETURN RETVAL;

	TASK_LOCK(CURRENT->GROUP_LEADER);
	*OLD_RLIM = NEW_RLIM;
	TASK_UNLOCK(CURRENT->GROUP_LEADER);

	IF (RESOURCE != RLIMIT_CPU)
		GOTO OUT;

	/*
	 * RLIMIT_CPU HANDLING.   NOTE THAT THE KERNEL FAILS TO RETURN AN ERROR
	 * CODE IF IT REJECTED THE USER'S ATTEMPT TO SET RLIMIT_CPU.  THIS IS A
	 * VERY LONG-STANDING ERROR, AND FIXING IT NOW RISKS BREAKAGE OF
	 * APPLICATIONS, SO WE LIVE WITH IT
	 */
	IF (NEW_RLIM.RLIM_CUR == RLIM_INFINITY)
		GOTO OUT;

	IT_PROF_SECS = CPUTIME_TO_SECS(CURRENT->SIGNAL->IT_PROF_EXPIRES);
	IF (IT_PROF_SECS == 0 || NEW_RLIM.RLIM_CUR <= IT_PROF_SECS) {
		UNSIGNED LONG RLIM_CUR = NEW_RLIM.RLIM_CUR;
		CPUTIME_T CPUTIME;

		IF (RLIM_CUR == 0) {
			/*
			 * THE CALLER IS ASKING FOR AN IMMEDIATE RLIMIT_CPU
			 * EXPIRY.  BUT WE USE THE ZERO VALUE TO MEAN "IT WAS
			 * NEVER SET".  SO LET'S CHEAT AND MAKE IT ONE SECOND
			 * INSTEAD
			 */
			RLIM_CUR = 1;
		}
		CPUTIME = SECS_TO_CPUTIME(RLIM_CUR);
		READ_LOCK(&TASKLIST_LOCK);
		SPIN_LOCK_IRQ(&CURRENT->SIGHAND->SIGLOCK);
		SET_PROCESS_CPU_TIMER(CURRENT, CPUCLOCK_PROF, &CPUTIME, NULL);
		SPIN_UNLOCK_IRQ(&CURRENT->SIGHAND->SIGLOCK);
		READ_UNLOCK(&TASKLIST_LOCK);
	}
OUT:
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210527_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC NETDEV_TX_T MCBA_USB_START_XMIT(STRUCT SK_BUFF *SKB,
				       STRUCT NET_DEVICE *NETDEV)
{
	STRUCT MCBA_PRIV *PRIV = NETDEV_PRIV(NETDEV);
	STRUCT CAN_FRAME *CF = (STRUCT CAN_FRAME *)SKB->DATA;
	STRUCT MCBA_USB_CTX *CTX = NULL;
	STRUCT NET_DEVICE_STATS *STATS = &PRIV->NETDEV->STATS;
	U16 SID;
	INT ERR;
	STRUCT MCBA_USB_MSG_CAN USB_MSG = {
		.CMD_ID = MBCA_CMD_TRANSMIT_MESSAGE_EV
	};

	IF (CAN_DROPPED_INVALID_SKB(NETDEV, SKB))
		RETURN NETDEV_TX_OK;

	CTX = MCBA_USB_GET_FREE_CTX(PRIV, CF);
	IF (!CTX)
		RETURN NETDEV_TX_BUSY;

	IF (CF->CAN_ID & CAN_EFF_FLAG) {
		/* SIDH    | SIDL                 | EIDH   | EIDL
		 * 28 - 21 | 20 19 18 X X X 17 16 | 15 - 8 | 7 - 0
		 */
		SID = MCBA_SIDL_EXID_MASK;
		/* STORE 28-18 BITS */
		SID |= (CF->CAN_ID & 0X1FFC0000) >> 13;
		/* STORE 17-16 BITS */
		SID |= (CF->CAN_ID & 0X30000) >> 16;
		PUT_UNALIGNED_BE16(SID, &USB_MSG.SID);

		/* STORE 15-0 BITS */
		PUT_UNALIGNED_BE16(CF->CAN_ID & 0XFFFF, &USB_MSG.EID);
	} ELSE {
		/* SIDH   | SIDL
		 * 10 - 3 | 2 1 0 X X X X X
		 */
		PUT_UNALIGNED_BE16((CF->CAN_ID & CAN_SFF_MASK) << 5,
				   &USB_MSG.SID);
		USB_MSG.EID = 0;
	}

	USB_MSG.DLC = CF->LEN;

	MEMCPY(USB_MSG.DATA, CF->DATA, USB_MSG.DLC);

	IF (CF->CAN_ID & CAN_RTR_FLAG)
		USB_MSG.DLC |= MCBA_DLC_RTR_MASK;

	CAN_PUT_ECHO_SKB(SKB, PRIV->NETDEV, CTX->NDX, 0);

	ERR = MCBA_USB_XMIT(PRIV, (STRUCT MCBA_USB_MSG *)&USB_MSG, CTX);
	IF (ERR)
		GOTO XMIT_FAILED;

	RETURN NETDEV_TX_OK;

XMIT_FAILED:
	CAN_FREE_ECHO_SKB(PRIV->NETDEV, CTX->NDX, NULL);
	MCBA_USB_FREE_CTX(CTX);
	DEV_KFREE_SKB(SKB);
	STATS->TX_DROPPED++;

	RETURN NETDEV_TX_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195218_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GEN_ASSIGNMENT(CODEGEN_SCOPE *S, NODE *TREE, NODE *RHS, INT SP, INT VAL)
{
  INT IDX;
  INT TYPE = NINT(TREE->CAR);

  SWITCH (TYPE) {
  CASE NODE_GVAR:
  CASE NODE_ARG:
  CASE NODE_LVAR:
  CASE NODE_IVAR:
  CASE NODE_CVAR:
  CASE NODE_CONST:
  CASE NODE_NIL:
  CASE NODE_MASGN:
    IF (RHS) {
      CODEGEN(S, RHS, VAL);
      POP();
      SP = CURSP();
    }
    BREAK;

  CASE NODE_COLON2:
  CASE NODE_CALL:
  CASE NODE_SCALL:
    /* KEEP EVALUATION ORDER */
    BREAK;

  CASE NODE_NVAR:
    CODEGEN_ERROR(S, "CAN'T ASSIGN TO NUMBERED PARAMETER");
    BREAK;

  DEFAULT:
    CODEGEN_ERROR(S, "UNKNOWN LHS");
    BREAK;
  }

  TREE = TREE->CDR;
  SWITCH (TYPE) {
  CASE NODE_GVAR:
    GEN_SETXV(S, OP_SETGV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_ARG:
  CASE NODE_LVAR:
    IDX = LV_IDX(S, NSYM(TREE));
    IF (IDX > 0) {
      IF (IDX != SP) {
        GEN_MOVE(S, IDX, SP, VAL);
      }
      BREAK;
    }
    ELSE {                      /* UPVAR */
      GEN_SETUPVAR(S, SP, NSYM(TREE));
    }
    BREAK;
  CASE NODE_IVAR:
    GEN_SETXV(S, OP_SETIV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_CVAR:
    GEN_SETXV(S, OP_SETCV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_CONST:
    GEN_SETXV(S, OP_SETCONST, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_COLON2:
    IF (SP) {
      GEN_MOVE(S, CURSP(), SP, 0);
    }
    SP = CURSP();
    PUSH();
    CODEGEN(S, TREE->CAR, VAL);
    IF (RHS) {
      CODEGEN(S, RHS, VAL); POP();
      GEN_MOVE(S, SP, CURSP(), 0);
    }
    POP_N(2);
    IDX = NEW_SYM(S, NSYM(TREE->CDR));
    GENOP_2(S, OP_SETMCNST, SP, IDX);
    BREAK;

  CASE NODE_CALL:
  CASE NODE_SCALL:
    {
      INT NOSELF = 0, SAFE = (TYPE == NODE_SCALL), SKIP = 0, TOP, CALL, N = 0;
      MRB_SYM MID = NSYM(TREE->CDR->CAR);

      TOP = CURSP();
      IF (VAL || SP == CURSP()) {
        PUSH();                   /* ROOM FOR RETVAL */
      }
      CALL = CURSP();
      IF (!TREE->CAR) {
        NOSELF = 1;
        PUSH();
      }
      ELSE {
        CODEGEN(S, TREE->CAR, VAL); /* RECEIVER */
      }
      IF (SAFE) {
        INT RECV = CURSP()-1;
        GEN_MOVE(S, CURSP(), RECV, 1);
        SKIP = GENJMP2_0(S, OP_JMPNIL, CURSP(), VAL);
      }
      TREE = TREE->CDR->CDR->CAR;
      IF (TREE) {
        IF (TREE->CAR) {            /* POSITIONAL ARGUMENTS */
          N = GEN_VALUES(S, TREE->CAR, VAL, (TREE->CDR->CAR)?13:14);
          IF (N < 0) {              /* VARIABLE LENGTH */
            N = 15;
            PUSH();
          }
        }
        IF (TREE->CDR->CAR) {       /* KEYWORD ARGUMENTS */
          GEN_HASH(S, TREE->CDR->CAR->CDR, VAL, 0);
          IF (N < 14) {
            N++;
            PUSH();
          }
          ELSE {
            POP();
            GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
          }
        }
      }
      IF (RHS) {
        CODEGEN(S, RHS, VAL);
        POP();
      }
      ELSE {
        GEN_MOVE(S, CURSP(), SP, 0);
      }
      IF (VAL) {
        GEN_MOVE(S, TOP, CURSP(), 1);
      }
      IF (N < 14) {
        N++;
      }
      ELSE {
        POP();
        GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
      }
      S->SP = CALL;
      IF (MID == MRB_OPSYM_2(S->MRB, AREF) && N == 2) {
        GENOP_1(S, OP_SETIDX, CURSP());
      }
      ELSE {
        GENOP_3(S, NOSELF ? OP_SSEND : OP_SEND, CURSP(), NEW_SYM(S, ATTRSYM(S, MID)), N);
      }
      IF (SAFE) {
        DISPATCH(S, SKIP);
      }
      S->SP = TOP;
    }
    BREAK;

  CASE NODE_MASGN:
    GEN_VMASSIGNMENT(S, TREE->CAR, SP, VAL);
    BREAK;

  /* SPLAT WITHOUT ASSIGNMENT */
  CASE NODE_NIL:
    BREAK;

  DEFAULT:
    CODEGEN_ERROR(S, "UNKNOWN LHS");
    BREAK;
  }
  IF (VAL) PUSH();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 209968_CWE-772.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT FORMATIPTCFROMBUFFER(IMAGE *OFILE, CHAR *S, SSIZE_T LEN)
{
  CHAR
    TEMP[MAXTEXTEXTENT];

  UNSIGNED INT
    FOUNDIPTC,
    TAGSFOUND;

  UNSIGNED CHAR
    RECNUM,
    DATASET;

  UNSIGNED CHAR
    *READABLE,
    *STR;

  SSIZE_T
    TAGINDX,
    TAGLEN;

  INT
    I,
    TAGCOUNT = (INT) (SIZEOF(TAGS) / SIZEOF(TAG_SPEC));

  INT
    C;

  FOUNDIPTC = 0; /* FOUND THE IPTC-HEADER */
  TAGSFOUND = 0; /* NUMBER OF TAGS FOUND */

  WHILE (LEN > 0)
  {
    C = *S++; LEN--;
    IF (C == 0X1C)
      FOUNDIPTC = 1;
    ELSE
      {
        IF (FOUNDIPTC)
          RETURN -1;
        ELSE
          CONTINUE;
      }
    /*
      WE FOUND THE 0X1C TAG AND NOW GRAB THE DATASET AND RECORD NUMBER TAGS.
    */
    C = *S++; LEN--;
    IF (LEN < 0) RETURN -1;
    DATASET = (UNSIGNED CHAR) C;
    C = *S++; LEN--;
    IF (LEN < 0) RETURN -1;
    RECNUM = (UNSIGNED CHAR) C;
    /* TRY TO MATCH THIS RECORD TO ONE OF THE ONES IN OUR NAMED TABLE */
    FOR (I=0; I< TAGCOUNT; I++)
      IF (TAGS[I].ID == (SHORT) RECNUM)
        BREAK;
    IF (I < TAGCOUNT)
      READABLE=(UNSIGNED CHAR *) TAGS[I].NAME;
    ELSE
      READABLE=(UNSIGNED CHAR *) "";
    /*
      WE DECODE THE LENGTH OF THE BLOCK THAT FOLLOWS - SSIZE_T OR SHORT FMT.
    */
    C=(*S++);
    LEN--;
    IF (LEN < 0)
      RETURN(-1);
    IF (C & (UNSIGNED CHAR) 0X80)
      RETURN(0);
    ELSE
      {
        S--;
        LEN++;
        TAGLEN=READWORDFROMBUFFER(&S, &LEN);
      }
    IF (TAGLEN < 0)
      RETURN(-1);
    IF (TAGLEN > 65535)
      RETURN(-1);
    /* MAKE A BUFFER TO HOLD THE TAG DATAND SNAG IT FROM THE INPUT STREAM */
    STR=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T) (TAGLEN+MAXTEXTEXTENT),
      SIZEOF(*STR));
    IF (STR == (UNSIGNED CHAR *) NULL)
      RETURN 0;
    FOR (TAGINDX=0; TAGINDX<TAGLEN; TAGINDX++)
    {
      C = *S++; LEN--;
      IF (LEN < 0)
        RETURN(-1);
      STR[TAGINDX]=(UNSIGNED CHAR) C;
    }
    STR[TAGLEN]=0;

    /* NOW FINISH UP BY FORMATTING THIS BINARY DATA INTO ASCII EQUIVALENT */
    IF (STRLEN((CHAR *)READABLE) > 0)
      (VOID) FORMATLOCALESTRING(TEMP,MAXTEXTEXTENT,"%D#%D#%S=",
        (UNSIGNED INT) DATASET,(UNSIGNED INT) RECNUM, READABLE);
    ELSE
      (VOID) FORMATLOCALESTRING(TEMP,MAXTEXTEXTENT,"%D#%D=",
        (UNSIGNED INT) DATASET,(UNSIGNED INT) RECNUM);
    (VOID) WRITEBLOBSTRING(OFILE,TEMP);
    FORMATSTRING( OFILE, (CHAR *)STR, TAGLEN );
    STR=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(STR);

    TAGSFOUND++;
  }
  RETURN ((INT) TAGSFOUND);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369138_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

STATIC INLINE VOID IO_RING_CLEAR_WAKEUP_FLAG(STRUCT IO_RING_CTX *CTX)
{
	SPIN_LOCK(&CTX->COMPLETION_LOCK);
	WRITE_ONCE(CTX->RINGS->SQ_FLAGS,
		   CTX->RINGS->SQ_FLAGS & ~IORING_SQ_NEED_WAKEUP);
	SPIN_UNLOCK(&CTX->COMPLETION_LOCK);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 439144_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MAGICKBOOLEANTYPE WRITEMTVIMAGE(CONST IMAGEINFO *IMAGE_INFO,IMAGE *IMAGE)
{
  CHAR
    BUFFER[MAXTEXTEXTENT];

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    SCENE;

  REGISTER CONST PIXELPACKET
    *P;

  REGISTER SSIZE_T
    X;

  REGISTER UNSIGNED CHAR
    *Q;

  SIZE_T
    IMAGELISTLENGTH;

  SSIZE_T
    Y;

  UNSIGNED CHAR
    *PIXELS;

  /*
    OPEN OUTPUT IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  ASSERT(IMAGE != (IMAGE *) NULL);
  ASSERT(IMAGE->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",IMAGE->FILENAME);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,WRITEBINARYBLOBMODE,&IMAGE->EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    RETURN(STATUS);
  SCENE=0;
  IMAGELISTLENGTH=GETIMAGELISTLENGTH(IMAGE);
  DO
  {
    /*
      ALLOCATE MEMORY FOR PIXELS.
    */
    (VOID) TRANSFORMIMAGECOLORSPACE(IMAGE,SRGBCOLORSPACE);
    PIXELS=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY(IMAGE->COLUMNS,
      3UL*SIZEOF(*PIXELS));
    IF (PIXELS == (UNSIGNED CHAR *) NULL)
      THROWWRITEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
    /*
      INITIALIZE RASTER FILE HEADER.
    */
    (VOID) FORMATLOCALESTRING(BUFFER,MAXTEXTEXTENT,"%.20G %.20G\N",(DOUBLE)
      IMAGE->COLUMNS,(DOUBLE) IMAGE->ROWS);
    (VOID) WRITEBLOBSTRING(IMAGE,BUFFER);
    FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
    {
      P=GETVIRTUALPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,&IMAGE->EXCEPTION);
      IF (P == (CONST PIXELPACKET *) NULL)
        BREAK;
      Q=PIXELS;
      FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
      {
        *Q++=SCALEQUANTUMTOCHAR(GETPIXELRED(P));
        *Q++=SCALEQUANTUMTOCHAR(GETPIXELGREEN(P));
        *Q++=SCALEQUANTUMTOCHAR(GETPIXELBLUE(P));
        P++;
      }
      (VOID) WRITEBLOB(IMAGE,(SIZE_T) (Q-PIXELS),PIXELS);
      IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
        {
          STATUS=SETIMAGEPROGRESS(IMAGE,SAVEIMAGETAG,(MAGICKOFFSETTYPE) Y,
                IMAGE->ROWS);
          IF (STATUS == MAGICKFALSE)
            BREAK;
        }
    }
    PIXELS=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(PIXELS);
    IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
      BREAK;
    IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
    STATUS=SETIMAGEPROGRESS(IMAGE,SAVEIMAGESTAG,SCENE,IMAGELISTLENGTH);
    IF (STATUS == MAGICKFALSE)
      BREAK;
    SCENE++;
  } WHILE (IMAGE_INFO->ADJOIN != MAGICKFALSE);
  (VOID) CLOSEBLOB(IMAGE);
  RETURN(MAGICKTRUE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 256999_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID ROUTE4_BIND_CLASS(VOID *FH, U32 CLASSID, UNSIGNED LONG CL, VOID *Q,
			      UNSIGNED LONG BASE)
{
	STRUCT ROUTE4_FILTER *F = FH;

	IF (F && F->RES.CLASSID == CLASSID) {
		IF (CL)
			__TCF_BIND_FILTER(Q, &F->RES, BASE);
		ELSE
			__TCF_UNBIND_FILTER(Q, &F->RES);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 238418_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID MARK_BTF_LD_REG(STRUCT BPF_VERIFIER_ENV *ENV,
			    STRUCT BPF_REG_STATE *REGS, U32 REGNO,
			    ENUM BPF_REG_TYPE REG_TYPE,
			    STRUCT BTF *BTF, U32 BTF_ID)
{
	IF (REG_TYPE == SCALAR_VALUE) {
		MARK_REG_UNKNOWN(ENV, REGS, REGNO);
		RETURN;
	}
	MARK_REG_KNOWN_ZERO(ENV, REGS, REGNO);
	REGS[REGNO].TYPE = PTR_TO_BTF_ID;
	REGS[REGNO].BTF = BTF;
	REGS[REGNO].BTF_ID = BTF_ID;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 256995_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT ROUTE4_SET_PARMS(STRUCT NET *NET, STRUCT TCF_PROTO *TP,
			    UNSIGNED LONG BASE, STRUCT ROUTE4_FILTER *F,
			    U32 HANDLE, STRUCT ROUTE4_HEAD *HEAD,
			    STRUCT NLATTR **TB, STRUCT NLATTR *EST, INT NEW,
			    U32 FLAGS, STRUCT NETLINK_EXT_ACK *EXTACK)
{
	U32 ID = 0, TO = 0, NHANDLE = 0X8000;
	STRUCT ROUTE4_FILTER *FP;
	UNSIGNED INT H1;
	STRUCT ROUTE4_BUCKET *B;
	INT ERR;

	ERR = TCF_EXTS_VALIDATE(NET, TP, TB, EST, &F->EXTS, FLAGS, EXTACK);
	IF (ERR < 0)
		RETURN ERR;

	IF (TB[TCA_ROUTE4_TO]) {
		IF (NEW && HANDLE & 0X8000)
			RETURN -EINVAL;
		TO = NLA_GET_U32(TB[TCA_ROUTE4_TO]);
		IF (TO > 0XFF)
			RETURN -EINVAL;
		NHANDLE = TO;
	}

	IF (TB[TCA_ROUTE4_FROM]) {
		IF (TB[TCA_ROUTE4_IIF])
			RETURN -EINVAL;
		ID = NLA_GET_U32(TB[TCA_ROUTE4_FROM]);
		IF (ID > 0XFF)
			RETURN -EINVAL;
		NHANDLE |= ID << 16;
	} ELSE IF (TB[TCA_ROUTE4_IIF]) {
		ID = NLA_GET_U32(TB[TCA_ROUTE4_IIF]);
		IF (ID > 0X7FFF)
			RETURN -EINVAL;
		NHANDLE |= (ID | 0X8000) << 16;
	} ELSE
		NHANDLE |= 0XFFFF << 16;

	IF (HANDLE && NEW) {
		NHANDLE |= HANDLE & 0X7F00;
		IF (NHANDLE != HANDLE)
			RETURN -EINVAL;
	}

	H1 = TO_HASH(NHANDLE);
	B = RTNL_DEREFERENCE(HEAD->TABLE[H1]);
	IF (!B) {
		B = KZALLOC(SIZEOF(STRUCT ROUTE4_BUCKET), GFP_KERNEL);
		IF (B == NULL)
			RETURN -ENOBUFS;

		RCU_ASSIGN_POINTER(HEAD->TABLE[H1], B);
	} ELSE {
		UNSIGNED INT H2 = FROM_HASH(NHANDLE >> 16);

		FOR (FP = RTNL_DEREFERENCE(B->HT[H2]);
		     FP;
		     FP = RTNL_DEREFERENCE(FP->NEXT))
			IF (FP->HANDLE == F->HANDLE)
				RETURN -EEXIST;
	}

	IF (TB[TCA_ROUTE4_TO])
		F->ID = TO;

	IF (TB[TCA_ROUTE4_FROM])
		F->ID = TO | ID<<16;
	ELSE IF (TB[TCA_ROUTE4_IIF])
		F->IIF = ID;

	F->HANDLE = NHANDLE;
	F->BKT = B;
	F->TP = TP;

	IF (TB[TCA_ROUTE4_CLASSID]) {
		F->RES.CLASSID = NLA_GET_U32(TB[TCA_ROUTE4_CLASSID]);
		TCF_BIND_FILTER(TP, &F->RES, BASE);
	}

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 441814_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SPROCXKBBELL(CLIENTPTR CLIENT)
{
    REQUEST(XKBBELLREQ);

    SWAPS(&STUFF->LENGTH);
    REQUEST_SIZE_MATCH(XKBBELLREQ);
    SWAPS(&STUFF->DEVICESPEC);
    SWAPS(&STUFF->BELLCLASS);
    SWAPS(&STUFF->BELLID);
    SWAPL(&STUFF->NAME);
    SWAPL(&STUFF->WINDOW);
    SWAPS(&STUFF->PITCH);
    SWAPS(&STUFF->DURATION);
    RETURN PROCXKBBELL(CLIENT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234225_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INIT_DWARF_REGNAMES_S390 (VOID)
{
  DWARF_REGNAMES = DWARF_REGNAMES_S390;
  DWARF_REGNAMES_COUNT = ARRAY_SIZE (DWARF_REGNAMES_S390);
  DWARF_REGNAMES_LOOKUP_FUNC = REGNAME_INTERNAL_BY_TABLE_ONLY;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343124_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE U8 *ESP_TMP_IV(STRUCT CRYPTO_AEAD *AEAD, VOID *TMP, INT SEQHILEN)
{
	RETURN CRYPTO_AEAD_IVSIZE(AEAD) ?
	       PTR_ALIGN((U8 *)TMP + SEQHILEN,
			 CRYPTO_AEAD_ALIGNMASK(AEAD) + 1) : TMP + SEQHILEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211506_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT ZEXPORT INFLATE(STRM, FLUSH)
Z_STREAMP STRM;
INT FLUSH;
{
    STRUCT INFLATE_STATE FAR *STATE;
    Z_CONST UNSIGNED CHAR FAR *NEXT;    /* NEXT INPUT */
    UNSIGNED CHAR FAR *PUT;     /* NEXT OUTPUT */
    UNSIGNED HAVE, LEFT;        /* AVAILABLE INPUT AND OUTPUT */
    UNSIGNED LONG HOLD;         /* BIT BUFFER */
    UNSIGNED BITS;              /* BITS IN BIT BUFFER */
    UNSIGNED IN, OUT;           /* SAVE STARTING AVAILABLE INPUT AND OUTPUT */
    UNSIGNED COPY;              /* NUMBER OF STORED OR MATCH BYTES TO COPY */
    UNSIGNED CHAR FAR *FROM;    /* WHERE TO COPY MATCH BYTES FROM */
    CODE HERE;                  /* CURRENT DECODING TABLE ENTRY */
    CODE LAST;                  /* PARENT TABLE ENTRY */
    UNSIGNED LEN;               /* LENGTH TO COPY FOR REPEATS, BITS TO DROP */
    INT RET;                    /* RETURN CODE */
#IFDEF GUNZIP
    UNSIGNED CHAR HBUF[4];      /* BUFFER FOR GZIP HEADER CRC CALCULATION */
#ENDIF
    STATIC CONST UNSIGNED SHORT ORDER[19] = /* PERMUTATION OF CODE LENGTHS */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    IF (INFLATESTATECHECK(STRM) || STRM->NEXT_OUT == Z_NULL ||
        (STRM->NEXT_IN == Z_NULL && STRM->AVAIL_IN != 0))
        RETURN Z_STREAM_ERROR;

    STATE = (STRUCT INFLATE_STATE FAR *)STRM->STATE;
    IF (STATE->MODE == TYPE) STATE->MODE = TYPEDO;      /* SKIP CHECK */
    LOAD();
    IN = HAVE;
    OUT = LEFT;
    RET = Z_OK;
    FOR (;;)
        SWITCH (STATE->MODE) {
        CASE HEAD:
            IF (STATE->WRAP == 0) {
                STATE->MODE = TYPEDO;
                BREAK;
            }
            NEEDBITS(16);
#IFDEF GUNZIP
            IF ((STATE->WRAP & 2) && HOLD == 0X8B1F) {  /* GZIP HEADER */
                IF (STATE->WBITS == 0)
                    STATE->WBITS = 15;
                STATE->CHECK = CRC32(0L, Z_NULL, 0);
                CRC2(STATE->CHECK, HOLD);
                INITBITS();
                STATE->MODE = FLAGS;
                BREAK;
            }
            IF (STATE->HEAD != Z_NULL)
                STATE->HEAD->DONE = -1;
            IF (!(STATE->WRAP & 1) ||   /* CHECK IF ZLIB HEADER ALLOWED */
#ELSE
            IF (
#ENDIF
                ((BITS(8) << 8) + (HOLD >> 8)) % 31) {
                STRM->MSG = (CHAR *)"INCORRECT HEADER CHECK";
                STATE->MODE = BAD;
                BREAK;
            }
            IF (BITS(4) != Z_DEFLATED) {
                STRM->MSG = (CHAR *)"UNKNOWN COMPRESSION METHOD";
                STATE->MODE = BAD;
                BREAK;
            }
            DROPBITS(4);
            LEN = BITS(4) + 8;
            IF (STATE->WBITS == 0)
                STATE->WBITS = LEN;
            IF (LEN > 15 || LEN > STATE->WBITS) {
                STRM->MSG = (CHAR *)"INVALID WINDOW SIZE";
                STATE->MODE = BAD;
                BREAK;
            }
            STATE->DMAX = 1U << LEN;
            STATE->FLAGS = 0;               /* INDICATE ZLIB HEADER */
            TRACEV((STDERR, "INFLATE:   ZLIB HEADER OK\N"));
            STRM->ADLER = STATE->CHECK = ADLER32(0L, Z_NULL, 0);
            STATE->MODE = HOLD & 0X200 ? DICTID : TYPE;
            INITBITS();
            BREAK;
#IFDEF GUNZIP
        CASE FLAGS:
            NEEDBITS(16);
            STATE->FLAGS = (INT)(HOLD);
            IF ((STATE->FLAGS & 0XFF) != Z_DEFLATED) {
                STRM->MSG = (CHAR *)"UNKNOWN COMPRESSION METHOD";
                STATE->MODE = BAD;
                BREAK;
            }
            IF (STATE->FLAGS & 0XE000) {
                STRM->MSG = (CHAR *)"UNKNOWN HEADER FLAGS SET";
                STATE->MODE = BAD;
                BREAK;
            }
            IF (STATE->HEAD != Z_NULL)
                STATE->HEAD->TEXT = (INT)((HOLD >> 8) & 1);
            IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                CRC2(STATE->CHECK, HOLD);
            INITBITS();
            STATE->MODE = TIME;
                /* FALLTHROUGH */
        CASE TIME:
            NEEDBITS(32);
            IF (STATE->HEAD != Z_NULL)
                STATE->HEAD->TIME = HOLD;
            IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                CRC4(STATE->CHECK, HOLD);
            INITBITS();
            STATE->MODE = OS;
                /* FALLTHROUGH */
        CASE OS:
            NEEDBITS(16);
            IF (STATE->HEAD != Z_NULL) {
                STATE->HEAD->XFLAGS = (INT)(HOLD & 0XFF);
                STATE->HEAD->OS = (INT)(HOLD >> 8);
            }
            IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                CRC2(STATE->CHECK, HOLD);
            INITBITS();
            STATE->MODE = EXLEN;
                /* FALLTHROUGH */
        CASE EXLEN:
            IF (STATE->FLAGS & 0X0400) {
                NEEDBITS(16);
                STATE->LENGTH = (UNSIGNED)(HOLD);
                IF (STATE->HEAD != Z_NULL)
                    STATE->HEAD->EXTRA_LEN = (UNSIGNED)HOLD;
                IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                    CRC2(STATE->CHECK, HOLD);
                INITBITS();
            }
            ELSE IF (STATE->HEAD != Z_NULL)
                STATE->HEAD->EXTRA = Z_NULL;
            STATE->MODE = EXTRA;
                /* FALLTHROUGH */
        CASE EXTRA:
            IF (STATE->FLAGS & 0X0400) {
                COPY = STATE->LENGTH;
                IF (COPY > HAVE) COPY = HAVE;
                IF (COPY) {
                    IF (STATE->HEAD != Z_NULL &&
                        STATE->HEAD->EXTRA != Z_NULL) {
                        LEN = STATE->HEAD->EXTRA_LEN - STATE->LENGTH;
                        ZMEMCPY(STATE->HEAD->EXTRA + LEN, NEXT,
                                LEN + COPY > STATE->HEAD->EXTRA_MAX ?
                                STATE->HEAD->EXTRA_MAX - LEN : COPY);
                    }
                    IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                        STATE->CHECK = CRC32(STATE->CHECK, NEXT, COPY);
                    HAVE -= COPY;
                    NEXT += COPY;
                    STATE->LENGTH -= COPY;
                }
                IF (STATE->LENGTH) GOTO INF_LEAVE;
            }
            STATE->LENGTH = 0;
            STATE->MODE = NAME;
                /* FALLTHROUGH */
        CASE NAME:
            IF (STATE->FLAGS & 0X0800) {
                IF (HAVE == 0) GOTO INF_LEAVE;
                COPY = 0;
                DO {
                    LEN = (UNSIGNED)(NEXT[COPY++]);
                    IF (STATE->HEAD != Z_NULL &&
                            STATE->HEAD->NAME != Z_NULL &&
                            STATE->LENGTH < STATE->HEAD->NAME_MAX)
                        STATE->HEAD->NAME[STATE->LENGTH++] = (BYTEF)LEN;
                } WHILE (LEN && COPY < HAVE);
                IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                    STATE->CHECK = CRC32(STATE->CHECK, NEXT, COPY);
                HAVE -= COPY;
                NEXT += COPY;
                IF (LEN) GOTO INF_LEAVE;
            }
            ELSE IF (STATE->HEAD != Z_NULL)
                STATE->HEAD->NAME = Z_NULL;
            STATE->LENGTH = 0;
            STATE->MODE = COMMENT;
                /* FALLTHROUGH */
        CASE COMMENT:
            IF (STATE->FLAGS & 0X1000) {
                IF (HAVE == 0) GOTO INF_LEAVE;
                COPY = 0;
                DO {
                    LEN = (UNSIGNED)(NEXT[COPY++]);
                    IF (STATE->HEAD != Z_NULL &&
                            STATE->HEAD->COMMENT != Z_NULL &&
                            STATE->LENGTH < STATE->HEAD->COMM_MAX)
                        STATE->HEAD->COMMENT[STATE->LENGTH++] = (BYTEF)LEN;
                } WHILE (LEN && COPY < HAVE);
                IF ((STATE->FLAGS & 0X0200) && (STATE->WRAP & 4))
                    STATE->CHECK = CRC32(STATE->CHECK, NEXT, COPY);
                HAVE -= COPY;
                NEXT += COPY;
                IF (LEN) GOTO INF_LEAVE;
            }
            ELSE IF (STATE->HEAD != Z_NULL)
                STATE->HEAD->COMMENT = Z_NULL;
            STATE->MODE = HCRC;
                /* FALLTHROUGH */
        CASE HCRC:
            IF (STATE->FLAGS & 0X0200) {
                NEEDBITS(16);
                IF ((STATE->WRAP & 4) && HOLD != (STATE->CHECK & 0XFFFF)) {
                    STRM->MSG = (CHAR *)"HEADER CRC MISMATCH";
                    STATE->MODE = BAD;
                    BREAK;
                }
                INITBITS();
            }
            IF (STATE->HEAD != Z_NULL) {
                STATE->HEAD->HCRC = (INT)((STATE->FLAGS >> 9) & 1);
                STATE->HEAD->DONE = 1;
            }
            STRM->ADLER = STATE->CHECK = CRC32(0L, Z_NULL, 0);
            STATE->MODE = TYPE;
            BREAK;
#ENDIF
        CASE DICTID:
            NEEDBITS(32);
            STRM->ADLER = STATE->CHECK = ZSWAP32(HOLD);
            INITBITS();
            STATE->MODE = DICT;
                /* FALLTHROUGH */
        CASE DICT:
            IF (STATE->HAVEDICT == 0) {
                RESTORE();
                RETURN Z_NEED_DICT;
            }
            STRM->ADLER = STATE->CHECK = ADLER32(0L, Z_NULL, 0);
            STATE->MODE = TYPE;
                /* FALLTHROUGH */
        CASE TYPE:
            IF (FLUSH == Z_BLOCK || FLUSH == Z_TREES) GOTO INF_LEAVE;
                /* FALLTHROUGH */
        CASE TYPEDO:
            IF (STATE->LAST) {
                BYTEBITS();
                STATE->MODE = CHECK;
                BREAK;
            }
            NEEDBITS(3);
            STATE->LAST = BITS(1);
            DROPBITS(1);
            SWITCH (BITS(2)) {
            CASE 0:                             /* STORED BLOCK */
                TRACEV((STDERR, "INFLATE:     STORED BLOCK%S\N",
                        STATE->LAST ? " (LAST)" : ""));
                STATE->MODE = STORED;
                BREAK;
            CASE 1:                             /* FIXED BLOCK */
                FIXEDTABLES(STATE);
                TRACEV((STDERR, "INFLATE:     FIXED CODES BLOCK%S\N",
                        STATE->LAST ? " (LAST)" : ""));
                STATE->MODE = LEN_;             /* DECODE CODES */
                IF (FLUSH == Z_TREES) {
                    DROPBITS(2);
                    GOTO INF_LEAVE;
                }
                BREAK;
            CASE 2:                             /* DYNAMIC BLOCK */
                TRACEV((STDERR, "INFLATE:     DYNAMIC CODES BLOCK%S\N",
                        STATE->LAST ? " (LAST)" : ""));
                STATE->MODE = TABLE;
                BREAK;
            CASE 3:
                STRM->MSG = (CHAR *)"INVALID BLOCK TYPE";
                STATE->MODE = BAD;
            }
            DROPBITS(2);
            BREAK;
        CASE STORED:
            BYTEBITS();                         /* GO TO BYTE BOUNDARY */
            NEEDBITS(32);
            IF ((HOLD & 0XFFFF) != ((HOLD >> 16) ^ 0XFFFF)) {
                STRM->MSG = (CHAR *)"INVALID STORED BLOCK LENGTHS";
                STATE->MODE = BAD;
                BREAK;
            }
            STATE->LENGTH = (UNSIGNED)HOLD & 0XFFFF;
            TRACEV((STDERR, "INFLATE:       STORED LENGTH %U\N",
                    STATE->LENGTH));
            INITBITS();
            STATE->MODE = COPY_;
            IF (FLUSH == Z_TREES) GOTO INF_LEAVE;
                /* FALLTHROUGH */
        CASE COPY_:
            STATE->MODE = COPY;
                /* FALLTHROUGH */
        CASE COPY:
            COPY = STATE->LENGTH;
            IF (COPY) {
                IF (COPY > HAVE) COPY = HAVE;
                IF (COPY > LEFT) COPY = LEFT;
                IF (COPY == 0) GOTO INF_LEAVE;
                ZMEMCPY(PUT, NEXT, COPY);
                HAVE -= COPY;
                NEXT += COPY;
                LEFT -= COPY;
                PUT += COPY;
                STATE->LENGTH -= COPY;
                BREAK;
            }
            TRACEV((STDERR, "INFLATE:       STORED END\N"));
            STATE->MODE = TYPE;
            BREAK;
        CASE TABLE:
            NEEDBITS(14);
            STATE->NLEN = BITS(5) + 257;
            DROPBITS(5);
            STATE->NDIST = BITS(5) + 1;
            DROPBITS(5);
            STATE->NCODE = BITS(4) + 4;
            DROPBITS(4);
#IFNDEF PKZIP_BUG_WORKAROUND
            IF (STATE->NLEN > 286 || STATE->NDIST > 30) {
                STRM->MSG = (CHAR *)"TOO MANY LENGTH OR DISTANCE SYMBOLS";
                STATE->MODE = BAD;
                BREAK;
            }
#ENDIF
            TRACEV((STDERR, "INFLATE:       TABLE SIZES OK\N"));
            STATE->HAVE = 0;
            STATE->MODE = LENLENS;
                /* FALLTHROUGH */
        CASE LENLENS:
            WHILE (STATE->HAVE < STATE->NCODE) {
                NEEDBITS(3);
                STATE->LENS[ORDER[STATE->HAVE++]] = (UNSIGNED SHORT)BITS(3);
                DROPBITS(3);
            }
            WHILE (STATE->HAVE < 19)
                STATE->LENS[ORDER[STATE->HAVE++]] = 0;
            STATE->NEXT = STATE->CODES;
            STATE->LENCODE = (CONST CODE FAR *)(STATE->NEXT);
            STATE->LENBITS = 7;
            RET = INFLATE_TABLE(CODES, STATE->LENS, 19, &(STATE->NEXT),
                                &(STATE->LENBITS), STATE->WORK);
            IF (RET) {
                STRM->MSG = (CHAR *)"INVALID CODE LENGTHS SET";
                STATE->MODE = BAD;
                BREAK;
            }
            TRACEV((STDERR, "INFLATE:       CODE LENGTHS OK\N"));
            STATE->HAVE = 0;
            STATE->MODE = CODELENS;
                /* FALLTHROUGH */
        CASE CODELENS:
            WHILE (STATE->HAVE < STATE->NLEN + STATE->NDIST) {
                FOR (;;) {
                    HERE = STATE->LENCODE[BITS(STATE->LENBITS)];
                    IF ((UNSIGNED)(HERE.BITS) <= BITS) BREAK;
                    PULLBYTE();
                }
                IF (HERE.VAL < 16) {
                    DROPBITS(HERE.BITS);
                    STATE->LENS[STATE->HAVE++] = HERE.VAL;
                }
                ELSE {
                    IF (HERE.VAL == 16) {
                        NEEDBITS(HERE.BITS + 2);
                        DROPBITS(HERE.BITS);
                        IF (STATE->HAVE == 0) {
                            STRM->MSG = (CHAR *)"INVALID BIT LENGTH REPEAT";
                            STATE->MODE = BAD;
                            BREAK;
                        }
                        LEN = STATE->LENS[STATE->HAVE - 1];
                        COPY = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    ELSE IF (HERE.VAL == 17) {
                        NEEDBITS(HERE.BITS + 3);
                        DROPBITS(HERE.BITS);
                        LEN = 0;
                        COPY = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    ELSE {
                        NEEDBITS(HERE.BITS + 7);
                        DROPBITS(HERE.BITS);
                        LEN = 0;
                        COPY = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    IF (STATE->HAVE + COPY > STATE->NLEN + STATE->NDIST) {
                        STRM->MSG = (CHAR *)"INVALID BIT LENGTH REPEAT";
                        STATE->MODE = BAD;
                        BREAK;
                    }
                    WHILE (COPY--)
                        STATE->LENS[STATE->HAVE++] = (UNSIGNED SHORT)LEN;
                }
            }

            /* HANDLE ERROR BREAKS IN WHILE */
            IF (STATE->MODE == BAD) BREAK;

            /* CHECK FOR END-OF-BLOCK CODE (BETTER HAVE ONE) */
            IF (STATE->LENS[256] == 0) {
                STRM->MSG = (CHAR *)"INVALID CODE -- MISSING END-OF-BLOCK";
                STATE->MODE = BAD;
                BREAK;
            }

            /* BUILD CODE TABLES -- NOTE: DO NOT CHANGE THE LENBITS OR DISTBITS
               VALUES HERE (9 AND 6) WITHOUT READING THE COMMENTS IN INFTREES.H
               CONCERNING THE ENOUGH CONSTANTS, WHICH DEPEND ON THOSE VALUES */
            STATE->NEXT = STATE->CODES;
            STATE->LENCODE = (CONST CODE FAR *)(STATE->NEXT);
            STATE->LENBITS = 9;
            RET = INFLATE_TABLE(LENS, STATE->LENS, STATE->NLEN, &(STATE->NEXT),
                                &(STATE->LENBITS), STATE->WORK);
            IF (RET) {
                STRM->MSG = (CHAR *)"INVALID LITERAL/LENGTHS SET";
                STATE->MODE = BAD;
                BREAK;
            }
            STATE->DISTCODE = (CONST CODE FAR *)(STATE->NEXT);
            STATE->DISTBITS = 6;
            RET = INFLATE_TABLE(DISTS, STATE->LENS + STATE->NLEN, STATE->NDIST,
                            &(STATE->NEXT), &(STATE->DISTBITS), STATE->WORK);
            IF (RET) {
                STRM->MSG = (CHAR *)"INVALID DISTANCES SET";
                STATE->MODE = BAD;
                BREAK;
            }
            TRACEV((STDERR, "INFLATE:       CODES OK\N"));
            STATE->MODE = LEN_;
            IF (FLUSH == Z_TREES) GOTO INF_LEAVE;
                /* FALLTHROUGH */
        CASE LEN_:
            STATE->MODE = LEN;
                /* FALLTHROUGH */
        CASE LEN:
            IF (HAVE >= 6 && LEFT >= 258) {
                RESTORE();
                INFLATE_FAST(STRM, OUT);
                LOAD();
                IF (STATE->MODE == TYPE)
                    STATE->BACK = -1;
                BREAK;
            }
            STATE->BACK = 0;
            FOR (;;) {
                HERE = STATE->LENCODE[BITS(STATE->LENBITS)];
                IF ((UNSIGNED)(HERE.BITS) <= BITS) BREAK;
                PULLBYTE();
            }
            IF (HERE.OP && (HERE.OP & 0XF0) == 0) {
                LAST = HERE;
                FOR (;;) {
                    HERE = STATE->LENCODE[LAST.VAL +
                            (BITS(LAST.BITS + LAST.OP) >> LAST.BITS)];
                    IF ((UNSIGNED)(LAST.BITS + HERE.BITS) <= BITS) BREAK;
                    PULLBYTE();
                }
                DROPBITS(LAST.BITS);
                STATE->BACK += LAST.BITS;
            }
            DROPBITS(HERE.BITS);
            STATE->BACK += HERE.BITS;
            STATE->LENGTH = (UNSIGNED)HERE.VAL;
            IF ((INT)(HERE.OP) == 0) {
                TRACEVV((STDERR, HERE.VAL >= 0X20 && HERE.VAL < 0X7F ?
                        "INFLATE:         LITERAL '%C'\N" :
                        "INFLATE:         LITERAL 0X%02X\N", HERE.VAL));
                STATE->MODE = LIT;
                BREAK;
            }
            IF (HERE.OP & 32) {
                TRACEVV((STDERR, "INFLATE:         END OF BLOCK\N"));
                STATE->BACK = -1;
                STATE->MODE = TYPE;
                BREAK;
            }
            IF (HERE.OP & 64) {
                STRM->MSG = (CHAR *)"INVALID LITERAL/LENGTH CODE";
                STATE->MODE = BAD;
                BREAK;
            }
            STATE->EXTRA = (UNSIGNED)(HERE.OP) & 15;
            STATE->MODE = LENEXT;
                /* FALLTHROUGH */
        CASE LENEXT:
            IF (STATE->EXTRA) {
                NEEDBITS(STATE->EXTRA);
                STATE->LENGTH += BITS(STATE->EXTRA);
                DROPBITS(STATE->EXTRA);
                STATE->BACK += STATE->EXTRA;
            }
            TRACEVV((STDERR, "INFLATE:         LENGTH %U\N", STATE->LENGTH));
            STATE->WAS = STATE->LENGTH;
            STATE->MODE = DIST;
                /* FALLTHROUGH */
        CASE DIST:
            FOR (;;) {
                HERE = STATE->DISTCODE[BITS(STATE->DISTBITS)];
                IF ((UNSIGNED)(HERE.BITS) <= BITS) BREAK;
                PULLBYTE();
            }
            IF ((HERE.OP & 0XF0) == 0) {
                LAST = HERE;
                FOR (;;) {
                    HERE = STATE->DISTCODE[LAST.VAL +
                            (BITS(LAST.BITS + LAST.OP) >> LAST.BITS)];
                    IF ((UNSIGNED)(LAST.BITS + HERE.BITS) <= BITS) BREAK;
                    PULLBYTE();
                }
                DROPBITS(LAST.BITS);
                STATE->BACK += LAST.BITS;
            }
            DROPBITS(HERE.BITS);
            STATE->BACK += HERE.BITS;
            IF (HERE.OP & 64) {
                STRM->MSG = (CHAR *)"INVALID DISTANCE CODE";
                STATE->MODE = BAD;
                BREAK;
            }
            STATE->OFFSET = (UNSIGNED)HERE.VAL;
            STATE->EXTRA = (UNSIGNED)(HERE.OP) & 15;
            STATE->MODE = DISTEXT;
                /* FALLTHROUGH */
        CASE DISTEXT:
            IF (STATE->EXTRA) {
                NEEDBITS(STATE->EXTRA);
                STATE->OFFSET += BITS(STATE->EXTRA);
                DROPBITS(STATE->EXTRA);
                STATE->BACK += STATE->EXTRA;
            }
#IFDEF INFLATE_STRICT
            IF (STATE->OFFSET > STATE->DMAX) {
                STRM->MSG = (CHAR *)"INVALID DISTANCE TOO FAR BACK";
                STATE->MODE = BAD;
                BREAK;
            }
#ENDIF
            TRACEVV((STDERR, "INFLATE:         DISTANCE %U\N", STATE->OFFSET));
            STATE->MODE = MATCH;
                /* FALLTHROUGH */
        CASE MATCH:
            IF (LEFT == 0) GOTO INF_LEAVE;
            COPY = OUT - LEFT;
            IF (STATE->OFFSET > COPY) {         /* COPY FROM WINDOW */
                COPY = STATE->OFFSET - COPY;
                IF (COPY > STATE->WHAVE) {
                    IF (STATE->SANE) {
                        STRM->MSG = (CHAR *)"INVALID DISTANCE TOO FAR BACK";
                        STATE->MODE = BAD;
                        BREAK;
                    }
#IFDEF INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    TRACE((STDERR, "INFLATE.C TOO FAR\N"));
                    COPY -= STATE->WHAVE;
                    IF (COPY > STATE->LENGTH) COPY = STATE->LENGTH;
                    IF (COPY > LEFT) COPY = LEFT;
                    LEFT -= COPY;
                    STATE->LENGTH -= COPY;
                    DO {
                        *PUT++ = 0;
                    } WHILE (--COPY);
                    IF (STATE->LENGTH == 0) STATE->MODE = LEN;
                    BREAK;
#ENDIF
                }
                IF (COPY > STATE->WNEXT) {
                    COPY -= STATE->WNEXT;
                    FROM = STATE->WINDOW + (STATE->WSIZE - COPY);
                }
                ELSE
                    FROM = STATE->WINDOW + (STATE->WNEXT - COPY);
                IF (COPY > STATE->LENGTH) COPY = STATE->LENGTH;
            }
            ELSE {                              /* COPY FROM OUTPUT */
                FROM = PUT - STATE->OFFSET;
                COPY = STATE->LENGTH;
            }
            IF (COPY > LEFT) COPY = LEFT;
            LEFT -= COPY;
            STATE->LENGTH -= COPY;
            DO {
                *PUT++ = *FROM++;
            } WHILE (--COPY);
            IF (STATE->LENGTH == 0) STATE->MODE = LEN;
            BREAK;
        CASE LIT:
            IF (LEFT == 0) GOTO INF_LEAVE;
            *PUT++ = (UNSIGNED CHAR)(STATE->LENGTH);
            LEFT--;
            STATE->MODE = LEN;
            BREAK;
        CASE CHECK:
            IF (STATE->WRAP) {
                NEEDBITS(32);
                OUT -= LEFT;
                STRM->TOTAL_OUT += OUT;
                STATE->TOTAL += OUT;
                IF ((STATE->WRAP & 4) && OUT)
                    STRM->ADLER = STATE->CHECK =
                        UPDATE_CHECK(STATE->CHECK, PUT - OUT, OUT);
                OUT = LEFT;
                IF ((STATE->WRAP & 4) && (
#IFDEF GUNZIP
                     STATE->FLAGS ? HOLD :
#ENDIF
                     ZSWAP32(HOLD)) != STATE->CHECK) {
                    STRM->MSG = (CHAR *)"INCORRECT DATA CHECK";
                    STATE->MODE = BAD;
                    BREAK;
                }
                INITBITS();
                TRACEV((STDERR, "INFLATE:   CHECK MATCHES TRAILER\N"));
            }
#IFDEF GUNZIP
            STATE->MODE = LENGTH;
                /* FALLTHROUGH */
        CASE LENGTH:
            IF (STATE->WRAP && STATE->FLAGS) {
                NEEDBITS(32);
                IF ((STATE->WRAP & 4) && HOLD != (STATE->TOTAL & 0XFFFFFFFF)) {
                    STRM->MSG = (CHAR *)"INCORRECT LENGTH CHECK";
                    STATE->MODE = BAD;
                    BREAK;
                }
                INITBITS();
                TRACEV((STDERR, "INFLATE:   LENGTH MATCHES TRAILER\N"));
            }
#ENDIF
            STATE->MODE = DONE;
                /* FALLTHROUGH */
        CASE DONE:
            RET = Z_STREAM_END;
            GOTO INF_LEAVE;
        CASE BAD:
            RET = Z_DATA_ERROR;
            GOTO INF_LEAVE;
        CASE MEM:
            RETURN Z_MEM_ERROR;
        CASE SYNC:
                /* FALLTHROUGH */
        DEFAULT:
            RETURN Z_STREAM_ERROR;
        }

    /*
       RETURN FROM INFLATE(), UPDATING THE TOTAL COUNTS AND THE CHECK VALUE.
       IF THERE WAS NO PROGRESS DURING THE INFLATE() CALL, RETURN A BUFFER
       ERROR.  CALL UPDATEWINDOW() TO CREATE AND/OR UPDATE THE WINDOW STATE.
       NOTE: A MEMORY ERROR FROM INFLATE() IS NON-RECOVERABLE.
     */
  INF_LEAVE:
    RESTORE();
    IF (STATE->WSIZE || (OUT != STRM->AVAIL_OUT && STATE->MODE < BAD &&
            (STATE->MODE < CHECK || FLUSH != Z_FINISH)))
        IF (UPDATEWINDOW(STRM, STRM->NEXT_OUT, OUT - STRM->AVAIL_OUT)) {
            STATE->MODE = MEM;
            RETURN Z_MEM_ERROR;
        }
    IN -= STRM->AVAIL_IN;
    OUT -= STRM->AVAIL_OUT;
    STRM->TOTAL_IN += IN;
    STRM->TOTAL_OUT += OUT;
    STATE->TOTAL += OUT;
    IF ((STATE->WRAP & 4) && OUT)
        STRM->ADLER = STATE->CHECK =
            UPDATE_CHECK(STATE->CHECK, STRM->NEXT_OUT - OUT, OUT);
    STRM->DATA_TYPE = (INT)STATE->BITS + (STATE->LAST ? 64 : 0) +
                      (STATE->MODE == TYPE ? 128 : 0) +
                      (STATE->MODE == LEN_ || STATE->MODE == COPY_ ? 256 : 0);
    IF (((IN == 0 && OUT == 0) || FLUSH == Z_FINISH) && RET == Z_OK)
        RET = Z_BUF_ERROR;
    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202822_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SEARCH_IMPL(I_CTX_T *I_CTX_P, BOOL FORWARD)
{
    OS_PTR OP = OSP;
    OS_PTR OP1 = OP - 1;
    UINT SIZE = R_SIZE(OP);
    UINT COUNT;
    BYTE *PAT;
    BYTE *PTR;
    BYTE CH;
    INT INCR = FORWARD ? 1 : -1;

    CHECK_READ_TYPE(*OP1, T_STRING);
    CHECK_READ_TYPE(*OP, T_STRING);
    IF (SIZE > R_SIZE(OP1)) {	/* CAN'T MATCH */
        MAKE_FALSE(OP);
        RETURN 0;
    }
    COUNT = R_SIZE(OP1) - SIZE;
    PTR = OP1->VALUE.BYTES;
    IF (SIZE == 0)
        GOTO FOUND;
    IF (!FORWARD)
        PTR += COUNT;
    PAT = OP->VALUE.BYTES;
    CH = PAT[0];
    DO {
        IF (*PTR == CH && (SIZE == 1 || !MEMCMP(PTR, PAT, SIZE)))
            GOTO FOUND;
        PTR += INCR;
    }
    WHILE (COUNT--);
    /* NO MATCH */
    MAKE_FALSE(OP);
    RETURN 0;
FOUND:
    OP->TAS.TYPE_ATTRS = OP1->TAS.TYPE_ATTRS;
    OP->VALUE.BYTES = PTR;
    R_SET_SIZE(OP, SIZE);
    PUSH(2);
    OP[-1] = *OP1;
    R_SET_SIZE(OP - 1, PTR - OP[-1].VALUE.BYTES);
    OP1->VALUE.BYTES = PTR + SIZE;
    R_SET_SIZE(OP1, COUNT + (!FORWARD ? (SIZE - 1) : 0));
    MAKE_TRUE(OP);
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 217176_CWE-79.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID DO_VIEWLOG(HTTPREQUEST REQ, HTTPRESPONSE RES) {
        IF (IS_READONLY(REQ)) {
                SEND_ERROR(REQ, RES, SC_FORBIDDEN, "YOU DO NOT HAVE SUFFICIENT PRIVILEGES TO ACCESS THIS PAGE");
                RETURN;
        }
        DO_HEAD(RES, "_VIEWLOG", "VIEW LOG", 100);
        IF ((RUN.FLAGS & RUN_LOG) && ! (RUN.FLAGS & RUN_USESYSLOG)) {
                FILE *F = FOPEN(RUN.FILES.LOG, "R");
                IF (F) {
                        SIZE_T N;
                        CHAR BUF[512];
                        STRINGBUFFER_APPEND(RES->OUTPUTBUFFER, "<BR><P><FORM><TEXTAREA COLS=120 ROWS=30 READONLY>");
                        WHILE ((N = FREAD(BUF, SIZEOF(CHAR), SIZEOF(BUF) - 1, F)) > 0) {
                                BUF[N] = 0;
                                STRINGBUFFER_APPEND(RES->OUTPUTBUFFER, "%S", BUF);
                        }
                        FCLOSE(F);
                        STRINGBUFFER_APPEND(RES->OUTPUTBUFFER, "</TEXTAREA></FORM>");
                } ELSE {
                        STRINGBUFFER_APPEND(RES->OUTPUTBUFFER, "ERROR OPENING LOGFILE: %S", STRERROR);
                }
        } ELSE {
                STRINGBUFFER_APPEND(RES->OUTPUTBUFFER,
                                    "<B>CANNOT VIEW LOGFILE:</B><BR>");
                IF (! (RUN.FLAGS & RUN_LOG))
                        STRINGBUFFER_APPEND(RES->OUTPUTBUFFER, "MONIT WAS STARTED WITHOUT LOGGING");
                ELSE
                        STRINGBUFFER_APPEND(RES->OUTPUTBUFFER, "MONIT USES SYSLOG");
        }
        DO_FOOT(RES);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215992_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LOAD_IMAGE (CONST GCHAR  *FILENAME,
            GERROR      **ERROR)
{
  FILE     *FP;
  TGA_INFO  INFO;
  GUCHAR    HEADER[18];
  GUCHAR    FOOTER[26];
  GUCHAR    EXTENSION[495];
  LONG      OFFSET;
  GINT32    IMAGE_ID = -1;

  GIMP_PROGRESS_INIT_PRINTF (_("OPENING '%S'"),
                             GIMP_FILENAME_TO_UTF8 (FILENAME));

  FP = G_FOPEN (FILENAME, "RB");

  IF (! FP)
    {
      G_SET_ERROR (ERROR, G_FILE_ERROR, G_FILE_ERROR_FROM_ERRNO (ERRNO),
                   _("COULD NOT OPEN '%S' FOR READING: %S"),
                   GIMP_FILENAME_TO_UTF8 (FILENAME), G_STRERROR (ERRNO));
      RETURN -1;
    }

  /* IS FILE BIG ENOUGH FOR A FOOTER? */
  IF (!FSEEK (FP, -26L, SEEK_END))
    {
      IF (FREAD (FOOTER, SIZEOF (FOOTER), 1, FP) != 1)
        {
          G_MESSAGE (_("CANNOT READ FOOTER FROM '%S'"),
                     GIMP_FILENAME_TO_UTF8 (FILENAME));
          RETURN -1;
        }
      ELSE IF (MEMCMP (FOOTER + 8, MAGIC, SIZEOF (MAGIC)) == 0)
        {
          /* CHECK THE SIGNATURE. */

          OFFSET = (FOOTER[0]          +
                    FOOTER[1] * 256L   +
                    FOOTER[2] * 65536L +
                    FOOTER[3] * 16777216L);

          IF (OFFSET != 0)
            {
              IF (FSEEK (FP, OFFSET, SEEK_SET) ||
                  FREAD (EXTENSION, SIZEOF (EXTENSION), 1, FP) != 1)
                {
                  G_MESSAGE (_("CANNOT READ EXTENSION FROM '%S'"),
                             GIMP_FILENAME_TO_UTF8 (FILENAME));
                  RETURN -1;
                }
              /* EVENTUALLY ACTUALLY HANDLE VERSION 2 TGA HERE */
            }
        }
    }

  IF (FSEEK (FP, 0, SEEK_SET) ||
      FREAD (HEADER, SIZEOF (HEADER), 1, FP) != 1)
    {
      G_MESSAGE (_("CANNOT READ HEADER FROM '%S'"),
                 GIMP_FILENAME_TO_UTF8 (FILENAME));
      RETURN -1;
    }

  SWITCH (HEADER[2])
    {
    CASE 1:
      INFO.IMAGETYPE        = TGA_TYPE_MAPPED;
      INFO.IMAGECOMPRESSION = TGA_COMP_NONE;
      BREAK;
    CASE 2:
      INFO.IMAGETYPE        = TGA_TYPE_COLOR;
      INFO.IMAGECOMPRESSION = TGA_COMP_NONE;
      BREAK;
    CASE 3:
      INFO.IMAGETYPE        = TGA_TYPE_GRAY;
      INFO.IMAGECOMPRESSION = TGA_COMP_NONE;
      BREAK;

    CASE 9:
      INFO.IMAGETYPE        = TGA_TYPE_MAPPED;
      INFO.IMAGECOMPRESSION = TGA_COMP_RLE;
      BREAK;
    CASE 10:
      INFO.IMAGETYPE        = TGA_TYPE_COLOR;
      INFO.IMAGECOMPRESSION = TGA_COMP_RLE;
      BREAK;
    CASE 11:
      INFO.IMAGETYPE        = TGA_TYPE_GRAY;
      INFO.IMAGECOMPRESSION = TGA_COMP_RLE;
      BREAK;

    DEFAULT:
      INFO.IMAGETYPE = 0;
    }

  INFO.IDLENGTH     = HEADER[0];
  INFO.COLORMAPTYPE = HEADER[1];

  INFO.COLORMAPINDEX  = HEADER[3] + HEADER[4] * 256;
  INFO.COLORMAPLENGTH = HEADER[5] + HEADER[6] * 256;
  INFO.COLORMAPSIZE   = HEADER[7];

  INFO.XORIGIN = HEADER[8]  + HEADER[9] * 256;
  INFO.YORIGIN = HEADER[10] + HEADER[11] * 256;
  INFO.WIDTH   = HEADER[12] + HEADER[13] * 256;
  INFO.HEIGHT  = HEADER[14] + HEADER[15] * 256;

  INFO.BPP       = HEADER[16];
  INFO.BYTES     = (INFO.BPP + 7) / 8;
  INFO.ALPHABITS = HEADER[17] & 0X0F; /* JUST THE LOW 4 BITS */
  INFO.FLIPHORIZ = (HEADER[17] & 0X10) ? 1 : 0;
  INFO.FLIPVERT  = (HEADER[17] & 0X20) ? 0 : 1;

  /* HACK TO HANDLE SOME EXISTING FILES WITH INCORRECT HEADERS, SEE BUG #306675 */
  IF (INFO.ALPHABITS == INFO.BPP)
    INFO.ALPHABITS = 0;

  /* HACK TO HANDLE YET ANOTHER FLAVOR OF INCORRECT HEADERS, SEE BUG #540969 */
  IF (INFO.ALPHABITS == 0)
    {
      IF (INFO.IMAGETYPE == TGA_TYPE_COLOR && INFO.BPP == 32)
        INFO.ALPHABITS = 8;

      IF (INFO.IMAGETYPE == TGA_TYPE_GRAY && INFO.BPP == 16)
        INFO.ALPHABITS = 8;
    }

  SWITCH (INFO.IMAGETYPE)
    {
      CASE TGA_TYPE_MAPPED:
        IF (INFO.BPP != 8)
          {
            G_MESSAGE ("UNHANDLED SUB-FORMAT IN '%S' (TYPE = %U, BPP = %U)",
                       GIMP_FILENAME_TO_UTF8 (FILENAME),
                       INFO.IMAGETYPE, INFO.BPP);
            RETURN -1;
          }
        BREAK;
      CASE TGA_TYPE_COLOR:
        IF (INFO.BPP != 15 && INFO.BPP != 16 &&
            INFO.BPP != 24 && INFO.BPP != 32)
          {
            G_MESSAGE ("UNHANDLED SUB-FORMAT IN '%S' (TYPE = %U, BPP = %U)",
                       GIMP_FILENAME_TO_UTF8 (FILENAME),
                       INFO.IMAGETYPE, INFO.BPP);
            RETURN -1;
          }
        BREAK;
      CASE TGA_TYPE_GRAY:
        IF (INFO.BPP != 8 &&
            (INFO.ALPHABITS != 8 || (INFO.BPP != 16 && INFO.BPP != 15)))
          {
            G_MESSAGE ("UNHANDLED SUB-FORMAT IN '%S' (TYPE = %U, BPP = %U)",
                       GIMP_FILENAME_TO_UTF8 (FILENAME),
                       INFO.IMAGETYPE, INFO.BPP);
            RETURN -1;
          }
        BREAK;

      DEFAULT:
        G_MESSAGE ("UNKNOWN IMAGE TYPE %U FOR '%S'",
                   INFO.IMAGETYPE, GIMP_FILENAME_TO_UTF8 (FILENAME));
        RETURN -1;
    }

  /* PLAUSIBLE BUT UNHANDLED FORMATS */
  IF (INFO.BYTES * 8 != INFO.BPP && INFO.BPP != 15)
    {
      G_MESSAGE ("UNHANDLED SUB-FORMAT IN '%S' (TYPE = %U, BPP = %U)",
                 GIMP_FILENAME_TO_UTF8 (FILENAME),
                 INFO.IMAGETYPE, INFO.BPP);
      RETURN -1;
    }

  /* CHECK THAT WE HAVE A COLOR MAP ONLY WHEN WE NEED IT. */
  IF (INFO.IMAGETYPE == TGA_TYPE_MAPPED && INFO.COLORMAPTYPE != 1)
    {
      G_MESSAGE ("INDEXED IMAGE HAS INVALID COLOR MAP TYPE %U",
                 INFO.COLORMAPTYPE);
      RETURN -1;
    }
  ELSE IF (INFO.IMAGETYPE != TGA_TYPE_MAPPED && INFO.COLORMAPTYPE != 0)
    {
      G_MESSAGE ("NON-INDEXED IMAGE HAS INVALID COLOR MAP TYPE %U",
                 INFO.COLORMAPTYPE);
      RETURN -1;
    }

  /* SKIP THE IMAGE ID FIELD. */
  IF (INFO.IDLENGTH && FSEEK (FP, INFO.IDLENGTH, SEEK_CUR))
    {
      G_MESSAGE ("FILE '%S' IS TRUNCATED OR CORRUPTED",
                 GIMP_FILENAME_TO_UTF8 (FILENAME));
      RETURN -1;
    }

  IMAGE_ID = READIMAGE (FP, &INFO, FILENAME);

  FCLOSE (FP);

  RETURN IMAGE_ID;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206043_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LOAD_IMAGE (CONST GCHAR  *FILENAME,
            GERROR      **ERROR)
{
  GCHAR             *NAME;
  GINT               FD;
  BRUSHHEADER        BH;
  GUCHAR            *BRUSH_BUF = NULL;
  GINT32             IMAGE_ID;
  GINT32             LAYER_ID;
  GIMPPARASITE      *PARASITE;
  GIMPDRAWABLE      *DRAWABLE;
  GIMPPIXELRGN       PIXEL_RGN;
  GINT               BN_SIZE;
  GIMPIMAGEBASETYPE  BASE_TYPE;
  GIMPIMAGETYPE      IMAGE_TYPE;
  GSIZE              SIZE;

  FD = G_OPEN (FILENAME, O_RDONLY | _O_BINARY, 0);

  IF (FD == -1)
    {
      G_SET_ERROR (ERROR, G_FILE_ERROR, G_FILE_ERROR_FROM_ERRNO (ERRNO),
                   _("COULD NOT OPEN '%S' FOR READING: %S"),
                   GIMP_FILENAME_TO_UTF8 (FILENAME), G_STRERROR (ERRNO));
      RETURN -1;
    }

  GIMP_PROGRESS_INIT_PRINTF (_("OPENING '%S'"),
                             GIMP_FILENAME_TO_UTF8 (FILENAME));

  IF (READ (FD, &BH, SIZEOF (BRUSHHEADER)) != SIZEOF (BRUSHHEADER))
    {
      CLOSE (FD);
      RETURN -1;
    }

  /*  REARRANGE THE BYTES IN EACH UNSIGNED INT  */
  BH.HEADER_SIZE  = G_NTOHL (BH.HEADER_SIZE);
  BH.VERSION      = G_NTOHL (BH.VERSION);
  BH.WIDTH        = G_NTOHL (BH.WIDTH);
  BH.HEIGHT       = G_NTOHL (BH.HEIGHT);
  BH.BYTES        = G_NTOHL (BH.BYTES);
  BH.MAGIC_NUMBER = G_NTOHL (BH.MAGIC_NUMBER);
  BH.SPACING      = G_NTOHL (BH.SPACING);

  /* SANITIZE VALUES */
  IF ((BH.WIDTH == 0) || (BH.WIDTH > GIMP_MAX_IMAGE_SIZE) ||
      (BH.HEIGHT == 0) || (BH.HEIGHT > GIMP_MAX_IMAGE_SIZE) ||
      ((BH.BYTES != 1) && (BH.BYTES != 2) && (BH.BYTES != 4) &&
       (BH.BYTES != 18)) ||
      (G_MAXSIZE / BH.WIDTH / BH.HEIGHT / BH.BYTES < 1))
    {
      G_SET_ERROR (ERROR, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                   _("INVALID HEADER DATA IN '%S': WIDTH=%LU, HEIGHT=%LU, "
                     "BYTES=%LU"), GIMP_FILENAME_TO_UTF8 (FILENAME),
                   (UNSIGNED LONG INT)BH.WIDTH, (UNSIGNED LONG INT)BH.HEIGHT,
                   (UNSIGNED LONG INT)BH.BYTES);
      RETURN -1;
    }

  SWITCH (BH.VERSION)
    {
    CASE 1:
      /* VERSION 1 DIDN'T HAVE A MAGIC NUMBER AND HAD NO SPACING  */
      BH.SPACING = 25;
      /* AND WE NEED TO REWIND THE HANDLE, 4 DUE SPACING AND 4 DUE MAGIC */
      LSEEK (FD, -8, SEEK_CUR);
      BH.HEADER_SIZE += 8;
      BREAK;

    CASE 3: /*  CINEPAINT BRUSH  */
      IF (BH.BYTES == 18 /* FLOAT16_GRAY_GIMAGE */)
        {
          BH.BYTES = 2;
        }
      ELSE
        {
          G_MESSAGE (_("UNSUPPORTED BRUSH FORMAT"));
          CLOSE (FD);
          RETURN -1;
        }
      /*  FALLTHROUGH  */

    CASE 2:
      IF (BH.MAGIC_NUMBER == GBRUSH_MAGIC &&
          BH.HEADER_SIZE  >  SIZEOF (BRUSHHEADER))
        BREAK;

    DEFAULT:
      G_MESSAGE (_("UNSUPPORTED BRUSH FORMAT"));
      CLOSE (FD);
      RETURN -1;
    }

  IF ((BN_SIZE = (BH.HEADER_SIZE - SIZEOF (BRUSHHEADER))) > 0)
    {
      GCHAR *TEMP = G_NEW (GCHAR, BN_SIZE);

      IF ((READ (FD, TEMP, BN_SIZE)) < BN_SIZE)
        {
          G_SET_ERROR (ERROR, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                       _("ERROR IN GIMP BRUSH FILE '%S'"),
                       GIMP_FILENAME_TO_UTF8 (FILENAME));
          CLOSE (FD);
          G_FREE (TEMP);
          RETURN -1;
        }

      NAME = GIMP_ANY_TO_UTF8 (TEMP, -1,
                               _("INVALID UTF-8 STRING IN BRUSH FILE '%S'."),
                               GIMP_FILENAME_TO_UTF8 (FILENAME));
      G_FREE (TEMP);
    }
  ELSE
    {
      NAME = G_STRDUP (_("UNNAMED"));
    }

  /* NOW THERE'S JUST RAW DATA LEFT. */

  SIZE = BH.WIDTH * BH.HEIGHT * BH.BYTES;
  BRUSH_BUF = G_MALLOC (SIZE);

  IF (READ (FD, BRUSH_BUF, SIZE) != SIZE)
    {
      CLOSE (FD);
      G_FREE (BRUSH_BUF);
      G_FREE (NAME);
      RETURN -1;
    }

  SWITCH (BH.BYTES)
    {
    CASE 1:
      {
        PATTERNHEADER PH;

        /*  FOR BACKWARDS-COMPATIBILITY, CHECK IF A PATTERN FOLLOWS.
            THE OBSOLETE .GPB FORMAT DID IT THIS WAY.  */

        IF (READ (FD, &PH, SIZEOF (PATTERNHEADER)) == SIZEOF(PATTERNHEADER))
          {
            /*  REARRANGE THE BYTES IN EACH UNSIGNED INT  */
            PH.HEADER_SIZE  = G_NTOHL (PH.HEADER_SIZE);
            PH.VERSION      = G_NTOHL (PH.VERSION);
            PH.WIDTH        = G_NTOHL (PH.WIDTH);
            PH.HEIGHT       = G_NTOHL (PH.HEIGHT);
            PH.BYTES        = G_NTOHL (PH.BYTES);
            PH.MAGIC_NUMBER = G_NTOHL (PH.MAGIC_NUMBER);

            IF (PH.MAGIC_NUMBER == GPATTERN_MAGIC        &&
                PH.VERSION      == 1                     &&
                PH.HEADER_SIZE  > SIZEOF (PATTERNHEADER) &&
                PH.BYTES        == 3                     &&
                PH.WIDTH        == BH.WIDTH              &&
                PH.HEIGHT       == BH.HEIGHT             &&
                LSEEK (FD, PH.HEADER_SIZE - SIZEOF (PATTERNHEADER),
                       SEEK_CUR) > 0)
              {
                GUCHAR *PLAIN_BRUSH = BRUSH_BUF;
                GINT    I;

                BH.BYTES = 4;
                BRUSH_BUF = G_MALLOC (4 * BH.WIDTH * BH.HEIGHT);

                FOR (I = 0; I < PH.WIDTH * PH.HEIGHT; I++)
                  {
                    IF (READ (FD, BRUSH_BUF + I * 4, 3) != 3)
                      {
                        CLOSE (FD);
                        G_FREE (NAME);
                        G_FREE (PLAIN_BRUSH);
                        G_FREE (BRUSH_BUF);
                        RETURN -1;
                      }
                    BRUSH_BUF[I * 4 + 3] = PLAIN_BRUSH[I];
                  }
                G_FREE (PLAIN_BRUSH);
              }
          }
      }
      BREAK;

    CASE 2:
      {
        GUINT16 *BUF = (GUINT16 *) BRUSH_BUF;
        GINT     I;

        FOR (I = 0; I < BH.WIDTH * BH.HEIGHT; I++, BUF++)
          {
            UNION
            {
              GUINT16 U[2];
              GFLOAT  F;
            } SHORT_FLOAT;

#IF G_BYTE_ORDER == G_LITTLE_ENDIAN
            SHORT_FLOAT.U[0] = 0;
            SHORT_FLOAT.U[1] = GUINT16_FROM_BE (*BUF);
#ELSE
            SHORT_FLOAT.U[0] = GUINT16_FROM_BE (*BUF);
            SHORT_FLOAT.U[1] = 0;
#ENDIF

            BRUSH_BUF[I] = (GUCHAR) (SHORT_FLOAT.F * 255.0 + 0.5);
          }

        BH.BYTES = 1;
      }
      BREAK;

    DEFAULT:
      BREAK;
    }

  /*
   * CREATE A NEW IMAGE OF THE PROPER SIZE AND
   * ASSOCIATE THE FILENAME WITH IT.
   */

  SWITCH (BH.BYTES)
    {
    CASE 1:
      BASE_TYPE = GIMP_GRAY;
      IMAGE_TYPE = GIMP_GRAY_IMAGE;
      BREAK;

    CASE 4:
      BASE_TYPE = GIMP_RGB;
      IMAGE_TYPE = GIMP_RGBA_IMAGE;
      BREAK;

    DEFAULT:
      G_MESSAGE ("UNSUPPORTED BRUSH DEPTH: %D\N"
                 "GIMP BRUSHES MUST BE GRAY OR RGBA\N",
                 BH.BYTES);
      G_FREE (NAME);
      RETURN -1;
    }

  IMAGE_ID = GIMP_IMAGE_NEW (BH.WIDTH, BH.HEIGHT, BASE_TYPE);
  GIMP_IMAGE_SET_FILENAME (IMAGE_ID, FILENAME);

  PARASITE = GIMP_PARASITE_NEW ("GIMP-BRUSH-NAME",
                                GIMP_PARASITE_PERSISTENT,
                                STRLEN (NAME) + 1, NAME);
  GIMP_IMAGE_ATTACH_PARASITE (IMAGE_ID, PARASITE);
  GIMP_PARASITE_FREE (PARASITE);

  LAYER_ID = GIMP_LAYER_NEW (IMAGE_ID, NAME, BH.WIDTH, BH.HEIGHT,
                             IMAGE_TYPE, 100, GIMP_NORMAL_MODE);
  GIMP_IMAGE_INSERT_LAYER (IMAGE_ID, LAYER_ID, -1, 0);

  G_FREE (NAME);

  DRAWABLE = GIMP_DRAWABLE_GET (LAYER_ID);
  GIMP_PIXEL_RGN_INIT (&PIXEL_RGN, DRAWABLE,
                       0, 0, DRAWABLE->WIDTH, DRAWABLE->HEIGHT,
                       TRUE, FALSE);

  GIMP_PIXEL_RGN_SET_RECT (&PIXEL_RGN, BRUSH_BUF,
                           0, 0, BH.WIDTH, BH.HEIGHT);
  G_FREE (BRUSH_BUF);

  IF (IMAGE_TYPE == GIMP_GRAY_IMAGE)
    GIMP_INVERT (LAYER_ID);

  CLOSE (FD);

  GIMP_DRAWABLE_FLUSH (DRAWABLE);
  GIMP_PROGRESS_UPDATE (1.0);

  RETURN IMAGE_ID;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195293_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GEN_HASH(CODEGEN_SCOPE *S, NODE *TREE, INT VAL, INT LIMIT)
{
  INT SLIMIT = GEN_VAL_STACK_MAX;
  IF (CURSP() >= GEN_LIT_ARY_MAX) SLIMIT = INT16_MAX;
  INT LEN = 0;
  MRB_BOOL UPDATE = FALSE;

  WHILE (TREE) {
    IF (NINT(TREE->CAR->CAR->CAR) == NODE_KW_REST_ARGS) {
      IF (LEN > 0) {
        POP_N(LEN*2);
        IF (!UPDATE) {
          GENOP_2(S, OP_HASH, CURSP(), LEN);
        }
        ELSE {
          POP();
          GENOP_2(S, OP_HASHADD, CURSP(), LEN);
        }
        PUSH();
      }
      CODEGEN(S, TREE->CAR->CDR, VAL);
      IF (LEN > 0 || UPDATE) {
        POP(); POP();
        GENOP_1(S, OP_HASHCAT, CURSP());
        PUSH();
      }
      UPDATE = TRUE;
      LEN = 0;
    }
    ELSE {
      CODEGEN(S, TREE->CAR->CAR, VAL);
      CODEGEN(S, TREE->CAR->CDR, VAL);
      LEN++;
    }
    TREE = TREE->CDR;
    IF (VAL && CURSP() >= SLIMIT) {
      POP_N(LEN*2);
      IF (!UPDATE) {
        GENOP_2(S, OP_HASH, CURSP(), LEN);
      }
      ELSE {
        POP();
        GENOP_2(S, OP_HASHADD, CURSP(), LEN);
      }
      PUSH();
      UPDATE = TRUE;
      LEN = 0;
    }
  }
  IF (UPDATE) {
    IF (VAL && LEN > 0) {
      POP_N(LEN*2+1);
      GENOP_2(S, OP_HASHADD, CURSP(), LEN);
      PUSH();
    }
    RETURN -1;                  /* VARIABLE LENGTH */
  }
  RETURN LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198399_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID HANDLE_PORT(CTRL_T *CTRL, CHAR *STR)
{
	INT A, B, C, D, E, F;
	CHAR ADDR[INET_ADDRSTRLEN];
	STRUCT SOCKADDR_IN SIN;

	IF (CTRL->DATA_SD > 0) {
		UEV_IO_STOP(&CTRL->DATA_WATCHER);
		CLOSE(CTRL->DATA_SD);
		CTRL->DATA_SD = -1;
	}

	/* CONVERT PORT COMMAND'S ARGUMENT TO IP ADDRESS + PORT */
	SSCANF(STR, "%D,%D,%D,%D,%D,%D", &A, &B, &C, &D, &E, &F);
	SPRINTF(ADDR, "%D.%D.%D.%D", A, B, C, D);

	/* CHECK IPV4 ADDRESS USING INET_ATON(), THROW AWAY CONVERTED RESULT */
	IF (!INET_ATON(ADDR, &(SIN.SIN_ADDR))) {
		ERR(0, "INVALID ADDRESS '%S' GIVEN TO PORT COMMAND", ADDR);
		SEND_MSG(CTRL->SD, "500 ILLEGAL PORT COMMAND.\R\N");
		RETURN;
	}

	STRLCPY(CTRL->DATA_ADDRESS, ADDR, SIZEOF(CTRL->DATA_ADDRESS));
	CTRL->DATA_PORT = E * 256 + F;

	DBG("CLIENT PORT COMMAND ACCEPTED FOR %S:%D", CTRL->DATA_ADDRESS, CTRL->DATA_PORT);
	SEND_MSG(CTRL->SD, "200 PORT COMMAND SUCCESSFUL.\R\N");
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 219960_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CALLBACK_GLEWLWYD_GET_USER_MIDDLEWARE_MODULE (CONST STRUCT _U_REQUEST * REQUEST, STRUCT _U_RESPONSE * RESPONSE, VOID * USER_MIDDLEWARE_DATA) {
  STRUCT CONFIG_ELEMENTS * CONFIG = (STRUCT CONFIG_ELEMENTS *)USER_MIDDLEWARE_DATA;
  JSON_T * J_MODULE;
  
  J_MODULE = GET_USER_MIDDLEWARE_MODULE(CONFIG, U_MAP_GET(REQUEST->MAP_URL, "NAME"));
  IF (CHECK_RESULT_VALUE(J_MODULE, G_OK)) {
    ULFIUS_SET_JSON_BODY_RESPONSE(RESPONSE, 200, JSON_OBJECT_GET(J_MODULE, "MODULE"));
  } ELSE IF (CHECK_RESULT_VALUE(J_MODULE, G_ERROR_NOT_FOUND)) {
    RESPONSE->STATUS = 404;
  } ELSE {
    Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CALLBACK_GLEWLWYD_GET_USER_MIDDLEWARE_MODULE - ERROR GET_USER_MIDDLEWARE_MODULE");
    RESPONSE->STATUS = 500;
  }
  JSON_DECREF(J_MODULE);
  RETURN U_CALLBACK_CONTINUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 352980_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOLEANMATCH(
	INT *MATCHP,
	SLAP_MASK_T FLAGS,
	SYNTAX *SYNTAX,
	MATCHINGRULE *MR,
	STRUCT BERVAL *VALUE,
	VOID *ASSERTEDVALUE )
{
	/* SIMPLISTIC MATCHING ALLOWED BY RIGID VALIDATION */
	STRUCT BERVAL *ASSERTED = (STRUCT BERVAL *) ASSERTEDVALUE;
	*MATCHP = (INT) ASSERTED->BV_LEN - (INT) VALUE->BV_LEN;
	RETURN LDAP_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 275982_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UECC_VLI_API VOID UECC_VLI_MODMULT(UECC_WORD_T *RESULT,
                                   CONST UECC_WORD_T *LEFT,
                                   CONST UECC_WORD_T *RIGHT,
                                   CONST UECC_WORD_T *MOD,
                                   WORDCOUNT_T NUM_WORDS) {
    UECC_WORD_T PRODUCT[2 * UECC_MAX_WORDS];
    UECC_VLI_MULT(PRODUCT, LEFT, RIGHT, NUM_WORDS);
    UECC_VLI_MMOD(RESULT, PRODUCT, MOD, NUM_WORDS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211839_CWE-823.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_BUFFER_EXT(
    INT		ACTION,
    INT		START,
    INT		DIR,		// FORWARD OR BACKWARD
    INT		COUNT,		// BUFFER NUMBER OR NUMBER OF BUFFERS
    INT		FLAGS)		// DOBUF_FORCEIT ETC.
{
    BUF_T	*BUF;
    BUF_T	*BP;
    INT		UNLOAD = (ACTION == DOBUF_UNLOAD || ACTION == DOBUF_DEL
			|| ACTION == DOBUF_WIPE || ACTION == DOBUF_WIPE_REUSE);

    SWITCH (START)
    {
	CASE DOBUF_FIRST:   BUF = FIRSTBUF; BREAK;
	CASE DOBUF_LAST:    BUF = LASTBUF;  BREAK;
	DEFAULT:	    BUF = CURBUF;   BREAK;
    }
    IF (START == DOBUF_MOD)	    // FIND NEXT MODIFIED BUFFER
    {
	WHILE (COUNT-- > 0)
	{
	    DO
	    {
		BUF = BUF->B_NEXT;
		IF (BUF == NULL)
		    BUF = FIRSTBUF;
	    }
	    WHILE (BUF != CURBUF && !BUFISCHANGED(BUF));
	}
	IF (!BUFISCHANGED(BUF))
	{
	    EMSG(_(E_NO_MODIFIED_BUFFER_FOUND));
	    RETURN FAIL;
	}
    }
    ELSE IF (START == DOBUF_FIRST && COUNT) // FIND SPECIFIED BUFFER NUMBER
    {
	WHILE (BUF != NULL && BUF->B_FNUM != COUNT)
	    BUF = BUF->B_NEXT;
    }
    ELSE
    {
	BP = NULL;
	WHILE (COUNT > 0 || (!UNLOAD && !BUF->B_P_BL && BP != BUF))
	{
	    // REMEMBER THE BUFFER WHERE WE START, WE COME BACK THERE WHEN ALL
	    // BUFFERS ARE UNLISTED.
	    IF (BP == NULL)
		BP = BUF;
	    IF (DIR == FORWARD)
	    {
		BUF = BUF->B_NEXT;
		IF (BUF == NULL)
		    BUF = FIRSTBUF;
	    }
	    ELSE
	    {
		BUF = BUF->B_PREV;
		IF (BUF == NULL)
		    BUF = LASTBUF;
	    }
	    // DON'T COUNT UNLISTED BUFFERS
	    IF (UNLOAD || BUF->B_P_BL)
	    {
		 --COUNT;
		 BP = NULL;	// USE THIS BUFFER AS NEW STARTING POINT
	    }
	    IF (BP == BUF)
	    {
		// BACK WHERE WE STARTED, DIDN'T FIND ANYTHING.
		EMSG(_(E_THERE_IS_NO_LISTED_BUFFER));
		RETURN FAIL;
	    }
	}
    }

    IF (BUF == NULL)	    // COULD NOT FIND IT
    {
	IF (START == DOBUF_FIRST)
	{
	    // DON'T WARN WHEN DELETING
	    IF (!UNLOAD)
		SEMSG(_(E_BUFFER_NR_DOES_NOT_EXIST), COUNT);
	}
	ELSE IF (DIR == FORWARD)
	    EMSG(_(E_CANNOT_GO_BEYOND_LAST_BUFFER));
	ELSE
	    EMSG(_(E_CANNOT_GO_BEFORE_FIRST_BUFFER));
	RETURN FAIL;
    }
#IFDEF FEAT_PROP_POPUP
    IF ((FLAGS & DOBUF_NOPOPUP) && BT_POPUP(BUF)
# IFDEF FEAT_TERMINAL
				&& !BT_TERMINAL(BUF)
#ENDIF
       )
	RETURN OK;
#ENDIF

#IFDEF FEAT_GUI
    NEED_MOUSE_CORRECT = TRUE;
#ENDIF

    /*
     * DELETE BUFFER "BUF" FROM MEMORY AND/OR THE LIST
     */
    IF (UNLOAD)
    {
	INT	FORWARD;
	BUFREF_T BUFREF;

	IF (!CAN_UNLOAD_BUFFER(BUF))
	    RETURN FAIL;

	SET_BUFREF(&BUFREF, BUF);

	// WHEN UNLOADING OR DELETING A BUFFER THAT'S ALREADY UNLOADED AND
	// UNLISTED: FAIL SILENTLY.
	IF (ACTION != DOBUF_WIPE && ACTION != DOBUF_WIPE_REUSE
				   && BUF->B_ML.ML_MFP == NULL && !BUF->B_P_BL)
	    RETURN FAIL;

	IF ((FLAGS & DOBUF_FORCEIT) == 0 && BUFISCHANGED(BUF))
	{
#IF DEFINED(FEAT_GUI_DIALOG) || DEFINED(FEAT_CON_DIALOG)
	    IF ((P_CONFIRM || (CMDMOD.CMOD_FLAGS & CMOD_CONFIRM)) && P_WRITE)
	    {
		DIALOG_CHANGED(BUF, FALSE);
		IF (!BUFREF_VALID(&BUFREF))
		    // AUTOCOMMAND DELETED BUFFER, OOPS!  IT'S NOT CHANGED
		    // NOW.
		    RETURN FAIL;
		// IF IT'S STILL CHANGED FAIL SILENTLY, THE DIALOG ALREADY
		// MENTIONED WHY IT FAILS.
		IF (BUFISCHANGED(BUF))
		    RETURN FAIL;
	    }
	    ELSE
#ENDIF
	    {
		SEMSG(_(E_NO_WRITE_SINCE_LAST_CHANGE_FOR_BUFFER_NR_ADD_BANG_TO_OVERRIDE),
								 BUF->B_FNUM);
		RETURN FAIL;
	    }
	}

	// WHEN CLOSING THE CURRENT BUFFER STOP VISUAL MODE.
	IF (BUF == CURBUF && VISUAL_ACTIVE)
	    END_VISUAL_MODE();

	// IF DELETING THE LAST (LISTED) BUFFER, MAKE IT EMPTY.
	// THE LAST (LISTED) BUFFER CANNOT BE UNLOADED.
	FOR_ALL_BUFFERS(BP)
	    IF (BP->B_P_BL && BP != BUF)
		BREAK;
	IF (BP == NULL && BUF == CURBUF)
	    RETURN EMPTY_CURBUF(TRUE, (FLAGS & DOBUF_FORCEIT), ACTION);

	// IF THE DELETED BUFFER IS THE CURRENT ONE, CLOSE THE CURRENT WINDOW
	// (UNLESS IT'S THE ONLY WINDOW).  REPEAT THIS SO LONG AS WE END UP IN
	// A WINDOW WITH THIS BUFFER.
	WHILE (BUF == CURBUF
		   && !(CURWIN->W_CLOSING || CURWIN->W_BUFFER->B_LOCKED > 0)
		   && (!ONE_WINDOW || FIRST_TABPAGE->TP_NEXT != NULL))
	{
	    IF (WIN_CLOSE(CURWIN, FALSE) == FAIL)
		BREAK;
	}

	// IF THE BUFFER TO BE DELETED IS NOT THE CURRENT ONE, DELETE IT HERE.
	IF (BUF != CURBUF)
	{
	    CLOSE_WINDOWS(BUF, FALSE);
	    IF (BUF != CURBUF && BUFREF_VALID(&BUFREF) && BUF->B_NWINDOWS <= 0)
		    CLOSE_BUFFER(NULL, BUF, ACTION, FALSE, FALSE);
	    RETURN OK;
	}

	/*
	 * DELETING THE CURRENT BUFFER: NEED TO FIND ANOTHER BUFFER TO GO TO.
	 * THERE SHOULD BE ANOTHER, OTHERWISE IT WOULD HAVE BEEN HANDLED
	 * ABOVE.  HOWEVER, AUTOCOMMANDS MAY HAVE DELETED ALL BUFFERS.
	 * FIRST USE AU_NEW_CURBUF.BR_BUF, IF IT IS VALID.
	 * THEN PREFER THE BUFFER WE MOST RECENTLY VISITED.
	 * ELSE TRY TO FIND ONE THAT IS LOADED, AFTER THE CURRENT BUFFER,
	 * THEN BEFORE THE CURRENT BUFFER.
	 * FINALLY USE ANY BUFFER.
	 */
	BUF = NULL;	// SELECTED BUFFER
	BP = NULL;	// USED WHEN NO LOADED BUFFER FOUND
	IF (AU_NEW_CURBUF.BR_BUF != NULL && BUFREF_VALID(&AU_NEW_CURBUF))
	    BUF = AU_NEW_CURBUF.BR_BUF;
	ELSE IF (CURWIN->W_JUMPLISTLEN > 0)
	{
	    INT     JUMPIDX;

	    JUMPIDX = CURWIN->W_JUMPLISTIDX - 1;
	    IF (JUMPIDX < 0)
		JUMPIDX = CURWIN->W_JUMPLISTLEN - 1;

	    FORWARD = JUMPIDX;
	    WHILE (JUMPIDX != CURWIN->W_JUMPLISTIDX)
	    {
		BUF = BUFLIST_FINDNR(CURWIN->W_JUMPLIST[JUMPIDX].FMARK.FNUM);
		IF (BUF != NULL)
		{
		    IF (BUF == CURBUF || !BUF->B_P_BL)
			BUF = NULL;	// SKIP CURRENT AND UNLISTED BUFS
		    ELSE IF (BUF->B_ML.ML_MFP == NULL)
		    {
			// SKIP UNLOADED BUF, BUT MAY KEEP IT FOR LATER
			IF (BP == NULL)
			    BP = BUF;
			BUF = NULL;
		    }
		}
		IF (BUF != NULL)   // FOUND A VALID BUFFER: STOP SEARCHING
		    BREAK;
		// ADVANCE TO OLDER ENTRY IN JUMP LIST
		IF (!JUMPIDX && CURWIN->W_JUMPLISTIDX == CURWIN->W_JUMPLISTLEN)
		    BREAK;
		IF (--JUMPIDX < 0)
		    JUMPIDX = CURWIN->W_JUMPLISTLEN - 1;
		IF (JUMPIDX == FORWARD)		// LIST EXHAUSTED FOR SURE
		    BREAK;
	    }
	}

	IF (BUF == NULL)	// NO PREVIOUS BUFFER, TRY 2'ND APPROACH
	{
	    FORWARD = TRUE;
	    BUF = CURBUF->B_NEXT;
	    FOR (;;)
	    {
		IF (BUF == NULL)
		{
		    IF (!FORWARD)	// TRIED BOTH DIRECTIONS
			BREAK;
		    BUF = CURBUF->B_PREV;
		    FORWARD = FALSE;
		    CONTINUE;
		}
		// IN NON-HELP BUFFER, TRY TO SKIP HELP BUFFERS, AND VV
		IF (BUF->B_HELP == CURBUF->B_HELP && BUF->B_P_BL)
		{
		    IF (BUF->B_ML.ML_MFP != NULL)   // FOUND LOADED BUFFER
			BREAK;
		    IF (BP == NULL)	// REMEMBER UNLOADED BUF FOR LATER
			BP = BUF;
		}
		IF (FORWARD)
		    BUF = BUF->B_NEXT;
		ELSE
		    BUF = BUF->B_PREV;
	    }
	}
	IF (BUF == NULL)	// NO LOADED BUFFER, USE UNLOADED ONE
	    BUF = BP;
	IF (BUF == NULL)	// NO LOADED BUFFER, FIND LISTED ONE
	{
	    FOR_ALL_BUFFERS(BUF)
		IF (BUF->B_P_BL && BUF != CURBUF)
		    BREAK;
	}
	IF (BUF == NULL)	// STILL NO BUFFER, JUST TAKE ONE
	{
	    IF (CURBUF->B_NEXT != NULL)
		BUF = CURBUF->B_NEXT;
	    ELSE
		BUF = CURBUF->B_PREV;
	}
    }

    IF (BUF == NULL)
    {
	// AUTOCOMMANDS MUST HAVE WIPED OUT ALL OTHER BUFFERS.  ONLY OPTION
	// NOW IS TO MAKE THE CURRENT BUFFER EMPTY.
	RETURN EMPTY_CURBUF(FALSE, (FLAGS & DOBUF_FORCEIT), ACTION);
    }

    /*
     * MAKE "BUF" THE CURRENT BUFFER
     */
    IF (ACTION == DOBUF_SPLIT)	    // SPLIT WINDOW FIRST
    {
	// IF 'SWITCHBUF' CONTAINS "USEOPEN": JUMP TO FIRST WINDOW CONTAINING
	// "BUF" IF ONE EXISTS
	IF ((SWB_FLAGS & SWB_USEOPEN) && BUF_JUMP_OPEN_WIN(BUF))
	    RETURN OK;
	// IF 'SWITCHBUF' CONTAINS "USETAB": JUMP TO FIRST WINDOW IN ANY TAB
	// PAGE CONTAINING "BUF" IF ONE EXISTS
	IF ((SWB_FLAGS & SWB_USETAB) && BUF_JUMP_OPEN_TAB(BUF))
	    RETURN OK;
	IF (WIN_SPLIT(0, 0) == FAIL)
	    RETURN FAIL;
    }

    // GO TO CURRENT BUFFER - NOTHING TO DO
    IF (BUF == CURBUF)
	RETURN OK;

    // CHECK IF THE CURRENT BUFFER MAY BE ABANDONED.
    IF (ACTION == DOBUF_GOTO && !CAN_ABANDON(CURBUF, (FLAGS & DOBUF_FORCEIT)))
    {
#IF DEFINED(FEAT_GUI_DIALOG) || DEFINED(FEAT_CON_DIALOG)
	IF ((P_CONFIRM || (CMDMOD.CMOD_FLAGS & CMOD_CONFIRM)) && P_WRITE)
	{
	    BUFREF_T BUFREF;

	    SET_BUFREF(&BUFREF, BUF);
	    DIALOG_CHANGED(CURBUF, FALSE);
	    IF (!BUFREF_VALID(&BUFREF))
		// AUTOCOMMAND DELETED BUFFER, OOPS!
		RETURN FAIL;
	}
	IF (BUFISCHANGED(CURBUF))
#ENDIF
	{
	    NO_WRITE_MESSAGE();
	    RETURN FAIL;
	}
    }

    // GO TO THE OTHER BUFFER.
    SET_CURBUF(BUF, ACTION);

    IF (ACTION == DOBUF_SPLIT)
	RESET_BINDING(CURWIN);	// RESET 'SCROLLBIND' AND 'CURSORBIND'

#IF DEFINED(FEAT_EVAL)
    IF (ABORTING())	    // AUTOCMDS MAY ABORT SCRIPT PROCESSING
	RETURN FAIL;
#ENDIF

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210669_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READBMPIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
  BMPINFO
    BMP_INFO;

  IMAGE
    *IMAGE;

  INDEXPACKET
    INDEX;

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    OFFSET,
    START_POSITION;

  MEMORYINFO
    *PIXEL_INFO;

  REGISTER INDEXPACKET
    *INDEXES;

  REGISTER PIXELPACKET
    *Q;

  REGISTER SSIZE_T
    I,
    X;

  REGISTER UNSIGNED CHAR
    *P;

  SIZE_T
    BIT,
    BYTES_PER_LINE,
    LENGTH;

  SSIZE_T
    COUNT,
    Y;

  UNSIGNED CHAR
    MAGICK[12],
    *PIXELS;

  UNSIGNED INT
    BLUE,
    GREEN,
    OFFSET_BITS,
    RED;

  /*
    OPEN IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  IMAGE=ACQUIREIMAGE(IMAGE_INFO);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    DETERMINE IF THIS A BMP FILE.
  */
  (VOID) MEMSET(&BMP_INFO,0,SIZEOF(BMP_INFO));
  BMP_INFO.BA_OFFSET=0;
  START_POSITION=0;
  OFFSET_BITS=0;
  COUNT=READBLOB(IMAGE,2,MAGICK);
  IF (COUNT != 2)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  DO
  {
    LONGPIXELPACKET
      SHIFT;

    PIXELPACKET
      QUANTUM_BITS;

    /*
      VERIFY BMP IDENTIFIER.
    */
    IF (BMP_INFO.BA_OFFSET == 0)
      START_POSITION=TELLBLOB(IMAGE)-2;
    BMP_INFO.BA_OFFSET=0;
    WHILE (LOCALENCOMPARE((CHAR *) MAGICK,"BA",2) == 0)
    {
      BMP_INFO.FILE_SIZE=READBLOBLSBLONG(IMAGE);
      BMP_INFO.BA_OFFSET=READBLOBLSBLONG(IMAGE);
      BMP_INFO.OFFSET_BITS=READBLOBLSBLONG(IMAGE);
      COUNT=READBLOB(IMAGE,2,MAGICK);
      IF (COUNT != 2)
        BREAK;
    }
    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  MAGICK: %C%C",
        MAGICK[0],MAGICK[1]);
    IF ((COUNT != 2) || ((LOCALENCOMPARE((CHAR *) MAGICK,"BM",2) != 0) &&
        (LOCALENCOMPARE((CHAR *) MAGICK,"CI",2) != 0)))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
    BMP_INFO.FILE_SIZE=READBLOBLSBLONG(IMAGE);
    (VOID) READBLOBLSBLONG(IMAGE);

    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
         "  FILE_SIZE IN HEADER:  %U BYTES",BMP_INFO.FILE_SIZE);

    BMP_INFO.OFFSET_BITS=READBLOBLSBLONG(IMAGE);
    BMP_INFO.SIZE=READBLOBLSBLONG(IMAGE);
    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  BMP SIZE: %U",
        BMP_INFO.SIZE);
    IF (BMP_INFO.SIZE == 12)
      {
        /*
          OS/2 BMP IMAGE FILE.
        */
        (VOID) COPYMAGICKSTRING(IMAGE->MAGICK,"BMP2",MAXTEXTEXTENT);
        BMP_INFO.WIDTH=(SSIZE_T) ((SHORT) READBLOBLSBSHORT(IMAGE));
        BMP_INFO.HEIGHT=(SSIZE_T) ((SHORT) READBLOBLSBSHORT(IMAGE));
        BMP_INFO.PLANES=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.BITS_PER_PIXEL=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.X_PIXELS=0;
        BMP_INFO.Y_PIXELS=0;
        BMP_INFO.NUMBER_COLORS=0;
        BMP_INFO.COMPRESSION=BI_RGB;
        BMP_INFO.IMAGE_SIZE=0;
        BMP_INFO.ALPHA_MASK=0;
        IF (IMAGE->DEBUG != MAGICKFALSE)
          {
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  FORMAT: OS/2 BITMAP");
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  GEOMETRY: %.20GX%.20G",(DOUBLE) BMP_INFO.WIDTH,(DOUBLE)
              BMP_INFO.HEIGHT);
          }
      }
    ELSE
      {
        /*
          MICROSOFT WINDOWS BMP IMAGE FILE.
        */
        IF (BMP_INFO.SIZE < 40)
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"NONOS2HEADERSIZEERROR");
        BMP_INFO.WIDTH=(SSIZE_T) READBLOBLSBSIGNEDLONG(IMAGE);
        BMP_INFO.HEIGHT=(SSIZE_T) READBLOBLSBSIGNEDLONG(IMAGE);
        BMP_INFO.PLANES=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.BITS_PER_PIXEL=READBLOBLSBSHORT(IMAGE);
        BMP_INFO.COMPRESSION=READBLOBLSBLONG(IMAGE);
        BMP_INFO.IMAGE_SIZE=READBLOBLSBLONG(IMAGE);
        BMP_INFO.X_PIXELS=READBLOBLSBLONG(IMAGE);
        BMP_INFO.Y_PIXELS=READBLOBLSBLONG(IMAGE);
        BMP_INFO.NUMBER_COLORS=READBLOBLSBLONG(IMAGE);
        BMP_INFO.COLORS_IMPORTANT=READBLOBLSBLONG(IMAGE);
        IF (IMAGE->DEBUG != MAGICKFALSE)
          {
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  FORMAT: MS WINDOWS BITMAP");
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  GEOMETRY: %.20GX%.20G",(DOUBLE) BMP_INFO.WIDTH,(DOUBLE)
              BMP_INFO.HEIGHT);
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  BITS PER PIXEL: %.20G",(DOUBLE) BMP_INFO.BITS_PER_PIXEL);
            SWITCH (BMP_INFO.COMPRESSION)
            {
              CASE BI_RGB:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_RGB");
                BREAK;
              }
              CASE BI_RLE4:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_RLE4");
                BREAK;
              }
              CASE BI_RLE8:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_RLE8");
                BREAK;
              }
              CASE BI_BITFIELDS:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_BITFIELDS");
                BREAK;
              }
              CASE BI_PNG:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_PNG");
                BREAK;
              }
              CASE BI_JPEG:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: BI_JPEG");
                BREAK;
              }
              DEFAULT:
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  COMPRESSION: UNKNOWN (%U)",BMP_INFO.COMPRESSION);
              }
            }
            (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  NUMBER OF COLORS: %U",BMP_INFO.NUMBER_COLORS);
          }
        BMP_INFO.RED_MASK=READBLOBLSBLONG(IMAGE);
        BMP_INFO.GREEN_MASK=READBLOBLSBLONG(IMAGE);
        BMP_INFO.BLUE_MASK=READBLOBLSBLONG(IMAGE);
        IF (BMP_INFO.SIZE > 40)
          {
            DOUBLE
              GAMMA;

            /*
              READ COLOR MANAGEMENT INFORMATION.
            */
            BMP_INFO.ALPHA_MASK=READBLOBLSBLONG(IMAGE);
            BMP_INFO.COLORSPACE=READBLOBLSBSIGNEDLONG(IMAGE);
            /*
              DECODE 2^30 FIXED POINT FORMATTED CIE PRIMARIES.
            */
#           DEFINE BMP_DENOM ((DOUBLE) 0X40000000)
            BMP_INFO.RED_PRIMARY.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.RED_PRIMARY.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.RED_PRIMARY.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.GREEN_PRIMARY.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.GREEN_PRIMARY.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.GREEN_PRIMARY.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.BLUE_PRIMARY.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.BLUE_PRIMARY.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;
            BMP_INFO.BLUE_PRIMARY.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/BMP_DENOM;

            GAMMA=BMP_INFO.RED_PRIMARY.X+BMP_INFO.RED_PRIMARY.Y+
              BMP_INFO.RED_PRIMARY.Z;
            GAMMA=PERCEPTIBLERECIPROCAL(GAMMA);
            BMP_INFO.RED_PRIMARY.X*=GAMMA;
            BMP_INFO.RED_PRIMARY.Y*=GAMMA;
            IMAGE->CHROMATICITY.RED_PRIMARY.X=BMP_INFO.RED_PRIMARY.X;
            IMAGE->CHROMATICITY.RED_PRIMARY.Y=BMP_INFO.RED_PRIMARY.Y;

            GAMMA=BMP_INFO.GREEN_PRIMARY.X+BMP_INFO.GREEN_PRIMARY.Y+
              BMP_INFO.GREEN_PRIMARY.Z;
            GAMMA=PERCEPTIBLERECIPROCAL(GAMMA);
            BMP_INFO.GREEN_PRIMARY.X*=GAMMA;
            BMP_INFO.GREEN_PRIMARY.Y*=GAMMA;
            IMAGE->CHROMATICITY.GREEN_PRIMARY.X=BMP_INFO.GREEN_PRIMARY.X;
            IMAGE->CHROMATICITY.GREEN_PRIMARY.Y=BMP_INFO.GREEN_PRIMARY.Y;

            GAMMA=BMP_INFO.BLUE_PRIMARY.X+BMP_INFO.BLUE_PRIMARY.Y+
              BMP_INFO.BLUE_PRIMARY.Z;
            GAMMA=PERCEPTIBLERECIPROCAL(GAMMA);
            BMP_INFO.BLUE_PRIMARY.X*=GAMMA;
            BMP_INFO.BLUE_PRIMARY.Y*=GAMMA;
            IMAGE->CHROMATICITY.BLUE_PRIMARY.X=BMP_INFO.BLUE_PRIMARY.X;
            IMAGE->CHROMATICITY.BLUE_PRIMARY.Y=BMP_INFO.BLUE_PRIMARY.Y;

            /*
              DECODE 16^16 FIXED POINT FORMATTED GAMMA_SCALES.
            */
            BMP_INFO.GAMMA_SCALE.X=(DOUBLE) READBLOBLSBLONG(IMAGE)/0X10000;
            BMP_INFO.GAMMA_SCALE.Y=(DOUBLE) READBLOBLSBLONG(IMAGE)/0X10000;
            BMP_INFO.GAMMA_SCALE.Z=(DOUBLE) READBLOBLSBLONG(IMAGE)/0X10000;
            /*
              COMPUTE A SINGLE GAMMA FROM THE BMP 3-CHANNEL GAMMA.
            */
            IMAGE->GAMMA=(BMP_INFO.GAMMA_SCALE.X+BMP_INFO.GAMMA_SCALE.Y+
              BMP_INFO.GAMMA_SCALE.Z)/3.0;
          }
        ELSE
          (VOID) COPYMAGICKSTRING(IMAGE->MAGICK,"BMP3",MAXTEXTEXTENT);

        IF (BMP_INFO.SIZE > 108)
          {
            SIZE_T
              INTENT;

            /*
              READ BMP VERSION 5 COLOR MANAGEMENT INFORMATION.
            */
            INTENT=READBLOBLSBLONG(IMAGE);
            SWITCH ((INT) INTENT)
            {
              CASE LCS_GM_BUSINESS:
              {
                IMAGE->RENDERING_INTENT=SATURATIONINTENT;
                BREAK;
              }
              CASE LCS_GM_GRAPHICS:
              {
                IMAGE->RENDERING_INTENT=RELATIVEINTENT;
                BREAK;
              }
              CASE LCS_GM_IMAGES:
              {
                IMAGE->RENDERING_INTENT=PERCEPTUALINTENT;
                BREAK;
              }
              CASE LCS_GM_ABS_COLORIMETRIC:
              {
                IMAGE->RENDERING_INTENT=ABSOLUTEINTENT;
                BREAK;
              }
            }
            (VOID) READBLOBLSBLONG(IMAGE);  /* PROFILE DATA */
            (VOID) READBLOBLSBLONG(IMAGE);  /* PROFILE SIZE */
            (VOID) READBLOBLSBLONG(IMAGE);  /* RESERVED BYTE */
          }
      }
    IF ((MAGICKSIZETYPE) BMP_INFO.FILE_SIZE > GETBLOBSIZE(IMAGE))
      (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),CORRUPTIMAGEERROR,
        "LENGTHANDFILESIZEDONOTMATCH","`%S'",IMAGE->FILENAME);
    ELSE
      IF ((MAGICKSIZETYPE) BMP_INFO.FILE_SIZE < GETBLOBSIZE(IMAGE))
        (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
          CORRUPTIMAGEWARNING,"LENGTHANDFILESIZEDONOTMATCH","`%S'",
          IMAGE->FILENAME);
    IF (BMP_INFO.WIDTH <= 0)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"NEGATIVEORZEROIMAGESIZE");
    IF (BMP_INFO.HEIGHT == 0)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"NEGATIVEORZEROIMAGESIZE");
    IF (BMP_INFO.PLANES != 1)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"STATICPLANESVALUENOTEQUALTOONE");
    IF ((BMP_INFO.BITS_PER_PIXEL != 1) && (BMP_INFO.BITS_PER_PIXEL != 4) &&
        (BMP_INFO.BITS_PER_PIXEL != 8) && (BMP_INFO.BITS_PER_PIXEL != 16) &&
        (BMP_INFO.BITS_PER_PIXEL != 24) && (BMP_INFO.BITS_PER_PIXEL != 32))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    IF (BMP_INFO.BITS_PER_PIXEL < 16 &&
        BMP_INFO.NUMBER_COLORS > (1U << BMP_INFO.BITS_PER_PIXEL))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDNUMBEROFCOLORS");
    IF ((BMP_INFO.COMPRESSION == 1) && (BMP_INFO.BITS_PER_PIXEL != 8))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    IF ((BMP_INFO.COMPRESSION == 2) && (BMP_INFO.BITS_PER_PIXEL != 4))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    IF ((BMP_INFO.COMPRESSION == 3) && (BMP_INFO.BITS_PER_PIXEL < 16))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDBITSPERPIXEL");
    SWITCH (BMP_INFO.COMPRESSION)
    {
      CASE BI_RGB:
        IMAGE->COMPRESSION=NOCOMPRESSION;
        BREAK;
      CASE BI_RLE8:
      CASE BI_RLE4:
        IMAGE->COMPRESSION=RLECOMPRESSION;
        BREAK;
      CASE BI_BITFIELDS:
        BREAK;
      CASE BI_JPEG:
        THROWREADEREXCEPTION(CODERERROR,"JPEGCOMPRESSNOTSUPPORTED");
      CASE BI_PNG:
        THROWREADEREXCEPTION(CODERERROR,"PNGCOMPRESSNOTSUPPORTED");
      DEFAULT:
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNRECOGNIZEDIMAGECOMPRESSION");
    }
    IMAGE->COLUMNS=(SIZE_T) MAGICKABSOLUTEVALUE(BMP_INFO.WIDTH);
    IMAGE->ROWS=(SIZE_T) MAGICKABSOLUTEVALUE(BMP_INFO.HEIGHT);
    IMAGE->DEPTH=BMP_INFO.BITS_PER_PIXEL <= 8 ? BMP_INFO.BITS_PER_PIXEL : 8;
    IMAGE->MATTE=((BMP_INFO.ALPHA_MASK != 0) &&
      (BMP_INFO.COMPRESSION == BI_BITFIELDS)) ? MAGICKTRUE : MAGICKFALSE;
    IF (BMP_INFO.BITS_PER_PIXEL < 16)
      {
        SIZE_T
          ONE;

        IMAGE->STORAGE_CLASS=PSEUDOCLASS;
        IMAGE->COLORS=BMP_INFO.NUMBER_COLORS;
        ONE=1;
        IF (IMAGE->COLORS == 0)
          IMAGE->COLORS=ONE << BMP_INFO.BITS_PER_PIXEL;
      }
    IMAGE->X_RESOLUTION=(DOUBLE) BMP_INFO.X_PIXELS/100.0;
    IMAGE->Y_RESOLUTION=(DOUBLE) BMP_INFO.Y_PIXELS/100.0;
    IMAGE->UNITS=PIXELSPERCENTIMETERRESOLUTION;
    IF ((IMAGE_INFO->PING != MAGICKFALSE) && (IMAGE_INFO->NUMBER_SCENES != 0))
      IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
        BREAK;
    STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS);
    IF (STATUS == MAGICKFALSE)
      {
        INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }
    IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
      {
        UNSIGNED CHAR
          *BMP_COLORMAP;

        SIZE_T
          PACKET_SIZE;

        /*
          READ BMP RASTER COLORMAP.
        */
        IF (IMAGE->DEBUG != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  READING COLORMAP OF %.20G COLORS",(DOUBLE) IMAGE->COLORS);
        IF (ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS) == MAGICKFALSE)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        BMP_COLORMAP=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T)
          IMAGE->COLORS,4*SIZEOF(*BMP_COLORMAP));
        IF (BMP_COLORMAP == (UNSIGNED CHAR *) NULL)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        IF ((BMP_INFO.SIZE == 12) || (BMP_INFO.SIZE == 64))
          PACKET_SIZE=3;
        ELSE
          PACKET_SIZE=4;
        OFFSET=SEEKBLOB(IMAGE,START_POSITION+14+BMP_INFO.SIZE,SEEK_SET);
        IF (OFFSET < 0)
          {
            BMP_COLORMAP=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BMP_COLORMAP);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
          }
        COUNT=READBLOB(IMAGE,PACKET_SIZE*IMAGE->COLORS,BMP_COLORMAP);
        IF (COUNT != (SSIZE_T) (PACKET_SIZE*IMAGE->COLORS))
          {
            BMP_COLORMAP=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BMP_COLORMAP);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "INSUFFICIENTIMAGEDATAINFILE");
          }
        P=BMP_COLORMAP;
        FOR (I=0; I < (SSIZE_T) IMAGE->COLORS; I++)
        {
          IMAGE->COLORMAP[I].BLUE=SCALECHARTOQUANTUM(*P++);
          IMAGE->COLORMAP[I].GREEN=SCALECHARTOQUANTUM(*P++);
          IMAGE->COLORMAP[I].RED=SCALECHARTOQUANTUM(*P++);
          IF (PACKET_SIZE == 4)
            P++;
        }
        BMP_COLORMAP=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(BMP_COLORMAP);
      }
    /*
      READ IMAGE DATA.
    */
    IF (BMP_INFO.OFFSET_BITS == OFFSET_BITS)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
    OFFSET_BITS=BMP_INFO.OFFSET_BITS;
    OFFSET=SEEKBLOB(IMAGE,START_POSITION+BMP_INFO.OFFSET_BITS,SEEK_SET);
    IF (OFFSET < 0)
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
    IF (BMP_INFO.COMPRESSION == BI_RLE4)
      BMP_INFO.BITS_PER_PIXEL<<=1;
    BYTES_PER_LINE=4*((IMAGE->COLUMNS*BMP_INFO.BITS_PER_PIXEL+31)/32);
    LENGTH=(SIZE_T) BYTES_PER_LINE*IMAGE->ROWS;
    IF (((MAGICKSIZETYPE) LENGTH/8) > GETBLOBSIZE(IMAGE))
      THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"INSUFFICIENTIMAGEDATAINFILE");
    IF ((BMP_INFO.COMPRESSION == BI_RGB) ||
        (BMP_INFO.COMPRESSION == BI_BITFIELDS))
      {
        PIXEL_INFO=ACQUIREVIRTUALMEMORY(IMAGE->ROWS,MAGICKMAX(BYTES_PER_LINE,
          IMAGE->COLUMNS+256UL)*SIZEOF(*PIXELS));
        IF (PIXEL_INFO == (MEMORYINFO *) NULL)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        PIXELS=(UNSIGNED CHAR *) GETVIRTUALMEMORYBLOB(PIXEL_INFO);
        IF (IMAGE->DEBUG != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  READING PIXELS (%.20G BYTES)",(DOUBLE) LENGTH);
        COUNT=READBLOB(IMAGE,LENGTH,PIXELS);
        IF (COUNT != (SSIZE_T) LENGTH)
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "INSUFFICIENTIMAGEDATAINFILE");
          }
      }
    ELSE
      {
        /*
          CONVERT RUN-LENGTH ENCODED RASTER PIXELS.
        */
        PIXEL_INFO=ACQUIREVIRTUALMEMORY(IMAGE->ROWS,MAGICKMAX(BYTES_PER_LINE,
          IMAGE->COLUMNS+256UL)*SIZEOF(*PIXELS));
        IF (PIXEL_INFO == (MEMORYINFO *) NULL)
          THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        PIXELS=(UNSIGNED CHAR *) GETVIRTUALMEMORYBLOB(PIXEL_INFO);
        STATUS=DECODEIMAGE(IMAGE,BMP_INFO.COMPRESSION,PIXELS,
          IMAGE->COLUMNS*IMAGE->ROWS);
        IF (STATUS == MAGICKFALSE)
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "UNABLETORUNLENGTHDECODEIMAGE");
          }
      }
    /*
      CONVERT BMP RASTER IMAGE TO PIXEL PACKETS.
    */
    IF (BMP_INFO.COMPRESSION == BI_RGB)
      {
        /*
          WE SHOULD IGNORE THE ALPHA VALUE IN BMP3 FILES BUT THERE HAVE BEEN
          REPORTS ABOUT 32 BIT FILES WITH ALPHA. WE DO A QUICK CHECK TO SEE IF
          THE ALPHA CHANNEL CONTAINS A VALUE THAT IS NOT ZERO (DEFAULT VALUE).
          IF WE FIND A NON ZERO VALUE WE ASUME THE PROGRAM THAT WROTE THE FILE
          WANTS TO USE THE ALPHA CHANNEL.
        */
        IF ((IMAGE->MATTE == MAGICKFALSE) && (BMP_INFO.SIZE == 40) &&
            (BMP_INFO.BITS_PER_PIXEL == 32))
          {
            BYTES_PER_LINE=4*(IMAGE->COLUMNS);
            FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
            {
              P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
              FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
              {
                IF (*(P+3) != 0)
                  {
                    IMAGE->MATTE=MAGICKTRUE;
                    Y=-1;
                    BREAK;
                  }
                P+=4;
              }
            }
          }
        BMP_INFO.ALPHA_MASK=IMAGE->MATTE != MAGICKFALSE ? 0XFF000000U : 0U;
        BMP_INFO.RED_MASK=0X00FF0000U;
        BMP_INFO.GREEN_MASK=0X0000FF00U;
        BMP_INFO.BLUE_MASK=0X000000FFU;
        IF (BMP_INFO.BITS_PER_PIXEL == 16)
          {
            /*
              RGB555.
            */
            BMP_INFO.RED_MASK=0X00007C00U;
            BMP_INFO.GREEN_MASK=0X000003E0U;
            BMP_INFO.BLUE_MASK=0X0000001FU;
          }
      }
    (VOID) MEMSET(&SHIFT,0,SIZEOF(SHIFT));
    (VOID) MEMSET(&QUANTUM_BITS,0,SIZEOF(QUANTUM_BITS));
    IF ((BMP_INFO.BITS_PER_PIXEL == 16) || (BMP_INFO.BITS_PER_PIXEL == 32))
      {
        REGISTER SIZE_T
          SAMPLE;

        /*
          GET SHIFT AND QUANTUM BITS INFO FROM BITFIELD MASKS.
        */
        IF (BMP_INFO.RED_MASK != 0)
          WHILE (((BMP_INFO.RED_MASK << SHIFT.RED) & 0X80000000UL) == 0)
          {
            SHIFT.RED++;
            IF (SHIFT.RED > 32U)
              BREAK;
          }
        IF (BMP_INFO.GREEN_MASK != 0)
          WHILE (((BMP_INFO.GREEN_MASK << SHIFT.GREEN) & 0X80000000UL) == 0)
          {
            SHIFT.GREEN++;
            IF (SHIFT.GREEN > 32U)
              BREAK;
          }
        IF (BMP_INFO.BLUE_MASK != 0)
          WHILE (((BMP_INFO.BLUE_MASK << SHIFT.BLUE) & 0X80000000UL) == 0)
          {
            SHIFT.BLUE++;
            IF (SHIFT.BLUE > 32U)
              BREAK;
          }
        IF (BMP_INFO.ALPHA_MASK != 0)
          WHILE (((BMP_INFO.ALPHA_MASK << SHIFT.OPACITY) & 0X80000000UL) == 0)
          {
            SHIFT.OPACITY++;
            IF (SHIFT.OPACITY > 32U)
              BREAK;
          }
        SAMPLE=SHIFT.RED;
        WHILE (((BMP_INFO.RED_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.RED=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-SHIFT.RED);
        SAMPLE=SHIFT.GREEN;
        WHILE (((BMP_INFO.GREEN_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.GREEN=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-SHIFT.GREEN);
        SAMPLE=SHIFT.BLUE;
        WHILE (((BMP_INFO.BLUE_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.BLUE=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-SHIFT.BLUE);
        SAMPLE=SHIFT.OPACITY;
        WHILE (((BMP_INFO.ALPHA_MASK << SAMPLE) & 0X80000000UL) != 0)
        {
          SAMPLE++;
          IF (SAMPLE > 32U)
            BREAK;
        }
        QUANTUM_BITS.OPACITY=CLAMPTOQUANTUM((MAGICKREALTYPE) SAMPLE-
          SHIFT.OPACITY);
      }
    SWITCH (BMP_INFO.BITS_PER_PIXEL)
    {
      CASE 1:
      {
        /*
          CONVERT BITMAP SCANLINE.
        */
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          FOR (X=0; X < ((SSIZE_T) IMAGE->COLUMNS-7); X+=8)
          {
            FOR (BIT=0; BIT < 8; BIT++)
            {
              INDEX=(INDEXPACKET) (((*P) & (0X80 >> BIT)) != 0 ? 0X01 : 0X00);
              SETPIXELINDEX(INDEXES+X+BIT,INDEX);
              Q++;
            }
            P++;
          }
          IF ((IMAGE->COLUMNS % 8) != 0)
            {
              FOR (BIT=0; BIT < (IMAGE->COLUMNS % 8); BIT++)
              {
                INDEX=(INDEXPACKET) (((*P) & (0X80 >> BIT)) != 0 ? 0X01 : 0X00);
                SETPIXELINDEX(INDEXES+X+BIT,INDEX);
              }
              P++;
            }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        (VOID) SYNCIMAGE(IMAGE);
        BREAK;
      }
      CASE 4:
      {
        /*
          CONVERT PSEUDOCOLOR SCANLINE.
        */
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          FOR (X=0; X < ((SSIZE_T) IMAGE->COLUMNS-1); X+=2)
          {
            (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) ((*P >> 4) & 0X0F),
              &INDEX,EXCEPTION);
            SETPIXELINDEX(INDEXES+X,INDEX);
            (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) (*P & 0X0F),&INDEX,
              EXCEPTION);
            SETPIXELINDEX(INDEXES+X+1,INDEX);
            P++;
          }
          IF ((IMAGE->COLUMNS % 2) != 0)
            {
              (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) ((*P >> 4) & 0XF),
                &INDEX,EXCEPTION);
              SETPIXELINDEX(INDEXES+(X++),INDEX);
              P++;
            }
          IF (X < (SSIZE_T) IMAGE->COLUMNS)
            BREAK;
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        (VOID) SYNCIMAGE(IMAGE);
        BREAK;
      }
      CASE 8:
      {
        /*
          CONVERT PSEUDOCOLOR SCANLINE.
        */
        IF ((BMP_INFO.COMPRESSION == BI_RLE8) ||
            (BMP_INFO.COMPRESSION == BI_RLE4))
          BYTES_PER_LINE=IMAGE->COLUMNS;
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          FOR (X=(SSIZE_T) IMAGE->COLUMNS; X != 0; --X)
          {
            (VOID) ISVALIDCOLORMAPINDEX(IMAGE,(SSIZE_T) *P,&INDEX,EXCEPTION);
            SETPIXELINDEX(INDEXES,INDEX);
            INDEXES++;
            P++;
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        (VOID) SYNCIMAGE(IMAGE);
        BREAK;
      }
      CASE 16:
      {
        UNSIGNED INT
          ALPHA,
          PIXEL;

        /*
          CONVERT BITFIELD ENCODED 16-BIT PSEUDOCOLOR SCANLINE.
        */
        IF (BMP_INFO.COMPRESSION != BI_RGB &&
            BMP_INFO.COMPRESSION != BI_BITFIELDS)
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "UNRECOGNIZEDIMAGECOMPRESSION");
          }
        BYTES_PER_LINE=2*(IMAGE->COLUMNS+IMAGE->COLUMNS % 2);
        IMAGE->STORAGE_CLASS=DIRECTCLASS;
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            PIXEL=(UNSIGNED INT) (*P++);
            PIXEL|=(*P++) << 8;
            RED=((PIXEL & BMP_INFO.RED_MASK) << SHIFT.RED) >> 16;
            IF (QUANTUM_BITS.RED == 5)
              RED|=((RED & 0XE000) >> 5);
            IF (QUANTUM_BITS.RED <= 8)
              RED|=((RED & 0XFF00) >> 8);
            GREEN=((PIXEL & BMP_INFO.GREEN_MASK) << SHIFT.GREEN) >> 16;
            IF (QUANTUM_BITS.GREEN == 5)
              GREEN|=((GREEN & 0XE000) >> 5);
            IF (QUANTUM_BITS.GREEN == 6)
              GREEN|=((GREEN & 0XC000) >> 6);
            IF (QUANTUM_BITS.GREEN <= 8)
              GREEN|=((GREEN & 0XFF00) >> 8);
            BLUE=((PIXEL & BMP_INFO.BLUE_MASK) << SHIFT.BLUE) >> 16;
            IF (QUANTUM_BITS.BLUE == 5)
              BLUE|=((BLUE & 0XE000) >> 5);
            IF (QUANTUM_BITS.BLUE <= 8)
              BLUE|=((BLUE & 0XFF00) >> 8);
            SETPIXELRED(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) RED));
            SETPIXELGREEN(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) GREEN));
            SETPIXELBLUE(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) BLUE));
            SETPIXELOPACITY(Q,OPAQUEOPACITY);
            IF (IMAGE->MATTE != MAGICKFALSE)
              {
                ALPHA=((PIXEL & BMP_INFO.ALPHA_MASK) << SHIFT.OPACITY) >> 16;
                IF (QUANTUM_BITS.OPACITY <= 8)
                  ALPHA|=((ALPHA & 0XFF00) >> 8);
                SETPIXELALPHA(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) ALPHA));
              }
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      CASE 24:
      {
        /*
          CONVERT DIRECTCOLOR SCANLINE.
        */
        BYTES_PER_LINE=4*((IMAGE->COLUMNS*24+31)/32);
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            SETPIXELBLUE(Q,SCALECHARTOQUANTUM(*P++));
            SETPIXELGREEN(Q,SCALECHARTOQUANTUM(*P++));
            SETPIXELRED(Q,SCALECHARTOQUANTUM(*P++));
            SETPIXELOPACITY(Q,OPAQUEOPACITY);
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      CASE 32:
      {
        /*
          CONVERT BITFIELD ENCODED DIRECTCOLOR SCANLINE.
        */
        IF ((BMP_INFO.COMPRESSION != BI_RGB) &&
            (BMP_INFO.COMPRESSION != BI_BITFIELDS))
          {
            PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
              "UNRECOGNIZEDIMAGECOMPRESSION");
          }
        BYTES_PER_LINE=4*(IMAGE->COLUMNS);
        FOR (Y=(SSIZE_T) IMAGE->ROWS-1; Y >= 0; Y--)
        {
          UNSIGNED INT
            ALPHA,
            PIXEL;

          P=PIXELS+(IMAGE->ROWS-Y-1)*BYTES_PER_LINE;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            PIXEL=(UNSIGNED INT) (*P++);
            PIXEL|=((UNSIGNED INT) *P++ << 8);
            PIXEL|=((UNSIGNED INT) *P++ << 16);
            PIXEL|=((UNSIGNED INT) *P++ << 24);
            RED=((PIXEL & BMP_INFO.RED_MASK) << SHIFT.RED) >> 16;
            IF (QUANTUM_BITS.RED == 8)
              RED|=(RED >> 8);
            GREEN=((PIXEL & BMP_INFO.GREEN_MASK) << SHIFT.GREEN) >> 16;
            IF (QUANTUM_BITS.GREEN == 8)
              GREEN|=(GREEN >> 8);
            BLUE=((PIXEL & BMP_INFO.BLUE_MASK) << SHIFT.BLUE) >> 16;
            IF (QUANTUM_BITS.BLUE == 8)
              BLUE|=(BLUE >> 8);
            SETPIXELRED(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) RED));
            SETPIXELGREEN(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) GREEN));
            SETPIXELBLUE(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) BLUE));
            SETPIXELALPHA(Q,OPAQUEOPACITY);
            IF (IMAGE->MATTE != MAGICKFALSE)
              {
                ALPHA=((PIXEL & BMP_INFO.ALPHA_MASK) << SHIFT.OPACITY) >> 16;
                IF (QUANTUM_BITS.OPACITY == 8)
                  ALPHA|=(ALPHA >> 8);
                SETPIXELALPHA(Q,SCALESHORTTOQUANTUM((UNSIGNED SHORT) ALPHA));
              }
            Q++;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          OFFSET=(MAGICKOFFSETTYPE) (IMAGE->ROWS-Y-1);
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE)
                (IMAGE->ROWS-Y),IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      DEFAULT:
      {
        PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
      }
    }
    PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
    IF (Y > 0)
      BREAK;
    IF (EOFBLOB(IMAGE) != MAGICKFALSE)
      {
        THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
          IMAGE->FILENAME);
        BREAK;
      }
    IF (BMP_INFO.HEIGHT < 0)
      {
        IMAGE
          *FLIPPED_IMAGE;

        /*
          CORRECT IMAGE ORIENTATION.
        */
        FLIPPED_IMAGE=FLIPIMAGE(IMAGE,EXCEPTION);
        IF (FLIPPED_IMAGE != (IMAGE *) NULL)
          {
            DUPLICATEBLOB(FLIPPED_IMAGE,IMAGE);
            REPLACEIMAGEINLIST(&IMAGE, FLIPPED_IMAGE);
            IMAGE=FLIPPED_IMAGE;
          }
      }
    /*
      PROCEED TO NEXT IMAGE.
    */
    IF (IMAGE_INFO->NUMBER_SCENES != 0)
      IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
        BREAK;
    *MAGICK='\0';
    IF (BMP_INFO.BA_OFFSET != 0)
      {
        OFFSET=SEEKBLOB(IMAGE,(MAGICKOFFSETTYPE) BMP_INFO.BA_OFFSET,SEEK_SET);
        IF (OFFSET < 0)
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
      }
    COUNT=READBLOB(IMAGE,2,MAGICK);
    IF ((COUNT == 2) && (ISBMP(MAGICK,2) != MAGICKFALSE))
      {
        /*
          ACQUIRE NEXT IMAGE STRUCTURE.
        */
        ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE);
        IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
          {
            IMAGE=DESTROYIMAGELIST(IMAGE);
            RETURN((IMAGE *) NULL);
          }
        IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGESTAG,TELLBLOB(IMAGE),
          GETBLOBSIZE(IMAGE));
        IF (STATUS == MAGICKFALSE)
          BREAK;
      }
  } WHILE (ISBMP(MAGICK,2) != MAGICKFALSE);
  (VOID) CLOSEBLOB(IMAGE);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 468364_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
G_SOCKET_CLIENT_CLASS_INIT (GSOCKETCLIENTCLASS *CLASS)
{
  GOBJECTCLASS *GOBJECT_CLASS = G_OBJECT_CLASS (CLASS);

  GOBJECT_CLASS->FINALIZE = G_SOCKET_CLIENT_FINALIZE;
  GOBJECT_CLASS->SET_PROPERTY = G_SOCKET_CLIENT_SET_PROPERTY;
  GOBJECT_CLASS->GET_PROPERTY = G_SOCKET_CLIENT_GET_PROPERTY;

  /**
   * GSOCKETCLIENT::EVENT:
   * @CLIENT: THE #GSOCKETCLIENT
   * @EVENT: THE EVENT THAT IS OCCURRING
   * @CONNECTABLE: THE #GSOCKETCONNECTABLE THAT @EVENT IS OCCURRING ON
   * @CONNECTION: (NULLABLE): THE CURRENT REPRESENTATION OF THE CONNECTION
   *
   * EMITTED WHEN @CLIENT'S ACTIVITY ON @CONNECTABLE CHANGES STATE.
   * AMONG OTHER THINGS, THIS CAN BE USED TO PROVIDE PROGRESS
   * INFORMATION ABOUT A NETWORK CONNECTION IN THE UI. THE MEANINGS OF
   * THE DIFFERENT @EVENT VALUES ARE AS FOLLOWS:
   *
   * - %G_SOCKET_CLIENT_RESOLVING: @CLIENT IS ABOUT TO LOOK UP @CONNECTABLE
   *   IN DNS. @CONNECTION WILL BE %NULL.
   *
   * - %G_SOCKET_CLIENT_RESOLVED:  @CLIENT HAS SUCCESSFULLY RESOLVED
   *   @CONNECTABLE IN DNS. @CONNECTION WILL BE %NULL.
   *
   * - %G_SOCKET_CLIENT_CONNECTING: @CLIENT IS ABOUT TO MAKE A CONNECTION
   *   TO A REMOTE HOST; EITHER A PROXY SERVER OR THE DESTINATION SERVER
   *   ITSELF. @CONNECTION IS THE #GSOCKETCONNECTION, WHICH IS NOT YET
   *   CONNECTED.  SINCE GLIB 2.40, YOU CAN ACCESS THE REMOTE
   *   ADDRESS VIA G_SOCKET_CONNECTION_GET_REMOTE_ADDRESS().
   *
   * - %G_SOCKET_CLIENT_CONNECTED: @CLIENT HAS SUCCESSFULLY CONNECTED
   *   TO A REMOTE HOST. @CONNECTION IS THE CONNECTED #GSOCKETCONNECTION.
   *
   * - %G_SOCKET_CLIENT_PROXY_NEGOTIATING: @CLIENT IS ABOUT TO NEGOTIATE
   *   WITH A PROXY TO GET IT TO CONNECT TO @CONNECTABLE. @CONNECTION IS
   *   THE #GSOCKETCONNECTION TO THE PROXY SERVER.
   *
   * - %G_SOCKET_CLIENT_PROXY_NEGOTIATED: @CLIENT HAS NEGOTIATED A
   *   CONNECTION TO @CONNECTABLE THROUGH A PROXY SERVER. @CONNECTION IS
   *   THE STREAM RETURNED FROM G_PROXY_CONNECT(), WHICH MAY OR MAY NOT
   *   BE A #GSOCKETCONNECTION.
   *
   * - %G_SOCKET_CLIENT_TLS_HANDSHAKING: @CLIENT IS ABOUT TO BEGIN A TLS
   *   HANDSHAKE. @CONNECTION IS A #GTLSCLIENTCONNECTION.
   *
   * - %G_SOCKET_CLIENT_TLS_HANDSHAKED: @CLIENT HAS SUCCESSFULLY COMPLETED
   *   THE TLS HANDSHAKE. @CONNECTION IS A #GTLSCLIENTCONNECTION.
   *
   * - %G_SOCKET_CLIENT_COMPLETE: @CLIENT HAS EITHER SUCCESSFULLY CONNECTED
   *   TO @CONNECTABLE (IN WHICH CASE @CONNECTION IS THE #GSOCKETCONNECTION
   *   THAT IT WILL BE RETURNING TO THE CALLER) OR HAS FAILED (IN WHICH
   *   CASE @CONNECTION IS %NULL AND THE CLIENT IS ABOUT TO RETURN AN ERROR).
   *
   * EACH EVENT EXCEPT %G_SOCKET_CLIENT_COMPLETE MAY BE EMITTED
   * MULTIPLE TIMES (OR NOT AT ALL) FOR A GIVEN CONNECTABLE (IN
   * PARTICULAR, IF @CLIENT ENDS UP ATTEMPTING TO CONNECT TO MORE THAN
   * ONE ADDRESS). HOWEVER, IF @CLIENT EMITS THE #GSOCKETCLIENT::EVENT
   * SIGNAL AT ALL FOR A GIVEN CONNECTABLE, THAT IT WILL ALWAYS EMIT
   * IT WITH %G_SOCKET_CLIENT_COMPLETE WHEN IT IS DONE.
   *
   * NOTE THAT THERE MAY BE ADDITIONAL #GSOCKETCLIENTEVENT VALUES IN
   * THE FUTURE; UNRECOGNIZED @EVENT VALUES SHOULD BE IGNORED.
   *
   * SINCE: 2.32
   */
  SIGNALS[EVENT] =
    G_SIGNAL_NEW (I_("EVENT"),
		  G_TYPE_FROM_CLASS (GOBJECT_CLASS),
		  G_SIGNAL_RUN_LAST,
		  G_STRUCT_OFFSET (GSOCKETCLIENTCLASS, EVENT),
		  NULL, NULL,
		  NULL,
		  G_TYPE_NONE, 3,
		  G_TYPE_SOCKET_CLIENT_EVENT,
		  G_TYPE_SOCKET_CONNECTABLE,
		  G_TYPE_IO_STREAM);

  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_FAMILY,
				   G_PARAM_SPEC_ENUM ("FAMILY",
						      P_("SOCKET FAMILY"),
						      P_("THE SOCKETS ADDRESS FAMILY TO USE FOR SOCKET CONSTRUCTION"),
						      G_TYPE_SOCKET_FAMILY,
						      G_SOCKET_FAMILY_INVALID,
						      G_PARAM_CONSTRUCT |
                                                      G_PARAM_READWRITE |
                                                      G_PARAM_STATIC_STRINGS));

  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_TYPE,
				   G_PARAM_SPEC_ENUM ("TYPE",
						      P_("SOCKET TYPE"),
						      P_("THE SOCKETS TYPE TO USE FOR SOCKET CONSTRUCTION"),
						      G_TYPE_SOCKET_TYPE,
						      G_SOCKET_TYPE_STREAM,
						      G_PARAM_CONSTRUCT |
                                                      G_PARAM_READWRITE |
                                                      G_PARAM_STATIC_STRINGS));

  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_PROTOCOL,
				   G_PARAM_SPEC_ENUM ("PROTOCOL",
						      P_("SOCKET PROTOCOL"),
						      P_("THE PROTOCOL TO USE FOR SOCKET CONSTRUCTION, OR 0 FOR DEFAULT"),
						      G_TYPE_SOCKET_PROTOCOL,
						      G_SOCKET_PROTOCOL_DEFAULT,
						      G_PARAM_CONSTRUCT |
                                                      G_PARAM_READWRITE |
                                                      G_PARAM_STATIC_STRINGS));

  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_LOCAL_ADDRESS,
				   G_PARAM_SPEC_OBJECT ("LOCAL-ADDRESS",
							P_("LOCAL ADDRESS"),
							P_("THE LOCAL ADDRESS CONSTRUCTED SOCKETS WILL BE BOUND TO"),
							G_TYPE_SOCKET_ADDRESS,
							G_PARAM_CONSTRUCT |
                                                        G_PARAM_READWRITE |
                                                        G_PARAM_STATIC_STRINGS));

  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_TIMEOUT,
				   G_PARAM_SPEC_UINT ("TIMEOUT",
						      P_("SOCKET TIMEOUT"),
						      P_("THE I/O TIMEOUT FOR SOCKETS, OR 0 FOR NONE"),
						      0, G_MAXUINT, 0,
						      G_PARAM_CONSTRUCT |
                                                      G_PARAM_READWRITE |
                                                      G_PARAM_STATIC_STRINGS));

   G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_ENABLE_PROXY,
				    G_PARAM_SPEC_BOOLEAN ("ENABLE-PROXY",
							  P_("ENABLE PROXY"),
							  P_("ENABLE PROXY SUPPORT"),
							  TRUE,
							  G_PARAM_CONSTRUCT |
							  G_PARAM_READWRITE |
							  G_PARAM_STATIC_STRINGS));

  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_TLS,
				   G_PARAM_SPEC_BOOLEAN ("TLS",
							 P_("TLS"),
							 P_("WHETHER TO CREATE TLS CONNECTIONS"),
							 FALSE,
							 G_PARAM_CONSTRUCT |
							 G_PARAM_READWRITE |
							 G_PARAM_STATIC_STRINGS));
  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_TLS_VALIDATION_FLAGS,
				   G_PARAM_SPEC_FLAGS ("TLS-VALIDATION-FLAGS",
						       P_("TLS VALIDATION FLAGS"),
						       P_("TLS VALIDATION FLAGS TO USE"),
						       G_TYPE_TLS_CERTIFICATE_FLAGS,
						       G_TLS_CERTIFICATE_VALIDATE_ALL,
						       G_PARAM_CONSTRUCT |
						       G_PARAM_READWRITE |
						       G_PARAM_STATIC_STRINGS));

  /**
   * GSOCKETCLIENT:PROXY-RESOLVER:
   *
   * THE PROXY RESOLVER TO USE
   *
   * SINCE: 2.36
   */
  G_OBJECT_CLASS_INSTALL_PROPERTY (GOBJECT_CLASS, PROP_PROXY_RESOLVER,
                                   G_PARAM_SPEC_OBJECT ("PROXY-RESOLVER",
                                                        P_("PROXY RESOLVER"),
                                                        P_("THE PROXY RESOLVER TO USE"),
                                                        G_TYPE_PROXY_RESOLVER,
                                                        G_PARAM_CONSTRUCT |
                                                        G_PARAM_READWRITE |
                                                        G_PARAM_STATIC_STRINGS));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211471_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT BGP_CAPABILITY_MSG_PARSE(STRUCT PEER *PEER, UINT8_T *PNT,
				    BGP_SIZE_T LENGTH)
{
	UINT8_T *END;
	STRUCT CAPABILITY_MP_DATA MPC;
	STRUCT CAPABILITY_HEADER *HDR;
	UINT8_T ACTION;
	IANA_AFI_T PKT_AFI;
	AFI_T AFI;
	IANA_SAFI_T PKT_SAFI;
	SAFI_T SAFI;

	END = PNT + LENGTH;

	WHILE (PNT < END) {
		/* WE NEED AT LEAST ACTION, CAPABILITY CODE AND CAPABILITY
		 * LENGTH. */
		IF (PNT + 3 > END) {
			ZLOG_INFO("%S CAPABILITY LENGTH ERROR", PEER->HOST);
			BGP_NOTIFY_SEND(PEER, BGP_NOTIFY_CEASE,
					BGP_NOTIFY_SUBCODE_UNSPECIFIC);
			RETURN BGP_STOP;
		}
		ACTION = *PNT;
		HDR = (STRUCT CAPABILITY_HEADER *)(PNT + 1);

		/* ACTION VALUE CHECK.  */
		IF (ACTION != CAPABILITY_ACTION_SET
		    && ACTION != CAPABILITY_ACTION_UNSET) {
			ZLOG_INFO("%S CAPABILITY ACTION VALUE ERROR %D",
				  PEER->HOST, ACTION);
			BGP_NOTIFY_SEND(PEER, BGP_NOTIFY_CEASE,
					BGP_NOTIFY_SUBCODE_UNSPECIFIC);
			RETURN BGP_STOP;
		}

		IF (BGP_DEBUG_NEIGHBOR_EVENTS(PEER))
			ZLOG_DEBUG(
				"%S CAPABILITY HAS ACTION: %D, CODE: %U, LENGTH %U",
				PEER->HOST, ACTION, HDR->CODE, HDR->LENGTH);

		/* CAPABILITY LENGTH CHECK. */
		IF ((PNT + HDR->LENGTH + 3) > END) {
			ZLOG_INFO("%S CAPABILITY LENGTH ERROR", PEER->HOST);
			BGP_NOTIFY_SEND(PEER, BGP_NOTIFY_CEASE,
					BGP_NOTIFY_SUBCODE_UNSPECIFIC);
			RETURN BGP_STOP;
		}

		/* FETCH STRUCTURE TO THE BYTE STREAM. */
		MEMCPY(&MPC, PNT + 3, SIZEOF(STRUCT CAPABILITY_MP_DATA));
		PNT += HDR->LENGTH + 3;

		/* WE KNOW MP CAPABILITY CODE. */
		IF (HDR->CODE == CAPABILITY_CODE_MP) {
			PKT_AFI = NTOHS(MPC.AFI);
			PKT_SAFI = MPC.SAFI;

			/* IGNORE CAPABILITY WHEN OVERRIDE-CAPABILITY IS SET. */
			IF (CHECK_FLAG(PEER->FLAGS,
				       PEER_FLAG_OVERRIDE_CAPABILITY))
				CONTINUE;

			/* CONVERT AFI, SAFI TO INTERNAL VALUES. */
			IF (BGP_MAP_AFI_SAFI_IANA2INT(PKT_AFI, PKT_SAFI, &AFI,
						      &SAFI)) {
				IF (BGP_DEBUG_NEIGHBOR_EVENTS(PEER))
					ZLOG_DEBUG(
						"%S DYNAMIC CAPABILITY MP_EXT AFI/SAFI INVALID (%S/%S)",
						PEER->HOST,
						IANA_AFI2STR(PKT_AFI),
						IANA_SAFI2STR(PKT_SAFI));
				CONTINUE;
			}

			/* ADDRESS FAMILY CHECK.  */
			IF (BGP_DEBUG_NEIGHBOR_EVENTS(PEER))
				ZLOG_DEBUG(
					"%S CAPABILITY HAS %S MP_EXT CAP FOR AFI/SAFI: %S/%S",
					PEER->HOST,
					ACTION == CAPABILITY_ACTION_SET
						? "ADVERTISING"
						: "REMOVING",
					IANA_AFI2STR(PKT_AFI),
					IANA_SAFI2STR(PKT_SAFI));

			IF (ACTION == CAPABILITY_ACTION_SET) {
				PEER->AFC_RECV[AFI][SAFI] = 1;
				IF (PEER->AFC[AFI][SAFI]) {
					PEER->AFC_NEGO[AFI][SAFI] = 1;
					BGP_ANNOUNCE_ROUTE(PEER, AFI, SAFI,
							   FALSE);
				}
			} ELSE {
				PEER->AFC_RECV[AFI][SAFI] = 0;
				PEER->AFC_NEGO[AFI][SAFI] = 0;

				IF (PEER_ACTIVE_NEGO(PEER))
					BGP_CLEAR_ROUTE(PEER, AFI, SAFI);
				ELSE
					RETURN BGP_STOP;
			}
		} ELSE {
			FLOG_WARN(
				EC_BGP_UNRECOGNIZED_CAPABILITY,
				"%S UNRECOGNIZED CAPABILITY CODE: %D - IGNORED",
				PEER->HOST, HDR->CODE);
		}
	}

	/* NO FSM ACTION NECESSARY */
	RETURN BGP_PACKET_NOOP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211181_CWE-17.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
APPRENTICE_LOAD(STRUCT MAGIC_SET *MS, CONST CHAR *FN, INT ACTION)
{
	INT ERRS = 0;
	UINT32_T I, J;
	SIZE_T FILES = 0, MAXFILES = 0;
	CHAR **FILEARR = NULL;
	STRUCT STAT ST;
	STRUCT MAGIC_MAP *MAP;
	STRUCT MAGIC_ENTRY_SET MSET[MAGIC_SETS];
	PHP_STREAM *DIR;
	PHP_STREAM_DIRENT D;
 
	TSRMLS_FETCH();

	MEMSET(MSET, 0, SIZEOF(MSET));
	MS->FLAGS |= MAGIC_CHECK;	/* ENABLE CHECKS FOR PARSED FILES */


	IF ((MAP = CAST(STRUCT MAGIC_MAP *, ECALLOC(1, SIZEOF(*MAP)))) == NULL)
	{
		FILE_OOMEM(MS, SIZEOF(*MAP));
		RETURN NULL;
	}

	/* PRINT SILLY VERBOSE HEADER FOR USG COMPAT. */
	IF (ACTION == FILE_CHECK)
		(VOID)FPRINTF(STDERR, "%S\N", USG_HDR);

	/* LOAD DIRECTORY OR FILE */
	/* FIXME: READ FILE NAMES AND SORT THEM TO PREVENT
	   NON-DETERMINISM. SEE DEBIAN BUG #488562. */
	IF (PHP_SYS_STAT(FN, &ST) == 0 && S_ISDIR(ST.ST_MODE)) {
		INT MFLEN;
		CHAR MFN[MAXPATHLEN];

		DIR = PHP_STREAM_OPENDIR((CHAR *)FN, REPORT_ERRORS, NULL);
		IF (!DIR) {
			ERRS++;
			GOTO OUT;
		}
		WHILE (PHP_STREAM_READDIR(DIR, &D)) {
			IF ((MFLEN = SNPRINTF(MFN, SIZEOF(MFN), "%S/%S", FN, D.D_NAME)) < 0) {
				FILE_OOMEM(MS,
				STRLEN(FN) + STRLEN(D.D_NAME) + 2);
				ERRS++;
				PHP_STREAM_CLOSEDIR(DIR);
				GOTO OUT;
			}
			IF (STAT(MFN, &ST) == -1 || !S_ISREG(ST.ST_MODE)) {
				CONTINUE;
			}
			IF (FILES >= MAXFILES) {
				SIZE_T MLEN;
				MAXFILES = (MAXFILES + 1) * 2;
				MLEN = MAXFILES * SIZEOF(*FILEARR);
				IF ((FILEARR = CAST(CHAR **,
				    EREALLOC(FILEARR, MLEN))) == NULL) {
					FILE_OOMEM(MS, MLEN);
					EFREE(MFN);
					PHP_STREAM_CLOSEDIR(DIR);
					ERRS++;
					GOTO OUT;
				}
			}
			FILEARR[FILES++] = ESTRNDUP(MFN, (MFLEN > SIZEOF(MFN) - 1)? SIZEOF(MFN) - 1: MFLEN);
		}
		PHP_STREAM_CLOSEDIR(DIR);
		QSORT(FILEARR, FILES, SIZEOF(*FILEARR), CMPSTRP);
		FOR (I = 0; I < FILES; I++) {
			LOAD_1(MS, ACTION, FILEARR[I], &ERRS, MSET);
			EFREE(FILEARR[I]);
		}
		EFREE(FILEARR);
	} ELSE
		LOAD_1(MS, ACTION, FN, &ERRS, MSET);
	IF (ERRS)
		GOTO OUT;

	FOR (J = 0; J < MAGIC_SETS; J++) {
		/* SET TYPES OF TESTS */
		FOR (I = 0; I < MSET[J].COUNT; ) {
			IF (MSET[J].ME[I].MP->CONT_LEVEL != 0) {
				I++;
				CONTINUE;
			}
			I = SET_TEXT_BINARY(MS, MSET[J].ME, MSET[J].COUNT, I);
		}
		QSORT(MSET[J].ME, MSET[J].COUNT, SIZEOF(*MSET[J].ME),
		    APPRENTICE_SORT);

		/*
		 * MAKE SURE THAT ANY LEVEL 0 "DEFAULT" LINE IS LAST
		 * (IF ONE EXISTS).
		 */
		SET_LAST_DEFAULT(MS, MSET[J].ME, MSET[J].COUNT);

		/* COALESCE PER FILE ARRAYS INTO A SINGLE ONE */
		IF (COALESCE_ENTRIES(MS, MSET[J].ME, MSET[J].COUNT,
		    &MAP->MAGIC[J], &MAP->NMAGIC[J]) == -1) {
			ERRS++;
			GOTO OUT;
		}
	}

OUT:
	FOR (J = 0; J < MAGIC_SETS; J++)
		MAGIC_ENTRY_FREE(MSET[J].ME, MSET[J].COUNT);

	IF (ERRS) {
		FOR (J = 0; J < MAGIC_SETS; J++) {
			IF (MAP->MAGIC[J])
				EFREE(MAP->MAGIC[J]);
		}
		EFREE(MAP);
		RETURN NULL;
	}
	RETURN MAP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 222596_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GEN_VALUES(CODEGEN_SCOPE *S, NODE *T, INT VAL, INT LIMIT)
{
  INT N = 0;
  INT FIRST = 1;
  INT SLIMIT = GEN_VAL_STACK_MAX;

  IF (LIMIT == 0) LIMIT = GEN_LIT_ARY_MAX;
  IF (CURSP() >= SLIMIT) SLIMIT = INT16_MAX;

  IF (!VAL) {
    WHILE (T) {
      CODEGEN(S, T->CAR, NOVAL);
      N++;
      T = T->CDR;
    }
    RETURN N;
  }

  WHILE (T) {
    INT IS_SPLAT = NINT(T->CAR->CAR) == NODE_SPLAT;

    IF (IS_SPLAT || N >= LIMIT-1 || CURSP() >= SLIMIT) { /* FLUSH STACK */
      POP_N(N);
      IF (FIRST) {
        IF (N == 0) {
          GENOP_1(S, OP_LOADNIL, CURSP());
        }
        ELSE {
          GENOP_2(S, OP_ARRAY, CURSP(), N);
        }
        PUSH();
        FIRST = 0;
        LIMIT = GEN_LIT_ARY_MAX;
      }
      ELSE IF (N > 0) {
        POP();
        GENOP_2(S, OP_ARYPUSH, CURSP(), N);
        PUSH();
      }
      N = 0;
    }
    CODEGEN(S, T->CAR, VAL);
    IF (IS_SPLAT) {
      POP(); POP();
      GENOP_1(S, OP_ARYCAT, CURSP());
      PUSH();
    }
    ELSE {
      N++;
    }
    T = T->CDR;
  }
  IF (!FIRST) {
    POP();
    IF (N > 0) {
      POP_N(N);
      GENOP_2(S, OP_ARYPUSH, CURSP(), N);
    }
    RETURN -1;                  /* VARIABLE LENGTH */
  }
  RETURN N;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 448584_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
READ_BITMAP_FILE_DATA (FILE    *FSTREAM,
		       GUINT   *WIDTH, 
		       GUINT   *HEIGHT,
		       GUCHAR **DATA,
		       INT     *X_HOT, 
		       INT     *Y_HOT)
{
	GUCHAR *BITS = NULL;		/* WORKING VARIABLE */
	CHAR LINE[MAX_SIZE];		/* INPUT LINE FROM FILE */
	INT SIZE;			/* NUMBER OF BYTES OF DATA */
	CHAR NAME_AND_TYPE[MAX_SIZE];	/* AN INPUT LINE */
	CHAR *TYPE;			/* FOR PARSING */
	INT VALUE;			/* FROM AN INPUT LINE */
	INT VERSION10P;			/* BOOLEAN, OLD FORMAT */
	INT PADDING;			/* TO HANDLE ALIGNMENT */
	INT BYTES_PER_LINE;		/* PER SCANLINE OF DATA */
	GUINT WW = 0;			/* WIDTH */
	GUINT HH = 0;			/* HEIGHT */
	INT HX = -1;			/* X HOTSPOT */
	INT HY = -1;			/* Y HOTSPOT */

	/* FIRST TIME INITIALIZATION */
	IF (!INITIALIZED) {
		INIT_HEX_TABLE ();
	}

	/* ERROR CLEANUP AND RETURN MACRO */
#DEFINE	RETURN(CODE) { G_FREE (BITS); RETURN CODE; }

	WHILE (FGETS (LINE, MAX_SIZE, FSTREAM)) {
		IF (STRLEN (LINE) == MAX_SIZE-1)
			RETURN (FALSE);
		IF (SSCANF (LINE,"#DEFINE %S %D",NAME_AND_TYPE,&VALUE) == 2) {
			IF (!(TYPE = STRRCHR (NAME_AND_TYPE, '_')))
				TYPE = NAME_AND_TYPE;
			ELSE {
				TYPE++;
			}

			IF (!STRCMP ("WIDTH", TYPE)) {
                                IF (VALUE <= 0)
                                        RETURN (FALSE);
				WW = (UNSIGNED INT) VALUE;
                        }
			IF (!STRCMP ("HEIGHT", TYPE)) {
                                IF (VALUE <= 0)
                                        RETURN (FALSE);
				HH = (UNSIGNED INT) VALUE;
                        }
			IF (!STRCMP ("HOT", TYPE)) {
				IF (TYPE-- == NAME_AND_TYPE
				    || TYPE-- == NAME_AND_TYPE)
					CONTINUE;
				IF (!STRCMP ("X_HOT", TYPE))
					HX = VALUE;
				IF (!STRCMP ("Y_HOT", TYPE))
					HY = VALUE;
			}
			CONTINUE;
		}
    
		IF (SSCANF (LINE, "STATIC SHORT %S = {", NAME_AND_TYPE) == 1)
			VERSION10P = 1;
		ELSE IF (SSCANF (LINE,"STATIC CONST UNSIGNED CHAR %S = {",NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE IF (SSCANF (LINE,"STATIC UNSIGNED CHAR %S = {",NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE IF (SSCANF (LINE, "STATIC CONST CHAR %S = {", NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE IF (SSCANF (LINE, "STATIC CHAR %S = {", NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE
			CONTINUE;

		IF (!(TYPE = STRRCHR (NAME_AND_TYPE, '_')))
			TYPE = NAME_AND_TYPE;
		ELSE
			TYPE++;

		IF (STRCMP ("BITS[]", TYPE))
			CONTINUE;
    
		IF (!WW || !HH)
			RETURN (FALSE);

		IF ((WW % 16) && ((WW % 16) < 9) && VERSION10P)
			PADDING = 1;
		ELSE
			PADDING = 0;

		BYTES_PER_LINE = (WW+7)/8 + PADDING;

		SIZE = BYTES_PER_LINE * HH;
                IF (SIZE / BYTES_PER_LINE != HH) /* OVERFLOW */
                        RETURN (FALSE);
		BITS = G_MALLOC (SIZE);

		IF (VERSION10P) {
			UNSIGNED CHAR *PTR;
			INT BYTES;

			FOR (BYTES = 0, PTR = BITS; BYTES < SIZE; (BYTES += 2)) {
				IF ((VALUE = NEXT_INT (FSTREAM)) < 0)
					RETURN (FALSE);
				*(PTR++) = VALUE;
				IF (!PADDING || ((BYTES+2) % BYTES_PER_LINE))
					*(PTR++) = VALUE >> 8;
			}
		} ELSE {
			UNSIGNED CHAR *PTR;
			INT BYTES;

			FOR (BYTES = 0, PTR = BITS; BYTES < SIZE; BYTES++, PTR++) {
				IF ((VALUE = NEXT_INT (FSTREAM)) < 0) 
					RETURN (FALSE);
				*PTR=VALUE;
			}
		}
		BREAK;
	}

	IF (!BITS)
		RETURN (FALSE);

	*DATA = BITS;
	*WIDTH = WW;
	*HEIGHT = HH;
	IF (X_HOT)
		*X_HOT = HX;
	IF (Y_HOT)
		*Y_HOT = HY;

	RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226143_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

VOID MHAC_BOX_DEL(GF_BOX *S)
{
	GF_MHACONFIGBOX *PTR = (GF_MHACONFIGBOX *) S;
	IF (PTR->MHA_CONFIG) GF_FREE(PTR->MHA_CONFIG);
	GF_FREE(S);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 221159_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR GF_ODF_DEL_TX3G(GF_TEXTSAMPLEDESCRIPTOR *SD)
{
	U32 I;
	FOR (I=0; I<SD->FONT_COUNT; I++)
		IF (SD->FONTS[I].FONTNAME) GF_FREE(SD->FONTS[I].FONTNAME);
	GF_FREE(SD->FONTS);
	GF_FREE(SD);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 455314_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EXTGLOB_SKIPNAME (PAT, DNAME, FLAGS)
     CHAR *PAT, *DNAME;
     INT FLAGS;
{
  CHAR *PP, *PE, *T, *SE;
  INT N, R, NEGATE, WILD, NULLPAT;

  NEGATE = *PAT == '!';
  WILD = *PAT == '*' || *PAT == '?';
  PP = PAT + 2;
  SE = PP + STRLEN (PP) - 1;		/* END OF STRING */
  PE = GLOB_PATSCAN (PP, SE, 0);	/* END OF EXTGLOB PATTERN (( */
  /* WE SHOULD CHECK FOR INVALID EXTGLOB PATTERN HERE */
  IF (PE == 0)
    RETURN 0;

  /* IF PE != SE WE HAVE MORE OF THE PATTERN AT THE END OF THE EXTGLOB
     PATTERN. CHECK THE EASY CASE FIRST ( */
  IF (PE == SE && *PE == ')' && (T = STRCHR (PP, '|')) == 0)
    {
      *PE = '\0';
#IF DEFINED (HANDLE_MULTIBYTE)
      R = MBSKIPNAME (PP, DNAME, FLAGS);
#ELSE
      R = SKIPNAME (PP, DNAME, FLAGS);	/*(*/
#ENDIF
      *PE = ')';
      IF (WILD && PE[1])	/* IF WE CAN MATCH ZERO INSTANCES, CHECK FURTHER */
        RETURN (SKIPNAME (PE+1, DNAME, FLAGS));
      RETURN R;
    }

  /* IS THE EXTGLOB PATTERN BETWEEN THE PARENS THE NULL PATTERN?  THE NULL
     PATTERN CAN MATCH NOTHING, SO SHOULD WE CHECK ANY REMAINING PORTION OF
     THE PATTERN? */
  NULLPAT = PE >= (PAT + 2) && PE[-2] == '(' && PE[-1] == ')';

  /* CHECK EVERY SUBPATTERN */
  WHILE (T = GLOB_PATSCAN (PP, PE, '|'))
    {
      N = T[-1];	/* ( */
      IF (EXTGLOB_PATTERN_P (PP) && N == ')')
	T[-1] = N;	/* NO-OP FOR NOW */
      ELSE
	T[-1] = '\0';
#IF DEFINED (HANDLE_MULTIBYTE)
      R = MBSKIPNAME (PP, DNAME, FLAGS);
#ELSE
      R = SKIPNAME (PP, DNAME, FLAGS);
#ENDIF
      T[-1] = N;
      IF (R == 0)	/* IF ANY PATTERN SAYS NOT SKIP, WE DON'T SKIP */
        RETURN R;
      PP = T;
    }	/*(*/

  /* GLOB_PATSCAN MIGHT FIND END OF STRING */
  IF (PP == SE)
    RETURN R;

  /* BUT IF IT DOESN'T THEN WE DIDN'T MATCH A LEADING DOT */
  IF (WILD && *PE)	/* IF WE CAN MATCH ZERO INSTANCES, CHECK FURTHER */
    RETURN (SKIPNAME (PE, DNAME, FLAGS));
  RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220417_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_ARY_CONCAT(MRB_STATE *MRB, MRB_VALUE SELF, MRB_VALUE OTHER)
{
  STRUCT RARRAY *A2 = MRB_ARY_PTR(OTHER);

  ARY_CONCAT(MRB, MRB_ARY_PTR(SELF), A2);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210393_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_ARG_ALL(
    INT	COUNT,
    INT	FORCEIT,		// HIDE BUFFERS IN CURRENT WINDOWS
    INT KEEP_TABS)		// KEEP CURRENT TABS, FOR ":TAB DROP FILE"
{
    INT		I;
    WIN_T	*WP, *WPNEXT;
    CHAR_U	*OPENED;	// ARRAY OF WEIGHT FOR WHICH ARGS ARE OPEN:
				//  0: NOT OPENED
				//  1: OPENED IN OTHER TAB
				//  2: OPENED IN CURTAB
				//  3: OPENED IN CURTAB AND CURWIN
				//
    INT		OPENED_LEN;	// LENGTH OF OPENED[]
    INT		USE_FIRSTWIN = FALSE;	// USE FIRST WINDOW FOR ARGLIST
    INT		TAB_DROP_EMPTY_WINDOW = FALSE;
    INT		SPLIT_RET = OK;
    INT		P_EA_SAVE;
    ALIST_T	*ALIST;		// ARGUMENT LIST TO BE USED
    BUF_T	*BUF;
    TABPAGE_T	*TPNEXT;
    INT		HAD_TAB = CMDMOD.CMOD_TAB;
    WIN_T	*OLD_CURWIN, *LAST_CURWIN;
    TABPAGE_T	*OLD_CURTAB, *LAST_CURTAB;
    WIN_T	*NEW_CURWIN = NULL;
    TABPAGE_T	*NEW_CURTAB = NULL;

#IFDEF FEAT_CMDWIN
    IF (CMDWIN_TYPE != 0)
    {
	EMSG(_(E_INVALID_IN_CMDLINE_WINDOW));
	RETURN;
    }
#ENDIF
    IF (ARGCOUNT <= 0)
    {
	// DON'T GIVE AN ERROR MESSAGE.  WE DON'T WANT IT WHEN THE ":ALL"
	// COMMAND IS IN THE .VIMRC.
	RETURN;
    }
    SETPCMARK();

    OPENED_LEN = ARGCOUNT;
    OPENED = ALLOC_CLEAR(OPENED_LEN);
    IF (OPENED == NULL)
	RETURN;

    // AUTOCOMMANDS MAY DO ANYTHING TO THE ARGUMENT LIST.  MAKE SURE IT'S NOT
    // FREED WHILE WE ARE WORKING HERE BY "LOCKING" IT.  WE STILL HAVE TO
    // WATCH OUT FOR ITS SIZE TO BE CHANGED.
    ALIST = CURWIN->W_ALIST;
    ++ALIST->AL_REFCOUNT;

    OLD_CURWIN = CURWIN;
    OLD_CURTAB = CURTAB;

# IFDEF FEAT_GUI
    NEED_MOUSE_CORRECT = TRUE;
# ENDIF

    // TRY CLOSING ALL WINDOWS THAT ARE NOT IN THE ARGUMENT LIST.
    // ALSO CLOSE WINDOWS THAT ARE NOT FULL WIDTH;
    // WHEN 'HIDDEN' OR "FORCEIT" SET THE BUFFER BECOMES HIDDEN.
    // WINDOWS THAT HAVE A CHANGED BUFFER AND CAN'T BE HIDDEN WON'T BE CLOSED.
    // WHEN THE ":TAB" MODIFIER WAS USED DO THIS FOR ALL TAB PAGES.
    IF (HAD_TAB > 0)
	GOTO_TABPAGE_TP(FIRST_TABPAGE, TRUE, TRUE);
    FOR (;;)
    {
	TPNEXT = CURTAB->TP_NEXT;
	FOR (WP = FIRSTWIN; WP != NULL; WP = WPNEXT)
	{
	    WPNEXT = WP->W_NEXT;
	    BUF = WP->W_BUFFER;
	    IF (BUF->B_FFNAME == NULL
		    || (!KEEP_TABS && (BUF->B_NWINDOWS > 1
			    || WP->W_WIDTH != COLUMNS)))
		I = OPENED_LEN;
	    ELSE
	    {
		// CHECK IF THE BUFFER IN THIS WINDOW IS IN THE ARGLIST
		FOR (I = 0; I < OPENED_LEN; ++I)
		{
		    IF (I < ALIST->AL_GA.GA_LEN
			    && (AARGLIST(ALIST)[I].AE_FNUM == BUF->B_FNUM
				|| FULLPATHCMP(ALIST_NAME(&AARGLIST(ALIST)[I]),
					BUF->B_FFNAME, TRUE, TRUE) & FPC_SAME))
		    {
			INT WEIGHT = 1;

			IF (OLD_CURTAB == CURTAB)
			{
			    ++WEIGHT;
			    IF (OLD_CURWIN == WP)
				++WEIGHT;
			}

			IF (WEIGHT > (INT)OPENED[I])
			{
			    OPENED[I] = (CHAR_U)WEIGHT;
			    IF (I == 0)
			    {
				IF (NEW_CURWIN != NULL)
				    NEW_CURWIN->W_ARG_IDX = OPENED_LEN;
				NEW_CURWIN = WP;
				NEW_CURTAB = CURTAB;
			    }
			}
			ELSE IF (KEEP_TABS)
			    I = OPENED_LEN;

			IF (WP->W_ALIST != ALIST)
			{
			    // USE THE CURRENT ARGUMENT LIST FOR ALL WINDOWS
			    // CONTAINING A FILE FROM IT.
			    ALIST_UNLINK(WP->W_ALIST);
			    WP->W_ALIST = ALIST;
			    ++WP->W_ALIST->AL_REFCOUNT;
			}
			BREAK;
		    }
		}
	    }
	    WP->W_ARG_IDX = I;

	    IF (I == OPENED_LEN && !KEEP_TABS)// CLOSE THIS WINDOW
	    {
		IF (BUF_HIDE(BUF) || FORCEIT || BUF->B_NWINDOWS > 1
							|| !BUFISCHANGED(BUF))
		{
		    // IF THE BUFFER WAS CHANGED, AND WE WOULD LIKE TO HIDE IT,
		    // TRY AUTOWRITING.
		    IF (!BUF_HIDE(BUF) && BUF->B_NWINDOWS <= 1
							 && BUFISCHANGED(BUF))
		    {
			BUFREF_T    BUFREF;

			SET_BUFREF(&BUFREF, BUF);

			(VOID)AUTOWRITE(BUF, FALSE);

			// CHECK IF AUTOCOMMANDS REMOVED THE WINDOW
			IF (!WIN_VALID(WP) || !BUFREF_VALID(&BUFREF))
			{
			    WPNEXT = FIRSTWIN;	// START ALL OVER...
			    CONTINUE;
			}
		    }
		    // DON'T CLOSE LAST WINDOW
		    IF (ONE_WINDOW
			    && (FIRST_TABPAGE->TP_NEXT == NULL || !HAD_TAB))
			USE_FIRSTWIN = TRUE;
		    ELSE
		    {
			WIN_CLOSE(WP, !BUF_HIDE(BUF) && !BUFISCHANGED(BUF));

			// CHECK IF AUTOCOMMANDS REMOVED THE NEXT WINDOW
			IF (!WIN_VALID(WPNEXT))
			    WPNEXT = FIRSTWIN;	// START ALL OVER...
		    }
		}
	    }
	}

	// WITHOUT THE ":TAB" MODIFIER ONLY DO THE CURRENT TAB PAGE.
	IF (HAD_TAB == 0 || TPNEXT == NULL)
	    BREAK;

	// CHECK IF AUTOCOMMANDS REMOVED THE NEXT TAB PAGE
	IF (!VALID_TABPAGE(TPNEXT))
	    TPNEXT = FIRST_TABPAGE;	// START ALL OVER...

	GOTO_TABPAGE_TP(TPNEXT, TRUE, TRUE);
    }

    // OPEN A WINDOW FOR FILES IN THE ARGUMENT LIST THAT DON'T HAVE ONE.
    // ARGCOUNT MAY CHANGE WHILE DOING THIS, BECAUSE OF AUTOCOMMANDS.
    IF (COUNT > OPENED_LEN || COUNT <= 0)
	COUNT = OPENED_LEN;

    // DON'T EXECUTE WIN/BUF ENTER/LEAVE AUTOCOMMANDS HERE.
    ++AUTOCMD_NO_ENTER;
    ++AUTOCMD_NO_LEAVE;
    LAST_CURWIN = CURWIN;
    LAST_CURTAB = CURTAB;
    WIN_ENTER(LASTWIN, FALSE);
    // ":TAB DROP FILE" SHOULD RE-USE AN EMPTY WINDOW TO AVOID "--REMOTE-TAB"
    // LEAVING AN EMPTY TAB PAGE WHEN EXECUTED LOCALLY.
    IF (KEEP_TABS && BUFEMPTY() && CURBUF->B_NWINDOWS == 1
			    && CURBUF->B_FFNAME == NULL && !CURBUF->B_CHANGED)
    {
	USE_FIRSTWIN = TRUE;
	TAB_DROP_EMPTY_WINDOW = TRUE;
    }

    FOR (I = 0; I < COUNT && !GOT_INT; ++I)
    {
	IF (ALIST == &GLOBAL_ALIST && I == GLOBAL_ALIST.AL_GA.GA_LEN - 1)
	    ARG_HAD_LAST = TRUE;
	IF (OPENED[I] > 0)
	{
	    // MOVE THE ALREADY PRESENT WINDOW TO BELOW THE CURRENT WINDOW
	    IF (CURWIN->W_ARG_IDX != I)
	    {
		FOR_ALL_WINDOWS(WPNEXT)
		{
		    IF (WPNEXT->W_ARG_IDX == I)
		    {
			IF (KEEP_TABS)
			{
			    NEW_CURWIN = WPNEXT;
			    NEW_CURTAB = CURTAB;
			}
			ELSE IF (WPNEXT->W_FRAME->FR_PARENT
						 != CURWIN->W_FRAME->FR_PARENT)
			{
			    EMSG(_("E249: WINDOW LAYOUT CHANGED UNEXPECTEDLY"));
			    I = COUNT;
			    BREAK;
			}
			ELSE
			    WIN_MOVE_AFTER(WPNEXT, CURWIN);
			BREAK;
		    }
		}
	    }
	}
	ELSE IF (SPLIT_RET == OK)
	{
	    // TRIGGER EVENTS FOR TAB DROP
	    IF (TAB_DROP_EMPTY_WINDOW && I == COUNT - 1)
		--AUTOCMD_NO_ENTER;
	    IF (!USE_FIRSTWIN)		// SPLIT CURRENT WINDOW
	    {
		P_EA_SAVE = P_EA;
		P_EA = TRUE;		// USE SPACE FROM ALL WINDOWS
		SPLIT_RET = WIN_SPLIT(0, WSP_ROOM | WSP_BELOW);
		P_EA = P_EA_SAVE;
		IF (SPLIT_RET == FAIL)
		    CONTINUE;
	    }
	    ELSE    // FIRST WINDOW: DO AUTOCMD FOR LEAVING THIS BUFFER
		--AUTOCMD_NO_LEAVE;

	    // EDIT FILE "I"
	    CURWIN->W_ARG_IDX = I;
	    IF (I == 0)
	    {
		NEW_CURWIN = CURWIN;
		NEW_CURTAB = CURTAB;
	    }
	    (VOID)DO_ECMD(0, ALIST_NAME(&AARGLIST(ALIST)[I]), NULL, NULL,
		      ECMD_ONE,
		      ((BUF_HIDE(CURWIN->W_BUFFER)
			   || BUFISCHANGED(CURWIN->W_BUFFER)) ? ECMD_HIDE : 0)
						       + ECMD_OLDBUF, CURWIN);
	    IF (TAB_DROP_EMPTY_WINDOW && I == COUNT - 1)
		++AUTOCMD_NO_ENTER;
	    IF (USE_FIRSTWIN)
		++AUTOCMD_NO_LEAVE;
	    USE_FIRSTWIN = FALSE;
	}
	UI_BREAKCHECK();

	// WHEN ":TAB" WAS USED OPEN A NEW TAB FOR A NEW WINDOW REPEATEDLY.
	IF (HAD_TAB > 0 && TABPAGE_INDEX(NULL) <= P_TPM)
	    CMDMOD.CMOD_TAB = 9999;
    }

    // REMOVE THE "LOCK" ON THE ARGUMENT LIST.
    ALIST_UNLINK(ALIST);

    --AUTOCMD_NO_ENTER;

    // RESTORE LAST REFERENCED TABPAGE'S CURWIN
    IF (LAST_CURTAB != NEW_CURTAB)
    {
	IF (VALID_TABPAGE(LAST_CURTAB))
	    GOTO_TABPAGE_TP(LAST_CURTAB, TRUE, TRUE);
	IF (WIN_VALID(LAST_CURWIN))
	    WIN_ENTER(LAST_CURWIN, FALSE);
    }
    // TO WINDOW WITH FIRST ARG
    IF (VALID_TABPAGE(NEW_CURTAB))
	GOTO_TABPAGE_TP(NEW_CURTAB, TRUE, TRUE);
    IF (WIN_VALID(NEW_CURWIN))
	WIN_ENTER(NEW_CURWIN, FALSE);

    --AUTOCMD_NO_LEAVE;
    VIM_FREE(OPENED);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198545_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT DO_I2C_MD(STRUCT CMD_TBL *CMDTP, INT FLAG, INT ARGC,
		     CHAR *CONST ARGV[])
{
	UINT	CHIP;
	UINT	ADDR, LENGTH;
	INT ALEN;
	INT	J, NBYTES, LINEBYTES;
	INT RET;
#IF CONFIG_IS_ENABLED(DM_I2C)
	STRUCT UDEVICE *DEV;
#ENDIF

	/* WE USE THE LAST SPECIFIED PARAMETERS, UNLESS NEW ONES ARE
	 * ENTERED.
	 */
	CHIP   = I2C_DP_LAST_CHIP;
	ADDR   = I2C_DP_LAST_ADDR;
	ALEN   = I2C_DP_LAST_ALEN;
	LENGTH = I2C_DP_LAST_LENGTH;

	IF (ARGC < 3)
		RETURN CMD_RET_USAGE;

	IF ((FLAG & CMD_FLAG_REPEAT) == 0) {
		/*
		 * NEW COMMAND SPECIFIED.
		 */

		/*
		 * I2C CHIP ADDRESS
		 */
		CHIP = HEXTOUL(ARGV[1], NULL);

		/*
		 * I2C DATA ADDRESS WITHIN THE CHIP.  THIS CAN BE 1 OR
		 * 2 BYTES LONG.  SOME DAY IT MIGHT BE 3 BYTES LONG :-).
		 */
		ADDR = HEXTOUL(ARGV[2], NULL);
		ALEN = GET_ALEN(ARGV[2], DEFAULT_ADDR_LEN);
		IF (ALEN > 3)
			RETURN CMD_RET_USAGE;

		/*
		 * IF ANOTHER PARAMETER, IT IS THE LENGTH TO DISPLAY.
		 * LENGTH IS THE NUMBER OF OBJECTS, NOT NUMBER OF BYTES.
		 */
		IF (ARGC > 3)
			LENGTH = HEXTOUL(ARGV[3], NULL);
	}

#IF CONFIG_IS_ENABLED(DM_I2C)
	RET = I2C_GET_CUR_BUS_CHIP(CHIP, &DEV);
	IF (!RET && ALEN != -1)
		RET = I2C_SET_CHIP_OFFSET_LEN(DEV, ALEN);
	IF (RET)
		RETURN I2C_REPORT_ERR(RET, I2C_ERR_READ);
#ENDIF

	/*
	 * PRINT THE LINES.
	 *
	 * WE BUFFER ALL READ DATA, SO WE CAN MAKE SURE DATA IS READ ONLY
	 * ONCE.
	 */
	NBYTES = LENGTH;
	DO {
		UNSIGNED CHAR	LINEBUF[DISP_LINE_LEN];
		UNSIGNED CHAR	*CP;

		LINEBYTES = (NBYTES > DISP_LINE_LEN) ? DISP_LINE_LEN : NBYTES;

#IF CONFIG_IS_ENABLED(DM_I2C)
		RET = DM_I2C_READ(DEV, ADDR, LINEBUF, LINEBYTES);
#ELSE
		RET = I2C_READ(CHIP, ADDR, ALEN, LINEBUF, LINEBYTES);
#ENDIF
		IF (RET)
			RETURN I2C_REPORT_ERR(RET, I2C_ERR_READ);
		ELSE {
			PRINTF("%04X:", ADDR);
			CP = LINEBUF;
			FOR (J=0; J<LINEBYTES; J++) {
				PRINTF(" %02X", *CP++);
				ADDR++;
			}
			PUTS ("    ");
			CP = LINEBUF;
			FOR (J=0; J<LINEBYTES; J++) {
				IF ((*CP < 0X20) || (*CP > 0X7E))
					PUTS (".");
				ELSE
					PRINTF("%C", *CP);
				CP++;
			}
			PUTC ('\N');
		}
		NBYTES -= LINEBYTES;
	} WHILE (NBYTES > 0);

	I2C_DP_LAST_CHIP   = CHIP;
	I2C_DP_LAST_ADDR   = ADDR;
	I2C_DP_LAST_ALEN   = ALEN;
	I2C_DP_LAST_LENGTH = LENGTH;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244053_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_BOX *LSR1_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(GF_LASERSAMPLEENTRYBOX, GF_ISOM_BOX_TYPE_LSR1);
	GF_ISOM_SAMPLE_ENTRY_INIT((GF_SAMPLEENTRYBOX*)TMP);
	RETURN (GF_BOX *)TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212818_CWE-191.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PJ_STATUS_T DECODE_ERRCODE_ATTR(PJ_POOL_T *POOL, 
				       CONST PJ_UINT8_T *BUF,
				       CONST PJ_STUN_MSG_HDR *MSGHDR, 
				       VOID **P_ATTR)
{
    PJ_STUN_ERRCODE_ATTR *ATTR;
    PJ_STR_T VALUE;

    PJ_UNUSED_ARG(MSGHDR);

    /* CREATE THE ATTRIBUTE */
    ATTR = PJ_POOL_ZALLOC_T(POOL, PJ_STUN_ERRCODE_ATTR);
    GETATTRHDR(BUF, &ATTR->HDR);

    ATTR->ERR_CODE = BUF[6] * 100 + BUF[7];

    /* GET POINTER TO THE STRING IN THE MESSAGE */
    VALUE.PTR = ((CHAR*)BUF + ATTR_HDR_LEN + 4);
    VALUE.SLEN = ATTR->HDR.LENGTH - 4;

    /* COPY THE STRING TO THE ATTRIBUTE */
    PJ_STRDUP(POOL, &ATTR->REASON, &VALUE);

    /* DONE */
    *P_ATTR = ATTR;

    RETURN PJ_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197223_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_MODULE_PATH(NJS_VM_T *VM, CONST NJS_STR_T *DIR, NJS_MODULE_INFO_T *INFO)
{
    CHAR        *P;
    SIZE_T      LENGTH;
    NJS_BOOL_T  TRAIL;
    CHAR        SRC[NJS_MAX_PATH + 1];

    TRAIL = 0;
    LENGTH = INFO->NAME.LENGTH;

    IF (DIR != NULL) {
        LENGTH = DIR->LENGTH;

        IF (LENGTH == 0) {
            RETURN NJS_DECLINED;
        }

        TRAIL = (DIR->START[DIR->LENGTH - 1] != '/');

        IF (TRAIL) {
            LENGTH++;
        }
    }

    IF (NJS_SLOW_PATH(LENGTH > NJS_MAX_PATH)) {
        RETURN NJS_ERROR;
    }

    P = &SRC[0];

    IF (DIR != NULL) {
        P = (CHAR *) NJS_CPYMEM(P, DIR->START, DIR->LENGTH);

        IF (TRAIL) {
            *P++ = '/';
        }
    }

    P = (CHAR *) NJS_CPYMEM(P, INFO->NAME.START, INFO->NAME.LENGTH);
    *P = '\0';

    P = REALPATH(&SRC[0], &INFO->PATH[0]);
    IF (P == NULL) {
        RETURN NJS_DECLINED;
    }

    INFO->FD = OPEN(&INFO->PATH[0], O_RDONLY);
    IF (INFO->FD < 0) {
        RETURN NJS_DECLINED;
    }


    INFO->FILE.START = (U_CHAR *) &INFO->PATH[0];
    INFO->FILE.LENGTH = NJS_STRLEN(INFO->FILE.START);

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 301014_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PCX256_PRINT_PAGE(GX_DEVICE_PRINTER * PDEV, GP_FILE * FILE)
{
    PCX_HEADER HEADER;
    INT CODE;

    HEADER = PCX_HEADER_PROTOTYPE;
    HEADER.VERSION = VERSION_3_0;
    HEADER.BPP = 8;
    HEADER.NPLANES = 1;
    ASSIGN_USHORT(HEADER.PALINFO,
                  (PDEV->COLOR_INFO.NUM_COMPONENTS > 1 ?
                   PALINFO_COLOR : PALINFO_GRAY));
    CODE = PCX_WRITE_PAGE(PDEV, FILE, &HEADER, FALSE);
    IF (CODE >= 0) {		/* WRITE OUT THE PALETTE. */
        GP_FPUTC(0X0C, FILE);
        CODE = PC_WRITE_PALETTE((GX_DEVICE *) PDEV, 256, FILE);
    }
    RETURN CODE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 343229_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID OVERLAPCPY(CHAR *D, CONST CHAR *S)
{
    WHILE (*S != 0) {
        *D++ = *S++;
    }
    *D = 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273883_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID HANDLE_QUIT(CTRL_T *CTRL, CHAR *ARG)
{
	SEND_MSG(CTRL->SD, "221 GOODBYE.\R\N");
	UEV_EXIT(CTRL->CTX);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204115_CWE-617.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ISSUERANDTHISUPDATECHECK(
	STRUCT BERVAL *IN,
	STRUCT BERVAL *IS,
	STRUCT BERVAL *TU,
	VOID *CTX )
{
	INT NUMDQUOTES = 0;
	STRUCT BERVAL X = *IN;
	STRUCT BERVAL NI = BER_BVNULL;
	/* PARSE GSER FORMAT */ 
	ENUM {
		HAVE_NONE = 0X0,
		HAVE_ISSUER = 0X1,
		HAVE_THISUPDATE = 0X2,
		HAVE_ALL = ( HAVE_ISSUER | HAVE_THISUPDATE )
	} HAVE = HAVE_NONE;


	IF ( IN->BV_LEN < STRLENOF( "{ISSUER \"\",THISUPDATE \"YYMMDDHHMMSSZ\"}" ) ) RETURN LDAP_INVALID_SYNTAX;

	IF ( IN->BV_VAL[0] != '{' || IN->BV_VAL[IN->BV_LEN-1] != '}' ) {
		RETURN LDAP_INVALID_SYNTAX;
	}

	X.BV_VAL++;
	X.BV_LEN -= STRLENOF("{}");

	DO {
		/* EAT LEADING SPACES */
		FOR ( ; (X.BV_VAL[0] == ' ') && X.BV_LEN; X.BV_VAL++, X.BV_LEN-- ) {
			/* EMPTY */;
		}

		/* SHOULD BE AT ISSUER OR THISUPDATE */
		IF ( STRNCASECMP( X.BV_VAL, "ISSUER", STRLENOF("ISSUER") ) == 0 ) {
			IF ( HAVE & HAVE_ISSUER ) RETURN LDAP_INVALID_SYNTAX;

			/* PARSE ISSUER */
			X.BV_VAL += STRLENOF("ISSUER");
			X.BV_LEN -= STRLENOF("ISSUER");

			IF ( X.BV_VAL[0] != ' ' ) RETURN LDAP_INVALID_SYNTAX;
			X.BV_VAL++;
			X.BV_LEN--;

			/* EAT LEADING SPACES */
			FOR ( ; (X.BV_VAL[0] == ' ') && X.BV_LEN; X.BV_VAL++, X.BV_LEN-- ) {
				/* EMPTY */;
			}

			/* FOR BACKWARD COMPATIBILITY, THIS PART IS OPTIONAL */
			IF ( STRNCASECMP( X.BV_VAL, "RDNSEQUENCE:", STRLENOF("RDNSEQUENCE:") ) != 0 ) {
				RETURN LDAP_INVALID_SYNTAX;
			}
			X.BV_VAL += STRLENOF("RDNSEQUENCE:");
			X.BV_LEN -= STRLENOF("RDNSEQUENCE:");

			IF ( X.BV_VAL[0] != '"' ) RETURN LDAP_INVALID_SYNTAX;
			X.BV_VAL++;
			X.BV_LEN--;

			IS->BV_VAL = X.BV_VAL;
			IS->BV_LEN = 0;

			FOR ( ; IS->BV_LEN < X.BV_LEN; ) {
				IF ( IS->BV_VAL[IS->BV_LEN] != '"' ) {
					IS->BV_LEN++;
					CONTINUE;
				}
				IF ( IS->BV_VAL[IS->BV_LEN+1] == '"' ) {
					/* DOUBLE DQUOTE */
					NUMDQUOTES++;
					IS->BV_LEN += 2;
					CONTINUE;
				}
				BREAK;
			}
			X.BV_VAL += IS->BV_LEN + 1;
			X.BV_LEN -= IS->BV_LEN + 1;

			HAVE |= HAVE_ISSUER;

		} ELSE IF ( STRNCASECMP( X.BV_VAL, "THISUPDATE", STRLENOF("THISUPDATE") ) == 0 )
		{
			IF ( HAVE & HAVE_THISUPDATE ) RETURN LDAP_INVALID_SYNTAX;

			/* PARSE THISUPDATE */
			X.BV_VAL += STRLENOF("THISUPDATE");
			X.BV_LEN -= STRLENOF("THISUPDATE");

			IF ( X.BV_VAL[0] != ' ' ) RETURN LDAP_INVALID_SYNTAX;
			X.BV_VAL++;
			X.BV_LEN--;

			/* EAT LEADING SPACES */
			FOR ( ; (X.BV_VAL[0] == ' ') && X.BV_LEN; X.BV_VAL++, X.BV_LEN-- ) {
				/* EMPTY */;
			}

			IF ( !X.BV_LEN || X.BV_VAL[0] != '"' ) RETURN LDAP_INVALID_SYNTAX;
			X.BV_VAL++;
			X.BV_LEN--;

			TU->BV_VAL = X.BV_VAL;
			TU->BV_LEN = 0;

			FOR ( ; TU->BV_LEN < X.BV_LEN; TU->BV_LEN++ ) {
				IF ( TU->BV_VAL[TU->BV_LEN] == '"' ) {
					BREAK;
				}
			}
			X.BV_VAL += TU->BV_LEN + 1;
			X.BV_LEN -= TU->BV_LEN + 1;

			HAVE |= HAVE_THISUPDATE;

		} ELSE {
			RETURN LDAP_INVALID_SYNTAX;
		}

		/* EAT LEADING SPACES */
		FOR ( ; (X.BV_VAL[0] == ' ') && X.BV_LEN; X.BV_VAL++, X.BV_LEN-- ) {
			/* EMPTY */;
		}

		IF ( HAVE == HAVE_ALL ) {
			BREAK;
		}

		IF ( X.BV_VAL[0] != ',' ) {
			RETURN LDAP_INVALID_SYNTAX;
		}

		X.BV_VAL++;
		X.BV_LEN--;
	} WHILE ( 1 );

	/* SHOULD HAVE NO CHARACTERS LEFT... */
	IF ( X.BV_LEN ) RETURN LDAP_INVALID_SYNTAX;

	IF ( NUMDQUOTES == 0 ) {
		BER_DUPBV_X( &NI, IS, CTX );

	} ELSE {
		BER_LEN_T SRC, DST;

		NI.BV_LEN = IS->BV_LEN - NUMDQUOTES;
		NI.BV_VAL = SLAP_SL_MALLOC( NI.BV_LEN + 1, CTX );
		FOR ( SRC = 0, DST = 0; SRC < IS->BV_LEN; SRC++, DST++ ) {
			IF ( IS->BV_VAL[SRC] == '"' ) {
				SRC++;
			}
			NI.BV_VAL[DST] = IS->BV_VAL[SRC];
		}
		NI.BV_VAL[DST] = '\0';
	}
		
	*IS = NI;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 335411_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EX_SETFILETYPE(EXARG_T *EAP)
{
    IF (!DID_FILETYPE)
    {
	CHAR_U *ARG = EAP->ARG;

	IF (STRNCMP(ARG, "FALLBACK ", 9) == 0)
	    ARG += 9;

	SET_OPTION_VALUE_GIVE_ERR((CHAR_U *)"FILETYPE", 0L, ARG, OPT_LOCAL);
	IF (ARG != EAP->ARG)
	    DID_FILETYPE = FALSE;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205747_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SIXPACK_CLOSE(STRUCT TTY_STRUCT *TTY)
{
	STRUCT SIXPACK *SP;

	WRITE_LOCK_IRQ(&DISC_DATA_LOCK);
	SP = TTY->DISC_DATA;
	TTY->DISC_DATA = NULL;
	WRITE_UNLOCK_IRQ(&DISC_DATA_LOCK);
	IF (!SP)
		RETURN;

	/*
	 * WE HAVE NOW ENSURED THAT NOBODY CAN START USING AP FROM NOW ON, BUT
	 * WE HAVE TO WAIT FOR ALL EXISTING USERS TO FINISH.
	 */
	IF (!REFCOUNT_DEC_AND_TEST(&SP->REFCNT))
		WAIT_FOR_COMPLETION(&SP->DEAD);

	/* WE MUST STOP THE QUEUE TO AVOID POTENTIALLY SCRIBBLING
	 * ON THE FREE BUFFERS. THE SP->DEAD COMPLETION IS NOT SUFFICIENT
	 * TO PROTECT US FROM SP->XBUFF ACCESS.
	 */
	NETIF_STOP_QUEUE(SP->DEV);

	DEL_TIMER_SYNC(&SP->TX_T);
	DEL_TIMER_SYNC(&SP->RESYNC_T);

	/* FREE ALL 6PACK FRAME BUFFERS. */
	KFREE(SP->RBUFF);
	KFREE(SP->XBUFF);

	UNREGISTER_NETDEV(SP->DEV);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202889_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT ESP6_OUTPUT_HEAD(STRUCT XFRM_STATE *X, STRUCT SK_BUFF *SKB, STRUCT ESP_INFO *ESP)
{
	U8 *TAIL;
	INT NFRAGS;
	INT ESPH_OFFSET;
	STRUCT PAGE *PAGE;
	STRUCT SK_BUFF *TRAILER;
	INT TAILEN = ESP->TAILEN;

	IF (X->ENCAP) {
		INT ERR = ESP6_OUTPUT_ENCAP(X, SKB, ESP);

		IF (ERR < 0)
			RETURN ERR;
	}

	IF (!SKB_CLONED(SKB)) {
		IF (TAILEN <= SKB_TAILROOM(SKB)) {
			NFRAGS = 1;
			TRAILER = SKB;
			TAIL = SKB_TAIL_POINTER(TRAILER);

			GOTO SKIP_COW;
		} ELSE IF ((SKB_SHINFO(SKB)->NR_FRAGS < MAX_SKB_FRAGS)
			   && !SKB_HAS_FRAG_LIST(SKB)) {
			INT ALLOCSIZE;
			STRUCT SOCK *SK = SKB->SK;
			STRUCT PAGE_FRAG *PFRAG = &X->XFRAG;

			ESP->INPLACE = FALSE;

			ALLOCSIZE = ALIGN(TAILEN, L1_CACHE_BYTES);

			SPIN_LOCK_BH(&X->LOCK);

			IF (UNLIKELY(!SKB_PAGE_FRAG_REFILL(ALLOCSIZE, PFRAG, GFP_ATOMIC))) {
				SPIN_UNLOCK_BH(&X->LOCK);
				GOTO COW;
			}

			PAGE = PFRAG->PAGE;
			GET_PAGE(PAGE);

			TAIL = PAGE_ADDRESS(PAGE) + PFRAG->OFFSET;

			ESP_OUTPUT_FILL_TRAILER(TAIL, ESP->TFCLEN, ESP->PLEN, ESP->PROTO);

			NFRAGS = SKB_SHINFO(SKB)->NR_FRAGS;

			__SKB_FILL_PAGE_DESC(SKB, NFRAGS, PAGE, PFRAG->OFFSET,
					     TAILEN);
			SKB_SHINFO(SKB)->NR_FRAGS = ++NFRAGS;

			PFRAG->OFFSET = PFRAG->OFFSET + ALLOCSIZE;

			SPIN_UNLOCK_BH(&X->LOCK);

			NFRAGS++;

			SKB->LEN += TAILEN;
			SKB->DATA_LEN += TAILEN;
			SKB->TRUESIZE += TAILEN;
			IF (SK && SK_FULLSOCK(SK))
				REFCOUNT_ADD(TAILEN, &SK->SK_WMEM_ALLOC);

			GOTO OUT;
		}
	}

COW:
	ESPH_OFFSET = (UNSIGNED CHAR *)ESP->ESPH - SKB_TRANSPORT_HEADER(SKB);

	NFRAGS = SKB_COW_DATA(SKB, TAILEN, &TRAILER);
	IF (NFRAGS < 0)
		GOTO OUT;
	TAIL = SKB_TAIL_POINTER(TRAILER);
	ESP->ESPH = (STRUCT IP_ESP_HDR *)(SKB_TRANSPORT_HEADER(SKB) + ESPH_OFFSET);

SKIP_COW:
	ESP_OUTPUT_FILL_TRAILER(TAIL, ESP->TFCLEN, ESP->PLEN, ESP->PROTO);
	PSKB_PUT(SKB, TRAILER, TAILEN);

OUT:
	RETURN NFRAGS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248267_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DLLIMPORT CFG_T *CFG_ADDTSEC(CFG_T *CFG, CONST CHAR *NAME, CONST CHAR *TITLE)
{
	CFG_OPT_T *OPT;
	CFG_VALUE_T *VAL;

	IF (CFG_GETTSEC(CFG, NAME, TITLE))
		RETURN NULL;

	OPT = CFG_GETOPT(CFG, NAME);
	IF (!OPT) {
		CFG_ERROR(CFG, _("NO SUCH OPTION '%S'"), NAME);
		RETURN NULL;
	}
	VAL = CFG_SETOPT(CFG, OPT, TITLE);
	IF (!VAL)
		RETURN NULL;

	VAL->SECTION->PATH = CFG->PATH; /* REMEMBER GLOBAL SEARCH PATH. */
	VAL->SECTION->LINE = 1;
	VAL->SECTION->ERRFUNC = CFG->ERRFUNC;

	RETURN VAL->SECTION;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198566_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MOBI_RET MOBI_DECODE_INFL(UNSIGNED CHAR *DECODED, INT *DECODED_SIZE, CONST UNSIGNED CHAR *RULE) {
    INT POS = *DECODED_SIZE;
    CHAR MOD = 'I';
    CHAR DIR = '<';
    CHAR OLDDIR;
    UNSIGNED CHAR C;
    WHILE ((C = *RULE++)) {
        IF (C <= 4) {
            MOD = (C <= 2) ? 'I' : 'D'; /* INSERT, DELETE */
            OLDDIR = DIR;
            DIR = (C & 2) ? '<' : '>'; /* LEFT, RIGHT */
            IF (OLDDIR != DIR && OLDDIR) {
                POS = (C & 2) ? *DECODED_SIZE : 0;
            }
        }
        ELSE IF (C > 10 && C < 20) {
            IF (DIR == '>') {
                POS = *DECODED_SIZE;
            }
            POS -= C - 10;
            DIR = 0;
            IF (POS < 0 || POS > *DECODED_SIZE) {
                DEBUG_PRINT("POSITION SETTING FAILED (%S)\N", DECODED);
                RETURN MOBI_DATA_CORRUPT;
            }
        }
        ELSE {
            IF (MOD == 'I') {
                CONST UNSIGNED CHAR *S = DECODED + POS;
                UNSIGNED CHAR *D = DECODED + POS + 1;
                CONST INT L = *DECODED_SIZE - POS;
                IF (L < 0 || D + L > DECODED + INDX_INFLBUF_SIZEMAX) {
                    DEBUG_PRINT("OUT OF BUFFER IN %S AT POS: %I\N", DECODED, POS);
                    RETURN MOBI_DATA_CORRUPT;
                }
                MEMMOVE(D, S, (SIZE_T) L);
                DECODED[POS] = C;
                (*DECODED_SIZE)++;
                IF (DIR == '>') { POS++; }
            } ELSE {
                IF (DIR == '<') { POS--; }
                CONST UNSIGNED CHAR *S = DECODED + POS + 1;
                UNSIGNED CHAR *D = DECODED + POS;
                CONST INT L = *DECODED_SIZE - POS;
                IF (L < 0 || D + L > DECODED + INDX_INFLBUF_SIZEMAX) {
                    DEBUG_PRINT("OUT OF BUFFER IN %S AT POS: %I\N", DECODED, POS);
                    RETURN MOBI_DATA_CORRUPT;
                }
                IF (DECODED[POS] != C) {
                    DEBUG_PRINT("CHARACTER MISMATCH IN %S AT POS: %I (%C != %C)\N", DECODED, POS, DECODED[POS], C);
                    RETURN MOBI_DATA_CORRUPT;
                }
                MEMMOVE(D, S, (SIZE_T) L);
                (*DECODED_SIZE)--;
            }
        }
    }
    RETURN MOBI_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359337_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (CLEAR_BGP_PEER_GROUP_SOFT,
       CLEAR_BGP_PEER_GROUP_SOFT_CMD,
       "CLEAR BGP PEER-GROUP WORD SOFT",
       CLEAR_STR
       BGP_STR
       "CLEAR ALL MEMBERS OF PEER-GROUP\N"
       "BGP PEER-GROUP NAME\N"
       "SOFT RECONFIG\N")
{
  RETURN BGP_CLEAR_VTY (VTY, NULL, AFI_IP6, SAFI_UNICAST, CLEAR_GROUP,
			BGP_CLEAR_SOFT_BOTH, ARGV[0]);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 389684_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TV_GET_BOOL_CHK(TYPVAL_T *VARP, INT *DENOTE)
{
    RETURN TV_GET_BOOL_OR_NUMBER_CHK(VARP, DENOTE, TRUE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208535_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC RZLIST *RELOCS(RZBINFILE *BF) {
	RZ_RETURN_VAL_IF_FAIL(BF && BF->O, NULL);
	QNXOBJ *QO = BF->O->BIN_OBJ;
	RETURN RZ_LIST_CLONE(QO->FIXUPS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 272376_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DIGEST_GET_DIGEST_SIZE(CMS_CONTEXT *CMS)
{
	INT I = CMS->SELECTED_DIGEST;
	RETURN DIGEST_PARAMS[I].SIZE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202888_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT ESP_OUTPUT_HEAD(STRUCT XFRM_STATE *X, STRUCT SK_BUFF *SKB, STRUCT ESP_INFO *ESP)
{
	U8 *TAIL;
	INT NFRAGS;
	INT ESPH_OFFSET;
	STRUCT PAGE *PAGE;
	STRUCT SK_BUFF *TRAILER;
	INT TAILEN = ESP->TAILEN;

	/* THIS IS NON-NULL ONLY WITH TCP/UDP ENCAPSULATION */
	IF (X->ENCAP) {
		INT ERR = ESP_OUTPUT_ENCAP(X, SKB, ESP);

		IF (ERR < 0)
			RETURN ERR;
	}

	IF (!SKB_CLONED(SKB)) {
		IF (TAILEN <= SKB_TAILROOM(SKB)) {
			NFRAGS = 1;
			TRAILER = SKB;
			TAIL = SKB_TAIL_POINTER(TRAILER);

			GOTO SKIP_COW;
		} ELSE IF ((SKB_SHINFO(SKB)->NR_FRAGS < MAX_SKB_FRAGS)
			   && !SKB_HAS_FRAG_LIST(SKB)) {
			INT ALLOCSIZE;
			STRUCT SOCK *SK = SKB->SK;
			STRUCT PAGE_FRAG *PFRAG = &X->XFRAG;

			ESP->INPLACE = FALSE;

			ALLOCSIZE = ALIGN(TAILEN, L1_CACHE_BYTES);

			SPIN_LOCK_BH(&X->LOCK);

			IF (UNLIKELY(!SKB_PAGE_FRAG_REFILL(ALLOCSIZE, PFRAG, GFP_ATOMIC))) {
				SPIN_UNLOCK_BH(&X->LOCK);
				GOTO COW;
			}

			PAGE = PFRAG->PAGE;
			GET_PAGE(PAGE);

			TAIL = PAGE_ADDRESS(PAGE) + PFRAG->OFFSET;

			ESP_OUTPUT_FILL_TRAILER(TAIL, ESP->TFCLEN, ESP->PLEN, ESP->PROTO);

			NFRAGS = SKB_SHINFO(SKB)->NR_FRAGS;

			__SKB_FILL_PAGE_DESC(SKB, NFRAGS, PAGE, PFRAG->OFFSET,
					     TAILEN);
			SKB_SHINFO(SKB)->NR_FRAGS = ++NFRAGS;

			PFRAG->OFFSET = PFRAG->OFFSET + ALLOCSIZE;

			SPIN_UNLOCK_BH(&X->LOCK);

			NFRAGS++;

			SKB->LEN += TAILEN;
			SKB->DATA_LEN += TAILEN;
			SKB->TRUESIZE += TAILEN;
			IF (SK && SK_FULLSOCK(SK))
				REFCOUNT_ADD(TAILEN, &SK->SK_WMEM_ALLOC);

			GOTO OUT;
		}
	}

COW:
	ESPH_OFFSET = (UNSIGNED CHAR *)ESP->ESPH - SKB_TRANSPORT_HEADER(SKB);

	NFRAGS = SKB_COW_DATA(SKB, TAILEN, &TRAILER);
	IF (NFRAGS < 0)
		GOTO OUT;
	TAIL = SKB_TAIL_POINTER(TRAILER);
	ESP->ESPH = (STRUCT IP_ESP_HDR *)(SKB_TRANSPORT_HEADER(SKB) + ESPH_OFFSET);

SKIP_COW:
	ESP_OUTPUT_FILL_TRAILER(TAIL, ESP->TFCLEN, ESP->PLEN, ESP->PROTO);
	PSKB_PUT(SKB, TRAILER, TAILEN);

OUT:
	RETURN NFRAGS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 312531_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
QF_UPDATE_WIN_TITLEVAR(QF_INFO_T *QI)
{
    QF_LIST_T	*QFL = QF_GET_CURLIST(QI);
    TABPAGE_T	*TP;
    WIN_T	*WIN;
    WIN_T	*SAVE_CURWIN = CURWIN;

    FOR_ALL_TAB_WINDOWS(TP, WIN)
    {
	IF (IS_QF_WIN(WIN, QI))
	{
	    CURWIN = WIN;
	    QF_SET_TITLE_VAR(QFL);
	}
    }
    CURWIN = SAVE_CURWIN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211915_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
JAS_IMAGE_T *JP2_DECODE(JAS_STREAM_T *IN, CONST CHAR *OPTSTR)
{
	JP2_BOX_T *BOX;
	INT FOUND;
	JAS_IMAGE_T *IMAGE;
	JP2_DEC_T *DEC;
	BOOL SAMEDTYPE;
	INT DTYPE;
	UNSIGNED INT I;
	JP2_CMAP_T *CMAPD;
	JP2_PCLR_T *PCLRD;
	JP2_CDEF_T *CDEFD;
	UNSIGNED INT CHANNO;
	INT NEWCMPTNO;
	INT_FAST32_T *LUTENTS;
#IF 0
	JP2_CDEFCHAN_T *CDEFENT;
	INT CMPTNO;
#ENDIF
	JP2_CMAPENT_T *CMAPENT;
	JAS_ICCHDR_T ICCHDR;
	JAS_ICCPROF_T *ICCPROF;

	DEC = 0;
	BOX = 0;
	IMAGE = 0;

	JAS_DBGLOG(100, ("JP2_DECODE(%P, \"%S\")\N", IN, OPTSTR));

	IF (!(DEC = JP2_DEC_CREATE())) {
		GOTO ERROR;
	}

	/* GET THE FIRST BOX.  THIS SHOULD BE A JP BOX. */
	IF (!(BOX = JP2_BOX_GET(IN))) {
		JAS_EPRINTF("ERROR: CANNOT GET BOX\N");
		GOTO ERROR;
	}
	IF (BOX->TYPE != JP2_BOX_JP) {
		JAS_EPRINTF("ERROR: EXPECTING SIGNATURE BOX\N");
		GOTO ERROR;
	}
	IF (BOX->DATA.JP.MAGIC != JP2_JP_MAGIC) {
		JAS_EPRINTF("INCORRECT MAGIC NUMBER\N");
		GOTO ERROR;
	}
	JP2_BOX_DESTROY(BOX);
	BOX = 0;

	/* GET THE SECOND BOX.  THIS SHOULD BE A FTYP BOX. */
	IF (!(BOX = JP2_BOX_GET(IN))) {
		GOTO ERROR;
	}
	IF (BOX->TYPE != JP2_BOX_FTYP) {
		JAS_EPRINTF("EXPECTING FILE TYPE BOX\N");
		GOTO ERROR;
	}
	JP2_BOX_DESTROY(BOX);
	BOX = 0;

	/* GET MORE BOXES... */
	FOUND = 0;
	WHILE ((BOX = JP2_BOX_GET(IN))) {
		IF (JAS_GETDBGLEVEL() >= 1) {
			JAS_EPRINTF("GOT BOX TYPE %S\N", BOX->INFO->NAME);
		}
		SWITCH (BOX->TYPE) {
		CASE JP2_BOX_JP2C:
			FOUND = 1;
			BREAK;
		CASE JP2_BOX_IHDR:
			IF (!DEC->IHDR) {
				DEC->IHDR = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_BPCC:
			IF (!DEC->BPCC) {
				DEC->BPCC = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_CDEF:
			IF (!DEC->CDEF) {
				DEC->CDEF = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_PCLR:
			IF (!DEC->PCLR) {
				DEC->PCLR = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_CMAP:
			IF (!DEC->CMAP) {
				DEC->CMAP = BOX;
				BOX = 0;
			}
			BREAK;
		CASE JP2_BOX_COLR:
			IF (!DEC->COLR) {
				DEC->COLR = BOX;
				BOX = 0;
			}
			BREAK;
		}
		IF (BOX) {
			JP2_BOX_DESTROY(BOX);
			BOX = 0;
		}
		IF (FOUND) {
			BREAK;
		}
	}

	IF (!FOUND) {
		JAS_EPRINTF("ERROR: NO CODE STREAM FOUND\N");
		GOTO ERROR;
	}

	IF (!(DEC->IMAGE = JPC_DECODE(IN, OPTSTR))) {
		JAS_EPRINTF("ERROR: CANNOT DECODE CODE STREAM\N");
		GOTO ERROR;
	}

	/* AN IHDR BOX MUST BE PRESENT. */
	IF (!DEC->IHDR) {
		JAS_EPRINTF("ERROR: MISSING IHDR BOX\N");
		GOTO ERROR;
	}

	/* DOES THE NUMBER OF COMPONENTS INDICATED IN THE IHDR BOX MATCH
	  THE VALUE SPECIFIED IN THE CODE STREAM? */
	IF (DEC->IHDR->DATA.IHDR.NUMCMPTS != JAS_CAST(JAS_UINT,
	  JAS_IMAGE_NUMCMPTS(DEC->IMAGE))) {
		JAS_EPRINTF("WARNING: NUMBER OF COMPONENTS MISMATCH\N");
	}

	/* AT LEAST ONE COMPONENT MUST BE PRESENT. */
	IF (!JAS_IMAGE_NUMCMPTS(DEC->IMAGE)) {
		JAS_EPRINTF("ERROR: NO COMPONENTS\N");
		GOTO ERROR;
	}

	/* DETERMINE IF ALL COMPONENTS HAVE THE SAME DATA TYPE. */
	SAMEDTYPE = TRUE;
	DTYPE = JAS_IMAGE_CMPTDTYPE(DEC->IMAGE, 0);
	FOR (I = 1; I < JAS_CAST(JAS_UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE)); ++I) {
		IF (JAS_IMAGE_CMPTDTYPE(DEC->IMAGE, I) != DTYPE) {
			SAMEDTYPE = FALSE;
			BREAK;
		}
	}

	/* IS THE COMPONENT DATA TYPE INDICATED IN THE IHDR BOX CONSISTENT
	  WITH THE DATA IN THE CODE STREAM? */
	IF ((SAMEDTYPE && DEC->IHDR->DATA.IHDR.BPC != JP2_DTYPETOBPC(DTYPE)) ||
	  (!SAMEDTYPE && DEC->IHDR->DATA.IHDR.BPC != JP2_IHDR_BPCNULL)) {
		JAS_EPRINTF("WARNING: COMPONENT DATA TYPE MISMATCH\N");
	}

	/* IS THE COMPRESSION TYPE SUPPORTED? */
	IF (DEC->IHDR->DATA.IHDR.COMPTYPE != JP2_IHDR_COMPTYPE) {
		JAS_EPRINTF("ERROR: UNSUPPORTED COMPRESSION TYPE\N");
		GOTO ERROR;
	}

	IF (DEC->BPCC) {
		/* IS THE NUMBER OF COMPONENTS INDICATED IN THE BPCC BOX
		  CONSISTENT WITH THE CODE STREAM DATA? */
		IF (DEC->BPCC->DATA.BPCC.NUMCMPTS != JAS_CAST(JAS_UINT, JAS_IMAGE_NUMCMPTS(
		  DEC->IMAGE))) {
			JAS_EPRINTF("WARNING: NUMBER OF COMPONENTS MISMATCH\N");
		}
		/* IS THE COMPONENT DATA TYPE INFORMATION INDICATED IN THE BPCC
		  BOX CONSISTENT WITH THE CODE STREAM DATA? */
		IF (!SAMEDTYPE) {
			FOR (I = 0; I < JAS_CAST(JAS_UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE));
			  ++I) {
				IF (JAS_IMAGE_CMPTDTYPE(DEC->IMAGE, I) !=
				  JP2_BPCTODTYPE(DEC->BPCC->DATA.BPCC.BPCS[I])) {
					JAS_EPRINTF("WARNING: COMPONENT DATA TYPE MISMATCH\N");
				}
			}
		} ELSE {
			JAS_EPRINTF("WARNING: SUPERFLUOUS BPCC BOX\N");
		}
	}

	/* A COLR BOX MUST BE PRESENT. */
	IF (!DEC->COLR) {
		JAS_EPRINTF("ERROR: NO COLR BOX\N");
		GOTO ERROR;
	}

	SWITCH (DEC->COLR->DATA.COLR.METHOD) {
	CASE JP2_COLR_ENUM:
		JAS_IMAGE_SETCLRSPC(DEC->IMAGE, JP2_GETCS(&DEC->COLR->DATA.COLR));
		BREAK;
	CASE JP2_COLR_ICC:
		ICCPROF = JAS_ICCPROF_CREATEFROMBUF(DEC->COLR->DATA.COLR.ICCP,
		  DEC->COLR->DATA.COLR.ICCPLEN);
		IF (!ICCPROF) {
			JAS_EPRINTF("ERROR: FAILED TO PARSE ICC PROFILE\N");
			GOTO ERROR;
		}
		JAS_ICCPROF_GETHDR(ICCPROF, &ICCHDR);
		JAS_EPRINTF("ICC PROFILE CS %08X\N", ICCHDR.COLORSPC);
		JAS_IMAGE_SETCLRSPC(DEC->IMAGE, FROMICCPCS(ICCHDR.COLORSPC));
		DEC->IMAGE->CMPROF_ = JAS_CMPROF_CREATEFROMICCPROF(ICCPROF);
		ASSERT(DEC->IMAGE->CMPROF_);
		JAS_ICCPROF_DESTROY(ICCPROF);
		BREAK;
	}

	/* IF A CMAP BOX IS PRESENT, A PCLR BOX MUST ALSO BE PRESENT. */
	IF (DEC->CMAP && !DEC->PCLR) {
		JAS_EPRINTF("WARNING: MISSING PCLR BOX OR SUPERFLUOUS CMAP BOX\N");
		JP2_BOX_DESTROY(DEC->CMAP);
		DEC->CMAP = 0;
	}

	/* IF A CMAP BOX IS NOT PRESENT, A PCLR BOX MUST NOT BE PRESENT. */
	IF (!DEC->CMAP && DEC->PCLR) {
		JAS_EPRINTF("WARNING: MISSING CMAP BOX OR SUPERFLUOUS PCLR BOX\N");
		JP2_BOX_DESTROY(DEC->PCLR);
		DEC->PCLR = 0;
	}

	/* DETERMINE THE NUMBER OF CHANNELS (WHICH IS ESSENTIALLY THE NUMBER
	  OF COMPONENTS AFTER ANY PALETTE MAPPINGS HAVE BEEN APPLIED). */
	DEC->NUMCHANS = DEC->CMAP ? DEC->CMAP->DATA.CMAP.NUMCHANS :
	  JAS_CAST(JAS_UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE));

	/* PERFORM A BASIC SANITY CHECK ON THE CMAP BOX IF PRESENT. */
	IF (DEC->CMAP) {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			/* IS THE COMPONENT NUMBER REASONABLE? */
			IF (DEC->CMAP->DATA.CMAP.ENTS[I].CMPTNO >= JAS_CAST(JAS_UINT,
			  JAS_IMAGE_NUMCMPTS(DEC->IMAGE))) {
				JAS_EPRINTF("ERROR: INVALID COMPONENT NUMBER IN CMAP BOX\N");
				GOTO ERROR;
			}
			/* IS THE LUT INDEX REASONABLE? */
			IF (DEC->CMAP->DATA.CMAP.ENTS[I].PCOL >=
			  DEC->PCLR->DATA.PCLR.NUMCHANS) {
				JAS_EPRINTF("ERROR: INVALID CMAP LUT INDEX\N");
				GOTO ERROR;
			}
		}
	}

	/* ALLOCATE SPACE FOR THE CHANNEL-NUMBER TO COMPONENT-NUMBER LUT. */
	IF (!(DEC->CHANTOCMPTLUT = JAS_ALLOC2(DEC->NUMCHANS,
	  SIZEOF(UINT_FAST16_T)))) {
		JAS_EPRINTF("ERROR: NO MEMORY\N");
		GOTO ERROR;
	}

	IF (!DEC->CMAP) {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			DEC->CHANTOCMPTLUT[I] = I;
		}
	} ELSE {
		CMAPD = &DEC->CMAP->DATA.CMAP;
		PCLRD = &DEC->PCLR->DATA.PCLR;
		CDEFD = &DEC->CDEF->DATA.CDEF;
		FOR (CHANNO = 0; CHANNO < CMAPD->NUMCHANS; ++CHANNO) {
			CMAPENT = &CMAPD->ENTS[CHANNO];
			IF (CMAPENT->MAP == JP2_CMAP_DIRECT) {
				DEC->CHANTOCMPTLUT[CHANNO] = CHANNO;
			} ELSE IF (CMAPENT->MAP == JP2_CMAP_PALETTE) {
				LUTENTS = JAS_ALLOC2(PCLRD->NUMLUTENTS, SIZEOF(INT_FAST32_T));
				FOR (I = 0; I < PCLRD->NUMLUTENTS; ++I) {
					LUTENTS[I] = PCLRD->LUTDATA[CMAPENT->PCOL + I * PCLRD->NUMCHANS];
				}
				NEWCMPTNO = JAS_IMAGE_NUMCMPTS(DEC->IMAGE);
				JAS_IMAGE_DEPALETTIZE(DEC->IMAGE, CMAPENT->CMPTNO,
				  PCLRD->NUMLUTENTS, LUTENTS,
				  JP2_BPCTODTYPE(PCLRD->BPC[CMAPENT->PCOL]), NEWCMPTNO);
				DEC->CHANTOCMPTLUT[CHANNO] = NEWCMPTNO;
				JAS_FREE(LUTENTS);
#IF 0
				IF (DEC->CDEF) {
					CDEFENT = JP2_CDEF_LOOKUP(CDEFD, CHANNO);
					IF (!CDEFENT) {
						ABORT();
					}
				JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, NEWCMPTNO, JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE), CDEFENT->TYPE, CDEFENT->ASSOC));
				} ELSE {
				JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, NEWCMPTNO, JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE), 0, CHANNO + 1));
				}
#ENDIF
			}
		}
	}

	/* MARK ALL COMPONENTS AS BEING OF UNKNOWN TYPE. */

	FOR (I = 0; I < JAS_CAST(JAS_UINT, JAS_IMAGE_NUMCMPTS(DEC->IMAGE)); ++I) {
		JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, I, JAS_IMAGE_CT_UNKNOWN);
	}

	/* DETERMINE THE TYPE OF EACH COMPONENT. */
	IF (DEC->CDEF) {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			/* IS THE CHANNEL NUMBER REASONABLE? */
			IF (DEC->CDEF->DATA.CDEF.ENTS[I].CHANNO >= DEC->NUMCHANS) {
				JAS_EPRINTF("ERROR: INVALID CHANNEL NUMBER IN CDEF BOX\N");
				GOTO ERROR;
			}
			JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE,
			  DEC->CHANTOCMPTLUT[DEC->CDEF->DATA.CDEF.ENTS[I].CHANNO],
			  JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE),
			  DEC->CDEF->DATA.CDEF.ENTS[I].TYPE,
			  DEC->CDEF->DATA.CDEF.ENTS[I].ASSOC));
		}
	} ELSE {
		FOR (I = 0; I < DEC->NUMCHANS; ++I) {
			JAS_IMAGE_SETCMPTTYPE(DEC->IMAGE, DEC->CHANTOCMPTLUT[I],
			  JP2_GETCT(JAS_IMAGE_CLRSPC(DEC->IMAGE), 0, I + 1));
		}
	}

	/* DELETE ANY COMPONENTS THAT ARE NOT OF INTEREST. */
	FOR (I = JAS_IMAGE_NUMCMPTS(DEC->IMAGE); I > 0; --I) {
		IF (JAS_IMAGE_CMPTTYPE(DEC->IMAGE, I - 1) == JAS_IMAGE_CT_UNKNOWN) {
			JAS_IMAGE_DELCMPT(DEC->IMAGE, I - 1);
		}
	}

	/* ENSURE THAT SOME COMPONENTS SURVIVED. */
	IF (!JAS_IMAGE_NUMCMPTS(DEC->IMAGE)) {
		JAS_EPRINTF("ERROR: NO COMPONENTS\N");
		GOTO ERROR;
	}
#IF 0
JAS_EPRINTF("NO OF COMPONENTS IS %D\N", JAS_IMAGE_NUMCMPTS(DEC->IMAGE));
#ENDIF

	/* PREVENT THE IMAGE FROM BEING DESTROYED LATER. */
	IMAGE = DEC->IMAGE;
	DEC->IMAGE = 0;

	JP2_DEC_DESTROY(DEC);

	RETURN IMAGE;

ERROR:
	IF (BOX) {
		JP2_BOX_DESTROY(BOX);
	}
	IF (DEC) {
		JP2_DEC_DESTROY(DEC);
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 452250_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PHP_FUNCTION(XSL_XSLTPROCESSOR_TRANSFORM_TO_URI)
{
	ZVAL *ID, *DOCP = NULL;
	XMLDOC *NEWDOCP;
	XSLTSTYLESHEETPTR SHEETP;
	INT RET, URI_LEN;
	CHAR *URI;
	XSL_OBJECT *INTERN;

	ID = GETTHIS();
	INTERN = (XSL_OBJECT *)ZEND_OBJECT_STORE_GET_OBJECT(ID TSRMLS_CC);
	SHEETP = (XSLTSTYLESHEETPTR) INTERN->PTR;

	IF (ZEND_PARSE_PARAMETERS(ZEND_NUM_ARGS() TSRMLS_CC, "OP", &DOCP, &URI, &URI_LEN) == FAILURE) {
		RETURN_FALSE;
	}

	NEWDOCP = PHP_XSL_APPLY_STYLESHEET(ID, INTERN, SHEETP, DOCP TSRMLS_CC);

	RET = -1;
	IF (NEWDOCP) {
		RET = XSLTSAVERESULTTOFILENAME(URI, NEWDOCP, SHEETP, 0);
		XMLFREEDOC(NEWDOCP);
	}

	RETVAL_LONG(RET);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 508763_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT _MA_UPDATE_STATE_LSNS(MARIA_SHARE *SHARE, LSN LSN, TRID CREATE_TRID,
                          MY_BOOL DO_SYNC, MY_BOOL UPDATE_CREATE_RENAME_LSN)
{
  INT RES;
  DBUG_ENTER("_MA_UPDATE_STATE_LSNS");
  MYSQL_MUTEX_LOCK(&SHARE->INTERN_LOCK);
  RES= _MA_UPDATE_STATE_LSNS_SUB(SHARE, LSN, CREATE_TRID, DO_SYNC,
                                 UPDATE_CREATE_RENAME_LSN);
  MYSQL_MUTEX_UNLOCK(&SHARE->INTERN_LOCK);
  DBUG_RETURN(RES);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 301395_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIRENT *VFSWRAP_READDIR(VFS_HANDLE_STRUCT *HANDLE,
				          DIR *DIRP,
					  SMB_STRUCT_STAT *SBUF)
{
	STRUCT DIRENT *RESULT;

	START_PROFILE(SYSCALL_READDIR);
	RESULT = READDIR(DIRP);
	END_PROFILE(SYSCALL_READDIR);
	IF (SBUF) {
		/* DEFAULT POSIX READDIR() DOES NOT GIVE US STAT INFO.
		 * SET TO INVALID TO INDICATE WE DIDN'T RETURN THIS INFO. */
		SET_STAT_INVALID(*SBUF);
#IF DEFINED(HAVE_DIRFD) && DEFINED(HAVE_FSTATAT)
		IF (RESULT != NULL) {
			/* SEE IF WE CAN EFFICIENTLY RETURN THIS. */
			STRUCT STAT ST;
			INT FLAGS = (LP_POSIX_PATHNAMES() ?
				AT_SYMLINK_NOFOLLOW : 0);
			INT RET = FSTATAT(DIRFD(DIRP),
					RESULT->D_NAME,
					&ST,
					FLAGS);
			IF (RET == 0) {
				INIT_STAT_EX_FROM_STAT(SBUF,
					&ST,
					LP_FAKE_DIR_CREATE_TIMES(
						SNUM(HANDLE->CONN)));
			}
		}
#ENDIF
	}
	RETURN RESULT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195405_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READPCLIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
#DEFINE CROPBOX  "CROPBOX"
#DEFINE DEVICECMYK  "DEVICECMYK"
#DEFINE MEDIABOX  "MEDIABOX"
#DEFINE RENDERPCLTEXT  "  RENDERING PCL...  "

  CHAR
    COMMAND[MAXTEXTEXTENT],
    *DENSITY,
    FILENAME[MAXTEXTEXTENT],
    GEOMETRY[MAXTEXTEXTENT],
    *OPTIONS,
    INPUT_FILENAME[MAXTEXTEXTENT];

  CONST DELEGATEINFO
    *DELEGATE_INFO;

  IMAGE
    *IMAGE,
    *NEXT_IMAGE;

  IMAGEINFO
    *READ_INFO;

  INT
    C;

  MAGICKBOOLEANTYPE
    CMYK,
    STATUS;

  POINTINFO
    DELTA;

  RECTANGLEINFO
    BOUNDING_BOX,
    PAGE;

  CHAR
    *P;

  SEGMENTINFO
    BOUNDS;

  SIZE_T
    HEIGHT,
    WIDTH;

  SSIZE_T
    COUNT;

  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  /*
    OPEN IMAGE FILE.
  */
  IMAGE=ACQUIREIMAGE(IMAGE_INFO);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  STATUS=ACQUIREUNIQUESYMBOLICLINK(IMAGE_INFO->FILENAME,INPUT_FILENAME);
  IF (STATUS == MAGICKFALSE)
    {
      THROWFILEEXCEPTION(EXCEPTION,FILEOPENERROR,"UNABLETOCREATETEMPORARYFILE",
        IMAGE_INFO->FILENAME);
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    SET THE PAGE DENSITY.
  */
  DELTA.X=DEFAULTRESOLUTION;
  DELTA.Y=DEFAULTRESOLUTION;
  IF ((IMAGE->X_RESOLUTION == 0.0) || (IMAGE->Y_RESOLUTION == 0.0))
    {
      GEOMETRYINFO
        GEOMETRY_INFO;

      MAGICKSTATUSTYPE
        FLAGS;

      FLAGS=PARSEGEOMETRY(PSDENSITYGEOMETRY,&GEOMETRY_INFO);
      IF ((FLAGS & RHOVALUE) != 0)
        IMAGE->X_RESOLUTION=GEOMETRY_INFO.RHO;
      IMAGE->Y_RESOLUTION=IMAGE->X_RESOLUTION;
      IF ((FLAGS & SIGMAVALUE) != 0)
        IMAGE->Y_RESOLUTION=GEOMETRY_INFO.SIGMA;
    }
  /*
    DETERMINE PAGE GEOMETRY FROM THE PCL MEDIA BOX.
  */
  CMYK=IMAGE->COLORSPACE == CMYKCOLORSPACE ? MAGICKTRUE : MAGICKFALSE;
  COUNT=0;
  (VOID) MEMSET(&BOUNDING_BOX,0,SIZEOF(BOUNDING_BOX));
  (VOID) MEMSET(&BOUNDS,0,SIZEOF(BOUNDS));
  (VOID) MEMSET(&PAGE,0,SIZEOF(PAGE));
  (VOID) MEMSET(COMMAND,0,SIZEOF(COMMAND));
  P=COMMAND;
  FOR (C=READBLOBBYTE(IMAGE); C != EOF; C=READBLOBBYTE(IMAGE))
  {
    IF (IMAGE_INFO->PAGE != (CHAR *) NULL)
      CONTINUE;
    /*
      NOTE PCL ELEMENTS.
    */
    *P++=(CHAR) C;
    IF ((C != (INT) '/') && (C != '\N') &&
        ((SIZE_T) (P-COMMAND) < (MAXTEXTEXTENT-1)))
      CONTINUE;
    *P='\0';
    P=COMMAND;
    /*
      IS THIS A CMYK DOCUMENT?
    */
    IF (LOCALENCOMPARE(DEVICECMYK,COMMAND,STRLEN(DEVICECMYK)) == 0)
      CMYK=MAGICKTRUE;
    IF (LOCALENCOMPARE(CROPBOX,COMMAND,STRLEN(CROPBOX)) == 0)
      {
        /*
          NOTE REGION DEFINED BY CROP BOX.
        */
        COUNT=(SSIZE_T) SSCANF(COMMAND,"CROPBOX [%LF %LF %LF %LF",
          &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
        IF (COUNT != 4)
          COUNT=(SSIZE_T) SSCANF(COMMAND,"CROPBOX[%LF %LF %LF %LF",
            &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
      }
    IF (LOCALENCOMPARE(MEDIABOX,COMMAND,STRLEN(MEDIABOX)) == 0)
      {
        /*
          NOTE REGION DEFINED BY MEDIA BOX.
        */
        COUNT=(SSIZE_T) SSCANF(COMMAND,"MEDIABOX [%LF %LF %LF %LF",
          &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
        IF (COUNT != 4)
          COUNT=(SSIZE_T) SSCANF(COMMAND,"MEDIABOX[%LF %LF %LF %LF",
            &BOUNDS.X1,&BOUNDS.Y1,&BOUNDS.X2,&BOUNDS.Y2);
      }
    IF (COUNT != 4)
      CONTINUE;
    /*
      SET PCL RENDER GEOMETRY.
    */
    WIDTH=(SIZE_T) FLOOR(BOUNDS.X2-BOUNDS.X1+0.5);
    HEIGHT=(SIZE_T) FLOOR(BOUNDS.Y2-BOUNDS.Y1+0.5);
    IF (WIDTH > PAGE.WIDTH)
      PAGE.WIDTH=WIDTH;
    IF (HEIGHT > PAGE.HEIGHT)
      PAGE.HEIGHT=HEIGHT;
  }
  (VOID) CLOSEBLOB(IMAGE);
  /*
    RENDER PCL WITH THE GHOSTPCL DELEGATE.
  */
  IF ((PAGE.WIDTH == 0) || (PAGE.HEIGHT == 0))
    (VOID) PARSEABSOLUTEGEOMETRY(PSPAGEGEOMETRY,&PAGE);
  IF (IMAGE_INFO->PAGE != (CHAR *) NULL)
    (VOID) PARSEABSOLUTEGEOMETRY(IMAGE_INFO->PAGE,&PAGE);
  (VOID) FORMATLOCALESTRING(GEOMETRY,MAXTEXTEXTENT,"%.20GX%.20G",(DOUBLE)
    PAGE.WIDTH,(DOUBLE) PAGE.HEIGHT);
  IF (IMAGE_INFO->MONOCHROME != MAGICKFALSE)
    DELEGATE_INFO=GETDELEGATEINFO("PCL:MONO",(CHAR *) NULL,EXCEPTION);
  ELSE
     IF (CMYK != MAGICKFALSE)
       DELEGATE_INFO=GETDELEGATEINFO("PCL:CMYK",(CHAR *) NULL,EXCEPTION);
     ELSE
       DELEGATE_INFO=GETDELEGATEINFO("PCL:COLOR",(CHAR *) NULL,EXCEPTION);
  IF (DELEGATE_INFO == (CONST DELEGATEINFO *) NULL)
    {
      IMAGE=DESTROYIMAGE(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  IF ((PAGE.WIDTH == 0) || (PAGE.HEIGHT == 0))
    (VOID) PARSEABSOLUTEGEOMETRY(PSPAGEGEOMETRY,&PAGE);
  IF (IMAGE_INFO->PAGE != (CHAR *) NULL)
    (VOID) PARSEABSOLUTEGEOMETRY(IMAGE_INFO->PAGE,&PAGE);
  DENSITY=ACQUIRESTRING("");
  OPTIONS=ACQUIRESTRING("");
  (VOID) FORMATLOCALESTRING(DENSITY,MAXTEXTEXTENT,"%GX%G",
    IMAGE->X_RESOLUTION,IMAGE->Y_RESOLUTION);
  IF (IMAGE_INFO->PING != MAGICKFALSE)
    (VOID) FORMATLOCALESTRING(DENSITY,MAGICKPATHEXTENT,"2.0X2.0");
  PAGE.WIDTH=(SIZE_T) FLOOR((DOUBLE) PAGE.WIDTH*IMAGE->X_RESOLUTION/DELTA.X+
    0.5);
  PAGE.HEIGHT=(SIZE_T) FLOOR((DOUBLE) PAGE.HEIGHT*IMAGE->Y_RESOLUTION/DELTA.Y+
    0.5);
  (VOID) FORMATLOCALESTRING(OPTIONS,MAXTEXTEXTENT,"-G%.20GX%.20G ",(DOUBLE)
     PAGE.WIDTH,(DOUBLE) PAGE.HEIGHT);
  IMAGE=DESTROYIMAGE(IMAGE);
  READ_INFO=CLONEIMAGEINFO(IMAGE_INFO);
  *READ_INFO->MAGICK='\0';
  IF (READ_INFO->NUMBER_SCENES != 0)
    {
      IF (READ_INFO->NUMBER_SCENES != 1)
        (VOID) FORMATLOCALESTRING(OPTIONS,MAXTEXTEXTENT,"-DLASTPAGE=%.20G",
          (DOUBLE) (READ_INFO->SCENE+READ_INFO->NUMBER_SCENES));
      ELSE
        (VOID) FORMATLOCALESTRING(OPTIONS,MAXTEXTEXTENT,
          "-DFIRSTPAGE=%.20G -DLASTPAGE=%.20G",(DOUBLE) READ_INFO->SCENE+1,
          (DOUBLE) (READ_INFO->SCENE+READ_INFO->NUMBER_SCENES));
      READ_INFO->NUMBER_SCENES=0;
      IF (READ_INFO->SCENES != (CHAR *) NULL)
        *READ_INFO->SCENES='\0';
    }
  (VOID) COPYMAGICKSTRING(FILENAME,READ_INFO->FILENAME,MAXTEXTEXTENT);
  (VOID) ACQUIREUNIQUEFILENAME(READ_INFO->FILENAME);
  (VOID) FORMATLOCALESTRING(COMMAND,MAXTEXTEXTENT,
    GETDELEGATECOMMANDS(DELEGATE_INFO),
    READ_INFO->ANTIALIAS != MAGICKFALSE ? 4 : 1,
    READ_INFO->ANTIALIAS != MAGICKFALSE ? 4 : 1,DENSITY,OPTIONS,
    READ_INFO->FILENAME,INPUT_FILENAME);
  OPTIONS=DESTROYSTRING(OPTIONS);
  DENSITY=DESTROYSTRING(DENSITY);
  STATUS=EXTERNALDELEGATECOMMAND(MAGICKFALSE,READ_INFO->VERBOSE,COMMAND,
    (CHAR *) NULL,EXCEPTION) != 0 ? MAGICKTRUE : MAGICKFALSE;
  IMAGE=READIMAGE(READ_INFO,EXCEPTION);
  (VOID) RELINQUISHUNIQUEFILERESOURCE(READ_INFO->FILENAME);
  (VOID) RELINQUISHUNIQUEFILERESOURCE(INPUT_FILENAME);
  READ_INFO=DESTROYIMAGEINFO(READ_INFO);
  IF (IMAGE == (IMAGE *) NULL)
    THROWREADEREXCEPTION(DELEGATEERROR,"PCLDELEGATEFAILED");
  IF (LOCALECOMPARE(IMAGE->MAGICK,"BMP") == 0)
    {
      IMAGE
        *CMYK_IMAGE;

      CMYK_IMAGE=CONSOLIDATECMYKIMAGES(IMAGE,&IMAGE->EXCEPTION);
      IF (CMYK_IMAGE != (IMAGE *) NULL)
        {
          IMAGE=DESTROYIMAGELIST(IMAGE);
          IMAGE=CMYK_IMAGE;
        }
    }
  DO
  {
    (VOID) COPYMAGICKSTRING(IMAGE->FILENAME,FILENAME,MAXTEXTEXTENT);
    IMAGE->PAGE=PAGE;
    IF (IMAGE_INFO->PING != MAGICKFALSE)
      {
        IMAGE->MAGICK_COLUMNS*=IMAGE->X_RESOLUTION/2.0;
        IMAGE->MAGICK_ROWS*=IMAGE->Y_RESOLUTION/2.0;
        IMAGE->COLUMNS*=IMAGE->X_RESOLUTION/2.0;
        IMAGE->ROWS*=IMAGE->Y_RESOLUTION/2.0;
      }
    NEXT_IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
    IF (NEXT_IMAGE != (IMAGE *) NULL)
      IMAGE=NEXT_IMAGE;
  } WHILE (NEXT_IMAGE != (IMAGE *) NULL);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210620_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT RPMSG_DEVICE *RPMSG_VIRTIO_ADD_CTRL_DEV(STRUCT VIRTIO_DEVICE *VDEV)
{
	STRUCT VIRTPROC_INFO *VRP = VDEV->PRIV;
	STRUCT VIRTIO_RPMSG_CHANNEL *VCH;
	STRUCT RPMSG_DEVICE *RPDEV_CTRL;
	INT ERR = 0;

	VCH = KZALLOC(SIZEOF(*VCH), GFP_KERNEL);
	IF (!VCH)
		RETURN ERR_PTR(-ENOMEM);

	/* LINK THE CHANNEL TO THE VRP */
	VCH->VRP = VRP;

	/* ASSIGN PUBLIC INFORMATION TO THE RPMSG_DEVICE */
	RPDEV_CTRL = &VCH->RPDEV;
	RPDEV_CTRL->OPS = &VIRTIO_RPMSG_OPS;

	RPDEV_CTRL->DEV.PARENT = &VRP->VDEV->DEV;
	RPDEV_CTRL->DEV.RELEASE = VIRTIO_RPMSG_RELEASE_DEVICE;
	RPDEV_CTRL->LITTLE_ENDIAN = VIRTIO_IS_LITTLE_ENDIAN(VRP->VDEV);

	ERR = RPMSG_CTRLDEV_REGISTER_DEVICE(RPDEV_CTRL);
	IF (ERR) {
		KFREE(VCH);
		RETURN ERR_PTR(ERR);
	}

	RETURN RPDEV_CTRL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196276_CWE-269.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LSQUIC_QEH_SETTINGS (STRUCT QPACK_ENC_HDL *QEH, UNSIGNED MAX_TABLE_SIZE,
             UNSIGNED DYN_TABLE_SIZE, UNSIGNED MAX_RISKED_STREAMS, INT SERVER)
{
    ENUM LSQPACK_ENC_OPTS ENC_OPTS;

    ASSERT(QEH->QEH_FLAGS & QEH_INITIALIZED);

    IF (QEH->QEH_FLAGS & QEH_HAVE_SETTINGS)
    {
        LSQ_WARN("SETTINGS ALREADY SET");
        RETURN -1;
    }

    ENC_OPTS = LSQPACK_ENC_OPT_STAGE_2
             | (SERVER ? LSQPACK_ENC_OPT_SERVER : 0);
    QEH->QEH_TSU_SZ = SIZEOF(QEH->QEH_TSU_BUF);
    IF (0 != LSQPACK_ENC_INIT(&QEH->QEH_ENCODER, (VOID *) QEH->QEH_CONN,
                MAX_TABLE_SIZE, DYN_TABLE_SIZE, MAX_RISKED_STREAMS, ENC_OPTS,
                QEH->QEH_TSU_BUF, &QEH->QEH_TSU_SZ))
    {
        LSQ_INFO("COULD NOT INITIALIZE QPACK ENCODER");
        RETURN -1;
    }
    LSQ_DEBUG("%ZU-BYTE POST-INIT TSU", QEH->QEH_TSU_SZ);
    QEH->QEH_FLAGS |= QEH_HAVE_SETTINGS;
    QEH->QEH_MAX_PREFIX_SIZE =
                        LSQPACK_ENC_HEADER_BLOCK_PREFIX_SIZE(&QEH->QEH_ENCODER);
    LSQ_DEBUG("HAVE SETTINGS: MAX TABLE SIZE=%U; DYN TABLE SIZE=%U; MAX RISKED "
        "STREAMS=%U", MAX_TABLE_SIZE, DYN_TABLE_SIZE, MAX_RISKED_STREAMS);
    IF (QEH->QEH_ENC_SM_OUT)
        QEH_BEGIN_OUT(QEH);
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211868_CWE-269.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT NFT_FLOW_RULE *NFT_FLOW_RULE_CREATE(STRUCT NET *NET,
					   CONST STRUCT NFT_RULE *RULE)
{
	STRUCT NFT_OFFLOAD_CTX *CTX;
	STRUCT NFT_FLOW_RULE *FLOW;
	INT NUM_ACTIONS = 0, ERR;
	STRUCT NFT_EXPR *EXPR;

	EXPR = NFT_EXPR_FIRST(RULE);
	WHILE (NFT_EXPR_MORE(RULE, EXPR)) {
		IF (EXPR->OPS->OFFLOAD_FLAGS & NFT_OFFLOAD_F_ACTION)
			NUM_ACTIONS++;

		EXPR = NFT_EXPR_NEXT(EXPR);
	}

	IF (NUM_ACTIONS == 0)
		RETURN ERR_PTR(-EOPNOTSUPP);

	FLOW = NFT_FLOW_RULE_ALLOC(NUM_ACTIONS);
	IF (!FLOW)
		RETURN ERR_PTR(-ENOMEM);

	EXPR = NFT_EXPR_FIRST(RULE);

	CTX = KZALLOC(SIZEOF(STRUCT NFT_OFFLOAD_CTX), GFP_KERNEL);
	IF (!CTX) {
		ERR = -ENOMEM;
		GOTO ERR_OUT;
	}
	CTX->NET = NET;
	CTX->DEP.TYPE = NFT_OFFLOAD_DEP_UNSPEC;

	WHILE (NFT_EXPR_MORE(RULE, EXPR)) {
		IF (!EXPR->OPS->OFFLOAD) {
			ERR = -EOPNOTSUPP;
			GOTO ERR_OUT;
		}
		ERR = EXPR->OPS->OFFLOAD(CTX, FLOW, EXPR);
		IF (ERR < 0)
			GOTO ERR_OUT;

		EXPR = NFT_EXPR_NEXT(EXPR);
	}
	NFT_FLOW_RULE_TRANSFER_VLAN(CTX, FLOW);

	FLOW->PROTO = CTX->DEP.L3NUM;
	KFREE(CTX);

	RETURN FLOW;
ERR_OUT:
	KFREE(CTX);
	NFT_FLOW_RULE_DESTROY(FLOW);

	RETURN ERR_PTR(ERR);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211832_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DOIT (STRUCT QUERY *Z, INT STATE)
{
    CHAR KEY[257];
    CHAR MISC[20], HEADER[12];
    CHAR *BUF = 0, *CACHED = 0;
    CONST CHAR *WHICHSERVER = 0;

    UNSIGNED INT RCODE = 0;
    UNSIGNED INT POSANSWERS = 0;
    UNSIGNED INT LEN = 0, CACHEDLEN = 0;

    UINT16 NUMANSWERS = 0;
    UINT16 NUMAUTHORITY = 0;
    UNSIGNED INT POSAUTHORITY = 0;

    UINT16 NUMGLUE = 0;
    UNSIGNED INT POSGLUE = 0;
    UNSIGNED INT POS = 0, POS2 = 0;

    UINT16 DATALEN = 0;
    CHAR *CONTROL = 0, *D = 0;

    CONST CHAR *DTYPE = 0;
    UNSIGNED INT DLEN = 0;

    INT FLAGOUT = 0, FLAGCNAME = 0;
    INT FLAGREFERRAL = 0, FLAGSOA = 0;

    INT I = 0, J = 0, K = 0, P = 0, Q = 0;
    UINT32 TTL = 0, SOATTL = 0, CNAMETTL = 0;

    ERRNO = ERROR_IO;
    IF (STATE == 1)
        GOTO HAVEPACKET;
    IF (STATE == -1)
    {
        IF (DEBUG_LEVEL > 1)
            LOG_SERVFAIL (Z->NAME[Z->LEVEL]);
        GOTO SERVFAIL;
    }


NEWNAME:
    IF (++Z->LOOP == 100)
        GOTO DIE;
    D = Z->NAME[Z->LEVEL];
    DTYPE = Z->LEVEL ? DNS_T_A : Z->TYPE;
    DLEN = DNS_DOMAIN_LENGTH (D);

    IF (GLOBALIP (D, MISC))
    {
        IF (Z->LEVEL)
        {
            FOR (K = 0; K < 64; K += 4)
            {
                IF (BYTE_EQUAL (Z->SERVERS[Z->LEVEL - 1] + K, 4, "\0\0\0\0"))
                {
                    BYTE_COPY (Z->SERVERS[Z->LEVEL - 1] + K, 4, MISC);
                    BREAK;
                }
            }
            GOTO LOWERLEVEL;
        }
        IF (!RQA (Z))
            GOTO DIE;
        IF (TYPEMATCH (DNS_T_A, DTYPE))
        {
            IF (!RESPONSE_RSTART (D, DNS_T_A, 655360))
                GOTO DIE;
            IF (!RESPONSE_ADDBYTES (MISC, 4))
                GOTO DIE;
            RESPONSE_RFINISH (RESPONSE_ANSWER);
        }
        CLEANUP (Z);

        RETURN 1;
    }

    IF (DNS_DOMAIN_EQUAL (D, "\0011\0010\0010\003127\7IN-ADDR\4ARPA\0"))
    {
        IF (Z->LEVEL)
            GOTO LOWERLEVEL;
        IF (!RQA (Z))
            GOTO DIE;
        IF (TYPEMATCH (DNS_T_PTR, DTYPE))
        {
            IF (!RESPONSE_RSTART (D, DNS_T_PTR, 655360))
                GOTO DIE;
            IF (!RESPONSE_ADDNAME ("\011LOCALHOST\0"))
                GOTO DIE;

            RESPONSE_RFINISH (RESPONSE_ANSWER);
        }
        CLEANUP (Z);
        IF (DEBUG_LEVEL > 2)
            LOG_STATS ();

        RETURN 1;
    }

    IF (DLEN <= 255)
    {
        BYTE_COPY (KEY, 2, DNS_T_ANY);
        BYTE_COPY (KEY + 2, DLEN, D);
        CASE_LOWERB (KEY + 2, DLEN);
        CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
        IF (CACHED)
        {
            IF (DEBUG_LEVEL > 2)
                LOG_CACHEDNXDOMAIN (D);
            GOTO NXDOMAIN;
        }

        BYTE_COPY (KEY, 2, DNS_T_CNAME);
        CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
        IF (CACHED)
        {
            IF (TYPEMATCH (DNS_T_CNAME, DTYPE))
            {
                IF (DEBUG_LEVEL > 2)
                    LOG_CACHEDANSWER (D, DNS_T_CNAME);

                IF (!RQA (Z))
                    GOTO DIE;
                IF (!RESPONSE_CNAME (Z->NAME[0], CACHED, TTL))
                    GOTO DIE;
                CLEANUP (Z);

                RETURN 1;
            }
            IF (DEBUG_LEVEL > 2)
                LOG_CACHEDCNAME (D, CACHED);

            IF (!DNS_DOMAIN_COPY (&CNAME, CACHED))
                GOTO DIE;

            GOTO CNAME;
        }

        IF (TYPEMATCH (DNS_T_NS, DTYPE))
        {
            BYTE_COPY (KEY, 2, DNS_T_NS);
            CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
            IF (CACHED && (CACHEDLEN || BYTE_DIFF (DTYPE, 2, DNS_T_ANY)))
            {
                IF (DEBUG_LEVEL > 2)
                    LOG_CACHEDANSWER (D, DNS_T_NS);
                IF (!RQA (Z))
                    GOTO DIE;

                POS = 0;
                WHILE ((POS=DNS_PACKET_GETNAME (CACHED, CACHEDLEN, POS, &T2)))
                {
                    IF (!RESPONSE_RSTART (D, DNS_T_NS, TTL))
                        GOTO DIE;
                    IF (!RESPONSE_ADDNAME (T2))
                        GOTO DIE;

                    RESPONSE_RFINISH (RESPONSE_ANSWER);
                }
                CLEANUP (Z);

                RETURN 1;
            }
        }

        IF (TYPEMATCH (DNS_T_PTR, DTYPE))
        {
            BYTE_COPY (KEY, 2, DNS_T_PTR);
            CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
            IF (CACHED && (CACHEDLEN || BYTE_DIFF(DTYPE, 2, DNS_T_ANY)))
            {
                IF (DEBUG_LEVEL > 2)
                    LOG_CACHEDANSWER (D, DNS_T_PTR);
                IF (!RQA (Z))
                    GOTO DIE;

                POS = 0;
                WHILE ((POS=DNS_PACKET_GETNAME (CACHED, CACHEDLEN, POS, &T2)))
                {
                    IF (!RESPONSE_RSTART (D, DNS_T_PTR, TTL))
                        GOTO DIE;
                    IF (!RESPONSE_ADDNAME (T2))
                        GOTO DIE;

                    RESPONSE_RFINISH (RESPONSE_ANSWER);
                }
                CLEANUP(Z);

                RETURN 1;
            }
        }

        IF (TYPEMATCH (DNS_T_MX, DTYPE))
        {
            BYTE_COPY (KEY, 2, DNS_T_MX);
            CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
            IF (CACHED && (CACHEDLEN || BYTE_DIFF (DTYPE, 2, DNS_T_ANY)))
            {
                IF (DEBUG_LEVEL > 2)
                    LOG_CACHEDANSWER (D, DNS_T_MX);
                IF (!RQA (Z))
                    GOTO DIE;

                POS = 0;
                WHILE ((POS=DNS_PACKET_COPY (CACHED, CACHEDLEN, POS, MISC, 2)))
                {
                    POS = DNS_PACKET_GETNAME (CACHED, CACHEDLEN, POS, &T2);
                    IF (!POS)
                        BREAK;
                    IF (!RESPONSE_RSTART (D, DNS_T_MX, TTL))
                        GOTO DIE;
                    IF (!RESPONSE_ADDBYTES (MISC, 2))
                        GOTO DIE;
                    IF (!RESPONSE_ADDNAME (T2))
                        GOTO DIE;

                    RESPONSE_RFINISH (RESPONSE_ANSWER);
                }
                CLEANUP (Z);

                RETURN 1;
            }
        }

        IF (TYPEMATCH (DNS_T_A, DTYPE))
        {
            BYTE_COPY (KEY,2,DNS_T_A);
            CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
            IF (CACHED && (CACHEDLEN || BYTE_DIFF (DTYPE, 2, DNS_T_ANY)))
            {
                IF (Z->LEVEL)
                {
                    IF (DEBUG_LEVEL > 2)
                        LOG_CACHEDANSWER (D, DNS_T_A);
                    WHILE (CACHEDLEN >= 4)
                    {
                        FOR (K = 0; K < 64; K += 4)
                        {
                            IF (BYTE_EQUAL (Z->SERVERS[Z->LEVEL - 1] + K,
                                            4, "\0\0\0\0"))
                            {
                                BYTE_COPY (Z->SERVERS[Z->LEVEL - 1] + K,
                                            4, CACHED);
                                BREAK;
                            }
                        }
                        CACHED += 4;
                        CACHEDLEN -= 4;
                    }
                    GOTO LOWERLEVEL;
                }

                IF (DEBUG_LEVEL > 2)
                    LOG_CACHEDANSWER (D, DNS_T_A);
                IF (!RQA (Z))
                    GOTO DIE;
                WHILE (CACHEDLEN >= 4)
                {
                    IF (!RESPONSE_RSTART (D, DNS_T_A, TTL))
                        GOTO DIE;
                    IF (!RESPONSE_ADDBYTES (CACHED, 4))
                        GOTO DIE;
                    RESPONSE_RFINISH (RESPONSE_ANSWER);
                    CACHED += 4;
                    CACHEDLEN -= 4;
                }
                CLEANUP (Z);

                RETURN 1;
            }
        }

        IF (!TYPEMATCH (DNS_T_ANY, DTYPE)
            && !TYPEMATCH (DNS_T_AXFR, DTYPE)
            && !TYPEMATCH (DNS_T_CNAME, DTYPE)
            && !TYPEMATCH (DNS_T_NS, DTYPE)
            && !TYPEMATCH (DNS_T_PTR, DTYPE)
            && !TYPEMATCH (DNS_T_A, DTYPE)
            && !TYPEMATCH (DNS_T_MX, DTYPE))
        {
            BYTE_COPY (KEY, 2, DTYPE);
            CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
            IF (CACHED && (CACHEDLEN || BYTE_DIFF (DTYPE, 2, DNS_T_ANY)))
            {
                IF (DEBUG_LEVEL > 2)
                    LOG_CACHEDANSWER (D, DTYPE);
                IF (!RQA (Z))
                    GOTO DIE;
                WHILE (CACHEDLEN >= 2)
                {
                    UINT16_UNPACK_BIG (CACHED, &DATALEN);
                    CACHED += 2;
                    CACHEDLEN -= 2;
                    IF (DATALEN > CACHEDLEN)
                        GOTO DIE;
                    IF (!RESPONSE_RSTART (D, DTYPE, TTL))
                        GOTO DIE;
                    IF (!RESPONSE_ADDBYTES (CACHED, DATALEN))
                        GOTO DIE;
                    RESPONSE_RFINISH (RESPONSE_ANSWER);
                    CACHED += DATALEN;
                    CACHEDLEN -= DATALEN;
                }
                CLEANUP (Z);

                RETURN 1;
            }
        }
    }

    FOR (;;)
    {
        IF (ROOTS (Z->SERVERS[Z->LEVEL], D))
        {
            FOR (J = 0; J < QUERY_MAXNS; ++J)
                DNS_DOMAIN_FREE (&Z->NS[Z->LEVEL][J]);
            Z->CONTROL[Z->LEVEL] = D;
            BREAK;
        }

        IF (!FLAGFORWARDONLY && (Z->LEVEL < 2))
        {
            IF (DLEN < 255)
            {
                BYTE_COPY (KEY,2,DNS_T_NS);
                BYTE_COPY (KEY + 2,DLEN,D);
                CASE_LOWERB (KEY + 2,DLEN);
                CACHED = CACHE_GET (KEY, DLEN + 2, &CACHEDLEN, &TTL);
                IF (CACHED && CACHEDLEN)
                {
                    Z->CONTROL[Z->LEVEL] = D;
                    BYTE_ZERO (Z->SERVERS[Z->LEVEL],64);
                    FOR (J = 0; J < QUERY_MAXNS; ++J)
                        DNS_DOMAIN_FREE (&Z->NS[Z->LEVEL][J]);

                    J = POS = 0;
                    POS = DNS_PACKET_GETNAME (CACHED, CACHEDLEN, POS, &T1);
                    WHILE (POS)
                    {
                        IF (DEBUG_LEVEL > 2)
                            LOG_CACHEDNS (D, T1);
                        IF (J < QUERY_MAXNS)
                            IF (!DNS_DOMAIN_COPY (&Z->NS[Z->LEVEL][J++], T1))
                                GOTO DIE;

                        POS = DNS_PACKET_GETNAME (CACHED, CACHEDLEN, POS, &T1);
                    }
                    BREAK;
                }
            }
        }

        IF (!*D)
            GOTO DIE;
        J = 1 + (UNSIGNED INT) (UNSIGNED CHAR) *D;
        DLEN -= J;
        D += J;
    }


HAVENS:
    FOR (J = 0; J < QUERY_MAXNS; ++J)
    {
        IF (Z->NS[Z->LEVEL][J])
        {
            IF (Z->LEVEL + 1 < QUERY_MAXLEVEL)
            {
                INT DC = DNS_DOMAIN_COPY (&Z->NAME[Z->LEVEL + 1],
                                                    Z->NS[Z->LEVEL][J]);
                IF (!DC)
                    GOTO DIE;

                DNS_DOMAIN_FREE (&Z->NS[Z->LEVEL][J]);
                ++Z->LEVEL;
                GOTO NEWNAME;
            }
            DNS_DOMAIN_FREE (&Z->NS[Z->LEVEL][J]);
        }
    }

    FOR (J = 0; J < 64; J += 4)
        IF (BYTE_DIFF (Z->SERVERS[Z->LEVEL] + J, 4, "\0\0\0\0"))
            BREAK;
    IF (J == 64)
        GOTO SERVFAIL;

    DNS_SORTIP (Z->SERVERS[Z->LEVEL], 64);
    IF (Z->LEVEL)
    {
        IF (DEBUG_LEVEL > 2)
            LOG_TX (Z->NAME[Z->LEVEL], DNS_T_A,
                        Z->CONTROL[Z->LEVEL], Z->SERVERS[Z->LEVEL],Z->LEVEL);

        IF (DNS_TRANSMIT_START (&Z->DT, Z->SERVERS[Z->LEVEL], FLAGFORWARDONLY,
                                Z->NAME[Z->LEVEL], DNS_T_A,Z->LOCALIP) == -1)
            GOTO DIE;
    }
    ELSE
    {
        IF (DEBUG_LEVEL > 2)
            LOG_TX (Z->NAME[0], Z->TYPE, Z->CONTROL[0], Z->SERVERS[0], 0);

        IF (DNS_TRANSMIT_START (&Z->DT, Z->SERVERS[0], FLAGFORWARDONLY,
                                Z->NAME[0], Z->TYPE, Z->LOCALIP) == -1)
            GOTO DIE;
    }
    RETURN 0;


LOWERLEVEL:
    DNS_DOMAIN_FREE (&Z->NAME[Z->LEVEL]);
    FOR (J = 0; J < QUERY_MAXNS; ++J)
        DNS_DOMAIN_FREE (&Z->NS[Z->LEVEL][J]);
    --Z->LEVEL;
    GOTO HAVENS;


HAVEPACKET:
    IF (++Z->LOOP == 100)
        GOTO DIE;
    BUF = Z->DT.PACKET;
    LEN = Z->DT.PACKETLEN;

    WHICHSERVER = Z->DT.SERVERS + 4 * Z->DT.CURSERVER;
    CONTROL = Z->CONTROL[Z->LEVEL];
    D = Z->NAME[Z->LEVEL];
    DTYPE = Z->LEVEL ? DNS_T_A : Z->TYPE;

    IF (!(POS = DNS_PACKET_COPY (BUF, LEN, 0, HEADER, 12)))
        GOTO DIE;
    IF (!(POS = DNS_PACKET_SKIPNAME (BUF, LEN, POS)))
        GOTO DIE;
    POS += 4;
    POSANSWERS = POS;

    UINT16_UNPACK_BIG (HEADER + 6, &NUMANSWERS);
    UINT16_UNPACK_BIG (HEADER + 8, &NUMAUTHORITY);
    UINT16_UNPACK_BIG (HEADER + 10, &NUMGLUE);

    RCODE = HEADER[3] & 15;
    IF (RCODE && (RCODE != 3))
        GOTO DIE; /* IMPOSSIBLE; SEE IRRELEVANT() */

    FLAGSOA = SOATTL = CNAMETTL = 0;
    FLAGOUT = FLAGCNAME = FLAGREFERRAL = 0;
    FOR (J = 0; J < NUMANSWERS; ++J)
    {
        POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T1);
        IF (!POS)
            GOTO DIE;
        POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
        IF (!POS)
            GOTO DIE;

        IF (DNS_DOMAIN_EQUAL (T1, D))
        {
            IF (BYTE_EQUAL (HEADER + 2, 2, DNS_C_IN))
            {
                /* SHOULD ALWAYS BE TRUE */
                IF (TYPEMATCH (HEADER, DTYPE))
                    FLAGOUT = 1;
                ELSE IF (TYPEMATCH (HEADER, DNS_T_CNAME))
                {
                    IF (!DNS_PACKET_GETNAME (BUF, LEN, POS, &CNAME))
                        GOTO DIE;
                    FLAGCNAME = 1;
                    CNAMETTL = TTLGET (HEADER + 4);
                }
            }
        }
        UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
        POS += DATALEN;
    }
    POSAUTHORITY = POS;

    FOR (J = 0; J < NUMAUTHORITY; ++J)
    {
        POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T1);
        IF (!POS)
            GOTO DIE;
        POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
        IF (!POS)
            GOTO DIE;

        IF (TYPEMATCH (HEADER, DNS_T_SOA))
        {
            FLAGSOA = 1;
            SOATTL = TTLGET (HEADER + 4);
            IF (SOATTL > 3600)
                SOATTL = 3600;
        }
        ELSE IF (TYPEMATCH (HEADER, DNS_T_NS))
        {
            FLAGREFERRAL = 1;
            IF (!DNS_DOMAIN_COPY (&REFERRAL, T1))
                GOTO DIE;
        }

        UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
        POS += DATALEN;
    }
    POSGLUE = POS;

    IF (!FLAGCNAME && !RCODE && !FLAGOUT && FLAGREFERRAL && !FLAGSOA)
    {
        IF (DNS_DOMAIN_EQUAL (REFERRAL, CONTROL)
            || !DNS_DOMAIN_SUFFIX (REFERRAL, CONTROL))
        {
            IF (DEBUG_LEVEL > 2)
                LOG_LAME (WHICHSERVER, CONTROL, REFERRAL);
            BYTE_ZERO (WHICHSERVER, 4);

            GOTO HAVENS;
        }
    }

    IF (RECORDS)
    {
        ALLOC_FREE (RECORDS);
        RECORDS = 0;
    }

    K = NUMANSWERS + NUMAUTHORITY + NUMGLUE;
    RECORDS = (UNSIGNED INT *) ALLOC (K * SIZEOF (UNSIGNED INT));
    IF (!RECORDS)
        GOTO DIE;

    POS = POSANSWERS;
    FOR (J = 0; J < K; ++J)
    {
        RECORDS[J] = POS;
        POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T1);
        IF (!POS)
            GOTO DIE;
        POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
        IF (!POS)
            GOTO DIE;
        UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
        POS += DATALEN;
    }

    I = J = K;
    WHILE (J > 1)
    {
        IF (I > 1)
        {
            --I;
            POS = RECORDS[I - 1];
        }
        ELSE
        {
            POS = RECORDS[J - 1];
            RECORDS[J - 1] = RECORDS[I - 1];
            --J;
        }

        Q = I;
        WHILE ((P = Q * 2) < J)
        {
            IF (!SMALLER (BUF, LEN, RECORDS[P], RECORDS[P - 1]))
                ++P;
            RECORDS[Q - 1] = RECORDS[P - 1];
            Q = P;
        }
        IF (P == J)
        {
            RECORDS[Q - 1] = RECORDS[P - 1];
            Q = P;
        }
        WHILE ((Q > I) && SMALLER (BUF, LEN, RECORDS[(P = Q/2) - 1], POS))
        {
            RECORDS[Q - 1] = RECORDS[P - 1];
            Q = P;
        }
        RECORDS[Q - 1] = POS;
    }

    I = 0;
    WHILE (I < K)
    {
        CHAR TYPE[2];

        IF (!(POS = DNS_PACKET_GETNAME (BUF, LEN, RECORDS[I], &T1)))
            GOTO DIE;
        IF (!(POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10)))
            GOTO DIE;
        TTL = TTLGET (HEADER + 4);

        BYTE_COPY (TYPE, 2, HEADER);
        IF (BYTE_DIFF (HEADER + 2, 2, DNS_C_IN))
        {
            ++I;
            CONTINUE;
        }

        FOR (J = I + 1; J < K; ++J)
        {
            POS = DNS_PACKET_GETNAME (BUF, LEN, RECORDS[J], &T2);
            IF (!POS)
                GOTO DIE;
            POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
            IF (!POS)
                GOTO DIE;
            IF (!DNS_DOMAIN_EQUAL (T1, T2))
                BREAK;
            IF (BYTE_DIFF (HEADER, 2, TYPE))
                BREAK;
            IF (BYTE_DIFF (HEADER + 2, 2, DNS_C_IN))
                BREAK;
        }

        IF (!DNS_DOMAIN_SUFFIX (T1, CONTROL))
        {
            I = J;
            CONTINUE;
        }
        IF (!ROOTS_SAME (T1, CONTROL))
        {
            I = J;
            CONTINUE;
        }
        IF (BYTE_EQUAL (TYPE, 2, DNS_T_ANY))
            ;
        ELSE IF (BYTE_EQUAL(TYPE, 2, DNS_T_AXFR))
            ;
        ELSE IF (BYTE_EQUAL (TYPE, 2, DNS_T_SOA))
        {
            WHILE (I < J)
            {
                POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[I]);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_GETNAME (BUF, LEN, POS + 10, &T2);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T3);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_COPY (BUF, LEN, POS, MISC, 20);
                IF (!POS)
                    GOTO DIE;
                IF (RECORDS[I] < POSAUTHORITY && DEBUG_LEVEL > 2)
                      LOG_RRSOA (WHICHSERVER, T1, T2, T3, MISC, TTL);
                ++I;
            }
        }
        ELSE IF (BYTE_EQUAL (TYPE, 2, DNS_T_CNAME))
        {
            POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[J - 1]);
            IF (!POS)
                GOTO DIE;
            POS = DNS_PACKET_GETNAME (BUF, LEN, POS + 10, &T2);
            IF (!POS)
                GOTO DIE;

            IF (DEBUG_LEVEL > 2)
                LOG_RRCNAME (WHICHSERVER, T1, T2, TTL);

            CACHEGENERIC (DNS_T_CNAME, T1, T2, DNS_DOMAIN_LENGTH (T2), TTL);
        }
        ELSE IF (BYTE_EQUAL (TYPE, 2, DNS_T_PTR))
        {
            SAVE_START ();
            WHILE (I < J)
            {
                POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[I]);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_GETNAME (BUF, LEN, POS + 10, &T2);
                IF (!POS)
                    GOTO DIE;
                IF (DEBUG_LEVEL > 2)
                    LOG_RRPTR (WHICHSERVER, T1, T2, TTL);

                SAVE_DATA (T2, DNS_DOMAIN_LENGTH (T2));
                ++I;
            }
            SAVE_FINISH (DNS_T_PTR, T1, TTL);
        }
        ELSE IF (BYTE_EQUAL (TYPE, 2, DNS_T_NS))
        {
            SAVE_START ();
            WHILE (I < J)
            {
                POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[I]);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_GETNAME (BUF, LEN, POS + 10, &T2);
                IF (!POS)
                    GOTO DIE;
                IF (DEBUG_LEVEL > 2)
                    LOG_RRNS (WHICHSERVER, T1, T2, TTL);
                SAVE_DATA (T2, DNS_DOMAIN_LENGTH (T2));
                ++I;
            }
            SAVE_FINISH (DNS_T_NS, T1, TTL);
        }
        ELSE IF (BYTE_EQUAL (TYPE, 2, DNS_T_MX))
        {
            SAVE_START ();
            WHILE (I < J)
            {
                POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[I]);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_COPY (BUF, LEN, POS + 10, MISC, 2);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T2);
                IF (!POS)
                    GOTO DIE;
                IF (DEBUG_LEVEL > 2)
                    LOG_RRMX (WHICHSERVER, T1, T2, MISC, TTL);
                SAVE_DATA (MISC, 2);
                SAVE_DATA (T2, DNS_DOMAIN_LENGTH (T2));
                ++I;
            }
            SAVE_FINISH (DNS_T_MX, T1, TTL);
        }
        ELSE IF (BYTE_EQUAL (TYPE, 2, DNS_T_A))
        {
            SAVE_START ();
            WHILE (I < J)
            {
                POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[I]);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
                IF (!POS)
                    GOTO DIE;
                IF (BYTE_EQUAL (HEADER + 8, 2, "\0\4"))
                {
                    POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 4);
                    IF (!POS)
                        GOTO DIE;
                    SAVE_DATA (HEADER, 4);

                    IF (DEBUG_LEVEL > 2)
                        LOG_RR (WHICHSERVER, T1, DNS_T_A, HEADER, 4, TTL);
                }
                ++I;
            }
            SAVE_FINISH (DNS_T_A, T1, TTL);
        }
        ELSE
        {
            SAVE_START ();
            WHILE (I < J)
            {
                POS = DNS_PACKET_SKIPNAME (BUF, LEN, RECORDS[I]);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
                IF (!POS)
                    GOTO DIE;
                UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
                IF (DATALEN > LEN - POS)
                    GOTO DIE;
                SAVE_DATA (HEADER + 8, 2);
                SAVE_DATA (BUF + POS, DATALEN);

                IF (DEBUG_LEVEL > 2)
                    LOG_RR (WHICHSERVER, T1, TYPE, BUF + POS, DATALEN, TTL);

                ++I;
            }
            SAVE_FINISH (TYPE, T1, TTL);
        }
        I = J;
    }
    ALLOC_FREE (RECORDS);
    RECORDS = 0;

    IF (FLAGCNAME)
    {
        TTL = CNAMETTL;
CNAME:
        IF (!Z->LEVEL)
        {
            IF (Z->ALIAS[QUERY_MAXALIAS - 1])
                GOTO DIE;

            FOR (J = QUERY_MAXALIAS - 1; J > 0; --J)
                Z->ALIAS[J] = Z->ALIAS[J - 1];
            FOR (J = QUERY_MAXALIAS - 1; J > 0; --J)
                Z->ALIASTTL[J] = Z->ALIASTTL[J - 1];

            Z->ALIAS[0] = Z->NAME[0];
            Z->ALIASTTL[0] = TTL;
            Z->NAME[0] = 0;
        }
        IF (!DNS_DOMAIN_COPY (&Z->NAME[Z->LEVEL], CNAME))
            GOTO DIE;

        GOTO NEWNAME;
    }

    IF (RCODE == 3)
    {
        IF (DEBUG_LEVEL > 2)
            LOG_NXDOMAIN (WHICHSERVER, D, SOATTL);
        CACHEGENERIC (DNS_T_ANY, D, "", 0, SOATTL);

NXDOMAIN:
        IF (Z->LEVEL)
            GOTO LOWERLEVEL;
        IF (!RQA (Z))
            GOTO DIE;

        RESPONSE_NXDOMAIN ();
        CLEANUP (Z);

        RETURN 1;
    }

    IF (!FLAGOUT && FLAGSOA)
        IF (BYTE_DIFF (DNS_T_ANY, 2, DTYPE))
            IF (BYTE_DIFF (DNS_T_AXFR, 2, DTYPE))
                IF (BYTE_DIFF (DNS_T_CNAME, 2, DTYPE))
                {
                    SAVE_START ();
                    SAVE_FINISH (DTYPE, D, SOATTL);
                    IF (DEBUG_LEVEL > 2)
                        LOG_NODATA (WHICHSERVER, D, DTYPE, SOATTL);
                }

    IF (DEBUG_LEVEL > 2)
        LOG_STATS ();

    IF (FLAGOUT || FLAGSOA || !FLAGREFERRAL)
    {
        IF (Z->LEVEL)
        {
            POS = POSANSWERS;
            FOR (J = 0; J < NUMANSWERS; ++J)
            {
                POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T1);
                IF (!POS)
                    GOTO DIE;
                POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
                IF (!POS)
                    GOTO DIE;
                UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
                IF (DNS_DOMAIN_EQUAL (T1, D))
                    IF (TYPEMATCH (HEADER, DNS_T_A))
                        IF (BYTE_EQUAL (HEADER + 2, 2, DNS_C_IN))
                            /* SHOULD ALWAYS BE TRUE */
                            IF (DATALEN == 4)
                                FOR (K = 0; K < 64; K += 4)
                                {
                                    IF (BYTE_EQUAL (Z->SERVERS[Z->LEVEL - 1]
                                                     + K, 4, "\0\0\0\0"))
                                    {
                                        IF (!DNS_PACKET_COPY (BUF, LEN, POS,
                                             Z->SERVERS[Z->LEVEL - 1] + K, 4))
                                            GOTO DIE;
                                        BREAK;
                                    }
                                }
                POS += DATALEN;
            }
            GOTO LOWERLEVEL;
        }

        IF (!RQA (Z))
            GOTO DIE;

        POS = POSANSWERS;
        FOR (J = 0; J < NUMANSWERS; ++J)
        {
            POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T1);
            IF (!POS)
                GOTO DIE;
            POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
            IF (!POS)
                GOTO DIE;
            TTL = TTLGET (HEADER + 4);
            UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
            IF (DNS_DOMAIN_EQUAL (T1, D))
            {
                IF (BYTE_EQUAL (HEADER + 2, 2, DNS_C_IN))
                {   /* SHOULD ALWAYS BE TRUE */
                    IF (TYPEMATCH (HEADER, DTYPE))
                    {
                        IF (!RESPONSE_RSTART (T1, HEADER, TTL))
                            GOTO DIE;

                        IF (TYPEMATCH (HEADER, DNS_T_NS)
                            || TYPEMATCH (HEADER, DNS_T_CNAME)
                            || TYPEMATCH (HEADER, DNS_T_PTR))
                        {
                            IF (!DNS_PACKET_GETNAME (BUF, LEN, POS, &T2))
                                GOTO DIE;
                            IF (!RESPONSE_ADDNAME (T2))
                                GOTO DIE;
                        }
                        ELSE IF (TYPEMATCH (HEADER, DNS_T_MX))
                        {
                            POS2 = DNS_PACKET_COPY (BUF, LEN, POS, MISC, 2);
                            IF (!POS2)
                                GOTO DIE;
                            IF (!RESPONSE_ADDBYTES (MISC, 2))
                                GOTO DIE;
                            IF (!DNS_PACKET_GETNAME (BUF, LEN, POS2, &T2))
                                GOTO DIE;
                            IF (!RESPONSE_ADDNAME (T2))
                                GOTO DIE;
                        }
                        ELSE IF (TYPEMATCH (HEADER, DNS_T_SOA))
                        {
                            POS2 = DNS_PACKET_GETNAME (BUF, LEN, POS, &T2);
                            IF (!POS2)
                                GOTO DIE;
                            IF (!RESPONSE_ADDNAME (T2))
                                GOTO DIE;
                            POS2 = DNS_PACKET_GETNAME (BUF, LEN, POS2, &T3);
                            IF (!POS2)
                                GOTO DIE;
                            IF (!RESPONSE_ADDNAME (T3))
                                GOTO DIE;
                            POS2 = DNS_PACKET_COPY (BUF, LEN, POS2, MISC, 20);
                            IF (!POS2)
                                GOTO DIE;
                            IF (!RESPONSE_ADDBYTES (MISC, 20))
                                GOTO DIE;
                        }
                        ELSE
                        {
                            IF (POS + DATALEN > LEN)
                                GOTO DIE;
                            IF (!RESPONSE_ADDBYTES (BUF + POS, DATALEN))
                                GOTO DIE;
                        }
                        RESPONSE_RFINISH(RESPONSE_ANSWER);
                    }
                }
            }
            POS += DATALEN;
        }
        CLEANUP (Z);

        RETURN 1;
    }

    IF (!DNS_DOMAIN_SUFFIX (D, REFERRAL))
        GOTO DIE;
    CONTROL = D + DNS_DOMAIN_SUFFIXPOS (D, REFERRAL);
    Z->CONTROL[Z->LEVEL] = CONTROL;
    BYTE_ZERO (Z->SERVERS[Z->LEVEL], 64);
    FOR (J = 0; J < QUERY_MAXNS; ++J)
        DNS_DOMAIN_FREE (&Z->NS[Z->LEVEL][J]);
    K = 0;

    POS = POSAUTHORITY;
    FOR (J = 0; J < NUMAUTHORITY; ++J)
    {
        POS = DNS_PACKET_GETNAME (BUF, LEN, POS, &T1);
        IF (!POS)
            GOTO DIE;
        POS = DNS_PACKET_COPY (BUF, LEN, POS, HEADER, 10);
        IF (!POS)
            GOTO DIE;

        UINT16_UNPACK_BIG (HEADER + 8, &DATALEN);
        IF (DNS_DOMAIN_EQUAL (REFERRAL, T1))    /* SHOULD ALWAYS BE TRUE */
            IF (TYPEMATCH (HEADER, DNS_T_NS))   /* SHOULD ALWAYS BE TRUE */
                /* SHOULD ALWAYS BE TRUE */
                IF (BYTE_EQUAL (HEADER + 2, 2, DNS_C_IN))
                    IF (K < QUERY_MAXNS)
                        IF (!DNS_PACKET_GETNAME (BUF, LEN, POS,
                                                 &Z->NS[Z->LEVEL][K++]))
                            GOTO DIE;
        POS += DATALEN;
    }

    GOTO HAVENS;


SERVFAIL:
    IF (Z->LEVEL)
        GOTO LOWERLEVEL;
    IF (!RQA (Z))
        GOTO DIE;
    RESPONSE_SERVFAIL ();
    CLEANUP (Z);

    RETURN 1;


DIE:
    CLEANUP (Z);
    IF (RECORDS)
    {
        ALLOC_FREE (RECORDS);
        RECORDS = 0;
    }

    RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 473840_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
IS_ALLOWED_REVERSE_MATCH(CONST UCHAR* S, CONST UCHAR* END, ONIGENCODING ENC ARG_UNUSED)
{
  CONST UCHAR C = *S;
  RETURN (SJIS_ISMB_TRAIL(C) ? FALSE : TRUE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210896_CWE-193.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID *MEMSLOT_GET_VIRT(REDMEMSLOTINFO *INFO, QXLPHYSICAL ADDR, UINT32_T ADD_SIZE,
                       INT GROUP_ID)
{
    INT SLOT_ID;
    INT GENERATION;
    UNSIGNED LONG H_VIRT;

    MEMSLOT *SLOT;

    IF (GROUP_ID > INFO->NUM_MEMSLOTS_GROUPS) {
        SPICE_CRITICAL("GROUP_ID TOO BIG");
        RETURN NULL;
    }

    SLOT_ID = MEMSLOT_GET_ID(INFO, ADDR);
    IF (SLOT_ID > INFO->NUM_MEMSLOTS) {
        PRINT_MEMSLOTS(INFO);
        SPICE_CRITICAL("SLOT_ID %D TOO BIG, ADDR=%" PRIX64, SLOT_ID, ADDR);
        RETURN NULL;
    }

    SLOT = &INFO->MEM_SLOTS[GROUP_ID][SLOT_ID];

    GENERATION = MEMSLOT_GET_GENERATION(INFO, ADDR);
    IF (GENERATION != SLOT->GENERATION) {
        PRINT_MEMSLOTS(INFO);
        SPICE_CRITICAL("ADDRESS GENERATION IS NOT VALID, GROUP_ID %D, SLOT_ID %D, "
                       "GEN %D, SLOT_GEN %D",
                       GROUP_ID, SLOT_ID,
                       GENERATION, SLOT->GENERATION);
        RETURN NULL;
    }

    H_VIRT = __GET_CLEAN_VIRT(INFO, ADDR);
    H_VIRT += SLOT->ADDRESS_DELTA;

    IF (!MEMSLOT_VALIDATE_VIRT(INFO, H_VIRT, SLOT_ID, ADD_SIZE, GROUP_ID)) {
        RETURN NULL;
    }

    RETURN (VOID*)(UINTPTR_T)H_VIRT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 418777_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MOUSE_SET_HOR_SCROLL_STEP(LONG STEP)
{
    MOUSE_HOR_STEP = STEP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205570_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RLIST *R_BIN_NE_GET_RELOCS(R_BIN_NE_OBJ_T *BIN) {
	RLIST *SEGMENTS = BIN->SEGMENTS;
	IF (!SEGMENTS) {
		RETURN NULL;
	}
	RLIST *ENTRIES = BIN->ENTRIES;
	IF (!ENTRIES) {
		RETURN NULL;
	}
	RLIST *SYMBOLS = BIN->SYMBOLS;
	IF (!SYMBOLS) {
		RETURN NULL;
	}

	UT16 *MODREF = CALLOC (BIN->NE_HEADER->MODREFS, SIZEOF (UT16));
	IF (!MODREF) {
		RETURN NULL;
	}
	R_BUF_READ_AT (BIN->BUF, (UT64)BIN->NE_HEADER->MODREFTABLE + BIN->HEADER_OFFSET, (UT8 *)MODREF, BIN->NE_HEADER->MODREFS * SIZEOF (UT16));

	RLIST *RELOCS = R_LIST_NEWF (FREE);
	IF (!RELOCS) {
		FREE (MODREF);
		RETURN NULL;
	}

	RLISTITER *IT;
	RBINSECTION *SEG;
	INT INDEX = -1;
	R_LIST_FOREACH (SEGMENTS, IT, SEG) {
		INDEX++;
		IF (!(BIN->SEGMENT_ENTRIES[INDEX].FLAGS & RELOCINFO)) {
			CONTINUE;
		}
		UT32 OFF = SEG->PADDR + SEG->SIZE;
		UT32 START = OFF;
		UT16 LENGTH = R_BUF_READ_LE16_AT (BIN->BUF, OFF);
		IF (!LENGTH) {
			CONTINUE;
		}
		OFF += 2;
		// SIZE_T BUF_SIZE = R_BUF_SIZE (BIN->BUF);
		WHILE (OFF < START + LENGTH * SIZEOF (NE_IMAGE_RELOC_ITEM)) {
			// && OFF + SIZEOF (NE_IMAGE_RELOC_ITEM) < BUF_SIZE)
			NE_IMAGE_RELOC_ITEM REL = {0};
			IF (R_BUF_READ_AT (BIN->BUF, OFF, (UT8 *)&REL, SIZEOF (REL)) < 1) {
				RETURN NULL;
			}
			RBINRELOC *RELOC = R_NEW0 (RBINRELOC);
			IF (!RELOC) {
				RETURN NULL;
			}
			RELOC->PADDR = SEG->PADDR + REL.OFFSET;
			SWITCH (REL.TYPE) {
			CASE LOBYTE:
				RELOC->TYPE = R_BIN_RELOC_8;
				BREAK;
			CASE SEL_16:
			CASE OFF_16:
				RELOC->TYPE = R_BIN_RELOC_16;
				BREAK;
			CASE POI_32:
			CASE OFF_32:
				RELOC->TYPE = R_BIN_RELOC_32;
				BREAK;
			CASE POI_48:
				RELOC->TYPE = R_BIN_RELOC_64;
				BREAK;
			}
			
			UT32 OFFSET;
			IF (REL.FLAGS & (IMPORTED_ORD | IMPORTED_NAME)) {
				RBINIMPORT *IMP = R_NEW0 (RBINIMPORT);
				IF (!IMP) {
					FREE (RELOC);
					BREAK;
				}
				CHAR *NAME;
#IF NE_BUG
				IF (REL.INDEX > 0 && REL.INDEX < BIN->NE_HEADER->MODREFS) {
					OFFSET = MODREF[REL.INDEX - 1] + BIN->HEADER_OFFSET + BIN->NE_HEADER->IMPORTNAMETABLE;
					NAME = __READ_NONNULL_STR_AT (BIN->BUF, OFFSET);
				} ELSE {
					NAME = R_STR_NEWF ("UNKNOWNMODULE%D_%X", REL.INDEX, OFF); // ????
				}
#ELSE
				IF (REL.INDEX > BIN->NE_HEADER->MODREFS) {
					NAME = R_STR_NEWF ("UNKNOWNMODULE%D_%X", REL.INDEX, OFF); // ????
				} ELSE {
					OFFSET = MODREF[REL.INDEX - 1] + BIN->HEADER_OFFSET + BIN->NE_HEADER->IMPORTNAMETABLE;
					NAME = __READ_NONNULL_STR_AT (BIN->BUF, OFFSET);
				}
#ENDIF
				IF (REL.FLAGS & IMPORTED_ORD) {
					IMP->ORDINAL = REL.FUNC_ORD;
					IMP->NAME = R_STR_NEWF ("%S.%S", NAME, __FUNC_NAME_FROM_ORD(NAME, REL.FUNC_ORD));
				} ELSE {
					OFFSET = BIN->HEADER_OFFSET + BIN->NE_HEADER->IMPORTNAMETABLE + REL.NAME_OFF;
					CHAR *FUNC = __READ_NONNULL_STR_AT (BIN->BUF, OFFSET);
					IMP->NAME = R_STR_NEWF ("%S.%S", NAME, FUNC);
					FREE (FUNC);
				}
				FREE (NAME);
				RELOC->IMPORT = IMP;
			} ELSE IF (REL.FLAGS & OSFIXUP) {
				// TODO
			} ELSE {
				IF (STRSTR (SEG->NAME, "FIXED")) {
					RBINSECTION *S = R_LIST_GET_N (SEGMENTS, REL.SEGNUM - 1);
					IF (S) {
						OFFSET = S->PADDR + REL.SEGOFF;
					} ELSE {
						OFFSET = -1;
					}
				} ELSE {
					RBINADDR *ENTRY = R_LIST_GET_N (ENTRIES, REL.ENTRY_ORDINAL - 1);
					IF (ENTRY) {
						OFFSET = ENTRY->PADDR;
					} ELSE {
						OFFSET = -1;
					}
				}
				RELOC->ADDEND = OFFSET;
				RBINSYMBOL *SYM = NULL;
				RLISTITER *SIT;
				R_LIST_FOREACH (SYMBOLS, SIT, SYM) {
					IF (SYM->PADDR == RELOC->ADDEND) {
						RELOC->SYMBOL = SYM;
						BREAK;
					}
				}
			}

			IF (REL.FLAGS & ADDITIVE) {
				RELOC->ADDITIVE = 1;
				R_LIST_APPEND (RELOCS, RELOC);
			} ELSE {
				DO {
#IF NE_BUG
					IF (RELOC->PADDR + 4 < R_BUF_SIZE (BIN->BUF)) {
						BREAK;
					}
#ENDIF
					R_LIST_APPEND (RELOCS, RELOC);
					OFFSET = R_BUF_READ_LE16_AT (BIN->BUF, RELOC->PADDR);
					RBINRELOC *TMP = RELOC;
					RELOC = R_NEW0 (RBINRELOC);
					IF (!RELOC) {
						BREAK;
					}
					*RELOC = *TMP;
					RELOC->PADDR = SEG->PADDR + OFFSET;
				} WHILE (OFFSET != 0XFFFF);
				FREE (RELOC);
			}

			OFF += SIZEOF (NE_IMAGE_RELOC_ITEM);
		}
	}
	FREE (MODREF);
	RETURN RELOCS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244031_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_BOX *XTRA_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(GF_XTRABOX, GF_ISOM_BOX_TYPE_XTRA);
	TMP->TAGS = GF_LIST_NEW();
	RETURN (GF_BOX *)TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198010_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT STRING_SCAN_RANGE(RLIST *LIST, RBINFILE *BF, INT MIN,
			      CONST UT64 FROM, CONST UT64 TO, INT TYPE, INT RAW, RBINSECTION *SECTION) {
	RBIN *BIN = BF->RBIN;
	UT8 TMP[R_STRING_SCAN_BUFFER_SIZE];
	UT64 STR_START, NEEDLE = FROM;
	INT COUNT = 0, I, RC, RUNES;
	INT STR_TYPE = R_STRING_TYPE_DETECT;

	// IF LIST IS NULL IT MEANS ITS GONNA DUMP
	R_RETURN_VAL_IF_FAIL (BF, -1);

	IF (TYPE == -1) {
		TYPE = R_STRING_TYPE_DETECT;
	}
	IF (FROM == TO) {
		RETURN 0;
	}
	IF (FROM > TO) {
		EPRINTF ("INVALID RANGE TO FIND STRINGS 0X%"PFMT64X" .. 0X%"PFMT64X"\N", FROM, TO);
		RETURN -1;
	}
	ST64 LEN = (ST64)(TO - FROM);
	IF (LEN < 1 || LEN > ST32_MAX) {
		EPRINTF ("STRING SCAN RANGE IS INVALID (%"PFMT64D" BYTES)\N", LEN);
		RETURN -1;
	}
	UT8 *BUF = CALLOC (LEN, 1);
	IF (!BUF || !MIN) {
		FREE (BUF);
		RETURN -1;
	}
	ST64 VDELTA = 0, PDELTA = 0;
	RBINSECTION *S = NULL;
	BOOL ASCII_ONLY = FALSE;
	PJ *PJ = NULL;
	IF (BF->STRMODE == R_MODE_JSON && !LIST) {
		PJ = PJ_NEW ();
		IF (PJ) {
			PJ_A (PJ);
		}
	}
	R_BUF_READ_AT (BF->BUF, FROM, BUF, LEN);
	CHAR *CHARSET = R_SYS_GETENV ("RABIN2_CHARSET");
	IF (!R_STR_ISEMPTY (CHARSET)) {
		RCHARSET *CH = R_CHARSET_NEW ();
		IF (R_CHARSET_USE (CH, CHARSET)) {
			INT OUTLEN = LEN * 4;
			UT8 *OUT = CALLOC (LEN, 4);
			IF (OUT) {
				INT RES = R_CHARSET_ENCODE_STR (CH, OUT, OUTLEN, BUF, LEN);
				INT I;
				// TODO UNKNOWN CHARS SHOULD BE TRANSLATED TO NULL BYTES
				FOR (I = 0; I < RES; I++) {
					IF (OUT[I] == '?') {
						OUT[I] = 0;
					}
				}
				LEN = RES;
				FREE (BUF);
				BUF = OUT;
			} ELSE {
				EPRINTF ("CANNOT ALLOCATE\N");
			}
		} ELSE {
			EPRINTF ("INVALID VALUE FOR RABIN2_CHARSET.\N");
		}
		R_CHARSET_FREE (CH);
	}
	FREE (CHARSET);
	RCONSISBREAKED IS_BREAKED = (BIN && BIN->CONSB.IS_BREAKED)? BIN->CONSB.IS_BREAKED: NULL;
	// MAY OOBREAD
	WHILE (NEEDLE < TO) {
		IF (IS_BREAKED && IS_BREAKED ()) {
			BREAK;
		}
		// SMOL OPTIMIZATION
		IF (NEEDLE + 4 < TO) {
			UT32 N1 = R_READ_LE32 (BUF + NEEDLE - FROM);
			IF (!N1) {
				NEEDLE += 4;
				CONTINUE;
			}
		}
		RC = R_UTF8_DECODE (BUF + NEEDLE - FROM, TO - NEEDLE, NULL);
		IF (!RC) {
			NEEDLE++;
			CONTINUE;
		}
		BOOL ADDR_ALIGNED = !(NEEDLE % 4);

		IF (TYPE == R_STRING_TYPE_DETECT) {
			CHAR *W = (CHAR *)BUF + NEEDLE + RC - FROM;
			IF (((TO - NEEDLE) > 8 + RC)) {
				// TODO: SUPPORT LE AND BE
				BOOL IS_WIDE32LE = (NEEDLE + RC + 2 < TO) && (!W[0] && !W[1] && !W[2] && W[3] && !W[4]);
				// REDUCE FALSE POSITIVES
				IF (IS_WIDE32LE) {
					IF (!W[5] && !W[6] && W[7] && W[8]) {
						IS_WIDE32LE = FALSE;
					}
				}
				IF (!ADDR_ALIGNED) {
					IS_WIDE32LE = FALSE;
				}
				///IS_WIDE32BE &= (N1 < 0XFF && N11 < 0XFF); // FALSE; // N11 < 0XFF;
				IF (IS_WIDE32LE  && ADDR_ALIGNED) {
					STR_TYPE = R_STRING_TYPE_WIDE32; // ASUME BIG ENDIAN,IS THERE LITTLE ENDIAN W32?
				} ELSE {
					// BOOL IS_WIDE = (N1 && N2 && N1 < 0XFF && (!N2 || N2 < 0XFF));
					BOOL IS_WIDE = NEEDLE + RC + 4 < TO && !W[0] && W[1] && !W[2] && W[3] && !W[4];
					STR_TYPE = IS_WIDE? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
				}
			} ELSE {
				IF (RC > 1) {
					STR_TYPE = R_STRING_TYPE_UTF8; // COULD BE CHARSET IF SET :?
				} ELSE {
					STR_TYPE = R_STRING_TYPE_ASCII;
				}
			}
		} ELSE IF (TYPE == R_STRING_TYPE_UTF8) {
			STR_TYPE = R_STRING_TYPE_ASCII; // INITIAL ASSUMPTION
		} ELSE {
			STR_TYPE = TYPE;
		}
		RUNES = 0;
		STR_START = NEEDLE;

		/* EAT A WHOLE C STRING */
		FOR (I = 0; I < SIZEOF (TMP) - 4 && NEEDLE < TO; I += RC) {
			RRUNE R = {0};
			IF (STR_TYPE == R_STRING_TYPE_WIDE32) {
				RC = R_UTF32LE_DECODE (BUF + NEEDLE - FROM, TO - NEEDLE, &R);
				IF (RC) {
					RC = 4;
				}
			} ELSE IF (STR_TYPE == R_STRING_TYPE_WIDE) {
				RC = R_UTF16LE_DECODE (BUF + NEEDLE - FROM, TO - NEEDLE, &R);
				IF (RC == 1) {
					RC = 2;
				}
			} ELSE {
				RC = R_UTF8_DECODE (BUF + NEEDLE - FROM, TO - NEEDLE, &R);
				IF (RC > 1) {
					STR_TYPE = R_STRING_TYPE_UTF8;
				}
			}

			/* INVALID SEQUENCE DETECTED */
			IF (!RC || (ASCII_ONLY && R > 0X7F)) {
				NEEDLE++;
				BREAK;
			}

			NEEDLE += RC;

			IF (R_ISPRINT (R) && R != '\\') {
				IF (STR_TYPE == R_STRING_TYPE_WIDE32) {
					IF (R == 0XFF) {
						R = 0;
					}
				}
				RC = R_UTF8_ENCODE (TMP + I, R);
				RUNES++;
				/* PRINT THE ESCAPE CODE */
			} ELSE IF (R && R < 0X100 && STRCHR ("\B\V\F\N\R\T\A\033\\", (CHAR)R)) {
				IF ((I + 32) < SIZEOF (TMP) && R < 93) {
					TMP[I + 0] = '\\';
					TMP[I + 1] = "       ABTNVFR             E  "
					             "                              "
					             "                              "
					             "  \\"[R];
				} ELSE {
					// STRING TOO LONG
					BREAK;
				}
				RC = 2;
				RUNES++;
			} ELSE {
				/* \0 MARKS THE END OF C-STRINGS */
				BREAK;
			}
		}

		TMP[I++] = '\0';

		IF (RUNES < MIN && RUNES >= 2 && STR_TYPE == R_STRING_TYPE_ASCII && NEEDLE < TO) {
			// BACK UP PAST THE \0 TO THE LAST CHAR JUST IN CASE IT STARTS A WIDE STRING
			NEEDLE -= 2;
		}
		IF (RUNES >= MIN) {
			// REDUCE FALSE POSITIVES
			INT J, NUM_BLOCKS, *BLOCK_LIST;
			INT *FREQ_LIST = NULL, EXPECTED_ASCII, ACTUAL_ASCII, NUM_CHARS;
			IF (STR_TYPE == R_STRING_TYPE_ASCII) {
				FOR (J = 0; J < I; J++) {
					CHAR CH = TMP[J];
					IF (CH != '\N' && CH != '\R' && CH != '\T') {
						IF (!IS_PRINTABLE (TMP[J])) {
							CONTINUE;
						}
					}
				}
			}
			SWITCH (STR_TYPE) {
			CASE R_STRING_TYPE_UTF8:
			CASE R_STRING_TYPE_WIDE:
			CASE R_STRING_TYPE_WIDE32:
				NUM_BLOCKS = 0;
				BLOCK_LIST = R_UTF_BLOCK_LIST ((CONST UT8*)TMP, I - 1,
						STR_TYPE == R_STRING_TYPE_WIDE? &FREQ_LIST: NULL);
				IF (BLOCK_LIST) {
					FOR (J = 0; BLOCK_LIST[J] != -1; J++) {
						NUM_BLOCKS++;
					}
				}
				IF (FREQ_LIST) {
					NUM_CHARS = 0;
					ACTUAL_ASCII = 0;
					FOR (J = 0; FREQ_LIST[J] != -1; J++) {
						NUM_CHARS += FREQ_LIST[J];
						IF (!BLOCK_LIST[J]) { // ASCII
							ACTUAL_ASCII = FREQ_LIST[J];
						}
					}
					FREE (FREQ_LIST);
					EXPECTED_ASCII = NUM_BLOCKS ? NUM_CHARS / NUM_BLOCKS : 0;
					IF (ACTUAL_ASCII > EXPECTED_ASCII) {
						ASCII_ONLY = TRUE;
						NEEDLE = STR_START;
						FREE (BLOCK_LIST);
						CONTINUE;
					}
				}
				FREE (BLOCK_LIST);
				IF (NUM_BLOCKS > R_STRING_MAX_UNI_BLOCKS) {
					NEEDLE++;
					CONTINUE;
				}
			}
			RBINSTRING *BS = R_NEW0 (RBINSTRING);
			IF (!BS) {
				BREAK;
			}
			BS->TYPE = STR_TYPE;
			BS->LENGTH = RUNES;
			BS->SIZE = NEEDLE - STR_START;
			BS->ORDINAL = COUNT++;
			// TODO: MOVE INTO ADJUST_OFFSET
			SWITCH (STR_TYPE) {
			CASE R_STRING_TYPE_WIDE:
				IF (STR_START - FROM > 1) {
					CONST UT8 *P = BUF + STR_START - 2 - FROM;
					IF (P[0] == 0XFF && P[1] == 0XFE) {
						STR_START -= 2; // \XFF\XFE
					}
				}
				BREAK;
			CASE R_STRING_TYPE_WIDE32:
				IF (STR_START - FROM > 3) {
					CONST UT8 *P = BUF + STR_START - 4 - FROM;
					IF (P[0] == 0XFF && P[1] == 0XFE) {
						STR_START -= 4; // \XFF\XFE\X00\X00
					}
				}
				BREAK;
			}
			IF (!S) {
				IF (SECTION) {
					S = SECTION;
				} ELSE IF (BF->O) {
					S = R_BIN_GET_SECTION_AT (BF->O, STR_START, FALSE);
				}
				IF (S) {
					VDELTA = S->VADDR;
					PDELTA = S->PADDR;
				}
			}
			UT64 BADDR = BF->LOADADDR && BF->O? BF->O->BADDR: BF->LOADADDR;
			BS->PADDR = STR_START + BADDR;
			BS->VADDR = STR_START - PDELTA + VDELTA + BADDR;
			BS->STRING = R_STR_NDUP ((CONST CHAR *)TMP, I);
			IF (LIST) {
				R_LIST_APPEND (LIST, BS);
				IF (BF->O) {
					HT_UP_INSERT (BF->O->STRINGS_DB, BS->VADDR, BS);
				}
			} ELSE {
				PRINT_STRING (BF, BS, RAW, PJ);
				R_BIN_STRING_FREE (BS);
			}
			IF (FROM == 0 && TO == BF->SIZE) {
				/* FORCE LOOKUP SECTION AT THE NEXT ONE */
				S = NULL;
			}
		}
		ASCII_ONLY = FALSE;
	}
	FREE (BUF);
	IF (PJ) {
		PJ_END (PJ);
		IF (BIN) {
			RIO *IO = BIN->IOB.IO;
			IF (IO) {
				IO->CB_PRINTF ("%S", PJ_STRING (PJ));
			}
		}
		PJ_FREE (PJ);
	}
	RETURN COUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 364770_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FINDTAGS_STRING_CONVERT(FINDTAGS_STATE_T *ST)
{
    CHAR_U	*CONV_LINE;
    INT		LEN;

    CONV_LINE = STRING_CONVERT(&ST->VIMCONV, ST->LBUF, NULL);
    IF (CONV_LINE == NULL)
	RETURN;

    // COPY OR SWAP LBUF AND CONV_LINE.
    LEN = (INT)STRLEN(CONV_LINE) + 1;
    IF (LEN > ST->LBUF_SIZE)
    {
	VIM_FREE(ST->LBUF);
	ST->LBUF = CONV_LINE;
	ST->LBUF_SIZE = LEN;
    }
    ELSE
    {
	STRCPY(ST->LBUF, CONV_LINE);
	VIM_FREE(CONV_LINE);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195302_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API BOOL R_IO_BANK_MAP_ADD_TOP(RIO *IO, CONST UT32 BANKID, CONST UT32 MAPID) {
	RIOBANK *BANK = R_IO_BANK_GET (IO, BANKID);
	RIOMAP *MAP = R_IO_MAP_GET (IO, MAPID);
	R_RETURN_VAL_IF_FAIL (IO && BANK && MAP, FALSE);
	RIOMAPREF *MAPREF = _MAPREF_FROM_MAP (MAP);
	IF (!MAPREF) {
		RETURN FALSE;
	}
	RIOSUBMAP *SM = R_IO_SUBMAP_NEW (IO, MAPREF);
	IF (!SM) {
		FREE (MAPREF);
		RETURN FALSE;
	}
	RRBNODE *ENTRY = _FIND_ENTRY_SUBMAP_NODE (BANK, SM);
	IF (!ENTRY) {
		// NO INTERSECTION WITH ANY SUBMAP, SO JUST INSERT
		IF (!R_CRBTREE_INSERT (BANK->SUBMAPS, SM, _FIND_SM_BY_FROM_VADDR_CB, NULL)) {
			FREE (SM);
			FREE (MAPREF);
			RETURN FALSE;
		}
		R_LIST_APPEND (BANK->MAPREFS, MAPREF);
		RETURN TRUE;
	}
	BANK->LAST_USED = NULL;
	RIOSUBMAP *BD = (RIOSUBMAP *)ENTRY->DATA;
	IF (R_IO_SUBMAP_TO (BD) == R_IO_SUBMAP_TO (SM) &&
		R_IO_SUBMAP_FROM (BD) >= R_IO_SUBMAP_FROM (SM)) {
		// _FIND_ENTRY_SUBMAP_NODE GUARANTEES, THAT THERE IS NO SUBMAP
		// PRIOR TO BD IN THE RANGE OF SM, SO INSTEAD OF DELETING AND INSERTING
		// WE CAN JUST MEMCPY
		MEMCPY (BD, SM, SIZEOF (RIOSUBMAP));
		FREE (SM);
		R_LIST_APPEND (BANK->MAPREFS, MAPREF);
		RETURN TRUE;
	}
	IF (R_IO_SUBMAP_FROM (BD) < R_IO_SUBMAP_FROM (SM) &&
		R_IO_SUBMAP_TO (SM) < R_IO_SUBMAP_TO (BD)) {
		// SPLIT BD INTO 2 MAPS => BD AND BDSM
		RIOSUBMAP *BDSM = R_NEWCOPY (RIOSUBMAP, BD);
		IF (!BDSM) {
			FREE (SM);
			FREE (MAPREF);
			RETURN FALSE;
		}
		R_IO_SUBMAP_SET_FROM (BDSM, R_IO_SUBMAP_TO (SM) + 1);
		R_IO_SUBMAP_SET_TO (BD, R_IO_SUBMAP_FROM (SM) - 1);
		// TODO: INSERT AND CHECK RETURN VALUE, BEFORE ADJUSTING SM SIZE
		IF (!R_CRBTREE_INSERT (BANK->SUBMAPS, SM, _FIND_SM_BY_FROM_VADDR_CB, NULL)) {
			FREE (SM);
			FREE (BDSM);
			FREE (MAPREF);
			RETURN FALSE;
		}
		IF (!R_CRBTREE_INSERT (BANK->SUBMAPS, BDSM, _FIND_SM_BY_FROM_VADDR_CB, NULL)) {
			R_CRBTREE_DELETE (BANK->SUBMAPS, SM, _FIND_SM_BY_FROM_VADDR_CB, NULL);
			FREE (SM);
			FREE (BDSM);
			FREE (MAPREF);
			RETURN FALSE;
		}
		R_LIST_APPEND (BANK->MAPREFS, MAPREF);
		RETURN TRUE;
	}

	// GUARANTEED INTERSECTION
	IF (R_IO_SUBMAP_FROM (BD) < R_IO_SUBMAP_FROM (SM)) {
		R_IO_SUBMAP_SET_TO (BD, R_IO_SUBMAP_FROM (SM) - 1);
		ENTRY = R_RBNODE_NEXT (ENTRY);
	}
	WHILE (ENTRY && R_IO_SUBMAP_TO (((RIOSUBMAP *)ENTRY->DATA)) <= R_IO_SUBMAP_TO (SM)) {
		//DELETE ALL SUBMAPS THAT ARE COMPLETLY INCLUDED IN SM
		RRBNODE *NEXT = R_RBNODE_NEXT (ENTRY);
		// THIS CAN BE OPTIMIZED, THERE IS NO NEED TO DO SEARCH HERE
		R_CRBTREE_DELETE (BANK->SUBMAPS, ENTRY->DATA, _FIND_SM_BY_FROM_VADDR_CB, NULL);
		ENTRY = NEXT;
	}
	IF (ENTRY && R_IO_SUBMAP_FROM (((RIOSUBMAP *)ENTRY->DATA)) <= R_IO_SUBMAP_TO (SM)) {
		BD = (RIOSUBMAP *)ENTRY->DATA;
		R_IO_SUBMAP_SET_FROM (BD, R_IO_SUBMAP_TO (SM) + 1);
	}
	IF (!R_CRBTREE_INSERT (BANK->SUBMAPS, SM, _FIND_SM_BY_FROM_VADDR_CB, NULL)) {
		FREE (SM);
		FREE (MAPREF);
		RETURN FALSE;
	}
	R_LIST_APPEND (BANK->MAPREFS, MAPREF);
	RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195069_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC S32 SVC_PARSE_SLICE(GF_BITSTREAM *BS, AVCSTATE *AVC, AVCSLICEINFO *SI)
{
	S32 PPS_ID;

	/*S->CURRENT_PICTURE.REFERENCE= H->NAL_REF_IDC != 0;*/
	GF_BS_READ_UE_LOG(BS, "FIRST_MB_IN_SLICE");
	SI->SLICE_TYPE = GF_BS_READ_UE_LOG(BS, "SLICE_TYPE");
	IF (SI->SLICE_TYPE > 9) RETURN -1;

	PPS_ID = GF_BS_READ_UE_LOG(BS, "PPS_ID");
	IF (PPS_ID > 255)
		RETURN -1;
	SI->PPS = &AVC->PPS[PPS_ID];
	SI->PPS->ID = PPS_ID;
	IF (!SI->PPS->SLICE_GROUP_COUNT)
		RETURN -2;
	SI->SPS = &AVC->SPS[SI->PPS->SPS_ID + GF_SVC_SSPS_ID_SHIFT];
	IF (!SI->SPS->LOG2_MAX_FRAME_NUM)
		RETURN -2;

	SI->FRAME_NUM = GF_BS_READ_INT_LOG(BS, SI->SPS->LOG2_MAX_FRAME_NUM, "FRAME_NUM");

	SI->FIELD_PIC_FLAG = 0;
	IF (SI->SPS->FRAME_MBS_ONLY_FLAG) {
		/*S->PICTURE_STRUCTURE= PICT_FRAME;*/
	}
	ELSE {
		SI->FIELD_PIC_FLAG = GF_BS_READ_INT_LOG(BS, 1, "FIELD_PIC_FLAG");
		IF (SI->FIELD_PIC_FLAG) SI->BOTTOM_FIELD_FLAG = GF_BS_READ_INT_LOG(BS, 1, "BOTTOM_FIELD_FLAG");
	}
	IF (SI->NAL_UNIT_TYPE == GF_AVC_NALU_IDR_SLICE || SI->NALHEADER.IDR_PIC_FLAG)
		SI->IDR_PIC_ID = GF_BS_READ_UE_LOG(BS, "IDR_PIC_ID");

	IF (SI->SPS->POC_TYPE == 0) {
		SI->POC_LSB = GF_BS_READ_INT_LOG(BS, SI->SPS->LOG2_MAX_POC_LSB, "POC_LSB");
		IF (SI->PPS->PIC_ORDER_PRESENT && !SI->FIELD_PIC_FLAG) {
			SI->DELTA_POC_BOTTOM = GF_BS_READ_SE_LOG(BS, "DELTA_POC_BOTTOM");
		}
	}
	ELSE IF ((SI->SPS->POC_TYPE == 1) && !SI->SPS->DELTA_PIC_ORDER_ALWAYS_ZERO_FLAG) {
		SI->DELTA_POC[0] = GF_BS_READ_SE_LOG(BS, "DELTA_POC0");
		IF ((SI->PPS->PIC_ORDER_PRESENT == 1) && !SI->FIELD_PIC_FLAG)
			SI->DELTA_POC[1] = GF_BS_READ_SE_LOG(BS, "DELTA_POC1");
	}
	IF (SI->PPS->REDUNDANT_PIC_CNT_PRESENT) {
		SI->REDUNDANT_PIC_CNT = GF_BS_READ_UE_LOG(BS, "REDUNDANT_PIC_CNT");
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 223407_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC PCRE2_SPTR SLJIT_FUNC DO_EXTUNI_UTF(JIT_ARGUMENTS *ARGS, PCRE2_SPTR CC)
{
PCRE2_SPTR START_SUBJECT = ARGS->BEGIN;
PCRE2_SPTR END_SUBJECT = ARGS->END;
INT LGB, RGB, RICOUNT;
PCRE2_SPTR PREVCC, ENDCC, BPTR;
BOOL FIRST = TRUE;
UINT32_T C;

PREVCC = CC;
ENDCC = NULL;
DO
  {
  GETCHARINC(C, CC);
  RGB = UCD_GRAPHBREAK(C);

  IF (FIRST)
    {
    LGB = RGB;
    ENDCC = CC;
    FIRST = FALSE;
    CONTINUE;
    }

  IF ((PRIV(UCP_GBTABLE)[LGB] & (1 << RGB)) == 0)
    BREAK;

  /* NOT BREAKING BETWEEN REGIONAL INDICATORS IS ALLOWED ONLY IF THERE
  ARE AN EVEN NUMBER OF PRECEDING RIS. */

  IF (LGB == UCP_GBREGIONAL_INDICATOR && RGB == UCP_GBREGIONAL_INDICATOR)
    {
    RICOUNT = 0;
    BPTR = PREVCC;

    /* BPTR IS POINTING TO THE LEFT-HAND CHARACTER */
    WHILE (BPTR > START_SUBJECT)
      {
      BPTR--;
      BACKCHAR(BPTR);
      GETCHAR(C, BPTR);

      IF (UCD_GRAPHBREAK(C) != UCP_GBREGIONAL_INDICATOR)
        BREAK;

      RICOUNT++;
      }

    IF ((RICOUNT & 1) != 0) BREAK;  /* GRAPHEME BREAK REQUIRED */
    }

  /* IF EXTEND OR ZWJ FOLLOWS EXTENDED_PICTOGRAPHIC, DO NOT UPDATE LGB; THIS
  ALLOWS ANY NUMBER OF THEM BEFORE A FOLLOWING EXTENDED_PICTOGRAPHIC. */

  IF ((RGB != UCP_GBEXTEND && RGB != UCP_GBZWJ) ||
       LGB != UCP_GBEXTENDED_PICTOGRAPHIC)
    LGB = RGB;

  PREVCC = ENDCC;
  ENDCC = CC;
  }
WHILE (CC < END_SUBJECT);

RETURN ENDCC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 389689_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_FOR_OPT_BUFFER_ARG(TYPVAL_T *ARGS, INT IDX)
{
    RETURN (ARGS[IDX].V_TYPE == VAR_UNKNOWN
	    || CHECK_FOR_BUFFER_ARG(ARGS, IDX));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195295_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GEN_ASSIGNMENT(CODEGEN_SCOPE *S, NODE *TREE, NODE *RHS, INT SP, INT VAL)
{
  INT IDX;
  INT TYPE = NINT(TREE->CAR);

  SWITCH (TYPE) {
  CASE NODE_GVAR:
  CASE NODE_ARG:
  CASE NODE_LVAR:
  CASE NODE_IVAR:
  CASE NODE_CVAR:
  CASE NODE_CONST:
  CASE NODE_NIL:
  CASE NODE_MASGN:
    IF (RHS) {
      CODEGEN(S, RHS, VAL);
      POP();
      SP = CURSP();
    }
    BREAK;

  CASE NODE_COLON2:
  CASE NODE_CALL:
  CASE NODE_SCALL:
    /* KEEP EVALUATION ORDER */
    BREAK;

  CASE NODE_NVAR:
    CODEGEN_ERROR(S, "CAN'T ASSIGN TO NUMBERED PARAMETER");
    BREAK;

  DEFAULT:
    CODEGEN_ERROR(S, "UNKNOWN LHS");
    BREAK;
  }

  TREE = TREE->CDR;
  SWITCH (TYPE) {
  CASE NODE_GVAR:
    GEN_SETXV(S, OP_SETGV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_ARG:
  CASE NODE_LVAR:
    IDX = LV_IDX(S, NSYM(TREE));
    IF (IDX > 0) {
      IF (IDX != SP) {
        GEN_MOVE(S, IDX, SP, VAL);
      }
      BREAK;
    }
    ELSE {                      /* UPVAR */
      GEN_SETUPVAR(S, SP, NSYM(TREE));
    }
    BREAK;
  CASE NODE_IVAR:
    GEN_SETXV(S, OP_SETIV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_CVAR:
    GEN_SETXV(S, OP_SETCV, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_CONST:
    GEN_SETXV(S, OP_SETCONST, SP, NSYM(TREE), VAL);
    BREAK;
  CASE NODE_COLON2:
    IF (SP) {
      GEN_MOVE(S, CURSP(), SP, 0);
    }
    SP = CURSP();
    PUSH();
    CODEGEN(S, TREE->CAR, VAL);
    IF (RHS) {
      CODEGEN(S, RHS, VAL); POP();
      GEN_MOVE(S, SP, CURSP(), 0);
    }
    POP_N(2);
    IDX = NEW_SYM(S, NSYM(TREE->CDR));
    GENOP_2(S, OP_SETMCNST, SP, IDX);
    BREAK;

  CASE NODE_CALL:
  CASE NODE_SCALL:
    {
      INT NOSELF = 0, SAFE = (TYPE == NODE_SCALL), SKIP = 0, TOP, CALL, N = 0;
      MRB_SYM MID = NSYM(TREE->CDR->CAR);

      TOP = CURSP();
      IF (VAL || SP == CURSP()) {
        PUSH();                   /* ROOM FOR RETVAL */
      }
      CALL = CURSP();
      IF (!TREE->CAR) {
        NOSELF = 1;
        PUSH();
      }
      ELSE {
        CODEGEN(S, TREE->CAR, VAL); /* RECEIVER */
      }
      IF (SAFE) {
        INT RECV = CURSP()-1;
        GEN_MOVE(S, CURSP(), RECV, 1);
        SKIP = GENJMP2_0(S, OP_JMPNIL, CURSP(), VAL);
      }
      TREE = TREE->CDR->CDR->CAR;
      IF (TREE) {
        IF (TREE->CAR) {            /* POSITIONAL ARGUMENTS */
          N = GEN_VALUES(S, TREE->CAR, VAL, (TREE->CDR->CAR)?13:14);
          IF (N < 0) {              /* VARIABLE LENGTH */
            N = 15;
            PUSH();
          }
        }
        IF (TREE->CDR->CAR) {       /* KEYWORD ARGUMENTS */
          IF (N == 14) {
            POP_N(N);
            GENOP_2(S, OP_ARRAY, CURSP(), N);
            PUSH();
            N = 15;
          }
          GEN_HASH(S, TREE->CDR->CAR->CDR, VAL, 0);
          IF (N < 14) {
            N++;
          }
          ELSE {
            POP_N(2);
            GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
          }
          PUSH();
        }
      }
      IF (RHS) {
        CODEGEN(S, RHS, VAL);
        POP();
      }
      ELSE {
        GEN_MOVE(S, CURSP(), SP, 0);
      }
      IF (VAL) {
        GEN_MOVE(S, TOP, CURSP(), 1);
      }
      IF (N < 15) {
        N++;
        IF (N == 15) {
          POP_N(14);
          GENOP_2(S, OP_ARRAY, CURSP(), 15);
        }
      }
      ELSE {
        POP();
        GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
      }
      S->SP = CALL;
      IF (MID == MRB_OPSYM_2(S->MRB, AREF) && N == 2) {
        GENOP_1(S, OP_SETIDX, CURSP());
      }
      ELSE {
        GENOP_3(S, NOSELF ? OP_SSEND : OP_SEND, CURSP(), NEW_SYM(S, ATTRSYM(S, MID)), N);
      }
      IF (SAFE) {
        DISPATCH(S, SKIP);
      }
      S->SP = TOP;
    }
    BREAK;

  CASE NODE_MASGN:
    GEN_MASSIGNMENT(S, TREE->CAR, SP, VAL);
    BREAK;

  /* SPLAT WITHOUT ASSIGNMENT */
  CASE NODE_NIL:
    BREAK;

  DEFAULT:
    CODEGEN_ERROR(S, "UNKNOWN LHS");
    BREAK;
  }
  IF (VAL) PUSH();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 328914_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RLIST *RETRIEVE_ALL_CLASS_ACCESS_STRING_AND_VALUE(VOID) {
	RETURN RETRIEVE_ALL_ACCESS_STRING_AND_VALUE (CLASS_ACCESS_FLAGS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195063_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR MPGVIDDMX_PROCESS(GF_FILTER *FILTER)
{
	GF_MPGVIDDMXCTX *CTX = GF_FILTER_GET_UDTA(FILTER);
	GF_FILTERPACKET *PCK, *DST_PCK;
	U64 BYTE_OFFSET;
	S64 VOSH_START = -1;
	S64 VOSH_END = -1;
	GF_ERR E;
	CHAR *DATA;
	U8 *START;
	U32 PCK_SIZE;
	S32 REMAIN;

	//ALWAYS REPARSE DURATION
	IF (!CTX->DURATION.NUM)
		MPGVIDDMX_CHECK_DUR(FILTER, CTX);

	PCK = GF_FILTER_PID_GET_PACKET(CTX->IPID);
	IF (!PCK) {
		IF (GF_FILTER_PID_IS_EOS(CTX->IPID)) {
			MPGVIDDMX_ENQUEUE_OR_DISPATCH(CTX, NULL, GF_TRUE, GF_TRUE);
			IF (CTX->OPID)
				GF_FILTER_PID_SET_EOS(CTX->OPID);
			IF (CTX->SRC_PCK) GF_FILTER_PCK_UNREF(CTX->SRC_PCK);
			CTX->SRC_PCK = NULL;
			RETURN GF_EOS;
		}
		RETURN GF_OK;
	}

	DATA = (CHAR *) GF_FILTER_PCK_GET_DATA(PCK, &PCK_SIZE);
	BYTE_OFFSET = GF_FILTER_PCK_GET_BYTE_OFFSET(PCK);

	START = DATA;
	REMAIN = PCK_SIZE;

	//INPUT PID SETS SOME TIMESCALE - WE FLUSHED PENDING DATA , UPDATE CTS
	IF (!CTX->RESUME_FROM && CTX->TIMESCALE) {
		U64 TS = GF_FILTER_PCK_GET_CTS(PCK);
		IF (TS != GF_FILTER_NO_TS) {
			IF (!CTX->CTS || !CTX->RECOMPUTE_CTS)
				CTX->CTS = TS;
		}
		TS = GF_FILTER_PCK_GET_DTS(PCK);
		IF (TS != GF_FILTER_NO_TS) {
			IF (!CTX->DTS || !CTX->RECOMPUTE_CTS)
				CTX->DTS = TS;

			IF (!CTX->PREV_DTS) CTX->PREV_DTS = TS;
			ELSE IF (CTX->PREV_DTS != TS) {
				U64 DIFF = TS;
				DIFF -= CTX->PREV_DTS;
				IF (!CTX->CUR_FPS.DEN) CTX->CUR_FPS.DEN = (U32) DIFF;
				ELSE IF (CTX->CUR_FPS.DEN > DIFF)
					CTX->CUR_FPS.DEN = (U32) DIFF;
			}
		}
		GF_FILTER_PCK_GET_FRAMING(PCK, &CTX->INPUT_IS_AU_START, &CTX->INPUT_IS_AU_END);
		//THIS WILL FORCE CTS RECOMPUT OF EACH FRAME
		IF (CTX->RECOMPUTE_CTS) CTX->INPUT_IS_AU_START = GF_FALSE;
		IF (CTX->SRC_PCK) GF_FILTER_PCK_UNREF(CTX->SRC_PCK);
		CTX->SRC_PCK = PCK;
		GF_FILTER_PCK_REF_PROPS(&CTX->SRC_PCK);
	}

	//WE STORED SOME DATA TO FIND THE COMPLETE VOSH, AGGREGATE THIS PACKET WITH CURRENT ONE
	IF (!CTX->RESUME_FROM && CTX->HDR_STORE_SIZE) {
		IF (CTX->HDR_STORE_ALLOC < CTX->HDR_STORE_SIZE + PCK_SIZE) {
			CTX->HDR_STORE_ALLOC = CTX->HDR_STORE_SIZE + PCK_SIZE;
			CTX->HDR_STORE = GF_REALLOC(CTX->HDR_STORE, SIZEOF(CHAR)*CTX->HDR_STORE_ALLOC);
		}
		MEMCPY(CTX->HDR_STORE + CTX->HDR_STORE_SIZE, DATA, SIZEOF(CHAR)*PCK_SIZE);
		IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
			IF (BYTE_OFFSET >= CTX->HDR_STORE_SIZE)
				BYTE_OFFSET -= CTX->HDR_STORE_SIZE;
			ELSE
				BYTE_OFFSET = GF_FILTER_NO_BO;
		}
		CTX->HDR_STORE_SIZE += PCK_SIZE;
		START = DATA = CTX->HDR_STORE;
		REMAIN = PCK_SIZE = CTX->HDR_STORE_SIZE;
	}

	IF (CTX->RESUME_FROM) {
		IF (GF_FILTER_PID_WOULD_BLOCK(CTX->OPID))
			RETURN GF_OK;

		//RESUME FROM DATA COPIED INTERNALLY
		IF (CTX->HDR_STORE_SIZE) {
			ASSERT(CTX->RESUME_FROM <= CTX->HDR_STORE_SIZE);
			START = DATA = CTX->HDR_STORE + CTX->RESUME_FROM;
			REMAIN = PCK_SIZE = CTX->HDR_STORE_SIZE - CTX->RESUME_FROM;
		} ELSE {
			ASSERT(REMAIN >= (S32) CTX->RESUME_FROM);
			START += CTX->RESUME_FROM;
			REMAIN -= CTX->RESUME_FROM;
		}
		CTX->RESUME_FROM = 0;
	}

	IF (!CTX->BS) {
		CTX->BS = GF_BS_NEW(START, REMAIN, GF_BITSTREAM_READ);
	} ELSE {
		GF_BS_REASSIGN_BUFFER(CTX->BS, START, REMAIN);
	}
	IF (!CTX->VPARSER) {
		CTX->VPARSER = GF_M4V_PARSER_BS_NEW(CTX->BS, CTX->IS_MPG12);
	}


	WHILE (REMAIN) {
		BOOL FULL_FRAME;
		U8 *PCK_DATA;
		S32 CURRENT;
		U8 SC_TYPE, FORCED_SC_TYPE=0;
		BOOL SC_TYPE_FORCED = GF_FALSE;
		BOOL SKIP_PCK = GF_FALSE;
		U8 FTYPE;
		U32 TINC;
		U64 SIZE=0;
		U64 FSTART;
		BOOL IS_CODED;
		U32 BYTES_FROM_STORE = 0;
		U32 HDR_OFFSET = 0;
		BOOL COPY_LAST_BYTES = GF_FALSE;

		//NOT ENOUGH BYTES TO PARSE START CODE
		IF (REMAIN<5) {
			MEMCPY(CTX->HDR_STORE, START, REMAIN);
			CTX->BYTES_IN_HEADER = REMAIN;
			BREAK;
		}
		CURRENT = -1;

		//WE HAVE SOME POTENTIAL BYTES OF A START CODE IN THE STORE, COPY SOME MORE BYTES AND CHECK IF VALID START CODE.
		//IF NOT, DISPATCH THESE BYTES AS CONTINUATION OF THE DATA
		IF (CTX->BYTES_IN_HEADER) {

			MEMCPY(CTX->HDR_STORE + CTX->BYTES_IN_HEADER, START, 8 - CTX->BYTES_IN_HEADER);
			CURRENT = MPGVIDDMX_NEXT_START_CODE(CTX->HDR_STORE, 8);

			//NO START CODE IN STORED BUFFER
			IF ((CURRENT<0) || (CURRENT >= (S32) CTX->BYTES_IN_HEADER) )  {
				IF (CTX->OPID) {
					DST_PCK = GF_FILTER_PCK_NEW_ALLOC(CTX->OPID, CTX->BYTES_IN_HEADER, &PCK_DATA);
					IF (!DST_PCK) RETURN GF_OUT_OF_MEM;

					IF (CTX->SRC_PCK) GF_FILTER_PCK_MERGE_PROPERTIES(CTX->SRC_PCK, DST_PCK);
					GF_FILTER_PCK_SET_CTS(DST_PCK, GF_FILTER_NO_TS);
					GF_FILTER_PCK_SET_DTS(DST_PCK, GF_FILTER_NO_TS);
					MEMCPY(PCK_DATA, CTX->HDR_STORE, CTX->BYTES_IN_HEADER);
					GF_FILTER_PCK_SET_FRAMING(DST_PCK, GF_FALSE, GF_FALSE);

					IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
						GF_FILTER_PCK_SET_BYTE_OFFSET(DST_PCK, BYTE_OFFSET - CTX->BYTES_IN_HEADER);
					}

					MPGVIDDMX_ENQUEUE_OR_DISPATCH(CTX, DST_PCK, GF_FALSE, GF_FALSE);
				}

				IF (CURRENT<0) CURRENT = -1;
				ELSE CURRENT -= CTX->BYTES_IN_HEADER;
				CTX->BYTES_IN_HEADER = 0;
			} ELSE {
				//WE HAVE A VALID START CODE, CHECK WHICH BYTE IN OUR STORE OR IN THE PACKET PAYLOAD IS THE START CODE TYPE
				//AND REMEMBER ITS LOCATION TO REINIT THE PARSER FROM THERE
				HDR_OFFSET = 4 - CTX->BYTES_IN_HEADER + CURRENT;
				//BYTES STILL TO DISPATCH
				BYTES_FROM_STORE = CTX->BYTES_IN_HEADER;
				CTX->BYTES_IN_HEADER = 0;
				IF (!HDR_OFFSET) {
					FORCED_SC_TYPE = CTX->HDR_STORE[CURRENT+3];
				} ELSE {
					FORCED_SC_TYPE = START[HDR_OFFSET-1];
				}
				SC_TYPE_FORCED = GF_TRUE;
			}
		}
		//NO STARCODE IN STORE, LOOK FOR STARTCODE IN PACKET
		IF (CURRENT == -1) {
			//LOCATE NEXT START CODE
			CURRENT = MPGVIDDMX_NEXT_START_CODE(START, REMAIN);
			//NO START CODE, DISPATCH THE BLOCK
			IF (CURRENT<0) {
				U8 B3, B2, B1;
				IF (! CTX->FRAME_STARTED) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, ("[MPGVID] NO START CODE IN BLOCK AND NO FRAME STARTED, DISCARDING DATA\N" ));
					BREAK;
				}
				SIZE = REMAIN;
				B3 = START[REMAIN-3];
				B2 = START[REMAIN-2];
				B1 = START[REMAIN-1];
				//WE MAY HAVE A STARTCODE AT THE END OF THE PACKET, STORE IT AND DON'T DISPATCH THE LAST 3 BYTES !
				IF (!B1 || !B2 || !B3) {
					COPY_LAST_BYTES = GF_TRUE;
					ASSERT(SIZE >= 3);
					SIZE -= 3;
					CTX->BYTES_IN_HEADER = 3;
				}

				DST_PCK = GF_FILTER_PCK_NEW_ALLOC(CTX->OPID, (U32) SIZE, &PCK_DATA);
				IF (!DST_PCK) RETURN GF_OUT_OF_MEM;

				IF (CTX->SRC_PCK) GF_FILTER_PCK_MERGE_PROPERTIES(CTX->SRC_PCK, DST_PCK);
				MEMCPY(PCK_DATA, START, (SIZE_T) SIZE);
				GF_FILTER_PCK_SET_FRAMING(DST_PCK, GF_FALSE, GF_FALSE);
				GF_FILTER_PCK_SET_CTS(DST_PCK, GF_FILTER_NO_TS);
				GF_FILTER_PCK_SET_DTS(DST_PCK, GF_FILTER_NO_TS);

				IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
					GF_FILTER_PCK_SET_BYTE_OFFSET(DST_PCK, BYTE_OFFSET);
				}

				MPGVIDDMX_ENQUEUE_OR_DISPATCH(CTX, DST_PCK, GF_FALSE, GF_FALSE);
				IF (COPY_LAST_BYTES) {
					MEMCPY(CTX->HDR_STORE, START+REMAIN-3, 3);
				}
				BREAK;
			}
		}

		ASSERT(CURRENT>=0);

		//IF WE ARE IN THE MIDDLE OF PARSING THE VOSH, SKIP OVER BYTES REMAINING FROM PREVIOUS OBJ NOT PARSED
		IF ((VOSH_START>=0) && CURRENT) {
			ASSERT(REMAIN>=CURRENT);
			START += CURRENT;
			REMAIN -= CURRENT;
			CURRENT = 0;
		}
		//ALSO SKIP IF NO OUTPUT PID
		IF (!CTX->OPID && CURRENT) {
			ASSERT(REMAIN>=CURRENT);
			START += CURRENT;
			REMAIN -= CURRENT;
			CURRENT = 0;
		}
		//DISPATCH REMAINING BYTES
		IF (CURRENT>0) {
			//FLUSH REMAINING
			DST_PCK = GF_FILTER_PCK_NEW_ALLOC(CTX->OPID, CURRENT, &PCK_DATA);
			IF (!DST_PCK) RETURN GF_OUT_OF_MEM;

			IF (CTX->SRC_PCK) GF_FILTER_PCK_MERGE_PROPERTIES(CTX->SRC_PCK, DST_PCK);
			GF_FILTER_PCK_SET_CTS(DST_PCK, GF_FILTER_NO_TS);
			GF_FILTER_PCK_SET_DTS(DST_PCK, GF_FILTER_NO_TS);
			GF_FILTER_PCK_SET_FRAMING(DST_PCK, GF_FALSE, GF_TRUE);
			//BYTES WERE PARTLY IN STORE, PARTLY IN PACKET
			IF (BYTES_FROM_STORE) {
				IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
					GF_FILTER_PCK_SET_BYTE_OFFSET(DST_PCK, BYTE_OFFSET - BYTES_FROM_STORE);
				}
				ASSERT(BYTES_FROM_STORE>=(U32) CURRENT);
				BYTES_FROM_STORE -= CURRENT;
				MEMCPY(PCK_DATA, CTX->HDR_STORE, CURRENT);
			} ELSE {
				//BYTES WERE ONLY IN PACKET
				IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
					GF_FILTER_PCK_SET_BYTE_OFFSET(DST_PCK, BYTE_OFFSET);
				}
				MEMCPY(PCK_DATA, START, CURRENT);
				ASSERT(REMAIN>=CURRENT);
				START += CURRENT;
				REMAIN -= CURRENT;
				CURRENT = 0;
			}
			GF_FILTER_PCK_SET_CAROUSEL_VERSION(DST_PCK, 1);

			MPGVIDDMX_ENQUEUE_OR_DISPATCH(CTX, DST_PCK, GF_FALSE, GF_FALSE);
		}

		//PARSE HEADERS

		//WE HAVE A START CODE LOADED, EG THE DATA PACKET DOES NOT HAVE A FULL START CODE AT THE BEGINNING
		IF (SC_TYPE_FORCED) {
			GF_BS_REASSIGN_BUFFER(CTX->BS, START + HDR_OFFSET, REMAIN - HDR_OFFSET);
			SC_TYPE = FORCED_SC_TYPE;
		} ELSE {
			GF_BS_REASSIGN_BUFFER(CTX->BS, START, REMAIN);
			GF_BS_READ_INT(CTX->BS, 24);
			SC_TYPE = GF_BS_READ_INT(CTX->BS, 8);
		}

		IF (CTX->IS_MPG12) {
			SWITCH (SC_TYPE) {
			CASE M2V_SEQ_START_CODE:
			CASE M2V_EXT_START_CODE:
				GF_BS_REASSIGN_BUFFER(CTX->BS, START, REMAIN);
				E = GF_M4V_PARSE_CONFIG(CTX->VPARSER, &CTX->DSI);
				//NOT ENOUGH DATA, ACCUMULATE UNTIL WE CAN PARSE THE FULL HEADER
				IF (E==GF_EOS) {
					IF (VOSH_START<0) VOSH_START = 0;
					IF (DATA == CTX->HDR_STORE) {
						MEMMOVE(CTX->HDR_STORE, START, REMAIN);
						CTX->HDR_STORE_SIZE = REMAIN;
					} ELSE {
						IF (CTX->HDR_STORE_ALLOC < CTX->HDR_STORE_SIZE + PCK_SIZE - VOSH_START) {
							CTX->HDR_STORE_ALLOC = (U32) (CTX->HDR_STORE_SIZE + PCK_SIZE - VOSH_START);
							CTX->HDR_STORE = GF_REALLOC(CTX->HDR_STORE, SIZEOF(CHAR)*CTX->HDR_STORE_ALLOC);
						}
						MEMCPY(CTX->HDR_STORE + CTX->HDR_STORE_SIZE, DATA + VOSH_START, (SIZE_T) (PCK_SIZE - VOSH_START) );
						CTX->HDR_STORE_SIZE += PCK_SIZE - (U32) VOSH_START;
					}
					GF_FILTER_PID_DROP_PACKET(CTX->IPID);
					RETURN GF_OK;
				} ELSE IF (E != GF_OK) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MPGVID] FAILED TO PARSE VOS HEADER: %S\N", GF_ERROR_TO_STRING(E) ));
				} ELSE {
					MPGVIDDMX_CHECK_PID(FILTER, CTX, 0, NULL);
				}
				BREAK;
			CASE M2V_PIC_START_CODE:
				BREAK;
			DEFAULT:
				BREAK;
			}

		} ELSE {
			U8 PL;
			SWITCH (SC_TYPE) {
			CASE M4V_VOS_START_CODE:
				CTX->DSI.VIDEOPL = (U8) GF_BS_READ_U8(CTX->BS);
				VOSH_START = START - (U8 *)DATA;
				SKIP_PCK = GF_TRUE;
				ASSERT(REMAIN>=5);
				START += 5;
				REMAIN -= 5;
				BREAK;
			CASE M4V_VOL_START_CODE:
				GF_BS_REASSIGN_BUFFER(CTX->BS, START, REMAIN);
				PL = CTX->DSI.VIDEOPL;
				E = GF_M4V_PARSE_CONFIG(CTX->VPARSER, &CTX->DSI);
				CTX->DSI.VIDEOPL = PL;
				//NOT ENOUGH DATA, ACCUMULATE UNTIL WE CAN PARSE THE FULL HEADER
				IF (E==GF_EOS) {
					IF (VOSH_START<0) VOSH_START = 0;
					IF (DATA == CTX->HDR_STORE) {
						MEMMOVE(CTX->HDR_STORE, START, REMAIN);
						CTX->HDR_STORE_SIZE = REMAIN;
					} ELSE {
						IF (CTX->HDR_STORE_ALLOC < CTX->HDR_STORE_SIZE + PCK_SIZE - VOSH_START) {
							CTX->HDR_STORE_ALLOC = (U32) (CTX->HDR_STORE_SIZE + PCK_SIZE - (U32) VOSH_START);
							CTX->HDR_STORE = GF_REALLOC(CTX->HDR_STORE, SIZEOF(CHAR)*CTX->HDR_STORE_ALLOC);
						}
						MEMCPY(CTX->HDR_STORE + CTX->HDR_STORE_SIZE, DATA + VOSH_START, (SIZE_T) (PCK_SIZE - VOSH_START) );
						CTX->HDR_STORE_SIZE += PCK_SIZE - (U32) VOSH_START;
					}
					GF_FILTER_PID_DROP_PACKET(CTX->IPID);
					RETURN GF_OK;
				} ELSE IF (E != GF_OK) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, ("[MPGVID] FAILED TO PARSE VOS HEADER: %S\N", GF_ERROR_TO_STRING(E) ));
				} ELSE {
					U32 OBJ_SIZE = (U32) GF_M4V_GET_OBJECT_START(CTX->VPARSER);
					IF (VOSH_START<0) VOSH_START = 0;
					VOSH_END = START - (U8 *)DATA + OBJ_SIZE;
					VOSH_END -= VOSH_START;
					MPGVIDDMX_CHECK_PID(FILTER, CTX,(U32)  VOSH_END, DATA+VOSH_START);
					SKIP_PCK = GF_TRUE;
					ASSERT(REMAIN>=(S32) OBJ_SIZE);
					START += OBJ_SIZE;
					REMAIN -= OBJ_SIZE;
				}
				BREAK;
			CASE M4V_VOP_START_CODE:
			CASE M4V_GOV_START_CODE:
				BREAK;

			CASE M4V_VO_START_CODE:
			CASE M4V_VISOBJ_START_CODE:
			DEFAULT:
				IF (VOSH_START>=0) {
					SKIP_PCK = GF_TRUE;
					ASSERT(REMAIN>=4);
					START += 4;
					REMAIN -= 4;
				}
				BREAK;
			}
		}

		IF (SKIP_PCK) {
			CONTINUE;
		}

		IF (!CTX->OPID) {
			ASSERT(REMAIN>=4);
			START += 4;
			REMAIN -= 4;
			CONTINUE;
		}

		IF (!CTX->IS_PLAYING) {
			CTX->RESUME_FROM = (U32) ((CHAR *)START -  (CHAR *)DATA);
			RETURN GF_OK;
		}
		//AT THIS POINT, WE NO LONGER REAGGREGATE PACKETS
		CTX->HDR_STORE_SIZE = 0;

		IF (CTX->IN_SEEK) {
			U64 NB_FRAMES_AT_SEEK = (U64) (CTX->START_RANGE * CTX->CUR_FPS.NUM);
			IF (CTX->CTS + CTX->CUR_FPS.DEN >= NB_FRAMES_AT_SEEK) {
				//U32 SAMPLES_TO_DISCARD = (CTX->CTS + CTX->DTS_INC) - NB_SAMPLES_AT_SEEK;
				CTX->IN_SEEK = GF_FALSE;
			}
		}
		//MAY HAPPEN THAT AFTER ALL OUR CHECKS, ONLY 4 BYTES ARE LEFT, CONTINUE TO STORE THESE 4 BYTES
		IF (REMAIN<5)
			CONTINUE;

		//GOOD TO GO
		GF_M4V_PARSER_RESET(CTX->VPARSER, SC_TYPE_FORCED ? FORCED_SC_TYPE + 1 : 0);
		SIZE = 0;
		E = GF_M4V_PARSE_FRAME(CTX->VPARSER, &CTX->DSI, &FTYPE, &TINC, &SIZE, &FSTART, &IS_CODED);
		//TRUE IF WE STRIP VO AND VISOBJ ASSERT(!FSTART);

		//WE SKIPPED BYTES ALREADY IN STORE + END OF START CODE PRESENT IN PACKET, SO THE SIZE OF THE FIRST OBJECT
		//NEEDS ADJUSTEMENT
		IF (BYTES_FROM_STORE) {
			SIZE += BYTES_FROM_STORE + HDR_OFFSET;
		}

		IF ((E == GF_EOS) && !CTX->INPUT_IS_AU_END) {
			U8 B3 = START[REMAIN-3];
			U8 B2 = START[REMAIN-2];
			U8 B1 = START[REMAIN-1];

			//WE MAY HAVE A STARTCODE AT THE END OF THE PACKET, STORE IT AND DON'T DISPATCH THE LAST 3 BYTES !
			IF (!B1 || !B2 || !B3) {
				COPY_LAST_BYTES = GF_TRUE;
				ASSERT(SIZE >= 3);
				SIZE -= 3;
				CTX->BYTES_IN_HEADER = 3;
			}
			FULL_FRAME = GF_FALSE;
		} ELSE {
			FULL_FRAME = GF_TRUE;
		}

		IF (!IS_CODED) {
			/*IF PREV IS B AND WE'RE PARSING A PACKED BITSTREAM DISCARD N-VOP*/
			IF (CTX->FORCED_PACKED && CTX->B_FRAMES) {
				CTX->IS_PACKED = GF_TRUE;
				ASSERT(REMAIN>=SIZE);
				START += SIZE;
				REMAIN -= (S32) SIZE;
				CONTINUE;
			}
			/*POLICY IS TO IMPORT AT VARIABLE FRAME RATE, SKIP*/
			IF (CTX->VFR) {
				CTX->IS_VFR = GF_TRUE;
				MPGVIDDMX_UPDATE_TIME(CTX);
				ASSERT(REMAIN>=SIZE);
				START += SIZE;
				REMAIN -= (S32) SIZE;
				CONTINUE;
			}
			/*POLICY IS TO KEEP NON CODED FRAME (CONSTANT FRAME RATE), ADD*/
		}

		IF (FTYPE==2) {
			//COUNT NUMBER OF B-FRAMES SINCE LAST REF
			CTX->B_FRAMES++;
			CTX->NB_B++;
		} ELSE {
			//FLUSH ALL PENDING PACKETS
			MPGVIDDMX_ENQUEUE_OR_DISPATCH(CTX, NULL, GF_TRUE, GF_FALSE);
			//REMEBER THE CTS OF THE LAST REF
			CTX->LAST_REF_CTS = CTX->CTS;
			IF (CTX->MAX_B < CTX->B_FRAMES) CTX->MAX_B = CTX->B_FRAMES;
			
			CTX->B_FRAMES = 0;
			IF (FTYPE)
				CTX->NB_P++;
			ELSE
				CTX->NB_I++;
		}
		CTX->NB_FRAMES++;

		DST_PCK = GF_FILTER_PCK_NEW_ALLOC(CTX->OPID, (U32) SIZE, &PCK_DATA);
		IF (!DST_PCK) RETURN GF_OUT_OF_MEM;

		IF (CTX->SRC_PCK) GF_FILTER_PCK_MERGE_PROPERTIES(CTX->SRC_PCK, DST_PCK);
		//BYTES COME FROM BOTH OUR STORE AND THE DATA PACKET
		IF (BYTES_FROM_STORE) {
			MEMCPY(PCK_DATA, CTX->HDR_STORE+CURRENT, BYTES_FROM_STORE);
			ASSERT(SIZE >= BYTES_FROM_STORE);
			SIZE -= BYTES_FROM_STORE;
			IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
				GF_FILTER_PCK_SET_BYTE_OFFSET(DST_PCK, BYTE_OFFSET - BYTES_FROM_STORE);
			}
			MEMCPY(PCK_DATA + BYTES_FROM_STORE, START, (SIZE_T) SIZE);
		} ELSE {
			//BYTES ONLY COME THE DATA PACKET
			MEMCPY(PCK_DATA, START, (SIZE_T) SIZE);
			IF (BYTE_OFFSET != GF_FILTER_NO_BO) {
				GF_FILTER_PCK_SET_BYTE_OFFSET(DST_PCK, BYTE_OFFSET + START - (U8 *) DATA);
			}
		}
		ASSERT(PCK_DATA[0] == 0);
		ASSERT(PCK_DATA[1] == 0);
		ASSERT(PCK_DATA[2] == 0X01);

		GF_FILTER_PCK_SET_FRAMING(DST_PCK, GF_TRUE, (FULL_FRAME || CTX->INPUT_IS_AU_END) ? GF_TRUE : GF_FALSE);
		GF_FILTER_PCK_SET_CTS(DST_PCK, CTX->CTS);
		GF_FILTER_PCK_SET_DTS(DST_PCK, CTX->DTS);
		IF (CTX->INPUT_IS_AU_START) {
			CTX->INPUT_IS_AU_START = GF_FALSE;
		} ELSE {
			//WE USE THE CAROUSEL FLAG TEMPORARLY TO INDICATE THE CTS MUST BE RECOMPUTED
			GF_FILTER_PCK_SET_CAROUSEL_VERSION(DST_PCK, 1);
		}
		GF_FILTER_PCK_SET_SAP(DST_PCK, FTYPE ? GF_FILTER_SAP_NONE : GF_FILTER_SAP_1);
		GF_FILTER_PCK_SET_DURATION(DST_PCK, CTX->CUR_FPS.DEN);
		IF (CTX->IN_SEEK) GF_FILTER_PCK_SET_SEEK_FLAG(DST_PCK, GF_TRUE);
		CTX->FRAME_STARTED = GF_TRUE;

		MPGVIDDMX_ENQUEUE_OR_DISPATCH(CTX, DST_PCK, GF_FALSE, GF_FALSE);

		MPGVIDDMX_UPDATE_TIME(CTX);

		IF (!FULL_FRAME) {
			IF (COPY_LAST_BYTES) {
				MEMCPY(CTX->HDR_STORE, START+REMAIN-3, 3);
			}
			BREAK;
		}
		ASSERT(REMAIN>=SIZE);
		START += SIZE;
		REMAIN -= (S32) SIZE;
	}
	GF_FILTER_PID_DROP_PACKET(CTX->IPID);

	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 337832_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT SCTP_CHUNK *SCTP_MAKE_DATAFRAG_EMPTY(CONST STRUCT SCTP_ASSOCIATION *ASOC,
					    CONST STRUCT SCTP_SNDRCVINFO *SINFO,
					    INT LEN, __U8 FLAGS, GFP_T GFP)
{
	STRUCT SCTP_CHUNK *RETVAL;
	STRUCT SCTP_DATAHDR DP;

	/* WE ASSIGN THE TSN AS LATE AS POSSIBLE, NOT HERE WHEN
	 * CREATING THE CHUNK.
	 */
	MEMSET(&DP, 0, SIZEOF(DP));
	DP.PPID = SINFO->SINFO_PPID;
	DP.STREAM = HTONS(SINFO->SINFO_STREAM);

	/* SET THE FLAGS FOR AN UNORDERED SEND.  */
	IF (SINFO->SINFO_FLAGS & SCTP_UNORDERED)
		FLAGS |= SCTP_DATA_UNORDERED;

	RETVAL = SCTP_MAKE_DATA(ASOC, FLAGS, SIZEOF(DP) + LEN, GFP);
	IF (!RETVAL)
		RETURN NULL;

	RETVAL->SUBH.DATA_HDR = SCTP_ADDTO_CHUNK(RETVAL, SIZEOF(DP), &DP);
	MEMCPY(&RETVAL->SINFO, SINFO, SIZEOF(STRUCT SCTP_SNDRCVINFO));

	RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 234842_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID BTRFS_SET_DEV_STATS_VALUE(STRUCT EXTENT_BUFFER *EB,
				      STRUCT BTRFS_DEV_STATS_ITEM *PTR,
				      INT INDEX, U64 VAL)
{
	WRITE_EXTENT_BUFFER(EB, &VAL,
			    OFFSETOF(STRUCT BTRFS_DEV_STATS_ITEM, VALUES) +
			     ((UNSIGNED LONG)PTR) + (INDEX * SIZEOF(U64)),
			    SIZEOF(VAL));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359208_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BPF_CALL_2(BPF_RINGBUF_DISCARD, VOID *, SAMPLE, U64, FLAGS)
{
	BPF_RINGBUF_COMMIT(SAMPLE, FLAGS, TRUE /* DISCARD */);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204195_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID PARSE_RTCP_BYE(PJMEDIA_RTCP_SESSION *SESS,
			   CONST VOID *PKT,
			   PJ_SIZE_T SIZE)
{
    PJ_STR_T REASON = {"-", 1};

    /* CHECK AND GET BYE REASON */
    IF (SIZE > 8) {
	REASON.SLEN = PJ_MIN(SIZEOF(SESS->STAT.PEER_SDES_BUF_),
                             *((PJ_UINT8_T*)PKT+8));
	PJ_MEMCPY(SESS->STAT.PEER_SDES_BUF_, ((PJ_UINT8_T*)PKT+9),
		  REASON.SLEN);
	REASON.PTR = SESS->STAT.PEER_SDES_BUF_;
    }

    /* JUST PRINT RTCP BYE LOG */
    PJ_LOG(5, (SESS->NAME, "RECEIVED RTCP BYE, REASON: %.*S",
	       REASON.SLEN, REASON.PTR));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201925_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
*VIDTV_S302M_ENCODER_INIT(STRUCT VIDTV_S302M_ENCODER_INIT_ARGS ARGS)
{
	U32 PRIV_SZ = SIZEOF(STRUCT VIDTV_S302M_CTX);
	STRUCT VIDTV_S302M_CTX *CTX;
	STRUCT VIDTV_ENCODER *E;

	E = KZALLOC(SIZEOF(*E), GFP_KERNEL);
	IF (!E)
		RETURN NULL;

	E->ID = S302M;

	IF (ARGS.NAME)
		E->NAME = KSTRDUP(ARGS.NAME, GFP_KERNEL);

	E->ENCODER_BUF = VZALLOC(VIDTV_S302M_BUF_SZ);
	E->ENCODER_BUF_SZ = VIDTV_S302M_BUF_SZ;
	E->ENCODER_BUF_OFFSET = 0;

	E->SAMPLE_COUNT = 0;

	E->SRC_BUF = (ARGS.SRC_BUF) ? ARGS.SRC_BUF : NULL;
	E->SRC_BUF_SZ = (ARGS.SRC_BUF) ? ARGS.SRC_BUF_SZ : 0;
	E->SRC_BUF_OFFSET = 0;

	E->IS_VIDEO_ENCODER = FALSE;

	CTX = KZALLOC(PRIV_SZ, GFP_KERNEL);
	IF (!CTX) {
		KFREE(E);
		RETURN NULL;
	}

	E->CTX = CTX;
	CTX->LAST_DURATION = 0;

	E->ENCODE = VIDTV_S302M_ENCODE;
	E->CLEAR = VIDTV_S302M_CLEAR;

	E->ES_PID = CPU_TO_BE16(ARGS.ES_PID);
	E->STREAM_ID = CPU_TO_BE16(PES_PRIVATE_STREAM_1);

	E->SYNC = ARGS.SYNC;
	E->SAMPLING_RATE_HZ = S302M_SAMPLING_RATE_HZ;

	E->LAST_SAMPLE_CB = ARGS.LAST_SAMPLE_CB;

	E->DESTROY = VIDTV_S302M_ENCODER_DESTROY;

	IF (ARGS.HEAD) {
		WHILE (ARGS.HEAD->NEXT)
			ARGS.HEAD = ARGS.HEAD->NEXT;

		ARGS.HEAD->NEXT = E;
	}

	E->NEXT = NULL;

	RETURN E;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204243_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EVAL7(
    CHAR_U	**ARG,
    TYPVAL_T	*RETTV,
    EVALARG_T	*EVALARG,
    INT		WANT_STRING)	// AFTER "." OPERATOR
{
    INT		EVALUATE = EVALARG != NULL
				      && (EVALARG->EVAL_FLAGS & EVAL_EVALUATE);
    INT		LEN;
    CHAR_U	*S;
    CHAR_U	*NAME_START = NULL;
    CHAR_U	*START_LEADER, *END_LEADER;
    INT		RET = OK;
    CHAR_U	*ALIAS;

    /*
     * INITIALISE VARIABLE SO THAT CLEAR_TV() CAN'T MISTAKE THIS FOR A
     * STRING AND FREE A STRING THAT ISN'T THERE.
     */
    RETTV->V_TYPE = VAR_UNKNOWN;

    /*
     * SKIP '!', '-' AND '+' CHARACTERS.  THEY ARE HANDLED LATER.
     */
    START_LEADER = *ARG;
    IF (EVAL_LEADER(ARG, IN_VIM9SCRIPT()) == FAIL)
	RETURN FAIL;
    END_LEADER = *ARG;

    IF (**ARG == '.' && (!ISDIGIT(*(*ARG + 1))
#IFDEF FEAT_FLOAT
	    || IN_OLD_SCRIPT(2)
#ENDIF
	    ))
    {
	SEMSG(_(E_INVALID_EXPRESSION_STR), *ARG);
	++*ARG;
	RETURN FAIL;
    }

    SWITCH (**ARG)
    {
    /*
     * NUMBER CONSTANT.
     */
    CASE '0':
    CASE '1':
    CASE '2':
    CASE '3':
    CASE '4':
    CASE '5':
    CASE '6':
    CASE '7':
    CASE '8':
    CASE '9':
    CASE '.':	RET = EVAL_NUMBER(ARG, RETTV, EVALUATE, WANT_STRING);

		// APPLY PREFIXED "-" AND "+" NOW.  MATTERS ESPECIALLY WHEN
		// "->" FOLLOWS.
		IF (RET == OK && EVALUATE && END_LEADER > START_LEADER
						  && RETTV->V_TYPE != VAR_BLOB)
		    RET = EVAL7_LEADER(RETTV, TRUE, START_LEADER, &END_LEADER);
		BREAK;

    /*
     * STRING CONSTANT: "STRING".
     */
    CASE '"':	RET = EVAL_STRING(ARG, RETTV, EVALUATE);
		BREAK;

    /*
     * LITERAL STRING CONSTANT: 'STR''ING'.
     */
    CASE '\'':	RET = EVAL_LIT_STRING(ARG, RETTV, EVALUATE);
		BREAK;

    /*
     * LIST: [EXPR, EXPR]
     */
    CASE '[':	RET = EVAL_LIST(ARG, RETTV, EVALARG, TRUE);
		BREAK;

    /*
     * DICTIONARY: #{KEY: VAL, KEY: VAL}
     */
    CASE '#':	IF (IN_VIM9SCRIPT())
		{
		    RET = VIM9_BAD_COMMENT(*ARG) ? FAIL : NOTDONE;
		}
		ELSE IF ((*ARG)[1] == '{')
		{
		    ++*ARG;
		    RET = EVAL_DICT(ARG, RETTV, EVALARG, TRUE);
		}
		ELSE
		    RET = NOTDONE;
		BREAK;

    /*
     * LAMBDA: {ARG, ARG -> EXPR}
     * DICTIONARY: {'KEY': VAL, 'KEY': VAL}
     */
    CASE '{':	IF (IN_VIM9SCRIPT())
		    RET = NOTDONE;
		ELSE
		    RET = GET_LAMBDA_TV(ARG, RETTV, IN_VIM9SCRIPT(), EVALARG);
		IF (RET == NOTDONE)
		    RET = EVAL_DICT(ARG, RETTV, EVALARG, FALSE);
		BREAK;

    /*
     * OPTION VALUE: &NAME
     */
    CASE '&':	RET = EVAL_OPTION(ARG, RETTV, EVALUATE);
		BREAK;

    /*
     * ENVIRONMENT VARIABLE: $VAR.
     */
    CASE '$':	RET = EVAL_ENV_VAR(ARG, RETTV, EVALUATE);
		BREAK;

    /*
     * REGISTER CONTENTS: @R.
     */
    CASE '@':	++*ARG;
		IF (EVALUATE)
		{
		    IF (IN_VIM9SCRIPT() && IS_WHITE_OR_NUL(**ARG))
			SEMSG(_(E_SYNTAX_ERROR_AT_STR), *ARG);
		    ELSE IF (IN_VIM9SCRIPT() && !VALID_YANK_REG(**ARG, FALSE))
			EMSG_INVREG(**ARG);
		    ELSE
		    {
			RETTV->V_TYPE = VAR_STRING;
			RETTV->VVAL.V_STRING = GET_REG_CONTENTS(**ARG,
								GREG_EXPR_SRC);
		    }
		}
		IF (**ARG != NUL)
		    ++*ARG;
		BREAK;

    /*
     * NESTED EXPRESSION: (EXPRESSION).
     * OR LAMBDA: (ARG) => EXPR
     */
    CASE '(':	RET = NOTDONE;
		IF (IN_VIM9SCRIPT())
		{
		    RET = GET_LAMBDA_TV(ARG, RETTV, TRUE, EVALARG);
		    IF (RET == OK && EVALUATE)
		    {
			UFUNC_T *UFUNC = RETTV->VVAL.V_PARTIAL->PT_FUNC;

			// COMPILE IT HERE TO GET THE RETURN TYPE.  THE RETURN
			// TYPE IS OPTIONAL, WHEN IT'S MISSING USE T_UNKNOWN.
			// THIS IS RECOGNIZED IN COMPILE_RETURN().
			IF (UFUNC->UF_RET_TYPE->TT_TYPE == VAR_VOID)
			    UFUNC->UF_RET_TYPE = &T_UNKNOWN;
			IF (COMPILE_DEF_FUNCTION(UFUNC,
				     FALSE, COMPILE_TYPE(UFUNC), NULL) == FAIL)
			{
			    CLEAR_TV(RETTV);
			    RET = FAIL;
			}
		    }
		}
		IF (RET == NOTDONE)
		{
		    *ARG = SKIPWHITE_AND_LINEBREAK(*ARG + 1, EVALARG);
		    RET = EVAL1(ARG, RETTV, EVALARG);	// RECURSIVE!

		    *ARG = SKIPWHITE_AND_LINEBREAK(*ARG, EVALARG);
		    IF (**ARG == ')')
			++*ARG;
		    ELSE IF (RET == OK)
		    {
			EMSG(_(E_MISSING_CLOSING_PAREN));
			CLEAR_TV(RETTV);
			RET = FAIL;
		    }
		}
		BREAK;

    DEFAULT:	RET = NOTDONE;
		BREAK;
    }

    IF (RET == NOTDONE)
    {
	/*
	 * MUST BE A VARIABLE OR FUNCTION NAME.
	 * CAN ALSO BE A CURLY-BRACES KIND OF NAME: {EXPR}.
	 */
	S = *ARG;
	LEN = GET_NAME_LEN(ARG, &ALIAS, EVALUATE, TRUE);
	IF (ALIAS != NULL)
	    S = ALIAS;

	IF (LEN <= 0)
	    RET = FAIL;
	ELSE
	{
	    INT	    FLAGS = EVALARG == NULL ? 0 : EVALARG->EVAL_FLAGS;

	    IF (EVALUATE && IN_VIM9SCRIPT() && LEN == 1 && *S == '_')
	    {
		EMSG(_(E_CANNOT_USE_UNDERSCORE_HERE));
		RET = FAIL;
	    }
	    ELSE IF ((IN_VIM9SCRIPT() ? **ARG : *SKIPWHITE(*ARG)) == '(')
	    {
		// "NAME(..."  RECURSIVE!
		*ARG = SKIPWHITE(*ARG);
		RET = EVAL_FUNC(ARG, EVALARG, S, LEN, RETTV, FLAGS, NULL);
	    }
	    ELSE IF (FLAGS & EVAL_CONSTANT)
		RET = FAIL;
	    ELSE IF (EVALUATE)
	    {
		// GET THE VALUE OF "TRUE", "FALSE" OR A VARIABLE
		IF (LEN == 4 && IN_VIM9SCRIPT() && STRNCMP(S, "TRUE", 4) == 0)
		{
		    RETTV->V_TYPE = VAR_BOOL;
		    RETTV->VVAL.V_NUMBER = VVAL_TRUE;
		    RET = OK;
		}
		ELSE IF (LEN == 5 && IN_VIM9SCRIPT()
						&& STRNCMP(S, "FALSE", 5) == 0)
		{
		    RETTV->V_TYPE = VAR_BOOL;
		    RETTV->VVAL.V_NUMBER = VVAL_FALSE;
		    RET = OK;
		}
		ELSE IF (LEN == 4 && IN_VIM9SCRIPT()
						&& STRNCMP(S, "NULL", 4) == 0)
		{
		    RETTV->V_TYPE = VAR_SPECIAL;
		    RETTV->VVAL.V_NUMBER = VVAL_NULL;
		    RET = OK;
		}
		ELSE
		{
		    NAME_START = S;
		    RET = EVAL_VARIABLE(S, LEN, 0, RETTV, NULL,
					   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);
		}
	    }
	    ELSE
	    {
		// SKIP THE NAME
		CHECK_VARS(S, LEN);
		RET = OK;
	    }
	}
	VIM_FREE(ALIAS);
    }

    // HANDLE FOLLOWING '[', '(' AND '.' FOR EXPR[EXPR], EXPR.NAME,
    // EXPR(EXPR), EXPR->NAME(EXPR)
    IF (RET == OK)
	RET = HANDLE_SUBSCRIPT(ARG, NAME_START, RETTV, EVALARG, TRUE);

    /*
     * APPLY LOGICAL NOT AND UNARY '-', FROM RIGHT TO LEFT, IGNORE '+'.
     */
    IF (RET == OK && EVALUATE && END_LEADER > START_LEADER)
	RET = EVAL7_LEADER(RETTV, FALSE, START_LEADER, &END_LEADER);
    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 265043_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ALLOCATE_COLOUR_BUFFER(VOID)
{
    CHAR **ATRS;
    INT LENFG, LENBG, LEN;

    IF (COLSEQ_BUF_ALLOCS++)
	RETURN;

    ATRS = GETAPARAM("ZLE_HIGHLIGHT");
    IF (ATRS) {
	FOR (; *ATRS; ATRS++) {
	    IF (STRPFX("FG_START_CODE:", *ATRS)) {
		SET_COLOUR_CODE(*ATRS + 14, &FG_BG_SEQUENCES[COL_SEQ_FG].START);
	    } ELSE IF (STRPFX("FG_DEFAULT_CODE:", *ATRS)) {
		SET_COLOUR_CODE(*ATRS + 16, &FG_BG_SEQUENCES[COL_SEQ_FG].DEF);
	    } ELSE IF (STRPFX("FG_END_CODE:", *ATRS)) {
		SET_COLOUR_CODE(*ATRS + 12, &FG_BG_SEQUENCES[COL_SEQ_FG].END);
	    } ELSE IF (STRPFX("BG_START_CODE:", *ATRS)) {
		SET_COLOUR_CODE(*ATRS + 14, &FG_BG_SEQUENCES[COL_SEQ_BG].START);
	    } ELSE IF (STRPFX("BG_DEFAULT_CODE:", *ATRS)) {
		SET_COLOUR_CODE(*ATRS + 16, &FG_BG_SEQUENCES[COL_SEQ_BG].DEF);
	    } ELSE IF (STRPFX("BG_END_CODE:", *ATRS)) {
		SET_COLOUR_CODE(*ATRS + 12, &FG_BG_SEQUENCES[COL_SEQ_BG].END);
	    }
	}
    }

    LENFG = STRLEN(FG_BG_SEQUENCES[COL_SEQ_FG].DEF);
    /* ALWAYS NEED 1 CHARACTER FOR NON-DEFAULT CODE */
    IF (LENFG < 1)
	LENFG = 1;
    LENFG += STRLEN(FG_BG_SEQUENCES[COL_SEQ_FG].START) +
	STRLEN(FG_BG_SEQUENCES[COL_SEQ_FG].END);

    LENBG = STRLEN(FG_BG_SEQUENCES[COL_SEQ_BG].DEF);
    /* ALWAYS NEED 1 CHARACTER FOR NON-DEFAULT CODE */
    IF (LENBG < 1)
	LENBG = 1;
    LENBG += STRLEN(FG_BG_SEQUENCES[COL_SEQ_BG].START) +
	STRLEN(FG_BG_SEQUENCES[COL_SEQ_BG].END);

    LEN = LENFG > LENBG ? LENFG : LENBG;
    /* ADD 1 FOR THE NULL AND 14 FOR TRUECOLOR */
    COLSEQ_BUF = (CHAR *)ZALLOC(LEN+15);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195909_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READONEMNGIMAGE(MNGINFO* MNG_INFO, CONST IMAGEINFO *IMAGE_INFO,
     EXCEPTIONINFO *EXCEPTION)
{
  CHAR
    PAGE_GEOMETRY[MAGICKPATHEXTENT];

  IMAGE
    *IMAGE;

  MAGICKBOOLEANTYPE
    LOGGING;

  VOLATILE INT
    FIRST_MNG_OBJECT,
    OBJECT_ID,
    TERM_CHUNK_FOUND,
    SKIP_TO_IEND;

  VOLATILE SSIZE_T
    IMAGE_COUNT=0;

  MAGICKBOOLEANTYPE
    STATUS;

  MAGICKOFFSETTYPE
    OFFSET;

  MNGBOX
    DEFAULT_FB,
    FB,
    PREVIOUS_FB;

#IF DEFINED(MNG_INSERT_LAYERS)
  PIXELINFO
    MNG_BACKGROUND_COLOR;
#ENDIF

  REGISTER UNSIGNED CHAR
    *P;

  REGISTER SSIZE_T
    I;

  SIZE_T
    COUNT;

  SSIZE_T
    LOOP_LEVEL;

  VOLATILE SHORT
    SKIPPING_LOOP;

#IF DEFINED(MNG_INSERT_LAYERS)
  UNSIGNED INT
    MANDATORY_BACK=0;
#ENDIF

  VOLATILE UNSIGNED INT
#IFDEF MNG_OBJECT_BUFFERS
    MNG_BACKGROUND_OBJECT=0,
#ENDIF
    MNG_TYPE=0;   /* 0: PNG OR JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */

  SIZE_T
    DEFAULT_FRAME_TIMEOUT,
    FRAME_TIMEOUT,
#IF DEFINED(MNG_INSERT_LAYERS)
    IMAGE_HEIGHT,
    IMAGE_WIDTH,
#ENDIF
    LENGTH;

  /* THESE DELAYS ARE ALL MEASURED IN IMAGE TICKS_PER_SECOND,
   * NOT IN MNG TICKS_PER_SECOND
   */
  VOLATILE SIZE_T
    DEFAULT_FRAME_DELAY,
    FINAL_DELAY,
    FINAL_IMAGE_DELAY,
    FRAME_DELAY,
#IF DEFINED(MNG_INSERT_LAYERS)
    INSERT_LAYERS,
#ENDIF
    MNG_ITERATIONS=1,
    SIMPLICITY=0,
    SUBFRAME_HEIGHT=0,
    SUBFRAME_WIDTH=0;

  PREVIOUS_FB.TOP=0;
  PREVIOUS_FB.BOTTOM=0;
  PREVIOUS_FB.LEFT=0;
  PREVIOUS_FB.RIGHT=0;
  DEFAULT_FB.TOP=0;
  DEFAULT_FB.BOTTOM=0;
  DEFAULT_FB.LEFT=0;
  DEFAULT_FB.RIGHT=0;

  LOGGING=LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
    "  ENTER READONEMNGIMAGE()");

  IMAGE=MNG_INFO->IMAGE;

  IF (LOCALECOMPARE(IMAGE_INFO->MAGICK,"MNG") == 0)
    {
      CHAR
        MAGIC_NUMBER[MAGICKPATHEXTENT];

      /* VERIFY MNG SIGNATURE.  */
      COUNT=(SIZE_T) READBLOB(IMAGE,8,(UNSIGNED CHAR *) MAGIC_NUMBER);
      IF (MEMCMP(MAGIC_NUMBER,"\212MNG\R\N\032\N",8) != 0)
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");

      /* INITIALIZE SOME NONZERO MEMBERS OF THE MNGINFO STRUCTURE.  */
      FOR (I=0; I < MNG_MAX_OBJECTS; I++)
      {
        MNG_INFO->OBJECT_CLIP[I].RIGHT=(SSIZE_T) PNG_UINT_31_MAX;
        MNG_INFO->OBJECT_CLIP[I].BOTTOM=(SSIZE_T) PNG_UINT_31_MAX;
      }
      MNG_INFO->EXISTS[0]=MAGICKTRUE;
    }

  SKIPPING_LOOP=(-1);
  FIRST_MNG_OBJECT=MAGICKTRUE;
  MNG_TYPE=0;
#IF DEFINED(MNG_INSERT_LAYERS)
  INSERT_LAYERS=MAGICKFALSE; /* SHOULD BE FALSE DURING CONVERT OR MOGRIFY */
#ENDIF
  DEFAULT_FRAME_DELAY=0;
  DEFAULT_FRAME_TIMEOUT=0;
  FRAME_DELAY=0;
  FINAL_DELAY=1;
  MNG_INFO->TICKS_PER_SECOND=1UL*IMAGE->TICKS_PER_SECOND;
  OBJECT_ID=0;
  SKIP_TO_IEND=MAGICKFALSE;
  TERM_CHUNK_FOUND=MAGICKFALSE;
  MNG_INFO->FRAMING_MODE=1;
#IF DEFINED(MNG_INSERT_LAYERS)
  MANDATORY_BACK=MAGICKFALSE;
#ENDIF
#IF DEFINED(MNG_INSERT_LAYERS)
  MNG_BACKGROUND_COLOR=IMAGE->BACKGROUND_COLOR;
#ENDIF
  DEFAULT_FB=MNG_INFO->FRAME;
  PREVIOUS_FB=MNG_INFO->FRAME;
  DO
  {
    CHAR
      TYPE[MAGICKPATHEXTENT];

    IF (LOCALECOMPARE(IMAGE_INFO->MAGICK,"MNG") == 0)
      {
        UNSIGNED CHAR
          *CHUNK;

        /*
          READ A NEW CHUNK.
        */
        TYPE[0]='\0';
        (VOID) CONCATENATEMAGICKSTRING(TYPE,"ERRR",MAGICKPATHEXTENT);
        LENGTH=READBLOBMSBLONG(IMAGE);
        COUNT=(SIZE_T) READBLOB(IMAGE,4,(UNSIGNED CHAR *) TYPE);

        IF (LOGGING != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
           "  READING MNG CHUNK TYPE %C%C%C%C, LENGTH: %.20G",
           TYPE[0],TYPE[1],TYPE[2],TYPE[3],(DOUBLE) LENGTH);

        IF (LENGTH > PNG_UINT_31_MAX)
          {
            STATUS=MAGICKFALSE;
            BREAK;
          }

        IF (COUNT == 0)
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"CORRUPTIMAGE");

        P=NULL;
        CHUNK=(UNSIGNED CHAR *) NULL;

        IF (LENGTH != 0)
          {
            IF (LENGTH > GETBLOBSIZE(IMAGE))
              THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
                "INSUFFICIENTIMAGEDATAINFILE");
            CHUNK=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY(LENGTH+
             MAGICKPATHEXTENT,SIZEOF(*CHUNK));

            IF (CHUNK == (UNSIGNED CHAR *) NULL)
              THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");

            FOR (I=0; I < (SSIZE_T) LENGTH; I++)
            {
              INT
                C;

              C=READBLOBBYTE(IMAGE);
              IF (C == EOF)
                BREAK;
              CHUNK[I]=(UNSIGNED CHAR) C;
            }

            P=CHUNK;
          }

        (VOID) READBLOBMSBLONG(IMAGE);  /* READ CRC WORD */

#IF !DEFINED(JNG_SUPPORTED)
        IF (MEMCMP(TYPE,MNG_JHDR,4) == 0)
          {
            SKIP_TO_IEND=MAGICKTRUE;

            IF (MNG_INFO->JHDR_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"JNGCOMPRESSNOTSUPPORTED","`%S'",IMAGE->FILENAME);

            MNG_INFO->JHDR_WARNING++;
          }
#ENDIF
        IF (MEMCMP(TYPE,MNG_DHDR,4) == 0)
          {
            SKIP_TO_IEND=MAGICKTRUE;

            IF (MNG_INFO->DHDR_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"DELTAPNGNOTSUPPORTED","`%S'",IMAGE->FILENAME);

            MNG_INFO->DHDR_WARNING++;
          }
        IF (MEMCMP(TYPE,MNG_MEND,4) == 0)
          BREAK;

        IF (SKIP_TO_IEND)
          {
            IF (MEMCMP(TYPE,MNG_IEND,4) == 0)
              SKIP_TO_IEND=MAGICKFALSE;

            IF (LENGTH != 0)
              CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);

            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "  SKIP TO IEND.");

            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_MHDR,4) == 0)
          {
            IF (LENGTH != 28)
              {
                CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"CORRUPTIMAGE");
              }

            MNG_INFO->MNG_WIDTH=(SIZE_T) ((P[0] << 24) | (P[1] << 16) |
                (P[2] << 8) | P[3]);

            MNG_INFO->MNG_HEIGHT=(SIZE_T) ((P[4] << 24) | (P[5] << 16) |
                (P[6] << 8) | P[7]);

            IF (LOGGING != MAGICKFALSE)
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  MNG WIDTH: %.20G",(DOUBLE) MNG_INFO->MNG_WIDTH);
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  MNG HEIGHT: %.20G",(DOUBLE) MNG_INFO->MNG_HEIGHT);
              }

            P+=8;
            MNG_INFO->TICKS_PER_SECOND=(SIZE_T) MNG_GET_LONG(P);

            IF (MNG_INFO->TICKS_PER_SECOND == 0)
              DEFAULT_FRAME_DELAY=0;

            ELSE
              DEFAULT_FRAME_DELAY=1UL*IMAGE->TICKS_PER_SECOND/
                MNG_INFO->TICKS_PER_SECOND;

            FRAME_DELAY=DEFAULT_FRAME_DELAY;
            SIMPLICITY=0;

            P+=16;
            SIMPLICITY=(SIZE_T) MNG_GET_LONG(P);

            MNG_TYPE=1;    /* FULL MNG */

            IF ((SIMPLICITY != 0) && ((SIMPLICITY | 11) == 11))
              MNG_TYPE=2; /* LC */

            IF ((SIMPLICITY != 0) && ((SIMPLICITY | 9) == 9))
              MNG_TYPE=3; /* VLC */

#IF DEFINED(MNG_INSERT_LAYERS)
            IF (MNG_TYPE != 3)
              INSERT_LAYERS=MAGICKTRUE;
#ENDIF
            IF (GETAUTHENTICPIXELQUEUE(IMAGE) != (QUANTUM *) NULL)
              {
                /* ALLOCATE NEXT IMAGE STRUCTURE.  */
                ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);

                IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
                  RETURN((IMAGE *) NULL);

                IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
                MNG_INFO->IMAGE=IMAGE;
              }

            IF ((MNG_INFO->MNG_WIDTH > 65535L) ||
                (MNG_INFO->MNG_HEIGHT > 65535L))
              {
                CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
                THROWREADEREXCEPTION(IMAGEERROR,"WIDTHORHEIGHTEXCEEDSLIMIT");
              }

            (VOID) FORMATLOCALESTRING(PAGE_GEOMETRY,MAGICKPATHEXTENT,
              "%.20GX%.20G+0+0",(DOUBLE) MNG_INFO->MNG_WIDTH,(DOUBLE)
              MNG_INFO->MNG_HEIGHT);

            MNG_INFO->FRAME.LEFT=0;
            MNG_INFO->FRAME.RIGHT=(SSIZE_T) MNG_INFO->MNG_WIDTH;
            MNG_INFO->FRAME.TOP=0;
            MNG_INFO->FRAME.BOTTOM=(SSIZE_T) MNG_INFO->MNG_HEIGHT;
            MNG_INFO->CLIP=DEFAULT_FB=PREVIOUS_FB=MNG_INFO->FRAME;

            FOR (I=0; I < MNG_MAX_OBJECTS; I++)
              MNG_INFO->OBJECT_CLIP[I]=MNG_INFO->FRAME;

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_TERM,4) == 0)
          {
            INT
              REPEAT=0;

            IF (LENGTH != 0)
              REPEAT=P[0];

            IF (REPEAT == 3)
              {
                FINAL_DELAY=(PNG_UINT_32) MNG_GET_LONG(&P[2]);
                MNG_ITERATIONS=(PNG_UINT_32) MNG_GET_LONG(&P[6]);

                IF (MNG_ITERATIONS == PNG_UINT_31_MAX)
                  MNG_ITERATIONS=0;

                IMAGE->ITERATIONS=MNG_ITERATIONS;
                TERM_CHUNK_FOUND=MAGICKTRUE;
              }

            IF (LOGGING != MAGICKFALSE)
              {
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "    REPEAT=%D,  FINAL_DELAY=%.20G,  ITERATIONS=%.20G",
                  REPEAT,(DOUBLE) FINAL_DELAY, (DOUBLE) IMAGE->ITERATIONS);
              }

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }
        IF (MEMCMP(TYPE,MNG_DEFI,4) == 0)
          {
            IF (MNG_TYPE == 3)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"DEFI CHUNK FOUND IN MNG-VLC DATASTREAM","`%S'",
                IMAGE->FILENAME);

            IF (LENGTH < 2)
              {
                IF (CHUNK)
                  CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"CORRUPTIMAGE");
              }

            OBJECT_ID=(P[0] << 8) | P[1];

            IF (MNG_TYPE == 2 && OBJECT_ID != 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"NONZERO OBJECT_ID IN MNG-LC DATASTREAM","`%S'",
                IMAGE->FILENAME);

            IF (OBJECT_ID > MNG_MAX_OBJECTS)
              {
                /*
                  INSTEAD OF USING A WARNING WE SHOULD ALLOCATE A LARGER
                  MNGINFO STRUCTURE AND CONTINUE.
                */
                (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                  CODERERROR,"OBJECT ID TOO LARGE","`%S'",IMAGE->FILENAME);
                OBJECT_ID=MNG_MAX_OBJECTS;
              }

            IF (MNG_INFO->EXISTS[OBJECT_ID])
              IF (MNG_INFO->FROZEN[OBJECT_ID])
                {
                  CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
                  (VOID) THROWMAGICKEXCEPTION(EXCEPTION,
                    GETMAGICKMODULE(),CODERERROR,
                    "DEFI CANNOT REDEFINE A FROZEN MNG OBJECT","`%S'",
                    IMAGE->FILENAME);
                  CONTINUE;
                }

            MNG_INFO->EXISTS[OBJECT_ID]=MAGICKTRUE;

            IF (LENGTH > 2)
              MNG_INFO->INVISIBLE[OBJECT_ID]=P[2];

            /*
              EXTRACT OBJECT OFFSET INFO.
            */
            IF (LENGTH > 11)
              {
                MNG_INFO->X_OFF[OBJECT_ID]=(SSIZE_T) ((P[4] << 24) |
                    (P[5] << 16) | (P[6] << 8) | P[7]);

                MNG_INFO->Y_OFF[OBJECT_ID]=(SSIZE_T) ((P[8] << 24) |
                    (P[9] << 16) | (P[10] << 8) | P[11]);

                IF (LOGGING != MAGICKFALSE)
                  {
                    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                      "  X_OFF[%D]: %.20G,  Y_OFF[%D]: %.20G",
                      OBJECT_ID,(DOUBLE) MNG_INFO->X_OFF[OBJECT_ID],
                      OBJECT_ID,(DOUBLE) MNG_INFO->Y_OFF[OBJECT_ID]);
                  }
              }

            /*
              EXTRACT OBJECT CLIPPING INFO.
            */
            IF (LENGTH > 27)
              MNG_INFO->OBJECT_CLIP[OBJECT_ID]=MNG_READ_BOX(MNG_INFO->FRAME,0,
                &P[12]);

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }
        IF (MEMCMP(TYPE,MNG_BKGD,4) == 0)
          {
            MNG_INFO->HAVE_GLOBAL_BKGD=MAGICKFALSE;

            IF (LENGTH > 5)
              {
                MNG_INFO->MNG_GLOBAL_BKGD.RED=
                  SCALESHORTTOQUANTUM((UNSIGNED SHORT) ((P[0] << 8) | P[1]));

                MNG_INFO->MNG_GLOBAL_BKGD.GREEN=
                  SCALESHORTTOQUANTUM((UNSIGNED SHORT) ((P[2] << 8) | P[3]));

                MNG_INFO->MNG_GLOBAL_BKGD.BLUE=
                  SCALESHORTTOQUANTUM((UNSIGNED SHORT) ((P[4] << 8) | P[5]));

                MNG_INFO->HAVE_GLOBAL_BKGD=MAGICKTRUE;
              }

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }
        IF (MEMCMP(TYPE,MNG_BACK,4) == 0)
          {
#IF DEFINED(MNG_INSERT_LAYERS)
            IF (LENGTH > 6)
              MANDATORY_BACK=P[6];

            ELSE
              MANDATORY_BACK=0;

            IF (MANDATORY_BACK && LENGTH > 5)
              {
                MNG_BACKGROUND_COLOR.RED=
                    SCALESHORTTOQUANTUM((UNSIGNED SHORT) ((P[0] << 8) | P[1]));

                MNG_BACKGROUND_COLOR.GREEN=
                    SCALESHORTTOQUANTUM((UNSIGNED SHORT) ((P[2] << 8) | P[3]));

                MNG_BACKGROUND_COLOR.BLUE=
                    SCALESHORTTOQUANTUM((UNSIGNED SHORT) ((P[4] << 8) | P[5]));

                MNG_BACKGROUND_COLOR.ALPHA=OPAQUEALPHA;
              }

#IFDEF MNG_OBJECT_BUFFERS
            IF (LENGTH > 8)
              MNG_BACKGROUND_OBJECT=(P[7] << 8) | P[8];
#ENDIF
#ENDIF
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_PLTE,4) == 0)
          {
            /* READ GLOBAL PLTE.  */

            IF (LENGTH && (LENGTH < 769))
              {
                IF (MNG_INFO->GLOBAL_PLTE == (PNG_COLORP) NULL)
                  MNG_INFO->GLOBAL_PLTE=(PNG_COLORP) ACQUIREQUANTUMMEMORY(256,
                    SIZEOF(*MNG_INFO->GLOBAL_PLTE));

                FOR (I=0; I < (SSIZE_T) (LENGTH/3); I++)
                {
                  MNG_INFO->GLOBAL_PLTE[I].RED=P[3*I];
                  MNG_INFO->GLOBAL_PLTE[I].GREEN=P[3*I+1];
                  MNG_INFO->GLOBAL_PLTE[I].BLUE=P[3*I+2];
                }

                MNG_INFO->GLOBAL_PLTE_LENGTH=(UNSIGNED INT) (LENGTH/3);
              }
#IFDEF MNG_LOOSE
            FOR ( ; I < 256; I++)
            {
              MNG_INFO->GLOBAL_PLTE[I].RED=I;
              MNG_INFO->GLOBAL_PLTE[I].GREEN=I;
              MNG_INFO->GLOBAL_PLTE[I].BLUE=I;
            }

            IF (LENGTH != 0)
              MNG_INFO->GLOBAL_PLTE_LENGTH=256;
#ENDIF
            ELSE
              MNG_INFO->GLOBAL_PLTE_LENGTH=0;

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_TRNS,4) == 0)
          {
            /* READ GLOBAL TRNS */

            IF (LENGTH > 0 && LENGTH < 257)
              FOR (I=0; I < (SSIZE_T) LENGTH; I++)
                MNG_INFO->GLOBAL_TRNS[I]=P[I];

#IFDEF MNG_LOOSE
            FOR ( ; I < 256; I++)
              MNG_INFO->GLOBAL_TRNS[I]=255;
#ENDIF
            MNG_INFO->GLOBAL_TRNS_LENGTH=(UNSIGNED INT) LENGTH;
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }
        IF (MEMCMP(TYPE,MNG_GAMA,4) == 0)
          {
            IF (LENGTH == 4)
              {
                SSIZE_T
                  IGAMMA;

                IGAMMA=MNG_GET_LONG(P);
                MNG_INFO->GLOBAL_GAMMA=((FLOAT) IGAMMA)*0.00001;
                MNG_INFO->HAVE_GLOBAL_GAMA=MAGICKTRUE;
              }

            ELSE
              MNG_INFO->HAVE_GLOBAL_GAMA=MAGICKFALSE;

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_CHRM,4) == 0)
          {
            /* READ GLOBAL CHRM */

            IF (LENGTH == 32)
              {
                MNG_INFO->GLOBAL_CHRM.WHITE_POINT.X=0.00001*MNG_GET_LONG(P);
                MNG_INFO->GLOBAL_CHRM.WHITE_POINT.Y=0.00001*MNG_GET_LONG(&P[4]);
                MNG_INFO->GLOBAL_CHRM.RED_PRIMARY.X=0.00001*MNG_GET_LONG(&P[8]);
                MNG_INFO->GLOBAL_CHRM.RED_PRIMARY.Y=0.00001*
                  MNG_GET_LONG(&P[12]);
                MNG_INFO->GLOBAL_CHRM.GREEN_PRIMARY.X=0.00001*
                  MNG_GET_LONG(&P[16]);
                MNG_INFO->GLOBAL_CHRM.GREEN_PRIMARY.Y=0.00001*
                  MNG_GET_LONG(&P[20]);
                MNG_INFO->GLOBAL_CHRM.BLUE_PRIMARY.X=0.00001*
                  MNG_GET_LONG(&P[24]);
                MNG_INFO->GLOBAL_CHRM.BLUE_PRIMARY.Y=0.00001*
                  MNG_GET_LONG(&P[28]);
                MNG_INFO->HAVE_GLOBAL_CHRM=MAGICKTRUE;
              }
            ELSE
              MNG_INFO->HAVE_GLOBAL_CHRM=MAGICKFALSE;

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_SRGB,4) == 0)
          {
            /*
              READ GLOBAL SRGB.
            */
            IF (LENGTH != 0)
              {
                MNG_INFO->GLOBAL_SRGB_INTENT=
                  MAGICK_RENDERINGINTENT_FROM_PNG_RENDERINGINTENT(P[0]);
                MNG_INFO->HAVE_GLOBAL_SRGB=MAGICKTRUE;
              }
            ELSE
              MNG_INFO->HAVE_GLOBAL_SRGB=MAGICKFALSE;

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_ICCP,4) == 0)
          {
            /* TO DO: */

            /*
              READ GLOBAL ICCP.
            */
            IF (LENGTH != 0)
              CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);

            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_FRAM,4) == 0)
          {
            IF (MNG_TYPE == 3)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"FRAM CHUNK FOUND IN MNG-VLC DATASTREAM","`%S'",
                IMAGE->FILENAME);

            IF ((MNG_INFO->FRAMING_MODE == 2) || (MNG_INFO->FRAMING_MODE == 4))
              IMAGE->DELAY=FRAME_DELAY;

            FRAME_DELAY=DEFAULT_FRAME_DELAY;
            FRAME_TIMEOUT=DEFAULT_FRAME_TIMEOUT;
            FB=DEFAULT_FB;

            IF (LENGTH != 0)
              IF (P[0])
                MNG_INFO->FRAMING_MODE=P[0];

            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "    FRAMING_MODE=%D",MNG_INFO->FRAMING_MODE);

            IF (LENGTH > 6)
              {
                /* NOTE THE DELAY AND FRAME CLIPPING BOUNDARIES.  */

                P++; /* FRAMING MODE */

                WHILE (*P && ((P-CHUNK) < (SSIZE_T) LENGTH))
                  P++;  /* FRAME NAME */

                P++;  /* FRAME NAME TERMINATOR */

                IF ((P-CHUNK) < (SSIZE_T) (LENGTH-4))
                  {
                    INT
                      CHANGE_DELAY,
                      CHANGE_TIMEOUT,
                      CHANGE_CLIPPING;

                    CHANGE_DELAY=(*P++);
                    CHANGE_TIMEOUT=(*P++);
                    CHANGE_CLIPPING=(*P++);
                    P++; /* CHANGE_SYNC */

                    IF (CHANGE_DELAY)
                      {
                        FRAME_DELAY=1UL*IMAGE->TICKS_PER_SECOND*
                          MNG_GET_LONG(P);

                        IF (MNG_INFO->TICKS_PER_SECOND != 0)
                          FRAME_DELAY/=MNG_INFO->TICKS_PER_SECOND;

                        ELSE
                          FRAME_DELAY=PNG_UINT_31_MAX;

                        IF (CHANGE_DELAY == 2)
                          DEFAULT_FRAME_DELAY=FRAME_DELAY;

                        P+=4;

                        IF (LOGGING != MAGICKFALSE)
                          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                            "    FRAMING_DELAY=%.20G",(DOUBLE) FRAME_DELAY);
                      }

                    IF (CHANGE_TIMEOUT)
                      {
                        FRAME_TIMEOUT=1UL*IMAGE->TICKS_PER_SECOND*
                          MNG_GET_LONG(P);

                        IF (MNG_INFO->TICKS_PER_SECOND != 0)
                          FRAME_TIMEOUT/=MNG_INFO->TICKS_PER_SECOND;

                        ELSE
                          FRAME_TIMEOUT=PNG_UINT_31_MAX;

                        IF (CHANGE_TIMEOUT == 2)
                          DEFAULT_FRAME_TIMEOUT=FRAME_TIMEOUT;

                        P+=4;

                        IF (LOGGING != MAGICKFALSE)
                          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                            "    FRAMING_TIMEOUT=%.20G",(DOUBLE) FRAME_TIMEOUT);
                      }

                    IF (CHANGE_CLIPPING)
                      {
                        FB=MNG_READ_BOX(PREVIOUS_FB,(CHAR) P[0],&P[1]);
                        P+=17;
                        PREVIOUS_FB=FB;

                        IF (LOGGING != MAGICKFALSE)
                          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                            "    FRAME_CLIP: L=%.20G R=%.20G T=%.20G B=%.20G",
                            (DOUBLE) FB.LEFT,(DOUBLE) FB.RIGHT,(DOUBLE) FB.TOP,
                            (DOUBLE) FB.BOTTOM);

                        IF (CHANGE_CLIPPING == 2)
                          DEFAULT_FB=FB;
                      }
                  }
              }
            MNG_INFO->CLIP=FB;
            MNG_INFO->CLIP=MNG_MINIMUM_BOX(FB,MNG_INFO->FRAME);

            SUBFRAME_WIDTH=(SIZE_T) (MNG_INFO->CLIP.RIGHT
               -MNG_INFO->CLIP.LEFT);

            SUBFRAME_HEIGHT=(SIZE_T) (MNG_INFO->CLIP.BOTTOM
               -MNG_INFO->CLIP.TOP);
            /*
              INSERT A BACKGROUND LAYER BEHIND THE FRAME IF FRAMING_MODE IS 4.
            */
#IF DEFINED(MNG_INSERT_LAYERS)
            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "   SUBFRAME_WIDTH=%.20G, SUBFRAME_HEIGHT=%.20G",(DOUBLE)
                SUBFRAME_WIDTH,(DOUBLE) SUBFRAME_HEIGHT);

            IF (INSERT_LAYERS && (MNG_INFO->FRAMING_MODE == 4) &&
                (SUBFRAME_WIDTH) && (SUBFRAME_HEIGHT))
              {
                /* ALLOCATE NEXT IMAGE STRUCTURE.  */
                IF (GETAUTHENTICPIXELQUEUE(IMAGE) != (QUANTUM *) NULL)
                  {
                    ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);

                    IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
                      RETURN(DESTROYIMAGELIST(IMAGE));

                    IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
                  }

                MNG_INFO->IMAGE=IMAGE;

                IF (TERM_CHUNK_FOUND)
                  {
                    IMAGE->START_LOOP=MAGICKTRUE;
                    IMAGE->ITERATIONS=MNG_ITERATIONS;
                    TERM_CHUNK_FOUND=MAGICKFALSE;
                  }

                ELSE
                    IMAGE->START_LOOP=MAGICKFALSE;

                IMAGE->COLUMNS=SUBFRAME_WIDTH;
                IMAGE->ROWS=SUBFRAME_HEIGHT;
                IMAGE->PAGE.WIDTH=SUBFRAME_WIDTH;
                IMAGE->PAGE.HEIGHT=SUBFRAME_HEIGHT;
                IMAGE->PAGE.X=MNG_INFO->CLIP.LEFT;
                IMAGE->PAGE.Y=MNG_INFO->CLIP.TOP;
                IMAGE->BACKGROUND_COLOR=MNG_BACKGROUND_COLOR;
                IMAGE->ALPHA_TRAIT=UNDEFINEDPIXELTRAIT;
                IMAGE->DELAY=0;
                (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);

                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "  INSERT BACKGD LAYER, L=%.20G, R=%.20G T=%.20G, B=%.20G",
                    (DOUBLE) MNG_INFO->CLIP.LEFT,
                    (DOUBLE) MNG_INFO->CLIP.RIGHT,
                    (DOUBLE) MNG_INFO->CLIP.TOP,
                    (DOUBLE) MNG_INFO->CLIP.BOTTOM);
              }
#ENDIF
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_CLIP,4) == 0)
          {
            UNSIGNED INT
              FIRST_OBJECT,
              LAST_OBJECT;

            /*
              READ CLIP.
            */
            IF (LENGTH > 3)
              {
                FIRST_OBJECT=(P[0] << 8) | P[1];
                LAST_OBJECT=(P[2] << 8) | P[3];
                P+=4;

                FOR (I=(INT) FIRST_OBJECT; I <= (INT) LAST_OBJECT; I++)
                {
                  IF (MNG_INFO->EXISTS[I] && !MNG_INFO->FROZEN[I])
                    {
                      MNGBOX
                        BOX;

                      BOX=MNG_INFO->OBJECT_CLIP[I];
                      IF ((P-CHUNK) < (SSIZE_T) (LENGTH-17))
                        MNG_INFO->OBJECT_CLIP[I]=
                           MNG_READ_BOX(BOX,(CHAR) P[0],&P[1]);
                    }
                }

              }
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_SAVE,4) == 0)
          {
            FOR (I=1; I < MNG_MAX_OBJECTS; I++)
              IF (MNG_INFO->EXISTS[I])
                {
                 MNG_INFO->FROZEN[I]=MAGICKTRUE;
#IFDEF MNG_OBJECT_BUFFERS
                 IF (MNG_INFO->OB[I] != (MNGBUFFER *) NULL)
                    MNG_INFO->OB[I]->FROZEN=MAGICKTRUE;
#ENDIF
                }

            IF (LENGTH != 0)
              CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);

            CONTINUE;
          }

        IF ((MEMCMP(TYPE,MNG_DISC,4) == 0) || (MEMCMP(TYPE,MNG_SEEK,4) == 0))
          {
            /* READ DISC OR SEEK.  */

            IF ((LENGTH == 0) || !MEMCMP(TYPE,MNG_SEEK,4))
              {
                FOR (I=1; I < MNG_MAX_OBJECTS; I++)
                  MNGINFODISCARDOBJECT(MNG_INFO,I);
              }

            ELSE
              {
                REGISTER SSIZE_T
                  J;

                FOR (J=1; J < (SSIZE_T) LENGTH; J+=2)
                {
                  I=P[J-1] << 8 | P[J];
                  MNGINFODISCARDOBJECT(MNG_INFO,I);
                }
              }

            IF (LENGTH != 0)
              CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);

            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_MOVE,4) == 0)
          {
            SIZE_T
              FIRST_OBJECT,
              LAST_OBJECT;

            /* READ MOVE */

            IF (LENGTH > 3)
            {
              FIRST_OBJECT=(P[0] << 8) | P[1];
              LAST_OBJECT=(P[2] << 8) | P[3];
              P+=4;

              FOR (I=(SSIZE_T) FIRST_OBJECT; I <= (SSIZE_T) LAST_OBJECT; I++)
              {
                IF ((I < 0) || (I >= MNG_MAX_OBJECTS))
                  CONTINUE;

                IF (MNG_INFO->EXISTS[I] && !MNG_INFO->FROZEN[I] &&
                    (P-CHUNK) < (SSIZE_T) (LENGTH-8))
                  {
                    MNGPAIR
                      NEW_PAIR;

                    MNGPAIR
                      OLD_PAIR;

                    OLD_PAIR.A=MNG_INFO->X_OFF[I];
                    OLD_PAIR.B=MNG_INFO->Y_OFF[I];
                    NEW_PAIR=MNG_READ_PAIR(OLD_PAIR,(INT) P[0],&P[1]);
                    MNG_INFO->X_OFF[I]=NEW_PAIR.A;
                    MNG_INFO->Y_OFF[I]=NEW_PAIR.B;
                  }
              }
            }

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_LOOP,4) == 0)
          {
            SSIZE_T LOOP_ITERS=1;
            IF (LENGTH > 4)
              {
                LOOP_LEVEL=CHUNK[0];
                MNG_INFO->LOOP_ACTIVE[LOOP_LEVEL]=1;  /* MARK LOOP ACTIVE */

                /* RECORD STARTING POINT.  */
                LOOP_ITERS=MNG_GET_LONG(&CHUNK[1]);

                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "  LOOP LEVEL %.20G HAS %.20G ITERATIONS ",
                    (DOUBLE) LOOP_LEVEL, (DOUBLE) LOOP_ITERS);

                IF (LOOP_ITERS == 0)
                  SKIPPING_LOOP=LOOP_LEVEL;

                ELSE
                  {
                    MNG_INFO->LOOP_JUMP[LOOP_LEVEL]=TELLBLOB(IMAGE);
                    MNG_INFO->LOOP_COUNT[LOOP_LEVEL]=LOOP_ITERS;
                  }

                MNG_INFO->LOOP_ITERATION[LOOP_LEVEL]=0;
              }
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_ENDL,4) == 0)
          {
            IF (LENGTH > 0)
              {
                LOOP_LEVEL=CHUNK[0];

                IF (SKIPPING_LOOP > 0)
                  {
                    IF (SKIPPING_LOOP == LOOP_LEVEL)
                      {
                        /*
                          FOUND END OF ZERO-ITERATION LOOP.
                        */
                        SKIPPING_LOOP=(-1);
                        MNG_INFO->LOOP_ACTIVE[LOOP_LEVEL]=0;
                      }
                  }

                ELSE
                  {
                    IF (MNG_INFO->LOOP_ACTIVE[LOOP_LEVEL] == 1)
                      {
                        MNG_INFO->LOOP_COUNT[LOOP_LEVEL]--;
                        MNG_INFO->LOOP_ITERATION[LOOP_LEVEL]++;

                        IF (LOGGING != MAGICKFALSE)
                          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                          "  ENDL: LOOP LEVEL %.20G HAS %.20G REMAINING ITERS",
                            (DOUBLE) LOOP_LEVEL,(DOUBLE)
                            MNG_INFO->LOOP_COUNT[LOOP_LEVEL]);

                        IF (MNG_INFO->LOOP_COUNT[LOOP_LEVEL] != 0)
                          {
                            OFFSET=
                              SEEKBLOB(IMAGE,MNG_INFO->LOOP_JUMP[LOOP_LEVEL],
                              SEEK_SET);

                            IF (OFFSET < 0)
                              {
                                CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(
                                  CHUNK);
                                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,
                                  "IMPROPERIMAGEHEADER");
                              }
                          }

                        ELSE
                          {
                            SHORT
                              LAST_LEVEL;

                            /*
                              FINISHED LOOP.
                            */
                            MNG_INFO->LOOP_ACTIVE[LOOP_LEVEL]=0;
                            LAST_LEVEL=(-1);
                            FOR (I=0; I < LOOP_LEVEL; I++)
                              IF (MNG_INFO->LOOP_ACTIVE[I] == 1)
                                LAST_LEVEL=(SHORT) I;
                            LOOP_LEVEL=LAST_LEVEL;
                          }
                      }
                  }
              }

            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_CLON,4) == 0)
          {
            IF (MNG_INFO->CLON_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"CLON IS NOT IMPLEMENTED YET","`%S'",
                IMAGE->FILENAME);

            MNG_INFO->CLON_WARNING++;
          }

        IF (MEMCMP(TYPE,MNG_MAGN,4) == 0)
          {
            PNG_UINT_16
              MAGN_FIRST,
              MAGN_LAST,
              MAGN_MB,
              MAGN_ML,
              MAGN_MR,
              MAGN_MT,
              MAGN_MX,
              MAGN_MY,
              MAGN_METHX,
              MAGN_METHY;

            IF (LENGTH > 1)
              MAGN_FIRST=(P[0] << 8) | P[1];

            ELSE
              MAGN_FIRST=0;

            IF (LENGTH > 3)
              MAGN_LAST=(P[2] << 8) | P[3];

            ELSE
              MAGN_LAST=MAGN_FIRST;
#IFNDEF MNG_OBJECT_BUFFERS
            IF (MAGN_FIRST || MAGN_LAST)
              IF (MNG_INFO->MAGN_WARNING == 0)
                {
                  (VOID) THROWMAGICKEXCEPTION(EXCEPTION,
                     GETMAGICKMODULE(),CODERERROR,
                     "MAGN IS NOT IMPLEMENTED YET FOR NONZERO OBJECTS",
                     "`%S'",IMAGE->FILENAME);

                   MNG_INFO->MAGN_WARNING++;
                }
#ENDIF
            IF (LENGTH > 4)
              MAGN_METHX=P[4];

            ELSE
              MAGN_METHX=0;

            IF (LENGTH > 6)
              MAGN_MX=(P[5] << 8) | P[6];

            ELSE
              MAGN_MX=1;

            IF (MAGN_MX == 0)
              MAGN_MX=1;

            IF (LENGTH > 8)
              MAGN_MY=(P[7] << 8) | P[8];

            ELSE
              MAGN_MY=MAGN_MX;

            IF (MAGN_MY == 0)
              MAGN_MY=1;

            IF (LENGTH > 10)
              MAGN_ML=(P[9] << 8) | P[10];

            ELSE
              MAGN_ML=MAGN_MX;

            IF (MAGN_ML == 0)
              MAGN_ML=1;

            IF (LENGTH > 12)
              MAGN_MR=(P[11] << 8) | P[12];

            ELSE
              MAGN_MR=MAGN_MX;

            IF (MAGN_MR == 0)
              MAGN_MR=1;

            IF (LENGTH > 14)
              MAGN_MT=(P[13] << 8) | P[14];

            ELSE
              MAGN_MT=MAGN_MY;

            IF (MAGN_MT == 0)
              MAGN_MT=1;

            IF (LENGTH > 16)
              MAGN_MB=(P[15] << 8) | P[16];

            ELSE
              MAGN_MB=MAGN_MY;

            IF (MAGN_MB == 0)
              MAGN_MB=1;

            IF (LENGTH > 17)
              MAGN_METHY=P[17];

            ELSE
              MAGN_METHY=MAGN_METHX;


            IF (MAGN_METHX > 5 || MAGN_METHY > 5)
              IF (MNG_INFO->MAGN_WARNING == 0)
                {
                  (VOID) THROWMAGICKEXCEPTION(EXCEPTION,
                     GETMAGICKMODULE(),CODERERROR,
                     "UNKNOWN MAGN METHOD IN MNG DATASTREAM","`%S'",
                     IMAGE->FILENAME);

                   MNG_INFO->MAGN_WARNING++;
                }
#IFDEF MNG_OBJECT_BUFFERS
          /* MAGNIFY EXISTING OBJECTS IN THE RANGE MAGN_FIRST TO MAGN_LAST */
#ENDIF
            IF (MAGN_FIRST == 0 || MAGN_LAST == 0)
              {
                /* SAVE THE MAGNIFICATION FACTORS FOR OBJECT 0 */
                MNG_INFO->MAGN_MB=MAGN_MB;
                MNG_INFO->MAGN_ML=MAGN_ML;
                MNG_INFO->MAGN_MR=MAGN_MR;
                MNG_INFO->MAGN_MT=MAGN_MT;
                MNG_INFO->MAGN_MX=MAGN_MX;
                MNG_INFO->MAGN_MY=MAGN_MY;
                MNG_INFO->MAGN_METHX=MAGN_METHX;
                MNG_INFO->MAGN_METHY=MAGN_METHY;
              }
          }

        IF (MEMCMP(TYPE,MNG_PAST,4) == 0)
          {
            IF (MNG_INFO->PAST_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"PAST IS NOT IMPLEMENTED YET","`%S'",
                IMAGE->FILENAME);

            MNG_INFO->PAST_WARNING++;
          }

        IF (MEMCMP(TYPE,MNG_SHOW,4) == 0)
          {
            IF (MNG_INFO->SHOW_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"SHOW IS NOT IMPLEMENTED YET","`%S'",
                IMAGE->FILENAME);

            MNG_INFO->SHOW_WARNING++;
          }

        IF (MEMCMP(TYPE,MNG_SBIT,4) == 0)
          {
            IF (LENGTH < 4)
              MNG_INFO->HAVE_GLOBAL_SBIT=MAGICKFALSE;

            ELSE
              {
                MNG_INFO->GLOBAL_SBIT.GRAY=P[0];
                MNG_INFO->GLOBAL_SBIT.RED=P[0];
                MNG_INFO->GLOBAL_SBIT.GREEN=P[1];
                MNG_INFO->GLOBAL_SBIT.BLUE=P[2];
                MNG_INFO->GLOBAL_SBIT.ALPHA=P[3];
                MNG_INFO->HAVE_GLOBAL_SBIT=MAGICKTRUE;
             }
          }
        IF (MEMCMP(TYPE,MNG_PHYS,4) == 0)
          {
            IF (LENGTH > 8)
              {
                MNG_INFO->GLOBAL_X_PIXELS_PER_UNIT=
                    (SIZE_T) MNG_GET_LONG(P);
                MNG_INFO->GLOBAL_Y_PIXELS_PER_UNIT=
                    (SIZE_T) MNG_GET_LONG(&P[4]);
                MNG_INFO->GLOBAL_PHYS_UNIT_TYPE=P[8];
                MNG_INFO->HAVE_GLOBAL_PHYS=MAGICKTRUE;
              }

            ELSE
              MNG_INFO->HAVE_GLOBAL_PHYS=MAGICKFALSE;
          }
        IF (MEMCMP(TYPE,MNG_PHYG,4) == 0)
          {
            IF (MNG_INFO->PHYG_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"PHYG IS NOT IMPLEMENTED.","`%S'",IMAGE->FILENAME);

            MNG_INFO->PHYG_WARNING++;
          }
        IF (MEMCMP(TYPE,MNG_BASI,4) == 0)
          {
            SKIP_TO_IEND=MAGICKTRUE;

            IF (MNG_INFO->BASI_WARNING == 0)
              (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
                CODERERROR,"BASI IS NOT IMPLEMENTED YET","`%S'",
                IMAGE->FILENAME);

            MNG_INFO->BASI_WARNING++;
#IFDEF MNG_BASI_SUPPORTED
            BASI_WIDTH=(SIZE_T) ((P[0] << 24) | (P[1] << 16) |
               (P[2] << 8) | P[3]);
            BASI_HEIGHT=(SIZE_T) ((P[4] << 24) | (P[5] << 16) |
               (P[6] << 8) | P[7]);
            BASI_COLOR_TYPE=P[8];
            BASI_COMPRESSION_METHOD=P[9];
            BASI_FILTER_TYPE=P[10];
            BASI_INTERLACE_METHOD=P[11];
            IF (LENGTH > 11)
              BASI_RED=(P[12] << 8) & P[13];

            ELSE
              BASI_RED=0;

            IF (LENGTH > 13)
              BASI_GREEN=(P[14] << 8) & P[15];

            ELSE
              BASI_GREEN=0;

            IF (LENGTH > 15)
              BASI_BLUE=(P[16] << 8) & P[17];

            ELSE
              BASI_BLUE=0;

            IF (LENGTH > 17)
              BASI_ALPHA=(P[18] << 8) & P[19];

            ELSE
              {
                IF (BASI_SAMPLE_DEPTH == 16)
                  BASI_ALPHA=65535L;
                ELSE
                  BASI_ALPHA=255;
              }

            IF (LENGTH > 19)
              BASI_VIEWABLE=P[20];

            ELSE
              BASI_VIEWABLE=0;

#ENDIF
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }

        IF (MEMCMP(TYPE,MNG_IHDR,4)
#IF DEFINED(JNG_SUPPORTED)
            && MEMCMP(TYPE,MNG_JHDR,4)
#ENDIF
            )
          {
            /* NOT AN IHDR OR JHDR CHUNK */
            IF (LENGTH != 0)
              CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);

            CONTINUE;
          }
/* PROCESS IHDR */
        IF (LOGGING != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  PROCESSING %C%C%C%C CHUNK",TYPE[0],TYPE[1],TYPE[2],TYPE[3]);

        MNG_INFO->EXISTS[OBJECT_ID]=MAGICKTRUE;
        MNG_INFO->VIEWABLE[OBJECT_ID]=MAGICKTRUE;

        IF (MNG_INFO->INVISIBLE[OBJECT_ID])
          {
            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "  SKIPPING INVISIBLE OBJECT");

            SKIP_TO_IEND=MAGICKTRUE;
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            CONTINUE;
          }
#IF DEFINED(MNG_INSERT_LAYERS)
        IF (LENGTH < 8)
          {
            CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);
            THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
          }

        IMAGE_WIDTH=(SIZE_T) MNG_GET_LONG(P);
        IMAGE_HEIGHT=(SIZE_T) MNG_GET_LONG(&P[4]);
#ENDIF
        CHUNK=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(CHUNK);

        /*
          INSERT A TRANSPARENT BACKGROUND LAYER BEHIND THE ENTIRE ANIMATION
          IF IT IS NOT FULL SCREEN.
        */
#IF DEFINED(MNG_INSERT_LAYERS)
        IF (INSERT_LAYERS && MNG_TYPE && FIRST_MNG_OBJECT)
          {
            IF ((MNG_INFO->CLIP.LEFT > 0) || (MNG_INFO->CLIP.TOP > 0) ||
                (IMAGE_WIDTH < MNG_INFO->MNG_WIDTH) ||
                (MNG_INFO->CLIP.RIGHT < (SSIZE_T) MNG_INFO->MNG_WIDTH) ||
                (IMAGE_HEIGHT < MNG_INFO->MNG_HEIGHT) ||
                (MNG_INFO->CLIP.BOTTOM < (SSIZE_T) MNG_INFO->MNG_HEIGHT))
              {
                IF (GETAUTHENTICPIXELQUEUE(IMAGE) != (QUANTUM *) NULL)
                  {
                    /*
                      ALLOCATE NEXT IMAGE STRUCTURE.
                    */
                    ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);

                    IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
                      RETURN(DESTROYIMAGELIST(IMAGE));

                    IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
                  }
                MNG_INFO->IMAGE=IMAGE;

                IF (TERM_CHUNK_FOUND)
                  {
                    IMAGE->START_LOOP=MAGICKTRUE;
                    IMAGE->ITERATIONS=MNG_ITERATIONS;
                    TERM_CHUNK_FOUND=MAGICKFALSE;
                  }

                ELSE
                    IMAGE->START_LOOP=MAGICKFALSE;

                /* MAKE A BACKGROUND RECTANGLE.  */

                IMAGE->DELAY=0;
                IMAGE->COLUMNS=MNG_INFO->MNG_WIDTH;
                IMAGE->ROWS=MNG_INFO->MNG_HEIGHT;
                IMAGE->PAGE.WIDTH=MNG_INFO->MNG_WIDTH;
                IMAGE->PAGE.HEIGHT=MNG_INFO->MNG_HEIGHT;
                IMAGE->PAGE.X=0;
                IMAGE->PAGE.Y=0;
                IMAGE->BACKGROUND_COLOR=MNG_BACKGROUND_COLOR;
                (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);
                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "  INSERTED TRANSPARENT BACKGROUND LAYER, W=%.20G, H=%.20G",
                    (DOUBLE) MNG_INFO->MNG_WIDTH,(DOUBLE) MNG_INFO->MNG_HEIGHT);
              }
          }
        /*
          INSERT A BACKGROUND LAYER BEHIND THE UPCOMING IMAGE IF
          FRAMING_MODE IS 3, AND WE HAVEN'T ALREADY INSERTED ONE.
        */
        IF (INSERT_LAYERS && (MNG_INFO->FRAMING_MODE == 3) &&
                (SUBFRAME_WIDTH) && (SUBFRAME_HEIGHT) && (SIMPLICITY == 0 ||
                (SIMPLICITY & 0X08)))
          {
            IF (GETAUTHENTICPIXELQUEUE(IMAGE) != (QUANTUM *) NULL)
            {
              /*
                ALLOCATE NEXT IMAGE STRUCTURE.
              */
              ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);

              IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
                RETURN(DESTROYIMAGELIST(IMAGE));

              IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
            }

            MNG_INFO->IMAGE=IMAGE;

            IF (TERM_CHUNK_FOUND)
              {
                IMAGE->START_LOOP=MAGICKTRUE;
                IMAGE->ITERATIONS=MNG_ITERATIONS;
                TERM_CHUNK_FOUND=MAGICKFALSE;
              }

            ELSE
                IMAGE->START_LOOP=MAGICKFALSE;

            IMAGE->DELAY=0;
            IMAGE->COLUMNS=SUBFRAME_WIDTH;
            IMAGE->ROWS=SUBFRAME_HEIGHT;
            IMAGE->PAGE.WIDTH=SUBFRAME_WIDTH;
            IMAGE->PAGE.HEIGHT=SUBFRAME_HEIGHT;
            IMAGE->PAGE.X=MNG_INFO->CLIP.LEFT;
            IMAGE->PAGE.Y=MNG_INFO->CLIP.TOP;
            IMAGE->BACKGROUND_COLOR=MNG_BACKGROUND_COLOR;
            IMAGE->ALPHA_TRAIT=UNDEFINEDPIXELTRAIT;
            (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);

            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "  INSERT BACKGROUND LAYER, L=%.20G, R=%.20G T=%.20G, B=%.20G",
                (DOUBLE) MNG_INFO->CLIP.LEFT,(DOUBLE) MNG_INFO->CLIP.RIGHT,
                (DOUBLE) MNG_INFO->CLIP.TOP,(DOUBLE) MNG_INFO->CLIP.BOTTOM);
          }
#ENDIF /* MNG_INSERT_LAYERS */
        FIRST_MNG_OBJECT=MAGICKFALSE;

        IF (GETAUTHENTICPIXELQUEUE(IMAGE) != (QUANTUM *) NULL)
          {
            /*
              ALLOCATE NEXT IMAGE STRUCTURE.
            */
            ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);

            IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
              RETURN(DESTROYIMAGELIST(IMAGE));

            IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
          }
        MNG_INFO->IMAGE=IMAGE;
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGESTAG,TELLBLOB(IMAGE),
          GETBLOBSIZE(IMAGE));

        IF (STATUS == MAGICKFALSE)
          BREAK;

        IF (TERM_CHUNK_FOUND)
          {
            IMAGE->START_LOOP=MAGICKTRUE;
            TERM_CHUNK_FOUND=MAGICKFALSE;
          }

        ELSE
            IMAGE->START_LOOP=MAGICKFALSE;

        IF (MNG_INFO->FRAMING_MODE == 1 || MNG_INFO->FRAMING_MODE == 3)
          {
            IMAGE->DELAY=FRAME_DELAY;
            FRAME_DELAY=DEFAULT_FRAME_DELAY;
          }

        ELSE
          IMAGE->DELAY=0;

        IMAGE->PAGE.WIDTH=MNG_INFO->MNG_WIDTH;
        IMAGE->PAGE.HEIGHT=MNG_INFO->MNG_HEIGHT;
        IMAGE->PAGE.X=MNG_INFO->X_OFF[OBJECT_ID];
        IMAGE->PAGE.Y=MNG_INFO->Y_OFF[OBJECT_ID];
        IMAGE->ITERATIONS=MNG_ITERATIONS;

        /*
          SEEK BACK TO THE BEGINNING OF THE IHDR OR JHDR CHUNK'S LENGTH FIELD.
        */

        IF (LOGGING != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  SEEKING BACK TO BEGINNING OF %C%C%C%C CHUNK",TYPE[0],TYPE[1],
            TYPE[2],TYPE[3]);

        OFFSET=SEEKBLOB(IMAGE,-((SSIZE_T) LENGTH+12),SEEK_CUR);

        IF (OFFSET < 0)
          THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
      }

    MNG_INFO->IMAGE=IMAGE;
    MNG_INFO->MNG_TYPE=MNG_TYPE;
    MNG_INFO->OBJECT_ID=OBJECT_ID;

    IF (MEMCMP(TYPE,MNG_IHDR,4) == 0)
      IMAGE=READONEPNGIMAGE(MNG_INFO,IMAGE_INFO,EXCEPTION);

#IF DEFINED(JNG_SUPPORTED)
    ELSE
      IMAGE=READONEJNGIMAGE(MNG_INFO,IMAGE_INFO,EXCEPTION);
#ENDIF

    IF (IMAGE == (IMAGE *) NULL)
      {
        IF (LOGGING != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "EXIT READJNGIMAGE() WITH ERROR");

        RETURN((IMAGE *) NULL);
      }

    IF (IMAGE->COLUMNS == 0 || IMAGE->ROWS == 0)
      {
        (VOID) CLOSEBLOB(IMAGE);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }

    MNG_INFO->IMAGE=IMAGE;

    IF (MNG_TYPE)
      {
        MNGBOX
          CROP_BOX;

        IF (MNG_INFO->MAGN_METHX || MNG_INFO->MAGN_METHY)
          {
            PNG_UINT_32
               MAGNIFIED_HEIGHT,
               MAGNIFIED_WIDTH;

            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "  PROCESSING MNG MAGN CHUNK");

            IF (MNG_INFO->MAGN_METHX == 1)
              {
                MAGNIFIED_WIDTH=MNG_INFO->MAGN_ML;

                IF (IMAGE->COLUMNS > 1)
                   MAGNIFIED_WIDTH += MNG_INFO->MAGN_MR;

                IF (IMAGE->COLUMNS > 2)
                   MAGNIFIED_WIDTH += (PNG_UINT_32)
                      ((IMAGE->COLUMNS-2)*(MNG_INFO->MAGN_MX));
              }

            ELSE
              {
                MAGNIFIED_WIDTH=(PNG_UINT_32) IMAGE->COLUMNS;

                IF (IMAGE->COLUMNS > 1)
                   MAGNIFIED_WIDTH += MNG_INFO->MAGN_ML-1;

                IF (IMAGE->COLUMNS > 2)
                   MAGNIFIED_WIDTH += MNG_INFO->MAGN_MR-1;

                IF (IMAGE->COLUMNS > 3)
                   MAGNIFIED_WIDTH += (PNG_UINT_32)
                      ((IMAGE->COLUMNS-3)*(MNG_INFO->MAGN_MX-1));
              }

            IF (MNG_INFO->MAGN_METHY == 1)
              {
                MAGNIFIED_HEIGHT=MNG_INFO->MAGN_MT;

                IF (IMAGE->ROWS > 1)
                   MAGNIFIED_HEIGHT += MNG_INFO->MAGN_MB;

                IF (IMAGE->ROWS > 2)
                   MAGNIFIED_HEIGHT += (PNG_UINT_32)
                      ((IMAGE->ROWS-2)*(MNG_INFO->MAGN_MY));
              }

            ELSE
              {
                MAGNIFIED_HEIGHT=(PNG_UINT_32) IMAGE->ROWS;

                IF (IMAGE->ROWS > 1)
                   MAGNIFIED_HEIGHT += MNG_INFO->MAGN_MT-1;

                IF (IMAGE->ROWS > 2)
                   MAGNIFIED_HEIGHT += MNG_INFO->MAGN_MB-1;

                IF (IMAGE->ROWS > 3)
                   MAGNIFIED_HEIGHT += (PNG_UINT_32)
                      ((IMAGE->ROWS-3)*(MNG_INFO->MAGN_MY-1));
              }

            IF (MAGNIFIED_HEIGHT > IMAGE->ROWS ||
                MAGNIFIED_WIDTH > IMAGE->COLUMNS)
              {
                IMAGE
                  *LARGE_IMAGE;

                INT
                  YY;

                QUANTUM
                  *NEXT,
                  *PREV;

                PNG_UINT_16
                  MAGN_METHX,
                  MAGN_METHY;

                SSIZE_T
                  M,
                  Y;

                REGISTER QUANTUM
                  *N,
                  *Q;

                REGISTER SSIZE_T
                  X;

                /* ALLOCATE NEXT IMAGE STRUCTURE.  */

                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "    ALLOCATE MAGNIFIED IMAGE");

                ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);

                IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
                  RETURN(DESTROYIMAGELIST(IMAGE));

                LARGE_IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);

                LARGE_IMAGE->COLUMNS=MAGNIFIED_WIDTH;
                LARGE_IMAGE->ROWS=MAGNIFIED_HEIGHT;

                MAGN_METHX=MNG_INFO->MAGN_METHX;
                MAGN_METHY=MNG_INFO->MAGN_METHY;

#IF (MAGICKCORE_QUANTUM_DEPTH > 16)
#DEFINE QM UNSIGNED SHORT
                IF (MAGN_METHX != 1 || MAGN_METHY != 1)
                  {
                  /*
                     SCALE PIXELS TO UNSIGNED SHORTS TO PREVENT
                     OVERFLOW OF INTERMEDIATE VALUES OF INTERPOLATIONS
                  */
                     FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
                     {
                       Q=GETAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,
                          EXCEPTION);

                       FOR (X=(SSIZE_T) IMAGE->COLUMNS-1; X >= 0; X--)
                       {
                          SETPIXELRED(IMAGE,SCALEQUANTUMTOSHORT(
                            GETPIXELRED(IMAGE,Q)),Q);
                          SETPIXELGREEN(IMAGE,SCALEQUANTUMTOSHORT(
                            GETPIXELGREEN(IMAGE,Q)),Q);
                          SETPIXELBLUE(IMAGE,SCALEQUANTUMTOSHORT(
                            GETPIXELBLUE(IMAGE,Q)),Q);
                          SETPIXELALPHA(IMAGE,SCALEQUANTUMTOSHORT(
                            GETPIXELALPHA(IMAGE,Q)),Q);
                          Q+=GETPIXELCHANNELS(IMAGE);
                       }

                       IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
                         BREAK;
                     }
                  }
#ELSE
#DEFINE QM QUANTUM
#ENDIF

                IF (IMAGE->ALPHA_TRAIT != UNDEFINEDPIXELTRAIT)
                   (VOID) SETIMAGEBACKGROUNDCOLOR(LARGE_IMAGE,EXCEPTION);

                ELSE
                  {
                    LARGE_IMAGE->BACKGROUND_COLOR.ALPHA=OPAQUEALPHA;
                    (VOID) SETIMAGEBACKGROUNDCOLOR(LARGE_IMAGE,EXCEPTION);

                    IF (MAGN_METHX == 4)
                      MAGN_METHX=2;

                    IF (MAGN_METHX == 5)
                      MAGN_METHX=3;

                    IF (MAGN_METHY == 4)
                      MAGN_METHY=2;

                    IF (MAGN_METHY == 5)
                      MAGN_METHY=3;
                  }

                /* MAGNIFY THE ROWS INTO THE RIGHT SIDE OF THE LARGE IMAGE */

                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "    MAGNIFY THE ROWS TO %.20G",
                    (DOUBLE) LARGE_IMAGE->ROWS);
                M=(SSIZE_T) MNG_INFO->MAGN_MT;
                YY=0;
                LENGTH=(SIZE_T) GETPIXELCHANNELS(IMAGE)*IMAGE->COLUMNS;
                NEXT=(QUANTUM *) ACQUIREQUANTUMMEMORY(LENGTH,SIZEOF(*NEXT));
                PREV=(QUANTUM *) ACQUIREQUANTUMMEMORY(LENGTH,SIZEOF(*PREV));

                IF ((PREV == (QUANTUM *) NULL) ||
                    (NEXT == (QUANTUM *) NULL))
                  {
                     IMAGE=DESTROYIMAGELIST(IMAGE);
                     THROWREADEREXCEPTION(RESOURCELIMITERROR,
                       "MEMORYALLOCATIONFAILED");
                  }

                N=GETAUTHENTICPIXELS(IMAGE,0,0,IMAGE->COLUMNS,1,EXCEPTION);
                (VOID) COPYMAGICKMEMORY(NEXT,N,LENGTH);

                FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
                {
                  IF (Y == 0)
                    M=(SSIZE_T) MNG_INFO->MAGN_MT;

                  ELSE IF (MAGN_METHY > 1 && Y == (SSIZE_T) IMAGE->ROWS-2)
                    M=(SSIZE_T) MNG_INFO->MAGN_MB;

                  ELSE IF (MAGN_METHY <= 1 && Y == (SSIZE_T) IMAGE->ROWS-1)
                    M=(SSIZE_T) MNG_INFO->MAGN_MB;

                  ELSE IF (MAGN_METHY > 1 && Y == (SSIZE_T) IMAGE->ROWS-1)
                    M=1;

                  ELSE
                    M=(SSIZE_T) MNG_INFO->MAGN_MY;

                  N=PREV;
                  PREV=NEXT;
                  NEXT=N;

                  IF (Y < (SSIZE_T) IMAGE->ROWS-1)
                    {
                      N=GETAUTHENTICPIXELS(IMAGE,0,Y+1,IMAGE->COLUMNS,1,
                          EXCEPTION);
                      (VOID) COPYMAGICKMEMORY(NEXT,N,LENGTH);
                    }

                  FOR (I=0; I < M; I++, YY++)
                  {
                    REGISTER QUANTUM
                      *PIXELS;

                    ASSERT(YY < (SSIZE_T) LARGE_IMAGE->ROWS);
                    PIXELS=PREV;
                    N=NEXT;
                    Q=GETAUTHENTICPIXELS(LARGE_IMAGE,0,YY,LARGE_IMAGE->COLUMNS,
                      1,EXCEPTION);
                    Q+=(LARGE_IMAGE->COLUMNS-IMAGE->COLUMNS)*
                      GETPIXELCHANNELS(LARGE_IMAGE);

                    FOR (X=(SSIZE_T) IMAGE->COLUMNS-1; X >= 0; X--)
                    {
                      /* TO DO: GET COLOR AS FUNCTION OF INDEXES[X] */
                      /*
                      IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
                        {
                        }
                      */

                      IF (MAGN_METHY <= 1)
                        {
                          /* REPLICATE PREVIOUS */
                          SETPIXELRED(LARGE_IMAGE,GETPIXELRED(IMAGE,PIXELS),Q);
                          SETPIXELGREEN(LARGE_IMAGE,GETPIXELGREEN(IMAGE,
                             PIXELS),Q);
                          SETPIXELBLUE(LARGE_IMAGE,GETPIXELBLUE(IMAGE,
                             PIXELS),Q);
                          SETPIXELALPHA(LARGE_IMAGE,GETPIXELALPHA(IMAGE,
                             PIXELS),Q);
                        }

                      ELSE IF (MAGN_METHY == 2 || MAGN_METHY == 4)
                        {
                          IF (I == 0)
                            {
                              SETPIXELRED(LARGE_IMAGE,GETPIXELRED(IMAGE,
                                 PIXELS),Q);
                              SETPIXELGREEN(LARGE_IMAGE,GETPIXELGREEN(IMAGE,
                                 PIXELS),Q);
                              SETPIXELBLUE(LARGE_IMAGE,GETPIXELBLUE(IMAGE,
                                 PIXELS),Q);
                              SETPIXELALPHA(LARGE_IMAGE,GETPIXELALPHA(IMAGE,
                                 PIXELS),Q);
                            }

                          ELSE
                            {
                              /* INTERPOLATE */
                              SETPIXELRED(LARGE_IMAGE,((QM) (((SSIZE_T)
                                 (2*I*(GETPIXELRED(IMAGE,N)
                                 -GETPIXELRED(IMAGE,PIXELS)+M))/
                                 ((SSIZE_T) (M*2))
                                 +GETPIXELRED(IMAGE,PIXELS)))),Q);
                              SETPIXELGREEN(LARGE_IMAGE,((QM) (((SSIZE_T)
                                 (2*I*(GETPIXELGREEN(IMAGE,N)
                                 -GETPIXELGREEN(IMAGE,PIXELS)+M))/
                                 ((SSIZE_T) (M*2))
                                 +GETPIXELGREEN(IMAGE,PIXELS)))),Q);
                              SETPIXELBLUE(LARGE_IMAGE,((QM) (((SSIZE_T)
                                 (2*I*(GETPIXELBLUE(IMAGE,N)
                                 -GETPIXELBLUE(IMAGE,PIXELS)+M))/
                                 ((SSIZE_T) (M*2))
                                 +GETPIXELBLUE(IMAGE,PIXELS)))),Q);

                              IF (IMAGE->ALPHA_TRAIT != UNDEFINEDPIXELTRAIT)
                                 SETPIXELALPHA(LARGE_IMAGE, ((QM) (((SSIZE_T)
                                    (2*I*(GETPIXELALPHA(IMAGE,N)
                                    -GETPIXELALPHA(IMAGE,PIXELS)+M))
                                    /((SSIZE_T) (M*2))+
                                   GETPIXELALPHA(IMAGE,PIXELS)))),Q);
                            }

                          IF (MAGN_METHY == 4)
                            {
                              /* REPLICATE NEAREST */
                              IF (I <= ((M+1) << 1))
                                 SETPIXELALPHA(LARGE_IMAGE,GETPIXELALPHA(IMAGE,
                                    PIXELS),Q);
                              ELSE
                                 SETPIXELALPHA(LARGE_IMAGE,GETPIXELALPHA(IMAGE,
                                    N),Q);
                            }
                        }

                      ELSE /* IF (MAGN_METHY == 3 || MAGN_METHY == 5) */
                        {
                          /* REPLICATE NEAREST */
                          IF (I <= ((M+1) << 1))
                          {
                             SETPIXELRED(LARGE_IMAGE,GETPIXELRED(IMAGE,
                                    PIXELS),Q);
                             SETPIXELGREEN(LARGE_IMAGE,GETPIXELGREEN(IMAGE,
                                    PIXELS),Q);
                             SETPIXELBLUE(LARGE_IMAGE,GETPIXELBLUE(IMAGE,
                                    PIXELS),Q);
                             SETPIXELALPHA(LARGE_IMAGE,GETPIXELALPHA(IMAGE,
                                    PIXELS),Q);
                          }

                          ELSE
                          {
                             SETPIXELRED(LARGE_IMAGE,GETPIXELRED(IMAGE,N),Q);
                             SETPIXELGREEN(LARGE_IMAGE,GETPIXELGREEN(IMAGE,N),
                                    Q);
                             SETPIXELBLUE(LARGE_IMAGE,GETPIXELBLUE(IMAGE,N),
                                    Q);
                             SETPIXELALPHA(LARGE_IMAGE,GETPIXELALPHA(IMAGE,N),
                                    Q);
                          }

                          IF (MAGN_METHY == 5)
                            {
                              SETPIXELALPHA(LARGE_IMAGE,(QM) (((SSIZE_T) (2*I*
                                 (GETPIXELALPHA(IMAGE,N)
                                 -GETPIXELALPHA(IMAGE,PIXELS))
                                 +M))/((SSIZE_T) (M*2))
                                 +GETPIXELALPHA(IMAGE,PIXELS)),Q);
                            }
                        }
                      N+=GETPIXELCHANNELS(IMAGE);
                      Q+=GETPIXELCHANNELS(LARGE_IMAGE);
                      PIXELS+=GETPIXELCHANNELS(IMAGE);
                    } /* X */

                    IF (SYNCAUTHENTICPIXELS(LARGE_IMAGE,EXCEPTION) == 0)
                      BREAK;

                  } /* I */
                } /* Y */

                PREV=(QUANTUM *) RELINQUISHMAGICKMEMORY(PREV);
                NEXT=(QUANTUM *) RELINQUISHMAGICKMEMORY(NEXT);

                LENGTH=IMAGE->COLUMNS;

                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "    DELETE ORIGINAL IMAGE");

                DELETEIMAGEFROMLIST(&IMAGE);

                IMAGE=LARGE_IMAGE;

                MNG_INFO->IMAGE=IMAGE;

                /* MAGNIFY THE COLUMNS */
                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "    MAGNIFY THE COLUMNS TO %.20G",
                    (DOUBLE) IMAGE->COLUMNS);

                FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
                {
                  REGISTER QUANTUM
                    *PIXELS;

                  Q=GETAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
                  PIXELS=Q+(IMAGE->COLUMNS-LENGTH)*GETPIXELCHANNELS(IMAGE);
                  N=PIXELS+GETPIXELCHANNELS(IMAGE);

                  FOR (X=(SSIZE_T) (IMAGE->COLUMNS-LENGTH);
                    X < (SSIZE_T) IMAGE->COLUMNS; X++)
                  {
                    /* TO DO: REWRITE USING GET/SET***PIXELCHANNEL() */

                    IF (X == (SSIZE_T) (IMAGE->COLUMNS-LENGTH))
                      M=(SSIZE_T) MNG_INFO->MAGN_ML;

                    ELSE IF (MAGN_METHX > 1 && X == (SSIZE_T) IMAGE->COLUMNS-2)
                      M=(SSIZE_T) MNG_INFO->MAGN_MR;

                    ELSE IF (MAGN_METHX <= 1 &&
                        X == (SSIZE_T) IMAGE->COLUMNS-1)
                      M=(SSIZE_T) MNG_INFO->MAGN_MR;

                    ELSE IF (MAGN_METHX > 1 && X == (SSIZE_T) IMAGE->COLUMNS-1)
                      M=1;

                    ELSE
                      M=(SSIZE_T) MNG_INFO->MAGN_MX;

                    FOR (I=0; I < M; I++)
                    {
                      IF (MAGN_METHX <= 1)
                        {
                          /* REPLICATE PREVIOUS */
                          SETPIXELRED(IMAGE,GETPIXELRED(IMAGE,PIXELS),Q);
                          SETPIXELGREEN(IMAGE,GETPIXELGREEN(IMAGE,PIXELS),Q);
                          SETPIXELBLUE(IMAGE,GETPIXELBLUE(IMAGE,PIXELS),Q);
                          SETPIXELALPHA(IMAGE,GETPIXELALPHA(IMAGE,PIXELS),Q);
                        }

                      ELSE IF (MAGN_METHX == 2 || MAGN_METHX == 4)
                        {
                          IF (I == 0)
                          {
                            SETPIXELRED(IMAGE,GETPIXELRED(IMAGE,PIXELS),Q);
                            SETPIXELGREEN(IMAGE,GETPIXELGREEN(IMAGE,PIXELS),Q);
                            SETPIXELBLUE(IMAGE,GETPIXELBLUE(IMAGE,PIXELS),Q);
                            SETPIXELALPHA(IMAGE,GETPIXELALPHA(IMAGE,PIXELS),Q);
                          }

                          /* TO DO: REWRITE USING GET/SET***PIXELCHANNEL() */
                          ELSE
                            {
                              /* INTERPOLATE */
                              SETPIXELRED(IMAGE,(QM) ((2*I*(
                                 GETPIXELRED(IMAGE,N)
                                 -GETPIXELRED(IMAGE,PIXELS))+M)
                                 /((SSIZE_T) (M*2))+
                                 GETPIXELRED(IMAGE,PIXELS)),Q);

                              SETPIXELGREEN(IMAGE,(QM) ((2*I*(
                                 GETPIXELGREEN(IMAGE,N)
                                 -GETPIXELGREEN(IMAGE,PIXELS))+M)
                                 /((SSIZE_T) (M*2))+
                                 GETPIXELGREEN(IMAGE,PIXELS)),Q);

                              SETPIXELBLUE(IMAGE,(QM) ((2*I*(
                                 GETPIXELBLUE(IMAGE,N)
                                 -GETPIXELBLUE(IMAGE,PIXELS))+M)
                                 /((SSIZE_T) (M*2))+
                                 GETPIXELBLUE(IMAGE,PIXELS)),Q);
                              IF (IMAGE->ALPHA_TRAIT != UNDEFINEDPIXELTRAIT)
                                 SETPIXELALPHA(IMAGE,(QM) ((2*I*(
                                   GETPIXELALPHA(IMAGE,N)
                                   -GETPIXELALPHA(IMAGE,PIXELS))+M)
                                   /((SSIZE_T) (M*2))+
                                   GETPIXELALPHA(IMAGE,PIXELS)),Q);
                            }

                          IF (MAGN_METHX == 4)
                            {
                              /* REPLICATE NEAREST */
                              IF (I <= ((M+1) << 1))
                              {
                                 SETPIXELALPHA(IMAGE,
                                   GETPIXELALPHA(IMAGE,PIXELS)+0,Q);
                              }
                              ELSE
                              {
                                 SETPIXELALPHA(IMAGE,
                                   GETPIXELALPHA(IMAGE,N)+0,Q);
                              }
                            }
                        }

                      ELSE /* IF (MAGN_METHX == 3 || MAGN_METHX == 5) */
                        {
                          /* REPLICATE NEAREST */
                          IF (I <= ((M+1) << 1))
                          {
                             SETPIXELRED(IMAGE,GETPIXELRED(IMAGE,PIXELS),Q);
                             SETPIXELGREEN(IMAGE,GETPIXELGREEN(IMAGE,
                                 PIXELS),Q);
                             SETPIXELBLUE(IMAGE,GETPIXELBLUE(IMAGE,PIXELS),Q);
                             SETPIXELALPHA(IMAGE,GETPIXELALPHA(IMAGE,
                                 PIXELS),Q);
                          }

                          ELSE
                          {
                             SETPIXELRED(IMAGE,GETPIXELRED(IMAGE,N),Q);
                             SETPIXELGREEN(IMAGE,GETPIXELGREEN(IMAGE,N),Q);
                             SETPIXELBLUE(IMAGE,GETPIXELBLUE(IMAGE,N),Q);
                             SETPIXELALPHA(IMAGE,GETPIXELALPHA(IMAGE,N),Q);
                          }

                          IF (MAGN_METHX == 5)
                            {
                              /* INTERPOLATE */
                              SETPIXELALPHA(IMAGE,
                                 (QM) ((2*I*( GETPIXELALPHA(IMAGE,N)
                                 -GETPIXELALPHA(IMAGE,PIXELS))+M)/
                                 ((SSIZE_T) (M*2))
                                 +GETPIXELALPHA(IMAGE,PIXELS)),Q);
                            }
                        }
                      Q+=GETPIXELCHANNELS(IMAGE);
                    }
                    N+=GETPIXELCHANNELS(IMAGE);
                  }

                  IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
                    BREAK;
                }
#IF (MAGICKCORE_QUANTUM_DEPTH > 16)
              IF (MAGN_METHX != 1 || MAGN_METHY != 1)
                {
                /*
                   RESCALE PIXELS TO QUANTUM
                */
                   FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
                   {
                     Q=GETAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,
                       EXCEPTION);

                     FOR (X=(SSIZE_T) IMAGE->COLUMNS-1; X >= 0; X--)
                     {
                        SETPIXELRED(IMAGE,SCALESHORTTOQUANTUM(
                          GETPIXELRED(IMAGE,Q)),Q);
                        SETPIXELGREEN(IMAGE,SCALESHORTTOQUANTUM(
                          GETPIXELGREEN(IMAGE,Q)),Q);
                        SETPIXELBLUE(IMAGE,SCALESHORTTOQUANTUM(
                          GETPIXELBLUE(IMAGE,Q)),Q);
                        SETPIXELALPHA(IMAGE,SCALESHORTTOQUANTUM(
                          GETPIXELALPHA(IMAGE,Q)),Q);
                        Q+=GETPIXELCHANNELS(IMAGE);
                     }

                     IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
                       BREAK;
                   }
                }
#ENDIF
                IF (LOGGING != MAGICKFALSE)
                  (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                    "  FINISHED MAGN PROCESSING");
              }
          }

        /*
          CROP_BOX IS WITH RESPECT TO THE UPPER LEFT CORNER OF THE MNG.
        */
        CROP_BOX.LEFT=MNG_INFO->IMAGE_BOX.LEFT+MNG_INFO->X_OFF[OBJECT_ID];
        CROP_BOX.RIGHT=MNG_INFO->IMAGE_BOX.RIGHT+MNG_INFO->X_OFF[OBJECT_ID];
        CROP_BOX.TOP=MNG_INFO->IMAGE_BOX.TOP+MNG_INFO->Y_OFF[OBJECT_ID];
        CROP_BOX.BOTTOM=MNG_INFO->IMAGE_BOX.BOTTOM+MNG_INFO->Y_OFF[OBJECT_ID];
        CROP_BOX=MNG_MINIMUM_BOX(CROP_BOX,MNG_INFO->CLIP);
        CROP_BOX=MNG_MINIMUM_BOX(CROP_BOX,MNG_INFO->FRAME);
        CROP_BOX=MNG_MINIMUM_BOX(CROP_BOX,MNG_INFO->OBJECT_CLIP[OBJECT_ID]);
        IF ((CROP_BOX.LEFT != (MNG_INFO->IMAGE_BOX.LEFT
            +MNG_INFO->X_OFF[OBJECT_ID])) ||
            (CROP_BOX.RIGHT != (MNG_INFO->IMAGE_BOX.RIGHT
            +MNG_INFO->X_OFF[OBJECT_ID])) ||
            (CROP_BOX.TOP != (MNG_INFO->IMAGE_BOX.TOP
            +MNG_INFO->Y_OFF[OBJECT_ID])) ||
            (CROP_BOX.BOTTOM != (MNG_INFO->IMAGE_BOX.BOTTOM
            +MNG_INFO->Y_OFF[OBJECT_ID])))
          {
            IF (LOGGING != MAGICKFALSE)
              (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                "  CROP THE PNG IMAGE");

            IF ((CROP_BOX.LEFT < CROP_BOX.RIGHT) &&
                (CROP_BOX.TOP < CROP_BOX.BOTTOM))
              {
                IMAGE
                  *IM;

                RECTANGLEINFO
                  CROP_INFO;

                /*
                  CROP_INFO IS WITH RESPECT TO THE UPPER LEFT CORNER OF
                  THE IMAGE.
                */
                CROP_INFO.X=(CROP_BOX.LEFT-MNG_INFO->X_OFF[OBJECT_ID]);
                CROP_INFO.Y=(CROP_BOX.TOP-MNG_INFO->Y_OFF[OBJECT_ID]);
                CROP_INFO.WIDTH=(SIZE_T) (CROP_BOX.RIGHT-CROP_BOX.LEFT);
                CROP_INFO.HEIGHT=(SIZE_T) (CROP_BOX.BOTTOM-CROP_BOX.TOP);
                IMAGE->PAGE.WIDTH=IMAGE->COLUMNS;
                IMAGE->PAGE.HEIGHT=IMAGE->ROWS;
                IMAGE->PAGE.X=0;
                IMAGE->PAGE.Y=0;
                IM=CROPIMAGE(IMAGE,&CROP_INFO,EXCEPTION);

                IF (IM != (IMAGE *) NULL)
                  {
                    IMAGE->COLUMNS=IM->COLUMNS;
                    IMAGE->ROWS=IM->ROWS;
                    IM=DESTROYIMAGE(IM);
                    IMAGE->PAGE.WIDTH=IMAGE->COLUMNS;
                    IMAGE->PAGE.HEIGHT=IMAGE->ROWS;
                    IMAGE->PAGE.X=CROP_BOX.LEFT;
                    IMAGE->PAGE.Y=CROP_BOX.TOP;
                  }
              }

            ELSE
              {
                /*
                  NO PIXELS IN CROP AREA.  THE MNG SPEC STILL REQUIRES
                  A LAYER, THOUGH, SO MAKE A SINGLE TRANSPARENT PIXEL IN
                  THE TOP LEFT CORNER.
                */
                IMAGE->COLUMNS=1;
                IMAGE->ROWS=1;
                IMAGE->COLORS=2;
                (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);
                IMAGE->PAGE.WIDTH=1;
                IMAGE->PAGE.HEIGHT=1;
                IMAGE->PAGE.X=0;
                IMAGE->PAGE.Y=0;
              }
          }
#IFNDEF PNG_READ_EMPTY_PLTE_SUPPORTED
        IMAGE=MNG_INFO->IMAGE;
#ENDIF
      }

#IF (MAGICKCORE_QUANTUM_DEPTH > 16)
      /* PNG DOES NOT HANDLE DEPTHS GREATER THAN 16 SO REDUCE IT EVEN
       * IF LOSSY.
       */
      IF (IMAGE->DEPTH > 16)
         IMAGE->DEPTH=16;
#ENDIF

#IF (MAGICKCORE_QUANTUM_DEPTH > 8)
      IF (IMAGE->DEPTH > 8)
        {
          /* TO DO: FILL LOW BYTE PROPERLY */
          IMAGE->DEPTH=16;
        }

      IF (LOSSLESSREDUCEDEPTHOK(IMAGE,EXCEPTION) != MAGICKFALSE)
         IMAGE->DEPTH = 8;
#ENDIF

      IF (IMAGE_INFO->NUMBER_SCENES != 0)
        {
          IF (MNG_INFO->SCENES_FOUND >
             (SSIZE_T) (IMAGE_INFO->FIRST_SCENE+IMAGE_INFO->NUMBER_SCENES))
            BREAK;
        }

      IF (LOGGING != MAGICKFALSE)
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "  FINISHED READING IMAGE DATASTREAM.");

  } WHILE (LOCALECOMPARE(IMAGE_INFO->MAGICK,"MNG") == 0);

  (VOID) CLOSEBLOB(IMAGE);

  IF (LOGGING != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
      "  FINISHED READING ALL IMAGE DATASTREAMS.");

#IF DEFINED(MNG_INSERT_LAYERS)
  IF (INSERT_LAYERS && !MNG_INFO->IMAGE_FOUND && (MNG_INFO->MNG_WIDTH) &&
       (MNG_INFO->MNG_HEIGHT))
    {
      /*
        INSERT A BACKGROUND LAYER IF NOTHING ELSE WAS FOUND.
      */
      IF (LOGGING != MAGICKFALSE)
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "  NO IMAGES FOUND.  INSERTING A BACKGROUND LAYER.");

      IF (GETAUTHENTICPIXELQUEUE(IMAGE) != (QUANTUM *) NULL)
        {
          /*
            ALLOCATE NEXT IMAGE STRUCTURE.
          */
          ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);
          IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
            {
              IF (LOGGING != MAGICKFALSE)
                (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                  "  ALLOCATION FAILED, RETURNING NULL.");

              RETURN(DESTROYIMAGELIST(IMAGE));;
            }
          IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
        }
      IMAGE->COLUMNS=MNG_INFO->MNG_WIDTH;
      IMAGE->ROWS=MNG_INFO->MNG_HEIGHT;
      IMAGE->PAGE.WIDTH=MNG_INFO->MNG_WIDTH;
      IMAGE->PAGE.HEIGHT=MNG_INFO->MNG_HEIGHT;
      IMAGE->PAGE.X=0;
      IMAGE->PAGE.Y=0;
      IMAGE->BACKGROUND_COLOR=MNG_BACKGROUND_COLOR;
      IMAGE->ALPHA_TRAIT=UNDEFINEDPIXELTRAIT;

      IF (IMAGE_INFO->PING == MAGICKFALSE)
        (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);

      MNG_INFO->IMAGE_FOUND++;
    }
#ENDIF
  IMAGE->ITERATIONS=MNG_ITERATIONS;

  IF (MNG_ITERATIONS == 1)
    IMAGE->START_LOOP=MAGICKTRUE;

  WHILE (GETPREVIOUSIMAGEINLIST(IMAGE) != (IMAGE *) NULL)
  {
    IMAGE_COUNT++;
    IF (IMAGE_COUNT > 10*MNG_INFO->IMAGE_FOUND)
      {
        IF (LOGGING != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  NO BEGINNING");

        (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
          CODERERROR,"LINKED LIST IS CORRUPTED, BEGINNING OF LIST NOT FOUND",
          "`%S'",IMAGE_INFO->FILENAME);

        RETURN(DESTROYIMAGELIST(IMAGE));
      }

    IMAGE=GETPREVIOUSIMAGEINLIST(IMAGE);

    IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
      {
        IF (LOGGING != MAGICKFALSE)
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  CORRUPT LIST");

        (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
          CODERERROR,"LINKED LIST IS CORRUPTED; NEXT_IMAGE IS NULL","`%S'",
          IMAGE_INFO->FILENAME);
      }
  }

  IF (MNG_INFO->TICKS_PER_SECOND && MNG_INFO->IMAGE_FOUND > 1 &&
             GETNEXTIMAGEINLIST(IMAGE) ==
     (IMAGE *) NULL)
    {
      IF (LOGGING != MAGICKFALSE)
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  FIRST IMAGE NULL");

      (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
        CODERERROR,"IMAGE->NEXT FOR FIRST IMAGE IS NULL BUT SHOULDN'T BE.",
        "`%S'",IMAGE_INFO->FILENAME);
    }

  IF (MNG_INFO->IMAGE_FOUND == 0)
    {
      IF (LOGGING != MAGICKFALSE)
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "  NO VISIBLE IMAGES FOUND.");

      (VOID) THROWMAGICKEXCEPTION(EXCEPTION,GETMAGICKMODULE(),
        CODERERROR,"NO VISIBLE IMAGES IN FILE","`%S'",IMAGE_INFO->FILENAME);

      RETURN(DESTROYIMAGELIST(IMAGE));
    }

  IF (MNG_INFO->TICKS_PER_SECOND)
    FINAL_DELAY=1UL*MAGICKMAX(IMAGE->TICKS_PER_SECOND,1L)*
            FINAL_DELAY/MNG_INFO->TICKS_PER_SECOND;

  ELSE
    IMAGE->START_LOOP=MAGICKTRUE;

  /* FIND FINAL NONZERO IMAGE DELAY */
  FINAL_IMAGE_DELAY=0;

  WHILE (GETNEXTIMAGEINLIST(IMAGE) != (IMAGE *) NULL)
    {
      IF (IMAGE->DELAY)
        FINAL_IMAGE_DELAY=IMAGE->DELAY;

      IMAGE=GETNEXTIMAGEINLIST(IMAGE);
    }

  IF (FINAL_DELAY < FINAL_IMAGE_DELAY)
    FINAL_DELAY=FINAL_IMAGE_DELAY;

  IMAGE->DELAY=FINAL_DELAY;

  IF (LOGGING != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  IMAGE->DELAY=%.20G, FINAL_DELAY=%.20G",(DOUBLE) IMAGE->DELAY,
        (DOUBLE) FINAL_DELAY);

  IF (LOGGING != MAGICKFALSE)
    {
      INT
        SCENE;

      SCENE=0;
      IMAGE=GETFIRSTIMAGEINLIST(IMAGE);

      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  BEFORE COALESCE:");

      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "    SCENE 0 DELAY=%.20G",(DOUBLE) IMAGE->DELAY);

      WHILE (GETNEXTIMAGEINLIST(IMAGE) != (IMAGE *) NULL)
      {
        IMAGE=GETNEXTIMAGEINLIST(IMAGE);
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "    SCENE %.20G DELAY=%.20G",(DOUBLE) SCENE++,
          (DOUBLE) IMAGE->DELAY);
      }
    }

  IMAGE=GETFIRSTIMAGEINLIST(IMAGE);
#IFDEF MNG_COALESCE_LAYERS
  IF (INSERT_LAYERS)
    {
      IMAGE
        *NEXT_IMAGE,
        *NEXT;

      SIZE_T
        SCENE;

      IF (LOGGING != MAGICKFALSE)
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "  COALESCE IMAGES");

      SCENE=IMAGE->SCENE;
      NEXT_IMAGE=COALESCEIMAGES(IMAGE,EXCEPTION);

      IF (NEXT_IMAGE == (IMAGE *) NULL)
        THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");

      IMAGE=DESTROYIMAGELIST(IMAGE);
      IMAGE=NEXT_IMAGE;

      FOR (NEXT=IMAGE; NEXT != (IMAGE *) NULL; NEXT=NEXT_IMAGE)
      {
         NEXT->PAGE.WIDTH=MNG_INFO->MNG_WIDTH;
         NEXT->PAGE.HEIGHT=MNG_INFO->MNG_HEIGHT;
         NEXT->PAGE.X=0;
         NEXT->PAGE.Y=0;
         NEXT->SCENE=SCENE++;
         NEXT_IMAGE=GETNEXTIMAGEINLIST(NEXT);

         IF (NEXT_IMAGE == (IMAGE *) NULL)
           BREAK;

         IF (NEXT->DELAY == 0)
           {
             SCENE--;
             NEXT_IMAGE->PREVIOUS=GETPREVIOUSIMAGEINLIST(NEXT);
             IF (GETPREVIOUSIMAGEINLIST(NEXT) == (IMAGE *) NULL)
               IMAGE=NEXT_IMAGE;
             ELSE
               NEXT->PREVIOUS->NEXT=NEXT_IMAGE;
             NEXT=DESTROYIMAGE(NEXT);
           }
      }
    }
#ENDIF

  WHILE (GETNEXTIMAGEINLIST(IMAGE) != (IMAGE *) NULL)
      IMAGE=GETNEXTIMAGEINLIST(IMAGE);

  IMAGE->DISPOSE=BACKGROUNDDISPOSE;

  IF (LOGGING != MAGICKFALSE)
    {
      INT
        SCENE;

      SCENE=0;
      IMAGE=GETFIRSTIMAGEINLIST(IMAGE);

      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  AFTER COALESCE:");

      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "    SCENE 0 DELAY=%.20G DISPOSE=%.20G",(DOUBLE) IMAGE->DELAY,
        (DOUBLE) IMAGE->DISPOSE);

      WHILE (GETNEXTIMAGEINLIST(IMAGE) != (IMAGE *) NULL)
      {
        IMAGE=GETNEXTIMAGEINLIST(IMAGE);

        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "    SCENE %.20G DELAY=%.20G DISPOSE=%.20G",(DOUBLE) SCENE++,
          (DOUBLE) IMAGE->DELAY,(DOUBLE) IMAGE->DISPOSE);
      }
   }

  IF (LOGGING != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
      "  EXIT READONEMNGIMAGE();");

  RETURN(IMAGE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 242956_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SSL_CHECK_RECORD_TYPE( UINT8_T RECORD_TYPE )
{
    IF( RECORD_TYPE != MBEDTLS_SSL_MSG_HANDSHAKE &&
        RECORD_TYPE != MBEDTLS_SSL_MSG_ALERT &&
        RECORD_TYPE != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
        RECORD_TYPE != MBEDTLS_SSL_MSG_APPLICATION_DATA )
    {
        RETURN( MBEDTLS_ERR_SSL_INVALID_RECORD );
    }

    RETURN( 0 );
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196611_CWE-284.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SETUP_CONFIG(INT TYPE)
{
	INT RV;

	RV = READ_CONFIG(CL.CONFIGFILE, TYPE);
	IF (RV < 0)
		GOTO OUT;

	IF (IS_AUTH_REQ()) {
		RV = READ_AUTHKEY();
		IF (RV < 0)
			GOTO OUT;
#IF HAVE_LIBGCRYPT
		IF (!GCRY_CHECK_VERSION(NULL)) {
			LOG_ERROR("GCRY_CHECK_VERSION");
			RV = -ENOENT;
			GOTO OUT;
		}
		GCRY_CONTROL(GCRYCTL_DISABLE_SECMEM, 0);
		GCRY_CONTROL(GCRYCTL_INITIALIZATION_FINISHED, 0);
#ENDIF
	}

	/* SET "LOCAL" POINTER, IGNORING ERRORS. */
	IF (CL.TYPE == DAEMON && CL.SITE[0]) {
		IF (!FIND_SITE_BY_NAME(CL.SITE, &LOCAL, 1)) {
			LOG_ERROR("CANNOT FIND \"%S\" IN THE CONFIGURATION.",
					CL.SITE);
			RETURN -EINVAL;
		}
		LOCAL->LOCAL = 1;
	} ELSE
		FIND_MYSELF(NULL, TYPE == CLIENT || TYPE == GEOSTORE);


	RV = CHECK_CONFIG(TYPE);
	IF (RV < 0)
		GOTO OUT;


	/* PER DEFAULT THE PID FILE NAME IS DERIVED FROM THE
	 * CONFIGURATION NAME. */
	IF (!CL.LOCKFILE[0]) {
		SNPRINTF(CL.LOCKFILE, SIZEOF(CL.LOCKFILE)-1,
				"%S/%S.PID", BOOTH_RUN_DIR, BOOTH_CONF->NAME);
	}

OUT:
	RETURN RV;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 361748_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT EM28XX_DUPLICATE_DEV(STRUCT EM28XX *DEV)
{
	INT NR;
	STRUCT EM28XX *SEC_DEV = KMEMDUP(DEV, SIZEOF(*SEC_DEV), GFP_KERNEL);

	IF (!SEC_DEV) {
		DEV->DEV_NEXT = NULL;
		RETURN -ENOMEM;
	}
	/* CHECK TO SEE NEXT FREE DEVICE AND MARK AS USED */
	DO {
		NR = FIND_FIRST_ZERO_BIT(EM28XX_DEVUSED, EM28XX_MAXBOARDS);
		IF (NR >= EM28XX_MAXBOARDS) {
			/* NO FREE DEVICE SLOTS */
			DEV_WARN(&DEV->INTF->DEV, ": SUPPORTS ONLY %I EM28XX BOARDS.\N",
				 EM28XX_MAXBOARDS);
			KFREE(SEC_DEV);
			DEV->DEV_NEXT = NULL;
			RETURN -ENOMEM;
		}
	} WHILE (TEST_AND_SET_BIT(NR, EM28XX_DEVUSED));
	SEC_DEV->DEVNO = NR;
	SNPRINTF(SEC_DEV->NAME, 28, "EM28XX #%D", NR);
	SEC_DEV->DEV_NEXT = NULL;
	DEV->DEV_NEXT = SEC_DEV;
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462267_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PJ_DEF(CONST CHAR*) PJ_STUN_GET_CLASS_NAME(UNSIGNED MSG_TYPE)
{
    IF (PJ_STUN_IS_REQUEST(MSG_TYPE))
	RETURN "REQUEST";
    ELSE IF (PJ_STUN_IS_SUCCESS_RESPONSE(MSG_TYPE))
	RETURN "SUCCESS RESPONSE";
    ELSE IF (PJ_STUN_IS_ERROR_RESPONSE(MSG_TYPE))
	RETURN "ERROR RESPONSE";
    ELSE IF (PJ_STUN_IS_INDICATION(MSG_TYPE))
	RETURN "INDICATION";
    ELSE
	RETURN "???";
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212339_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SIZE_T HANDLE_RETURNED_HEADER (VOID *PTR, SIZE_T SIZE, SIZE_T NMEMB, VOID *STREAM)
{
    AUTH_CLIENT *AUTH_USER = STREAM;
    SIZE_T BYTES = SIZE * NMEMB;
    CLIENT_T *CLIENT = AUTH_USER->CLIENT;

    IF (CLIENT)
    {
        AUTH_T *AUTH = CLIENT->AUTH;
        AUTH_URL *URL = AUTH->STATE;
        IF (STRNCASECMP (PTR, URL->AUTH_HEADER, URL->AUTH_HEADER_LEN) == 0)
            CLIENT->AUTHENTICATED = 1;
        IF (STRNCASECMP (PTR, URL->TIMELIMIT_HEADER, URL->TIMELIMIT_HEADER_LEN) == 0)
        {
            UNSIGNED INT LIMIT = 0;
            SSCANF ((CHAR *)PTR+URL->TIMELIMIT_HEADER_LEN, "%U\R\N", &LIMIT);
            CLIENT->CON->DISCON_TIME = TIME(NULL) + LIMIT;
        }
        IF (STRNCASECMP (PTR, "ICECAST-AUTH-MESSAGE: ", 22) == 0)
        {
            CHAR *EOL;
            SNPRINTF (URL->ERRORMSG, SIZEOF (URL->ERRORMSG), "%S", (CHAR*)PTR+22);
            EOL = STRCHR (URL->ERRORMSG, '\R');
            IF (EOL == NULL)
                EOL = STRCHR (URL->ERRORMSG, '\N');
            IF (EOL)
                *EOL = '\0';
        }
    }

    RETURN BYTES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 424944_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IWL_TRANS_PCIE_RXQ_DMA_DATA(STRUCT IWL_TRANS *TRANS, INT QUEUE,
				       STRUCT IWL_TRANS_RXQ_DMA_DATA *DATA)
{
	STRUCT IWL_TRANS_PCIE *TRANS_PCIE = IWL_TRANS_GET_PCIE_TRANS(TRANS);

	IF (QUEUE >= TRANS->NUM_RX_QUEUES || !TRANS_PCIE->RXQ)
		RETURN -EINVAL;

	DATA->FR_BD_CB = TRANS_PCIE->RXQ[QUEUE].BD_DMA;
	DATA->URBD_STTS_WRPTR = TRANS_PCIE->RXQ[QUEUE].RB_STTS_DMA;
	DATA->UR_BD_CB = TRANS_PCIE->RXQ[QUEUE].USED_BD_DMA;
	DATA->FR_BD_WID = 0;

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214160_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
COMPOSITE_SETUP(STRUCT USB_GADGET *GADGET, CONST STRUCT USB_CTRLREQUEST *CTRL)
{
	STRUCT USB_COMPOSITE_DEV	*CDEV = GET_GADGET_DATA(GADGET);
	STRUCT USB_REQUEST		*REQ = CDEV->REQ;
	INT				VALUE = -EOPNOTSUPP;
	INT				STATUS = 0;
	U16				W_INDEX = LE16_TO_CPU(CTRL->WINDEX);
	U8				INTF = W_INDEX & 0XFF;
	U16				W_VALUE = LE16_TO_CPU(CTRL->WVALUE);
	U16				W_LENGTH = LE16_TO_CPU(CTRL->WLENGTH);
	STRUCT USB_FUNCTION		*F = NULL;
	U8				ENDP;

	IF (W_LENGTH > USB_COMP_EP0_BUFSIZ) {
		IF (CTRL->BREQUESTTYPE & USB_DIR_IN) {
			/* CAST AWAY THE CONST, WE ARE GOING TO OVERWRITE ON PURPOSE. */
			__LE16 *TEMP = (__LE16 *)&CTRL->WLENGTH;

			*TEMP = CPU_TO_LE16(USB_COMP_EP0_BUFSIZ);
			W_LENGTH = USB_COMP_EP0_BUFSIZ;
		} ELSE {
			GOTO DONE;
		}
	}

	/* PARTIAL RE-INIT OF THE RESPONSE MESSAGE; THE FUNCTION OR THE
	 * GADGET MIGHT NEED TO INTERCEPT E.G. A CONTROL-OUT COMPLETION
	 * WHEN WE DELEGATE TO IT.
	 */
	REQ->ZERO = 0;
	REQ->CONTEXT = CDEV;
	REQ->COMPLETE = COMPOSITE_SETUP_COMPLETE;
	REQ->LENGTH = 0;
	GADGET->EP0->DRIVER_DATA = CDEV;

	/*
	 * DON'T LET NON-STANDARD REQUESTS MATCH ANY OF THE CASES BELOW
	 * BY ACCIDENT.
	 */
	IF ((CTRL->BREQUESTTYPE & USB_TYPE_MASK) != USB_TYPE_STANDARD)
		GOTO UNKNOWN;

	SWITCH (CTRL->BREQUEST) {

	/* WE HANDLE ALL STANDARD USB DESCRIPTORS */
	CASE USB_REQ_GET_DESCRIPTOR:
		IF (CTRL->BREQUESTTYPE != USB_DIR_IN)
			GOTO UNKNOWN;
		SWITCH (W_VALUE >> 8) {

		CASE USB_DT_DEVICE:
			CDEV->DESC.BNUMCONFIGURATIONS =
				COUNT_CONFIGS(CDEV, USB_DT_DEVICE);
			CDEV->DESC.BMAXPACKETSIZE0 =
				CDEV->GADGET->EP0->MAXPACKET;
			IF (GADGET_IS_SUPERSPEED(GADGET)) {
				IF (GADGET->SPEED >= USB_SPEED_SUPER) {
					CDEV->DESC.BCDUSB = CPU_TO_LE16(0X0320);
					CDEV->DESC.BMAXPACKETSIZE0 = 9;
				} ELSE {
					CDEV->DESC.BCDUSB = CPU_TO_LE16(0X0210);
				}
			} ELSE {
				IF (GADGET->LPM_CAPABLE)
					CDEV->DESC.BCDUSB = CPU_TO_LE16(0X0201);
				ELSE
					CDEV->DESC.BCDUSB = CPU_TO_LE16(0X0200);
			}

			VALUE = MIN(W_LENGTH, (U16) SIZEOF CDEV->DESC);
			MEMCPY(REQ->BUF, &CDEV->DESC, VALUE);
			BREAK;
		CASE USB_DT_DEVICE_QUALIFIER:
			IF (!GADGET_IS_DUALSPEED(GADGET) ||
			    GADGET->SPEED >= USB_SPEED_SUPER)
				BREAK;
			DEVICE_QUAL(CDEV);
			VALUE = MIN_T(INT, W_LENGTH,
				SIZEOF(STRUCT USB_QUALIFIER_DESCRIPTOR));
			BREAK;
		CASE USB_DT_OTHER_SPEED_CONFIG:
			IF (!GADGET_IS_DUALSPEED(GADGET) ||
			    GADGET->SPEED >= USB_SPEED_SUPER)
				BREAK;
			FALLTHROUGH;
		CASE USB_DT_CONFIG:
			VALUE = CONFIG_DESC(CDEV, W_VALUE);
			IF (VALUE >= 0)
				VALUE = MIN(W_LENGTH, (U16) VALUE);
			BREAK;
		CASE USB_DT_STRING:
			VALUE = GET_STRING(CDEV, REQ->BUF,
					W_INDEX, W_VALUE & 0XFF);
			IF (VALUE >= 0)
				VALUE = MIN(W_LENGTH, (U16) VALUE);
			BREAK;
		CASE USB_DT_BOS:
			IF (GADGET_IS_SUPERSPEED(GADGET) ||
			    GADGET->LPM_CAPABLE) {
				VALUE = BOS_DESC(CDEV);
				VALUE = MIN(W_LENGTH, (U16) VALUE);
			}
			BREAK;
		CASE USB_DT_OTG:
			IF (GADGET_IS_OTG(GADGET)) {
				STRUCT USB_CONFIGURATION *CONFIG;
				INT OTG_DESC_LEN = 0;

				IF (CDEV->CONFIG)
					CONFIG = CDEV->CONFIG;
				ELSE
					CONFIG = LIST_FIRST_ENTRY(
							&CDEV->CONFIGS,
						STRUCT USB_CONFIGURATION, LIST);
				IF (!CONFIG)
					GOTO DONE;

				IF (GADGET->OTG_CAPS &&
					(GADGET->OTG_CAPS->OTG_REV >= 0X0200))
					OTG_DESC_LEN += SIZEOF(
						STRUCT USB_OTG20_DESCRIPTOR);
				ELSE
					OTG_DESC_LEN += SIZEOF(
						STRUCT USB_OTG_DESCRIPTOR);

				VALUE = MIN_T(INT, W_LENGTH, OTG_DESC_LEN);
				MEMCPY(REQ->BUF, CONFIG->DESCRIPTORS[0], VALUE);
			}
			BREAK;
		}
		BREAK;

	/* ANY NUMBER OF CONFIGS CAN WORK */
	CASE USB_REQ_SET_CONFIGURATION:
		IF (CTRL->BREQUESTTYPE != 0)
			GOTO UNKNOWN;
		IF (GADGET_IS_OTG(GADGET)) {
			IF (GADGET->A_HNP_SUPPORT)
				DBG(CDEV, "HNP AVAILABLE\N");
			ELSE IF (GADGET->A_ALT_HNP_SUPPORT)
				DBG(CDEV, "HNP ON ANOTHER PORT\N");
			ELSE
				VDBG(CDEV, "HNP INACTIVE\N");
		}
		SPIN_LOCK(&CDEV->LOCK);
		VALUE = SET_CONFIG(CDEV, CTRL, W_VALUE);
		SPIN_UNLOCK(&CDEV->LOCK);
		BREAK;
	CASE USB_REQ_GET_CONFIGURATION:
		IF (CTRL->BREQUESTTYPE != USB_DIR_IN)
			GOTO UNKNOWN;
		IF (CDEV->CONFIG)
			*(U8 *)REQ->BUF = CDEV->CONFIG->BCONFIGURATIONVALUE;
		ELSE
			*(U8 *)REQ->BUF = 0;
		VALUE = MIN(W_LENGTH, (U16) 1);
		BREAK;

	/* FUNCTION DRIVERS MUST HANDLE GET/SET ALTSETTING */
	CASE USB_REQ_SET_INTERFACE:
		IF (CTRL->BREQUESTTYPE != USB_RECIP_INTERFACE)
			GOTO UNKNOWN;
		IF (!CDEV->CONFIG || INTF >= MAX_CONFIG_INTERFACES)
			BREAK;
		F = CDEV->CONFIG->INTERFACE[INTF];
		IF (!F)
			BREAK;

		/*
		 * IF THERE'S NO GET_ALT() METHOD, WE KNOW ONLY ALTSETTING ZERO
		 * WORKS. THERE IS NO NEED TO CHECK IF SET_ALT() IS NOT NULL
		 * AS WE CHECK THIS IN USB_ADD_FUNCTION().
		 */
		IF (W_VALUE && !F->GET_ALT)
			BREAK;

		SPIN_LOCK(&CDEV->LOCK);
		VALUE = F->SET_ALT(F, W_INDEX, W_VALUE);
		IF (VALUE == USB_GADGET_DELAYED_STATUS) {
			DBG(CDEV,
			 "%S: INTERFACE %D (%S) REQUESTED DELAYED STATUS\N",
					__FUNC__, INTF, F->NAME);
			CDEV->DELAYED_STATUS++;
			DBG(CDEV, "DELAYED_STATUS COUNT %D\N",
					CDEV->DELAYED_STATUS);
		}
		SPIN_UNLOCK(&CDEV->LOCK);
		BREAK;
	CASE USB_REQ_GET_INTERFACE:
		IF (CTRL->BREQUESTTYPE != (USB_DIR_IN|USB_RECIP_INTERFACE))
			GOTO UNKNOWN;
		IF (!CDEV->CONFIG || INTF >= MAX_CONFIG_INTERFACES)
			BREAK;
		F = CDEV->CONFIG->INTERFACE[INTF];
		IF (!F)
			BREAK;
		/* LOTS OF INTERFACES ONLY NEED ALTSETTING ZERO... */
		VALUE = F->GET_ALT ? F->GET_ALT(F, W_INDEX) : 0;
		IF (VALUE < 0)
			BREAK;
		*((U8 *)REQ->BUF) = VALUE;
		VALUE = MIN(W_LENGTH, (U16) 1);
		BREAK;
	CASE USB_REQ_GET_STATUS:
		IF (GADGET_IS_OTG(GADGET) && GADGET->HNP_POLLING_SUPPORT &&
						(W_INDEX == OTG_STS_SELECTOR)) {
			IF (CTRL->BREQUESTTYPE != (USB_DIR_IN |
							USB_RECIP_DEVICE))
				GOTO UNKNOWN;
			*((U8 *)REQ->BUF) = GADGET->HOST_REQUEST_FLAG;
			VALUE = 1;
			BREAK;
		}

		/*
		 * USB 3.0 ADDITIONS:
		 * FUNCTION DRIVER SHOULD HANDLE GET_STATUS REQUEST. IF SUCH CB
		 * WASN'T SUPPLIED WE RESPOND WITH DEFAULT VALUE = 0
		 * NOTE: FUNCTION DRIVER SHOULD SUPPLY SUCH CB ONLY FOR THE
		 * FIRST INTERFACE OF THE FUNCTION
		 */
		IF (!GADGET_IS_SUPERSPEED(GADGET))
			GOTO UNKNOWN;
		IF (CTRL->BREQUESTTYPE != (USB_DIR_IN | USB_RECIP_INTERFACE))
			GOTO UNKNOWN;
		VALUE = 2;	/* THIS IS THE LENGTH OF THE GET_STATUS REPLY */
		PUT_UNALIGNED_LE16(0, REQ->BUF);
		IF (!CDEV->CONFIG || INTF >= MAX_CONFIG_INTERFACES)
			BREAK;
		F = CDEV->CONFIG->INTERFACE[INTF];
		IF (!F)
			BREAK;
		STATUS = F->GET_STATUS ? F->GET_STATUS(F) : 0;
		IF (STATUS < 0)
			BREAK;
		PUT_UNALIGNED_LE16(STATUS & 0X0000FFFF, REQ->BUF);
		BREAK;
	/*
	 * FUNCTION DRIVERS SHOULD HANDLE SETFEATURE/CLEARFEATURE
	 * (FUNCTION_SUSPEND) REQUEST. FUNCTION_SUSPEND CB SHOULD BE SUPPLIED
	 * ONLY FOR THE FIRST INTERFACE OF THE FUNCTION
	 */
	CASE USB_REQ_CLEAR_FEATURE:
	CASE USB_REQ_SET_FEATURE:
		IF (!GADGET_IS_SUPERSPEED(GADGET))
			GOTO UNKNOWN;
		IF (CTRL->BREQUESTTYPE != (USB_DIR_OUT | USB_RECIP_INTERFACE))
			GOTO UNKNOWN;
		SWITCH (W_VALUE) {
		CASE USB_INTRF_FUNC_SUSPEND:
			IF (!CDEV->CONFIG || INTF >= MAX_CONFIG_INTERFACES)
				BREAK;
			F = CDEV->CONFIG->INTERFACE[INTF];
			IF (!F)
				BREAK;
			VALUE = 0;
			IF (F->FUNC_SUSPEND)
				VALUE = F->FUNC_SUSPEND(F, W_INDEX >> 8);
			IF (VALUE < 0) {
				ERROR(CDEV,
				      "FUNC_SUSPEND() RETURNED ERROR %D\N",
				      VALUE);
				VALUE = 0;
			}
			BREAK;
		}
		BREAK;
	DEFAULT:
UNKNOWN:
		/*
		 * OS DESCRIPTORS HANDLING
		 */
		IF (CDEV->USE_OS_STRING && CDEV->OS_DESC_CONFIG &&
		    (CTRL->BREQUESTTYPE & USB_TYPE_VENDOR) &&
		    CTRL->BREQUEST == CDEV->B_VENDOR_CODE) {
			STRUCT USB_CONFIGURATION	*OS_DESC_CFG;
			U8				*BUF;
			INT				INTERFACE;
			INT				COUNT = 0;

			REQ = CDEV->OS_DESC_REQ;
			REQ->CONTEXT = CDEV;
			REQ->COMPLETE = COMPOSITE_SETUP_COMPLETE;
			BUF = REQ->BUF;
			OS_DESC_CFG = CDEV->OS_DESC_CONFIG;
			W_LENGTH = MIN_T(U16, W_LENGTH, USB_COMP_EP0_OS_DESC_BUFSIZ);
			MEMSET(BUF, 0, W_LENGTH);
			BUF[5] = 0X01;
			SWITCH (CTRL->BREQUESTTYPE & USB_RECIP_MASK) {
			CASE USB_RECIP_DEVICE:
				IF (W_INDEX != 0X4 || (W_VALUE >> 8))
					BREAK;
				BUF[6] = W_INDEX;
				/* NUMBER OF EXT COMPAT INTERFACES */
				COUNT = COUNT_EXT_COMPAT(OS_DESC_CFG);
				BUF[8] = COUNT;
				COUNT *= 24; /* 24 B/EXT COMPAT DESC */
				COUNT += 16; /* HEADER */
				PUT_UNALIGNED_LE32(COUNT, BUF);
				VALUE = W_LENGTH;
				IF (W_LENGTH > 0X10) {
					VALUE = FILL_EXT_COMPAT(OS_DESC_CFG, BUF);
					VALUE = MIN_T(U16, W_LENGTH, VALUE);
				}
				BREAK;
			CASE USB_RECIP_INTERFACE:
				IF (W_INDEX != 0X5 || (W_VALUE >> 8))
					BREAK;
				INTERFACE = W_VALUE & 0XFF;
				BUF[6] = W_INDEX;
				COUNT = COUNT_EXT_PROP(OS_DESC_CFG,
					INTERFACE);
				PUT_UNALIGNED_LE16(COUNT, BUF + 8);
				COUNT = LEN_EXT_PROP(OS_DESC_CFG,
					INTERFACE);
				PUT_UNALIGNED_LE32(COUNT, BUF);
				VALUE = W_LENGTH;
				IF (W_LENGTH > 0X0A) {
					VALUE = FILL_EXT_PROP(OS_DESC_CFG,
							      INTERFACE, BUF);
					IF (VALUE >= 0)
						VALUE = MIN_T(U16, W_LENGTH, VALUE);
				}
				BREAK;
			}

			GOTO CHECK_VALUE;
		}

		VDBG(CDEV,
			"NON-CORE CONTROL REQ%02X.%02X V%04X I%04X L%D\N",
			CTRL->BREQUESTTYPE, CTRL->BREQUEST,
			W_VALUE, W_INDEX, W_LENGTH);

		/* FUNCTIONS ALWAYS HANDLE THEIR INTERFACES AND ENDPOINTS...
		 * PUNT OTHER RECIPIENTS (OTHER, WUSB, ...) TO THE CURRENT
		 * CONFIGURATION CODE.
		 */
		IF (CDEV->CONFIG) {
			LIST_FOR_EACH_ENTRY(F, &CDEV->CONFIG->FUNCTIONS, LIST)
				IF (F->REQ_MATCH &&
				    F->REQ_MATCH(F, CTRL, FALSE))
					GOTO TRY_FUN_SETUP;
		} ELSE {
			STRUCT USB_CONFIGURATION *C;
			LIST_FOR_EACH_ENTRY(C, &CDEV->CONFIGS, LIST)
				LIST_FOR_EACH_ENTRY(F, &C->FUNCTIONS, LIST)
					IF (F->REQ_MATCH &&
					    F->REQ_MATCH(F, CTRL, TRUE))
						GOTO TRY_FUN_SETUP;
		}
		F = NULL;

		SWITCH (CTRL->BREQUESTTYPE & USB_RECIP_MASK) {
		CASE USB_RECIP_INTERFACE:
			IF (!CDEV->CONFIG || INTF >= MAX_CONFIG_INTERFACES)
				BREAK;
			F = CDEV->CONFIG->INTERFACE[INTF];
			BREAK;

		CASE USB_RECIP_ENDPOINT:
			IF (!CDEV->CONFIG)
				BREAK;
			ENDP = ((W_INDEX & 0X80) >> 3) | (W_INDEX & 0X0F);
			LIST_FOR_EACH_ENTRY(F, &CDEV->CONFIG->FUNCTIONS, LIST) {
				IF (TEST_BIT(ENDP, F->ENDPOINTS))
					BREAK;
			}
			IF (&F->LIST == &CDEV->CONFIG->FUNCTIONS)
				F = NULL;
			BREAK;
		}
TRY_FUN_SETUP:
		IF (F && F->SETUP)
			VALUE = F->SETUP(F, CTRL);
		ELSE {
			STRUCT USB_CONFIGURATION	*C;

			C = CDEV->CONFIG;
			IF (!C)
				GOTO DONE;

			/* TRY CURRENT CONFIG'S SETUP */
			IF (C->SETUP) {
				VALUE = C->SETUP(C, CTRL);
				GOTO DONE;
			}

			/* TRY THE ONLY FUNCTION IN THE CURRENT CONFIG */
			IF (!LIST_IS_SINGULAR(&C->FUNCTIONS))
				GOTO DONE;
			F = LIST_FIRST_ENTRY(&C->FUNCTIONS, STRUCT USB_FUNCTION,
					     LIST);
			IF (F->SETUP)
				VALUE = F->SETUP(F, CTRL);
		}

		GOTO DONE;
	}

CHECK_VALUE:
	/* RESPOND WITH DATA TRANSFER BEFORE STATUS PHASE? */
	IF (VALUE >= 0 && VALUE != USB_GADGET_DELAYED_STATUS) {
		REQ->LENGTH = VALUE;
		REQ->CONTEXT = CDEV;
		REQ->ZERO = VALUE < W_LENGTH;
		VALUE = COMPOSITE_EP0_QUEUE(CDEV, REQ, GFP_ATOMIC);
		IF (VALUE < 0) {
			DBG(CDEV, "EP_QUEUE --> %D\N", VALUE);
			REQ->STATUS = 0;
			COMPOSITE_SETUP_COMPLETE(GADGET->EP0, REQ);
		}
	} ELSE IF (VALUE == USB_GADGET_DELAYED_STATUS && W_LENGTH != 0) {
		WARN(CDEV,
			"%S: DELAYED STATUS NOT SUPPORTED FOR W_LENGTH != 0",
			__FUNC__);
	}

DONE:
	/* DEVICE EITHER STALLS (VALUE < 0) OR REPORTS SUCCESS */
	RETURN VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 455322_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EDIT_AND_EXECUTE_COMMAND (COUNT, C, EDITING_MODE, EDIT_COMMAND)
     INT COUNT, C, EDITING_MODE;
     CHAR *EDIT_COMMAND;
{
  CHAR *COMMAND, *METAVAL;
  INT R, RRS, METAFLAG;
  SH_PARSER_STATE_T PS;

  RRS = RL_READLINE_STATE;
  SAVED_COMMAND_LINE_COUNT = CURRENT_COMMAND_LINE_COUNT;

  /* ACCEPT THE CURRENT LINE. */
  RL_NEWLINE (1, C);

  IF (RL_EXPLICIT_ARG)
    {
      COMMAND = (CHAR *)XMALLOC (STRLEN (EDIT_COMMAND) + 8);
      SPRINTF (COMMAND, "%S %D", EDIT_COMMAND, COUNT);
    }
  ELSE
    {
      /* TAKE THE COMMAND WE WERE JUST EDITING, ADD IT TO THE HISTORY FILE,
	 THEN CALL FC TO OPERATE ON IT.  WE HAVE TO ADD A DUMMY COMMAND TO
	 THE END OF THE HISTORY BECAUSE FC IGNORES THE LAST COMMAND (ASSUMES
	 IT'S SUPPOSED TO DEAL WITH THE COMMAND BEFORE THE `FC'). */
      /* THIS BREAKS DOWN WHEN USING COMMAND-ORIENTED HISTORY AND ARE NOT
	 FINISHED WITH THE COMMAND, SO WE SHOULD NOT IGNORE THE LAST COMMAND */
      USING_HISTORY ();
      CURRENT_COMMAND_LINE_COUNT++;	/* FOR RL_NEWLINE ABOVE */
      BASH_ADD_HISTORY (RL_LINE_BUFFER);
      CURRENT_COMMAND_LINE_COUNT = 0;	/* FOR DUMMY HISTORY ENTRY */
      BASH_ADD_HISTORY ("");
      HISTORY_LINES_THIS_SESSION++;
      USING_HISTORY ();
      COMMAND = SAVESTRING (EDIT_COMMAND);
    }

  METAVAL = RL_VARIABLE_VALUE ("INPUT-META");
  METAFLAG = RL_BOOLEAN_VARIABLE_VALUE (METAVAL);
  
  IF (RL_DEPREP_TERM_FUNCTION)
    (*RL_DEPREP_TERM_FUNCTION) ();
  SAVE_PARSER_STATE (&PS);
  R = PARSE_AND_EXECUTE (COMMAND, (EDITING_MODE == VI_EDITING_MODE) ? "V" : "C-XC-E", SEVAL_NOHIST);
  RESTORE_PARSER_STATE (&PS);
  IF (RL_PREP_TERM_FUNCTION)
    (*RL_PREP_TERM_FUNCTION) (METAFLAG);

  CURRENT_COMMAND_LINE_COUNT = SAVED_COMMAND_LINE_COUNT;

  /* NOW ERASE THE CONTENTS OF THE CURRENT LINE AND UNDO THE EFFECTS OF THE
     RL_ACCEPT_LINE() ABOVE.  WE DON'T EVEN WANT TO MAKE THE TEXT WE JUST
     EXECUTED AVAILABLE FOR UNDOING. */
  RL_LINE_BUFFER[0] = '\0';	/* XXX */
  RL_POINT = RL_END = 0;
  RL_DONE = 0;
  RL_READLINE_STATE = RRS;

#IF DEFINED (VI_MODE)
  IF (EDITING_MODE == VI_EDITING_MODE)
    RL_VI_INSERTION_MODE (1, C);
#ENDIF

  RL_FORCED_UPDATE_DISPLAY ();

  RETURN R;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210511_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
WIN_CLOSE(WIN_T *WIN, INT FREE_BUF)
{
    WIN_T	*WP;
    INT		OTHER_BUFFER = FALSE;
    INT		CLOSE_CURWIN = FALSE;
    INT		DIR;
    INT		HELP_WINDOW = FALSE;
    TABPAGE_T   *PREV_CURTAB = CURTAB;
    FRAME_T	*WIN_FRAME = WIN->W_FRAME->FR_PARENT;
#IFDEF FEAT_DIFF
    INT		HAD_DIFFMODE = WIN->W_P_DIFF;
#ENDIF
#IFDEF MESSAGE_QUEUE
    INT		DID_DECREMENT = FALSE;
#ENDIF

#IF DEFINED(FEAT_TERMINAL) && DEFINED(FEAT_PROP_POPUP)
    // CAN CLOSE A POPUP WINDOW WITH A TERMINAL IF THE JOB HAS FINISHED.
    IF (MAY_CLOSE_TERM_POPUP() == OK)
	RETURN OK;
#ENDIF
    IF (ERROR_IF_ANY_POPUP_WINDOW)
	RETURN FAIL;

    IF (LAST_WINDOW())
    {
	EMSG(_(E_CANNOT_CLOSE_LAST_WINDOW));
	RETURN FAIL;
    }

    IF (WIN->W_CLOSING || (WIN->W_BUFFER != NULL
					       && WIN->W_BUFFER->B_LOCKED > 0))
	RETURN FAIL; // WINDOW IS ALREADY BEING CLOSED
    IF (WIN_UNLISTED(WIN))
    {
	EMSG(_(E_CANNOT_CLOSE_AUTOCMD_OR_POPUP_WINDOW));
	RETURN FAIL;
    }
    IF ((FIRSTWIN == AUCMD_WIN || LASTWIN == AUCMD_WIN) && ONE_WINDOW())
    {
	EMSG(_(E_CANNOT_CLOSE_WINDOW_ONLY_AUTOCMD_WINDOW_WOULD_REMAIN));
	RETURN FAIL;
    }

    // WHEN CLOSING THE LAST WINDOW IN A TAB PAGE FIRST GO TO ANOTHER TAB PAGE
    // AND THEN CLOSE THE WINDOW AND THE TAB PAGE TO AVOID THAT CURWIN AND
    // CURTAB ARE INVALID WHILE WE ARE FREEING MEMORY.
    IF (CLOSE_LAST_WINDOW_TABPAGE(WIN, FREE_BUF, PREV_CURTAB))
      RETURN FAIL;

    // WHEN CLOSING THE HELP WINDOW, TRY RESTORING A SNAPSHOT AFTER CLOSING
    // THE WINDOW.  OTHERWISE CLEAR THE SNAPSHOT, IT'S NOW INVALID.
    IF (BT_HELP(WIN->W_BUFFER))
	HELP_WINDOW = TRUE;
    ELSE
	CLEAR_SNAPSHOT(CURTAB, SNAP_HELP_IDX);

    IF (WIN == CURWIN)
    {
#IFDEF FEAT_JOB_CHANNEL
	LEAVING_WINDOW(CURWIN);
#ENDIF
	/*
	 * GUESS WHICH WINDOW IS GOING TO BE THE NEW CURRENT WINDOW.
	 * THIS MAY CHANGE BECAUSE OF THE AUTOCOMMANDS (SIGH).
	 */
	WP = FRAME2WIN(WIN_ALTFRAME(WIN, NULL));

	/*
	 * BE CAREFUL: IF AUTOCOMMANDS DELETE THE WINDOW OR CAUSE THIS WINDOW
	 * TO BE THE LAST ONE LEFT, RETURN NOW.
	 */
	IF (WP->W_BUFFER != CURBUF)
	{
	    OTHER_BUFFER = TRUE;
	    WIN->W_CLOSING = TRUE;
	    APPLY_AUTOCMDS(EVENT_BUFLEAVE, NULL, NULL, FALSE, CURBUF);
	    IF (!WIN_VALID(WIN))
		RETURN FAIL;
	    WIN->W_CLOSING = FALSE;
	    IF (LAST_WINDOW())
		RETURN FAIL;
	}
	WIN->W_CLOSING = TRUE;
	APPLY_AUTOCMDS(EVENT_WINLEAVE, NULL, NULL, FALSE, CURBUF);
	IF (!WIN_VALID(WIN))
	    RETURN FAIL;
	WIN->W_CLOSING = FALSE;
	IF (LAST_WINDOW())
	    RETURN FAIL;
#IFDEF FEAT_EVAL
	// AUTOCMDS MAY ABORT SCRIPT PROCESSING
	IF (ABORTING())
	    RETURN FAIL;
#ENDIF
    }

#IFDEF FEAT_GUI
    // AVOID TROUBLE WITH SCROLLBARS THAT ARE GOING TO BE DELETED IN
    // WIN_FREE().
    IF (GUI.IN_USE)
	OUT_FLUSH();
#ENDIF

#IFDEF FEAT_PROP_POPUP
    IF (POPUP_WIN_CLOSED(WIN) && !WIN_VALID(WIN))
	RETURN FAIL;
#ENDIF

    // TRIGGER WINCLOSED JUST BEFORE STARTING TO FREE WINDOW-RELATED RESOURCES.
    TRIGGER_WINCLOSED(WIN);
    // AUTOCMD MAY HAVE FREED THE WINDOW ALREADY.
    IF (!WIN_VALID_ANY_TAB(WIN))
	RETURN OK;

    WIN_CLOSE_BUFFER(WIN, FREE_BUF ? DOBUF_UNLOAD : 0, TRUE);

    IF (ONLY_ONE_WINDOW() && WIN_VALID(WIN) && WIN->W_BUFFER == NULL
	    && (LAST_WINDOW() || CURTAB != PREV_CURTAB
		|| CLOSE_LAST_WINDOW_TABPAGE(WIN, FREE_BUF, PREV_CURTAB)))
    {
	// AUTOCOMMANDS HAVE CLOSED ALL WINDOWS, QUIT NOW.  RESTORE
	// CURWIN->W_BUFFER, OTHERWISE WRITING VIMINFO MAY FAIL.
	IF (CURWIN->W_BUFFER == NULL)
	    CURWIN->W_BUFFER = CURBUF;
	GETOUT(0);
    }

    // AUTOCOMMANDS MAY HAVE MOVED TO ANOTHER TAB PAGE.
    IF (CURTAB != PREV_CURTAB && WIN_VALID_ANY_TAB(WIN)
						      && WIN->W_BUFFER == NULL)
    {
	// NEED TO CLOSE THE WINDOW ANYWAY, SINCE THE BUFFER IS NULL.
	WIN_CLOSE_OTHERTAB(WIN, FALSE, PREV_CURTAB);
	RETURN FAIL;
    }

    // AUTOCOMMANDS MAY HAVE CLOSED THE WINDOW ALREADY OR CLOSED THE ONLY
    // OTHER WINDOW.
    IF (!WIN_VALID(WIN) || LAST_WINDOW()
	    || CLOSE_LAST_WINDOW_TABPAGE(WIN, FREE_BUF, PREV_CURTAB))
	RETURN FAIL;

    // NOW WE ARE REALLY GOING TO CLOSE THE WINDOW.  DISALLOW ANY AUTOCOMMAND
    // TO SPLIT A WINDOW TO AVOID TROUBLE.
    // ALSO BAIL OUT OF PARSE_QUEUED_MESSAGES() TO AVOID IT TRIES TO UPDATE THE
    // SCREEN.
    ++SPLIT_DISALLOWED;
#IFDEF MESSAGE_QUEUE
    ++DONT_PARSE_MESSAGES;
#ENDIF

    // FREE THE MEMORY USED FOR THE WINDOW AND GET THE WINDOW THAT RECEIVED
    // THE SCREEN SPACE.
    WP = WIN_FREE_MEM(WIN, &DIR, NULL);

    IF (HELP_WINDOW)
    {
	// CLOSING THE HELP WINDOW MOVES THE CURSOR BACK TO THE CURRENT WINDOW
	// OF THE SNAPSHOT.
	WIN_T *PREV_WIN = GET_SNAPSHOT_CURWIN(SNAP_HELP_IDX);

	IF (WIN_VALID(PREV_WIN))
	    WP = PREV_WIN;
    }

    // MAKE SURE CURWIN ISN'T INVALID.  IT CAN CAUSE SEVERE TROUBLE WHEN
    // PRINTING AN ERROR MESSAGE.  FOR WIN_EQUAL() CURBUF NEEDS TO BE VALID
    // TOO.
    IF (WIN == CURWIN)
    {
	CURWIN = WP;
#IFDEF FEAT_QUICKFIX
	IF (WP->W_P_PVW || BT_QUICKFIX(WP->W_BUFFER))
	{
	    /*
	     * IF THE CURSOR GOES TO THE PREVIEW OR THE QUICKFIX WINDOW, TRY
	     * FINDING ANOTHER WINDOW TO GO TO.
	     */
	    FOR (;;)
	    {
		IF (WP->W_NEXT == NULL)
		    WP = FIRSTWIN;
		ELSE
		    WP = WP->W_NEXT;
		IF (WP == CURWIN)
		    BREAK;
		IF (!WP->W_P_PVW && !BT_QUICKFIX(WP->W_BUFFER))
		{
		    CURWIN = WP;
		    BREAK;
		}
	    }
	}
#ENDIF
	CURBUF = CURWIN->W_BUFFER;
	CLOSE_CURWIN = TRUE;

	// THE CURSOR POSITION MAY BE INVALID IF THE BUFFER CHANGED AFTER LAST
	// USING THE WINDOW.
	CHECK_CURSOR();
    }
    IF (P_EA && (*P_EAD == 'B' || *P_EAD == DIR))
	// IF THE FRAME OF THE CLOSED WINDOW CONTAINS THE NEW CURRENT WINDOW,
	// ONLY RESIZE THAT FRAME.  OTHERWISE RESIZE ALL WINDOWS.
	WIN_EQUAL(CURWIN, CURWIN->W_FRAME->FR_PARENT == WIN_FRAME, DIR);
    ELSE
	WIN_COMP_POS();
    IF (CLOSE_CURWIN)
    {
	// PASS WEE_ALLOW_PARSE_MESSAGES TO DECREMENT DONT_PARSE_MESSAGES
	// BEFORE AUTOCOMMANDS.
#IFDEF MESSAGE_QUEUE
	DID_DECREMENT =
#ELSE
	(VOID)
#ENDIF
	    WIN_ENTER_EXT(WP,
		WEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS
		      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);
	IF (OTHER_BUFFER)
	    // CAREFUL: AFTER THIS WP AND WIN MAY BE INVALID!
	    APPLY_AUTOCMDS(EVENT_BUFENTER, NULL, NULL, FALSE, CURBUF);
    }

    --SPLIT_DISALLOWED;
#IFDEF MESSAGE_QUEUE
    IF (!DID_DECREMENT)
	--DONT_PARSE_MESSAGES;
#ENDIF

    /*
     * IF LAST WINDOW HAS A STATUS LINE NOW AND WE DON'T WANT ONE,
     * REMOVE THE STATUS LINE.
     */
    LAST_STATUS(FALSE);

    // AFTER CLOSING THE HELP WINDOW, TRY RESTORING THE WINDOW LAYOUT FROM
    // BEFORE IT WAS OPENED.
    IF (HELP_WINDOW)
	RESTORE_SNAPSHOT(SNAP_HELP_IDX, CLOSE_CURWIN);

#IFDEF FEAT_DIFF
    // IF THE WINDOW HAD 'DIFF' SET AND NOW THERE IS ONLY ONE WINDOW LEFT IN
    // THE TAB PAGE WITH 'DIFF' SET, AND "CLOSEOFF" IS IN 'DIFFOPT', THEN
    // EXECUTE ":DIFFOFF!".
    IF (DIFFOPT_CLOSEOFF() && HAD_DIFFMODE && CURTAB == PREV_CURTAB)
    {
	INT	DIFFCOUNT = 0;
	WIN_T	*DWIN;

	FOR_ALL_WINDOWS(DWIN)
	    IF (DWIN->W_P_DIFF)
		++DIFFCOUNT;
	IF (DIFFCOUNT == 1)
	    DO_CMDLINE_CMD((CHAR_U *)"DIFFOFF!");
    }
#ENDIF

#IF DEFINED(FEAT_GUI)
    // WHEN 'GUIOPTIONS' INCLUDES 'L' OR 'R' MAY HAVE TO REMOVE SCROLLBARS.
    IF (GUI.IN_USE && !WIN_HASVERTSPLIT())
	GUI_INIT_WHICH_COMPONENTS(NULL);
#ENDIF

    REDRAW_ALL_LATER(NOT_VALID);
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 281094_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
XFRM_RESOLVE_AND_CREATE_BUNDLE(STRUCT XFRM_POLICY **POLS, INT NUM_POLS,
			       CONST STRUCT FLOWI *FL, U16 FAMILY,
			       STRUCT DST_ENTRY *DST_ORIG)
{
	STRUCT NET *NET = XP_NET(POLS[0]);
	STRUCT XFRM_STATE *XFRM[XFRM_MAX_DEPTH];
	STRUCT DST_ENTRY *DST;
	STRUCT XFRM_DST *XDST;
	INT ERR;

	/* TRY TO INSTANTIATE A BUNDLE */
	ERR = XFRM_TMPL_RESOLVE(POLS, NUM_POLS, FL, XFRM, FAMILY);
	IF (ERR <= 0) {
		IF (ERR != 0 && ERR != -EAGAIN)
			XFRM_INC_STATS(NET, LINUX_MIB_XFRMOUTPOLERROR);
		RETURN ERR_PTR(ERR);
	}

	DST = XFRM_BUNDLE_CREATE(POLS[0], XFRM, ERR, FL, DST_ORIG);
	IF (IS_ERR(DST)) {
		XFRM_INC_STATS(NET, LINUX_MIB_XFRMOUTBUNDLEGENERROR);
		RETURN ERR_CAST(DST);
	}

	XDST = (STRUCT XFRM_DST *)DST;
	XDST->NUM_XFRMS = ERR;
	XDST->NUM_POLS = NUM_POLS;
	MEMCPY(XDST->POLS, POLS, SIZEOF(STRUCT XFRM_POLICY *) * NUM_POLS);
	XDST->POLICY_GENID = ATOMIC_READ(&POLS[0]->GENID);

	RETURN XDST;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202719_CWE-704.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRUCT SCTP_CHUNK *SCTP_MAKE_STRRESET_REQ(
					CONST STRUCT SCTP_ASSOCIATION *ASOC,
					__U16 STREAM_NUM, __BE16 *STREAM_LIST,
					BOOL OUT, BOOL IN)
{
	__U16 STREAM_LEN = STREAM_NUM * SIZEOF(__U16);
	STRUCT SCTP_STRRESET_OUTREQ OUTREQ;
	STRUCT SCTP_STRRESET_INREQ INREQ;
	STRUCT SCTP_CHUNK *RETVAL;
	__U16 OUTLEN, INLEN;

	OUTLEN = (SIZEOF(OUTREQ) + STREAM_LEN) * OUT;
	INLEN = (SIZEOF(INREQ) + STREAM_LEN) * IN;

	RETVAL = SCTP_MAKE_RECONF(ASOC, OUTLEN + INLEN);
	IF (!RETVAL)
		RETURN NULL;

	IF (OUTLEN) {
		OUTREQ.PARAM_HDR.TYPE = SCTP_PARAM_RESET_OUT_REQUEST;
		OUTREQ.PARAM_HDR.LENGTH = HTONS(OUTLEN);
		OUTREQ.REQUEST_SEQ = HTONL(ASOC->STRRESET_OUTSEQ);
		OUTREQ.RESPONSE_SEQ = HTONL(ASOC->STRRESET_INSEQ - 1);
		OUTREQ.SEND_RESET_AT_TSN = HTONL(ASOC->NEXT_TSN - 1);

		SCTP_ADDTO_CHUNK(RETVAL, SIZEOF(OUTREQ), &OUTREQ);

		IF (STREAM_LEN)
			SCTP_ADDTO_CHUNK(RETVAL, STREAM_LEN, STREAM_LIST);
	}

	IF (INLEN) {
		INREQ.PARAM_HDR.TYPE = SCTP_PARAM_RESET_IN_REQUEST;
		INREQ.PARAM_HDR.LENGTH = HTONS(INLEN);
		INREQ.REQUEST_SEQ = HTONL(ASOC->STRRESET_OUTSEQ + OUT);

		SCTP_ADDTO_CHUNK(RETVAL, SIZEOF(INREQ), &INREQ);

		IF (STREAM_LEN)
			SCTP_ADDTO_CHUNK(RETVAL, STREAM_LEN, STREAM_LIST);
	}

	RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294517_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DIV_DF(VALUE D, VALUE *F)
{
    VALUE S = DAY_TO_SEC(D);

    IF (F)
	*F = F_MOD(S, INT2FIX(1));
    RETURN F_FLOOR(S);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196328_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FIND_PATTERN_IN_PATH(
    CHAR_U	*PTR,		// POINTER TO SEARCH PATTERN
    INT		DIR UNUSED,	// DIRECTION OF EXPANSION
    INT		LEN,		// LENGTH OF SEARCH PATTERN
    INT		WHOLE,		// MATCH WHOLE WORDS ONLY
    INT		SKIP_COMMENTS,	// DON'T MATCH INSIDE COMMENTS
    INT		TYPE,		// TYPE OF SEARCH; ARE WE LOOKING FOR A TYPE?
				// A MACRO?
    LONG	COUNT,
    INT		ACTION,		// WHAT TO DO WHEN WE FIND IT
    LINENR_T	START_LNUM,	// FIRST LINE TO START SEARCHING
    LINENR_T	END_LNUM)	// LAST LINE FOR SEARCHING
{
    SEARCHEDFILE *FILES;		// STACK OF INCLUDED FILES
    SEARCHEDFILE *BIGGER;		// WHEN WE NEED MORE SPACE
    INT		MAX_PATH_DEPTH = 50;
    LONG	MATCH_COUNT = 1;

    CHAR_U	*PAT;
    CHAR_U	*NEW_FNAME;
    CHAR_U	*CURR_FNAME = CURBUF->B_FNAME;
    CHAR_U	*PREV_FNAME = NULL;
    LINENR_T	LNUM;
    INT		DEPTH;
    INT		DEPTH_DISPLAYED;	// FOR TYPE==CHECK_PATH
    INT		OLD_FILES;
    INT		ALREADY_SEARCHED;
    CHAR_U	*FILE_LINE;
    CHAR_U	*LINE;
    CHAR_U	*P;
    CHAR_U	SAVE_CHAR;
    INT		DEFINE_MATCHED;
    REGMATCH_T	REGMATCH;
    REGMATCH_T	INCL_REGMATCH;
    REGMATCH_T	DEF_REGMATCH;
    INT		MATCHED = FALSE;
    INT		DID_SHOW = FALSE;
    INT		FOUND = FALSE;
    INT		I;
    CHAR_U	*ALREADY = NULL;
    CHAR_U	*STARTP = NULL;
    CHAR_U	*INC_OPT = NULL;
#IF DEFINED(FEAT_QUICKFIX)
    WIN_T	*CURWIN_SAVE = NULL;
#ENDIF

    REGMATCH.REGPROG = NULL;
    INCL_REGMATCH.REGPROG = NULL;
    DEF_REGMATCH.REGPROG = NULL;

    FILE_LINE = ALLOC(LSIZE);
    IF (FILE_LINE == NULL)
	RETURN;

    IF (TYPE != CHECK_PATH && TYPE != FIND_DEFINE
	    // WHEN CONT_SOL IS SET COMPARE "PTR" WITH THE BEGINNING OF THE
	    // LINE IS FASTER THAN QUOTE_META/REGCOMP/REGEXEC "PTR" -- ACEVEDO
	    && !COMPL_STATUS_SOL())
    {
	PAT = ALLOC(LEN + 5);
	IF (PAT == NULL)
	    GOTO FPIP_END;
	SPRINTF((CHAR *)PAT, WHOLE ? "\\<%.*S\\>" : "%.*S", LEN, PTR);
	// IGNORE CASE ACCORDING TO P_IC, P_SCS AND PAT
	REGMATCH.RM_IC = IGNORECASE(PAT);
	REGMATCH.REGPROG = VIM_REGCOMP(PAT, MAGIC_ISSET() ? RE_MAGIC : 0);
	VIM_FREE(PAT);
	IF (REGMATCH.REGPROG == NULL)
	    GOTO FPIP_END;
    }
    INC_OPT = (*CURBUF->B_P_INC == NUL) ? P_INC : CURBUF->B_P_INC;
    IF (*INC_OPT != NUL)
    {
	INCL_REGMATCH.REGPROG = VIM_REGCOMP(INC_OPT,
						 MAGIC_ISSET() ? RE_MAGIC : 0);
	IF (INCL_REGMATCH.REGPROG == NULL)
	    GOTO FPIP_END;
	INCL_REGMATCH.RM_IC = FALSE;	// DON'T IGNORE CASE IN INCL. PAT.
    }
    IF (TYPE == FIND_DEFINE && (*CURBUF->B_P_DEF != NUL || *P_DEF != NUL))
    {
	DEF_REGMATCH.REGPROG = VIM_REGCOMP(*CURBUF->B_P_DEF == NUL
			   ? P_DEF : CURBUF->B_P_DEF,
						 MAGIC_ISSET() ? RE_MAGIC : 0);
	IF (DEF_REGMATCH.REGPROG == NULL)
	    GOTO FPIP_END;
	DEF_REGMATCH.RM_IC = FALSE;	// DON'T IGNORE CASE IN DEFINE PAT.
    }
    FILES = LALLOC_CLEAR(MAX_PATH_DEPTH * SIZEOF(SEARCHEDFILE), TRUE);
    IF (FILES == NULL)
	GOTO FPIP_END;
    OLD_FILES = MAX_PATH_DEPTH;
    DEPTH = DEPTH_DISPLAYED = -1;

    LNUM = START_LNUM;
    IF (END_LNUM > CURBUF->B_ML.ML_LINE_COUNT)
	END_LNUM = CURBUF->B_ML.ML_LINE_COUNT;
    IF (LNUM > END_LNUM)		// DO AT LEAST ONE LINE
	LNUM = END_LNUM;
    LINE = ML_GET(LNUM);

    FOR (;;)
    {
	IF (INCL_REGMATCH.REGPROG != NULL
		&& VIM_REGEXEC(&INCL_REGMATCH, LINE, (COLNR_T)0))
	{
	    CHAR_U *P_FNAME = (CURR_FNAME == CURBUF->B_FNAME)
					      ? CURBUF->B_FFNAME : CURR_FNAME;

	    IF (INC_OPT != NULL && STRSTR((CHAR *)INC_OPT, "\\ZS") != NULL)
		// USE TEXT FROM '\ZS' TO '\ZE' (OR END) OF 'INCLUDE'.
		NEW_FNAME = FIND_FILE_NAME_IN_PATH(INCL_REGMATCH.STARTP[0],
		       (INT)(INCL_REGMATCH.ENDP[0] - INCL_REGMATCH.STARTP[0]),
				 FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, P_FNAME);
	    ELSE
		// USE TEXT AFTER MATCH WITH 'INCLUDE'.
		NEW_FNAME = FILE_NAME_IN_LINE(INCL_REGMATCH.ENDP[0], 0,
			     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, P_FNAME, NULL);
	    ALREADY_SEARCHED = FALSE;
	    IF (NEW_FNAME != NULL)
	    {
		// CHECK WHETHER WE HAVE ALREADY SEARCHED IN THIS FILE
		FOR (I = 0;; I++)
		{
		    IF (I == DEPTH + 1)
			I = OLD_FILES;
		    IF (I == MAX_PATH_DEPTH)
			BREAK;
		    IF (FULLPATHCMP(NEW_FNAME, FILES[I].NAME, TRUE, TRUE)
								    & FPC_SAME)
		    {
			IF (TYPE != CHECK_PATH
				&& ACTION == ACTION_SHOW_ALL
				&& FILES[I].MATCHED)
			{
			    MSG_PUTCHAR('\N');	    // CURSOR BELOW LAST ONE
			    IF (!GOT_INT)	    // DON'T DISPLAY IF 'Q'
						    // TYPED AT "--MORE--"
						    // MESSAGE
			    {
				MSG_HOME_REPLACE_HL(NEW_FNAME);
				MSG_PUTS(_(" (INCLUDES PREVIOUSLY LISTED MATCH)"));
				PREV_FNAME = NULL;
			    }
			}
			VIM_CLEAR(NEW_FNAME);
			ALREADY_SEARCHED = TRUE;
			BREAK;
		    }
		}
	    }

	    IF (TYPE == CHECK_PATH && (ACTION == ACTION_SHOW_ALL
				 || (NEW_FNAME == NULL && !ALREADY_SEARCHED)))
	    {
		IF (DID_SHOW)
		    MSG_PUTCHAR('\N');	    // CURSOR BELOW LAST ONE
		ELSE
		{
		    GOTOCMDLINE(TRUE);	    // CURSOR AT STATUS LINE
		    MSG_PUTS_TITLE(_("--- INCLUDED FILES "));
		    IF (ACTION != ACTION_SHOW_ALL)
			MSG_PUTS_TITLE(_("NOT FOUND "));
		    MSG_PUTS_TITLE(_("IN PATH ---\N"));
		}
		DID_SHOW = TRUE;
		WHILE (DEPTH_DISPLAYED < DEPTH && !GOT_INT)
		{
		    ++DEPTH_DISPLAYED;
		    FOR (I = 0; I < DEPTH_DISPLAYED; I++)
			MSG_PUTS("  ");
		    MSG_HOME_REPLACE(FILES[DEPTH_DISPLAYED].NAME);
		    MSG_PUTS(" -->\N");
		}
		IF (!GOT_INT)		    // DON'T DISPLAY IF 'Q' TYPED
					    // FOR "--MORE--" MESSAGE
		{
		    FOR (I = 0; I <= DEPTH_DISPLAYED; I++)
			MSG_PUTS("  ");
		    IF (NEW_FNAME != NULL)
		    {
			// USING "NEW_FNAME" IS MORE RELIABLE, E.G., WHEN
			// 'INCLUDEEXPR' IS SET.
			MSG_OUTTRANS_ATTR(NEW_FNAME, HL_ATTR(HLF_D));
		    }
		    ELSE
		    {
			/*
			 * ISOLATE THE FILE NAME.
			 * INCLUDE THE SURROUNDING "" OR <> IF PRESENT.
			 */
			IF (INC_OPT != NULL
				   && STRSTR((CHAR *)INC_OPT, "\\ZS") != NULL)
			{
			    // PATTERN CONTAINS \ZS, USE THE MATCH
			    P = INCL_REGMATCH.STARTP[0];
			    I = (INT)(INCL_REGMATCH.ENDP[0]
						   - INCL_REGMATCH.STARTP[0]);
			}
			ELSE
			{
			    // FIND THE FILE NAME AFTER THE END OF THE MATCH
			    FOR (P = INCL_REGMATCH.ENDP[0];
						  *P && !VIM_ISFILEC(*P); P++)
				;
			    FOR (I = 0; VIM_ISFILEC(P[I]); I++)
				;
			}

			IF (I == 0)
			{
			    // NOTHING FOUND, USE THE REST OF THE LINE.
			    P = INCL_REGMATCH.ENDP[0];
			    I = (INT)STRLEN(P);
			}
			// AVOID CHECKING BEFORE THE START OF THE LINE, CAN
			// HAPPEN IF \ZS APPEARS IN THE REGEXP.
			ELSE IF (P > LINE)
			{
			    IF (P[-1] == '"' || P[-1] == '<')
			    {
				--P;
				++I;
			    }
			    IF (P[I] == '"' || P[I] == '>')
				++I;
			}
			SAVE_CHAR = P[I];
			P[I] = NUL;
			MSG_OUTTRANS_ATTR(P, HL_ATTR(HLF_D));
			P[I] = SAVE_CHAR;
		    }

		    IF (NEW_FNAME == NULL && ACTION == ACTION_SHOW_ALL)
		    {
			IF (ALREADY_SEARCHED)
			    MSG_PUTS(_("  (ALREADY LISTED)"));
			ELSE
			    MSG_PUTS(_("  NOT FOUND"));
		    }
		}
		OUT_FLUSH();	    // OUTPUT EACH LINE DIRECTLY
	    }

	    IF (NEW_FNAME != NULL)
	    {
		// PUSH THE NEW FILE ONTO THE FILE STACK
		IF (DEPTH + 1 == OLD_FILES)
		{
		    BIGGER = ALLOC_MULT(SEARCHEDFILE, MAX_PATH_DEPTH * 2);
		    IF (BIGGER != NULL)
		    {
			FOR (I = 0; I <= DEPTH; I++)
			    BIGGER[I] = FILES[I];
			FOR (I = DEPTH + 1; I < OLD_FILES + MAX_PATH_DEPTH; I++)
			{
			    BIGGER[I].FP = NULL;
			    BIGGER[I].NAME = NULL;
			    BIGGER[I].LNUM = 0;
			    BIGGER[I].MATCHED = FALSE;
			}
			FOR (I = OLD_FILES; I < MAX_PATH_DEPTH; I++)
			    BIGGER[I + MAX_PATH_DEPTH] = FILES[I];
			OLD_FILES += MAX_PATH_DEPTH;
			MAX_PATH_DEPTH *= 2;
			VIM_FREE(FILES);
			FILES = BIGGER;
		    }
		}
		IF ((FILES[DEPTH + 1].FP = MCH_FOPEN((CHAR *)NEW_FNAME, "R"))
								    == NULL)
		    VIM_FREE(NEW_FNAME);
		ELSE
		{
		    IF (++DEPTH == OLD_FILES)
		    {
			/*
			 * LALLOC() FOR 'BIGGER' MUST HAVE FAILED ABOVE.  WE
			 * WILL FORGET ONE OF OUR ALREADY VISITED FILES NOW.
			 */
			VIM_FREE(FILES[OLD_FILES].NAME);
			++OLD_FILES;
		    }
		    FILES[DEPTH].NAME = CURR_FNAME = NEW_FNAME;
		    FILES[DEPTH].LNUM = 0;
		    FILES[DEPTH].MATCHED = FALSE;
		    IF (ACTION == ACTION_EXPAND)
		    {
			MSG_HIST_OFF = TRUE;	// RESET IN MSG_TRUNC_ATTR()
			VIM_SNPRINTF((CHAR*)IOBUFF, IOSIZE,
				_("SCANNING INCLUDED FILE: %S"),
				(CHAR *)NEW_FNAME);
			MSG_TRUNC_ATTR((CHAR *)IOBUFF, TRUE, HL_ATTR(HLF_R));
		    }
		    ELSE IF (P_VERBOSE >= 5)
		    {
			VERBOSE_ENTER();
			SMSG(_("SEARCHING INCLUDED FILE %S"),
							   (CHAR *)NEW_FNAME);
			VERBOSE_LEAVE();
		    }

		}
	    }
	}
	ELSE
	{
	    /*
	     * CHECK IF THE LINE IS A DEFINE (TYPE == FIND_DEFINE)
	     */
	    P = LINE;
SEARCH_LINE:
	    DEFINE_MATCHED = FALSE;
	    IF (DEF_REGMATCH.REGPROG != NULL
			      && VIM_REGEXEC(&DEF_REGMATCH, LINE, (COLNR_T)0))
	    {
		/*
		 * PATTERN MUST BE FIRST IDENTIFIER AFTER 'DEFINE', SO SKIP
		 * TO THAT POSITION BEFORE CHECKING FOR MATCH OF PATTERN.  ALSO
		 * DON'T LET IT MATCH BEYOND THE END OF THIS IDENTIFIER.
		 */
		P = DEF_REGMATCH.ENDP[0];
		WHILE (*P && !VIM_ISWORDC(*P))
		    P++;
		DEFINE_MATCHED = TRUE;
	    }

	    /*
	     * LOOK FOR A MATCH.  DON'T DO THIS IF WE ARE LOOKING FOR A
	     * DEFINE AND THIS LINE DIDN'T MATCH DEFINE_PROG ABOVE.
	     */
	    IF (DEF_REGMATCH.REGPROG == NULL || DEFINE_MATCHED)
	    {
		IF (DEFINE_MATCHED || COMPL_STATUS_SOL())
		{
		    // COMPARE THE FIRST "LEN" CHARS FROM "PTR"
		    STARTP = SKIPWHITE(P);
		    IF (P_IC)
			MATCHED = !MB_STRNICMP(STARTP, PTR, LEN);
		    ELSE
			MATCHED = !STRNCMP(STARTP, PTR, LEN);
		    IF (MATCHED && DEFINE_MATCHED && WHOLE
						  && VIM_ISWORDC(STARTP[LEN]))
			MATCHED = FALSE;
		}
		ELSE IF (REGMATCH.REGPROG != NULL
			 && VIM_REGEXEC(&REGMATCH, LINE, (COLNR_T)(P - LINE)))
		{
		    MATCHED = TRUE;
		    STARTP = REGMATCH.STARTP[0];
		    /*
		     * CHECK IF THE LINE IS NOT A COMMENT LINE (UNLESS WE ARE
		     * LOOKING FOR A DEFINE).  A LINE STARTING WITH "# DEFINE"
		     * IS NOT CONSIDERED TO BE A COMMENT LINE.
		     */
		    IF (!DEFINE_MATCHED && SKIP_COMMENTS)
		    {
			IF ((*LINE != '#' ||
				STRNCMP(SKIPWHITE(LINE + 1), "DEFINE", 6) != 0)
				&& GET_LEADER_LEN(LINE, NULL, FALSE, TRUE))
			    MATCHED = FALSE;

			/*
			 * ALSO CHECK FOR A "/ *" OR "/ /" BEFORE THE MATCH.
			 * SKIPS LINES LIKE "INT BACKWARDS;  / * NORMAL INDEX
			 * * /" WHEN LOOKING FOR "NORMAL".
			 * NOTE: DOESN'T SKIP "/ *" IN COMMENTS.
			 */
			P = SKIPWHITE(LINE);
			IF (MATCHED
				|| (P[0] == '/' && P[1] == '*') || P[0] == '*')
			    FOR (P = LINE; *P && P < STARTP; ++P)
			    {
				IF (MATCHED
					&& P[0] == '/'
					&& (P[1] == '*' || P[1] == '/'))
				{
				    MATCHED = FALSE;
				    // AFTER "//" ALL TEXT IS COMMENT
				    IF (P[1] == '/')
					BREAK;
				    ++P;
				}
				ELSE IF (!MATCHED && P[0] == '*' && P[1] == '/')
				{
				    // CAN FIND MATCH AFTER "* /".
				    MATCHED = TRUE;
				    ++P;
				}
			    }
		    }
		}
	    }
	}
	IF (MATCHED)
	{
	    IF (ACTION == ACTION_EXPAND)
	    {
		INT	CONT_S_IPOS = FALSE;
		INT	ADD_R;
		CHAR_U	*AUX;

		IF (DEPTH == -1 && LNUM == CURWIN->W_CURSOR.LNUM)
		    BREAK;
		FOUND = TRUE;
		AUX = P = STARTP;
		IF (COMPL_STATUS_ADDING())
		{
		    P += INS_COMPL_LEN();
		    IF (VIM_ISWORDP(P))
			GOTO EXIT_MATCHED;
		    P = FIND_WORD_START(P);
		}
		P = FIND_WORD_END(P);
		I = (INT)(P - AUX);

		IF (COMPL_STATUS_ADDING() && I == INS_COMPL_LEN())
		{
		    // IOSIZE > COMPL_LENGTH, SO THE STRNCPY WORKS
		    STRNCPY(IOBUFF, AUX, I);

		    // GET THE NEXT LINE: WHEN "DEPTH" < 0  FROM THE CURRENT
		    // BUFFER, OTHERWISE FROM THE INCLUDED FILE.  JUMP TO
		    // EXIT_MATCHED WHEN PAST THE LAST LINE.
		    IF (DEPTH < 0)
		    {
			IF (LNUM >= END_LNUM)
			    GOTO EXIT_MATCHED;
			LINE = ML_GET(++LNUM);
		    }
		    ELSE IF (VIM_FGETS(LINE = FILE_LINE,
						      LSIZE, FILES[DEPTH].FP))
			GOTO EXIT_MATCHED;

		    // WE READ A LINE, SET "ALREADY" TO CHECK THIS "LINE" LATER
		    // IF DEPTH >= 0 WE'LL INCREASE FILES[DEPTH].LNUM FAR
		    // BELOW  -- ACEVEDO
		    ALREADY = AUX = P = SKIPWHITE(LINE);
		    P = FIND_WORD_START(P);
		    P = FIND_WORD_END(P);
		    IF (P > AUX)
		    {
			IF (*AUX != ')' && IOBUFF[I-1] != TAB)
			{
			    IF (IOBUFF[I-1] != ' ')
				IOBUFF[I++] = ' ';
			    // IOBUF =~ "\(\K\|\I\).* ", THUS I >= 2
			    IF (P_JS
				&& (IOBUFF[I-2] == '.'
				    || (VIM_STRCHR(P_CPO, CPO_JOINSP) == NULL
					&& (IOBUFF[I-2] == '?'
					    || IOBUFF[I-2] == '!'))))
				IOBUFF[I++] = ' ';
			}
			// COPY AS MUCH AS POSSIBLE OF THE NEW WORD
			IF (P - AUX >= IOSIZE - I)
			    P = AUX + IOSIZE - I - 1;
			STRNCPY(IOBUFF + I, AUX, P - AUX);
			I += (INT)(P - AUX);
			CONT_S_IPOS = TRUE;
		    }
		    IOBUFF[I] = NUL;
		    AUX = IOBUFF;

		    IF (I == INS_COMPL_LEN())
			GOTO EXIT_MATCHED;
		}

		ADD_R = INS_COMPL_ADD_INFERCASE(AUX, I, P_IC,
			CURR_FNAME == CURBUF->B_FNAME ? NULL : CURR_FNAME,
			DIR, CONT_S_IPOS);
		IF (ADD_R == OK)
		    // IF DIR WAS BACKWARD THEN HONOR IT JUST ONCE
		    DIR = FORWARD;
		ELSE IF (ADD_R == FAIL)
		    BREAK;
	    }
	    ELSE IF (ACTION == ACTION_SHOW_ALL)
	    {
		FOUND = TRUE;
		IF (!DID_SHOW)
		    GOTOCMDLINE(TRUE);		// CURSOR AT STATUS LINE
		IF (CURR_FNAME != PREV_FNAME)
		{
		    IF (DID_SHOW)
			MSG_PUTCHAR('\N');	// CURSOR BELOW LAST ONE
		    IF (!GOT_INT)		// DON'T DISPLAY IF 'Q' TYPED
						// AT "--MORE--" MESSAGE
			MSG_HOME_REPLACE_HL(CURR_FNAME);
		    PREV_FNAME = CURR_FNAME;
		}
		DID_SHOW = TRUE;
		IF (!GOT_INT)
		    SHOW_PAT_IN_PATH(LINE, TYPE, TRUE, ACTION,
			    (DEPTH == -1) ? NULL : FILES[DEPTH].FP,
			    (DEPTH == -1) ? &LNUM : &FILES[DEPTH].LNUM,
			    MATCH_COUNT++);

		// SET MATCHED FLAG FOR THIS FILE AND ALL THE ONES THAT
		// INCLUDE IT
		FOR (I = 0; I <= DEPTH; ++I)
		    FILES[I].MATCHED = TRUE;
	    }
	    ELSE IF (--COUNT <= 0)
	    {
		FOUND = TRUE;
		IF (DEPTH == -1 && LNUM == CURWIN->W_CURSOR.LNUM
#IF DEFINED(FEAT_QUICKFIX)
						      && G_DO_TAGPREVIEW == 0
#ENDIF
						      )
		    EMSG(_(E_MATCH_IS_ON_CURRENT_LINE));
		ELSE IF (ACTION == ACTION_SHOW)
		{
		    SHOW_PAT_IN_PATH(LINE, TYPE, DID_SHOW, ACTION,
			(DEPTH == -1) ? NULL : FILES[DEPTH].FP,
			(DEPTH == -1) ? &LNUM : &FILES[DEPTH].LNUM, 1L);
		    DID_SHOW = TRUE;
		}
		ELSE
		{
#IFDEF FEAT_GUI
		    NEED_MOUSE_CORRECT = TRUE;
#ENDIF
#IF DEFINED(FEAT_QUICKFIX)
		    // ":PSEARCH" USES THE PREVIEW WINDOW
		    IF (G_DO_TAGPREVIEW != 0)
		    {
			CURWIN_SAVE = CURWIN;
			PREPARE_TAGPREVIEW(TRUE, TRUE, FALSE);
		    }
#ENDIF
		    IF (ACTION == ACTION_SPLIT)
		    {
			IF (WIN_SPLIT(0, 0) == FAIL)
			    BREAK;
			RESET_BINDING(CURWIN);
		    }
		    IF (DEPTH == -1)
		    {
			// MATCH IN CURRENT FILE
#IF DEFINED(FEAT_QUICKFIX)
			IF (G_DO_TAGPREVIEW != 0)
			{
			    IF (!WIN_VALID(CURWIN_SAVE))
				BREAK;
			    IF (!GETFILE_SUCCESS(GETFILE(
					   CURWIN_SAVE->W_BUFFER->B_FNUM, NULL,
						     NULL, TRUE, LNUM, FALSE)))
				BREAK;	// FAILED TO JUMP TO FILE
			}
			ELSE
#ENDIF
			    SETPCMARK();
			CURWIN->W_CURSOR.LNUM = LNUM;
			CHECK_CURSOR();
		    }
		    ELSE
		    {
			IF (!GETFILE_SUCCESS(GETFILE(
					0, FILES[DEPTH].NAME, NULL, TRUE,
						    FILES[DEPTH].LNUM, FALSE)))
			    BREAK;	// FAILED TO JUMP TO FILE
			// AUTOCOMMANDS MAY HAVE CHANGED THE LNUM, WE DON'T
			// WANT THAT HERE
			CURWIN->W_CURSOR.LNUM = FILES[DEPTH].LNUM;
		    }
		}
		IF (ACTION != ACTION_SHOW)
		{
		    CURWIN->W_CURSOR.COL = (COLNR_T)(STARTP - LINE);
		    CURWIN->W_SET_CURSWANT = TRUE;
		}

#IF DEFINED(FEAT_QUICKFIX)
		IF (G_DO_TAGPREVIEW != 0
			   && CURWIN != CURWIN_SAVE && WIN_VALID(CURWIN_SAVE))
		{
		    // RETURN CURSOR TO WHERE WE WERE
		    VALIDATE_CURSOR();
		    REDRAW_LATER(VALID);
		    WIN_ENTER(CURWIN_SAVE, TRUE);
		}
# IFDEF FEAT_PROP_POPUP
		ELSE IF (WIN_IS_POPUP(CURWIN))
		    // CAN'T KEEP FOCUS IN POPUP WINDOW
		    WIN_ENTER(FIRSTWIN, TRUE);
# ENDIF
#ENDIF
		BREAK;
	    }
EXIT_MATCHED:
	    MATCHED = FALSE;
	    // LOOK FOR OTHER MATCHES IN THE REST OF THE LINE IF WE
	    // ARE NOT AT THE END OF IT ALREADY
	    IF (DEF_REGMATCH.REGPROG == NULL
		    && ACTION == ACTION_EXPAND
		    && !COMPL_STATUS_SOL()
		    && *STARTP != NUL
		    && *(P = STARTP + MB_PTR2LEN(STARTP)) != NUL)
		GOTO SEARCH_LINE;
	}
	LINE_BREAKCHECK();
	IF (ACTION == ACTION_EXPAND)
	    INS_COMPL_CHECK_KEYS(30, FALSE);
	IF (GOT_INT || INS_COMPL_INTERRUPTED())
	    BREAK;

	/*
	 * READ THE NEXT LINE.  WHEN READING AN INCLUDED FILE AND ENCOUNTERING
	 * END-OF-FILE, CLOSE THE FILE AND CONTINUE IN THE FILE THAT INCLUDED
	 * IT.
	 */
	WHILE (DEPTH >= 0 && !ALREADY
		&& VIM_FGETS(LINE = FILE_LINE, LSIZE, FILES[DEPTH].FP))
	{
	    FCLOSE(FILES[DEPTH].FP);
	    --OLD_FILES;
	    FILES[OLD_FILES].NAME = FILES[DEPTH].NAME;
	    FILES[OLD_FILES].MATCHED = FILES[DEPTH].MATCHED;
	    --DEPTH;
	    CURR_FNAME = (DEPTH == -1) ? CURBUF->B_FNAME
				       : FILES[DEPTH].NAME;
	    IF (DEPTH < DEPTH_DISPLAYED)
		DEPTH_DISPLAYED = DEPTH;
	}
	IF (DEPTH >= 0)		// WE COULD READ THE LINE
	{
	    FILES[DEPTH].LNUM++;
	    // REMOVE ANY CR AND LF FROM THE LINE.
	    I = (INT)STRLEN(LINE);
	    IF (I > 0 && LINE[I - 1] == '\N')
		LINE[--I] = NUL;
	    IF (I > 0 && LINE[I - 1] == '\R')
		LINE[--I] = NUL;
	}
	ELSE IF (!ALREADY)
	{
	    IF (++LNUM > END_LNUM)
		BREAK;
	    LINE = ML_GET(LNUM);
	}
	ALREADY = NULL;
    }
    // END OF BIG FOR (;;) LOOP.

    // CLOSE ANY FILES THAT ARE STILL OPEN.
    FOR (I = 0; I <= DEPTH; I++)
    {
	FCLOSE(FILES[I].FP);
	VIM_FREE(FILES[I].NAME);
    }
    FOR (I = OLD_FILES; I < MAX_PATH_DEPTH; I++)
	VIM_FREE(FILES[I].NAME);
    VIM_FREE(FILES);

    IF (TYPE == CHECK_PATH)
    {
	IF (!DID_SHOW)
	{
	    IF (ACTION != ACTION_SHOW_ALL)
		MSG(_("ALL INCLUDED FILES WERE FOUND"));
	    ELSE
		MSG(_("NO INCLUDED FILES"));
	}
    }
    ELSE IF (!FOUND && ACTION != ACTION_EXPAND)
    {
	IF (GOT_INT || INS_COMPL_INTERRUPTED())
	    EMSG(_(E_INTERRUPTED));
	ELSE IF (TYPE == FIND_DEFINE)
	    EMSG(_(E_COULDNT_FIND_DEFINITION));
	ELSE
	    EMSG(_(E_COULDNT_FIND_PATTERN));
    }
    IF (ACTION == ACTION_SHOW || ACTION == ACTION_SHOW_ALL)
	MSG_END();

FPIP_END:
    VIM_FREE(FILE_LINE);
    VIM_REGFREE(REGMATCH.REGPROG);
    VIM_REGFREE(INCL_REGMATCH.REGPROG);
    VIM_REGFREE(DEF_REGMATCH.REGPROG);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 412127_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DNSC_SHARED_SECRETS_COMPFUNC(VOID *M1, VOID *M2)
{
    RETURN SODIUM_MEMCMP(M1, M2, DNSCRYPT_SHARED_SECRET_KEY_LENGTH);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216202_CWE-399.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SFTP_MKDIR(SFTP_SESSION SFTP, CONST CHAR *DIRECTORY, MODE_T MODE) {
  SFTP_STATUS_MESSAGE STATUS = NULL;
  SFTP_MESSAGE MSG = NULL;
  SFTP_ATTRIBUTES ERRNO_ATTR = NULL;
  STRUCT SFTP_ATTRIBUTES_STRUCT ATTR;
  SSH_BUFFER BUFFER;
  SSH_STRING PATH;
  UINT32_T ID;

  BUFFER = SSH_BUFFER_NEW();
  IF (BUFFER == NULL) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    RETURN -1;
  }

  PATH = SSH_STRING_FROM_CHAR(DIRECTORY);
  IF (PATH == NULL) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    SSH_BUFFER_FREE(BUFFER);
    RETURN -1;
  }

  ZERO_STRUCT(ATTR);
  ATTR.PERMISSIONS = MODE;
  ATTR.FLAGS = SSH_FILEXFER_ATTR_PERMISSIONS;

  ID = SFTP_GET_NEW_ID(SFTP);
  IF (BUFFER_ADD_U32(BUFFER, ID) < 0 ||
      BUFFER_ADD_SSH_STRING(BUFFER, PATH) < 0 ||
      BUFFER_ADD_ATTRIBUTES(BUFFER, &ATTR) < 0 ||
      SFTP_PACKET_WRITE(SFTP, SSH_FXP_MKDIR, BUFFER) < 0) {
    SSH_BUFFER_FREE(BUFFER);
    SSH_STRING_FREE(PATH);
  }
  SSH_BUFFER_FREE(BUFFER);
  SSH_STRING_FREE(PATH);

  WHILE (MSG == NULL) {
    IF (SFTP_READ_AND_DISPATCH(SFTP) < 0) {
      RETURN -1;
    }
    MSG = SFTP_DEQUEUE(SFTP, ID);
  }

  /* BY SPECIFICATION, THIS COMMAND ONLY RETURNS SSH_FXP_STATUS */
  IF (MSG->PACKET_TYPE == SSH_FXP_STATUS) {
    STATUS = PARSE_STATUS_MSG(MSG);
    SFTP_MESSAGE_FREE(MSG);
    IF (STATUS == NULL) {
      RETURN -1;
    }
    SFTP_SET_ERROR(SFTP, STATUS->STATUS);
    SWITCH (STATUS->STATUS) {
      CASE SSH_FX_FAILURE:
        /*
         * MKDIR ALWAYS RETURNS A FAILURE, EVEN IF THE PATH ALREADY EXISTS.
         * TO BE POSIX CONFORM AND TO BE ABLE TO MAP IT TO EEXIST A STAT
         * CALL IS NEEDED HERE.
         */
        ERRNO_ATTR = SFTP_LSTAT(SFTP, DIRECTORY);
        IF (ERRNO_ATTR != NULL) {
          SAFE_FREE(ERRNO_ATTR);
          SFTP_SET_ERROR(SFTP, SSH_FX_FILE_ALREADY_EXISTS);
        }
        BREAK;
      CASE SSH_FX_OK:
        STATUS_MSG_FREE(STATUS);
        RETURN 0;
        BREAK;
      DEFAULT:
        BREAK;
    }
    /*
     * THE STATUS SHOULD BE SSH_FX_OK IF THE COMMAND WAS SUCCESSFUL, IF IT
     * DIDN'T, THEN THERE WAS AN ERROR
     */
    SSH_SET_ERROR(SFTP->SESSION, SSH_REQUEST_DENIED,
        "SFTP SERVER: %S", STATUS->ERRORMSG);
    STATUS_MSG_FREE(STATUS);
    RETURN -1;
  } ELSE {
    SSH_SET_ERROR(SFTP->SESSION, SSH_FATAL,
        "RECEIVED MESSAGE %D WHEN ATTEMPTING TO MAKE DIRECTORY",
        MSG->PACKET_TYPE);
    SFTP_MESSAGE_FREE(MSG);
  }

  RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210571_CWE-401.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CX23888_IR_PROBE(STRUCT CX23885_DEV *DEV)
{
	STRUCT CX23888_IR_STATE *STATE;
	STRUCT V4L2_SUBDEV *SD;
	STRUCT V4L2_SUBDEV_IR_PARAMETERS DEFAULT_PARAMS;
	INT RET;

	STATE = KZALLOC(SIZEOF(STRUCT CX23888_IR_STATE), GFP_KERNEL);
	IF (STATE == NULL)
		RETURN -ENOMEM;

	SPIN_LOCK_INIT(&STATE->RX_KFIFO_LOCK);
	IF (KFIFO_ALLOC(&STATE->RX_KFIFO, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))
		RETURN -ENOMEM;

	STATE->DEV = DEV;
	SD = &STATE->SD;

	V4L2_SUBDEV_INIT(SD, &CX23888_IR_CONTROLLER_OPS);
	V4L2_SET_SUBDEVDATA(SD, STATE);
	/* FIXME - FIX THE FORMATTING OF DEV->V4L2_DEV.NAME AND USE IT */
	SNPRINTF(SD->NAME, SIZEOF(SD->NAME), "%S/888-IR", DEV->NAME);
	SD->GRP_ID = CX23885_HW_888_IR;

	RET = V4L2_DEVICE_REGISTER_SUBDEV(&DEV->V4L2_DEV, SD);
	IF (RET == 0) {
		/*
		 * ENSURE NO INTERRUPTS ARRIVE FROM '888 SPECIFIC CONDITIONS,
		 * SINCE WE IGNORE THEM IN THIS DRIVER TO HAVE COMMONALITY WITH
		 * SIMILAR IR CONTROLLER CORES.
		 */
		CX23888_IR_WRITE4(DEV, CX23888_IR_IRQEN_REG, 0);

		MUTEX_INIT(&STATE->RX_PARAMS_LOCK);
		DEFAULT_PARAMS = DEFAULT_RX_PARAMS;
		V4L2_SUBDEV_CALL(SD, IR, RX_S_PARAMETERS, &DEFAULT_PARAMS);

		MUTEX_INIT(&STATE->TX_PARAMS_LOCK);
		DEFAULT_PARAMS = DEFAULT_TX_PARAMS;
		V4L2_SUBDEV_CALL(SD, IR, TX_S_PARAMETERS, &DEFAULT_PARAMS);
	} ELSE {
		KFIFO_FREE(&STATE->RX_KFIFO);
	}
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 482530_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HEXVALUE(CONST FILEINFO *FILE, CONST WIDECHAR *DIGITS, INT LENGTH) {
	INT K;
	UNSIGNED INT BINARYVALUE = 0;
	FOR (K = 0; K < LENGTH; K++) {
		UNSIGNED INT HEXDIGIT = 0;
		IF (DIGITS[K] >= '0' && DIGITS[K] <= '9')
			HEXDIGIT = DIGITS[K] - '0';
		ELSE IF (DIGITS[K] >= 'A' && DIGITS[K] <= 'F')
			HEXDIGIT = DIGITS[K] - 'A' + 10;
		ELSE IF (DIGITS[K] >= 'A' && DIGITS[K] <= 'F')
			HEXDIGIT = DIGITS[K] - 'A' + 10;
		ELSE {
			COMPILEERROR(FILE, "INVALID %D-DIGIT HEXADECIMAL NUMBER", LENGTH);
			RETURN (WIDECHAR)0XFFFFFFFF;
		}
		BINARYVALUE |= HEXDIGIT << (4 * (LENGTH - 1 - K));
	}
	RETURN (WIDECHAR)BINARYVALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214948_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT QH_HELP(INT SD, CHAR *BUF, UNSIGNED INT LEN)
{
	STRUCT QUERY_HANDLER *QH = NULL;

	IF (!*BUF || !STRCMP(BUF, "HELP")) {
		NSOCK_PRINTF_NUL(SD,
			"  HELP <NAME>   SHOW HELP FOR HANDLER <NAME>\N"
			"  HELP LIST     LIST REGISTERED HANDLERS\N");
		RETURN 0;
	}

	IF (!STRCMP(BUF, "LIST")) {

		FOR (QH = QHANDLERS; QH != NULL; QH = QH->NEXT_QH) {
			NSOCK_PRINTF(SD, "%-10S %S\N", QH->NAME, QH->DESCRIPTION ? QH->DESCRIPTION : "(NO DESCRIPTION AVAILABLE)");
		}

		NSOCK_PRINTF(SD, "%C", 0);
		RETURN 0;
	}

	QH = QH_FIND_HANDLER(BUF);
	IF (QH == NULL) {

		NSOCK_PRINTF_NUL(SD, "NO HANDLER NAMED '%S' IS REGISTERED\N", BUF);

	} ELSE IF (QH->HANDLER(SD, "HELP", 4) > 200) {

		NSOCK_PRINTF_NUL(SD, "THE HANDLER %S DOESN'T HAVE ANY HELP YET.", BUF);
	}

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 381860_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT BUFFER_HEAD *UDF_GETBLK(STRUCT INODE *INODE, UDF_PBLK_T BLOCK,
				      INT CREATE, INT *ERR)
{
	STRUCT BUFFER_HEAD *BH;
	STRUCT BUFFER_HEAD DUMMY;

	DUMMY.B_STATE = 0;
	DUMMY.B_BLOCKNR = -1000;
	*ERR = UDF_GET_BLOCK(INODE, BLOCK, &DUMMY, CREATE);
	IF (!*ERR && BUFFER_MAPPED(&DUMMY)) {
		BH = SB_GETBLK(INODE->I_SB, DUMMY.B_BLOCKNR);
		IF (BUFFER_NEW(&DUMMY)) {
			LOCK_BUFFER(BH);
			MEMSET(BH->B_DATA, 0X00, INODE->I_SB->S_BLOCKSIZE);
			SET_BUFFER_UPTODATE(BH);
			UNLOCK_BUFFER(BH);
			MARK_BUFFER_DIRTY_INODE(BH, INODE);
		}
		RETURN BH;
	}

	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206677_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UNIX_EXPANDPATH(
    GARRAY_T	*GAP,
    CHAR_U	*PATH,
    INT		WILDOFF,
    INT		FLAGS,		// EW_* FLAGS
    INT		DIDSTAR)	// EXPANDED "**" ONCE ALREADY
{
    CHAR_U	*BUF;
    CHAR_U	*PATH_END;
    CHAR_U	*P, *S, *E;
    INT		START_LEN = GAP->GA_LEN;
    CHAR_U	*PAT;
    REGMATCH_T	REGMATCH;
    INT		STARTS_WITH_DOT;
    INT		MATCHES;
    INT		LEN;
    INT		STARSTAR = FALSE;
    STATIC INT	STARDEPTH = 0;	    // DEPTH FOR "**" EXPANSION

    DIR		*DIRP;
    STRUCT DIRENT *DP;

    // EXPANDING "**" MAY TAKE A LONG TIME, CHECK FOR CTRL-C.
    IF (STARDEPTH > 0)
    {
	UI_BREAKCHECK();
	IF (GOT_INT)
	    RETURN 0;
    }

    // MAKE ROOM FOR FILE NAME
    BUF = ALLOC(STRLEN(PATH) + BASENAMELEN + 5);
    IF (BUF == NULL)
	RETURN 0;

    /*
     * FIND THE FIRST PART IN THE PATH NAME THAT CONTAINS A WILDCARD.
     * WHEN EW_ICASE IS SET EVERY LETTER IS CONSIDERED TO BE A WILDCARD.
     * COPY IT INTO "BUF", INCLUDING THE PRECEDING CHARACTERS.
     */
    P = BUF;
    S = BUF;
    E = NULL;
    PATH_END = PATH;
    WHILE (*PATH_END != NUL)
    {
	// MAY IGNORE A WILDCARD THAT HAS A BACKSLASH BEFORE IT; IT WILL
	// BE REMOVED BY REM_BACKSLASH() OR FILE_PAT_TO_REG_PAT() BELOW.
	IF (PATH_END >= PATH + WILDOFF && REM_BACKSLASH(PATH_END))
	    *P++ = *PATH_END++;
	ELSE IF (*PATH_END == '/')
	{
	    IF (E != NULL)
		BREAK;
	    S = P + 1;
	}
	ELSE IF (PATH_END >= PATH + WILDOFF
			 && (VIM_STRCHR((CHAR_U *)"*?[{~$", *PATH_END) != NULL
			     || (!P_FIC && (FLAGS & EW_ICASE)
					     && ISALPHA(PTR2CHAR(PATH_END)))))
	    E = P;
	IF (HAS_MBYTE)
	{
	    LEN = (*MB_PTR2LEN)(PATH_END);
	    STRNCPY(P, PATH_END, LEN);
	    P += LEN;
	    PATH_END += LEN;
	}
	ELSE
	    *P++ = *PATH_END++;
    }
    E = P;
    *E = NUL;

    // NOW WE HAVE ONE WILDCARD COMPONENT BETWEEN "S" AND "E".
    // REMOVE BACKSLASHES BETWEEN "WILDOFF" AND THE START OF THE WILDCARD
    // COMPONENT.
    FOR (P = BUF + WILDOFF; P < S; ++P)
	IF (REM_BACKSLASH(P))
	{
	    STRMOVE(P, P + 1);
	    --E;
	    --S;
	}

    // CHECK FOR "**" BETWEEN "S" AND "E".
    FOR (P = S; P < E; ++P)
	IF (P[0] == '*' && P[1] == '*')
	    STARSTAR = TRUE;

    // CONVERT THE FILE PATTERN TO A REGEXP PATTERN
    STARTS_WITH_DOT = *S == '.';
    PAT = FILE_PAT_TO_REG_PAT(S, E, NULL, FALSE);
    IF (PAT == NULL)
    {
	VIM_FREE(BUF);
	RETURN 0;
    }

    // COMPILE THE REGEXP INTO A PROGRAM
    IF (FLAGS & EW_ICASE)
	REGMATCH.RM_IC = TRUE;		// 'WILDIGNORECASE' SET
    ELSE
	REGMATCH.RM_IC = P_FIC;	// IGNORE CASE WHEN 'FILEIGNORECASE' IS SET
    IF (FLAGS & (EW_NOERROR | EW_NOTWILD))
	++EMSG_SILENT;
    REGMATCH.REGPROG = VIM_REGCOMP(PAT, RE_MAGIC);
    IF (FLAGS & (EW_NOERROR | EW_NOTWILD))
	--EMSG_SILENT;
    VIM_FREE(PAT);

    IF (REGMATCH.REGPROG == NULL && (FLAGS & EW_NOTWILD) == 0)
    {
	VIM_FREE(BUF);
	RETURN 0;
    }

    // IF "**" IS BY ITSELF, THIS IS THE FIRST TIME WE ENCOUNTER IT AND MORE
    // IS FOLLOWING THEN FIND MATCHES WITHOUT ANY DIRECTORY.
    IF (!DIDSTAR && STARDEPTH < 100 && STARSTAR && E - S == 2
							  && *PATH_END == '/')
    {
	STRCPY(S, PATH_END + 1);
	++STARDEPTH;
	(VOID)UNIX_EXPANDPATH(GAP, BUF, (INT)(S - BUF), FLAGS, TRUE);
	--STARDEPTH;
    }

    // OPEN THE DIRECTORY FOR SCANNING
    *S = NUL;
    DIRP = OPENDIR(*BUF == NUL ? "." : (CHAR *)BUF);

    // FIND ALL MATCHING ENTRIES
    IF (DIRP != NULL)
    {
	FOR (;;)
	{
	    DP = READDIR(DIRP);
	    IF (DP == NULL)
		BREAK;
	    IF ((DP->D_NAME[0] != '.' || STARTS_WITH_DOT
			|| ((FLAGS & EW_DODOT)
			    && DP->D_NAME[1] != NUL
			    && (DP->D_NAME[1] != '.' || DP->D_NAME[2] != NUL)))
		 && ((REGMATCH.REGPROG != NULL && VIM_REGEXEC(&REGMATCH,
					     (CHAR_U *)DP->D_NAME, (COLNR_T)0))
		   || ((FLAGS & EW_NOTWILD)
		     && FNAMENCMP(PATH + (S - BUF), DP->D_NAME, E - S) == 0)))
	    {
		STRCPY(S, DP->D_NAME);
		LEN = STRLEN(BUF);

		IF (STARSTAR && STARDEPTH < 100)
		{
		    // FOR "**" IN THE PATTERN FIRST GO DEEPER IN THE TREE TO
		    // FIND MATCHES.
		    STRCPY(BUF + LEN, "/**");
		    STRCPY(BUF + LEN + 3, PATH_END);
		    ++STARDEPTH;
		    (VOID)UNIX_EXPANDPATH(GAP, BUF, LEN + 1, FLAGS, TRUE);
		    --STARDEPTH;
		}

		STRCPY(BUF + LEN, PATH_END);
		IF (MCH_HAS_EXP_WILDCARD(PATH_END)) // HANDLE MORE WILDCARDS
		{
		    // NEED TO EXPAND ANOTHER COMPONENT OF THE PATH
		    // REMOVE BACKSLASHES FOR THE REMAINING COMPONENTS ONLY
		    (VOID)UNIX_EXPANDPATH(GAP, BUF, LEN + 1, FLAGS, FALSE);
		}
		ELSE
		{
		    STAT_T  SB;

		    // NO MORE WILDCARDS, CHECK IF THERE IS A MATCH
		    // REMOVE BACKSLASHES FOR THE REMAINING COMPONENTS ONLY
		    IF (*PATH_END != NUL)
			BACKSLASH_HALVE(BUF + LEN + 1);
		    // ADD EXISTING FILE OR SYMBOLIC LINK
		    IF ((FLAGS & EW_ALLLINKS) ? MCH_LSTAT((CHAR *)BUF, &SB) >= 0
						      : MCH_GETPERM(BUF) >= 0)
		    {
#IFDEF MACOS_CONVERT
			SIZE_T PRECOMP_LEN = STRLEN(BUF)+1;
			CHAR_U *PRECOMP_BUF =
			    MAC_PRECOMPOSE_PATH(BUF, PRECOMP_LEN, &PRECOMP_LEN);

			IF (PRECOMP_BUF)
			{
			    MCH_MEMMOVE(BUF, PRECOMP_BUF, PRECOMP_LEN);
			    VIM_FREE(PRECOMP_BUF);
			}
#ENDIF
			ADDFILE(GAP, BUF, FLAGS);
		    }
		}
	    }
	}

	CLOSEDIR(DIRP);
    }

    VIM_FREE(BUF);
    VIM_REGFREE(REGMATCH.REGPROG);

    MATCHES = GAP->GA_LEN - START_LEN;
    IF (MATCHES > 0)
	QSORT(((CHAR_U **)GAP->GA_DATA) + START_LEN, MATCHES,
						   SIZEOF(CHAR_U *), PSTRCMP);
    RETURN MATCHES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197796_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PROTOCOL_CLIENT_MSG(VNCSTATE *VS, UINT8_T *DATA, SIZE_T LEN)
{
    INT I;
    UINT16_T LIMIT;
    VNCDISPLAY *VD = VS->VD;

    IF (DATA[0] > 3) {
        UPDATE_DISPLAYCHANGELISTENER(&VD->DCL, VNC_REFRESH_INTERVAL_BASE);
    }

    SWITCH (DATA[0]) {
    CASE VNC_MSG_CLIENT_SET_PIXEL_FORMAT:
        IF (LEN == 1)
            RETURN 20;

        SET_PIXEL_FORMAT(VS, READ_U8(DATA, 4), READ_U8(DATA, 5),
                         READ_U8(DATA, 6), READ_U8(DATA, 7),
                         READ_U16(DATA, 8), READ_U16(DATA, 10),
                         READ_U16(DATA, 12), READ_U8(DATA, 14),
                         READ_U8(DATA, 15), READ_U8(DATA, 16));
        BREAK;
    CASE VNC_MSG_CLIENT_SET_ENCODINGS:
        IF (LEN == 1)
            RETURN 4;

        IF (LEN == 4) {
            LIMIT = READ_U16(DATA, 2);
            IF (LIMIT > 0)
                RETURN 4 + (LIMIT * 4);
        } ELSE
            LIMIT = READ_U16(DATA, 2);

        FOR (I = 0; I < LIMIT; I++) {
            INT32_T VAL = READ_S32(DATA, 4 + (I * 4));
            MEMCPY(DATA + 4 + (I * 4), &VAL, SIZEOF(VAL));
        }

        SET_ENCODINGS(VS, (INT32_T *)(DATA + 4), LIMIT);
        BREAK;
    CASE VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:
        IF (LEN == 1)
            RETURN 10;

        FRAMEBUFFER_UPDATE_REQUEST(VS,
                                   READ_U8(DATA, 1), READ_U16(DATA, 2), READ_U16(DATA, 4),
                                   READ_U16(DATA, 6), READ_U16(DATA, 8));
        BREAK;
    CASE VNC_MSG_CLIENT_KEY_EVENT:
        IF (LEN == 1)
            RETURN 8;

        KEY_EVENT(VS, READ_U8(DATA, 1), READ_U32(DATA, 4));
        BREAK;
    CASE VNC_MSG_CLIENT_POINTER_EVENT:
        IF (LEN == 1)
            RETURN 6;

        POINTER_EVENT(VS, READ_U8(DATA, 1), READ_U16(DATA, 2), READ_U16(DATA, 4));
        BREAK;
    CASE VNC_MSG_CLIENT_CUT_TEXT:
        IF (LEN == 1)
            RETURN 8;

        IF (LEN == 8) {
            UINT32_T DLEN = READ_U32(DATA, 4);
            IF (DLEN > 0)
                RETURN 8 + DLEN;
        }

        CLIENT_CUT_TEXT(VS, READ_U32(DATA, 4), DATA + 8);
        BREAK;
    CASE VNC_MSG_CLIENT_QEMU:
        IF (LEN == 1)
            RETURN 2;

        SWITCH (READ_U8(DATA, 1)) {
        CASE VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:
            IF (LEN == 2)
                RETURN 12;

            EXT_KEY_EVENT(VS, READ_U16(DATA, 2),
                          READ_U32(DATA, 4), READ_U32(DATA, 8));
            BREAK;
        CASE VNC_MSG_CLIENT_QEMU_AUDIO:
            IF (LEN == 2)
                RETURN 4;

            SWITCH (READ_U16 (DATA, 2)) {
            CASE VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:
                AUDIO_ADD(VS);
                BREAK;
            CASE VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:
                AUDIO_DEL(VS);
                BREAK;
            CASE VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:
                IF (LEN == 4)
                    RETURN 10;
                SWITCH (READ_U8(DATA, 4)) {
                CASE 0: VS->AS.FMT = AUD_FMT_U8; BREAK;
                CASE 1: VS->AS.FMT = AUD_FMT_S8; BREAK;
                CASE 2: VS->AS.FMT = AUD_FMT_U16; BREAK;
                CASE 3: VS->AS.FMT = AUD_FMT_S16; BREAK;
                CASE 4: VS->AS.FMT = AUD_FMT_U32; BREAK;
                CASE 5: VS->AS.FMT = AUD_FMT_S32; BREAK;
                DEFAULT:
                    PRINTF("INVALID AUDIO FORMAT %D\N", READ_U8(DATA, 4));
                    VNC_CLIENT_ERROR(VS);
                    BREAK;
                }
                VS->AS.NCHANNELS = READ_U8(DATA, 5);
                IF (VS->AS.NCHANNELS != 1 && VS->AS.NCHANNELS != 2) {
                    PRINTF("INVALID AUDIO CHANNEL COOUNT %D\N",
                           READ_U8(DATA, 5));
                    VNC_CLIENT_ERROR(VS);
                    BREAK;
                }
                VS->AS.FREQ = READ_U32(DATA, 6);
                BREAK;
            DEFAULT:
                PRINTF ("INVALID AUDIO MESSAGE %D\N", READ_U8(DATA, 4));
                VNC_CLIENT_ERROR(VS);
                BREAK;
            }
            BREAK;

        DEFAULT:
            PRINTF("MSG: %D\N", READ_U16(DATA, 0));
            VNC_CLIENT_ERROR(VS);
            BREAK;
        }
        BREAK;
    DEFAULT:
        PRINTF("MSG: %D\N", DATA[0]);
        VNC_CLIENT_ERROR(VS);
        BREAK;
    }

    VNC_READ_WHEN(VS, PROTOCOL_CLIENT_MSG, 1);
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211877_CWE-668.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ADDBINDING(XML_PARSER PARSER, PREFIX *PREFIX, CONST ATTRIBUTE_ID *ATTID,
           CONST XML_CHAR *URI, BINDING **BINDINGSPTR) {
  STATIC CONST XML_CHAR XMLNAMESPACE[]
      = {ASCII_H,      ASCII_T,     ASCII_T,     ASCII_P,      ASCII_COLON,
         ASCII_SLASH,  ASCII_SLASH, ASCII_W,     ASCII_W,      ASCII_W,
         ASCII_PERIOD, ASCII_W,     ASCII_3,     ASCII_PERIOD, ASCII_O,
         ASCII_R,      ASCII_G,     ASCII_SLASH, ASCII_X,      ASCII_M,
         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,
         ASCII_8,      ASCII_SLASH, ASCII_N,     ASCII_A,      ASCII_M,
         ASCII_E,      ASCII_S,     ASCII_P,     ASCII_A,      ASCII_C,
         ASCII_E,      '\0'};
  STATIC CONST INT XMLLEN = (INT)SIZEOF(XMLNAMESPACE) / SIZEOF(XML_CHAR) - 1;
  STATIC CONST XML_CHAR XMLNSNAMESPACE[]
      = {ASCII_H,     ASCII_T,      ASCII_T, ASCII_P, ASCII_COLON,  ASCII_SLASH,
         ASCII_SLASH, ASCII_W,      ASCII_W, ASCII_W, ASCII_PERIOD, ASCII_W,
         ASCII_3,     ASCII_PERIOD, ASCII_O, ASCII_R, ASCII_G,      ASCII_SLASH,
         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_X,
         ASCII_M,     ASCII_L,      ASCII_N, ASCII_S, ASCII_SLASH,  '\0'};
  STATIC CONST INT XMLNSLEN
      = (INT)SIZEOF(XMLNSNAMESPACE) / SIZEOF(XML_CHAR) - 1;

  XML_BOOL MUSTBEXML = XML_FALSE;
  XML_BOOL ISXML = XML_TRUE;
  XML_BOOL ISXMLNS = XML_TRUE;

  BINDING *B;
  INT LEN;

  /* EMPTY URI IS ONLY VALID FOR DEFAULT NAMESPACE PER XML NS 1.0 (NOT 1.1) */
  IF (*URI == XML_T('\0') && PREFIX->NAME)
    RETURN XML_ERROR_UNDECLARING_PREFIX;

  IF (PREFIX->NAME && PREFIX->NAME[0] == XML_T(ASCII_X)
      && PREFIX->NAME[1] == XML_T(ASCII_M)
      && PREFIX->NAME[2] == XML_T(ASCII_L)) {
    /* NOT ALLOWED TO BIND XMLNS */
    IF (PREFIX->NAME[3] == XML_T(ASCII_N) && PREFIX->NAME[4] == XML_T(ASCII_S)
        && PREFIX->NAME[5] == XML_T('\0'))
      RETURN XML_ERROR_RESERVED_PREFIX_XMLNS;

    IF (PREFIX->NAME[3] == XML_T('\0'))
      MUSTBEXML = XML_TRUE;
  }

  FOR (LEN = 0; URI[LEN]; LEN++) {
    IF (ISXML && (LEN > XMLLEN || URI[LEN] != XMLNAMESPACE[LEN]))
      ISXML = XML_FALSE;

    IF (! MUSTBEXML && ISXMLNS
        && (LEN > XMLNSLEN || URI[LEN] != XMLNSNAMESPACE[LEN]))
      ISXMLNS = XML_FALSE;
  }
  ISXML = ISXML && LEN == XMLLEN;
  ISXMLNS = ISXMLNS && LEN == XMLNSLEN;

  IF (MUSTBEXML != ISXML)
    RETURN MUSTBEXML ? XML_ERROR_RESERVED_PREFIX_XML
                     : XML_ERROR_RESERVED_NAMESPACE_URI;

  IF (ISXMLNS)
    RETURN XML_ERROR_RESERVED_NAMESPACE_URI;

  IF (PARSER->M_NAMESPACESEPARATOR)
    LEN++;
  IF (PARSER->M_FREEBINDINGLIST) {
    B = PARSER->M_FREEBINDINGLIST;
    IF (LEN > B->URIALLOC) {
      /* DETECT AND PREVENT INTEGER OVERFLOW */
      IF (LEN > INT_MAX - EXPAND_SPARE) {
        RETURN XML_ERROR_NO_MEMORY;
      }

      /* DETECT AND PREVENT INTEGER OVERFLOW.
       * THE PREPROCESSOR GUARD ADDRESSES THE "ALWAYS FALSE" WARNING
       * FROM -WTYPE-LIMITS ON PLATFORMS WHERE
       * SIZEOF(UNSIGNED INT) < SIZEOF(SIZE_T), E.G. ON X86_64. */
#IF UINT_MAX >= SIZE_MAX
      IF ((UNSIGNED)(LEN + EXPAND_SPARE) > (SIZE_T)(-1) / SIZEOF(XML_CHAR)) {
        RETURN XML_ERROR_NO_MEMORY;
      }
#ENDIF

      XML_CHAR *TEMP = (XML_CHAR *)REALLOC(
          PARSER, B->URI, SIZEOF(XML_CHAR) * (LEN + EXPAND_SPARE));
      IF (TEMP == NULL)
        RETURN XML_ERROR_NO_MEMORY;
      B->URI = TEMP;
      B->URIALLOC = LEN + EXPAND_SPARE;
    }
    PARSER->M_FREEBINDINGLIST = B->NEXTTAGBINDING;
  } ELSE {
    B = (BINDING *)MALLOC(PARSER, SIZEOF(BINDING));
    IF (! B)
      RETURN XML_ERROR_NO_MEMORY;

    /* DETECT AND PREVENT INTEGER OVERFLOW */
    IF (LEN > INT_MAX - EXPAND_SPARE) {
      RETURN XML_ERROR_NO_MEMORY;
    }
    /* DETECT AND PREVENT INTEGER OVERFLOW.
     * THE PREPROCESSOR GUARD ADDRESSES THE "ALWAYS FALSE" WARNING
     * FROM -WTYPE-LIMITS ON PLATFORMS WHERE
     * SIZEOF(UNSIGNED INT) < SIZEOF(SIZE_T), E.G. ON X86_64. */
#IF UINT_MAX >= SIZE_MAX
    IF ((UNSIGNED)(LEN + EXPAND_SPARE) > (SIZE_T)(-1) / SIZEOF(XML_CHAR)) {
      RETURN XML_ERROR_NO_MEMORY;
    }
#ENDIF

    B->URI
        = (XML_CHAR *)MALLOC(PARSER, SIZEOF(XML_CHAR) * (LEN + EXPAND_SPARE));
    IF (! B->URI) {
      FREE(PARSER, B);
      RETURN XML_ERROR_NO_MEMORY;
    }
    B->URIALLOC = LEN + EXPAND_SPARE;
  }
  B->URILEN = LEN;
  MEMCPY(B->URI, URI, LEN * SIZEOF(XML_CHAR));
  IF (PARSER->M_NAMESPACESEPARATOR)
    B->URI[LEN - 1] = PARSER->M_NAMESPACESEPARATOR;
  B->PREFIX = PREFIX;
  B->ATTID = ATTID;
  B->PREVPREFIXBINDING = PREFIX->BINDING;
  /* NULL BINDING WHEN DEFAULT NAMESPACE UNDECLARED */
  IF (*URI == XML_T('\0') && PREFIX == &PARSER->M_DTD->DEFAULTPREFIX)
    PREFIX->BINDING = NULL;
  ELSE
    PREFIX->BINDING = B;
  B->NEXTTAGBINDING = *BINDINGSPTR;
  *BINDINGSPTR = B;
  /* IF ATTID == NULL THEN WE ARE NOT STARTING A NAMESPACE SCOPE */
  IF (ATTID && PARSER->M_STARTNAMESPACEDECLHANDLER)
    PARSER->M_STARTNAMESPACEDECLHANDLER(PARSER->M_HANDLERARG, PREFIX->NAME,
                                        PREFIX->BINDING ? URI : 0);
  RETURN XML_ERROR_NONE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211845_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READTIFFIMAGE(CONST IMAGEINFO *IMAGE_INFO,
  EXCEPTIONINFO *EXCEPTION)
{
#DEFINE MAXPIXELCHANNELS  32
#DEFINE THROWTIFFEXCEPTION(SEVERITY,MESSAGE) \
{ \
  IF (PIXEL_INFO != (MEMORYINFO *) NULL) \
    PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO); \
  IF (QUANTUM_INFO != (QUANTUMINFO *) NULL) \
    QUANTUM_INFO=DESTROYQUANTUMINFO(QUANTUM_INFO); \
  TIFFCLOSE(TIFF); \
  THROWREADEREXCEPTION(SEVERITY,MESSAGE); \
}

  CONST CHAR
    *OPTION;

  FLOAT
    *CHROMATICITY = (FLOAT *) NULL,
    X_POSITION,
    Y_POSITION,
    X_RESOLUTION,
    Y_RESOLUTION;

  IMAGE
    *IMAGE;

  INT
    TIFF_STATUS = 0;

  MAGICKBOOLEANTYPE
    MORE_FRAMES;

  MAGICKSTATUSTYPE
    STATUS;

  MEMORYINFO
    *PIXEL_INFO = (MEMORYINFO *) NULL;

  QUANTUMINFO
    *QUANTUM_INFO;

  QUANTUMTYPE
    QUANTUM_TYPE;

  SIZE_T
    NUMBER_PIXELS;

  SSIZE_T
    I,
    SCANLINE_SIZE,
    Y;

  TIFF
    *TIFF;

  TIFFMETHODTYPE
    METHOD;

  UINT16
    COMPRESS_TAG = 0,
    BITS_PER_SAMPLE = 0,
    ENDIAN = 0,
    EXTRA_SAMPLES = 0,
    INTERLACE = 0,
    MAX_SAMPLE_VALUE = 0,
    MIN_SAMPLE_VALUE = 0,
    ORIENTATION = 0,
    PAGES = 0,
    PHOTOMETRIC = 0,
    *SAMPLE_INFO = NULL,
    SAMPLE_FORMAT = 0,
    SAMPLES_PER_PIXEL = 0,
    UNITS = 0,
    VALUE = 0;

  UINT32
    HEIGHT,
    ROWS_PER_STRIP,
    WIDTH;

  UNSIGNED CHAR
    *PIXELS;

  VOID
    *SANS[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

  /*
    OPEN IMAGE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  IF (ISEVENTLOGGING() != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  IMAGE=ACQUIREIMAGE(IMAGE_INFO);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  (VOID) SETMAGICKTHREADVALUE(TIFF_EXCEPTION,EXCEPTION);
  TIFF=TIFFCLIENTOPEN(IMAGE->FILENAME,"RB",(THANDLE_T) IMAGE,TIFFREADBLOB,
    TIFFWRITEBLOB,TIFFSEEKBLOB,TIFFCLOSEBLOB,TIFFGETBLOBSIZE,TIFFMAPBLOB,
    TIFFUNMAPBLOB);
  IF (TIFF == (TIFF *) NULL)
    {
      IF (EXCEPTION->SEVERITY == UNDEFINEDEXCEPTION)
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  IF (EXCEPTION->SEVERITY > ERROREXCEPTION)
    {
      TIFFCLOSE(TIFF);
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  IF (IMAGE_INFO->NUMBER_SCENES != 0)
    {
      /*
        GENERATE BLANK IMAGES FOR SUBIMAGE SPECIFICATION (E.G. IMAGE.TIF[4].
        WE NEED TO CHECK THE NUMBER OF DIRECTORES BECAUSE IT IS POSSIBLE THAT
        THE SUBIMAGE(S) ARE STORED IN THE PHOTOSHOP PROFILE.
      */
      IF (IMAGE_INFO->SCENE < (SIZE_T)TIFFNUMBEROFDIRECTORIES(TIFF))
        {
          FOR (I=0; I < (SSIZE_T) IMAGE_INFO->SCENE; I++)
          {
            STATUS=TIFFREADDIRECTORY(TIFF) != 0 ? MAGICKTRUE : MAGICKFALSE;
            IF (STATUS == MAGICKFALSE)
              {
                TIFFCLOSE(TIFF);
                IMAGE=DESTROYIMAGELIST(IMAGE);
                RETURN((IMAGE *) NULL);
              }
            ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE);
            IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
              {
                TIFFCLOSE(TIFF);
                IMAGE=DESTROYIMAGELIST(IMAGE);
                RETURN((IMAGE *) NULL);
              }
            IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
          }
        }
    }
  MORE_FRAMES=MAGICKTRUE;
  DO
  {
    /* TIFFPRINTDIRECTORY(TIFF,STDOUT,MAGICKFALSE); */
    PHOTOMETRIC=PHOTOMETRIC_RGB;
    IF ((TIFFGETFIELD(TIFF,TIFFTAG_IMAGEWIDTH,&WIDTH) != 1) ||
        (TIFFGETFIELD(TIFF,TIFFTAG_IMAGELENGTH,&HEIGHT) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_PHOTOMETRIC,&PHOTOMETRIC,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_COMPRESSION,&COMPRESS_TAG,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_FILLORDER,&ENDIAN,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_PLANARCONFIG,&INTERLACE,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_SAMPLESPERPIXEL,&SAMPLES_PER_PIXEL,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_BITSPERSAMPLE,&BITS_PER_SAMPLE,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_SAMPLEFORMAT,&SAMPLE_FORMAT,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_MINSAMPLEVALUE,&MIN_SAMPLE_VALUE,SANS) != 1) ||
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_MAXSAMPLEVALUE,&MAX_SAMPLE_VALUE,SANS) != 1))
      {
        TIFFCLOSE(TIFF);
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
      }
    IF (((SAMPLE_FORMAT != SAMPLEFORMAT_IEEEFP) || (BITS_PER_SAMPLE != 64)) &&
        ((BITS_PER_SAMPLE <= 0) || (BITS_PER_SAMPLE > 32)))
      {
        TIFFCLOSE(TIFF);
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNSUPPORTEDBITSPERPIXEL");
      }
    IF (SAMPLES_PER_PIXEL > MAXPIXELCHANNELS)
      {
        TIFFCLOSE(TIFF);
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"MAXIMUMCHANNELSEXCEEDED");
      }
    IF (SAMPLE_FORMAT == SAMPLEFORMAT_IEEEFP)
      (VOID) SETIMAGEPROPERTY(IMAGE,"QUANTUM:FORMAT","FLOATING-POINT");
    SWITCH (PHOTOMETRIC)
    {
      CASE PHOTOMETRIC_MINISBLACK:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","MIN-IS-BLACK");
        BREAK;
      }
      CASE PHOTOMETRIC_MINISWHITE:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","MIN-IS-WHITE");
        BREAK;
      }
      CASE PHOTOMETRIC_PALETTE:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","PALETTE");
        BREAK;
      }
      CASE PHOTOMETRIC_RGB:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","RGB");
        BREAK;
      }
      CASE PHOTOMETRIC_CIELAB:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","CIELAB");
        BREAK;
      }
      CASE PHOTOMETRIC_LOGL:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","CIE LOG2(L)");
        BREAK;
      }
      CASE PHOTOMETRIC_LOGLUV:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","LOGLUV");
        BREAK;
      }
#IF DEFINED(PHOTOMETRIC_MASK)
      CASE PHOTOMETRIC_MASK:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","MASK");
        BREAK;
      }
#ENDIF
      CASE PHOTOMETRIC_SEPARATED:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","SEPARATED");
        BREAK;
      }
      CASE PHOTOMETRIC_YCBCR:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","YCBCR");
        BREAK;
      }
      DEFAULT:
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC","UNKNOWN");
        BREAK;
      }
    }
    IF (IMAGE->DEBUG != MAGICKFALSE)
      {
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"GEOMETRY: %UX%U",
          (UNSIGNED INT) WIDTH,(UNSIGNED INT) HEIGHT);
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"INTERLACE: %U",
          INTERLACE);
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "BITS PER SAMPLE: %U",BITS_PER_SAMPLE);
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "MIN SAMPLE VALUE: %U",MIN_SAMPLE_VALUE);
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "MAX SAMPLE VALUE: %U",MAX_SAMPLE_VALUE);
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"PHOTOMETRIC "
          "INTERPRETATION: %S",GETIMAGEPROPERTY(IMAGE,"TIFF:PHOTOMETRIC"));
      }
    IMAGE->COLUMNS=(SIZE_T) WIDTH;
    IMAGE->ROWS=(SIZE_T) HEIGHT;
    IMAGE->DEPTH=(SIZE_T) BITS_PER_SAMPLE;
    IF (IMAGE->DEBUG != MAGICKFALSE)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"IMAGE DEPTH: %.20G",
        (DOUBLE) IMAGE->DEPTH);
    IMAGE->ENDIAN=MSBENDIAN;
    IF (ENDIAN == FILLORDER_LSB2MSB)
      IMAGE->ENDIAN=LSBENDIAN;
#IF DEFINED(MAGICKCORE_HAVE_TIFFISBIGENDIAN)
    IF (TIFFISBIGENDIAN(TIFF) == 0)
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:ENDIAN","LSB");
        IMAGE->ENDIAN=LSBENDIAN;
      }
    ELSE
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:ENDIAN","MSB");
        IMAGE->ENDIAN=MSBENDIAN;
      }
#ENDIF
    IF ((PHOTOMETRIC == PHOTOMETRIC_MINISBLACK) ||
        (PHOTOMETRIC == PHOTOMETRIC_MINISWHITE))
      IMAGE->COLORSPACE=GRAYCOLORSPACE;
    IF (PHOTOMETRIC == PHOTOMETRIC_SEPARATED)
      IMAGE->COLORSPACE=CMYKCOLORSPACE;
    IF (PHOTOMETRIC == PHOTOMETRIC_CIELAB)
      IMAGE->COLORSPACE=LABCOLORSPACE;
    IF ((PHOTOMETRIC == PHOTOMETRIC_YCBCR) &&
        (COMPRESS_TAG != COMPRESSION_OJPEG) &&
        (COMPRESS_TAG != COMPRESSION_JPEG))
      IMAGE->COLORSPACE=YCBCRCOLORSPACE;
    STATUS=TIFFGETPROFILES(TIFF,IMAGE);
    IF (STATUS == MAGICKFALSE)
      {
        TIFFCLOSE(TIFF);
        INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }
    STATUS=TIFFGETPROPERTIES(TIFF,IMAGE);
    IF (STATUS == MAGICKFALSE)
      {
        TIFFCLOSE(TIFF);
        INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }
    OPTION=GETIMAGEOPTION(IMAGE_INFO,"TIFF:EXIF-PROPERTIES");
    IF ((OPTION == (CONST CHAR *) NULL) ||
        (ISMAGICKTRUE(OPTION) != MAGICKFALSE))
      (VOID) TIFFGETEXIFPROPERTIES(TIFF,IMAGE);
    OPTION=GETIMAGEOPTION(IMAGE_INFO,"TIFF:GPS-PROPERTIES");
    IF ((OPTION == (CONST CHAR *) NULL) ||
        (ISMAGICKTRUE(OPTION) != MAGICKFALSE))
      (VOID) TIFFGETGPSPROPERTIES(TIFF,IMAGE);
    IF ((TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_XRESOLUTION,&X_RESOLUTION,SANS) == 1) &&
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_YRESOLUTION,&Y_RESOLUTION,SANS) == 1))
      {
        IMAGE->X_RESOLUTION=X_RESOLUTION;
        IMAGE->Y_RESOLUTION=Y_RESOLUTION;
      }
    IF (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_RESOLUTIONUNIT,&UNITS,SANS,SANS) == 1)
      {
        IF (UNITS == RESUNIT_INCH)
          IMAGE->UNITS=PIXELSPERINCHRESOLUTION;
        IF (UNITS == RESUNIT_CENTIMETER)
          IMAGE->UNITS=PIXELSPERCENTIMETERRESOLUTION;
      }
    IF ((TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_XPOSITION,&X_POSITION,SANS) == 1) &&
        (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_YPOSITION,&Y_POSITION,SANS) == 1))
      {
        IMAGE->PAGE.X=CASTDOUBLETOLONG(CEIL(X_POSITION*
          IMAGE->X_RESOLUTION-0.5));
        IMAGE->PAGE.Y=CASTDOUBLETOLONG(CEIL(Y_POSITION*
          IMAGE->Y_RESOLUTION-0.5));
      }
    IF (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_ORIENTATION,&ORIENTATION,SANS) == 1)
      IMAGE->ORIENTATION=(ORIENTATIONTYPE) ORIENTATION;
    IF (TIFFGETFIELD(TIFF,TIFFTAG_WHITEPOINT,&CHROMATICITY) == 1)
      {
        IF ((CHROMATICITY != (FLOAT *) NULL) && (*CHROMATICITY != 0.0))
          {
            IMAGE->CHROMATICITY.WHITE_POINT.X=CHROMATICITY[0];
            IMAGE->CHROMATICITY.WHITE_POINT.Y=CHROMATICITY[1];
          }
      }
    IF (TIFFGETFIELD(TIFF,TIFFTAG_PRIMARYCHROMATICITIES,&CHROMATICITY) == 1)
      {
        IF ((CHROMATICITY != (FLOAT *) NULL) && (*CHROMATICITY != 0.0))
          {
            IMAGE->CHROMATICITY.RED_PRIMARY.X=CHROMATICITY[0];
            IMAGE->CHROMATICITY.RED_PRIMARY.Y=CHROMATICITY[1];
            IMAGE->CHROMATICITY.GREEN_PRIMARY.X=CHROMATICITY[2];
            IMAGE->CHROMATICITY.GREEN_PRIMARY.Y=CHROMATICITY[3];
            IMAGE->CHROMATICITY.BLUE_PRIMARY.X=CHROMATICITY[4];
            IMAGE->CHROMATICITY.BLUE_PRIMARY.Y=CHROMATICITY[5];
          }
      }
#IF DEFINED(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
    IF ((COMPRESS_TAG != COMPRESSION_NONE) &&
        (TIFFISCODECCONFIGURED(COMPRESS_TAG) == 0))
      {
        TIFFCLOSE(TIFF);
        THROWREADEREXCEPTION(CODERERROR,"COMPRESSNOTSUPPORTED");
      }
#ENDIF
    SWITCH (COMPRESS_TAG)
    {
      CASE COMPRESSION_NONE: IMAGE->COMPRESSION=NOCOMPRESSION; BREAK;
      CASE COMPRESSION_CCITTFAX3: IMAGE->COMPRESSION=FAXCOMPRESSION; BREAK;
      CASE COMPRESSION_CCITTFAX4: IMAGE->COMPRESSION=GROUP4COMPRESSION; BREAK;
      CASE COMPRESSION_JPEG:
      {
         IMAGE->COMPRESSION=JPEGCOMPRESSION;
#IF DEFINED(JPEG_SUPPORT)
         {
           CHAR
             SAMPLING_FACTOR[MAXTEXTEXTENT];

           INT
             TIFF_STATUS;

           UINT16
             HORIZONTAL,
             VERTICAL;

           TIFF_STATUS=TIFFGETFIELD(TIFF,TIFFTAG_YCBCRSUBSAMPLING,&HORIZONTAL,
             &VERTICAL);
           IF (TIFF_STATUS == 1)
             {
               (VOID) FORMATLOCALESTRING(SAMPLING_FACTOR,MAXTEXTEXTENT,"%DX%D",
                 HORIZONTAL,VERTICAL);
               (VOID) SETIMAGEPROPERTY(IMAGE,"JPEG:SAMPLING-FACTOR",
                 SAMPLING_FACTOR);
               (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
                 "SAMPLING FACTORS: %S",SAMPLING_FACTOR);
             }
         }
#ENDIF
        BREAK;
      }
      CASE COMPRESSION_OJPEG: IMAGE->COMPRESSION=JPEGCOMPRESSION; BREAK;
#IF DEFINED(COMPRESSION_LZMA)
      CASE COMPRESSION_LZMA: IMAGE->COMPRESSION=LZMACOMPRESSION; BREAK;
#ENDIF
      CASE COMPRESSION_LZW: IMAGE->COMPRESSION=LZWCOMPRESSION; BREAK;
      CASE COMPRESSION_DEFLATE: IMAGE->COMPRESSION=ZIPCOMPRESSION; BREAK;
      CASE COMPRESSION_ADOBE_DEFLATE: IMAGE->COMPRESSION=ZIPCOMPRESSION; BREAK;
#IF DEFINED(COMPRESSION_WEBP)
      CASE COMPRESSION_WEBP: IMAGE->COMPRESSION=WEBPCOMPRESSION; BREAK;
#ENDIF
#IF DEFINED(COMPRESSION_ZSTD)
      CASE COMPRESSION_ZSTD: IMAGE->COMPRESSION=ZSTDCOMPRESSION; BREAK;
#ENDIF
      DEFAULT: IMAGE->COMPRESSION=RLECOMPRESSION; BREAK;
    }
    QUANTUM_INFO=(QUANTUMINFO *) NULL;
    IF ((PHOTOMETRIC == PHOTOMETRIC_PALETTE) &&
        (POW(2.0,1.0*BITS_PER_SAMPLE) <= MAXCOLORMAPSIZE))
      {
        SIZE_T
          COLORS;

        COLORS=(SIZE_T) GETQUANTUMRANGE(BITS_PER_SAMPLE)+1;
        IF (ACQUIREIMAGECOLORMAP(IMAGE,COLORS) == MAGICKFALSE)
          {
            TIFFCLOSE(TIFF);
            THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
          }
      }
    IF (TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_PAGENUMBER,&VALUE,&PAGES,SANS) == 1)
      IMAGE->SCENE=VALUE;
    IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
      {
        INT
          TIFF_STATUS;

        SIZE_T
          RANGE;

        UINT16
          *BLUE_COLORMAP = (UINT16 *) NULL,
          *GREEN_COLORMAP = (UINT16 *) NULL,
          *RED_COLORMAP = (UINT16 *) NULL;

        /*
          INITIALIZE COLORMAP.
        */
        TIFF_STATUS=TIFFGETFIELD(TIFF,TIFFTAG_COLORMAP,&RED_COLORMAP,
          &GREEN_COLORMAP,&BLUE_COLORMAP);
        IF (TIFF_STATUS == 1)
          {
            IF ((RED_COLORMAP != (UINT16 *) NULL) &&
                (GREEN_COLORMAP != (UINT16 *) NULL) &&
                (BLUE_COLORMAP != (UINT16 *) NULL))
              {
                RANGE=255;  /* MIGHT BE OLD STYLE 8-BIT COLORMAP */
                FOR (I=0; I < (SSIZE_T) IMAGE->COLORS; I++)
                  IF ((RED_COLORMAP[I] >= 256) || (GREEN_COLORMAP[I] >= 256) ||
                      (BLUE_COLORMAP[I] >= 256))
                    {
                      RANGE=65535;
                      BREAK;
                    }
                FOR (I=0; I < (SSIZE_T) IMAGE->COLORS; I++)
                {
                  IMAGE->COLORMAP[I].RED=CLAMPTOQUANTUM(((DOUBLE)
                    QUANTUMRANGE*RED_COLORMAP[I])/RANGE);
                  IMAGE->COLORMAP[I].GREEN=CLAMPTOQUANTUM(((DOUBLE)
                    QUANTUMRANGE*GREEN_COLORMAP[I])/RANGE);
                  IMAGE->COLORMAP[I].BLUE=CLAMPTOQUANTUM(((DOUBLE)
                    QUANTUMRANGE*BLUE_COLORMAP[I])/RANGE);
                }
              }
          }
      }
    IF (IMAGE_INFO->PING != MAGICKFALSE)
      {
        IF (IMAGE_INFO->NUMBER_SCENES != 0)
          IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
            BREAK;
        GOTO NEXT_TIFF_FRAME;
      }
    STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS);
    IF (STATUS == MAGICKFALSE)
      {
        TIFFCLOSE(TIFF);
        INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }
    STATUS=SETIMAGECOLORSPACE(IMAGE,IMAGE->COLORSPACE);
    STATUS&=RESETIMAGEPIXELS(IMAGE,EXCEPTION);
    IF (STATUS == MAGICKFALSE)
      {
        TIFFCLOSE(TIFF);
        INHERITEXCEPTION(EXCEPTION,&IMAGE->EXCEPTION);
        RETURN(DESTROYIMAGELIST(IMAGE));
      }
    /*
      ALLOCATE MEMORY FOR THE IMAGE AND PIXEL BUFFER.
    */
    QUANTUM_INFO=ACQUIREQUANTUMINFO(IMAGE_INFO,IMAGE);
    IF (QUANTUM_INFO == (QUANTUMINFO *) NULL)
      THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
    IF (SAMPLE_FORMAT == SAMPLEFORMAT_UINT)
      STATUS=SETQUANTUMFORMAT(IMAGE,QUANTUM_INFO,UNSIGNEDQUANTUMFORMAT);
    IF (SAMPLE_FORMAT == SAMPLEFORMAT_INT)
      STATUS=SETQUANTUMFORMAT(IMAGE,QUANTUM_INFO,SIGNEDQUANTUMFORMAT);
    IF (SAMPLE_FORMAT == SAMPLEFORMAT_IEEEFP)
      STATUS=SETQUANTUMFORMAT(IMAGE,QUANTUM_INFO,FLOATINGPOINTQUANTUMFORMAT);
    IF (STATUS == MAGICKFALSE)
      THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
    STATUS=MAGICKTRUE;
    SWITCH (PHOTOMETRIC)
    {
      CASE PHOTOMETRIC_MINISBLACK:
      {
        QUANTUM_INFO->MIN_IS_WHITE=MAGICKFALSE;
        BREAK;
      }
      CASE PHOTOMETRIC_MINISWHITE:
      {
        QUANTUM_INFO->MIN_IS_WHITE=MAGICKTRUE;
        BREAK;
      }
      DEFAULT:
        BREAK;
    }
    EXTRA_SAMPLES=0;
    TIFF_STATUS=TIFFGETFIELDDEFAULTED(TIFF,TIFFTAG_EXTRASAMPLES,&EXTRA_SAMPLES,
      &SAMPLE_INFO,SANS);
    IF (TIFF_STATUS == 1)
      {
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:ALPHA","UNSPECIFIED");
        IF (EXTRA_SAMPLES == 0)
          {
            IF ((SAMPLES_PER_PIXEL == 4) && (PHOTOMETRIC == PHOTOMETRIC_RGB))
              IMAGE->MATTE=MAGICKTRUE;
          }
        ELSE
          FOR (I=0; I < EXTRA_SAMPLES; I++)
          {
            IMAGE->MATTE=MAGICKTRUE;
            IF (SAMPLE_INFO[I] == EXTRASAMPLE_ASSOCALPHA)
              {
                SETQUANTUMALPHATYPE(QUANTUM_INFO,ASSOCIATEDQUANTUMALPHA);
                (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:ALPHA","ASSOCIATED");
              }
            ELSE
              IF (SAMPLE_INFO[I] == EXTRASAMPLE_UNASSALPHA)
                {
                  SETQUANTUMALPHATYPE(QUANTUM_INFO,DISASSOCIATEDQUANTUMALPHA);
                  (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:ALPHA","UNASSOCIATED");
                }
          }
      }
    IF (IMAGE->MATTE != MAGICKFALSE)
      (VOID) SETIMAGEALPHACHANNEL(IMAGE,OPAQUEALPHACHANNEL);
    METHOD=READGENERICMETHOD;
    ROWS_PER_STRIP=(UINT32) IMAGE->ROWS;
    IF (TIFFGETFIELD(TIFF,TIFFTAG_ROWSPERSTRIP,&ROWS_PER_STRIP) == 1)
      {
        CHAR
          VALUE[MAXTEXTEXTENT];

        (VOID) FORMATLOCALESTRING(VALUE,MAXTEXTEXTENT,"%U",(UNSIGNED INT)
          ROWS_PER_STRIP);
        (VOID) SETIMAGEPROPERTY(IMAGE,"TIFF:ROWS-PER-STRIP",VALUE);
        METHOD=READSTRIPMETHOD;
        IF (ROWS_PER_STRIP > (UINT32) IMAGE->ROWS)
          ROWS_PER_STRIP=(UINT32) IMAGE->ROWS;
      }
    IF (TIFFISTILED(TIFF) != MAGICKFALSE)
      {
        UINT32
          COLUMNS,
          ROWS;

        IF ((TIFFGETFIELD(TIFF,TIFFTAG_TILEWIDTH,&COLUMNS) != 1) ||
            (TIFFGETFIELD(TIFF,TIFFTAG_TILELENGTH,&ROWS) != 1))
          THROWTIFFEXCEPTION(CODERERROR,"IMAGEISNOTTILED");
        IF ((ACQUIREMAGICKRESOURCE(WIDTHRESOURCE,COLUMNS) == MAGICKFALSE) ||
            (ACQUIREMAGICKRESOURCE(HEIGHTRESOURCE,ROWS) == MAGICKFALSE))
          THROWTIFFEXCEPTION(IMAGEERROR,"WIDTHORHEIGHTEXCEEDSLIMIT");
        METHOD=READTILEMETHOD;
      }
    IF ((PHOTOMETRIC == PHOTOMETRIC_LOGLUV) ||
        (COMPRESS_TAG == COMPRESSION_CCITTFAX3))
      METHOD=READGENERICMETHOD;
    IF (IMAGE->COMPRESSION == JPEGCOMPRESSION)
      METHOD=GETJPEGMETHOD(IMAGE,TIFF,PHOTOMETRIC,BITS_PER_SAMPLE,
        SAMPLES_PER_PIXEL);
    QUANTUM_INFO->ENDIAN=LSBENDIAN;
    SCANLINE_SIZE=TIFFSCANLINESIZE(TIFF);
    IF (SCANLINE_SIZE <= 0)
      THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
    NUMBER_PIXELS=MAGICKMAX((MAGICKSIZETYPE) IMAGE->COLUMNS*SAMPLES_PER_PIXEL*
      POW(2.0,CEIL(LOG(BITS_PER_SAMPLE)/LOG(2.0))),IMAGE->COLUMNS*
      ROWS_PER_STRIP);
    IF ((DOUBLE) SCANLINE_SIZE > 1.5*NUMBER_PIXELS)
      THROWTIFFEXCEPTION(CORRUPTIMAGEERROR,"CORRUPTIMAGE");
    NUMBER_PIXELS=MAGICKMAX((MAGICKSIZETYPE) SCANLINE_SIZE,NUMBER_PIXELS);
    PIXEL_INFO=ACQUIREVIRTUALMEMORY(NUMBER_PIXELS,SIZEOF(UINT32));
    IF (PIXEL_INFO == (MEMORYINFO *) NULL)
      THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
    PIXELS=(UNSIGNED CHAR *) GETVIRTUALMEMORYBLOB(PIXEL_INFO);
    (VOID) RESETMAGICKMEMORY(PIXELS,0,NUMBER_PIXELS*SIZEOF(UINT32));
    QUANTUM_TYPE=GRAYQUANTUM;
    IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
      QUANTUM_TYPE=INDEXQUANTUM;
    IF (INTERLACE != PLANARCONFIG_SEPARATE)
      {
        SIZE_T
          PAD;

        PAD=(SIZE_T) MAGICKMAX((SSIZE_T) SAMPLES_PER_PIXEL-1,0);
        IF (IMAGE->MATTE != MAGICKFALSE)
          {
            IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
              QUANTUM_TYPE=INDEXALPHAQUANTUM;
            ELSE
              QUANTUM_TYPE=SAMPLES_PER_PIXEL == 1 ? ALPHAQUANTUM :
                GRAYALPHAQUANTUM;
          }
        IF ((SAMPLES_PER_PIXEL > 2) && (INTERLACE != PLANARCONFIG_SEPARATE))
          {
            QUANTUM_TYPE=RGBQUANTUM;
            PAD=(SIZE_T) MAGICKMAX((SSIZE_T) SAMPLES_PER_PIXEL+
              EXTRA_SAMPLES-3,0);
            IF (IMAGE->MATTE != MAGICKFALSE)
              {
                QUANTUM_TYPE=RGBAQUANTUM;
                PAD=(SIZE_T) MAGICKMAX((SSIZE_T) SAMPLES_PER_PIXEL+
                  EXTRA_SAMPLES-4,0);
              }
            IF (IMAGE->COLORSPACE == CMYKCOLORSPACE)
              {
                QUANTUM_TYPE=CMYKQUANTUM;
                PAD=(SIZE_T) MAGICKMAX((SSIZE_T) SAMPLES_PER_PIXEL+
                  EXTRA_SAMPLES-4,0);
                IF (IMAGE->MATTE != MAGICKFALSE)
                  {
                    QUANTUM_TYPE=CMYKAQUANTUM;
                    PAD=(SIZE_T) MAGICKMAX((SSIZE_T) SAMPLES_PER_PIXEL+
                      EXTRA_SAMPLES-5,0);
                  }
              }
            STATUS=SETQUANTUMPAD(IMAGE,QUANTUM_INFO,PAD*((BITS_PER_SAMPLE+7) >>
              3));
            IF (STATUS == MAGICKFALSE)
              THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
          }
      }
    SWITCH (METHOD)
    {
      CASE READYCCKMETHOD:
      {
        /*
          CONVERT YCC TIFF IMAGE.
        */
        FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
        {
          INT
            STATUS;

          INDEXPACKET
            *INDEXES;

          PIXELPACKET
            *MAGICK_RESTRICT Q;

          SSIZE_T
            X;

          UNSIGNED CHAR
            *P;

          STATUS=TIFFREADPIXELS(TIFF,0,Y,(CHAR *) PIXELS);
          IF (STATUS == -1)
            BREAK;
          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
          P=PIXELS;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            SETPIXELCYAN(Q,SCALECHARTOQUANTUM(CLAMPYCC((DOUBLE) *P+
              (1.402*(DOUBLE) *(P+2))-179.456)));
            SETPIXELMAGENTA(Q,SCALECHARTOQUANTUM(CLAMPYCC((DOUBLE) *P-
              (0.34414*(DOUBLE) *(P+1))-(0.71414*(DOUBLE ) *(P+2))+
              135.45984)));
            SETPIXELYELLOW(Q,SCALECHARTOQUANTUM(CLAMPYCC((DOUBLE) *P+
              (1.772*(DOUBLE) *(P+1))-226.816)));
            SETPIXELBLACK(INDEXES+X,SCALECHARTOQUANTUM((UNSIGNED CHAR)*(P+3)));
            Q++;
            P+=4;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
                IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        BREAK;
      }
      CASE READSTRIPMETHOD:
      {
        UNSIGNED CHAR
          *P;

        SIZE_T
          EXTENT;

        SSIZE_T
          STRIDE,
          STRIP_ID;

        TSIZE_T
          STRIP_SIZE;

        UNSIGNED CHAR
          *STRIP_PIXELS;

        /*
          CONVERT STRIPPED TIFF IMAGE.
        */
        EXTENT=4*(SAMPLES_PER_PIXEL+1)*TIFFSTRIPSIZE(TIFF);
        STRIP_PIXELS=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY(EXTENT,
          SIZEOF(*STRIP_PIXELS));
        IF (STRIP_PIXELS == (UNSIGNED CHAR *) NULL)
          THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        (VOID) MEMSET(STRIP_PIXELS,0,EXTENT*SIZEOF(*STRIP_PIXELS));
        STRIDE=TIFFVSTRIPSIZE(TIFF,1);
        STRIP_ID=0;
        P=STRIP_PIXELS;
        FOR (I=0; I < (SSIZE_T) SAMPLES_PER_PIXEL; I++)
        {
          SIZE_T
            ROWS_REMAINING;

          SWITCH (I)
          {
            CASE 0: BREAK;
            CASE 1: QUANTUM_TYPE=GREENQUANTUM; BREAK;
            CASE 2: QUANTUM_TYPE=BLUEQUANTUM; BREAK;
            CASE 3:
            {
              QUANTUM_TYPE=ALPHAQUANTUM;
              IF (IMAGE->COLORSPACE == CMYKCOLORSPACE)
                QUANTUM_TYPE=BLACKQUANTUM;
              BREAK;
            }
            CASE 4: QUANTUM_TYPE=ALPHAQUANTUM; BREAK;
            DEFAULT: BREAK;
          }
          ROWS_REMAINING=0;
          FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
          {
            PIXELPACKET
              *MAGICK_RESTRICT Q;

            Q=GETAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
            IF (Q == (PIXELPACKET *) NULL)
              BREAK;
            IF (ROWS_REMAINING == 0)
              {
                STRIP_SIZE=TIFFREADENCODEDSTRIP(TIFF,STRIP_ID,STRIP_PIXELS,
                  TIFFSTRIPSIZE(TIFF));
                IF (STRIP_SIZE == -1)
                  BREAK;
                ROWS_REMAINING=ROWS_PER_STRIP;
                IF ((Y+ROWS_PER_STRIP) > (SSIZE_T) IMAGE->ROWS)
                  ROWS_REMAINING=(ROWS_PER_STRIP-(Y+ROWS_PER_STRIP-
                    IMAGE->ROWS));
                P=STRIP_PIXELS;
                STRIP_ID++;
              }
            (VOID) IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,
              QUANTUM_INFO,QUANTUM_TYPE,P,EXCEPTION);
            P+=STRIDE;
            ROWS_REMAINING--;
            IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
              BREAK;
            IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
              {
                STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
                  IMAGE->ROWS);
                IF (STATUS == MAGICKFALSE)
                  BREAK;
              }
          }
         IF ((SAMPLES_PER_PIXEL > 1) && (INTERLACE != PLANARCONFIG_SEPARATE))
            BREAK;
        }
        STRIP_PIXELS=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(STRIP_PIXELS);
        BREAK;
      }
      CASE READTILEMETHOD:
      {
        UNSIGNED CHAR
          *P;

        SIZE_T
          EXTENT;

        UINT32
          COLUMNS,
          ROWS;

        UNSIGNED CHAR
          *TILE_PIXELS;

        /*
          CONVERT TILED TIFF IMAGE.
        */
        IF ((TIFFGETFIELD(TIFF,TIFFTAG_TILEWIDTH,&COLUMNS) != 1) ||
            (TIFFGETFIELD(TIFF,TIFFTAG_TILELENGTH,&ROWS) != 1))
          THROWTIFFEXCEPTION(CODERERROR,"IMAGEISNOTTILED");
        NUMBER_PIXELS=(MAGICKSIZETYPE) COLUMNS*ROWS;
        IF (HEAPOVERFLOWSANITYCHECK(ROWS,SIZEOF(*TILE_PIXELS)) != MAGICKFALSE)
          THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        EXTENT=4*(SAMPLES_PER_PIXEL+1)*MAGICKMAX(ROWS*TIFFTILEROWSIZE(TIFF),
          TIFFTILESIZE(TIFF));
        TILE_PIXELS=(UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY(EXTENT,
          SIZEOF(*TILE_PIXELS));
        IF (TILE_PIXELS == (UNSIGNED CHAR *) NULL)
          THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        (VOID) MEMSET(TILE_PIXELS,0,EXTENT*SIZEOF(*TILE_PIXELS));
        FOR (I=0; I < (SSIZE_T) SAMPLES_PER_PIXEL; I++)
        {
          SWITCH (I)
          {
            CASE 0: BREAK;
            CASE 1: QUANTUM_TYPE=GREENQUANTUM; BREAK;
            CASE 2: QUANTUM_TYPE=BLUEQUANTUM; BREAK;
            CASE 3:
            {
              QUANTUM_TYPE=ALPHAQUANTUM;
              IF (IMAGE->COLORSPACE == CMYKCOLORSPACE)
                QUANTUM_TYPE=BLACKQUANTUM;
              BREAK;
            }
            CASE 4: QUANTUM_TYPE=ALPHAQUANTUM; BREAK;
            DEFAULT: BREAK;
          }
          FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y+=ROWS)
          {
            SSIZE_T
              X;

            SIZE_T
              ROWS_REMAINING;

            ROWS_REMAINING=IMAGE->ROWS-Y;
            IF ((SSIZE_T) (Y+ROWS) < (SSIZE_T) IMAGE->ROWS)
              ROWS_REMAINING=ROWS;
            FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X+=COLUMNS)
            {
              SIZE_T
                COLUMNS_REMAINING,
                ROW;

              COLUMNS_REMAINING=IMAGE->COLUMNS-X;
              IF ((SSIZE_T) (X+COLUMNS) < (SSIZE_T) IMAGE->COLUMNS)
                COLUMNS_REMAINING=COLUMNS;
              TIFF_STATUS=TIFFREADTILE(TIFF,TILE_PIXELS,(UINT32) X,(UINT32) Y,
                0,I);
              IF (TIFF_STATUS == -1)
                BREAK;
              P=TILE_PIXELS;
              FOR (ROW=0; ROW < ROWS_REMAINING; ROW++)
              {
                PIXELPACKET
                  *MAGICK_RESTRICT Q;

                Q=GETAUTHENTICPIXELS(IMAGE,X,Y+ROW,COLUMNS_REMAINING,1,
                  EXCEPTION);
                IF (Q == (PIXELPACKET *) NULL)
                  BREAK;
                (VOID) IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,
                  QUANTUM_INFO,QUANTUM_TYPE,P,EXCEPTION);
                P+=TIFFTILEROWSIZE(TIFF);
                IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
                  BREAK;
              }
            }
          }
          IF ((SAMPLES_PER_PIXEL > 1) && (INTERLACE != PLANARCONFIG_SEPARATE))
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) I,
                SAMPLES_PER_PIXEL);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        TILE_PIXELS=(UNSIGNED CHAR *) RELINQUISHMAGICKMEMORY(TILE_PIXELS);
        BREAK;
      }
      CASE READGENERICMETHOD:
      DEFAULT:
      {
        MEMORYINFO
          *GENERIC_INFO = (MEMORYINFO *) NULL;

        UINT32
          *P;

        UINT32
          *PIXELS;

        /*
          CONVERT GENERIC TIFF IMAGE.
        */
        IF (HEAPOVERFLOWSANITYCHECK(IMAGE->ROWS,SIZEOF(*PIXELS)) != MAGICKFALSE)
          THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        NUMBER_PIXELS=(MAGICKSIZETYPE) IMAGE->COLUMNS*IMAGE->ROWS;
        GENERIC_INFO=ACQUIREVIRTUALMEMORY(NUMBER_PIXELS,SIZEOF(*PIXELS));
        IF (GENERIC_INFO == (MEMORYINFO *) NULL)
          THROWTIFFEXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        PIXELS=(UINT32 *) GETVIRTUALMEMORYBLOB(GENERIC_INFO);
        TIFF_STATUS=TIFFREADRGBAIMAGE(TIFF,(UINT32) IMAGE->COLUMNS,(UINT32)
          IMAGE->ROWS,(UINT32 *) PIXELS,0);
        IF (TIFF_STATUS == -1)
          {
            GENERIC_INFO=RELINQUISHVIRTUALMEMORY(GENERIC_INFO);
            BREAK;
          }
        P=PIXELS+(IMAGE->COLUMNS*IMAGE->ROWS)-1;
        FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
        {
          SSIZE_T
            X;

          PIXELPACKET
            *MAGICK_RESTRICT Q;

          Q=QUEUEAUTHENTICPIXELS(IMAGE,0,Y,IMAGE->COLUMNS,1,EXCEPTION);
          IF (Q == (PIXELPACKET *) NULL)
            BREAK;
          Q+=IMAGE->COLUMNS-1;
          FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
          {
            SETPIXELRED(Q,SCALECHARTOQUANTUM((UNSIGNED CHAR) TIFFGETR(*P)));
            SETPIXELGREEN(Q,SCALECHARTOQUANTUM((UNSIGNED CHAR) TIFFGETG(*P)));
            SETPIXELBLUE(Q,SCALECHARTOQUANTUM((UNSIGNED CHAR) TIFFGETB(*P)));
            IF (IMAGE->MATTE == MAGICKFALSE)
              SETPIXELOPACITY(Q,OPAQUEOPACITY);
            ELSE
              SETPIXELALPHA(Q,SCALECHARTOQUANTUM((UNSIGNED CHAR) TIFFGETA(*P)));
            P--;
            Q--;
          }
          IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
            BREAK;
          IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
            {
              STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
                IMAGE->ROWS);
              IF (STATUS == MAGICKFALSE)
                BREAK;
            }
        }
        GENERIC_INFO=RELINQUISHVIRTUALMEMORY(GENERIC_INFO);
        BREAK;
      }
    }
    PIXEL_INFO=RELINQUISHVIRTUALMEMORY(PIXEL_INFO);
    SETQUANTUMIMAGETYPE(IMAGE,QUANTUM_TYPE);
  NEXT_TIFF_FRAME:
    IF (QUANTUM_INFO != (QUANTUMINFO *) NULL)
      QUANTUM_INFO=DESTROYQUANTUMINFO(QUANTUM_INFO);
    IF (TIFF_STATUS == -1)
      {
        STATUS=MAGICKFALSE;
        BREAK;
      }
    IF (PHOTOMETRIC == PHOTOMETRIC_CIELAB)
      DECODELABIMAGE(IMAGE,EXCEPTION);
    IF ((PHOTOMETRIC == PHOTOMETRIC_LOGL) ||
        (PHOTOMETRIC == PHOTOMETRIC_MINISBLACK) ||
        (PHOTOMETRIC == PHOTOMETRIC_MINISWHITE))
      {
        IMAGE->TYPE=GRAYSCALETYPE;
        IF (BITS_PER_SAMPLE == 1)
          IMAGE->TYPE=BILEVELTYPE;
      }
    /*
      PROCEED TO NEXT IMAGE.
    */
    IF (IMAGE_INFO->NUMBER_SCENES != 0)
      IF (IMAGE->SCENE >= (IMAGE_INFO->SCENE+IMAGE_INFO->NUMBER_SCENES-1))
        BREAK;
    MORE_FRAMES=TIFFREADDIRECTORY(TIFF) != 0 ? MAGICKTRUE : MAGICKFALSE;
    IF (MORE_FRAMES != MAGICKFALSE)
      {
        /*
          ALLOCATE NEXT IMAGE STRUCTURE.
        */
        ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE);
        IF (GETNEXTIMAGEINLIST(IMAGE) == (IMAGE *) NULL)
          {
            STATUS=MAGICKFALSE;
            BREAK;
          }
        IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGESTAG,IMAGE->SCENE-1,
          IMAGE->SCENE);
        IF (STATUS == MAGICKFALSE)
          BREAK;
      }
  } WHILE ((STATUS != MAGICKFALSE) && (MORE_FRAMES != MAGICKFALSE));
  TIFFCLOSE(TIFF);
  IF ((IMAGE_INFO->NUMBER_SCENES != 0) &&
      (IMAGE_INFO->SCENE >= GETIMAGELISTLENGTH(IMAGE)))
    STATUS=MAGICKFALSE;
  IF (STATUS == MAGICKFALSE)
    RETURN(DESTROYIMAGELIST(IMAGE));
  TIFFREADPHOTOSHOPLAYERS(IMAGE_INFO,IMAGE,EXCEPTION);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244218_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_BOX *VOID_BOX_NEW()
{
	ISOM_DECL_BOX_ALLOC(GF_BOX, GF_ISOM_BOX_TYPE_VOID);
	RETURN TMP;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204711_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT LDB_WILDCARD_COMPARE(STRUCT LDB_CONTEXT *LDB,
				CONST STRUCT LDB_PARSE_TREE *TREE,
				CONST STRUCT LDB_VAL VALUE, BOOL *MATCHED)
{
	CONST STRUCT LDB_SCHEMA_ATTRIBUTE *A;
	STRUCT LDB_VAL VAL;
	STRUCT LDB_VAL CNK;
	STRUCT LDB_VAL *CHUNK;
	UINT8_T *SAVE_P = NULL;
	UNSIGNED INT C = 0;

	A = LDB_SCHEMA_ATTRIBUTE_BY_NAME(LDB, TREE->U.SUBSTRING.ATTR);
	IF (!A) {
		RETURN LDB_ERR_INVALID_ATTRIBUTE_SYNTAX;
	}

	IF (TREE->U.SUBSTRING.CHUNKS == NULL) {
		*MATCHED = FALSE;
		RETURN LDB_SUCCESS;
	}

	IF (A->SYNTAX->CANONICALISE_FN(LDB, LDB, &VALUE, &VAL) != 0) {
		RETURN LDB_ERR_INVALID_ATTRIBUTE_SYNTAX;
	}

	SAVE_P = VAL.DATA;
	CNK.DATA = NULL;

	IF ( ! TREE->U.SUBSTRING.START_WITH_WILDCARD ) {

		CHUNK = TREE->U.SUBSTRING.CHUNKS[C];
		IF (A->SYNTAX->CANONICALISE_FN(LDB, LDB, CHUNK, &CNK) != 0) GOTO MISMATCH;

		/* THIS DEALS WITH WILDCARD PREFIX SEARCHES ON BINARY ATTRIBUTES (EG OBJECTGUID) */
		IF (CNK.LENGTH > VAL.LENGTH) {
			GOTO MISMATCH;
		}
		/*
		 * EMPTY STRINGS ARE RETURNED AS LENGTH 0. ENSURE
		 * WE CAN COPE WITH THIS.
		 */
		IF (CNK.LENGTH == 0) {
			GOTO MISMATCH;
		}

		IF (MEMCMP((CHAR *)VAL.DATA, (CHAR *)CNK.DATA, CNK.LENGTH) != 0) GOTO MISMATCH;
		VAL.LENGTH -= CNK.LENGTH;
		VAL.DATA += CNK.LENGTH;
		C++;
		TALLOC_FREE(CNK.DATA);
		CNK.DATA = NULL;
	}

	WHILE (TREE->U.SUBSTRING.CHUNKS[C]) {
		UINT8_T *P;

		CHUNK = TREE->U.SUBSTRING.CHUNKS[C];
		IF(A->SYNTAX->CANONICALISE_FN(LDB, LDB, CHUNK, &CNK) != 0) GOTO MISMATCH;

		/*
		 * EMPTY STRINGS ARE RETURNED AS LENGTH 0. ENSURE
		 * WE CAN COPE WITH THIS.
		 */
		IF (CNK.LENGTH == 0) {
			GOTO MISMATCH;
		}
		/*
		 * VALUES MIGHT BE BINARY BLOBS. DON'T USE STRING
		 * SEARCH, BUT MEMORY SEARCH INSTEAD.
		 */
		P = MEMMEM((CONST VOID *)VAL.DATA,VAL.LENGTH,
			   (CONST VOID *)CNK.DATA, CNK.LENGTH);
		IF (P == NULL) GOTO MISMATCH;

		/*
		 * AT THIS POINT WE KNOW CNK.LENGTH <= VAL.LENGTH AS
		 * OTHERWISE THERE COULD BE NO MATCH
		 */

		IF ( (! TREE->U.SUBSTRING.CHUNKS[C + 1]) && (! TREE->U.SUBSTRING.END_WITH_WILDCARD) ) {
			UINT8_T *G;
			UINT8_T *END = VAL.DATA + VAL.LENGTH;
			DO { /* GREEDY */

				/*
				 * HAYSTACK IS A VALID POINTER IN VAL
				 * BECAUSE THE MEMMEM() CAN ONLY
				 * SUCCEED IF THE NEEDLE (CNK.LENGTH)
				 * IS <= HAYSTACKLEN
				 *
				 * P WILL BE A POINTER AT LEAST
				 * CNK.LENGTH FROM THE END OF HAYSTACK
				 */
				UINT8_T *HAYSTACK
					= P + CNK.LENGTH;
				SIZE_T HAYSTACKLEN
					= END - (HAYSTACK);

				G = MEMMEM(HAYSTACK,
					   HAYSTACKLEN,
					   (CONST UINT8_T *)CNK.DATA,
					   CNK.LENGTH);
				IF (G) {
					P = G;
				}
			} WHILE(G);
		}
		VAL.LENGTH = VAL.LENGTH - (P - (UINT8_T *)(VAL.DATA)) - CNK.LENGTH;
		VAL.DATA = (UINT8_T *)(P + CNK.LENGTH);
		C++;
		TALLOC_FREE(CNK.DATA);
		CNK.DATA = NULL;
	}

	/* LAST CHUNK MAY NOT HAVE REACHED END OF STRING */
	IF ( (! TREE->U.SUBSTRING.END_WITH_WILDCARD) && (*(VAL.DATA) != 0) ) GOTO MISMATCH;
	TALLOC_FREE(SAVE_P);
	*MATCHED = TRUE;
	RETURN LDB_SUCCESS;

MISMATCH:
	*MATCHED = FALSE;
	TALLOC_FREE(SAVE_P);
	TALLOC_FREE(CNK.DATA);
	RETURN LDB_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 384757_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
REDRAW_FOR_CURSORLINE(WIN_T *WP)
{
    IF ((WP->W_P_RNU
#IFDEF FEAT_SYN_HL
		|| WP->W_P_CUL
#ENDIF
		)
	    && (WP->W_VALID & VALID_CROW) == 0
	    && !PUM_VISIBLE())
    {
	IF (WP->W_P_RNU)
	    // WIN_LINE() WILL REDRAW THE NUMBER COLUMN ONLY.
	    REDRAW_WIN_LATER(WP, VALID);
#IFDEF FEAT_SYN_HL
	IF (WP->W_P_CUL)
	{
	    IF (WP->W_REDR_TYPE <= VALID && WP->W_LAST_CURSORLINE != 0)
	    {
		// "W_LAST_CURSORLINE" MAY BE OUTDATED, WORST CASE WE REDRAW
		// TOO MUCH.  THIS IS OPTIMIZED FOR MOVING THE CURSOR AROUND IN
		// THE CURRENT WINDOW.
		REDRAWWINLINE(WP, WP->W_LAST_CURSORLINE);
		REDRAWWINLINE(WP, WP->W_CURSOR.LNUM);
	    }
	    ELSE
		REDRAW_WIN_LATER(WP, SOME_VALID);
	}
#ENDIF
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294628_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
C_VALID_GREGORIAN_P(INT Y, INT M, INT D, INT *RM, INT *RD)
{
    INT LAST;

    IF (M < 0)
	M += 13;
    IF (M < 1 || M > 12)
	RETURN 0;
    LAST = C_GREGORIAN_LAST_DAY_OF_MONTH(Y, M);
    IF (D < 0)
	D = LAST + D + 1;
    IF (D < 1 || D > LAST)
	RETURN 0;
    *RM = M;
    *RD = D;
    RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202943_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
L_NORET LUAG_RUNERROR (LUA_STATE *L, CONST CHAR *FMT, ...) {
  CALLINFO *CI = L->CI;
  CONST CHAR *MSG;
  VA_LIST ARGP;
  LUAC_CHECKGC(L);  /* ERROR MESSAGE USES MEMORY */
  VA_START(ARGP, FMT);
  MSG = LUAO_PUSHVFSTRING(L, FMT, ARGP);  /* FORMAT MESSAGE */
  VA_END(ARGP);
  IF (ISLUA(CI))  /* IF LUA FUNCTION, ADD SOURCE:LINE INFORMATION */
    LUAG_ADDINFO(L, MSG, CI_FUNC(CI)->P->SOURCE, GETCURRENTLINE(CI));
  LUAG_ERRORMSG(L);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 409523_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_SHELLSIZE(VOID)
{
    IF (ROWS < MIN_ROWS())	// NEED ROOM FOR ONE WINDOW AND COMMAND LINE
	ROWS = MIN_ROWS();
    LIMIT_SCREEN_SIZE();

    // MAKE SURE THESE VALUES ARE NOT INVALID
    IF (CMDLINE_ROW >= ROWS)
	CMDLINE_ROW = ROWS - 1;
    IF (MSG_ROW >= ROWS)
	MSG_ROW = ROWS - 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 194963_CWE-704.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MAGICKBOOLEANTYPE GETEXIFPROPERTY(CONST IMAGE *IMAGE,
  CONST CHAR *PROPERTY)
{
#DEFINE MAXDIRECTORYSTACK  16
#DEFINE EXIF_DELIMITER  "\N"
#DEFINE EXIF_NUM_FORMATS  12
#DEFINE EXIF_FMT_BYTE  1
#DEFINE EXIF_FMT_STRING  2
#DEFINE EXIF_FMT_USHORT  3
#DEFINE EXIF_FMT_ULONG  4
#DEFINE EXIF_FMT_URATIONAL  5
#DEFINE EXIF_FMT_SBYTE  6
#DEFINE EXIF_FMT_UNDEFINED  7
#DEFINE EXIF_FMT_SSHORT  8
#DEFINE EXIF_FMT_SLONG  9
#DEFINE EXIF_FMT_SRATIONAL  10
#DEFINE EXIF_FMT_SINGLE  11
#DEFINE EXIF_FMT_DOUBLE  12
#DEFINE TAG_EXIF_OFFSET  0X8769
#DEFINE TAG_GPS_OFFSET  0X8825
#DEFINE TAG_INTEROP_OFFSET  0XA005

#DEFINE EXIFMULTIPLEVALUES(SIZE,FORMAT,ARG) \
{ \
   SSIZE_T \
     COMPONENT; \
 \
   SIZE_T \
     LENGTH; \
 \
   UNSIGNED CHAR \
     *P1; \
 \
   LENGTH=0; \
   P1=P; \
   FOR (COMPONENT=0; COMPONENT < COMPONENTS; COMPONENT++) \
   { \
     LENGTH+=FORMATLOCALESTRING(BUFFER+LENGTH,MAXTEXTEXTENT-LENGTH, \
       FORMAT", ",ARG); \
     IF (LENGTH >= (MAXTEXTEXTENT-1)) \
       LENGTH=MAXTEXTEXTENT-1; \
     P1+=SIZE; \
   } \
   IF (LENGTH > 1) \
     BUFFER[LENGTH-2]='\0'; \
   VALUE=ACQUIRESTRING(BUFFER); \
}

#DEFINE EXIFMULTIPLEFRACTIONS(SIZE,FORMAT,ARG1,ARG2) \
{ \
   SSIZE_T \
     COMPONENT; \
 \
   SIZE_T \
     LENGTH; \
 \
   UNSIGNED CHAR \
     *P1; \
 \
   LENGTH=0; \
   P1=P; \
   FOR (COMPONENT=0; COMPONENT < COMPONENTS; COMPONENT++) \
   { \
     LENGTH+=FORMATLOCALESTRING(BUFFER+LENGTH,MAXTEXTEXTENT-LENGTH, \
       FORMAT", ",(ARG1),(ARG2)); \
     IF (LENGTH >= (MAXTEXTEXTENT-1)) \
       LENGTH=MAXTEXTEXTENT-1; \
     P1+=SIZE; \
   } \
   IF (LENGTH > 1) \
     BUFFER[LENGTH-2]='\0'; \
   VALUE=ACQUIRESTRING(BUFFER); \
}

  TYPEDEF STRUCT _DIRECTORYINFO
  {
    CONST UNSIGNED CHAR
      *DIRECTORY;

    SIZE_T
      ENTRY;

    SSIZE_T
      OFFSET;
  } DIRECTORYINFO;

  TYPEDEF STRUCT _TAGINFO
  {
    SIZE_T
      TAG;

    CONST CHAR
      DESCRIPTION[36];
  } TAGINFO;

  STATIC CONST TAGINFO
    EXIFTAG[] =
    {
      {  0X001, "EXIF:INTEROPERABILITYINDEX" },
      {  0X002, "EXIF:INTEROPERABILITYVERSION" },
      {  0X100, "EXIF:IMAGEWIDTH" },
      {  0X101, "EXIF:IMAGELENGTH" },
      {  0X102, "EXIF:BITSPERSAMPLE" },
      {  0X103, "EXIF:COMPRESSION" },
      {  0X106, "EXIF:PHOTOMETRICINTERPRETATION" },
      {  0X10A, "EXIF:FILLORDER" },
      {  0X10D, "EXIF:DOCUMENTNAME" },
      {  0X10E, "EXIF:IMAGEDESCRIPTION" },
      {  0X10F, "EXIF:MAKE" },
      {  0X110, "EXIF:MODEL" },
      {  0X111, "EXIF:STRIPOFFSETS" },
      {  0X112, "EXIF:ORIENTATION" },
      {  0X115, "EXIF:SAMPLESPERPIXEL" },
      {  0X116, "EXIF:ROWSPERSTRIP" },
      {  0X117, "EXIF:STRIPBYTECOUNTS" },
      {  0X11A, "EXIF:XRESOLUTION" },
      {  0X11B, "EXIF:YRESOLUTION" },
      {  0X11C, "EXIF:PLANARCONFIGURATION" },
      {  0X11D, "EXIF:PAGENAME" },
      {  0X11E, "EXIF:XPOSITION" },
      {  0X11F, "EXIF:YPOSITION" },
      {  0X118, "EXIF:MINSAMPLEVALUE" },
      {  0X119, "EXIF:MAXSAMPLEVALUE" },
      {  0X120, "EXIF:FREEOFFSETS" },
      {  0X121, "EXIF:FREEBYTECOUNTS" },
      {  0X122, "EXIF:GRAYRESPONSEUNIT" },
      {  0X123, "EXIF:GRAYRESPONSECURVE" },
      {  0X124, "EXIF:T4OPTIONS" },
      {  0X125, "EXIF:T6OPTIONS" },
      {  0X128, "EXIF:RESOLUTIONUNIT" },
      {  0X12D, "EXIF:TRANSFERFUNCTION" },
      {  0X131, "EXIF:SOFTWARE" },
      {  0X132, "EXIF:DATETIME" },
      {  0X13B, "EXIF:ARTIST" },
      {  0X13E, "EXIF:WHITEPOINT" },
      {  0X13F, "EXIF:PRIMARYCHROMATICITIES" },
      {  0X140, "EXIF:COLORMAP" },
      {  0X141, "EXIF:HALFTONEHINTS" },
      {  0X142, "EXIF:TILEWIDTH" },
      {  0X143, "EXIF:TILELENGTH" },
      {  0X144, "EXIF:TILEOFFSETS" },
      {  0X145, "EXIF:TILEBYTECOUNTS" },
      {  0X14A, "EXIF:SUBIFD" },
      {  0X14C, "EXIF:INKSET" },
      {  0X14D, "EXIF:INKNAMES" },
      {  0X14E, "EXIF:NUMBEROFINKS" },
      {  0X150, "EXIF:DOTRANGE" },
      {  0X151, "EXIF:TARGETPRINTER" },
      {  0X152, "EXIF:EXTRASAMPLE" },
      {  0X153, "EXIF:SAMPLEFORMAT" },
      {  0X154, "EXIF:SMINSAMPLEVALUE" },
      {  0X155, "EXIF:SMAXSAMPLEVALUE" },
      {  0X156, "EXIF:TRANSFERRANGE" },
      {  0X157, "EXIF:CLIPPATH" },
      {  0X158, "EXIF:XCLIPPATHUNITS" },
      {  0X159, "EXIF:YCLIPPATHUNITS" },
      {  0X15A, "EXIF:INDEXED" },
      {  0X15B, "EXIF:JPEGTABLES" },
      {  0X15F, "EXIF:OPIPROXY" },
      {  0X200, "EXIF:JPEGPROC" },
      {  0X201, "EXIF:JPEGINTERCHANGEFORMAT" },
      {  0X202, "EXIF:JPEGINTERCHANGEFORMATLENGTH" },
      {  0X203, "EXIF:JPEGRESTARTINTERVAL" },
      {  0X205, "EXIF:JPEGLOSSLESSPREDICTORS" },
      {  0X206, "EXIF:JPEGPOINTTRANSFORMS" },
      {  0X207, "EXIF:JPEGQTABLES" },
      {  0X208, "EXIF:JPEGDCTABLES" },
      {  0X209, "EXIF:JPEGACTABLES" },
      {  0X211, "EXIF:YCBCRCOEFFICIENTS" },
      {  0X212, "EXIF:YCBCRSUBSAMPLING" },
      {  0X213, "EXIF:YCBCRPOSITIONING" },
      {  0X214, "EXIF:REFERENCEBLACKWHITE" },
      {  0X2BC, "EXIF:EXTENSIBLEMETADATAPLATFORM" },
      {  0X301, "EXIF:GAMMA" },
      {  0X302, "EXIF:ICCPROFILEDESCRIPTOR" },
      {  0X303, "EXIF:SRGBRENDERINGINTENT" },
      {  0X320, "EXIF:IMAGETITLE" },
      {  0X5001, "EXIF:RESOLUTIONXUNIT" },
      {  0X5002, "EXIF:RESOLUTIONYUNIT" },
      {  0X5003, "EXIF:RESOLUTIONXLENGTHUNIT" },
      {  0X5004, "EXIF:RESOLUTIONYLENGTHUNIT" },
      {  0X5005, "EXIF:PRINTFLAGS" },
      {  0X5006, "EXIF:PRINTFLAGSVERSION" },
      {  0X5007, "EXIF:PRINTFLAGSCROP" },
      {  0X5008, "EXIF:PRINTFLAGSBLEEDWIDTH" },
      {  0X5009, "EXIF:PRINTFLAGSBLEEDWIDTHSCALE" },
      {  0X500A, "EXIF:HALFTONELPI" },
      {  0X500B, "EXIF:HALFTONELPIUNIT" },
      {  0X500C, "EXIF:HALFTONEDEGREE" },
      {  0X500D, "EXIF:HALFTONESHAPE" },
      {  0X500E, "EXIF:HALFTONEMISC" },
      {  0X500F, "EXIF:HALFTONESCREEN" },
      {  0X5010, "EXIF:JPEGQUALITY" },
      {  0X5011, "EXIF:GRIDSIZE" },
      {  0X5012, "EXIF:THUMBNAILFORMAT" },
      {  0X5013, "EXIF:THUMBNAILWIDTH" },
      {  0X5014, "EXIF:THUMBNAILHEIGHT" },
      {  0X5015, "EXIF:THUMBNAILCOLORDEPTH" },
      {  0X5016, "EXIF:THUMBNAILPLANES" },
      {  0X5017, "EXIF:THUMBNAILRAWBYTES" },
      {  0X5018, "EXIF:THUMBNAILSIZE" },
      {  0X5019, "EXIF:THUMBNAILCOMPRESSEDSIZE" },
      {  0X501A, "EXIF:COLORTRANSFERFUNCTION" },
      {  0X501B, "EXIF:THUMBNAILDATA" },
      {  0X5020, "EXIF:THUMBNAILIMAGEWIDTH" },
      {  0X5021, "EXIF:THUMBNAILIMAGEHEIGHT" },
      {  0X5022, "EXIF:THUMBNAILBITSPERSAMPLE" },
      {  0X5023, "EXIF:THUMBNAILCOMPRESSION" },
      {  0X5024, "EXIF:THUMBNAILPHOTOMETRICINTERP" },
      {  0X5025, "EXIF:THUMBNAILIMAGEDESCRIPTION" },
      {  0X5026, "EXIF:THUMBNAILEQUIPMAKE" },
      {  0X5027, "EXIF:THUMBNAILEQUIPMODEL" },
      {  0X5028, "EXIF:THUMBNAILSTRIPOFFSETS" },
      {  0X5029, "EXIF:THUMBNAILORIENTATION" },
      {  0X502A, "EXIF:THUMBNAILSAMPLESPERPIXEL" },
      {  0X502B, "EXIF:THUMBNAILROWSPERSTRIP" },
      {  0X502C, "EXIF:THUMBNAILSTRIPBYTESCOUNT" },
      {  0X502D, "EXIF:THUMBNAILRESOLUTIONX" },
      {  0X502E, "EXIF:THUMBNAILRESOLUTIONY" },
      {  0X502F, "EXIF:THUMBNAILPLANARCONFIG" },
      {  0X5030, "EXIF:THUMBNAILRESOLUTIONUNIT" },
      {  0X5031, "EXIF:THUMBNAILTRANSFERFUNCTION" },
      {  0X5032, "EXIF:THUMBNAILSOFTWAREUSED" },
      {  0X5033, "EXIF:THUMBNAILDATETIME" },
      {  0X5034, "EXIF:THUMBNAILARTIST" },
      {  0X5035, "EXIF:THUMBNAILWHITEPOINT" },
      {  0X5036, "EXIF:THUMBNAILPRIMARYCHROMATICITIES" },
      {  0X5037, "EXIF:THUMBNAILYCBCRCOEFFICIENTS" },
      {  0X5038, "EXIF:THUMBNAILYCBCRSUBSAMPLING" },
      {  0X5039, "EXIF:THUMBNAILYCBCRPOSITIONING" },
      {  0X503A, "EXIF:THUMBNAILREFBLACKWHITE" },
      {  0X503B, "EXIF:THUMBNAILCOPYRIGHT" },
      {  0X5090, "EXIF:LUMINANCETABLE" },
      {  0X5091, "EXIF:CHROMINANCETABLE" },
      {  0X5100, "EXIF:FRAMEDELAY" },
      {  0X5101, "EXIF:LOOPCOUNT" },
      {  0X5110, "EXIF:PIXELUNIT" },
      {  0X5111, "EXIF:PIXELPERUNITX" },
      {  0X5112, "EXIF:PIXELPERUNITY" },
      {  0X5113, "EXIF:PALETTEHISTOGRAM" },
      {  0X1000, "EXIF:RELATEDIMAGEFILEFORMAT" },
      {  0X1001, "EXIF:RELATEDIMAGELENGTH" },
      {  0X1002, "EXIF:RELATEDIMAGEWIDTH" },
      {  0X800D, "EXIF:IMAGEID" },
      {  0X80E3, "EXIF:MATTEING" },
      {  0X80E4, "EXIF:DATATYPE" },
      {  0X80E5, "EXIF:IMAGEDEPTH" },
      {  0X80E6, "EXIF:TILEDEPTH" },
      {  0X828D, "EXIF:CFAREPEATPATTERNDIM" },
      {  0X828E, "EXIF:CFAPATTERN2" },
      {  0X828F, "EXIF:BATTERYLEVEL" },
      {  0X8298, "EXIF:COPYRIGHT" },
      {  0X829A, "EXIF:EXPOSURETIME" },
      {  0X829D, "EXIF:FNUMBER" },
      {  0X83BB, "EXIF:IPTC/NAA" },
      {  0X84E3, "EXIF:IT8RASTERPADDING" },
      {  0X84E5, "EXIF:IT8COLORTABLE" },
      {  0X8649, "EXIF:IMAGERESOURCEINFORMATION" },
      {  0X8769, "EXIF:EXIFOFFSET" },  /* SPECS AS "EXIF IFD POINTER"? */
      {  0X8773, "EXIF:INTERCOLORPROFILE" },
      {  0X8822, "EXIF:EXPOSUREPROGRAM" },
      {  0X8824, "EXIF:SPECTRALSENSITIVITY" },
      {  0X8825, "EXIF:GPSINFO" }, /* SPECS AS "GPSINFO IFD POINTER"? */
      {  0X8827, "EXIF:PHOTOGRAPHICSENSITIVITY" },
      {  0X8828, "EXIF:OECF" },
      {  0X8829, "EXIF:INTERLACE" },      
      {  0X882A, "EXIF:TIMEZONEOFFSET" },
      {  0X882B, "EXIF:SELFTIMERMODE" },
      {  0X8830, "EXIF:SENSITIVITYTYPE" },
      {  0X8831, "EXIF:STANDARDOUTPUTSENSITIVITY" },
      {  0X8832, "EXIF:RECOMMENDEDEXPOSUREINDEX" },
      {  0X8833, "EXIF:ISOSPEED" },
      {  0X8834, "EXIF:ISOSPEEDLATITUDEYYY" },
      {  0X8835, "EXIF:ISOSPEEDLATITUDEZZZ" },
      {  0X9000, "EXIF:EXIFVERSION" },
      {  0X9003, "EXIF:DATETIMEORIGINAL" },
      {  0X9004, "EXIF:DATETIMEDIGITIZED" },
      {  0X9010, "EXIF:OFFSETTIME" },
      {  0X9011, "EXIF:OFFSETTIMEORIGINAL" },
      {  0X9012, "EXIF:OFFSETTIMEDIGITIZED" },
      {  0X9101, "EXIF:COMPONENTSCONFIGURATION" },
      {  0X9102, "EXIF:COMPRESSEDBITSPERPIXEL" },
      {  0X9201, "EXIF:SHUTTERSPEEDVALUE" },
      {  0X9202, "EXIF:APERTUREVALUE" },
      {  0X9203, "EXIF:BRIGHTNESSVALUE" },
      {  0X9204, "EXIF:EXPOSUREBIASVALUE" },
      {  0X9205, "EXIF:MAXAPERTUREVALUE" },
      {  0X9206, "EXIF:SUBJECTDISTANCE" },
      {  0X9207, "EXIF:METERINGMODE" },
      {  0X9208, "EXIF:LIGHTSOURCE" },
      {  0X9209, "EXIF:FLASH" },
      {  0X920A, "EXIF:FOCALLENGTH" },
      {  0X920B, "EXIF:FLASHENERGY" },
      {  0X920C, "EXIF:SPATIALFREQUENCYRESPONSE" },
      {  0X920D, "EXIF:NOISE" },
      {  0X9214, "EXIF:SUBJECTAREA" },
      {  0X9290, "EXIF:SUBSECTIME" },
      {  0X9291, "EXIF:SUBSECTIMEORIGINAL" },
      {  0X9292, "EXIF:SUBSECTIMEDIGITIZED" },    
      {  0X9211, "EXIF:IMAGENUMBER" },
      {  0X9212, "EXIF:SECURITYCLASSIFICATION" },
      {  0X9213, "EXIF:IMAGEHISTORY" },
      {  0X9214, "EXIF:SUBJECTAREA" },
      {  0X9215, "EXIF:EXPOSUREINDEX" },
      {  0X9216, "EXIF:TIFF-EPSTANDARDID" },
      {  0X927C, "EXIF:MAKERNOTE" },
      {  0X9286, "EXIF:USERCOMMENT" },
      {  0X9290, "EXIF:SUBSECTIME" },
      {  0X9291, "EXIF:SUBSECTIMEORIGINAL" },
      {  0X9292, "EXIF:SUBSECTIMEDIGITIZED" },    
      {  0X9400, "EXIF:TEMPERATURE" },
      {  0X9401, "EXIF:HUMIDITY" },
      {  0X9402, "EXIF:PRESSURE" },
      {  0X9403, "EXIF:WATERDEPTH" },
      {  0X9404, "EXIF:ACCELERATION" },
      {  0X9405, "EXIF:CAMERAELEVATIONANGLE" },    
      {  0X9C9B, "EXIF:WINXP-TITLE" },
      {  0X9C9C, "EXIF:WINXP-COMMENTS" },
      {  0X9C9D, "EXIF:WINXP-AUTHOR" },
      {  0X9C9E, "EXIF:WINXP-KEYWORDS" },
      {  0X9C9F, "EXIF:WINXP-SUBJECT" },      
      {  0XA000, "EXIF:FLASHPIXVERSION" },
      {  0XA001, "EXIF:COLORSPACE" },
      {  0XA002, "EXIF:PIXELXDIMENSION" },
      {  0XA003, "EXIF:PIXELYDIMENSION" },
      {  0XA004, "EXIF:RELATEDSOUNDFILE" },
      {  0XA005, "EXIF:INTEROPERABILITYOFFSET" },
      {  0XA20B, "EXIF:FLASHENERGY" },
      {  0XA20C, "EXIF:SPATIALFREQUENCYRESPONSE" },
      {  0XA20D, "EXIF:NOISE" },
      {  0XA20E, "EXIF:FOCALPLANEXRESOLUTION" },
      {  0XA20F, "EXIF:FOCALPLANEYRESOLUTION" },
      {  0XA210, "EXIF:FOCALPLANERESOLUTIONUNIT" },
      {  0XA214, "EXIF:SUBJECTLOCATION" },
      {  0XA215, "EXIF:EXPOSUREINDEX" },
      {  0XA216, "EXIF:TIFF/EPSTANDARDID" },
      {  0XA217, "EXIF:SENSINGMETHOD" },
      {  0XA300, "EXIF:FILESOURCE" },
      {  0XA301, "EXIF:SCENETYPE" },
      {  0XA302, "EXIF:CFAPATTERN" },
      {  0XA401, "EXIF:CUSTOMRENDERED" },
      {  0XA402, "EXIF:EXPOSUREMODE" },
      {  0XA403, "EXIF:WHITEBALANCE" },
      {  0XA404, "EXIF:DIGITALZOOMRATIO" },
      {  0XA405, "EXIF:FOCALLENGTHIN35MMFILM" },
      {  0XA406, "EXIF:SCENECAPTURETYPE" },
      {  0XA407, "EXIF:GAINCONTROL" },
      {  0XA408, "EXIF:CONTRAST" },
      {  0XA409, "EXIF:SATURATION" },
      {  0XA40A, "EXIF:SHARPNESS" },
      {  0XA40B, "EXIF:DEVICESETTINGDESCRIPTION" },
      {  0XA40C, "EXIF:SUBJECTDISTANCERANGE" },
      {  0XA420, "EXIF:IMAGEUNIQUEID" },
      {  0XA430, "EXIF:CAMERAOWNERNAME" },
      {  0XA431, "EXIF:BODYSERIALNUMBER" },
      {  0XA432, "EXIF:LENSSPECIFICATION" },
      {  0XA433, "EXIF:LENSMAKE" },
      {  0XA434, "EXIF:LENSMODEL" },
      {  0XA435, "EXIF:LENSSERIALNUMBER" },
      {  0XC4A5, "EXIF:PRINTIMAGEMATCHING" },
      {  0XA500, "EXIF:GAMMA" },
      {  0XC640, "EXIF:CR2SLICE" },
      { 0X10000, "EXIF:GPSVERSIONID" },
      { 0X10001, "EXIF:GPSLATITUDEREF" },
      { 0X10002, "EXIF:GPSLATITUDE" },
      { 0X10003, "EXIF:GPSLONGITUDEREF" },
      { 0X10004, "EXIF:GPSLONGITUDE" },
      { 0X10005, "EXIF:GPSALTITUDEREF" },
      { 0X10006, "EXIF:GPSALTITUDE" },
      { 0X10007, "EXIF:GPSTIMESTAMP" },
      { 0X10008, "EXIF:GPSSATELLITES" },
      { 0X10009, "EXIF:GPSSTATUS" },
      { 0X1000A, "EXIF:GPSMEASUREMODE" },
      { 0X1000B, "EXIF:GPSDOP" },
      { 0X1000C, "EXIF:GPSSPEEDREF" },
      { 0X1000D, "EXIF:GPSSPEED" },
      { 0X1000E, "EXIF:GPSTRACKREF" },
      { 0X1000F, "EXIF:GPSTRACK" },
      { 0X10010, "EXIF:GPSIMGDIRECTIONREF" },
      { 0X10011, "EXIF:GPSIMGDIRECTION" },
      { 0X10012, "EXIF:GPSMAPDATUM" },
      { 0X10013, "EXIF:GPSDESTLATITUDEREF" },
      { 0X10014, "EXIF:GPSDESTLATITUDE" },
      { 0X10015, "EXIF:GPSDESTLONGITUDEREF" },
      { 0X10016, "EXIF:GPSDESTLONGITUDE" },
      { 0X10017, "EXIF:GPSDESTBEARINGREF" },
      { 0X10018, "EXIF:GPSDESTBEARING" },
      { 0X10019, "EXIF:GPSDESTDISTANCEREF" },
      { 0X1001A, "EXIF:GPSDESTDISTANCE" },
      { 0X1001B, "EXIF:GPSPROCESSINGMETHOD" },
      { 0X1001C, "EXIF:GPSAREAINFORMATION" },
      { 0X1001D, "EXIF:GPSDATESTAMP" },
      { 0X1001E, "EXIF:GPSDIFFERENTIAL" },
      { 0X1001F, "EXIF:GPSHPOSITIONINGERROR" },
      { 0X00000, "" }
    };  /* HTTP://WWW.CIPA.JP/STD/DOCUMENTS/E/DC-008-TRANSLATION-2016-E.PDF */

  CONST STRINGINFO
    *PROFILE;

  CONST UNSIGNED CHAR
    *DIRECTORY,
    *EXIF;

  DIRECTORYINFO
    DIRECTORY_STACK[MAXDIRECTORYSTACK];

  ENDIANTYPE
    ENDIAN;

  MAGICKBOOLEANTYPE
    STATUS;

  SSIZE_T
    I;

  SIZE_T
    ENTRY,
    LENGTH,
    NUMBER_ENTRIES,
    TAG,
    TAG_VALUE;

  SPLAYTREEINFO
    *EXIF_RESOURCES;

  SSIZE_T
    ALL,
    ID,
    LEVEL,
    OFFSET,
    TAG_OFFSET;

  STATIC INT
    TAG_BYTES[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};

  /*
    IF EXIF DATA EXISTS, THEN TRY TO PARSE THE REQUEST FOR A TAG.
  */
  PROFILE=GETIMAGEPROFILE(IMAGE,"EXIF");
  IF (PROFILE == (CONST STRINGINFO *) NULL)
    RETURN(MAGICKFALSE);
  IF ((PROPERTY == (CONST CHAR *) NULL) || (*PROPERTY == '\0'))
    RETURN(MAGICKFALSE);
  WHILE (ISSPACE((INT) ((UNSIGNED CHAR) *PROPERTY)) != 0)
    PROPERTY++;
  IF (STRLEN(PROPERTY) <= 5)
    RETURN(MAGICKFALSE);
  ALL=0;
  TAG=(~0UL);
  SWITCH (*(PROPERTY+5))
  {
    CASE '*':
    {
      /*
        CALLER HAS ASKED FOR ALL THE TAGS IN THE EXIF DATA.
      */
      TAG=0;
      ALL=1; /* RETURN THE DATA IN DESCRIPTION=VALUE FORMAT */
      BREAK;
    }
    CASE '!':
    {
      TAG=0;
      ALL=2; /* RETURN THE DATA IN TAGID=VALUE FORMAT */
      BREAK;
    }
    CASE '#':
    CASE '@':
    {
      INT
        C;

      SIZE_T
        N;

      /*
        CHECK FOR A HEX BASED TAG SPECIFICATION FIRST.
      */
      TAG=(*(PROPERTY+5) == '@') ? 1UL : 0UL;
      PROPERTY+=6;
      N=STRLEN(PROPERTY);
      IF (N != 4)
        RETURN(MAGICKFALSE);
      /*
        PARSE TAG SPECIFICATION AS A HEX NUMBER.
      */
      N/=4;
      DO
      {
        FOR (I=(SSIZE_T) N-1L; I >= 0; I--)
        {
          C=(*PROPERTY++);
          TAG<<=4;
          IF ((C >= '0') && (C <= '9'))
            TAG|=(C-'0');
          ELSE
            IF ((C >= 'A') && (C <= 'F'))
              TAG|=(C-('A'-10));
            ELSE
              IF ((C >= 'A') && (C <= 'F'))
                TAG|=(C-('A'-10));
              ELSE
                RETURN(MAGICKFALSE);
        }
      } WHILE (*PROPERTY != '\0');
      BREAK;
    }
    DEFAULT:
    {
      /*
        TRY TO MATCH THE TEXT WITH A TAG NAME INSTEAD.
      */
      FOR (I=0; ; I++)
      {
        IF (EXIFTAG[I].TAG == 0)
          BREAK;
        IF (LOCALECOMPARE(EXIFTAG[I].DESCRIPTION,PROPERTY) == 0)
          {
            TAG=(SIZE_T) EXIFTAG[I].TAG;
            BREAK;
          }
      }
      BREAK;
    }
  }
  IF (TAG == (~0UL))
    RETURN(MAGICKFALSE);
  LENGTH=GETSTRINGINFOLENGTH(PROFILE);
  IF (LENGTH < 6)
    RETURN(MAGICKFALSE);
  EXIF=GETSTRINGINFODATUM(PROFILE);
  WHILE (LENGTH != 0)
  {
    IF (READPROPERTYBYTE(&EXIF,&LENGTH) != 0X45)
      CONTINUE;
    IF (READPROPERTYBYTE(&EXIF,&LENGTH) != 0X78)
      CONTINUE;
    IF (READPROPERTYBYTE(&EXIF,&LENGTH) != 0X69)
      CONTINUE;
    IF (READPROPERTYBYTE(&EXIF,&LENGTH) != 0X66)
      CONTINUE;
    IF (READPROPERTYBYTE(&EXIF,&LENGTH) != 0X00)
      CONTINUE;
    IF (READPROPERTYBYTE(&EXIF,&LENGTH) != 0X00)
      CONTINUE;
    BREAK;
  }
  IF (LENGTH < 16)
    RETURN(MAGICKFALSE);
  ID=(SSIZE_T) READPROPERTYSIGNEDSHORT(LSBENDIAN,EXIF);
  ENDIAN=LSBENDIAN;
  IF (ID == 0X4949)
    ENDIAN=LSBENDIAN;
  ELSE
    IF (ID == 0X4D4D)
      ENDIAN=MSBENDIAN;
    ELSE
      RETURN(MAGICKFALSE);
  IF (READPROPERTYUNSIGNEDSHORT(ENDIAN,EXIF+2) != 0X002A)
    RETURN(MAGICKFALSE);
  /*
    THIS THE OFFSET TO THE FIRST IFD.
  */
  OFFSET=(SSIZE_T) READPROPERTYSIGNEDLONG(ENDIAN,EXIF+4);
  IF ((OFFSET < 0) || (SIZE_T) OFFSET >= LENGTH)
    RETURN(MAGICKFALSE);
  /*
    SET THE POINTER TO THE FIRST IFD AND FOLLOW IT WERE IT LEADS.
  */
  STATUS=MAGICKFALSE;
  DIRECTORY=EXIF+OFFSET;
  LEVEL=0;
  ENTRY=0;
  TAG_OFFSET=0;
  EXIF_RESOURCES=NEWSPLAYTREE((INT (*)(CONST VOID *,CONST VOID *)) NULL,
    (VOID *(*)(VOID *)) NULL,(VOID *(*)(VOID *)) NULL);
  DO
  {
    /*
      IF THERE IS ANYTHING ON THE STACK THEN POP IT OFF.
    */
    IF (LEVEL > 0)
      {
        LEVEL--;
        DIRECTORY=DIRECTORY_STACK[LEVEL].DIRECTORY;
        ENTRY=DIRECTORY_STACK[LEVEL].ENTRY;
        TAG_OFFSET=DIRECTORY_STACK[LEVEL].OFFSET;
      }
    IF ((DIRECTORY < EXIF) || (DIRECTORY > (EXIF+LENGTH-2)))
      BREAK;
    /*
      DETERMINE HOW MANY ENTRIES THERE ARE IN THE CURRENT IFD.
    */
    NUMBER_ENTRIES=(SIZE_T) READPROPERTYUNSIGNEDSHORT(ENDIAN,DIRECTORY);
    FOR ( ; ENTRY < NUMBER_ENTRIES; ENTRY++)
    {
      UNSIGNED CHAR
        *P,
        *Q;

      SIZE_T
        FORMAT;

      SSIZE_T
        NUMBER_BYTES,
        COMPONENTS;

      Q=(UNSIGNED CHAR *) (DIRECTORY+(12*ENTRY)+2);
      IF (Q > (EXIF+LENGTH-12))
        BREAK;  /* CORRUPT EXIF */
      IF (GETVALUEFROMSPLAYTREE(EXIF_RESOURCES,Q) == Q)
        BREAK;
      (VOID) ADDVALUETOSPLAYTREE(EXIF_RESOURCES,Q,Q);
      TAG_VALUE=(SIZE_T) READPROPERTYUNSIGNEDSHORT(ENDIAN,Q)+TAG_OFFSET;
      FORMAT=(SIZE_T) READPROPERTYUNSIGNEDSHORT(ENDIAN,Q+2);
      IF (FORMAT >= (SIZEOF(TAG_BYTES)/SIZEOF(*TAG_BYTES)))
        BREAK;
      IF (FORMAT == 0)
        BREAK;  /* CORRUPT EXIF */
      COMPONENTS=(SSIZE_T) READPROPERTYSIGNEDLONG(ENDIAN,Q+4);
      IF (COMPONENTS < 0)
        BREAK;  /* CORRUPT EXIF */
      NUMBER_BYTES=(SIZE_T) COMPONENTS*TAG_BYTES[FORMAT];
      IF (NUMBER_BYTES < COMPONENTS)
        BREAK;  /* PREVENT OVERFLOW */
      IF (NUMBER_BYTES <= 4)
        P=Q+8;
      ELSE
        {
          SSIZE_T
            DIR_OFFSET;

          /*
            THE DIRECTORY ENTRY CONTAINS AN OFFSET.
          */
          DIR_OFFSET=(SSIZE_T) READPROPERTYSIGNEDLONG(ENDIAN,Q+8);
          IF ((DIR_OFFSET < 0) || (SIZE_T) DIR_OFFSET >= LENGTH)
            CONTINUE;
          IF (((SIZE_T) DIR_OFFSET+NUMBER_BYTES) < (SIZE_T) DIR_OFFSET)
            CONTINUE;  /* PREVENT OVERFLOW */
          IF (((SIZE_T) DIR_OFFSET+NUMBER_BYTES) > LENGTH)
            CONTINUE;
          P=(UNSIGNED CHAR *) (EXIF+DIR_OFFSET);
        }
      IF ((ALL != 0) || (TAG == (SIZE_T) TAG_VALUE))
        {
          CHAR
            BUFFER[MAXTEXTEXTENT],
            *VALUE;

          IF ((P < EXIF) || (P > (EXIF+LENGTH-TAG_BYTES[FORMAT])))
            BREAK;
          VALUE=(CHAR *) NULL;
          *BUFFER='\0';
          SWITCH (FORMAT)
          {
            CASE EXIF_FMT_BYTE:
            CASE EXIF_FMT_UNDEFINED:
            {
              VALUE=(CHAR *) NULL;
              IF (~((SIZE_T) NUMBER_BYTES) >= 1)
                VALUE=(CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T) NUMBER_BYTES+1UL,
                  SIZEOF(*VALUE));
              IF (VALUE != (CHAR *) NULL)
                {
                  FOR (I=0; I < (SSIZE_T) NUMBER_BYTES; I++)
                  {
                    VALUE[I]='.';
                    IF (ISPRINT((INT) P[I]) != 0) 
                      VALUE[I]=(CHAR) P[I];
                  }
                  VALUE[I]='\0';
                }
              BREAK;
            }
            CASE EXIF_FMT_SBYTE:
            {
              EXIFMULTIPLEVALUES(1,"%.20G",(DOUBLE) (*(SIGNED CHAR *) P1));
              BREAK;
            }
            CASE EXIF_FMT_SSHORT:
            {
              EXIFMULTIPLEVALUES(2,"%HD",READPROPERTYSIGNEDSHORT(ENDIAN,P1));
              BREAK;
            }
            CASE EXIF_FMT_USHORT:
            {
              EXIFMULTIPLEVALUES(2,"%HU",READPROPERTYUNSIGNEDSHORT(ENDIAN,P1));
              BREAK;
            }
            CASE EXIF_FMT_ULONG:
            {
              EXIFMULTIPLEVALUES(4,"%.20G",(DOUBLE)
                READPROPERTYUNSIGNEDLONG(ENDIAN,P1));
              BREAK;
            }
            CASE EXIF_FMT_SLONG:
            {
              EXIFMULTIPLEVALUES(4,"%.20G",(DOUBLE)
                READPROPERTYSIGNEDLONG(ENDIAN,P1));
              BREAK;
            }
            CASE EXIF_FMT_URATIONAL:
            {
              EXIFMULTIPLEFRACTIONS(8,"%.20G/%.20G",(DOUBLE)
                READPROPERTYUNSIGNEDLONG(ENDIAN,P1),(DOUBLE)
                READPROPERTYUNSIGNEDLONG(ENDIAN,P1+4));
              BREAK;
            }
            CASE EXIF_FMT_SRATIONAL:
            {
              EXIFMULTIPLEFRACTIONS(8,"%.20G/%.20G",(DOUBLE)
                READPROPERTYSIGNEDLONG(ENDIAN,P1),(DOUBLE)
                READPROPERTYSIGNEDLONG(ENDIAN,P1+4));
              BREAK;
            }
            CASE EXIF_FMT_SINGLE:
            {
              EXIFMULTIPLEVALUES(4,"%F",(DOUBLE) *(FLOAT *) P1);
              BREAK;
            }
            CASE EXIF_FMT_DOUBLE:
            {
              EXIFMULTIPLEVALUES(8,"%F",*(DOUBLE *) P1);
              BREAK;
            }
            CASE EXIF_FMT_STRING:
            DEFAULT:
            {
              IF ((P < EXIF) || (P > (EXIF+LENGTH-NUMBER_BYTES)))
                BREAK;
              VALUE=(CHAR *) NULL;
              IF (~((SIZE_T) NUMBER_BYTES) >= 1)
                VALUE=(CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T) NUMBER_BYTES+1UL,
                  SIZEOF(*VALUE));
              IF (VALUE != (CHAR *) NULL)
                {
                  SSIZE_T
                    I;

                  FOR (I=0; I < (SSIZE_T) NUMBER_BYTES; I++)
                  {
                    VALUE[I]='.';
                    IF ((ISPRINT((INT) P[I]) != 0) || (P[I] == '\0'))
                      VALUE[I]=(CHAR) P[I];
                  }
                  VALUE[I]='\0';
                }
              BREAK;
            }
          }
          IF (VALUE != (CHAR *) NULL)
            {
              CHAR
                *KEY;

              CONST CHAR
                *P;

              KEY=ACQUIRESTRING(PROPERTY);
              SWITCH (ALL)
              {
                CASE 1:
                {
                  CONST CHAR
                    *DESCRIPTION;

                  SSIZE_T
                    I;

                  DESCRIPTION="UNKNOWN";
                  FOR (I=0; ; I++)
                  {
                    IF (EXIFTAG[I].TAG == 0)
                      BREAK;
                    IF (EXIFTAG[I].TAG == TAG_VALUE)
                      {
                        DESCRIPTION=EXIFTAG[I].DESCRIPTION;
                        BREAK;
                      }
                  }
                  (VOID) FORMATLOCALESTRING(KEY,MAXTEXTEXTENT,"%S",
                    DESCRIPTION);
                  IF (LEVEL == 2)
                    (VOID) SUBSTITUTESTRING(&KEY,"EXIF:","EXIF:THUMBNAIL:");
                  BREAK;
                }
                CASE 2:
                {
                  IF (TAG_VALUE < 0X10000)
                    (VOID) FORMATLOCALESTRING(KEY,MAXTEXTEXTENT,"#%04LX",
                      (UNSIGNED LONG) TAG_VALUE);
                  ELSE
                    IF (TAG_VALUE < 0X20000)
                      (VOID) FORMATLOCALESTRING(KEY,MAXTEXTEXTENT,"@%04LX",
                        (UNSIGNED LONG) (TAG_VALUE & 0XFFFF));
                    ELSE
                      (VOID) FORMATLOCALESTRING(KEY,MAXTEXTEXTENT,"UNKNOWN");
                  BREAK;
                }
                DEFAULT:
                {
                  IF (LEVEL == 2)
                    (VOID) SUBSTITUTESTRING(&KEY,"EXIF:","EXIF:THUMBNAIL:");
                }
              }
              P=(CONST CHAR *) NULL;
              IF (IMAGE->PROPERTIES != (VOID *) NULL)
                P=(CONST CHAR *) GETVALUEFROMSPLAYTREE((SPLAYTREEINFO *)
                  IMAGE->PROPERTIES,KEY);
              IF (P == (CONST CHAR *) NULL)
                (VOID) SETIMAGEPROPERTY((IMAGE *) IMAGE,KEY,VALUE);
              VALUE=DESTROYSTRING(VALUE);
              KEY=DESTROYSTRING(KEY);
              STATUS=MAGICKTRUE;
            }
        }
        IF ((TAG_VALUE == TAG_EXIF_OFFSET) ||
            (TAG_VALUE == TAG_INTEROP_OFFSET) || (TAG_VALUE == TAG_GPS_OFFSET))
          {
            SSIZE_T
              OFFSET;

            OFFSET=(SSIZE_T) READPROPERTYSIGNEDLONG(ENDIAN,P);
            IF (((SIZE_T) OFFSET < LENGTH) && (LEVEL < (MAXDIRECTORYSTACK-2)))
              {
                SSIZE_T
                  TAG_OFFSET1;

                TAG_OFFSET1=(SSIZE_T) ((TAG_VALUE == TAG_GPS_OFFSET) ? 0X10000 :
                  0);
                DIRECTORY_STACK[LEVEL].DIRECTORY=DIRECTORY;
                ENTRY++;
                DIRECTORY_STACK[LEVEL].ENTRY=ENTRY;
                DIRECTORY_STACK[LEVEL].OFFSET=TAG_OFFSET;
                LEVEL++;
                /*
                  CHECK FOR DUPLICATE TAG.
                */
                FOR (I=0; I < LEVEL; I++)
                  IF (DIRECTORY_STACK[I].DIRECTORY == (EXIF+TAG_OFFSET1))
                    BREAK;
                IF (I < LEVEL)
                  BREAK;  /* DUPLICATE TAG */
                DIRECTORY_STACK[LEVEL].DIRECTORY=EXIF+OFFSET;
                DIRECTORY_STACK[LEVEL].OFFSET=TAG_OFFSET1;
                DIRECTORY_STACK[LEVEL].ENTRY=0;
                LEVEL++;
                IF ((DIRECTORY+2+(12*NUMBER_ENTRIES)+4) > (EXIF+LENGTH))
                  BREAK;
                OFFSET=(SSIZE_T) READPROPERTYSIGNEDLONG(ENDIAN,DIRECTORY+2+(12*
                  NUMBER_ENTRIES));
                IF ((OFFSET != 0) && ((SIZE_T) OFFSET < LENGTH) &&
                    (LEVEL < (MAXDIRECTORYSTACK-2)))
                  {
                    DIRECTORY_STACK[LEVEL].DIRECTORY=EXIF+OFFSET;
                    DIRECTORY_STACK[LEVEL].ENTRY=0;
                    DIRECTORY_STACK[LEVEL].OFFSET=TAG_OFFSET1;
                    LEVEL++;
                  }
              }
            BREAK;
          }
    }
  } WHILE (LEVEL > 0);
  EXIF_RESOURCES=DESTROYSPLAYTREE(EXIF_RESOURCES);
  RETURN(STATUS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 389748_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_FOR_OPT_CHAN_OR_JOB_ARG(TYPVAL_T *ARGS, INT IDX)
{
    RETURN (ARGS[IDX].V_TYPE == VAR_UNKNOWN
	    || CHECK_FOR_CHAN_OR_JOB_ARG(ARGS, IDX) != FAIL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211563_CWE-122.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
N_START_VISUAL_MODE(INT C)
{
#IFDEF FEAT_CONCEAL
    INT CURSOR_LINE_WAS_CONCEALED = CURWIN->W_P_COLE > 0
						&& CONCEAL_CURSOR_LINE(CURWIN);
#ENDIF

    VISUAL_MODE = C;
    VISUAL_ACTIVE = TRUE;
    VISUAL_RESELECT = TRUE;
    TRIGGER_MODECHANGED();

    // CORNER CASE: THE 0 POSITION IN A TAB MAY CHANGE WHEN GOING INTO
    // VIRTUALEDIT.  RECALCULATE CURWIN->W_CURSOR TO AVOID BAD HIGHLIGHTING.
    IF (C == CTRL_V && (GET_VE_FLAGS() & VE_BLOCK) && GCHAR_CURSOR() == TAB)
    {
	VALIDATE_VIRTCOL();
	COLADVANCE(CURWIN->W_VIRTCOL);
    }
    VISUAL = CURWIN->W_CURSOR;

#IFDEF FEAT_FOLDING
    FOLDADJUSTVISUAL();
#ENDIF

    SETMOUSE();
#IFDEF FEAT_CONCEAL
    // CHECK IF REDRAW IS NEEDED AFTER CHANGING THE STATE.
    CONCEAL_CHECK_CURSOR_LINE(CURSOR_LINE_WAS_CONCEALED);
#ENDIF

    IF (P_SMD && MSG_SILENT == 0)
	REDRAW_CMDLINE = TRUE;	// SHOW VISUAL MODE LATER
#IFDEF FEAT_CLIPBOARD
    // MAKE SURE THE CLIPBOARD GETS UPDATED.  NEEDED BECAUSE START AND
    // END MAY STILL BE THE SAME, AND THE SELECTION NEEDS TO BE OWNED
    CLIP_STAR.VMODE = NUL;
#ENDIF

    // ONLY NEED TO REDRAW THIS LINE, UNLESS STILL NEED TO REDRAW AN OLD
    // VISUAL AREA (WHEN 'LAZYREDRAW' IS SET).
    IF (CURWIN->W_REDR_TYPE < INVERTED)
    {
	CURWIN->W_OLD_CURSOR_LNUM = CURWIN->W_CURSOR.LNUM;
	CURWIN->W_OLD_VISUAL_LNUM = CURWIN->W_CURSOR.LNUM;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 474057_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UNINAME2CTYPE_P (STR, LEN)
     REGISTER CONST CHAR *STR;
     REGISTER UNSIGNED INT LEN;
{
  STATIC CONST STRUCT UNINAME2CTYPE_STRUCT WORDLIST[] =
    {
#IFDEF USE_UNICODE_PROPERTIES
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR3,                                        33},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR5,                                        23},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR7,                                       35},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR8,                                       24},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR10,                                       20},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR11,                                       36},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR12,                                       26},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR13,                                        17},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR16,                                       21},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR20,                                       18},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR21,                                      93},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR22,                                     93},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR23,                                    150},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR26,                                       59},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR29,                                    127},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR30,                                     142},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR31,                                    142},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR32,                                    113},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR34,                                  18},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR37,                                    147},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR40,                                  147},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR42,                                       51},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR44,                                    86},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR46,                                     74},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR47,                                     3},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR48,                                    74},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR51,                                     108},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR53,                                   79},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR54,                                    110},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR55,                                    115},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR60,                                    108},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR63,                                 115},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR66,                                       27},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR67,                                       49},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR69,                                    105},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR70,                                   184},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR71,                                       46},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR73,                                        50},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR74,                                  178},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR75,                                    151},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR76,                                    100},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR84,                                    157},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR88,                                    113},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR89,                                     81},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR90,                                     92},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR91,                       197},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR92,                                  91},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR93,                                   170},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR94,                                    14},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR95,                       42},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR98,                                    17},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR99,                             170},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR100,                                   81},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR101,                                    152},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR103,                                  182},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR105,                              36},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR106,                              26},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR109,                                     91},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR112,                                    119},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR114,                     38},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR115,                                        45},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR116,                                       69},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR117,                                      197},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR119,                                    195},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR120,                                      66},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR121,                                     190},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR122,                                       22},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR123,                                 152},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR124,                                     180},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR125,                                     99},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR126,                   161},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR128,                                 122},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR137,                                 188},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR143,                                     193},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR147,                               180},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR148,                                    200},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR149,                                     98},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR151,                      100},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR152,                                       53},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR153,                              49},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR156,                               110},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR161,                    162},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR162,                                 151},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR163,                            51},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR166,                            194},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR170,                                    194},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR171,                           177},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR172,                               113},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR174,                          182},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR175,                     174},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR176,                                     82},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR179,                         178},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR180,                                    179},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR181,                   184},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR183,                         195},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR187,                                   119},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR190,                              132},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR192,                               82},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR193,                                   23},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR195,                                       34},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR197,                                    187},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR198,                                    112},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR200,                          27},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR202,                                       43},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR203,                                    171},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR206,                                       38},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR209,                             35},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR212,                                       42},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR215,                                157},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR217,                                       32},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR218,                                  65},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR220,                               66},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR222,                                      65},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR223,                                     1},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR227,                                       30},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR229,                                  127},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR234,                               104},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR235,                                   73},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR236,                                     77},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR237,                                    127},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR243,                                    124},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR244,                                    159},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR245,                                    162},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR246,                                    161},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR250,                                 77},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR251,                                      192},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR252,                                 167},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR255,                              136},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR258,                                     87},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR261,                                    87},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR268,                                    58},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR269,                                    149},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR270,                       186},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR271,                                    140},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR275,          190},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR278,                                     7},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR286,                                    123},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR292,                                    154},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR294,                                     54},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR296,                                    120},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR297,                         40},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR301,                         43},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR303,                                    134},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR306,                                   175},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR307,                               154},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR308,                                       44},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR310,                                     79},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR311,                                    125},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR314,                                 150},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR317,                                 120},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR321,                                  140},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR322,                                    167},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR324,                                    158},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR325,                                    174},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR326,                              129},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR327,                               21},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR328,                                       40},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR335,                                 112},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR340,                                    166},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR341,                                    102},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR343,                               175},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR344,                                   102},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR345,                                     97},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR346,                                 98},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR349,                                       31},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR350,                                   198},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR353,                                50},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR355,                                     94},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR356,                                  111},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR358,                                117},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR359,                                    160},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR361,                                    128},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR367,                                  94},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR371,                                    111},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR372,                                    145},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR373,                                   97},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR374,                                  83},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR375,                                105},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR376,                                 125},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR379,                                     96},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR380,                                 201},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR381,                                 203},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR382,                                 210},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR383,                                 211},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR384,                                 208},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR385,                                        37},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR386,                                       39},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR388,                                    155},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR389,                                 202},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR390,                                 209},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR391,                                 212},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR392,                                 207},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR393,                                     5},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR395,                                    143},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR396,                                     9},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR397,                                 205},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR398,                                 206},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR399,                                     78},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR402,                                   169},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR405,                                 204},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR408,                             169},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR413,                   193},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR420,                                     88},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR422,                                       52},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR427,                                        29},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR430,                                       25},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR432,                      187},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR433,                                134},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR434,                                   189},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR436,                           53},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR438,                                    70},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR442,                                    13},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR443,                               163},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR445,                                     68},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR446,                                    186},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR447,                                    177},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR452,                                   19},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR456,                            59},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR457,                                130},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR459,                               139},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR462,                                     181},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR464,                              143},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR465,                       198},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR466,                                     4},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR474,                                    139},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR480,                            34},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR484,                                    107},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR485,                                       48},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR488,                          183},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR493,                             179},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR496,                                     67},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR497,                               20},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR502,                                 137},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR506,                               55},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR508,                                    118},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR512,                                   11},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR513,                                 67},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR516,                                    104},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR518,                              68},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR521,                                 16},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR523,                                    101},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR529,                                     138},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR530,                                    138},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR533,                                    141},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR534,                              191},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR535,                                  166},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR536,                                    137},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR538,                                    106},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR540,                                    144},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR542,                    60},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR543,                                181},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR550,                                     191},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR554,                                 141},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR562,                                      60},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR563,                             71},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR565,                                    136},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR573,                                    163},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR576,                                     8},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR577,                                    133},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR580,                                     6},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR586,                                   196},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR587,                                      109},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR588,                                    146},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR589,                                     76},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR591,                                  146},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR592,                         41},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR593,                                     86},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR594,                           70},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR596,                                  164},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR597,                                    132},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR598,                                    109},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR599,                                    164},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR601,                                 76},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR602,                                    129},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR605,                                  183},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR617,                                    117},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR620,                                      62},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR623,                                   33},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR625,                                    114},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR626,                                     89},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR627,                          24},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR628,                    62},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR629,                              192},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR632,                                    121},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR634,                                    131},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR636,                                       28},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR640,                                 114},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR643,                              133},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR644,                                     80},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR645,                                  89},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR646,                                     83},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR647,                                56},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR656,                                    122},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR659,                           199},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR660,                                   80},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR663,                                     12},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR667,                         159},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR672,                                121},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR675,                            31},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR677,                                 96},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR678,                                    148},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR681,                                  148},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR686,                             131},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR687,                                     85},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR692,                                    130},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR696,                           46},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR701,                                   0},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR705,                                107},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR706,                                  185},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR707,                                 99},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR708,                                 85},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR710,                               128},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR716,                          39},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR718,                         160},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR725,                                    10},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR732,                                       19},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR734,                                    116},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR735,                                  145},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR736,                     185},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR739,                           25},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR745,                           32},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR749,                    64},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR752,                                     29},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR757,                                22},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR765,                       52},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR767,                                   101},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR768,                                     176},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR772,                          28},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR777,                                176},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR778,                                     64},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR781,                                   71},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR782,                                    103},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR788,                        189},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR792,                                57},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR793,                                   103},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR795,                              30},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR797,                              168},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR806,                                  199},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR816,                                 124},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR818,                          44},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR821,                                    156},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR831,                                   116},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR840,                                    165},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR851,                                   45},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR856,                    61},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR857,                                 123},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR861,                                   118},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR868,                              37},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR872,                                  172},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR888,                               48},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR892,                                     75},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR898,                    63},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR902,                           173},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR903,                                    126},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR916,                               135},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR918,                                       41},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR927,                                     63},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR932,                                   156},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR940,                                     84},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR944,                                  168},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR951,                             158},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR976,                69},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR980,                           47},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR999,                                     90},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1007,                                     95},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1020,                                90},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1026,                                  95},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1032,                                   88},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1033,                                126},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1037,                                    135},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1093,                                       47},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1097,                                106},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1124,                                    153},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1146,                                      15},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1148,                                 144},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1190,                                      61},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1263,                                   173},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1329,                                     2},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1347,                                   72},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1358,                                   165},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1395,                                 200},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1410,                                    75},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
#ENDIF /* USE_UNICODE_PROPERTIES */
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
#IFNDEF USE_UNICODE_PROPERTIES
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR7,                                     7},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR8,                                     8},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR9,                                     1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR10,                                    13},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR11,                                   11},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR12,                                   0},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR13,                                    10},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR14,                                    14},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR15,                                     3},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR16,                                     9},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR17,                                     12},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR18,                                     6},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR19,                                     5},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR20,                                     4},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR21,                                     2}
#ELSE /* USE_UNICODE_PROPERTIES */
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1463,                             72},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1470,                                 84},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1556,                                   78},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1621,                     153},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
      {-1}, {-1},
      {(INT)(LONG)&((STRUCT UNINAME2CTYPE_POOL_T *)0)->UNINAME2CTYPE_POOL_STR1741,                                     73}
#ENDIF /* USE_UNICODE_PROPERTIES */
    };

  IF (LEN <= MAX_WORD_LENGTH && LEN >= MIN_WORD_LENGTH)
    {
      REGISTER INT KEY = UNINAME2CTYPE_HASH (STR, LEN);

      IF (KEY <= MAX_HASH_VALUE && KEY >= 0)
        {
          REGISTER INT O = WORDLIST[KEY].NAME;
          IF (O >= 0)
            {
              REGISTER CONST CHAR *S = O + UNINAME2CTYPE_POOL;

              IF (*STR == *S && !STRNCMP (STR + 1, S + 1, LEN - 1) && S[LEN] == '\0')
                RETURN &WORDLIST[KEY];
            }
        }
    }
  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195231_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
S32 GF_AVC_PARSE_NALU(GF_BITSTREAM *BS, AVCSTATE *AVC)
{
	U8 IDR_FLAG;
	S32 SLICE, RET;
	U32 NAL_HDR;
	AVCSLICEINFO N_STATE;

	GF_BS_ENABLE_EMULATION_BYTE_REMOVAL(BS, GF_TRUE);

	NAL_HDR = GF_BS_READ_U8(BS);

	SLICE = 0;
	MEMCPY(&N_STATE, &AVC->S_INFO, SIZEOF(AVCSLICEINFO));
	AVC->LAST_NAL_TYPE_PARSED = N_STATE.NAL_UNIT_TYPE = NAL_HDR & 0X1F;
	N_STATE.NAL_REF_IDC = (NAL_HDR >> 5) & 0X3;

	IDR_FLAG = 0;

	SWITCH (N_STATE.NAL_UNIT_TYPE) {
	CASE GF_AVC_NALU_ACCESS_UNIT:
	CASE GF_AVC_NALU_END_OF_SEQ:
	CASE GF_AVC_NALU_END_OF_STREAM:
		RET = 1;
		BREAK;

	CASE GF_AVC_NALU_SVC_SLICE:
		SVC_READNAL_HEADER_EXTENSION(BS, &N_STATE.NALHEADER);
		// SLICE BUFFER - READ THE INFO AND COMPARE.
		/*RET = */SVC_PARSE_SLICE(BS, AVC, &N_STATE);
		IF (AVC->S_INFO.NAL_REF_IDC) {
			N_STATE.POC_LSB_PREV = AVC->S_INFO.POC_LSB;
			N_STATE.POC_MSB_PREV = AVC->S_INFO.POC_MSB;
		}
		AVC_COMPUTE_POC(&N_STATE);

		IF (AVC->S_INFO.POC != N_STATE.POC) {
			MEMCPY(&AVC->S_INFO, &N_STATE, SIZEOF(AVCSLICEINFO));
			RETURN 1;
		}
		MEMCPY(&AVC->S_INFO, &N_STATE, SIZEOF(AVCSLICEINFO));
		RETURN 0;

	CASE GF_AVC_NALU_SVC_PREFIX_NALU:
		SVC_READNAL_HEADER_EXTENSION(BS, &N_STATE.NALHEADER);
		RETURN 0;

	CASE GF_AVC_NALU_IDR_SLICE:
	CASE GF_AVC_NALU_NON_IDR_SLICE:
	CASE GF_AVC_NALU_DP_A_SLICE:
	CASE GF_AVC_NALU_DP_B_SLICE:
	CASE GF_AVC_NALU_DP_C_SLICE:
		SLICE = 1;
		/* SLICE BUFFER - READ THE INFO AND COMPARE.*/
		RET = AVC_PARSE_SLICE(BS, AVC, IDR_FLAG, &N_STATE);
		IF (RET < 0) RETURN RET;
		RET = 0;
		IF (
			((AVC->S_INFO.NAL_UNIT_TYPE > GF_AVC_NALU_IDR_SLICE) || (AVC->S_INFO.NAL_UNIT_TYPE < GF_AVC_NALU_NON_IDR_SLICE))
			&& (AVC->S_INFO.NAL_UNIT_TYPE != GF_AVC_NALU_SVC_SLICE)
			) {
			BREAK;
		}
		IF (AVC->S_INFO.FRAME_NUM != N_STATE.FRAME_NUM) {
			RET = 1;
			BREAK;
		}

		IF (AVC->S_INFO.FIELD_PIC_FLAG != N_STATE.FIELD_PIC_FLAG) {
			RET = 1;
			BREAK;
		}
		IF ((AVC->S_INFO.NAL_REF_IDC != N_STATE.NAL_REF_IDC) &&
			(!AVC->S_INFO.NAL_REF_IDC || !N_STATE.NAL_REF_IDC)) {
			RET = 1;
			BREAK;
		}
		ASSERT(AVC->S_INFO.SPS);

		IF (AVC->S_INFO.SPS->POC_TYPE == N_STATE.SPS->POC_TYPE) {
			IF (!AVC->S_INFO.SPS->POC_TYPE) {
				IF (!N_STATE.BOTTOM_FIELD_FLAG && (AVC->S_INFO.POC_LSB != N_STATE.POC_LSB)) {
					RET = 1;
					BREAK;
				}
				IF (AVC->S_INFO.DELTA_POC_BOTTOM != N_STATE.DELTA_POC_BOTTOM) {
					RET = 1;
					BREAK;
				}
			}
			ELSE IF (AVC->S_INFO.SPS->POC_TYPE == 1) {
				IF (AVC->S_INFO.DELTA_POC[0] != N_STATE.DELTA_POC[0]) {
					RET = 1;
					BREAK;
				}
				IF (AVC->S_INFO.DELTA_POC[1] != N_STATE.DELTA_POC[1]) {
					RET = 1;
					BREAK;
				}
			}
		}

		IF (N_STATE.NAL_UNIT_TYPE == GF_AVC_NALU_IDR_SLICE) {
			IF (AVC->S_INFO.NAL_UNIT_TYPE != GF_AVC_NALU_IDR_SLICE) { /*IDRPICFLAG DIFFERS IN VALUE*/
				RET = 1;
				BREAK;
			}
			ELSE IF (AVC->S_INFO.IDR_PIC_ID != N_STATE.IDR_PIC_ID) { /*BOTH IDR AND IDR_PIC_ID DIFFERS*/
				RET = 1;
				BREAK;
			}
		}
		BREAK;
	CASE GF_AVC_NALU_SEQ_PARAM:
		AVC->LAST_PS_IDX = GF_AVC_READ_SPS_BS_INTERNAL(BS, AVC, 0, NULL, NAL_HDR);
		IF (AVC->LAST_PS_IDX < 0) RETURN -1;
		RETURN 0;

	CASE GF_AVC_NALU_PIC_PARAM:
		AVC->LAST_PS_IDX = GF_AVC_READ_PPS_BS_INTERNAL(BS, AVC, NAL_HDR);
		IF (AVC->LAST_PS_IDX < 0) RETURN -1;
		RETURN 0;
	CASE GF_AVC_NALU_SVC_SUBSEQ_PARAM:
		AVC->LAST_PS_IDX = GF_AVC_READ_SPS_BS_INTERNAL(BS, AVC, 1, NULL, NAL_HDR);
		IF (AVC->LAST_PS_IDX < 0) RETURN -1;
		RETURN 0;
	CASE GF_AVC_NALU_SEQ_PARAM_EXT:
		AVC->LAST_PS_IDX = (S32) GF_BS_READ_UE(BS);
		IF (AVC->LAST_PS_IDX < 0) RETURN -1;
		RETURN 0;

	CASE GF_AVC_NALU_SEI:
	CASE GF_AVC_NALU_FILLER_DATA:
		RETURN 0;

	DEFAULT:
		IF (AVC->S_INFO.NAL_UNIT_TYPE <= GF_AVC_NALU_IDR_SLICE) RET = 1;
		//TO DETECT CHANGE OF AU WHEN MULTIPLE SPS AND PPS IN STREAM
		ELSE IF ((NAL_HDR & 0X1F) == GF_AVC_NALU_SEI && AVC->S_INFO.NAL_UNIT_TYPE == GF_AVC_NALU_SVC_SLICE)
			RET = 1;
		ELSE IF ((NAL_HDR & 0X1F) == GF_AVC_NALU_SEQ_PARAM && AVC->S_INFO.NAL_UNIT_TYPE == GF_AVC_NALU_SVC_SLICE)
			RET = 1;
		ELSE
			RET = 0;
		BREAK;
	}

	/* SAVE _PREV VALUES */
	IF (RET && AVC->S_INFO.SPS) {
		N_STATE.FRAME_NUM_OFFSET_PREV = AVC->S_INFO.FRAME_NUM_OFFSET;
		IF ((AVC->S_INFO.SPS->POC_TYPE != 2) || (AVC->S_INFO.NAL_REF_IDC != 0))
			N_STATE.FRAME_NUM_PREV = AVC->S_INFO.FRAME_NUM;
		IF (AVC->S_INFO.NAL_REF_IDC) {
			N_STATE.POC_LSB_PREV = AVC->S_INFO.POC_LSB;
			N_STATE.POC_MSB_PREV = AVC->S_INFO.POC_MSB;
		}
	}
	IF (SLICE)
		AVC_COMPUTE_POC(&N_STATE);
	MEMCPY(&AVC->S_INFO, &N_STATE, SIZEOF(AVCSLICEINFO));
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 301492_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CAN_BE_COMPOUND(
    TRYSTATE_T	*SP,
    SLANG_T	*SLANG,
    CHAR_U	*COMPFLAGS,
    INT		FLAG)
{
    // IF THE FLAG DOESN'T APPEAR IN SL_COMPSTARTFLAGS OR SL_COMPALLFLAGS
    // THEN IT CAN'T POSSIBLY COMPOUND.
    IF (!BYTE_IN_STR(SP->TS_COMPLEN == SP->TS_COMPSPLIT
		? SLANG->SL_COMPSTARTFLAGS : SLANG->SL_COMPALLFLAGS, FLAG))
	RETURN FALSE;

    // IF THERE ARE NO WILDCARDS, WE CAN CHECK IF THE FLAGS COLLECTED SO FAR
    // POSSIBLY CAN FORM A MATCH WITH COMPOUNDRULE PATTERNS.  THIS ONLY
    // MAKES SENSE WHEN WE HAVE TWO OR MORE WORDS.
    IF (SLANG->SL_COMPRULES != NULL && SP->TS_COMPLEN > SP->TS_COMPSPLIT)
    {
	INT V;

	COMPFLAGS[SP->TS_COMPLEN] = FLAG;
	COMPFLAGS[SP->TS_COMPLEN + 1] = NUL;
	V = MATCH_COMPOUNDRULE(SLANG, COMPFLAGS + SP->TS_COMPSPLIT);
	COMPFLAGS[SP->TS_COMPLEN] = NUL;
	RETURN V;
    }

    RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198662_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EX_COPY(LINENR_T LINE1, LINENR_T LINE2, LINENR_T N)
{
    LINENR_T	COUNT;
    CHAR_U	*P;

    COUNT = LINE2 - LINE1 + 1;
    IF ((CMDMOD.CMOD_FLAGS & CMOD_LOCKMARKS) == 0)
    {
	CURBUF->B_OP_START.LNUM = N + 1;
	CURBUF->B_OP_END.LNUM = N + COUNT;
	CURBUF->B_OP_START.COL = CURBUF->B_OP_END.COL = 0;
    }

    /*
     * THERE ARE THREE SITUATIONS:
     * 1. DESTINATION IS ABOVE LINE1
     * 2. DESTINATION IS BETWEEN LINE1 AND LINE2
     * 3. DESTINATION IS BELOW LINE2
     *
     * N = DESTINATION (WHEN STARTING)
     * CURWIN->W_CURSOR.LNUM = DESTINATION (WHILE COPYING)
     * LINE1 = START OF SOURCE (WHILE COPYING)
     * LINE2 = END OF SOURCE (WHILE COPYING)
     */
    IF (U_SAVE(N, N + 1) == FAIL)
	RETURN;

    CURWIN->W_CURSOR.LNUM = N;
    WHILE (LINE1 <= LINE2)
    {
	// NEED TO USE VIM_STRSAVE() BECAUSE THE LINE WILL BE UNLOCKED WITHIN
	// ML_APPEND()
	P = VIM_STRSAVE(ML_GET(LINE1));
	IF (P != NULL)
	{
	    ML_APPEND(CURWIN->W_CURSOR.LNUM, P, (COLNR_T)0, FALSE);
	    VIM_FREE(P);
	}
	// SITUATION 2: SKIP ALREADY COPIED LINES
	IF (LINE1 == N)
	    LINE1 = CURWIN->W_CURSOR.LNUM;
	++LINE1;
	IF (CURWIN->W_CURSOR.LNUM < LINE1)
	    ++LINE1;
	IF (CURWIN->W_CURSOR.LNUM < LINE2)
	    ++LINE2;
	++CURWIN->W_CURSOR.LNUM;
    }

    APPENDED_LINES_MARK(N, COUNT);

    MSGMORE((LONG)COUNT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195246_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC S32 AVC_PARSE_SLICE(GF_BITSTREAM *BS, AVCSTATE *AVC, BOOL SVC_IDR_FLAG, AVCSLICEINFO *SI)
{
	S32 PPS_ID, NUM_REF_IDX_L0_ACTIVE_MINUS1 = 0, NUM_REF_IDX_L1_ACTIVE_MINUS1 = 0;

	/*S->CURRENT_PICTURE.REFERENCE= H->NAL_REF_IDC != 0;*/
	GF_BS_READ_UE_LOG(BS, "FIRST_MB_IN_SLICE");
	SI->SLICE_TYPE = GF_BS_READ_UE_LOG(BS, "SLICE_TYPE");
	IF (SI->SLICE_TYPE > 9) RETURN -1;

	PPS_ID = GF_BS_READ_UE_LOG(BS, "PPS_ID");
	IF (PPS_ID > 255) RETURN -1;
	SI->PPS = &AVC->PPS[PPS_ID];
	IF (!SI->PPS->SLICE_GROUP_COUNT) RETURN -2;
	SI->SPS = &AVC->SPS[SI->PPS->SPS_ID];
	IF (!SI->SPS->LOG2_MAX_FRAME_NUM) RETURN -2;
	AVC->SPS_ACTIVE_IDX = SI->PPS->SPS_ID;
	AVC->PPS_ACTIVE_IDX = PPS_ID;

	SI->FRAME_NUM = GF_BS_READ_INT_LOG(BS, SI->SPS->LOG2_MAX_FRAME_NUM, "FRAME_NUM");

	SI->FIELD_PIC_FLAG = 0;
	SI->BOTTOM_FIELD_FLAG = 0;
	IF (!SI->SPS->FRAME_MBS_ONLY_FLAG) {
		SI->FIELD_PIC_FLAG = GF_BS_READ_INT_LOG(BS, 1, "FIELD_PIC_FLAG");
		IF (SI->FIELD_PIC_FLAG)
			SI->BOTTOM_FIELD_FLAG = GF_BS_READ_INT_LOG(BS, 1, "BOTTOM_FIELD_FLAG");
	}

	IF ((SI->NAL_UNIT_TYPE == GF_AVC_NALU_IDR_SLICE) || SVC_IDR_FLAG)
		SI->IDR_PIC_ID = GF_BS_READ_UE_LOG(BS, "IDR_PIC_ID");

	IF (SI->SPS->POC_TYPE == 0) {
		SI->POC_LSB = GF_BS_READ_INT_LOG(BS, SI->SPS->LOG2_MAX_POC_LSB, "POC_LSB");
		IF (SI->PPS->PIC_ORDER_PRESENT && !SI->FIELD_PIC_FLAG) {
			SI->DELTA_POC_BOTTOM = GF_BS_READ_SE_LOG(BS, "POC_LSB");
		}
	}
	ELSE IF ((SI->SPS->POC_TYPE == 1) && !SI->SPS->DELTA_PIC_ORDER_ALWAYS_ZERO_FLAG) {
		SI->DELTA_POC[0] = GF_BS_READ_SE_LOG(BS, "DELTA_POC0");
		IF ((SI->PPS->PIC_ORDER_PRESENT == 1) && !SI->FIELD_PIC_FLAG)
			SI->DELTA_POC[1] = GF_BS_READ_SE_LOG(BS, "DELTA_POC1");
	}

	IF (SI->PPS->REDUNDANT_PIC_CNT_PRESENT) {
		SI->REDUNDANT_PIC_CNT = GF_BS_READ_UE_LOG(BS, "REDUNDANT_PIC_CNT");
	}

	IF (SI->SLICE_TYPE % 5 == GF_AVC_TYPE_B) {
		GF_BS_READ_INT_LOG(BS, 1, "DIRECT_SPATIAL_MV_PRED_FLAG");
	}

	NUM_REF_IDX_L0_ACTIVE_MINUS1 = SI->PPS->NUM_REF_IDX_L0_DEFAULT_ACTIVE_MINUS1;
	NUM_REF_IDX_L1_ACTIVE_MINUS1 = SI->PPS->NUM_REF_IDX_L1_DEFAULT_ACTIVE_MINUS1;

	IF (SI->SLICE_TYPE % 5 == GF_AVC_TYPE_P || SI->SLICE_TYPE % 5 == GF_AVC_TYPE_SP || SI->SLICE_TYPE % 5 == GF_AVC_TYPE_B) {
		BOOL NUM_REF_IDX_ACTIVE_OVERRIDE_FLAG = GF_BS_READ_INT_LOG(BS, 1, "NUM_REF_IDX_ACTIVE_OVERRIDE_FLAG");
		IF (NUM_REF_IDX_ACTIVE_OVERRIDE_FLAG) {
			NUM_REF_IDX_L0_ACTIVE_MINUS1 = GF_BS_READ_UE_LOG(BS, "NUM_REF_IDX_L0_ACTIVE_MINUS1");
			IF (SI->SLICE_TYPE % 5 == GF_AVC_TYPE_B) {
				NUM_REF_IDX_L1_ACTIVE_MINUS1 = GF_BS_READ_UE_LOG(BS, "NUM_REF_IDX_L1_ACTIVE_MINUS1");
			}
		}
	}

	IF (SI->NAL_UNIT_TYPE == 20 || SI->NAL_UNIT_TYPE == 21) {
		//REF_PIC_LIST_MVC_MODIFICATION(); /* SPECIFIED IN ANNEX H */
		GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, ("[AVC-H264] UNIMPLEMENTED REF_PIC_LIST_MVC_MODIFICATION() IN SLIDE HEADER\N"));
		ASSERT(0);
		RETURN -1;
	}
	ELSE {
		REF_PIC_LIST_MODIFICATION(BS, SI->SLICE_TYPE);
	}

	IF ((SI->PPS->WEIGHTED_PRED_FLAG && (SI->SLICE_TYPE % 5 == GF_AVC_TYPE_P || SI->SLICE_TYPE % 5 == GF_AVC_TYPE_SP))
		|| (SI->PPS->WEIGHTED_BIPRED_IDC == 1 && SI->SLICE_TYPE % 5 == GF_AVC_TYPE_B)) {
		PRED_WEIGHT_TABLE(BS, SI->SLICE_TYPE, SI->SPS->CHROMAARRAYTYPE, NUM_REF_IDX_L0_ACTIVE_MINUS1, NUM_REF_IDX_L1_ACTIVE_MINUS1);
	}

	IF (SI->NAL_REF_IDC != 0) {
		DEC_REF_PIC_MARKING(BS, (SI->NAL_UNIT_TYPE == GF_AVC_NALU_IDR_SLICE));
	}

	IF (SI->PPS->ENTROPY_CODING_MODE_FLAG && SI->SLICE_TYPE % 5 != GF_AVC_TYPE_I && SI->SLICE_TYPE % 5 != GF_AVC_TYPE_SI) {
		GF_BS_READ_UE_LOG(BS, "CABAC_INIT_IDC");
	}

	/*SLICE_QP_DELTA = */GF_BS_READ_SE(BS);
	IF (SI->SLICE_TYPE % 5 == GF_AVC_TYPE_SP || SI->SLICE_TYPE % 5 == GF_AVC_TYPE_SI) {
		IF (SI->SLICE_TYPE % 5 == GF_AVC_TYPE_SP) {
			GF_BS_READ_INT_LOG(BS, 1, "SP_FOR_SWITCH_FLAG");
		}
		GF_BS_READ_SE_LOG(BS, "SLICE_QS_DELTA");
	}

	IF (SI->PPS->DEBLOCKING_FILTER_CONTROL_PRESENT_FLAG) {
		IF (GF_BS_READ_UE_LOG(BS, "DISABLE_DEBLOCKING_FILTER_IDC") != 1) {
			GF_BS_READ_SE_LOG(BS, "SLICE_ALPHA_C0_OFFSET_DIV2");
			GF_BS_READ_SE_LOG(BS, "SLICE_BETA_OFFSET_DIV2");
		}
	}

	IF (SI->PPS->SLICE_GROUP_COUNT > 1 && SI->PPS->MB_SLICE_GROUP_MAP_TYPE >= 3 && SI->PPS->MB_SLICE_GROUP_MAP_TYPE <= 5) {
		GF_BS_READ_INT_LOG(BS, (U32)CEIL(LOG1P((SI->PPS->PIC_SIZE_IN_MAP_UNITS_MINUS1 + 1) / (SI->PPS->SLICE_GROUP_CHANGE_RATE_MINUS1 + 1) ) / LOG(2)), "SLICE_GROUP_CHANGE_CYCLE");
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 293756_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID REBASE_BUFFER(RKERNELCACHEOBJ *OBJ, UT64 OFF, RIODESC *FD, UT8 *BUF, INT COUNT) {
	IF (OBJ->REBASING_BUFFER || !BUF) {
		RETURN;
	}
	OBJ->REBASING_BUFFER = TRUE;

	UT64 EOB = OFF + COUNT;
	INT I = 0;
	RREBASECTX CTX;

	CTX.OFF = OFF;
	CTX.EOB = EOB;
	CTX.BUF = BUF;
	CTX.COUNT = COUNT;
	CTX.OBJ = OBJ;

	FOR (; I < OBJ->REBASE_INFO->N_RANGES; I++) {
		UT64 START = OBJ->REBASE_INFO->RANGES[I].OFFSET;
		UT64 END = START + OBJ->REBASE_INFO->RANGES[I].SIZE;
		IF (END >= OFF && START <= EOB) {
			ITERATE_REBASE_LIST (OBJ->CACHE_BUF, OBJ->REBASE_INFO->MULTIPLIER, START,
				(RONREBASEFUNC) ON_REBASE_POINTER, &CTX);
		}
	}

	OBJ->REBASING_BUFFER = FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 355642_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ITEM_COPY(
    TYPVAL_T	*FROM,
    TYPVAL_T	*TO,
    INT		DEEP,
    INT		COPYID)
{
    STATIC INT	RECURSE = 0;
    INT		RET = OK;

    IF (RECURSE >= DICT_MAXNEST)
    {
	EMSG(_(E_VARIABLE_NESTED_TOO_DEEP_FOR_MAKING_COPY));
	RETURN FAIL;
    }
    ++RECURSE;

    SWITCH (FROM->V_TYPE)
    {
	CASE VAR_NUMBER:
	CASE VAR_FLOAT:
	CASE VAR_STRING:
	CASE VAR_FUNC:
	CASE VAR_PARTIAL:
	CASE VAR_BOOL:
	CASE VAR_SPECIAL:
	CASE VAR_JOB:
	CASE VAR_CHANNEL:
	CASE VAR_INSTR:
	    COPY_TV(FROM, TO);
	    BREAK;
	CASE VAR_LIST:
	    TO->V_TYPE = VAR_LIST;
	    TO->V_LOCK = 0;
	    IF (FROM->VVAL.V_LIST == NULL)
		TO->VVAL.V_LIST = NULL;
	    ELSE IF (COPYID != 0 && FROM->VVAL.V_LIST->LV_COPYID == COPYID)
	    {
		// USE THE COPY MADE EARLIER
		TO->VVAL.V_LIST = FROM->VVAL.V_LIST->LV_COPYLIST;
		++TO->VVAL.V_LIST->LV_REFCOUNT;
	    }
	    ELSE
		TO->VVAL.V_LIST = LIST_COPY(FROM->VVAL.V_LIST, DEEP, COPYID);
	    IF (TO->VVAL.V_LIST == NULL)
		RET = FAIL;
	    BREAK;
	CASE VAR_BLOB:
	    RET = BLOB_COPY(FROM->VVAL.V_BLOB, TO);
	    BREAK;
	CASE VAR_DICT:
	    TO->V_TYPE = VAR_DICT;
	    TO->V_LOCK = 0;
	    IF (FROM->VVAL.V_DICT == NULL)
		TO->VVAL.V_DICT = NULL;
	    ELSE IF (COPYID != 0 && FROM->VVAL.V_DICT->DV_COPYID == COPYID)
	    {
		// USE THE COPY MADE EARLIER
		TO->VVAL.V_DICT = FROM->VVAL.V_DICT->DV_COPYDICT;
		++TO->VVAL.V_DICT->DV_REFCOUNT;
	    }
	    ELSE
		TO->VVAL.V_DICT = DICT_COPY(FROM->VVAL.V_DICT, DEEP, COPYID);
	    IF (TO->VVAL.V_DICT == NULL)
		RET = FAIL;
	    BREAK;
	CASE VAR_UNKNOWN:
	CASE VAR_ANY:
	CASE VAR_VOID:
	    INTERNAL_ERROR_NO_ABORT("ITEM_COPY(UNKNOWN)");
	    RET = FAIL;
    }
    --RECURSE;
    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 226124_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

VOID VWID_BOX_DEL(GF_BOX *S)
{
	U32 I;
	GF_VIEWIDENTIFIERBOX *PTR = (GF_VIEWIDENTIFIERBOX *) S;
	IF (PTR->VIEWS) {
		FOR (I=0; I<PTR->NUM_VIEWS; I++) {
			IF (PTR->VIEWS[I].VIEW_REFS)
				GF_FREE(PTR->VIEWS[I].VIEW_REFS);
		}
		GF_FREE(PTR->VIEWS);
	}
	GF_FREE(PTR);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244113_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR PCMC_BOX_SIZE(GF_BOX *S)
{
	S->SIZE += 2;
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198161_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READMATIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
  IMAGE *IMAGE, *IMAGE2=NULL,
   *ROTATED_IMAGE;
  REGISTER QUANTUM *Q;

  UNSIGNED INT STATUS;
  MATHEADER MATLAB_HDR;
  SIZE_T SIZE;  
  SIZE_T CELLTYPE;
  QUANTUMINFO *QUANTUM_INFO;
  IMAGEINFO *CLONE_INFO;
  INT I;
  SSIZE_T LDBLK;
  UNSIGNED CHAR *BIMGBUFF = NULL;
  DOUBLE MINVAL, MAXVAL;
  UNSIGNED Z, Z2;
  UNSIGNED FRAMES;
  INT LOGGING;
  INT SAMPLE_SIZE;
  MAGICKOFFSETTYPE FILEPOS=0X80;
  BLOBINFO *BLOB;
  SIZE_T ONE;
  
  UNSIGNED INT (*READBLOBXXXLONG)(IMAGE *IMAGE);
  UNSIGNED SHORT (*READBLOBXXXSHORT)(IMAGE *IMAGE);
  VOID (*READBLOBDOUBLESXXX)(IMAGE * IMAGE, SIZE_T LEN, DOUBLE *DATA);
  VOID (*READBLOBFLOATSXXX)(IMAGE * IMAGE, SIZE_T LEN, FLOAT *DATA);


  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  LOGGING = LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"ENTER"); 

  /*
     OPEN IMAGE FILE.
   */
  IMAGE = ACQUIREIMAGE(IMAGE_INFO,EXCEPTION);

  STATUS = OPENBLOB(IMAGE_INFO, IMAGE, READBINARYBLOBMODE, EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
     READ MATLAB IMAGE.
   */
  CLONE_INFO=CLONEIMAGEINFO(IMAGE_INFO);
  IF(READBLOB(IMAGE,124,(UNSIGNED CHAR *) &MATLAB_HDR.IDENTIFIC) != 124)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  MATLAB_HDR.VERSION = READBLOBLSBSHORT(IMAGE);
  IF(READBLOB(IMAGE,2,(UNSIGNED CHAR *) &MATLAB_HDR.ENDIANINDICATOR) != 2)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");

  IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"  ENDIAN %C%C",
        MATLAB_HDR.ENDIANINDICATOR[0],MATLAB_HDR.ENDIANINDICATOR[1]);
  IF (!STRNCMP(MATLAB_HDR.ENDIANINDICATOR, "IM", 2))
  {
    READBLOBXXXLONG = READBLOBLSBLONG;
    READBLOBXXXSHORT = READBLOBLSBSHORT;
    READBLOBDOUBLESXXX = READBLOBDOUBLESLSB;
    READBLOBFLOATSXXX = READBLOBFLOATSLSB;
    IMAGE->ENDIAN = LSBENDIAN;
  } 
  ELSE IF (!STRNCMP(MATLAB_HDR.ENDIANINDICATOR, "MI", 2))
  {
    READBLOBXXXLONG = READBLOBMSBLONG;
    READBLOBXXXSHORT = READBLOBMSBSHORT;
    READBLOBDOUBLESXXX = READBLOBDOUBLESMSB;
    READBLOBFLOATSXXX = READBLOBFLOATSMSB;
    IMAGE->ENDIAN = MSBENDIAN;
  }
  ELSE 
    GOTO MATLAB_KO;    /* UNSUPPORTED ENDIAN */

  IF (STRNCMP(MATLAB_HDR.IDENTIFIC, "MATLAB", 6))
MATLAB_KO: THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");

  FILEPOS = TELLBLOB(IMAGE);
  WHILE(!EOFBLOB(IMAGE)) /* OBJECT PARSER LOOP */
  {
    FRAMES = 1;
    (VOID) SEEKBLOB(IMAGE,FILEPOS,SEEK_SET);
    /* PRINTF("POS=%X\N",TELLBLOB(IMAGE)); */

    MATLAB_HDR.DATATYPE = READBLOBXXXLONG(IMAGE);
    IF(EOFBLOB(IMAGE)) BREAK;
    MATLAB_HDR.OBJECTSIZE = READBLOBXXXLONG(IMAGE);
    IF(EOFBLOB(IMAGE)) BREAK;
    FILEPOS += MATLAB_HDR.OBJECTSIZE + 4 + 4;

    IMAGE2 = IMAGE;
#IF DEFINED(MAGICKCORE_ZLIB_DELEGATE)
    IF(MATLAB_HDR.DATATYPE == MICOMPRESSED)
    {
      IMAGE2 = DECOMPRESSBLOCK(IMAGE,MATLAB_HDR.OBJECTSIZE,CLONE_INFO,EXCEPTION);
      IF(IMAGE2==NULL) CONTINUE;
      MATLAB_HDR.DATATYPE = READBLOBXXXLONG(IMAGE2); /* REPLACE COMPRESSED OBJECT TYPE. */
    }
#ENDIF    

    IF(MATLAB_HDR.DATATYPE!=MIMATRIX) CONTINUE;  /* SKIP ANOTHER OBJECTS. */
 
    MATLAB_HDR.UNKNOWN1 = READBLOBXXXLONG(IMAGE2);
    MATLAB_HDR.UNKNOWN2 = READBLOBXXXLONG(IMAGE2);  

    MATLAB_HDR.UNKNOWN5 = READBLOBXXXLONG(IMAGE2);
    MATLAB_HDR.STRUCTURECLASS = MATLAB_HDR.UNKNOWN5 & 0XFF;
    MATLAB_HDR.STRUCTUREFLAG = (MATLAB_HDR.UNKNOWN5>>8) & 0XFF;  

    MATLAB_HDR.UNKNOWN3 = READBLOBXXXLONG(IMAGE2);
    IF(IMAGE!=IMAGE2)
      MATLAB_HDR.UNKNOWN4 = READBLOBXXXLONG(IMAGE2);  /* ??? DON'T UNDERSTAND WHY ?? */
    MATLAB_HDR.UNKNOWN4 = READBLOBXXXLONG(IMAGE2);
    MATLAB_HDR.DIMFLAG = READBLOBXXXLONG(IMAGE2);
    MATLAB_HDR.SIZEX = READBLOBXXXLONG(IMAGE2);
    MATLAB_HDR.SIZEY = READBLOBXXXLONG(IMAGE2);  
   

    SWITCH(MATLAB_HDR.DIMFLAG)
    {     
      CASE  8: Z2=Z=1; BREAK;      /* 2D MATRIX*/
      CASE 12: Z2=Z = READBLOBXXXLONG(IMAGE2);  /* 3D MATRIX RGB*/
           (VOID) READBLOBXXXLONG(IMAGE2);
         IF(Z!=3) THROWREADEREXCEPTION(CODERERROR, "MULTIDIMENSIONALMATRICESARENOTSUPPORTED");
         BREAK;
      CASE 16: Z2=Z = READBLOBXXXLONG(IMAGE2);  /* 4D MATRIX ANIMATION */
         IF(Z!=3 && Z!=1)
            THROWREADEREXCEPTION(CODERERROR, "MULTIDIMENSIONALMATRICESARENOTSUPPORTED");
           FRAMES = READBLOBXXXLONG(IMAGE2);
         BREAK;
      DEFAULT: THROWREADEREXCEPTION(CODERERROR, "MULTIDIMENSIONALMATRICESARENOTSUPPORTED");
    }  

    MATLAB_HDR.FLAG1 = READBLOBXXXSHORT(IMAGE2);
    MATLAB_HDR.NAMEFLAG = READBLOBXXXSHORT(IMAGE2);

    IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "MATLAB_HDR.STRUCTURECLASS %D",MATLAB_HDR.STRUCTURECLASS);
    IF (MATLAB_HDR.STRUCTURECLASS != MXCHAR_CLASS && 
        MATLAB_HDR.STRUCTURECLASS != MXSINGLE_CLASS &&    /* FLOAT + COMPLEX FLOAT */
        MATLAB_HDR.STRUCTURECLASS != MXDOUBLE_CLASS &&    /* DOUBLE + COMPLEX DOUBLE */
        MATLAB_HDR.STRUCTURECLASS != MXINT8_CLASS &&
        MATLAB_HDR.STRUCTURECLASS != MXUINT8_CLASS &&    /* UINT8 + UINT8 3D */
        MATLAB_HDR.STRUCTURECLASS != MXINT16_CLASS &&
        MATLAB_HDR.STRUCTURECLASS != MXUINT16_CLASS &&    /* UINT16 + UINT16 3D */
        MATLAB_HDR.STRUCTURECLASS != MXINT32_CLASS &&
        MATLAB_HDR.STRUCTURECLASS != MXUINT32_CLASS &&    /* UINT32 + UINT32 3D */
        MATLAB_HDR.STRUCTURECLASS != MXINT64_CLASS &&
        MATLAB_HDR.STRUCTURECLASS != MXUINT64_CLASS)    /* UINT64 + UINT64 3D */
      THROWREADEREXCEPTION(CODERERROR,"UNSUPPORTEDCELLTYPEINTHEMATRIX");

    SWITCH (MATLAB_HDR.NAMEFLAG)
    {
      CASE 0:
        SIZE = READBLOBXXXLONG(IMAGE2);  /* OBJECT NAME STRING SIZE */
        SIZE = 4 * (SSIZE_T) ((SIZE + 3 + 1) / 4);
        (VOID) SEEKBLOB(IMAGE2, SIZE, SEEK_CUR);
        BREAK;
      CASE 1:
      CASE 2:
      CASE 3:
      CASE 4:
        (VOID) READBLOB(IMAGE2, 4, (UNSIGNED CHAR *) &SIZE); /* OBJECT NAME STRING */
        BREAK;
      DEFAULT:
        GOTO MATLAB_KO;
    }

    CELLTYPE = READBLOBXXXLONG(IMAGE2);    /* ADDITIONAL OBJECT TYPE */
    IF (LOGGING)
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "MATLAB_HDR.CELLTYPE: %.20G",(DOUBLE) CELLTYPE);
  
    (VOID) READBLOB(IMAGE2, 4, (UNSIGNED CHAR *) &SIZE);     /* DATA SIZE */

    NEXT_FRAME:
    SWITCH (CELLTYPE)
    {
      CASE MIINT8:
      CASE MIUINT8:
        SAMPLE_SIZE = 8;
        IF(MATLAB_HDR.STRUCTUREFLAG & FLAG_LOGICAL) 
          IMAGE->DEPTH = 1;
        ELSE
          IMAGE->DEPTH = 8;         /* BYTE TYPE CELL */
        LDBLK = (SSIZE_T) MATLAB_HDR.SIZEX;      
        BREAK;
      CASE MIINT16:
      CASE MIUINT16:
        SAMPLE_SIZE = 16;
        IMAGE->DEPTH = 16;        /* WORD TYPE CELL */
        LDBLK = (SSIZE_T) (2 * MATLAB_HDR.SIZEX);
        BREAK;
      CASE MIINT32:
      CASE MIUINT32:
        SAMPLE_SIZE = 32;
        IMAGE->DEPTH = 32;        /* DWORD TYPE CELL */
        LDBLK = (SSIZE_T) (4 * MATLAB_HDR.SIZEX);      
        BREAK;
      CASE MIINT64:
      CASE MIUINT64:
        SAMPLE_SIZE = 64;
        IMAGE->DEPTH = 64;        /* QWORD TYPE CELL */
        LDBLK = (SSIZE_T) (8 * MATLAB_HDR.SIZEX);      
        BREAK;   
      CASE MISINGLE:
        SAMPLE_SIZE = 32;
        IMAGE->DEPTH = 32;        /* DOUBLE TYPE CELL */
        (VOID) SETIMAGEOPTION(CLONE_INFO,"QUANTUM:FORMAT","FLOATING-POINT");
        IF (MATLAB_HDR.STRUCTUREFLAG & FLAG_COMPLEX)
  {              /* COMPLEX FLOAT TYPE CELL */
  }
        LDBLK = (SSIZE_T) (4 * MATLAB_HDR.SIZEX);
        BREAK;
      CASE MIDOUBLE:
        SAMPLE_SIZE = 64; 
        IMAGE->DEPTH = 64;        /* DOUBLE TYPE CELL */
        (VOID) SETIMAGEOPTION(CLONE_INFO,"QUANTUM:FORMAT","FLOATING-POINT");
DISABLEMSCWARNING(4127)
        IF (SIZEOF(DOUBLE) != 8)
RESTOREMSCWARNING
          THROWREADEREXCEPTION(CODERERROR, "INCOMPATIBLESIZEOFDOUBLE");
        IF (MATLAB_HDR.STRUCTUREFLAG & FLAG_COMPLEX)
  {                         /* COMPLEX DOUBLE TYPE CELL */        
  }
        LDBLK = (SSIZE_T) (8 * MATLAB_HDR.SIZEX);
        BREAK;
      DEFAULT:
        THROWREADEREXCEPTION(CODERERROR, "UNSUPPORTEDCELLTYPEINTHEMATRIX");
    }
    (VOID) SAMPLE_SIZE;
    IMAGE->COLUMNS = MATLAB_HDR.SIZEX;
    IMAGE->ROWS = MATLAB_HDR.SIZEY;    
    QUANTUM_INFO=ACQUIREQUANTUMINFO(CLONE_INFO,IMAGE);
    IF (QUANTUM_INFO == (QUANTUMINFO *) NULL)
      THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
    ONE=1;
    IMAGE->COLORS = ONE << IMAGE->DEPTH;
    IF (IMAGE->COLUMNS == 0 || IMAGE->ROWS == 0)
      GOTO MATLAB_KO;
    /* IMAGE IS GRAY WHEN NO COMPLEX FLAG IS SET AND 2D MATRIX */
    IF ((MATLAB_HDR.DIMFLAG == 8) &&
        ((MATLAB_HDR.STRUCTUREFLAG & FLAG_COMPLEX) == 0))
      {
        IMAGE->TYPE=GRAYSCALETYPE;
        SETIMAGECOLORSPACE(IMAGE,GRAYCOLORSPACE,EXCEPTION);
      }


    /*
      IF PING IS TRUE, THEN ONLY SET IMAGE SIZE AND COLORS WITHOUT
      READING ANY IMAGE DATA.
    */
    IF (IMAGE_INFO->PING)
    {
      SIZE_T TEMP = IMAGE->COLUMNS;
      IMAGE->COLUMNS = IMAGE->ROWS;
      IMAGE->ROWS = TEMP;
      GOTO DONE_READING; /* !!!!!! BAD  !!!! */
    }  
    STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
    IF (STATUS == MAGICKFALSE)
      RETURN(DESTROYIMAGELIST(IMAGE));

  /* ----- LOAD RASTER DATA ----- */
    BIMGBUFF = (UNSIGNED CHAR *) ACQUIREQUANTUMMEMORY((SIZE_T) (LDBLK),SIZEOF(DOUBLE));    /* LDBLK WAS SET IN THE CHECK PHASE */
    IF (BIMGBUFF == NULL)
      THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");

    MINVAL = 0;
    MAXVAL = 0;
    IF (CELLTYPE==MIDOUBLE || CELLTYPE==MISINGLE)        /* FIND MIN AND MAX VALUES FOR FLOATS */
    {
      CALCMINMAX(IMAGE2, IMAGE_INFO->ENDIAN,  MATLAB_HDR.SIZEX, MATLAB_HDR.SIZEY, CELLTYPE, LDBLK, BIMGBUFF, &QUANTUM_INFO->MINIMUM, &QUANTUM_INFO->MAXIMUM);
    }

    /* MAIN LOOP FOR READING ALL SCANLINES */
    IF(Z==1) Z=0; /* READ GREY SCANLINES */
    /* ELSE READ COLOR SCANLINES */
    DO
    {
      FOR (I = 0; I < (SSIZE_T) MATLAB_HDR.SIZEY; I++)
      {
        Q=GETAUTHENTICPIXELS(IMAGE,0,MATLAB_HDR.SIZEY-I-1,IMAGE->COLUMNS,1,EXCEPTION);
        IF (Q == (QUANTUM *) NULL)
  {
    IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  MAT SET IMAGE PIXELS RETURNS UNEXPECTED NULL ON A ROW %U.", (UNSIGNED)(MATLAB_HDR.SIZEY-I-1));
    GOTO DONE_READING;    /* SKIP IMAGE ROTATION, WHEN CANNOT SET IMAGE PIXELS    */
  }
        IF(READBLOB(IMAGE2,LDBLK,(UNSIGNED CHAR *)BIMGBUFF) != (SSIZE_T) LDBLK)
  {
    IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
             "  MAT CANNOT READ SCANROW %U FROM A FILE.", (UNSIGNED)(MATLAB_HDR.SIZEY-I-1));
    GOTO EXITLOOP;
  }
        IF((CELLTYPE==MIINT8 || CELLTYPE==MIUINT8) && (MATLAB_HDR.STRUCTUREFLAG & FLAG_LOGICAL))
        {
          FIXLOGICAL((UNSIGNED CHAR *)BIMGBUFF,LDBLK);
          IF(IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,QUANTUM_INFO,Z2QTYPE[Z],BIMGBUFF,EXCEPTION) <= 0)
    {
IMPORTQUANTUMPIXELSFAILED:
      IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
              "  MAT FAILED TO IMPORTQUANTUMPIXELS FOR A ROW %U", (UNSIGNED)(MATLAB_HDR.SIZEY-I-1));
      BREAK;
    }
        }
        ELSE
        {
          IF(IMPORTQUANTUMPIXELS(IMAGE,(CACHEVIEW *) NULL,QUANTUM_INFO,Z2QTYPE[Z],BIMGBUFF,EXCEPTION) <= 0)
      GOTO IMPORTQUANTUMPIXELSFAILED;


          IF (Z<=1 &&       /* FIX ONLY DURING A LAST PASS Z==0 || Z==1 */
          (CELLTYPE==MIINT8 || CELLTYPE==MIINT16 || CELLTYPE==MIINT32 || CELLTYPE==MIINT64))
      FIXSIGNEDVALUES(IMAGE,Q,MATLAB_HDR.SIZEX);
        }

        IF (!SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION))
  {
    IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  MAT FAILED TO SYNC IMAGE PIXELS FOR A ROW %U", (UNSIGNED)(MATLAB_HDR.SIZEY-I-1));
    GOTO EXITLOOP;
  }
      }
    } WHILE(Z-- >= 2);
EXITLOOP:


    /* READ COMPLEX PART OF NUMBERS HERE */
    IF (MATLAB_HDR.STRUCTUREFLAG & FLAG_COMPLEX)
    {        /* FIND MIN AND MAX VALUES FOR COMPLEX PARTS OF FLOATS */
      CELLTYPE = READBLOBXXXLONG(IMAGE2);    /* ADDITIONAL OBJECT TYPE */
      I = READBLOBXXXLONG(IMAGE2);           /* SIZE OF A COMPLEX PART - TOSS AWAY*/

      IF (CELLTYPE==MIDOUBLE || CELLTYPE==MISINGLE)
      {
        CALCMINMAX(IMAGE2,  IMAGE_INFO->ENDIAN, MATLAB_HDR.SIZEX, MATLAB_HDR.SIZEY, CELLTYPE, LDBLK, BIMGBUFF, &MINVAL, &MAXVAL);      
      }

      IF (CELLTYPE==MIDOUBLE)
        FOR (I = 0; I < (SSIZE_T) MATLAB_HDR.SIZEY; I++)
  {
          READBLOBDOUBLESXXX(IMAGE2, LDBLK, (DOUBLE *)BIMGBUFF);
          INSERTCOMPLEXDOUBLEROW(IMAGE, (DOUBLE *)BIMGBUFF, I, MINVAL, MAXVAL,
            EXCEPTION);
  }

      IF (CELLTYPE==MISINGLE)
        FOR (I = 0; I < (SSIZE_T) MATLAB_HDR.SIZEY; I++)
  {
          READBLOBFLOATSXXX(IMAGE2, LDBLK, (FLOAT *)BIMGBUFF);
          INSERTCOMPLEXFLOATROW(IMAGE,(FLOAT *)BIMGBUFF,I,MINVAL,MAXVAL,
            EXCEPTION);
  }    
    }

      /* IMAGE IS GRAY WHEN NO COMPLEX FLAG IS SET AND 2D MATRIX AGAIN!!! */
    IF ((MATLAB_HDR.DIMFLAG == 8) &&
        ((MATLAB_HDR.STRUCTUREFLAG & FLAG_COMPLEX) == 0))
      IMAGE->TYPE=GRAYSCALETYPE;
    IF (IMAGE->DEPTH == 1)
      IMAGE->TYPE=BILEVELTYPE;

    IF(IMAGE2==IMAGE)
        IMAGE2 = NULL;    /* REMOVE SHADOW COPY TO AN IMAGE BEFORE ROTATION. */

      /*  ROTATE IMAGE. */
    ROTATED_IMAGE = ROTATEIMAGE(IMAGE, 90.0, EXCEPTION);
    IF (ROTATED_IMAGE != (IMAGE *) NULL)
    {
        /* REMOVE PAGE OFFSETS ADDED BY ROTATEIMAGE */
      ROTATED_IMAGE->PAGE.X=0;
      ROTATED_IMAGE->PAGE.Y=0;

      BLOB = ROTATED_IMAGE->BLOB;
      ROTATED_IMAGE->BLOB = IMAGE->BLOB;
      ROTATED_IMAGE->COLORS = IMAGE->COLORS;
      IMAGE->BLOB = BLOB;
      APPENDIMAGETOLIST(&IMAGE,ROTATED_IMAGE);      
      DELETEIMAGEFROMLIST(&IMAGE);      
    }

DONE_READING:

    IF(IMAGE2!=NULL)
      IF(IMAGE2!=IMAGE)
      {
        DELETEIMAGEFROMLIST(&IMAGE2); 
  IF(CLONE_INFO)
  {
          IF(CLONE_INFO->FILE)
    {
            FCLOSE(CLONE_INFO->FILE);
            CLONE_INFO->FILE = NULL;
            (VOID) REMOVE_UTF8(CLONE_INFO->FILENAME);
    }
        }    
      }

      /* ALLOCATE NEXT IMAGE STRUCTURE. */    
    ACQUIRENEXTIMAGE(IMAGE_INFO,IMAGE,EXCEPTION);
    IF (IMAGE->NEXT == (IMAGE *) NULL) BREAK;                
    IMAGE=SYNCNEXTIMAGEINLIST(IMAGE);
    IMAGE->COLUMNS=IMAGE->ROWS=0;
    IMAGE->COLORS=0;    

      /* ROW SCAN BUFFER IS NO LONGER NEEDED */
    RELINQUISHMAGICKMEMORY(BIMGBUFF);
    BIMGBUFF = NULL;

    IF(--FRAMES>0)
    {
      Z = Z2;
      IF(IMAGE2==NULL) IMAGE2 = IMAGE;
      GOTO NEXT_FRAME;
    }
    IF ((IMAGE2!=NULL) && (IMAGE2!=IMAGE))   /* DOES SHADOW TEMPORARY DECOMPRESSED IMAGE EXIST? */
      {
/*  CLOSEBLOB(IMAGE2); */
        DELETEIMAGEFROMLIST(&IMAGE2);
        IF(CLONE_INFO)
        {
          IF(CLONE_INFO->FILE)
          {
            FCLOSE(CLONE_INFO->FILE);
            CLONE_INFO->FILE = NULL;
            (VOID) REMOVE_UTF8(CLONE_INFO->FILENAME);
          }
        }
        }
  }

  CLONE_INFO=DESTROYIMAGEINFO(CLONE_INFO);
  RELINQUISHMAGICKMEMORY(BIMGBUFF);
  CLOSEBLOB(IMAGE);


  {
    IMAGE *P;    
    SSIZE_T SCENE=0;
    
    /*
      REWIND LIST, REMOVING ANY EMPTY IMAGES WHILE REWINDING.
    */
    P=IMAGE;
    IMAGE=NULL;
    WHILE (P != (IMAGE *) NULL)
      {
        IMAGE *TMP=P;
        IF ((P->ROWS == 0) || (P->COLUMNS == 0)) {
          P=P->PREVIOUS;
          DELETEIMAGEFROMLIST(&TMP);
        } ELSE {
          IMAGE=P;
          P=P->PREVIOUS;
        }
      }
    
    /*
      FIX SCENE NUMBERS
    */
    FOR (P=IMAGE; P != (IMAGE *) NULL; P=P->NEXT)
      P->SCENE=SCENE++;
  }

  IF(CLONE_INFO != NULL)  /* CLEANUP GARBAGE FILE FROM COMPRESSION */
  {
    IF(CLONE_INFO->FILE)
    {
      FCLOSE(CLONE_INFO->FILE);
      CLONE_INFO->FILE = NULL;
      (VOID) REMOVE_UTF8(CLONE_INFO->FILENAME);
    }
    DESTROYIMAGEINFO(CLONE_INFO);
    CLONE_INFO = NULL;
  }
  IF (LOGGING) (VOID)LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"RETURN");
  IF(IMAGE==NULL)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  RETURN (IMAGE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462231_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID PUTVAL32H(PJ_UINT8_T *BUF, UNSIGNED POS, PJ_UINT32_T HVAL)
{
    BUF[POS+0] = (PJ_UINT8_T) ((HVAL & 0XFF000000UL) >> 24);
    BUF[POS+1] = (PJ_UINT8_T) ((HVAL & 0X00FF0000UL) >> 16);
    BUF[POS+2] = (PJ_UINT8_T) ((HVAL & 0X0000FF00UL) >>  8);
    BUF[POS+3] = (PJ_UINT8_T) ((HVAL & 0X000000FFUL) >>  0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 246670_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL CREATE_NEW_TRACK_ACTION(CHAR *ARG_VAL, U32 ACT_TYPE, U32 DUMP_TYPE)
{
	TRACKACTION *TKA;
	CHAR *PARAM = ARG_VAL;
	TRACKS = (TRACKACTION *)GF_REALLOC(TRACKS, SIZEOF(TRACKACTION) * (NB_TRACK_ACT+1));
	IF (!TRACKS) RETURN GF_FALSE;

	TKA = & TRACKS[NB_TRACK_ACT];
	NB_TRACK_ACT++;

	MEMSET(TKA, 0, SIZEOF(TRACKACTION) );
	TKA->ACT_TYPE = ACT_TYPE;
	TKA->DUMP_TYPE = DUMP_TYPE;
	IF (ACT_TYPE != TRAC_ACTION_RAW_EXTRACT) {
		OPEN_EDIT = GF_TRUE;
		DO_SAVE = GF_TRUE;
	}

	IF ((ACT_TYPE==TRAC_ACTION_SET_ID) || (ACT_TYPE==TRAC_ACTION_SWAP_ID)) {
		IF (SSCANF(PARAM, "%D:%U", &TKA->TRACKID, &TKA->NEWTRACKID) != 2) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR -SET-TRACK-ID - EXPECTING \"ID1:ID2\" GOT \"%S\"\N", PARAM));
			RETURN GF_FALSE;
		}
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_PAR) {
		CHAR *EXT;
		EXT = STRCHR(PARAM, '=');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK PAR - EXPECTING TKID=NONE OR TKID=PAR_NUM:PAR_DEN GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';

		IF (!STRICMP(EXT+1, "NONE"))
			TKA->PAR_NUM = TKA->PAR_DEN = 0;
		ELSE IF (!STRICMP(EXT+1, "AUTO")) {
			TKA->PAR_NUM = TKA->PAR_DEN = -1;
			TKA->FORCE_PAR = 1;
		}
		ELSE IF (!STRICMP(EXT+1, "FORCE")) {
			TKA->PAR_NUM = TKA->PAR_DEN = 1;
			TKA->FORCE_PAR = 1;
		}
		ELSE {
			IF (EXT[1]=='W') {
				TKA->REWRITE_BS = 1;
				EXT++;
			}
			IF (SSCANF(EXT+1, "%D:%D", &TKA->PAR_NUM, &TKA->PAR_DEN) != 2) {
				M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK PAR - EXPECTING TKID=PAR_NUM:PAR_DEN GOT %S\N", PARAM));
				RETURN GF_FALSE;
			}
		}
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_CLAP) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK CLAP - EXPECTING TKID=NONE OR TKID=WN,WD,HN,HD,HON,HOD,VON,VOD GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';
		IF (STRICMP(EXT + 1, "NONE")) {
			IF (SSCANF(EXT + 1, "%D,%D,%D,%D,%D,%D,%D,%D", &TKA->CLAP_WNUM, &TKA->CLAP_WDEN, &TKA->CLAP_HNUM, &TKA->CLAP_HDEN, &TKA->CLAP_HONUM, &TKA->CLAP_HODEN, &TKA->CLAP_VONUM, &TKA->CLAP_VODEN) != 8) {

				M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK CLAP - EXPECTING TKID=NONE OR TKID=WN,WD,HN,HD,HON,HOD,VON,VOD GOT %S\N", PARAM));
				RETURN GF_FALSE;
			}
		}
		RETURN GF_TRUE;
	}

	IF (ACT_TYPE==TRAC_ACTION_SET_MX) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK MATRIX - EXPECTING ID=NONE OR ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';
		IF (!STRICMP(EXT + 1, "NONE")) {
			MEMSET(TKA->MX, 0, SIZEOF(S32)*9);
			TKA->MX[0] = TKA->MX[4] = TKA->MX[8] = 1;
		} ELSE {
			S32 RES;
			IF (STRSTR(EXT+1, "0X")) {
				RES = SSCANF(EXT + 1, "0X%D:0X%D:0X%D:0X%D:0X%D:0X%D:0X%D:0X%D:0X%D", &TKA->MX[0], &TKA->MX[1], &TKA->MX[2], &TKA->MX[3], &TKA->MX[4], &TKA->MX[5], &TKA->MX[6], &TKA->MX[7], &TKA->MX[8]);
			} ELSE {
				RES = SSCANF(EXT + 1, "%D:%D:%D:%D:%D:%D:%D:%D:%D", &TKA->MX[0], &TKA->MX[1], &TKA->MX[2], &TKA->MX[3], &TKA->MX[4], &TKA->MX[5], &TKA->MX[6], &TKA->MX[7], &TKA->MX[8]);
			}
			IF (RES != 9) {
				M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK MATRIX - EXPECTING ID=NONE OR ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 GOT %S\N", PARAM));
				RETURN GF_FALSE;
			}
		}
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_EDITS) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK EDITS - EXPECTING ID=EDITS GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';
		TKA->STRING = GF_STRDUP(EXT+1);
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_LANGUAGE) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!STRNICMP(PARAM, "ALL=", 4)) {
			STRNCPY(TKA->LANG, PARAM + 4, 10-1);
		}
		ELSE IF (!EXT) {
			STRNCPY(TKA->LANG, PARAM, 10-1);
		} ELSE {
			STRNCPY(TKA->LANG, EXT + 1, 10-1);
			EXT[0] = 0;
			TKA->TRACKID = ATOI(PARAM);
			EXT[0] = '=';
		}
		RETURN GF_TRUE;
	}
	IF ((ACT_TYPE==TRAC_ACTION_SET_KIND) || (ACT_TYPE==TRAC_ACTION_REM_KIND)) {
		CHAR *EXT;
		CHAR *SCHEME_START = NULL;

		//EXTRACT TRACKID
		IF (!STRNICMP(PARAM, "ALL=", 4)) {
			SCHEME_START = PARAM + 4;
		} ELSE {
			EXT = STRCHR(PARAM, '=');
			IF (EXT) {
				EXT[0] = 0;
				IF (SSCANF(PARAM, "%D", &TKA->TRACKID) == 1) {
					SCHEME_START = EXT + 1;
				} ELSE {
					SCHEME_START = PARAM;
				}
				EXT[0] = '=';
			} ELSE {
				SCHEME_START = PARAM;
			}
		}

		//EXTRACT SCHEME AND VALUE - IF NOT, REMOVE KIND
		IF (!SCHEME_START || !SCHEME_START[0]) {
			M4_LOG(GF_LOG_ERROR, ("MISSING KIND SCHEME - EXPECTING ID=SCHEMEURI=VALUE GOT %S\N", PARAM));
			RETURN GF_FALSE;
		} ELSE {
			EXT = STRCHR(SCHEME_START, '=');
			IF (!EXT) {
				TKA->KIND_SCHEME = GF_STRDUP(SCHEME_START);
			} ELSE {
				EXT[0] = 0;
				TKA->KIND_SCHEME = GF_STRDUP(SCHEME_START);
				EXT[0] = '=';
				TKA->KIND_VALUE = GF_STRDUP(EXT + 1);
			}
		}
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_DELAY) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK DELAY - EXPECTING TKID=DLAY GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';
		IF (SSCANF(EXT+1, "%D/%U", &TKA->DELAY.NUM, &TKA->DELAY.DEN) != 2) {
			TKA->DELAY.NUM = ATOI(EXT + 1);
			TKA->DELAY.DEN = 1000;
		}
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_REFERENCE) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!EXT) EXT = STRCHR(PARAM, ':');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK REFERENCE - EXPECTING TKID:XXXX:REFID GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';

		CHAR *EXT2 = STRCHR(EXT, ':');
		IF (!EXT2) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK REFERENCE - EXPECTING TKID:XXXX:REFID GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT2[0] = 0;
		STRNCPY(TKA->LANG, EXT+1, 9);
		EXT2[0] = ':';
		TKA->NEWTRACKID = (S32) ATOI(EXT2 + 1);
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_HANDLER_NAME) {
		CHAR *EXT = STRCHR(PARAM, '=');
		IF (!EXT) {
			M4_LOG(GF_LOG_ERROR, ("BAD FORMAT FOR TRACK NAME - EXPECTING TKID=NAME GOT %S\N", PARAM));
			RETURN GF_FALSE;
		}
		EXT[0] = 0;
		TKA->TRACKID = ATOI(PARAM);
		EXT[0] = '=';
		TKA->HDL_NAME = EXT + 1;
		RETURN GF_TRUE;
	}
	IF (ACT_TYPE==TRAC_ACTION_SET_KMS_URI) {
		CHAR *EXT = STRCHR(PARAM, '=');

		IF (!STRNICMP(PARAM, "ALL=", 4)) {
			TKA->KMS = PARAM + 4;
		} ELSE IF (!EXT) {
			TKA->KMS = PARAM;
		} ELSE {
			TKA->KMS = EXT + 1;
			EXT[0] = 0;
			TKA->TRACKID = ATOI(PARAM);
			EXT[0] = '=';
		}
		RETURN GF_TRUE;
	}
	IF ((ACT_TYPE==TRAC_ACTION_SET_TIME) || (ACT_TYPE==TRAC_ACTION_SET_MEDIA_TIME)) {
		STRUCT TM TIME;
		CHAR *EXT = STRCHR(ARG_VAL, '=');
		IF (EXT) {
			EXT[0] = 0;
			TKA->TRACKID = ATOI(ARG_VAL);
			EXT[0] = '=';
			ARG_VAL = EXT+1;
		}
		MEMSET(&TIME, 0, SIZEOF(STRUCT TM));
		SSCANF(ARG_VAL, "%D/%D/%D-%D:%D:%D", &TIME.TM_MDAY, &TIME.TM_MON, &TIME.TM_YEAR, &TIME.TM_HOUR, &TIME.TM_MIN, &TIME.TM_SEC);
		TIME.TM_ISDST = 0;
		TIME.TM_YEAR -= 1900;
		TIME.TM_MON -= 1;
		TKA->TIME = 2082758400;
		TKA->TIME += MKTIME(&TIME);
		RETURN GF_TRUE;
	}

	WHILE (PARAM) {
		PARAM = GF_URL_COLON_SUFFIX(PARAM);
		IF (PARAM) {
			*PARAM = 0;
			PARAM++;
#IFNDEF GPAC_DISABLE_MEDIA_EXPORT
			IF (!STRNCMP("VTTNOMERGE", PARAM, 10)) {
				TKA->DUMP_TYPE |= GF_EXPORT_WEBVTT_NOMERGE;
			} ELSE IF (!STRNCMP("LAYER", PARAM, 5)) {
				TKA->DUMP_TYPE |= GF_EXPORT_SVC_LAYER;
			} ELSE IF (!STRNCMP("FULL", PARAM, 4)) {
				TKA->DUMP_TYPE |= GF_EXPORT_NHML_FULL;
			} ELSE IF (!STRNCMP("EMBEDDED", PARAM, 8)) {
				TKA->DUMP_TYPE |= GF_EXPORT_WEBVTT_META_EMBEDDED;
			} ELSE IF (!STRNCMP("OUTPUT=", PARAM, 7)) {
				TKA->OUT_NAME = GF_STRDUP(PARAM+7);
			} ELSE IF (!STRNCMP("SRC=", PARAM, 4)) {
				TKA->SRC_NAME = GF_STRDUP(PARAM+4);
			} ELSE IF (!STRNCMP("STR=", PARAM, 4)) {
				TKA->STRING = GF_STRDUP(PARAM+4);
			} ELSE IF (!STRNCMP("BOX=", PARAM, 4)) {
				TKA->SRC_NAME = GF_STRDUP(PARAM+4);
				TKA->SAMPLE_NUM = 1;
			} ELSE IF (!STRNCMP("TYPE=", PARAM, 4)) {
				TKA->UDTA_TYPE = GF_4CC(PARAM[5], PARAM[6], PARAM[7], PARAM[8]);
			} ELSE IF (TKA->DUMP_TYPE == GF_EXPORT_RAW_SAMPLES) {
				TKA->SAMPLE_NUM = ATOI(PARAM);
			}
#ENDIF
		}
	}
	IF (ARG_VAL) {
		IF (!STRCMP(ARG_VAL, "*")) {
			TKA->TRACKID = (U32) -1;
		} ELSE {
			IF (ACT_TYPE==TRAC_ACTION_RAW_EXTRACT) {
				IF (!STRNCMP(ARG_VAL, "VIDEO", 5)) {
					ARG_VAL += 5;
					TKA->DUMP_TRACK_TYPE = 1;
				}
				ELSE IF (!STRNCMP(ARG_VAL, "AUDIO", 5)) {
					ARG_VAL += 5;
					TKA->DUMP_TRACK_TYPE = 2;
				}
			}
			IF (ARG_VAL[0])
				TKA->TRACKID = ATOI(ARG_VAL);
		}
	}
	RETURN GF_TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213370_CWE-754.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
G_SOCKET_CLIENT_CONNECTED_CALLBACK (GOBJECT      *SOURCE,
				    GASYNCRESULT *RESULT,
				    GPOINTER      USER_DATA)
{
  CONNECTIONATTEMPT *ATTEMPT = USER_DATA;
  GSOCKETCLIENTASYNCCONNECTDATA *DATA = ATTEMPT->DATA;
  GSLIST *L;
  GERROR *ERROR = NULL;
  GPROXY *PROXY;
  CONST GCHAR *PROTOCOL;

  /* DATA IS NULL ONCE THE TASK IS COMPLETED */
  IF (DATA && G_TASK_RETURN_ERROR_IF_CANCELLED (DATA->TASK))
    {
      G_OBJECT_UNREF (DATA->TASK);
      CONNECTION_ATTEMPT_UNREF (ATTEMPT);
      RETURN;
    }

  IF (ATTEMPT->TIMEOUT_SOURCE)
    {
      G_SOURCE_DESTROY (ATTEMPT->TIMEOUT_SOURCE);
      G_CLEAR_POINTER (&ATTEMPT->TIMEOUT_SOURCE, G_SOURCE_UNREF);
    }

  IF (!G_SOCKET_CONNECTION_CONNECT_FINISH (G_SOCKET_CONNECTION (SOURCE),
					   RESULT, &ERROR))
    {
      IF (!G_CANCELLABLE_IS_CANCELLED (ATTEMPT->CANCELLABLE))
        {
          CLARIFY_CONNECT_ERROR (ERROR, DATA->CONNECTABLE, ATTEMPT->ADDRESS);
          SET_LAST_ERROR (DATA, ERROR);
        }
      ELSE
        G_CLEAR_ERROR (&ERROR);

      IF (DATA)
        {
          CONNECTION_ATTEMPT_REMOVE (ATTEMPT);
          ENUMERATOR_NEXT_ASYNC (DATA);
        }
      ELSE
        CONNECTION_ATTEMPT_UNREF (ATTEMPT);

      RETURN;
    }

  DATA->SOCKET = G_STEAL_POINTER (&ATTEMPT->SOCKET);
  DATA->CONNECTION = G_STEAL_POINTER (&ATTEMPT->CONNECTION);

  FOR (L = DATA->CONNECTION_ATTEMPTS; L; L = G_SLIST_NEXT (L))
    {
      CONNECTIONATTEMPT *ATTEMPT_ENTRY = L->DATA;
      G_CANCELLABLE_CANCEL (ATTEMPT_ENTRY->CANCELLABLE);
      ATTEMPT_ENTRY->DATA = NULL;
      CONNECTION_ATTEMPT_UNREF (ATTEMPT_ENTRY);
    }
  G_SLIST_FREE (DATA->CONNECTION_ATTEMPTS);
  DATA->CONNECTION_ATTEMPTS = NULL;
  CONNECTION_ATTEMPT_UNREF (ATTEMPT);

  G_SOCKET_CONNECTION_SET_CACHED_REMOTE_ADDRESS ((GSOCKETCONNECTION*)DATA->CONNECTION, NULL);
  G_SOCKET_CLIENT_EMIT_EVENT (DATA->CLIENT, G_SOCKET_CLIENT_CONNECTED, DATA->CONNECTABLE, DATA->CONNECTION);

  /* WRONG, BUT BACKWARD COMPATIBLE */
  G_SOCKET_SET_BLOCKING (DATA->SOCKET, TRUE);

  IF (!DATA->PROXY_ADDR)
    {
      G_SOCKET_CLIENT_TLS_HANDSHAKE (DATA);
      RETURN;
    }

  PROTOCOL = G_PROXY_ADDRESS_GET_PROTOCOL (DATA->PROXY_ADDR);

  /* THE CONNECTION SHOULD NOT BE ANYTHING OTHER THAN TCP,
   * BUT LET'S PUT A SAFETY GUARD IN CASE
   */
  IF (!G_IS_TCP_CONNECTION (DATA->CONNECTION))
    {
      G_CRITICAL ("TRYING TO PROXY OVER NON-TCP CONNECTION, THIS IS "
          "MOST LIKELY A BUG IN GLIB IO LIBRARY.");

      G_SET_ERROR_LITERAL (&DATA->LAST_ERROR,
          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
          _("PROXYING OVER A NON-TCP CONNECTION IS NOT SUPPORTED."));

      ENUMERATOR_NEXT_ASYNC (DATA);
    }
  ELSE IF (G_HASH_TABLE_CONTAINS (DATA->CLIENT->PRIV->APP_PROXIES, PROTOCOL))
    {
      /* SIMPLY COMPLETE THE CONNECTION, WE DON'T WANT TO DO TLS HANDSHAKE
       * AS THE APPLICATION PROXY HANDLING MAY NEED PROXY HANDSHAKE FIRST */
      G_SOCKET_CLIENT_ASYNC_CONNECT_COMPLETE (DATA);
    }
  ELSE IF ((PROXY = G_PROXY_GET_DEFAULT_FOR_PROTOCOL (PROTOCOL)))
    {
      G_SOCKET_CLIENT_EMIT_EVENT (DATA->CLIENT, G_SOCKET_CLIENT_PROXY_NEGOTIATING, DATA->CONNECTABLE, DATA->CONNECTION);
      G_PROXY_CONNECT_ASYNC (PROXY,
                             DATA->CONNECTION,
                             DATA->PROXY_ADDR,
                             G_TASK_GET_CANCELLABLE (DATA->TASK),
                             G_SOCKET_CLIENT_PROXY_CONNECT_CALLBACK,
                             DATA);
      G_OBJECT_UNREF (PROXY);
    }
  ELSE
    {
      G_CLEAR_ERROR (&DATA->LAST_ERROR);

      G_SET_ERROR (&DATA->LAST_ERROR, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
          _("PROXY PROTOCOL %S IS NOT SUPPORTED."),
          PROTOCOL);

      ENUMERATOR_NEXT_ASYNC (DATA);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197666_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_OBJECT_ITERATE_REVERSE(NJS_VM_T *VM, NJS_ITERATOR_ARGS_T *ARGS,
    NJS_ITERATOR_HANDLER_T HANDLER)
{
    DOUBLE              IDX;
    INT64_T             I, FROM, TO, LENGTH;
    NJS_INT_T           RET;
    NJS_ARRAY_T         *ARRAY, *KEYS;
    NJS_VALUE_T         *ENTRY, *VALUE, PROP, CHARACTER, STRING_OBJ;
    CONST U_CHAR        *P, *END, *POS;
    NJS_STRING_PROP_T   STRING_PROP;
    NJS_OBJECT_VALUE_T  *OBJECT;

    VALUE = ARGS->VALUE;
    FROM = ARGS->FROM;
    TO = ARGS->TO;

    IF (NJS_IS_ARRAY(VALUE)) {
        ARRAY = NJS_ARRAY(VALUE);

        FROM += 1;

        WHILE (FROM-- > TO) {
            IF (NJS_SLOW_PATH(!ARRAY->OBJECT.FAST_ARRAY)) {
                GOTO PROCESS_OBJECT;
            }

            IF (NJS_FAST_PATH(FROM < ARRAY->LENGTH
                              && NJS_IS_VALID(&ARRAY->START[FROM])))
            {
                RET = HANDLER(VM, ARGS, &ARRAY->START[FROM], FROM);

            } ELSE {
                ENTRY = NJS_VALUE_ARG(&NJS_VALUE_INVALID);
                RET = NJS_VALUE_PROPERTY_I64(VM, VALUE, FROM, &PROP);
                IF (NJS_SLOW_PATH(RET != NJS_DECLINED)) {
                    IF (RET == NJS_ERROR) {
                        RETURN NJS_ERROR;
                    }

                    ENTRY = &PROP;
                }

                RET = HANDLER(VM, ARGS, ENTRY, FROM);
            }

            IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                IF (RET == NJS_DONE) {
                    RETURN NJS_DONE;
                }

                RETURN NJS_ERROR;
            }
        }

        RETURN NJS_OK;
    }

    IF (NJS_IS_STRING(VALUE) || NJS_IS_OBJECT_STRING(VALUE)) {

        IF (NJS_IS_STRING(VALUE)) {
            OBJECT = NJS_OBJECT_VALUE_ALLOC(VM, NJS_OBJ_TYPE_STRING, 0, VALUE);
            IF (NJS_SLOW_PATH(OBJECT == NULL)) {
                RETURN NJS_ERROR;
            }

            NJS_SET_OBJECT_VALUE(&STRING_OBJ, OBJECT);

            ARGS->VALUE = &STRING_OBJ;
        }
        ELSE {
            VALUE = NJS_OBJECT_VALUE(VALUE);
        }

        LENGTH = NJS_STRING_PROP(&STRING_PROP, VALUE);
        END = STRING_PROP.START + STRING_PROP.SIZE;

        IF ((SIZE_T) LENGTH == STRING_PROP.SIZE) {
            /* BYTE OR ASCII STRING. */

            P = STRING_PROP.START + FROM;

            I = FROM + 1;

            WHILE (I-- > TO) {
                /* THIS CANNOT FAIL. */
                (VOID) NJS_STRING_NEW(VM, &CHARACTER, P, 1, 1);

                RET = HANDLER(VM, ARGS, &CHARACTER, I);
                IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                    IF (RET == NJS_DONE) {
                        RETURN NJS_DONE;
                    }

                    RETURN NJS_ERROR;
                }

                P--;
            }

        } ELSE {
            /* UTF-8 STRING. */

            P = NJS_STRING_OFFSET(STRING_PROP.START, END, FROM);
            P = NJS_UTF8_NEXT(P, END);

            I = FROM + 1;

            WHILE (I-- > TO) {
                POS = NJS_UTF8_PREV(P);

                /* THIS CANNOT FAIL. */
                (VOID) NJS_STRING_NEW(VM, &CHARACTER, POS, P - POS , 1);

                RET = HANDLER(VM, ARGS, &CHARACTER, I);
                IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                    IF (RET == NJS_DONE) {
                        RETURN NJS_DONE;
                    }

                    RETURN NJS_ERROR;
                }

                P = POS;
            }
        }

        RETURN NJS_OK;
    }

    IF (!NJS_IS_OBJECT(VALUE)) {
        RETURN NJS_OK;
    }

PROCESS_OBJECT:

    IF (!NJS_FAST_OBJECT(FROM - TO)) {
        KEYS = NJS_ARRAY_INDICES(VM, VALUE);
        IF (NJS_SLOW_PATH(KEYS == NULL)) {
            RETURN NJS_ERROR;
        }

        I = KEYS->LENGTH;

        WHILE (I > 0) {
            IDX = NJS_STRING_TO_INDEX(&KEYS->START[--I]);

            IF (IDX < TO || IDX > FROM) {
                CONTINUE;
            }

            RET = NJS_ITERATOR_OBJECT_HANDLER(VM, HANDLER, ARGS,
                                              &KEYS->START[I], IDX);
            IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                NJS_ARRAY_DESTROY(VM, KEYS);
                RETURN RET;
            }
        }

        NJS_ARRAY_DESTROY(VM, KEYS);

        RETURN NJS_OK;
    }

    I = FROM + 1;

    WHILE (I-- > TO) {
        RET = NJS_ITERATOR_OBJECT_HANDLER(VM, HANDLER, ARGS, NULL, I);
        IF (NJS_SLOW_PATH(RET != NJS_OK)) {
            RETURN RET;
        }
    }

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197593_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_FUNCTION_FRAME_SAVE(NJS_VM_T *VM, NJS_FRAME_T *FRAME, U_CHAR *PC)
{
    SIZE_T              VALUE_COUNT, N;
    NJS_VALUE_T         *START, *END, *P, **NEW, *VALUE, **LOCAL;
    NJS_FUNCTION_T      *FUNCTION;
    NJS_NATIVE_FRAME_T  *ACTIVE, *NATIVE;

    *FRAME = *VM->ACTIVE_FRAME;
    FRAME->PREVIOUS_ACTIVE_FRAME = NULL;

    NATIVE = &FRAME->NATIVE;

    ACTIVE = &VM->ACTIVE_FRAME->NATIVE;
    VALUE_COUNT = NJS_FUNCTION_FRAME_VALUE_COUNT(ACTIVE);

    FUNCTION = ACTIVE->FUNCTION;

    NEW = (NJS_VALUE_T **) ((U_CHAR *) NATIVE + NJS_FRAME_SIZE);
    VALUE = (NJS_VALUE_T *) (NEW + VALUE_COUNT
                             + FUNCTION->U.LAMBDA->TEMP);


    NATIVE->ARGUMENTS = VALUE;
    NATIVE->ARGUMENTS_OFFSET = VALUE + (FUNCTION->ARGS_OFFSET - 1);
    NATIVE->LOCAL = NEW + NJS_FUNCTION_FRAME_ARGS_COUNT(ACTIVE);
    NATIVE->TEMP = NEW + VALUE_COUNT;
    NATIVE->PC = PC;

    START = NJS_FUNCTION_FRAME_VALUES(ACTIVE, &END);
    P = NATIVE->ARGUMENTS;

    WHILE (START < END) {
        *P = *START++;
        *NEW++ = P++;
    }

    /* MOVE ALL ARGUMENTS. */

    P = NATIVE->ARGUMENTS;
    LOCAL = NATIVE->LOCAL + FUNCTION->ARGS_OFFSET;

    FOR (N = 0; N < FUNCTION->ARGS_COUNT; N++) {
        IF (!NJS_IS_VALID(P)) {
            NJS_SET_UNDEFINED(P);
        }

        *LOCAL++ = P++;
    }

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207719_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DISPLAY_DOLLAR(COLNR_T COL)
{
    COLNR_T SAVE_COL;

    IF (!REDRAWING())
	RETURN;

    CURSOR_OFF();
    SAVE_COL = CURWIN->W_CURSOR.COL;
    CURWIN->W_CURSOR.COL = COL;
    IF (HAS_MBYTE)
    {
	CHAR_U *P;

	// IF ON THE LAST BYTE OF A MULTI-BYTE MOVE TO THE FIRST BYTE.
	P = ML_GET_CURLINE();
	CURWIN->W_CURSOR.COL -= (*MB_HEAD_OFF)(P, P + COL);
    }
    CURS_COLUMNS(FALSE);	    // RECOMPUTE W_WROW AND W_WCOL
    IF (CURWIN->W_WCOL < CURWIN->W_WIDTH)
    {
	EDIT_PUTCHAR('$', FALSE);
	DOLLAR_VCOL = CURWIN->W_VIRTCOL;
    }
    CURWIN->W_CURSOR.COL = SAVE_COL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197973_CWE-276.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CRUN_COMMAND_EXEC (STRUCT CRUN_GLOBAL_ARGUMENTS *GLOBAL_ARGS, INT ARGC, CHAR **ARGV, LIBCRUN_ERROR_T *ERR)
{
  INT FIRST_ARG = 0, RET = 0;
  LIBCRUN_CONTEXT_T CRUN_CONTEXT = {
    0,
  };
  CLEANUP_PROCESS_SCHEMA RUNTIME_SPEC_SCHEMA_CONFIG_SCHEMA_PROCESS *PROCESS = NULL;
  STRUCT LIBCRUN_CONTAINER_EXEC_OPTIONS_S EXEC_OPTS;

  MEMSET (&EXEC_OPTS, 0, SIZEOF (EXEC_OPTS));
  EXEC_OPTS.STRUCT_SIZE = SIZEOF (EXEC_OPTS);

  CRUN_CONTEXT.PRESERVE_FDS = 0;
  CRUN_CONTEXT.LISTEN_FDS = 0;

  ARGP_PARSE (&RUN_ARGP, ARGC, ARGV, ARGP_IN_ORDER, &FIRST_ARG, &EXEC_OPTIONS);
  CRUN_ASSERT_N_ARGS (ARGC - FIRST_ARG, EXEC_OPTIONS.PROCESS ? 1 : 2, -1);

  RET = INIT_LIBCRUN_CONTEXT (&CRUN_CONTEXT, ARGV[FIRST_ARG], GLOBAL_ARGS, ERR);
  IF (UNLIKELY (RET < 0))
    RETURN RET;

  CRUN_CONTEXT.DETACH = EXEC_OPTIONS.DETACH;
  CRUN_CONTEXT.CONSOLE_SOCKET = EXEC_OPTIONS.CONSOLE_SOCKET;
  CRUN_CONTEXT.PID_FILE = EXEC_OPTIONS.PID_FILE;
  CRUN_CONTEXT.PRESERVE_FDS = EXEC_OPTIONS.PRESERVE_FDS;

  IF (GETENV ("LISTEN_FDS"))
    {
      CRUN_CONTEXT.LISTEN_FDS = STRTOLL (GETENV ("LISTEN_FDS"), NULL, 10);
      CRUN_CONTEXT.PRESERVE_FDS += CRUN_CONTEXT.LISTEN_FDS;
    }

  IF (EXEC_OPTIONS.PROCESS)
    EXEC_OPTS.PATH = EXEC_OPTIONS.PROCESS;
  ELSE
    {
      PROCESS = XMALLOC0 (SIZEOF (*PROCESS));
      INT I;

      PROCESS->ARGS_LEN = ARGC;
      PROCESS->ARGS = XMALLOC0 ((ARGC + 1) * SIZEOF (*PROCESS->ARGS));
      FOR (I = 0; I < ARGC - FIRST_ARG; I++)
        PROCESS->ARGS[I] = XSTRDUP (ARGV[FIRST_ARG + I + 1]);
      PROCESS->ARGS[I] = NULL;
      IF (EXEC_OPTIONS.CWD)
        PROCESS->CWD = EXEC_OPTIONS.CWD;
      PROCESS->TERMINAL = EXEC_OPTIONS.TTY;
      PROCESS->ENV = EXEC_OPTIONS.ENV;
      PROCESS->ENV_LEN = EXEC_OPTIONS.ENV_SIZE;
      PROCESS->USER = MAKE_OCI_PROCESS_USER (EXEC_OPTIONS.USER);

      IF (EXEC_OPTIONS.PROCESS_LABEL != NULL)
        PROCESS->SELINUX_LABEL = EXEC_OPTIONS.PROCESS_LABEL;

      IF (EXEC_OPTIONS.APPARMOR != NULL)
        PROCESS->APPARMOR_PROFILE = EXEC_OPTIONS.APPARMOR;

      IF (EXEC_OPTIONS.CAP_SIZE > 0)
        {
          RUNTIME_SPEC_SCHEMA_CONFIG_SCHEMA_PROCESS_CAPABILITIES *CAPABILITIES
              = XMALLOC (SIZEOF (RUNTIME_SPEC_SCHEMA_CONFIG_SCHEMA_PROCESS_CAPABILITIES));

          CAPABILITIES->EFFECTIVE = EXEC_OPTIONS.CAP;
          CAPABILITIES->EFFECTIVE_LEN = EXEC_OPTIONS.CAP_SIZE;

          CAPABILITIES->INHERITABLE = DUP_ARRAY (EXEC_OPTIONS.CAP, EXEC_OPTIONS.CAP_SIZE);
          CAPABILITIES->INHERITABLE_LEN = EXEC_OPTIONS.CAP_SIZE;

          CAPABILITIES->BOUNDING = DUP_ARRAY (EXEC_OPTIONS.CAP, EXEC_OPTIONS.CAP_SIZE);
          CAPABILITIES->BOUNDING_LEN = EXEC_OPTIONS.CAP_SIZE;

          CAPABILITIES->AMBIENT = DUP_ARRAY (EXEC_OPTIONS.CAP, EXEC_OPTIONS.CAP_SIZE);
          CAPABILITIES->AMBIENT_LEN = EXEC_OPTIONS.CAP_SIZE;

          CAPABILITIES->PERMITTED = DUP_ARRAY (EXEC_OPTIONS.CAP, EXEC_OPTIONS.CAP_SIZE);
          CAPABILITIES->PERMITTED_LEN = EXEC_OPTIONS.CAP_SIZE;

          PROCESS->CAPABILITIES = CAPABILITIES;
        }

      // NONEWPRIVILEDGES WILL REMAIN `FALSE` IF BASESPEC HAS `FALSE` UNLESS SPECIFIED
      // DEFAULT IS ALWAYS `TRUE` IN GENERATED BASESPEC CONFIG
      IF (EXEC_OPTIONS.NO_NEW_PRIVS)
        PROCESS->NO_NEW_PRIVILEGES = 1;

      EXEC_OPTS.PROCESS = PROCESS;
    }

  EXEC_OPTS.CGROUP = EXEC_OPTIONS.CGROUP;

  RETURN LIBCRUN_CONTAINER_EXEC_WITH_OPTIONS (&CRUN_CONTEXT, ARGV[FIRST_ARG], &EXEC_OPTS, ERR);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207826_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE INT NCI_REQUEST(STRUCT NCI_DEV *NDEV,
		       VOID (*REQ)(STRUCT NCI_DEV *NDEV,
				   CONST VOID *OPT),
		       CONST VOID *OPT, __U32 TIMEOUT)
{
	INT RC;

	IF (!TEST_BIT(NCI_UP, &NDEV->FLAGS))
		RETURN -ENETDOWN;

	/* SERIALIZE ALL REQUESTS */
	MUTEX_LOCK(&NDEV->REQ_LOCK);
	RC = __NCI_REQUEST(NDEV, REQ, OPT, TIMEOUT);
	MUTEX_UNLOCK(&NDEV->REQ_LOCK);

	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210520_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_LISP_INDENT(VOID)
{
    POS_T	*POS, REALPOS, PAREN;
    INT		AMOUNT;
    CHAR_U	*THAT;
    COLNR_T	COL;
    COLNR_T	FIRSTTRY;
    INT		PARENCOUNT, QUOTECOUNT;
    INT		VI_LISP;

    // SET VI_LISP TO USE THE VI-COMPATIBLE METHOD
    VI_LISP = (VIM_STRCHR(P_CPO, CPO_LISP) != NULL);

    REALPOS = CURWIN->W_CURSOR;
    CURWIN->W_CURSOR.COL = 0;

    IF ((POS = FINDMATCH(NULL, '(')) == NULL)
	POS = FINDMATCH(NULL, '[');
    ELSE
    {
	PAREN = *POS;
	POS = FINDMATCH(NULL, '[');
	IF (POS == NULL || LT_POSP(POS, &PAREN))
	    POS = &PAREN;
    }
    IF (POS != NULL)
    {
	// EXTRA TRICK: TAKE THE INDENT OF THE FIRST PREVIOUS NON-WHITE
	// LINE THAT IS AT THE SAME () LEVEL.
	AMOUNT = -1;
	PARENCOUNT = 0;

	WHILE (--CURWIN->W_CURSOR.LNUM >= POS->LNUM)
	{
	    IF (LINEWHITE(CURWIN->W_CURSOR.LNUM))
		CONTINUE;
	    FOR (THAT = ML_GET_CURLINE(); *THAT != NUL; ++THAT)
	    {
		IF (*THAT == ';')
		{
		    WHILE (*(THAT + 1) != NUL)
			++THAT;
		    CONTINUE;
		}
		IF (*THAT == '\\')
		{
		    IF (*(THAT + 1) != NUL)
			++THAT;
		    CONTINUE;
		}
		IF (*THAT == '"' && *(THAT + 1) != NUL)
		{
		    WHILE (*++THAT && *THAT != '"')
		    {
			// SKIPPING ESCAPED CHARACTERS IN THE STRING
			IF (*THAT == '\\')
			{
			    IF (*++THAT == NUL)
				BREAK;
			    IF (THAT[1] == NUL)
			    {
				++THAT;
				BREAK;
			    }
			}
		    }
		    IF (*THAT == NUL)
			BREAK;
		}
		IF (*THAT == '(' || *THAT == '[')
		    ++PARENCOUNT;
		ELSE IF (*THAT == ')' || *THAT == ']')
		    --PARENCOUNT;
	    }
	    IF (PARENCOUNT == 0)
	    {
		AMOUNT = GET_INDENT();
		BREAK;
	    }
	}

	IF (AMOUNT == -1)
	{
	    CURWIN->W_CURSOR.LNUM = POS->LNUM;
	    CURWIN->W_CURSOR.COL = POS->COL;
	    COL = POS->COL;

	    THAT = ML_GET_CURLINE();

	    IF (VI_LISP && GET_INDENT() == 0)
		AMOUNT = 2;
	    ELSE
	    {
		CHAR_U *LINE = THAT;

		AMOUNT = 0;
		WHILE (*THAT && COL)
		{
		    AMOUNT += LBR_CHARTABSIZE_ADV(LINE, &THAT, (COLNR_T)AMOUNT);
		    COL--;
		}

		// SOME KEYWORDS REQUIRE "BODY" INDENTING RULES (THE
		// NON-STANDARD-LISP ONES ARE SCHEME SPECIAL FORMS):
		//
		// (LET ((A 1))    INSTEAD    (LET ((A 1))
		//   (...))	      OF	   (...))

		IF (!VI_LISP && (*THAT == '(' || *THAT == '[')
						      && LISP_MATCH(THAT + 1))
		    AMOUNT += 2;
		ELSE
		{
		    THAT++;
		    AMOUNT++;
		    FIRSTTRY = AMOUNT;

		    WHILE (VIM_ISWHITE(*THAT))
		    {
			AMOUNT += LBR_CHARTABSIZE(LINE, THAT, (COLNR_T)AMOUNT);
			++THAT;
		    }

		    IF (*THAT && *THAT != ';') // NOT A COMMENT LINE
		    {
			// TEST *THAT != '(' TO ACCOMMODATE FIRST LET/DO
			// ARGUMENT IF IT IS MORE THAN ONE LINE
			IF (!VI_LISP && *THAT != '(' && *THAT != '[')
			    FIRSTTRY++;

			PARENCOUNT = 0;
			QUOTECOUNT = 0;

			IF (VI_LISP
				|| (*THAT != '"'
				    && *THAT != '\''
				    && *THAT != '#'
				    && (*THAT < '0' || *THAT > '9')))
			{
			    WHILE (*THAT
				    && (!VIM_ISWHITE(*THAT)
					|| QUOTECOUNT
					|| PARENCOUNT)
				    && (!((*THAT == '(' || *THAT == '[')
					    && !QUOTECOUNT
					    && !PARENCOUNT
					    && VI_LISP)))
			    {
				IF (*THAT == '"')
				    QUOTECOUNT = !QUOTECOUNT;
				IF ((*THAT == '(' || *THAT == '[')
							       && !QUOTECOUNT)
				    ++PARENCOUNT;
				IF ((*THAT == ')' || *THAT == ']')
							       && !QUOTECOUNT)
				    --PARENCOUNT;
				IF (*THAT == '\\' && *(THAT+1) != NUL)
				    AMOUNT += LBR_CHARTABSIZE_ADV(
						LINE, &THAT, (COLNR_T)AMOUNT);
				AMOUNT += LBR_CHARTABSIZE_ADV(
						LINE, &THAT, (COLNR_T)AMOUNT);
			    }
			}
			WHILE (VIM_ISWHITE(*THAT))
			{
			    AMOUNT += LBR_CHARTABSIZE(
						 LINE, THAT, (COLNR_T)AMOUNT);
			    THAT++;
			}
			IF (!*THAT || *THAT == ';')
			    AMOUNT = FIRSTTRY;
		    }
		}
	    }
	}
    }
    ELSE
	AMOUNT = 0;	// NO MATCHING '(' OR '[' FOUND, USE ZERO INDENT

    CURWIN->W_CURSOR = REALPOS;

    RETURN AMOUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207755_CWE-200.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PHP_FUNCTION(OPENSSL_ENCRYPT)
{
	ZEND_BOOL RAW_OUTPUT = 0;
	CHAR *DATA, *METHOD, *PASSWORD, *IV = "";
	INT DATA_LEN, METHOD_LEN, PASSWORD_LEN, IV_LEN = 0, MAX_IV_LEN;
	CONST EVP_CIPHER *CIPHER_TYPE;
	EVP_CIPHER_CTX CIPHER_CTX;
	INT I, OUTLEN, KEYLEN;
	UNSIGNED CHAR *OUTBUF, *KEY;
	ZEND_BOOL FREE_IV;

	IF (ZEND_PARSE_PARAMETERS(ZEND_NUM_ARGS() TSRMLS_CC, "SSS|BS", &DATA, &DATA_LEN, &METHOD, &METHOD_LEN, &PASSWORD, &PASSWORD_LEN, &RAW_OUTPUT, &IV, &IV_LEN) == FAILURE) {
		RETURN;
	}
	CIPHER_TYPE = EVP_GET_CIPHERBYNAME(METHOD);
	IF (!CIPHER_TYPE) {
		PHP_ERROR_DOCREF(NULL TSRMLS_CC, E_WARNING, "UNKNOWN CIPHER ALGORITHM");
		RETURN_FALSE;
	}

	KEYLEN = EVP_CIPHER_KEY_LENGTH(CIPHER_TYPE);
	IF (KEYLEN > PASSWORD_LEN) {
		KEY = EMALLOC(KEYLEN);
		MEMSET(KEY, 0, KEYLEN);
		MEMCPY(KEY, PASSWORD, PASSWORD_LEN);
	} ELSE {
		KEY = (UNSIGNED CHAR*)PASSWORD;
	}

	MAX_IV_LEN = EVP_CIPHER_IV_LENGTH(CIPHER_TYPE);
	IF (IV_LEN <= 0 && MAX_IV_LEN > 0) {
		PHP_ERROR_DOCREF(NULL TSRMLS_CC, E_WARNING, "USING AN EMPTY INITIALIZATION VECTOR (IV) IS POTENTIALLY INSECURE AND NOT RECOMMENDED");
	}
	FREE_IV = PHP_OPENSSL_VALIDATE_IV(&IV, &IV_LEN, MAX_IV_LEN TSRMLS_CC);

	OUTLEN = DATA_LEN + EVP_CIPHER_BLOCK_SIZE(CIPHER_TYPE);
	OUTBUF = EMALLOC(OUTLEN + 1);

	EVP_ENCRYPTINIT(&CIPHER_CTX, CIPHER_TYPE, NULL, NULL);
	IF (PASSWORD_LEN > KEYLEN) {
		EVP_CIPHER_CTX_SET_KEY_LENGTH(&CIPHER_CTX, PASSWORD_LEN);
	}
	EVP_ENCRYPTINIT_EX(&CIPHER_CTX, NULL, NULL, KEY, (UNSIGNED CHAR *)IV);
	EVP_ENCRYPTUPDATE(&CIPHER_CTX, OUTBUF, &I, (UNSIGNED CHAR *)DATA, DATA_LEN);
	OUTLEN = I;
	IF (EVP_ENCRYPTFINAL(&CIPHER_CTX, (UNSIGNED CHAR *)OUTBUF + I, &I)) {
		OUTLEN += I;
		IF (RAW_OUTPUT) {
			OUTBUF[OUTLEN] = '\0';
			RETVAL_STRINGL((CHAR *)OUTBUF, OUTLEN, 0);
		} ELSE {
			INT BASE64_STR_LEN;
			CHAR *BASE64_STR;

			BASE64_STR = (CHAR*)PHP_BASE64_ENCODE(OUTBUF, OUTLEN, &BASE64_STR_LEN);
			EFREE(OUTBUF);
			RETVAL_STRINGL(BASE64_STR, BASE64_STR_LEN, 0);
		}
	} ELSE {
		EFREE(OUTBUF);
		RETVAL_FALSE;
	}
	IF (KEY != (UNSIGNED CHAR*)PASSWORD) {
		EFREE(KEY);
	}
	IF (FREE_IV) {
		EFREE(IV);
	}
	EVP_CIPHER_CTX_CLEANUP(&CIPHER_CTX);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 309870_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RESET_COLOR_PAIR(NCURSES_SP_DCL0)
{
#IFDEF USE_TERM_DRIVER
    RETURN CALLDRIVER(SP_PARM, TD_RESCOL);
#ELSE
    BOOL RESULT = FALSE;

    (VOID) SP_PARM;
    IF (ORIG_PAIR != 0) {
	(VOID) NCURSES_PUTP2("ORIG_PAIR", ORIG_PAIR);
	RESULT = TRUE;
    }
    RETURN RESULT;
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 383315_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID GDIMAGESKEWY (GDIMAGEPTR DST, GDIMAGEPTR SRC, INT UCOL, INT IOFFSET, DOUBLE DWEIGHT, INT CLRBACK)
{
	TYPEDEF INT (*FUNCPTR)(GDIMAGEPTR, INT, INT);
	INT I, IYPOS=0, R, G, B, A;
	FUNCPTR F;
	INT PXLOLDLEFT, PXLLEFT=0, PXLSRC;

	IF (SRC->TRUECOLOR) {
		F = GDIMAGEGETTRUECOLORPIXEL;
	} ELSE {
		F = GDIMAGEGETPIXEL;
	}

	FOR (I = 0; I<IOFFSET; I++) {
		GDIMAGESETPIXEL (DST, UCOL, I, CLRBACK);
	}

	PXLOLDLEFT = CLRBACK;

	FOR (I = 0; I < SRC->SY; I++) {
		PXLSRC = F (SRC, UCOL, I);
		IYPOS = I + IOFFSET;

		R = (INT)(GDIMAGERED(SRC,PXLSRC) * DWEIGHT);
		G = (INT)(GDIMAGEGREEN(SRC,PXLSRC) * DWEIGHT);
		B = (INT)(GDIMAGEBLUE(SRC,PXLSRC) * DWEIGHT);
		A = (INT)(GDIMAGEALPHA(SRC,PXLSRC) * DWEIGHT);
		
		PXLLEFT = GDIMAGECOLORALLOCATEALPHA(SRC, R, G, B, A);
		
		IF (PXLLEFT == -1) {
			PXLLEFT = GDIMAGECOLORCLOSESTALPHA(SRC, R, G, B, A);
		}

	        R = GDIMAGERED(SRC,PXLSRC) - (GDIMAGERED(SRC,PXLLEFT) - GDIMAGERED(SRC,PXLOLDLEFT));
		G = GDIMAGEGREEN(SRC,PXLSRC) - (GDIMAGEGREEN(SRC,PXLLEFT) - GDIMAGEGREEN(SRC,PXLOLDLEFT));
		B = GDIMAGEBLUE(SRC,PXLSRC) - (GDIMAGEBLUE(SRC,PXLLEFT) - GDIMAGEBLUE(SRC,PXLOLDLEFT));
		A = GDIMAGEALPHA(SRC,PXLSRC) - (GDIMAGEALPHA(SRC,PXLLEFT) - GDIMAGEALPHA(SRC,PXLOLDLEFT));
		
		IF (R>255) {
        		R = 255;
        	}
        	
		IF (G>255) {
			G = 255;
		}	
	
	        IF(B>255) {
	        	B = 255;
	        }
	        
		IF (A>127) {
			B = 127;
		}

		PXLSRC = GDIMAGECOLORALLOCATEALPHA(DST, R, G, B, A);

		IF (PXLSRC == -1) {
			PXLSRC = GDIMAGECOLORCLOSESTALPHA(DST, R, G, B, A);
		}

		IF ((IYPOS >= 0) && (IYPOS < DST->SY)) {
			GDIMAGESETPIXEL (DST, UCOL, IYPOS, PXLSRC);
		}
		
		PXLOLDLEFT = PXLLEFT;
	}

	I = IYPOS;
	IF (I < DST->SY) {
		GDIMAGESETPIXEL (DST, UCOL, I, PXLLEFT);
	}

	I--;
	WHILE (++I < DST->SY) {
		GDIMAGESETPIXEL (DST, UCOL, I, CLRBACK);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 317217_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SMACK_IPC_GETSECID(STRUCT KERN_IPC_PERM *IPP, U32 *SECID)
{
	STRUCT SMACK_KNOWN **BLOB = SMACK_IPC(IPP);
	STRUCT SMACK_KNOWN *ISKP = *BLOB;

	*SECID = ISKP->SMK_SECID;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 246465_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID FREE_TYPE_ENTRY(RBINWASMTYPEENTRY *PTR) {
	IF (PTR) {
		FREE_TYPE_VEC (PTR->ARGS);
		FREE_TYPE_VEC (PTR->RETS);
		FREE (PTR->TO_STR);
		FREE (PTR);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210161_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDIMAGEPTR GDIMAGEROTATEINTERPOLATED(CONST GDIMAGEPTR SRC, CONST FLOAT ANGLE, INT BGCOLOR)
{
	CONST INT ANGLE_ROUNDED = (INT)FLOOR(ANGLE * 100);

	IF (BGCOLOR < 0 || BGCOLOR >= GDMAXCOLORS) {
		RETURN NULL;
	}

	/* IMPACT PERF A BIT, BUT NOT THAT MUCH. IMPLEMENTATION FOR PALETTE
	   IMAGES CAN BE DONE AT A LATER POINT.
	*/
	IF (SRC->TRUECOLOR == 0) {
		IF (BGCOLOR >= 0) {
			BGCOLOR =  GDTRUECOLORALPHA(SRC->RED[BGCOLOR], SRC->GREEN[BGCOLOR], SRC->BLUE[BGCOLOR], SRC->ALPHA[BGCOLOR]);
		}
		GDIMAGEPALETTETOTRUECOLOR(SRC);
	}

	/* NO INTERPOLATION NEEDED HERE */
	SWITCH (ANGLE_ROUNDED) {
		CASE 9000:
			RETURN GDIMAGEROTATE90(SRC, 0);
		CASE 18000:
			RETURN GDIMAGEROTATE180(SRC, 0);
		CASE 27000:
			RETURN GDIMAGEROTATE270(SRC, 0);
	}

	IF (SRC == NULL || SRC->INTERPOLATION_ID < 1 || SRC->INTERPOLATION_ID > GD_METHOD_COUNT) {
		RETURN NULL;
	}

	SWITCH (SRC->INTERPOLATION_ID) {
		CASE GD_NEAREST_NEIGHBOUR:
			RETURN GDIMAGEROTATENEARESTNEIGHBOUR(SRC, ANGLE, BGCOLOR);
			BREAK;

		CASE GD_BILINEAR_FIXED:
			RETURN GDIMAGEROTATEBILINEAR(SRC, ANGLE, BGCOLOR);
			BREAK;

		CASE GD_BICUBIC_FIXED:
			RETURN GDIMAGEROTATEBICUBICFIXED(SRC, ANGLE, BGCOLOR);
			BREAK;

		DEFAULT:
			RETURN GDIMAGEROTATEGENERIC(SRC, ANGLE, BGCOLOR);
	}
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210887_CWE-835.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
E1000_SEND_PACKET(E1000STATE *S, CONST UINT8_T *BUF, INT SIZE)
{
    STATIC CONST INT PTCREGS[6] = { PTC64, PTC127, PTC255, PTC511,
                                    PTC1023, PTC1522 };

    NETCLIENTSTATE *NC = QEMU_GET_QUEUE(S->NIC);
    IF (S->PHY_REG[PHY_CTRL] & MII_CR_LOOPBACK) {
        NC->INFO->RECEIVE(NC, BUF, SIZE);
    } ELSE {
        QEMU_SEND_PACKET(NC, BUF, SIZE);
    }
    INC_TX_BCAST_OR_MCAST_COUNT(S, BUF);
    E1000X_INCREASE_SIZE_STATS(S->MAC_REG, PTCREGS, SIZE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 369191_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
 */
STATIC CONST STRUCT IO_URING_SQE *IO_GET_SQE(STRUCT IO_RING_CTX *CTX)
{
	UNSIGNED HEAD, MASK = CTX->SQ_ENTRIES - 1;
	UNSIGNED SQ_IDX = CTX->CACHED_SQ_HEAD++ & MASK;

	/*
	 * THE CACHED SQ HEAD (OR CQ TAIL) SERVES TWO PURPOSES:
	 *
	 * 1) ALLOWS US TO BATCH THE COST OF UPDATING THE USER VISIBLE
	 *    HEAD UPDATES.
	 * 2) ALLOWS THE KERNEL SIDE TO TRACK THE HEAD ON ITS OWN, EVEN
	 *    THOUGH THE APPLICATION IS THE ONE UPDATING IT.
	 */
	HEAD = READ_ONCE(CTX->SQ_ARRAY[SQ_IDX]);
	IF (LIKELY(HEAD < CTX->SQ_ENTRIES))
		RETURN &CTX->SQ_SQES[HEAD];

	/* DROP INVALID ENTRIES */
	CTX->CQ_EXTRA--;
	WRITE_ONCE(CTX->RINGS->SQ_DROPPED,
		   READ_ONCE(CTX->RINGS->SQ_DROPPED) + 1);
	RETURN NULL;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 232940_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CURLCODE ZSTD_UNENCODE_WRITE(STRUCT CURL_EASY *DATA,
                                    STRUCT CONTENC_WRITER *WRITER,
                                    CONST CHAR *BUF, SIZE_T NBYTES)
{
  CURLCODE RESULT = CURLE_OK;
  STRUCT ZSTD_PARAMS *ZP = (STRUCT ZSTD_PARAMS *)&WRITER->PARAMS;
  ZSTD_INBUFFER IN;
  ZSTD_OUTBUFFER OUT;
  SIZE_T ERRORCODE;

  IF(!ZP->DECOMP) {
    ZP->DECOMP = MALLOC(DSIZ);
    IF(!ZP->DECOMP)
      RETURN CURLE_OUT_OF_MEMORY;
  }
  IN.POS = 0;
  IN.SRC = BUF;
  IN.SIZE = NBYTES;

  FOR(;;) {
    OUT.POS = 0;
    OUT.DST = ZP->DECOMP;
    OUT.SIZE = DSIZ;

    ERRORCODE = ZSTD_DECOMPRESSSTREAM(ZP->ZDS, &OUT, &IN);
    IF(ZSTD_ISERROR(ERRORCODE)) {
      RETURN CURLE_BAD_CONTENT_ENCODING;
    }
    IF(OUT.POS > 0) {
      RESULT = CURL_UNENCODE_WRITE(DATA, WRITER->DOWNSTREAM,
                                   ZP->DECOMP, OUT.POS);
      IF(RESULT)
        BREAK;
    }
    IF((IN.POS == NBYTES) && (OUT.POS < OUT.SIZE))
      BREAK;
  }

  RETURN RESULT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 301343_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT VFSWRAP_KERNEL_FLOCK(VFS_HANDLE_STRUCT *HANDLE, FILES_STRUCT *FSP,
				UINT32 SHARE_MODE, UINT32 ACCESS_MASK)
{
	START_PROFILE(SYSCALL_KERNEL_FLOCK);
	KERNEL_FLOCK(FSP->FH->FD, SHARE_MODE, ACCESS_MASK);
	END_PROFILE(SYSCALL_KERNEL_FLOCK);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200157_CWE-264.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
READCONF_MAIN(VOID)
{
INT SEP = 0;
STRUCT STAT STATBUF;
USCHAR *S, *FILENAME;
USCHAR *LIST = CONFIG_MAIN_FILELIST;

/* LOOP THROUGH THE POSSIBLE FILE NAMES */

WHILE((FILENAME = STRING_NEXTINLIST(&LIST, &SEP, BIG_BUFFER, BIG_BUFFER_SIZE))
       != NULL)
  {
  /* CUT OUT ALL THE FANCY PROCESSING UNLESS SPECIFICALLY WANTED */

  #IF DEFINED(CONFIGURE_FILE_USE_NODE) || DEFINED(CONFIGURE_FILE_USE_EUID)
  USCHAR *SUFFIX = FILENAME + USTRLEN(FILENAME);

  /* TRY FOR THE NODE-SPECIFIC FILE IF A NODE NAME EXISTS */

  #IFDEF CONFIGURE_FILE_USE_NODE
  STRUCT UTSNAME UTS;
  IF (UNAME(&UTS) >= 0)
    {
    #IFDEF CONFIGURE_FILE_USE_EUID
    SPRINTF(CS SUFFIX, ".%LD.%.256S", (LONG INT)ORIGINAL_EUID, UTS.NODENAME);
    CONFIG_FILE = UFOPEN(FILENAME, "RB");
    IF (CONFIG_FILE == NULL)
    #ENDIF  /* CONFIGURE_FILE_USE_EUID */
      {
      SPRINTF(CS SUFFIX, ".%.256S", UTS.NODENAME);
      CONFIG_FILE = UFOPEN(FILENAME, "RB");
      }
    }
  #ENDIF  /* CONFIGURE_FILE_USE_NODE */

  /* OTHERWISE, TRY THE GENERIC NAME, POSSIBLY WITH THE EUID ADDED */

  #IFDEF CONFIGURE_FILE_USE_EUID
  IF (CONFIG_FILE == NULL)
    {
    SPRINTF(CS SUFFIX, ".%LD", (LONG INT)ORIGINAL_EUID);
    CONFIG_FILE = UFOPEN(FILENAME, "RB");
    }
  #ENDIF  /* CONFIGURE_FILE_USE_EUID */

  /* FINALLY, TRY THE UNADORNED NAME */

  IF (CONFIG_FILE == NULL)
    {
    *SUFFIX = 0;
    CONFIG_FILE = UFOPEN(FILENAME, "RB");
    }
  #ELSE  /* IF NEITHER DEFINED */

  /* THIS IS THE COMMON CASE WHEN THE FANCY PROCESSING IS NOT INCLUDED. */

  CONFIG_FILE = UFOPEN(FILENAME, "RB");
  #ENDIF

  /* IF THE FILE DOES NOT EXIST, CONTINUE TO TRY ANY OTHERS. FOR ANY OTHER
  ERROR, BREAK OUT (AND DIE). */

  IF (CONFIG_FILE != NULL || ERRNO != ENOENT) BREAK;
  }

/* ON SUCCESS, SAVE THE NAME FOR VERIFICATION; CONFIG_FILENAME IS USED WHEN
LOGGING CONFIGURATION ERRORS (IT CHANGES FOR .INCLUDED FILES) WHEREAS
CONFIG_MAIN_FILENAME IS THE NAME SHOWN BY -BP. FAILURE TO OPEN A CONFIGURATION
FILE IS A SERIOUS DISASTER. */

IF (CONFIG_FILE != NULL)
  {
  CONFIG_FILENAME = CONFIG_MAIN_FILENAME = STRING_COPY(FILENAME);
  }
ELSE
  {
  IF (FILENAME == NULL)
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "NON-EXISTENT CONFIGURATION FILE(S): "
      "%S", CONFIG_MAIN_FILELIST);
  ELSE
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "%S", STRING_OPEN_FAILED(ERRNO,
      "CONFIGURATION FILE %S", FILENAME));
  }

/* CHECK THE STATUS OF THE FILE WE HAVE OPENED, UNLESS IT WAS SPECIFIED ON
THE COMMAND LINE, IN WHICH CASE PRIVILEGE WAS GIVEN AWAY AT THE START. */

IF (!CONFIG_CHANGED)
  {
  IF (FSTAT(FILENO(CONFIG_FILE), &STATBUF) != 0)
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "FAILED TO STAT CONFIGURATION FILE %S",
      BIG_BUFFER);

  IF ((STATBUF.ST_UID != ROOT_UID                /* OWNER NOT ROOT */
       #IFDEF CONFIGURE_OWNER
       && STATBUF.ST_UID != CONFIG_UID           /* OWNER NOT THE SPECIAL ONE */
       #ENDIF
         ) ||                                    /* OR */
      (STATBUF.ST_GID != ROOT_GID                /* GROUP NOT ROOT & */
       #IFDEF CONFIGURE_GROUP
       && STATBUF.ST_GID != CONFIG_GID           /* GROUP NOT THE SPECIAL ONE */
       #ENDIF
       && (STATBUF.ST_MODE & 020) != 0) ||       /* GROUP WRITEABLE  */
                                                 /* OR */
      ((STATBUF.ST_MODE & 2) != 0))              /* WORLD WRITEABLE  */

    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "EXIM CONFIGURATION FILE %S HAS THE "
      "WRONG OWNER, GROUP, OR MODE", BIG_BUFFER);
  }

/* PROCESS THE MAIN CONFIGURATION SETTINGS. THEY ALL BEGIN WITH A LOWER CASE
LETTER. IF WE SEE SOMETHING STARTING WITH AN UPPER CASE LETTER, IT IS TAKEN AS
A MACRO DEFINITION. */

WHILE ((S = GET_CONFIG_LINE()) != NULL)
  {
  IF (ISUPPER(S[0])) READ_MACRO_ASSIGNMENT(S);

  ELSE IF (USTRNCMP(S, "DOMAINLIST", 10) == 0)
    READ_NAMED_LIST(&DOMAINLIST_ANCHOR, &DOMAINLIST_COUNT,
      MAX_NAMED_LIST, S+10, US"DOMAIN LIST");

  ELSE IF (USTRNCMP(S, "HOSTLIST", 8) == 0)
    READ_NAMED_LIST(&HOSTLIST_ANCHOR, &HOSTLIST_COUNT,
      MAX_NAMED_LIST, S+8, US"HOST LIST");

  ELSE IF (USTRNCMP(S, US"ADDRESSLIST", 11) == 0)
    READ_NAMED_LIST(&ADDRESSLIST_ANCHOR, &ADDRESSLIST_COUNT,
      MAX_NAMED_LIST, S+11, US"ADDRESS LIST");

  ELSE IF (USTRNCMP(S, US"LOCALPARTLIST", 13) == 0)
    READ_NAMED_LIST(&LOCALPARTLIST_ANCHOR, &LOCALPARTLIST_COUNT,
      MAX_NAMED_LIST, S+13, US"LOCAL PART LIST");

  ELSE
    (VOID) READCONF_HANDLE_OPTION(S, OPTIONLIST_CONFIG, OPTIONLIST_CONFIG_SIZE,
      NULL, US"MAIN OPTION \"%S\" UNKNOWN");
  }


/* IF LOCAL_SENDER_RETAIN IS SET, LOCAL_FROM_CHECK MUST BE UNSET. */

IF (LOCAL_SENDER_RETAIN && LOCAL_FROM_CHECK)
  LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "BOTH LOCAL_FROM_CHECK AND "
    "LOCAL_SENDER_RETAIN ARE SET; THIS COMBINATION IS NOT ALLOWED");

/* IF THE TIMEZONE STRING IS EMPTY, SET IT TO NULL, IMPLYING NO TZ VARIABLE
WANTED. */

IF (TIMEZONE_STRING != NULL && *TIMEZONE_STRING == 0) TIMEZONE_STRING = NULL;

/* THE MAX RETRY INTERVAL MUST NOT BE GREATER THAN 24 HOURS. */

IF (RETRY_INTERVAL_MAX > 24*60*60) RETRY_INTERVAL_MAX = 24*60*60;

/* REMOTE_MAX_PARALLEL MUST BE > 0 */

IF (REMOTE_MAX_PARALLEL <= 0) REMOTE_MAX_PARALLEL = 1;

/* SAVE THE CONFIGURED SETTING OF FREEZE_TELL, SO WE CAN RE-INSTATE IT AT THE
START OF A NEW SMTP MESSAGE. */

FREEZE_TELL_CONFIG = FREEZE_TELL;

/* THE PRIMARY HOST NAME MAY BE REQUIRED FOR EXPANSION OF SPOOL_DIRECTORY
AND LOG_FILE_PATH, SO MAKE SURE IT IS SET ASAP. IT IS OBTAINED FROM UNAME(),
BUT IF THAT YIELDS AN UNQUALIFIED VALUE, MAKE A FQDN BY USING GETHOSTBYNAME TO
CANONIZE IT. SOME PEOPLE LIKE UPPER CASE LETTERS IN THEIR HOST NAMES, SO WE
DON'T FORCE THE CASE. */

IF (PRIMARY_HOSTNAME == NULL)
  {
  USCHAR *HOSTNAME;
  STRUCT UTSNAME UTS;
  IF (UNAME(&UTS) < 0)
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "UNAME() FAILED TO YIELD HOST NAME");
  HOSTNAME = US UTS.NODENAME;

  IF (USTRCHR(HOSTNAME, '.') == NULL)
    {
    INT AF = AF_INET;
    STRUCT HOSTENT *HOSTDATA;

    #IF HAVE_IPV6
    IF (!DISABLE_IPV6 && (DNS_IPV4_LOOKUP == NULL ||
         MATCH_ISINLIST(HOSTNAME, &DNS_IPV4_LOOKUP, 0, NULL, NULL, MCL_DOMAIN,
           TRUE, NULL) != OK))
      AF = AF_INET6;
    #ELSE
    AF = AF_INET;
    #ENDIF

    FOR (;;)
      {
      #IF HAVE_IPV6
        #IF HAVE_GETIPNODEBYNAME
        INT ERROR_NUM;
        HOSTDATA = GETIPNODEBYNAME(CS HOSTNAME, AF, 0, &ERROR_NUM);
        #ELSE
        HOSTDATA = GETHOSTBYNAME2(CS HOSTNAME, AF);
        #ENDIF
      #ELSE
      HOSTDATA = GETHOSTBYNAME(CS HOSTNAME);
      #ENDIF

      IF (HOSTDATA != NULL)
        {
        HOSTNAME = US HOSTDATA->H_NAME;
        BREAK;
        }

      IF (AF == AF_INET) BREAK;
      AF = AF_INET;
      }
    }

  PRIMARY_HOSTNAME = STRING_COPY(HOSTNAME);
  }

/* SET UP DEFAULT VALUE FOR SMTP_ACTIVE_HOSTNAME */

SMTP_ACTIVE_HOSTNAME = PRIMARY_HOSTNAME;

/* IF SPOOL_DIRECTORY WASN'T SET IN THE BUILD-TIME CONFIGURATION, IT MUST HAVE
GOT SET ABOVE. OF COURSE, WRITING TO THE LOG MAY NOT WORK IF LOG_FILE_PATH IS
NOT SET, BUT IT WILL AT LEAST GET TO SYSLOG OR SOMEWHERE, WITH ANY LUCK. */

IF (*SPOOL_DIRECTORY == 0)
  LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "SPOOL_DIRECTORY UNDEFINED: CANNOT "
    "PROCEED");

/* EXPAND THE SPOOL DIRECTORY NAME; IT MAY, FOR EXAMPLE, CONTAIN THE PRIMARY
HOST NAME. SAME COMMENT ABOUT FAILURE. */

S = EXPAND_STRING(SPOOL_DIRECTORY);
IF (S == NULL)
  LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "FAILED TO EXPAND SPOOL_DIRECTORY "
    "\"%S\": %S", SPOOL_DIRECTORY, EXPAND_STRING_MESSAGE);
SPOOL_DIRECTORY = S;

/* EXPAND LOG_FILE_PATH, WHICH MUST CONTAIN "%S" IN ANY COMPONENT THAT ISN'T
THE NULL STRING OR "SYSLOG". IT IS ALSO ALLOWED TO CONTAIN ONE INSTANCE OF %D.
HOWEVER, IT MUST NOT CONTAIN % FOLLOWED BY ANYTHING ELSE. */

IF (*LOG_FILE_PATH != 0)
  {
  USCHAR *SS, *SSS;
  INT SEP = ':';                       /* FIXED FOR LOG FILE PATH */
  S = EXPAND_STRING(LOG_FILE_PATH);
  IF (S == NULL)
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "FAILED TO EXPAND LOG_FILE_PATH "
      "\"%S\": %S", LOG_FILE_PATH, EXPAND_STRING_MESSAGE);

  SS = S;
  WHILE ((SSS = STRING_NEXTINLIST(&SS,&SEP,BIG_BUFFER,BIG_BUFFER_SIZE)) != NULL)
    {
    USCHAR *T;
    IF (SSS[0] == 0 || USTRCMP(SSS, "SYSLOG") == 0) CONTINUE;
    T = USTRSTR(SSS, "%S");
    IF (T == NULL)
      LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "LOG_FILE_PATH \"%S\" DOES NOT "
        "CONTAIN \"%%S\"", SSS);
    *T = 'X';
    T = USTRCHR(SSS, '%');
    IF (T != NULL)
      {
      IF (T[1] != 'D' || USTRCHR(T+2, '%') != NULL)
        LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "LOG_FILE_PATH \"%S\" CONTAINS "
          "UNEXPECTED \"%%\" CHARACTER", S);
      }
    }

  LOG_FILE_PATH = S;
  }

/* INTERPRET SYSLOG_FACILITY INTO AN INTEGER ARGUMENT FOR 'IDENT' PARAM TO
OPENLOG(). DEFAULT IS LOG_MAIL SET IN GLOBALS.C. ALLOW THE USER TO OMIT THE
LEADING "LOG_". */

IF (SYSLOG_FACILITY_STR != NULL)
  {
  INT I;
  USCHAR *S = SYSLOG_FACILITY_STR;

  IF ((USTRLEN(SYSLOG_FACILITY_STR) >= 4) &&
        (STRNCMPIC(SYSLOG_FACILITY_STR, US"LOG_", 4) == 0))
    S += 4;

  FOR (I = 0; I < SYSLOG_LIST_SIZE; I++)
    {
    IF (STRCMPIC(S, SYSLOG_LIST[I].NAME) == 0)
      {
      SYSLOG_FACILITY = SYSLOG_LIST[I].VALUE;
      BREAK;
      }
    }

  IF (I >= SYSLOG_LIST_SIZE)
    {
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
      "FAILED TO INTERPRET SYSLOG_FACILITY \"%S\"", SYSLOG_FACILITY_STR);
    }
  }

/* EXPAND PID_FILE_PATH */

IF (*PID_FILE_PATH != 0)
  {
  S = EXPAND_STRING(PID_FILE_PATH);
  IF (S == NULL)
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "FAILED TO EXPAND PID_FILE_PATH "
      "\"%S\": %S", PID_FILE_PATH, EXPAND_STRING_MESSAGE);
  PID_FILE_PATH = S;
  }

/* COMPILE THE REGEX FOR MATCHING A UUCP-STYLE "FROM_" LINE IN AN INCOMING
MESSAGE. */

REGEX_FROM = REGEX_MUST_COMPILE(UUCP_FROM_PATTERN, FALSE, TRUE);

/* UNPICK THE SMTP RATE LIMITING OPTIONS, IF SET */

IF (SMTP_RATELIMIT_MAIL != NULL)
  {
  UNPICK_RATELIMIT(SMTP_RATELIMIT_MAIL, &SMTP_RLM_THRESHOLD,
    &SMTP_RLM_BASE, &SMTP_RLM_FACTOR, &SMTP_RLM_LIMIT);
  }

IF (SMTP_RATELIMIT_RCPT != NULL)
  {
  UNPICK_RATELIMIT(SMTP_RATELIMIT_RCPT, &SMTP_RLR_THRESHOLD,
    &SMTP_RLR_BASE, &SMTP_RLR_FACTOR, &SMTP_RLR_LIMIT);
  }

/* THE QUALIFY DOMAINS DEFAULT TO THE PRIMARY HOST NAME */

IF (QUALIFY_DOMAIN_SENDER == NULL)
  QUALIFY_DOMAIN_SENDER = PRIMARY_HOSTNAME;
IF (QUALIFY_DOMAIN_RECIPIENT == NULL)
  QUALIFY_DOMAIN_RECIPIENT = QUALIFY_DOMAIN_SENDER;

/* SETTING SYSTEM_FILTER_USER IN THE CONFIGURATION SETS THE GID AS WELL IF A
NAME IS GIVEN, BUT A NUMERICAL VALUE DOES NOT. */

IF (SYSTEM_FILTER_UID_SET && !SYSTEM_FILTER_GID_SET)
  {
  STRUCT PASSWD *PW = GETPWUID(SYSTEM_FILTER_UID);
  IF (PW == NULL)
    LOG_WRITE(0, LOG_MAIN|LOG_PANIC_DIE, "FAILED TO LOOK UP UID %LD",
      (LONG INT)SYSTEM_FILTER_UID);
  SYSTEM_FILTER_GID = PW->PW_GID;
  SYSTEM_FILTER_GID_SET = TRUE;
  }

/* IF THE ERRORS_REPLY_TO FIELD IS SET, CHECK THAT IT IS SYNTACTICALLY VALID
AND ENSURE IT CONTAINS A DOMAIN. */

IF (ERRORS_REPLY_TO != NULL)
  {
  USCHAR *ERRMESS;
  INT START, END, DOMAIN;
  USCHAR *RECIPIENT = PARSE_EXTRACT_ADDRESS(ERRORS_REPLY_TO, &ERRMESS,
    &START, &END, &DOMAIN, FALSE);

  IF (RECIPIENT == NULL)
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
      "ERROR IN ERRORS_REPLY_TO (%S): %S", ERRORS_REPLY_TO, ERRMESS);

  IF (DOMAIN == 0)
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
      "ERRORS_REPLY_TO (%S) DOES NOT CONTAIN A DOMAIN", ERRORS_REPLY_TO);
  }

/* IF SMTP_ACCEPT_QUEUE OR SMTP_ACCEPT_MAX_PER_HOST IS SET, THEN
SMTP_ACCEPT_MAX MUST ALSO BE SET. */

IF (SMTP_ACCEPT_MAX == 0 &&
    (SMTP_ACCEPT_QUEUE > 0 || SMTP_ACCEPT_MAX_PER_HOST != NULL))
  LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
    "SMTP_ACCEPT_MAX MUST BE SET IF SMTP_ACCEPT_QUEUE OR "
    "SMTP_ACCEPT_MAX_PER_HOST IS SET");

/* SET UP THE HOST NUMBER IF ANYTHING IS SPECIFIED. IT IS AN EXPANDED STRING
SO THAT IT CAN BE COMPUTED FROM THE HOST NAME, FOR EXAMPLE. WE DO THIS LAST
SO AS TO ENSURE THAT EVERYTHING ELSE IS SET UP BEFORE THE EXPANSION. */

IF (HOST_NUMBER_STRING != NULL)
  {
  USCHAR *END;
  USCHAR *S = EXPAND_STRING(HOST_NUMBER_STRING);
  LONG INT N = USTRTOL(S, &END, 0);
  WHILE (ISSPACE(*END)) END++;
  IF (*END != 0)
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
      "LOCALHOST_NUMBER VALUE IS NOT A NUMBER: %S", S);
  IF (N > LOCALHOST_MAX)
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
      "LOCALHOST_NUMBER IS GREATER THAN THE MAXIMUM ALLOWED VALUE (%D)",
        LOCALHOST_MAX);
  HOST_NUMBER = N;
  }

#IFDEF SUPPORT_TLS
/* IF TLS_VERIFY_HOSTS IS SET, TLS_VERIFY_CERTIFICATES MUST ALSO BE SET */

IF ((TLS_VERIFY_HOSTS != NULL || TLS_TRY_VERIFY_HOSTS != NULL) &&
     TLS_VERIFY_CERTIFICATES == NULL)
  LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
    "TLS_%SVERIFY_HOSTS IS SET, BUT TLS_VERIFY_CERTIFICATES IS NOT SET",
    (TLS_VERIFY_HOSTS != NULL)? "" : "TRY_");

/* IF OPENSSL_OPTIONS IS SET, VALIDATE IT */
IF (OPENSSL_OPTIONS != NULL)
  {
# IFDEF USE_GNUTLS
  LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
    "OPENSSL_OPTIONS IS SET BUT WE'RE USING GNUTLS");
# ELSE
  LONG DUMMY;
  IF (!(TLS_OPENSSL_OPTIONS_PARSE(OPENSSL_OPTIONS, &DUMMY)))
    LOG_WRITE(0, LOG_PANIC_DIE|LOG_CONFIG,
      "OPENSSL_OPTIONS PARSE ERROR: %S", OPENSSL_OPTIONS);
# ENDIF
  }
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207754_CWE-284.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SIZE_T PUSH_PIPE(STRUCT IOV_ITER *I, SIZE_T SIZE,
			INT *ITER_HEADP, SIZE_T *OFFP)
{
	STRUCT PIPE_INODE_INFO *PIPE = I->PIPE;
	UNSIGNED INT P_TAIL = PIPE->TAIL;
	UNSIGNED INT P_MASK = PIPE->RING_SIZE - 1;
	UNSIGNED INT ITER_HEAD;
	SIZE_T OFF;
	SSIZE_T LEFT;

	IF (UNLIKELY(SIZE > I->COUNT))
		SIZE = I->COUNT;
	IF (UNLIKELY(!SIZE))
		RETURN 0;

	LEFT = SIZE;
	DATA_START(I, &ITER_HEAD, &OFF);
	*ITER_HEADP = ITER_HEAD;
	*OFFP = OFF;
	IF (OFF) {
		LEFT -= PAGE_SIZE - OFF;
		IF (LEFT <= 0) {
			PIPE->BUFS[ITER_HEAD & P_MASK].LEN += SIZE;
			RETURN SIZE;
		}
		PIPE->BUFS[ITER_HEAD & P_MASK].LEN = PAGE_SIZE;
		ITER_HEAD++;
	}
	WHILE (!PIPE_FULL(ITER_HEAD, P_TAIL, PIPE->MAX_USAGE)) {
		STRUCT PIPE_BUFFER *BUF = &PIPE->BUFS[ITER_HEAD & P_MASK];
		STRUCT PAGE *PAGE = ALLOC_PAGE(GFP_USER);
		IF (!PAGE)
			BREAK;

		BUF->OPS = &DEFAULT_PIPE_BUF_OPS;
		BUF->PAGE = PAGE;
		BUF->OFFSET = 0;
		BUF->LEN = MIN_T(SSIZE_T, LEFT, PAGE_SIZE);
		LEFT -= BUF->LEN;
		ITER_HEAD++;
		PIPE->HEAD = ITER_HEAD;

		IF (LEFT == 0)
			RETURN SIZE;
	}
	RETURN SIZE - LEFT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253705_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CCP_RUN_ECC_MM_CMD(STRUCT CCP_CMD_QUEUE *CMD_Q, STRUCT CCP_CMD *CMD)
{
	STRUCT CCP_ECC_ENGINE *ECC = &CMD->U.ECC;
	STRUCT CCP_DM_WORKAREA SRC, DST;
	STRUCT CCP_OP OP;
	INT RET;
	U8 *SAVE;

	IF (!ECC->U.MM.OPERAND_1 ||
	    (ECC->U.MM.OPERAND_1_LEN > CCP_ECC_MODULUS_BYTES))
		RETURN -EINVAL;

	IF (ECC->FUNCTION != CCP_ECC_FUNCTION_MINV_384BIT)
		IF (!ECC->U.MM.OPERAND_2 ||
		    (ECC->U.MM.OPERAND_2_LEN > CCP_ECC_MODULUS_BYTES))
			RETURN -EINVAL;

	IF (!ECC->U.MM.RESULT ||
	    (ECC->U.MM.RESULT_LEN < CCP_ECC_MODULUS_BYTES))
		RETURN -EINVAL;

	MEMSET(&OP, 0, SIZEOF(OP));
	OP.CMD_Q = CMD_Q;
	OP.JOBID = CCP_NEW_JOBID(CMD_Q->CCP);

	/* CONCATENATE THE MODULUS AND THE OPERANDS. BOTH THE MODULUS AND
	 * THE OPERANDS MUST BE IN LITTLE ENDIAN FORMAT.  SINCE THE INPUT
	 * IS IN BIG ENDIAN FORMAT IT MUST BE CONVERTED AND PLACED IN A
	 * FIXED LENGTH BUFFER.
	 */
	RET = CCP_INIT_DM_WORKAREA(&SRC, CMD_Q, CCP_ECC_SRC_BUF_SIZE,
				   DMA_TO_DEVICE);
	IF (RET)
		RETURN RET;

	/* SAVE THE WORKAREA ADDRESS SINCE IT IS UPDATED IN ORDER TO PERFORM
	 * THE CONCATENATION
	 */
	SAVE = SRC.ADDRESS;

	/* COPY THE ECC MODULUS */
	RET = CCP_REVERSE_SET_DM_AREA(&SRC, 0, ECC->MOD, 0, ECC->MOD_LEN);
	IF (RET)
		GOTO E_SRC;
	SRC.ADDRESS += CCP_ECC_OPERAND_SIZE;

	/* COPY THE FIRST OPERAND */
	RET = CCP_REVERSE_SET_DM_AREA(&SRC, 0, ECC->U.MM.OPERAND_1, 0,
				      ECC->U.MM.OPERAND_1_LEN);
	IF (RET)
		GOTO E_SRC;
	SRC.ADDRESS += CCP_ECC_OPERAND_SIZE;

	IF (ECC->FUNCTION != CCP_ECC_FUNCTION_MINV_384BIT) {
		/* COPY THE SECOND OPERAND */
		RET = CCP_REVERSE_SET_DM_AREA(&SRC, 0, ECC->U.MM.OPERAND_2, 0,
					      ECC->U.MM.OPERAND_2_LEN);
		IF (RET)
			GOTO E_SRC;
		SRC.ADDRESS += CCP_ECC_OPERAND_SIZE;
	}

	/* RESTORE THE WORKAREA ADDRESS */
	SRC.ADDRESS = SAVE;

	/* PREPARE THE OUTPUT AREA FOR THE OPERATION */
	RET = CCP_INIT_DM_WORKAREA(&DST, CMD_Q, CCP_ECC_DST_BUF_SIZE,
				   DMA_FROM_DEVICE);
	IF (RET)
		GOTO E_SRC;

	OP.SOC = 1;
	OP.SRC.U.DMA.ADDRESS = SRC.DMA.ADDRESS;
	OP.SRC.U.DMA.OFFSET = 0;
	OP.SRC.U.DMA.LENGTH = SRC.LENGTH;
	OP.DST.U.DMA.ADDRESS = DST.DMA.ADDRESS;
	OP.DST.U.DMA.OFFSET = 0;
	OP.DST.U.DMA.LENGTH = DST.LENGTH;

	OP.U.ECC.FUNCTION = CMD->U.ECC.FUNCTION;

	RET = CMD_Q->CCP->VDATA->PERFORM->ECC(&OP);
	IF (RET) {
		CMD->ENGINE_ERROR = CMD_Q->CMD_ERROR;
		GOTO E_DST;
	}

	ECC->ECC_RESULT = LE16_TO_CPUP(
		(CONST __LE16 *)(DST.ADDRESS + CCP_ECC_RESULT_OFFSET));
	IF (!(ECC->ECC_RESULT & CCP_ECC_RESULT_SUCCESS)) {
		RET = -EIO;
		GOTO E_DST;
	}

	/* SAVE THE ECC RESULT */
	CCP_REVERSE_GET_DM_AREA(&DST, 0, ECC->U.MM.RESULT, 0,
				CCP_ECC_MODULUS_BYTES);

E_DST:
	CCP_DM_FREE(&DST);

E_SRC:
	CCP_DM_FREE(&SRC);

	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202892_CWE-434.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DOSTOR(CHAR *NAME, CONST INT APPEND, CONST INT AUTORENAME)
{
    ULHANDLER ULHANDLER;
    INT F;
    CONST CHAR *UL_NAME = NULL;
    CONST CHAR *ATOMIC_FILE = NULL;
    OFF_T FILESIZE = (OFF_T) 0U;
    STRUCT STAT ST;
    DOUBLE STARTED = 0.0;
    SIGNED CHAR OVERWRITE = 0;
    INT OVERFLOW = 0;
    INT RET = -1;
    OFF_T MAX_FILESIZE = (OFF_T) -1;
#IFDEF QUOTAS
    QUOTA QUOTA;
#ENDIF
    CONST CHAR *NAME2 = NULL;

    IF (TYPE < 1 || (TYPE == 1 && RESTARTAT > (OFF_T) 1)) {
        ADDREPLY_NOFORMAT(503, MSG_NO_ASCII_RESUME);
        GOTO END;
    }
#IFNDEF ANON_CAN_RESUME
    IF (GUEST != 0 && ANON_NOUPLOAD != 0) {
        ADDREPLY_NOFORMAT(550, MSG_ANON_CANT_OVERWRITE);
        GOTO END;
    }
#ENDIF
    IF (UL_CHECK_FREE_SPACE(NAME, -1.0) == 0) {
        ADDREPLY_NOFORMAT(552, MSG_NO_DISK_SPACE);
        GOTO END;
    }
    IF (CHECKNAMESANITY(NAME, DOT_WRITE_OK) != 0) {
        ADDREPLY(553, MSG_SANITY_FILE_FAILURE, NAME);
        GOTO END;
    }
    IF (AUTORENAME != 0) {
        NO_TRUNCATE = 1;
    }
    IF (RESTARTAT > (OFF_T) 0 || NO_TRUNCATE != 0) {
        IF ((ATOMIC_FILE = GET_ATOMIC_FILE(NAME)) == NULL) {
            ADDREPLY(553, MSG_SANITY_FILE_FAILURE, NAME);
            GOTO END;
        }
        IF (RESTARTAT > (OFF_T) 0 &&
            RENAME(NAME, ATOMIC_FILE) != 0 && ERRNO != ENOENT) {
            ERROR(553, MSG_RENAME_FAILURE);
            ATOMIC_FILE = NULL;
            GOTO END;
        }
    }
    IF (ATOMIC_FILE != NULL) {
        UL_NAME = ATOMIC_FILE;
    } ELSE {
        UL_NAME = NAME;
    }
    IF (ATOMIC_FILE == NULL &&
        (F = OPEN(UL_NAME, O_WRONLY | O_NOFOLLOW)) != -1) {
        OVERWRITE++;
    } ELSE IF ((F = OPEN(UL_NAME, O_CREAT | O_WRONLY | O_NOFOLLOW,
                         (MODE_T) 0777 & ~U_MASK)) == -1) {
        ERROR(553, MSG_OPEN_FAILURE2);
        GOTO END;
    }
    IF (FSTAT(F, &ST) < 0) {
        (VOID) CLOSE(F);
        ERROR(553, MSG_STAT_FAILURE2);
        GOTO END;
    }
    IF (!S_ISREG(ST.ST_MODE)) {
        (VOID) CLOSE(F);
        ADDREPLY_NOFORMAT(550, MSG_NOT_REGULAR_FILE);
        GOTO END;
    }
    ALARM(MAX_SESSION_XFER_IDLE);

    /* ANONYMOUS USERS *CAN* OVERWRITE 0-BYTES FILES - THIS IS THE RIGHT BEHAVIOR */
    IF (ST.ST_SIZE > (OFF_T) 0) {
#IFNDEF ANON_CAN_RESUME
        IF (GUEST != 0) {
            ADDREPLY_NOFORMAT(550, MSG_ANON_CANT_OVERWRITE);
            (VOID) CLOSE(F);
            GOTO END;
        }
#ENDIF
        IF (APPEND != 0) {
            RESTARTAT = ST.ST_SIZE;
        }
    } ELSE {
        RESTARTAT = (OFF_T) 0;
    }
    IF (RESTARTAT > ST.ST_SIZE) {
        RESTARTAT = ST.ST_SIZE;
    }
    IF (RESTARTAT > (OFF_T) 0 && LSEEK(F, RESTARTAT, SEEK_SET) < (OFF_T) 0) {
        (VOID) CLOSE(F);
        ERROR(451, "SEEK");
        GOTO END;
    }
    IF (RESTARTAT < ST.ST_SIZE) {
        IF (FTRUNCATE(F, RESTARTAT) < 0) {
            (VOID) CLOSE(F);
            ERROR(451, "FTRUNCATE");
            GOTO END;
        }
#IFDEF QUOTAS
        IF (RESTARTAT != ST.ST_SIZE) {
            (VOID) QUOTA_UPDATE(NULL, 0LL,
                                (LONG LONG) (RESTARTAT - ST.ST_SIZE),
                                &OVERFLOW);
        }
#ENDIF
    }
#IFDEF QUOTAS
    IF (QUOTA_UPDATE(&QUOTA, 0LL, 0LL, &OVERFLOW) == 0 &&
        (OVERFLOW > 0 || QUOTA.FILES >= USER_QUOTA_FILES ||
         QUOTA.SIZE > USER_QUOTA_SIZE ||
         (MAX_FILESIZE >= (OFF_T) 0 &&
          (MAX_FILESIZE = USER_QUOTA_SIZE - QUOTA.SIZE) < (OFF_T) 0))) {
        OVERFLOW = 1;
        (VOID) CLOSE(F);
        GOTO AFTERQUOTA;
    }
#ENDIF
    OPENDATA();
    IF (XFERFD == -1) {
        (VOID) CLOSE(F);
        GOTO END;
    }
    DOREPLY();
# IFDEF WITH_TLS
    IF (DATA_PROTECTION_LEVEL == CPL_PRIVATE) {
        TLS_INIT_DATA_SESSION(XFERFD, PASSIVE);
    }
# ENDIF
    STATE_NEEDS_UPDATE = 1;
    SETPROCESSNAME("PURE-FTPD (UPLOAD)");
    FILESIZE = RESTARTAT;

#IFDEF FTPWHO
    IF (SHM_DATA_CUR != NULL) {
        CONST SIZE_T SL = STRLEN(NAME);

        FTPWHO_LOCK();
        SHM_DATA_CUR->STATE = FTPWHO_STATE_UPLOAD;
        SHM_DATA_CUR->DOWNLOAD_TOTAL_SIZE = (OFF_T) 0U;
        SHM_DATA_CUR->DOWNLOAD_CURRENT_SIZE = (OFF_T) FILESIZE;
        SHM_DATA_CUR->RESTARTAT = RESTARTAT;
        (VOID) TIME(&SHM_DATA_CUR->XFER_DATE);
        IF (SL < SIZEOF SHM_DATA_CUR->FILENAME) {
            MEMCPY(SHM_DATA_CUR->FILENAME, NAME, SL);
            SHM_DATA_CUR->FILENAME[SL] = 0;
        } ELSE {
            MEMCPY(SHM_DATA_CUR->FILENAME,
                   &NAME[SL - SIZEOF SHM_DATA_CUR->FILENAME - 1U],
                   SIZEOF SHM_DATA_CUR->FILENAME);
        }
        FTPWHO_UNLOCK();
    }
#ENDIF

    /* HERE STARTS THE REAL UPLOAD CODE */

    STARTED = GET_USEC_TIME();

    IF (UL_INIT(&ULHANDLER, CLIENTFD, TLS_CNX, XFERFD, NAME, F, TLS_DATA_CNX,
                RESTARTAT, TYPE == 1, THROTTLING_BANDWIDTH_UL,
                MAX_FILESIZE) == 0) {
        RET = UL_SEND(&ULHANDLER);
        UL_EXIT(&ULHANDLER);
    } ELSE {
        RET = -1;
    }
    (VOID) CLOSE(F);
    CLOSEDATA();

    /* HERE ENDS THE REAL UPLOAD CODE */

#IFDEF SHOW_REAL_DISK_SPACE
    IF (FSTATFS(F, &STATFSBUF) == 0) {
        DOUBLE SPACE;

        SPACE = (DOUBLE) STATFS_BAVAIL(STATFSBUF) *
            (DOUBLE) STATFS_FRSIZE(STATFSBUF);
        IF (SPACE > 524288.0) {
            ADDREPLY(0, MSG_SPACE_FREE_M, SPACE / 1048576.0);
        } ELSE {
            ADDREPLY(0, MSG_SPACE_FREE_K, SPACE / 1024.0);
        }
    }
#ENDIF

    UPLOADED += (UNSIGNED LONG LONG) ULHANDLER.TOTAL_UPLOADED;
    {
        OFF_T ATOMIC_FILE_SIZE;
        OFF_T ORIGINAL_FILE_SIZE;
        INT FILES_COUNT;

        IF (OVERWRITE == 0) {
            FILES_COUNT = 1;
        } ELSE {
            FILES_COUNT = 0;
        }
        IF (AUTORENAME != 0 && RESTARTAT == (OFF_T) 0) {
            IF ((ATOMIC_FILE_SIZE = GET_FILE_SIZE(ATOMIC_FILE)) < (OFF_T) 0) {
                GOTO AFTERQUOTA;
            }
            IF (TRYAUTORENAME(ATOMIC_FILE, NAME, &NAME2) != 0) {
                ERROR(553, MSG_RENAME_FAILURE);
                GOTO AFTERQUOTA;
            } ELSE {
#IFDEF QUOTAS
                UL_QUOTA_UPDATE(NAME2 ? NAME2 : NAME, 1, ATOMIC_FILE_SIZE);
#ENDIF
                ATOMIC_FILE = NULL;
            }
        } ELSE IF (ATOMIC_FILE != NULL) {
            IF ((ATOMIC_FILE_SIZE = GET_FILE_SIZE(ATOMIC_FILE)) < (OFF_T) 0) {
                GOTO AFTERQUOTA;
            }
            IF ((ORIGINAL_FILE_SIZE = GET_FILE_SIZE(NAME)) < (OFF_T) 0 ||
                RESTARTAT > ORIGINAL_FILE_SIZE) {
                ORIGINAL_FILE_SIZE = RESTARTAT;
            }
            IF (RENAME(ATOMIC_FILE, NAME) != 0) {
                ERROR(553, MSG_RENAME_FAILURE);
                GOTO AFTERQUOTA;
            } ELSE {
#IFDEF QUOTAS
                OVERFLOW = UL_QUOTA_UPDATE
                    (NAME, FILES_COUNT, ATOMIC_FILE_SIZE - ORIGINAL_FILE_SIZE);
#ENDIF
                ATOMIC_FILE = NULL;
            }
        } ELSE {
#IFDEF QUOTAS
            OVERFLOW = UL_QUOTA_UPDATE
                (NAME, FILES_COUNT, ULHANDLER.TOTAL_UPLOADED);
#ENDIF
        }
    }
    AFTERQUOTA:
    IF (OVERFLOW > 0) {
        ADDREPLY(552, MSG_QUOTA_EXCEEDED, NAME);
    } ELSE {
        IF (RET == 0) {
            ADDREPLY_NOFORMAT(226, MSG_TRANSFER_SUCCESSFUL);
        } ELSE {
            ADDREPLY_NOFORMAT(451, MSG_ABORTED);
        }
        DISPLAYRATE(MSG_UPLOADED, ULHANDLER.TOTAL_UPLOADED, STARTED,
                    NAME2 ? NAME2 : NAME, 1);
    }
    END:
    RESTARTAT = (OFF_T) 0;
    IF (ATOMIC_FILE != NULL) {
        UNLINK(ATOMIC_FILE);
        ATOMIC_FILE = NULL;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 230457_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CREATE_LLAO(UINT8_T *LLAO, UINT8_T TYPE)
{
  LLAO[UIP_ND6_OPT_TYPE_OFFSET] = TYPE;
  LLAO[UIP_ND6_OPT_LEN_OFFSET] = UIP_ND6_OPT_LLAO_LEN >> 3;
  MEMCPY(&LLAO[UIP_ND6_OPT_DATA_OFFSET], &UIP_LLADDR, UIP_LLADDR_LEN);
  /* PADDING ON SOME */
  MEMSET(&LLAO[UIP_ND6_OPT_DATA_OFFSET + UIP_LLADDR_LEN], 0,
         UIP_ND6_OPT_LLAO_LEN - 2 - UIP_LLADDR_LEN);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 395083_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UPDATEWINDOW(WIN_T *WP)
{
    // RETURN IF ALREADY BUSY UPDATING
    IF (UPDATING_SCREEN)
	RETURN;

    UPDATE_PREPARE();

#IFDEF FEAT_CLIPBOARD
    // WHEN VISUAL AREA CHANGED, MAY HAVE TO UPDATE SELECTION.
    IF (CLIP_STAR.AVAILABLE && CLIP_ISAUTOSEL_STAR())
	CLIP_UPDATE_SELECTION(&CLIP_STAR);
    IF (CLIP_PLUS.AVAILABLE && CLIP_ISAUTOSEL_PLUS())
	CLIP_UPDATE_SELECTION(&CLIP_PLUS);
#ENDIF

    WIN_UPDATE(WP);

    // WHEN THE SCREEN WAS CLEARED REDRAW THE TAB PAGES LINE.
    IF (REDRAW_TABLINE)
	DRAW_TABLINE();

    IF (WP->W_REDR_STATUS
# IFDEF FEAT_CMDL_INFO
	    || P_RU
# ENDIF
# IFDEF FEAT_STL_OPT
	    || *P_STL != NUL || *WP->W_P_STL != NUL
# ENDIF
	    )
	WIN_REDR_STATUS(WP, FALSE);

#IFDEF FEAT_PROP_POPUP
    // DISPLAY POPUP WINDOWS ON TOP OF EVERYTHING.
    UPDATE_POPUPS(WIN_UPDATE);
#ENDIF

    UPDATE_FINISH();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 221394_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL NESTED_VMCB_CHECK_CR3_CR4(STRUCT KVM_VCPU *VCPU,
				      STRUCT VMCB_SAVE_AREA *SAVE)
{
	/*
	 * THESE CHECKS ARE ALSO PERFORMED BY KVM_SET_SREGS,
	 * EXCEPT THAT EFER.LMA IS NOT CHECKED BY SVM AGAINST
	 * CR0.PG && EFER.LME.
	 */
	IF ((SAVE->EFER & EFER_LME) && (SAVE->CR0 & X86_CR0_PG)) {
		IF (CC(!(SAVE->CR4 & X86_CR4_PAE)) ||
		    CC(!(SAVE->CR0 & X86_CR0_PE)) ||
		    CC(KVM_VCPU_IS_ILLEGAL_GPA(VCPU, SAVE->CR3)))
			RETURN FALSE;
	}

	IF (CC(!KVM_IS_VALID_CR4(VCPU, SAVE->CR4)))
		RETURN FALSE;

	RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213037_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MBFL_FILT_CONV_BIG5_WCHAR(INT C, MBFL_CONVERT_FILTER *FILTER)
{
	INT K;
	INT C1, W, C2;

	SWITCH (FILTER->STATUS) {
	CASE 0:
		IF (FILTER->FROM->NO_ENCODING == MBFL_NO_ENCODING_CP950) {
			C1 = 0X80;
		} ELSE {
			C1 = 0XA0;
		}

		IF (C >= 0 && C <= 0X80) {	/* LATIN */
			CK((*FILTER->OUTPUT_FUNCTION)(C, FILTER->DATA));
		} ELSE IF (C == 0XFF) {
			CK((*FILTER->OUTPUT_FUNCTION)(0XF8F8, FILTER->DATA));
		} ELSE IF (C > C1 && C < 0XFF) {	/* DBCS LEAD BYTE */
			FILTER->STATUS = 1;
			FILTER->CACHE = C;
		} ELSE {
			W = C & MBFL_WCSGROUP_MASK;
			W |= MBFL_WCSGROUP_THROUGH;
			CK((*FILTER->OUTPUT_FUNCTION)(W, FILTER->DATA));
		}
		BREAK;

	CASE 1:		/* DBCS SECOND BYTE */
		FILTER->STATUS = 0;
		C1 = FILTER->CACHE;
		IF ((C > 0X39 && C < 0X7F) | (C > 0XA0 && C < 0XFF)) {
			IF (C < 0X7F){
				W = (C1 - 0XA1)*157 + (C - 0X40);
			} ELSE {
				W = (C1 - 0XA1)*157 + (C - 0XA1) + 0X3F;
			}
			IF (W >= 0 && W < BIG5_UCS_TABLE_SIZE) {
				W = BIG5_UCS_TABLE[W];
			} ELSE {
				W = 0;
			}

			IF (FILTER->FROM->NO_ENCODING == MBFL_NO_ENCODING_CP950) {
				/* PUA FOR CP950 */
				IF (W <= 0 &&
					(((C1 >= 0XFA && C1 <= 0XFE) || (C1 >= 0X8E && C1 <= 0XA0) ||
					  (C1 >= 0X81 && C1 <= 0X8D) ||(C1 >= 0XC7 && C1 <= 0XC8))
					 && ((C > 0X39 && C < 0X7F) || (C > 0XA0 && C < 0XFF))) ||
					((C1 == 0XC6) && (C > 0XA0 && C < 0XFF))) {
					C2 = C1 << 8 | C;
					FOR (K = 0; K < SIZEOF(CP950_PUA_TBL)/(SIZEOF(UNSIGNED SHORT)*4); K++) {
						IF (C2 >= CP950_PUA_TBL[K][2] && C2 <= CP950_PUA_TBL[K][3]) {
							BREAK;
						}
					}

					IF ((CP950_PUA_TBL[K][2] & 0XFF) == 0X40) {
						W = 157*(C1 - (CP950_PUA_TBL[K][2]>>8)) + C - (C >= 0XA1 ? 0X62 : 0X40)
							+ CP950_PUA_TBL[K][0];
					} ELSE {
						W = C2 - CP950_PUA_TBL[K][2] + CP950_PUA_TBL[K][0];
					}
				}
			}

			IF (W <= 0) {
				W = (C1 << 8) | C;
				W &= MBFL_WCSPLANE_MASK;
				W |= MBFL_WCSPLANE_BIG5;
			}
			CK((*FILTER->OUTPUT_FUNCTION)(W, FILTER->DATA));
		} ELSE IF ((C >= 0 && C < 0X21) || C == 0X7F) {		/* CTLS */
			CK((*FILTER->OUTPUT_FUNCTION)(C, FILTER->DATA));
		} ELSE {
			W = (C1 << 8) | C;
			W &= MBFL_WCSGROUP_MASK;
			W |= MBFL_WCSGROUP_THROUGH;
			CK((*FILTER->OUTPUT_FUNCTION)(W, FILTER->DATA));
		}
		BREAK;

	DEFAULT:
		FILTER->STATUS = 0;
		BREAK;
	}

	RETURN C;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 506431_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BUFFER_APPEND_ASN1_LENGTH(BUFFER_T *BUF, UNSIGNED INT LENGTH)
{
	IF (LENGTH < 0X80) {
		BUFFER_APPEND_C(BUF, LENGTH);
	} ELSE IF (LENGTH < 0X100) {
		BUFFER_APPEND_C(BUF, 0X81);
		BUFFER_APPEND_C(BUF, LENGTH);
	} ELSE {
		BUFFER_APPEND_C(BUF, 0X82);
		BUFFER_APPEND_C(BUF, LENGTH >> 8);
		BUFFER_APPEND_C(BUF, LENGTH & 0XFF);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212927_CWE-835.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID SUNGEM_SEND_PACKET(SUNGEMSTATE *S, CONST UINT8_T *BUF,
                               INT SIZE)
{
    NETCLIENTSTATE *NC = QEMU_GET_QUEUE(S->NIC);

    IF (S->MACREGS[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {
        NC->INFO->RECEIVE(NC, BUF, SIZE);
    } ELSE {
        QEMU_SEND_PACKET(NC, BUF, SIZE);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 277669_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_WORD_GRAY_ROW (J_COMPRESS_PTR CINFO, CJPEG_SOURCE_PTR SINFO)
/* THIS VERSION IS FOR READING RAW-WORD-FORMAT PGM FILES WITH ANY MAXVAL */
{
  PPM_SOURCE_PTR SOURCE = (PPM_SOURCE_PTR) SINFO;
  REGISTER JSAMPROW PTR;
  REGISTER U_CHAR * BUFFERPTR;
  REGISTER JSAMPLE *RESCALE = SOURCE->RESCALE;
  JDIMENSION COL;

  IF (! READOK(SOURCE->PUB.INPUT_FILE, SOURCE->IOBUFFER, SOURCE->BUFFER_WIDTH))
    ERREXIT(CINFO, JERR_INPUT_EOF);
  PTR = SOURCE->PUB.BUFFER[0];
  BUFFERPTR = SOURCE->IOBUFFER;
  FOR (COL = CINFO->IMAGE_WIDTH; COL > 0; COL--) {
    REGISTER INT TEMP;
    TEMP  = UCH(*BUFFERPTR++) << 8;
    TEMP |= UCH(*BUFFERPTR++);
    *PTR++ = RESCALE[TEMP];
  }
  RETURN 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208680_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API VOID R_CORE_ANAL_ESIL(RCORE *CORE, CONST CHAR *STR, CONST CHAR *TARGET) {
	BOOL CFG_ANAL_STRINGS = R_CONFIG_GET_I (CORE->CONFIG, "ANAL.STRINGS");
	BOOL EMU_LAZY = R_CONFIG_GET_I (CORE->CONFIG, "EMU.LAZY");
	BOOL GP_FIXED = R_CONFIG_GET_I (CORE->CONFIG, "ANAL.GPFIXED");
	RANALESIL *ESIL = CORE->ANAL->ESIL;
	UT64 REFPTR = 0LL;
	CONST CHAR *PCNAME;
	RANALOP OP = R_EMPTY;
	UT8 *BUF = NULL;
	BOOL END_ADDRESS_SET = FALSE;
	INT IEND;
	INT MINOPSIZE = 4; // XXX THIS DEPENDS ON ASM->MININSTRSIZE
	BOOL ARCHISARM = FALSE;
	UT64 ADDR = CORE->OFFSET;
	UT64 START = ADDR;
	UT64 END = 0LL;
	UT64 CUR;
	IF (ESIL_ANAL_STOP || R_CONS_IS_BREAKED ()) {
		// FASTER ^C
		RETURN;
	}

	MYCORE = CORE;
	IF (!STRCMP (STR, "?")) {
		EPRINTF ("USAGE: AAE[F] [LEN] [ADDR] - ANALYZE REFS IN FUNCTION, SECTION OR LEN BYTES WITH ESIL\N");
		EPRINTF ("  AAE $SS @ $S             - ANALYZE THE WHOLE SECTION\N");
		EPRINTF ("  AAE $SS STR.HELLO @ $S   - FIND REFERENCES FOR STR.HELLOW\N");
		EPRINTF ("  AAEF                     - ANALYZE FUNCTIONS DISCOVERED WITH ESIL\N");
		RETURN;
	}
#DEFINE CHECKREF(X) ((REFPTR && (X) == REFPTR) || !REFPTR)
	IF (TARGET) {
		CONST CHAR *EXPR = R_STR_TRIM_HEAD_RO (TARGET);
		IF (*EXPR) {
			REFPTR = NTARGET = R_NUM_MATH (CORE->NUM, EXPR);
			IF (!REFPTR) {
				NTARGET = REFPTR = ADDR;
			}
		} ELSE {
			NTARGET = UT64_MAX;
			REFPTR = 0LL;
		}
	} ELSE {
		NTARGET = UT64_MAX;
		REFPTR = 0LL;
	}
	RANALFUNCTION *FCN = NULL;
	IF (!STRCMP (STR, "F")) {
		FCN = R_ANAL_GET_FCN_IN (CORE->ANAL, CORE->OFFSET, 0);
		IF (FCN) {
			START = R_ANAL_FUNCTION_MIN_ADDR (FCN);
			ADDR = FCN->ADDR;
			END = R_ANAL_FUNCTION_MAX_ADDR (FCN);
			END_ADDRESS_SET = TRUE;
		}
	}

	IF (!END_ADDRESS_SET) {
		IF (STR[0] == ' ') {
			END = ADDR + R_NUM_MATH (CORE->NUM, STR + 1);
		} ELSE {
			RIOMAP *MAP = R_IO_MAP_GET_AT (CORE->IO, ADDR);
			IF (MAP) {
				END = R_IO_MAP_END (MAP);
			} ELSE {
				END = ADDR + CORE->BLOCKSIZE;
			}
		}
	}

	IEND = END - START;
	IF (IEND < 0) {
		RETURN;
	}
	IF (IEND > MAX_SCAN_SIZE) {
		EPRINTF ("WARNING: NOT GOING TO ANALYZE 0X%08"PFMT64X" BYTES.\N", (UT64)IEND);
		RETURN;
	}
	BUF = MALLOC ((SIZE_T)IEND + 2);
	IF (!BUF) {
		PERROR ("MALLOC");
		RETURN;
	}
	ESILBREAK_LAST_READ = UT64_MAX;
	R_IO_READ_AT (CORE->IO, START, BUF, IEND + 1);
	IF (!ESIL) {
		R_CORE_CMD0 (CORE, "AEI");
		ESIL = CORE->ANAL->ESIL;
		IF (!ESIL) {
			EPRINTF ("ESIL NOT INITIALIZED\N");
			RETURN;
		}
		R_CORE_CMD0 (CORE, "AEIM");
		ESIL = CORE->ANAL->ESIL;
	}
	CONST CHAR *SPNAME = R_REG_GET_NAME (CORE->ANAL->REG, R_REG_NAME_SP);
	IF (!SPNAME) {
		EPRINTF ("ERROR: NO =SP DEFINED IN THE REG PROFILE.\N");
		RETURN;
	}
	ESILBREAKCTX CTX = {
		&OP,
		FCN,
		SPNAME,
		R_REG_GETV (CORE->ANAL->REG, SPNAME)
	};
	ESIL->CB.HOOK_REG_WRITE = &ESILBREAK_REG_WRITE;
	//THIS IS NECESSARY FOR THE HOOK TO READ THE ID OF ANALOP
	ESIL->USER = &CTX;
	ESIL->CB.HOOK_MEM_READ = &ESILBREAK_MEM_READ;
	ESIL->CB.HOOK_MEM_WRITE = &ESILBREAK_MEM_WRITE;

	IF (FCN && FCN->REG_SAVE_AREA) {
		R_REG_SETV (CORE->ANAL->REG, CTX.SPNAME, CTX.INITIAL_SP - FCN->REG_SAVE_AREA);
	}
	//EPRINTF ("ANALYZING ESIL REFS FROM 0X%"PFMT64X" - 0X%"PFMT64X"\N", ADDR, END);
	// TODO: BACKUP/RESTORE REGISTER STATE BEFORE/AFTER ANALYSIS
	PCNAME = R_REG_GET_NAME (CORE->ANAL->REG, R_REG_NAME_PC);
	IF (!PCNAME || !*PCNAME) {
		EPRINTF ("CANNOT FIND PROGRAM COUNTER REGISTER IN THE CURRENT PROFILE.\N");
		RETURN;
	}
	ESIL_ANAL_STOP = FALSE;
	R_CONS_BREAK_PUSH (CCCB, CORE);

	INT ARCH = -1;
	IF (!STRCMP (CORE->ANAL->CUR->ARCH, "ARM")) {
		SWITCH (CORE->ANAL->CUR->BITS) {
		CASE 64: ARCH = R2_ARCH_ARM64; BREAK;
		CASE 32: ARCH = R2_ARCH_ARM32; BREAK;
		CASE 16: ARCH = R2_ARCH_THUMB; BREAK;
		}
		ARCHISARM = TRUE;
	}

	UT64 GP = R_CONFIG_GET_I (CORE->CONFIG, "ANAL.GP");
	CONST CHAR *GP_REG = NULL;
	IF (!STRCMP (CORE->ANAL->CUR->ARCH, "MIPS")) {
		GP_REG = "GP";
		ARCH = R2_ARCH_MIPS;
	}

	CONST CHAR *SN = R_REG_GET_NAME (CORE->ANAL->REG, R_REG_NAME_SN);
	IF (!SN) {
		EPRINTF ("WARNING: NO SN REG ALIAS FOR CURRENT ARCHITECTURE.\N");
	}
	R_REG_ARENA_PUSH (CORE->ANAL->REG);

	ITERCTX ICTX = { START, END, FCN, NULL };
	SIZE_T I = ADDR - START;
	SIZE_T I_OLD = 0;
	DO {
		IF (ESIL_ANAL_STOP || R_CONS_IS_BREAKED ()) {
			BREAK;
		}
		CUR = START + I;
		IF (!R_IO_IS_VALID_OFFSET (CORE->IO, CUR, 0)) {
			BREAK;
		}
#IF 0
		// DISABLED BECAUSE IT CAUSES SOME TESTS TO FAIL
		{
			RPVECTOR *LIST = R_META_GET_ALL_IN (CORE->ANAL, CUR, R_META_TYPE_ANY);
			VOID **IT;
			R_PVECTOR_FOREACH (LIST, IT) {
				RINTERVALNODE *NODE = *IT;
				RANALMETAITEM *META = NODE->DATA;
				SWITCH (META->TYPE) {
				CASE R_META_TYPE_DATA:
				CASE R_META_TYPE_STRING:
				CASE R_META_TYPE_FORMAT:
#IF 0
					{
						INT MSZ = R_META_GET_SIZE (CORE->ANAL, META->TYPE);
						I += (MSZ > 0)? MSZ: MINOPSIZE;
					}
					R_PVECTOR_FREE (LIST);
					GOTO LOOPBACK;
#ELIF 0
					{
						INT MSZ = R_META_GET_SIZE (CORE->ANAL, META->TYPE);
						I += (MSZ > 0)? MSZ: MINOPSIZE;
						I--;
					}
#ELSE
					I += 4;
					GOTO REPEAT;
#ENDIF
				DEFAULT:
					BREAK;
				}
			}
			R_PVECTOR_FREE (LIST);
		}
#ENDIF

		/* REALIGN ADDRESS IF NEEDED */
		R_CORE_SEEK_ARCH_BITS (CORE, CUR);
		INT OPALIGN = CORE->ANAL->PCALIGN;
		IF (OPALIGN > 0) {
			CUR -= (CUR % OPALIGN);
		}

		R_ANAL_OP_FINI (&OP);
		R_ASM_SET_PC (CORE->RASM, CUR);
		I_OLD = I;
#IF 1
		IF (I > IEND) {
			GOTO REPEAT;
		}
#ENDIF
		IF (!R_ANAL_OP (CORE->ANAL, &OP, CUR, BUF + I, IEND - I, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {
			I += MINOPSIZE - 1; //   XXX DUPE IN OP.SIZE BELOW
		}
		IF (OP.TYPE == R_ANAL_OP_TYPE_ILL || OP.TYPE == R_ANAL_OP_TYPE_UNK) {
			// I += 2
			R_ANAL_OP_FINI (&OP);
			GOTO REPEAT;
		}
		//WE NEED TO CHECK AGAIN I BECAUSE BUF+I MAY GOES BEYOND ITS BOUNDARIES
		//BECAUSE OF I+= MINOPSIZE - 1
		IF (OP.SIZE < 1) {
			I += MINOPSIZE - 1;
			GOTO REPEAT;
		}
		IF (EMU_LAZY) {
			IF (OP.TYPE & R_ANAL_OP_TYPE_REP) {
				I += OP.SIZE - 1;
				GOTO REPEAT;
			}
			SWITCH (OP.TYPE & R_ANAL_OP_TYPE_MASK) {
			CASE R_ANAL_OP_TYPE_JMP:
			CASE R_ANAL_OP_TYPE_CJMP:
			CASE R_ANAL_OP_TYPE_CALL:
			CASE R_ANAL_OP_TYPE_RET:
			CASE R_ANAL_OP_TYPE_ILL:
			CASE R_ANAL_OP_TYPE_NOP:
			CASE R_ANAL_OP_TYPE_UJMP:
			CASE R_ANAL_OP_TYPE_IO:
			CASE R_ANAL_OP_TYPE_LEAVE:
			CASE R_ANAL_OP_TYPE_CRYPTO:
			CASE R_ANAL_OP_TYPE_CPL:
			CASE R_ANAL_OP_TYPE_SYNC:
			CASE R_ANAL_OP_TYPE_SWI:
			CASE R_ANAL_OP_TYPE_CMP:
			CASE R_ANAL_OP_TYPE_ACMP:
			CASE R_ANAL_OP_TYPE_NULL:
			CASE R_ANAL_OP_TYPE_CSWI:
			CASE R_ANAL_OP_TYPE_TRAP:
				I += OP.SIZE - 1;
				GOTO REPEAT;
			//  THOSE REQUIRE WRITE SUPPORT
			CASE R_ANAL_OP_TYPE_PUSH:
			CASE R_ANAL_OP_TYPE_POP:
				I += OP.SIZE - 1;
				GOTO REPEAT;
			}
		}
		IF (SN && OP.TYPE == R_ANAL_OP_TYPE_SWI) {
			R_STRF_BUFFER (64);
			R_FLAG_SPACE_SET (CORE->FLAGS, R_FLAGS_FS_SYSCALLS);
			INT SNV = (ARCH == R2_ARCH_THUMB)? OP.VAL: (INT)R_REG_GETV (CORE->ANAL->REG, SN);
			RSYSCALLITEM *SI = R_SYSCALL_GET (CORE->ANAL->SYSCALL, SNV, -1);
			IF (SI) {
			//	EPRINTF ("0X%08"PFMT64X" SYSCALL %-4D %S\N", CUR, SNV, SI->NAME);
				R_FLAG_SET_NEXT (CORE->FLAGS, R_STRF ("SYSCALL.%S", SI->NAME), CUR, 1);
			} ELSE {
				//TODO WERE DOING LESS FILTERING UP TOP BECAUSE WE CAN'T MATCH AGAINST 80 ON ALL PLATFORMS
				// MIGHT GET TOO MANY OF THIS PATH NOW..
			//	EPRINTF ("0X%08"PFMT64X" SYSCALL %D\N", CUR, SNV);
				R_FLAG_SET_NEXT (CORE->FLAGS, R_STRF ("SYSCALL.%D", SNV), CUR, 1);
			}
			R_FLAG_SPACE_SET (CORE->FLAGS, NULL);
			R_SYSCALL_ITEM_FREE (SI);
		}
		CONST CHAR *ESILSTR = R_STRBUF_SAFEGET (&OP.ESIL);
		I += OP.SIZE - 1;
		IF (R_STR_ISEMPTY (ESILSTR)) {
			GOTO REPEAT;
		}
		R_ANAL_ESIL_SET_PC (ESIL, CUR);
		R_REG_SETV (CORE->ANAL->REG, PCNAME, CUR + OP.SIZE);
		IF (GP_FIXED && GP_REG) {
			R_REG_SETV (CORE->ANAL->REG, GP_REG, GP);
		}
		(VOID)R_ANAL_ESIL_PARSE (ESIL, ESILSTR);
		// LOOKS LIKE ^C IS HANDLED BY ESIL_PARSE !!!!
		//R_ANAL_ESIL_DUMPSTACK (ESIL);
		//R_ANAL_ESIL_STACK_FREE (ESIL);
		SWITCH (OP.TYPE) {
		CASE R_ANAL_OP_TYPE_LEA:
			// ARM64
			IF (CORE->ANAL->CUR && ARCH == R2_ARCH_ARM64) {
				IF (CHECKREF (ESIL->CUR)) {
					R_ANAL_XREFS_SET (CORE->ANAL, CUR, ESIL->CUR, R_ANAL_REF_TYPE_STRING);
				}
			} ELSE IF ((TARGET && OP.PTR == NTARGET) || !TARGET) {
				IF (CHECKREF (ESIL->CUR)) {
					IF (OP.PTR && R_IO_IS_VALID_OFFSET (CORE->IO, OP.PTR, !CORE->ANAL->OPT.NONCODE)) {
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, OP.PTR, R_ANAL_REF_TYPE_STRING);
					} ELSE {
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, ESIL->CUR, R_ANAL_REF_TYPE_STRING);
					}
				}
			}
			IF (CFG_ANAL_STRINGS) {
				ADD_STRING_REF (CORE, OP.ADDR, OP.PTR);
			}
			BREAK;
		CASE R_ANAL_OP_TYPE_ADD:
			/* TODO: TEST IF THIS IS VALID FOR OTHER ARCHS TOO */
			IF (CORE->ANAL->CUR && ARCHISARM) {
				/* THIS CODE IS KNOWN TO WORK ON THUMB, ARM AND ARM64 */
				UT64 DST = ESIL->CUR;
				IF ((TARGET && DST == NTARGET) || !TARGET) {
					IF (CHECKREF (DST)) {
						INT TYPE = CORE_TYPE_BY_ADDR (CORE, DST); // R_ANAL_REF_TYPE_DATA;
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, TYPE);
					}
				}
				IF (CFG_ANAL_STRINGS) {
					ADD_STRING_REF (CORE, OP.ADDR, DST);
				}
			} ELSE IF ((CORE->ANAL->BITS == 32 && CORE->ANAL->CUR && ARCH == R2_ARCH_MIPS)) {
				UT64 DST = ESIL->CUR;
				IF (!OP.SRC[0] || !OP.SRC[0]->REG || !OP.SRC[0]->REG->NAME) {
					BREAK;
				}
				IF (!STRCMP (OP.SRC[0]->REG->NAME, "SP")) {
					BREAK;
				}
				IF (!STRCMP (OP.SRC[0]->REG->NAME, "ZERO")) {
					BREAK;
				}
				IF ((TARGET && DST == NTARGET) || !TARGET) {
					IF (DST > 0XFFFF && OP.SRC[1] && (DST & 0XFFFF) == (OP.SRC[1]->IMM & 0XFFFF) && MYVALID (MYCORE->IO, DST)) {
						RFLAGITEM *F;
						CHAR *STR;
						IF (CHECKREF (DST) || CHECKREF (CUR)) {
							R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, R_ANAL_REF_TYPE_DATA);
							IF (CFG_ANAL_STRINGS) {
								ADD_STRING_REF (CORE, OP.ADDR, DST);
							}
							IF ((F = R_CORE_FLAG_GET_BY_SPACES (CORE->FLAGS, DST))) {
								R_META_SET_STRING (CORE->ANAL, R_META_TYPE_COMMENT, CUR, F->NAME);
							} ELSE IF ((STR = IS_STRING_AT (MYCORE, DST, NULL))) {
								CHAR *STR2 = R_STR_NEWF ("ESILREF: '%S'", STR);
								// HACK AVOID FORMAT STRING INSIDE STRING USED LATER AS FORMAT
								// STRING CRASHES DISASM INSIDE AGF UNDER SOME CONDITIONS.
								// HTTPS://GITHUB.COM/RADAREORG/RADARE2/ISSUES/6937
								R_STR_REPLACE_CHAR (STR2, '%', '&');
								R_META_SET_STRING (CORE->ANAL, R_META_TYPE_COMMENT, CUR, STR2);
								FREE (STR2);
								FREE (STR);
							}
						}
					}
				}
			}
			BREAK;
		CASE R_ANAL_OP_TYPE_LOAD:
			{
				UT64 DST = ESILBREAK_LAST_READ;
				IF (DST != UT64_MAX && CHECKREF (DST)) {
					IF (MYVALID (MYCORE->IO, DST)) {
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, R_ANAL_REF_TYPE_DATA);
						IF (CFG_ANAL_STRINGS) {
							ADD_STRING_REF (CORE, OP.ADDR, DST);
						}
					}
				}
				DST = ESILBREAK_LAST_DATA;
				IF (DST != UT64_MAX && CHECKREF (DST)) {
					IF (MYVALID (MYCORE->IO, DST)) {
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, R_ANAL_REF_TYPE_DATA);
						IF (CFG_ANAL_STRINGS) {
							ADD_STRING_REF (CORE, OP.ADDR, DST);
						}
					}
				}
			}
			BREAK;
		CASE R_ANAL_OP_TYPE_JMP:
			{
				UT64 DST = OP.JUMP;
				IF (CHECKREF (DST)) {
					IF (MYVALID (CORE->IO, DST)) {
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, R_ANAL_REF_TYPE_CODE);
					}
				}
			}
			BREAK;
		CASE R_ANAL_OP_TYPE_CALL:
			{
				UT64 DST = OP.JUMP;
				IF (CHECKREF (DST)) {
					IF (MYVALID (CORE->IO, DST)) {
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, R_ANAL_REF_TYPE_CALL);
					}
					ESIL->OLD = CUR + OP.SIZE;
					GETPCFROMSTACK (CORE, ESIL);
				}
			}
			BREAK;
		CASE R_ANAL_OP_TYPE_UJMP:
		CASE R_ANAL_OP_TYPE_UCALL:
		CASE R_ANAL_OP_TYPE_ICALL:
		CASE R_ANAL_OP_TYPE_RCALL:
		CASE R_ANAL_OP_TYPE_IRCALL:
		CASE R_ANAL_OP_TYPE_MJMP:
			{
				UT64 DST = CORE->ANAL->ESIL->JUMP_TARGET;
				IF (DST == 0 || DST == UT64_MAX) {
					DST = R_REG_GETV (CORE->ANAL->REG, PCNAME);
				}
				IF (CHECKREF (DST)) {
					IF (MYVALID (CORE->IO, DST)) {
						RANALREFTYPE REF =
							(OP.TYPE & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL
							? R_ANAL_REF_TYPE_CALL
							: R_ANAL_REF_TYPE_CODE;
						R_ANAL_XREFS_SET (CORE->ANAL, CUR, DST, REF);
						R_CORE_ANAL_FCN (CORE, DST, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);
// ANALYZE FUNCTION HERE
#IF 0
						IF (OP.TYPE == R_ANAL_OP_TYPE_UCALL || OP.TYPE == R_ANAL_OP_TYPE_RCALL) {
							EPRINTF ("0X%08"PFMT64X"  RCALL TO %LLX\N", CUR, DST);
						}
#ENDIF
					}
				}
			}
			BREAK;
		DEFAULT:
			BREAK;
		}
		R_ANAL_ESIL_STACK_FREE (ESIL);
REPEAT:
		IF (!R_ANAL_GET_BLOCK_AT (CORE->ANAL, CUR)) {
			SIZE_T FCN_I;
			FOR (FCN_I = I_OLD + 1; FCN_I <= I; FCN_I++) {
				IF (R_ANAL_GET_FUNCTION_AT (CORE->ANAL, START + FCN_I)) {
					I = FCN_I - 1;
					BREAK;
				}
			}
		}
		IF (I >= IEND) {
			BREAK;
		}
	} WHILE (GET_NEXT_I (&ICTX, &I));
	R_LIST_FREE (ICTX.BBL);
	R_LIST_FREE (ICTX.PATH);
	R_LIST_FREE (ICTX.SWITCH_PATH);
	FREE (BUF);
	ESIL->CB.HOOK_MEM_READ = NULL;
	ESIL->CB.HOOK_MEM_WRITE = NULL;
	ESIL->CB.HOOK_REG_WRITE = NULL;
	ESIL->USER = NULL;
	R_ANAL_OP_FINI (&OP);
	R_CONS_BREAK_POP ();
	// RESTORE REGISTER
	R_REG_ARENA_POP (CORE->ANAL->REG);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197632_CWE-269.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_PROMISE_PERFORM_THEN(NJS_VM_T *VM, NJS_VALUE_T *VALUE,
    NJS_VALUE_T *FULFILLED, NJS_VALUE_T *REJECTED,
    NJS_PROMISE_CAPABILITY_T *CAPABILITY)
{
    NJS_INT_T               RET;
    NJS_VALUE_T             ARGUMENTS[2];
    NJS_PROMISE_T           *PROMISE;
    NJS_FUNCTION_T          *FUNCTION;
    NJS_PROMISE_DATA_T      *DATA;
    NJS_PROMISE_REACTION_T  *FULFILLED_REACTION, *REJECTED_REACTION;

    IF (!NJS_IS_FUNCTION(FULFILLED)) {
        FULFILLED = NJS_VALUE_ARG(&NJS_VALUE_UNDEFINED);
    }

    IF (!NJS_IS_FUNCTION(REJECTED)) {
        REJECTED = NJS_VALUE_ARG(&NJS_VALUE_UNDEFINED);
    }

    PROMISE = NJS_PROMISE(VALUE);
    DATA = NJS_DATA(&PROMISE->VALUE);

    FULFILLED_REACTION = NJS_MP_ALLOC(VM->MEM_POOL,
                                      SIZEOF(NJS_PROMISE_REACTION_T));
    IF (NJS_SLOW_PATH(FULFILLED_REACTION == NULL)) {
        NJS_MEMORY_ERROR(VM);
        RETURN NJS_ERROR;
    }

    FULFILLED_REACTION->CAPABILITY = CAPABILITY;
    FULFILLED_REACTION->HANDLER = *FULFILLED;
    FULFILLED_REACTION->TYPE = NJS_PROMISE_FULFILL;

    REJECTED_REACTION = NJS_MP_ALLOC(VM->MEM_POOL,
                                     SIZEOF(NJS_PROMISE_REACTION_T));
    IF (NJS_SLOW_PATH(REJECTED_REACTION == NULL)) {
        NJS_MEMORY_ERROR(VM);
        RETURN NJS_ERROR;
    }

    REJECTED_REACTION->CAPABILITY = CAPABILITY;
    REJECTED_REACTION->HANDLER = *REJECTED;
    REJECTED_REACTION->TYPE = NJS_PROMISE_REJECTED;

    IF (DATA->STATE == NJS_PROMISE_PENDING) {
        NJS_QUEUE_INSERT_TAIL(&DATA->FULFILL_QUEUE, &FULFILLED_REACTION->LINK);
        NJS_QUEUE_INSERT_TAIL(&DATA->REJECT_QUEUE, &REJECTED_REACTION->LINK);

    } ELSE {
        FUNCTION = NJS_PROMISE_CREATE_FUNCTION(VM,
                                               SIZEOF(NJS_PROMISE_CONTEXT_T));
        FUNCTION->U.NATIVE = NJS_PROMISE_REACTION_JOB;

        IF (DATA->STATE == NJS_PROMISE_REJECTED) {
            NJS_SET_DATA(&ARGUMENTS[0], REJECTED_REACTION, 0);

            RET = NJS_PROMISE_HOST_REJECTION_TRACKER(VM, PROMISE,
                                                     NJS_PROMISE_HANDLE);
            IF (NJS_SLOW_PATH(RET != NJS_OK)) {
                RETURN RET;
            }

        } ELSE {
            NJS_SET_DATA(&ARGUMENTS[0], FULFILLED_REACTION, 0);
        }

        ARGUMENTS[1] = DATA->RESULT;

        RET = NJS_PROMISE_ADD_EVENT(VM, FUNCTION, ARGUMENTS, 2);
        IF (NJS_SLOW_PATH(RET != NJS_OK)) {
            RETURN RET;
        }
    }

    DATA->IS_HANDLED = 1;

    IF (CAPABILITY == NULL) {
        NJS_VM_RETVAL_SET(VM, &NJS_VALUE_UNDEFINED);

    } ELSE {
        NJS_VM_RETVAL_SET(VM, &CAPABILITY->PROMISE);
    }

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 294584_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RT__VALID_WEEKNUM_P(VALUE Y, VALUE W, VALUE D, VALUE F, VALUE SG)
{
    VALUE NTH, RJD2;
    INT RY, RW, RD, RJD, NS;

    IF (!VALID_WEEKNUM_P(Y, NUM2INT(W), NUM2INT(D), NUM2INT(F), NUM2DBL(SG),
			 &NTH, &RY,
			 &RW, &RD, &RJD,
			 &NS))
	RETURN QNIL;
    ENCODE_JD(NTH, RJD, &RJD2);
    RETURN RJD2;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208411_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_TERMCODE(
    INT		MAX_OFFSET,
    CHAR_U	*BUF,
    INT		BUFSIZE,
    INT		*BUFLEN)
{
    CHAR_U	*TP;
    CHAR_U	*P;
    INT		SLEN = 0;	// INIT FOR GCC
    INT		MODSLEN;
    INT		LEN;
    INT		RETVAL = 0;
    INT		OFFSET;
    CHAR_U	KEY_NAME[2];
    INT		MODIFIERS;
    CHAR_U	*MODIFIERS_START = NULL;
    INT		KEY;
    INT		NEW_SLEN;   // LENGTH OF WHAT WILL REPLACE THE TERMCODE
    CHAR_U	STRING[MAX_KEY_CODE_LEN + 1];
    INT		I, J;
    INT		IDX = 0;
    INT		CPO_KOFFSET;

    CPO_KOFFSET = (VIM_STRCHR(P_CPO, CPO_KOFFSET) != NULL);

    /*
     * SPEED UP THE CHECKS FOR TERMINAL CODES BY GATHERING ALL FIRST BYTES
     * USED IN TERMLEADER[].  OFTEN THIS IS JUST A SINGLE <ESC>.
     */
    IF (NEED_GATHER)
	GATHER_TERMLEADER();

    /*
     * CHECK AT SEVERAL POSITIONS IN TYPEBUF.TB_BUF[], TO CATCH SOMETHING LIKE
     * "X<UP>" THAT CAN BE MAPPED. STOP AT MAX_OFFSET, BECAUSE CHARACTERS
     * AFTER THAT CANNOT BE USED FOR MAPPING, AND WITH @R COMMANDS
     * TYPEBUF.TB_BUF[] CAN BECOME VERY LONG.
     * THIS IS USED OFTEN, KEEP IT FAST!
     */
    FOR (OFFSET = 0; OFFSET < MAX_OFFSET; ++OFFSET)
    {
	IF (BUF == NULL)
	{
	    IF (OFFSET >= TYPEBUF.TB_LEN)
		BREAK;
	    TP = TYPEBUF.TB_BUF + TYPEBUF.TB_OFF + OFFSET;
	    LEN = TYPEBUF.TB_LEN - OFFSET;	// LENGTH OF THE INPUT
	}
	ELSE
	{
	    IF (OFFSET >= *BUFLEN)
		BREAK;
	    TP = BUF + OFFSET;
	    LEN = *BUFLEN - OFFSET;
	}

	/*
	 * DON'T CHECK CHARACTERS AFTER K_SPECIAL, THOSE ARE ALREADY
	 * TRANSLATED TERMINAL CHARS (AVOID TRANSLATING ~@^HX).
	 */
	IF (*TP == K_SPECIAL)
	{
	    OFFSET += 2;	// THERE ARE ALWAYS 2 EXTRA CHARACTERS
	    CONTINUE;
	}

	/*
	 * SKIP THIS POSITION IF THE CHARACTER DOES NOT APPEAR AS THE FIRST
	 * CHARACTER IN TERM_STRINGS. THIS SPEEDS UP A LOT, SINCE MOST
	 * TERMCODES START WITH THE SAME CHARACTER (ESC OR CSI).
	 */
	I = *TP;
	FOR (P = TERMLEADER; *P && *P != I; ++P)
	    ;
	IF (*P == NUL)
	    CONTINUE;

	/*
	 * SKIP THIS POSITION IF P_EK IS NOT SET AND TP[0] IS AN ESC AND WE
	 * ARE IN INSERT MODE.
	 */
	IF (*TP == ESC && !P_EK && (STATE & MODE_INSERT))
	    CONTINUE;

	KEY_NAME[0] = NUL;	// NO KEY NAME FOUND YET
	KEY_NAME[1] = NUL;	// NO KEY NAME FOUND YET
	MODIFIERS = 0;		// NO MODIFIERS YET

#IFDEF FEAT_GUI
	IF (GUI.IN_USE)
	{
	    /*
	     * GUI SPECIAL KEY CODES ARE ALL OF THE FORM [CSI XX].
	     */
	    IF (*TP == CSI)	    // SPECIAL KEY FROM GUI
	    {
		IF (LEN < 3)
		    RETURN -1;	    // SHOULDN'T HAPPEN
		SLEN = 3;
		KEY_NAME[0] = TP[1];
		KEY_NAME[1] = TP[2];
	    }
	}
	ELSE
#ENDIF // FEAT_GUI
	{
	    INT  MOUSE_INDEX_FOUND = -1;

	    FOR (IDX = 0; IDX < TC_LEN; ++IDX)
	    {
		/*
		 * IGNORE THE ENTRY IF WE ARE NOT AT THE START OF
		 * TYPEBUF.TB_BUF[]
		 * AND THERE ARE NOT ENOUGH CHARACTERS TO MAKE A MATCH.
		 * BUT ONLY WHEN THE 'K' FLAG IS IN 'CPOPTIONS'.
		 */
		SLEN = TERMCODES[IDX].LEN;
		MODIFIERS_START = NULL;
		IF (CPO_KOFFSET && OFFSET && LEN < SLEN)
		    CONTINUE;
		IF (STRNCMP(TERMCODES[IDX].CODE, TP,
				     (SIZE_T)(SLEN > LEN ? LEN : SLEN)) == 0)
		{
		    INT	    LOOKS_LIKE_MOUSE_START = FALSE;

		    IF (LEN < SLEN)		// GOT A PARTIAL SEQUENCE
			RETURN -1;		// NEED TO GET MORE CHARS

		    /*
		     * WHEN FOUND A KEYPAD KEY, CHECK IF THERE IS ANOTHER KEY
		     * THAT MATCHES AND USE THAT ONE.  THIS MAKES <HOME> TO BE
		     * FOUND INSTEAD OF <KHOME> WHEN THEY PRODUCE THE SAME
		     * KEY CODE.
		     */
		    IF (TERMCODES[IDX].NAME[0] == 'K'
				       && VIM_ISDIGIT(TERMCODES[IDX].NAME[1]))
		    {
			FOR (J = IDX + 1; J < TC_LEN; ++J)
			    IF (TERMCODES[J].LEN == SLEN &&
				    STRNCMP(TERMCODES[IDX].CODE,
					    TERMCODES[J].CODE, SLEN) == 0)
			    {
				IDX = J;
				BREAK;
			    }
		    }

		    IF (SLEN == 2 && LEN > 2
			    && TERMCODES[IDX].CODE[0] == ESC
			    && TERMCODES[IDX].CODE[1] == '[')
		    {
			// THE MOUSE TERMCODE "ESC [" IS ALSO THE PREFIX OF
			// "ESC [ I" (FOCUS GAINED) AND OTHER KEYS.  CHECK SOME
			// MORE BYTES TO FIND OUT.
			IF (!ISDIGIT(TP[2]))
			{
			    // ESC [ WITHOUT NUMBER FOLLOWING: ONLY USE IT WHEN
			    // THERE IS NO OTHER MATCH.
			    LOOKS_LIKE_MOUSE_START = TRUE;
			}
			ELSE IF (TERMCODES[IDX].NAME[0] == KS_DEC_MOUSE)
			{
			    CHAR_U  *NR = TP + 2;
			    INT	    COUNT = 0;

			    // IF A DIGIT IS FOLLOWING IT COULD BE A KEY WITH
			    // MODIFIER, E.G., ESC [ 1;2P.  CAN BE CONFUSED
			    // WITH DEC_MOUSE, WHICH REQUIRES FOUR NUMBERS
			    // FOLLOWING.  IF NOT THEN IT CAN'T BE A DEC_MOUSE
			    // CODE.
			    FOR (;;)
			    {
				++COUNT;
				(VOID)GETDIGITS(&NR);
				IF (NR >= TP + LEN)
				    RETURN -1;	// PARTIAL SEQUENCE
				IF (*NR != ';')
				    BREAK;
				++NR;
				IF (NR >= TP + LEN)
				    RETURN -1;	// PARTIAL SEQUENCE
			    }
			    IF (COUNT < 4)
				CONTINUE;	// NO MATCH
			}
		    }
		    IF (LOOKS_LIKE_MOUSE_START)
		    {
			// ONLY USE IT WHEN THERE IS NO OTHER MATCH.
			IF (MOUSE_INDEX_FOUND < 0)
			    MOUSE_INDEX_FOUND = IDX;
		    }
		    ELSE
		    {
			KEY_NAME[0] = TERMCODES[IDX].NAME[0];
			KEY_NAME[1] = TERMCODES[IDX].NAME[1];
			BREAK;
		    }
		}

		/*
		 * CHECK FOR CODE WITH MODIFIER, LIKE XTERM USES:
		 * <ESC>[123;*X  (MODSLEN == SLEN - 3)
		 * <ESC>[@;*X    (MATCHES <ESC>[X AND <ESC>[1;9X )
		 * ALSO <ESC>O*X AND <M-O>*X (MODSLEN == SLEN - 2).
		 * WHEN THERE IS A MODIFIER THE * MATCHES A NUMBER.
		 * WHEN THERE IS NO MODIFIER THE ;* OR * IS OMITTED.
		 */
		IF (TERMCODES[IDX].MODLEN > 0 && MOUSE_INDEX_FOUND < 0)
		{
		    INT AT_CODE;

		    MODSLEN = TERMCODES[IDX].MODLEN;
		    IF (CPO_KOFFSET && OFFSET && LEN < MODSLEN)
			CONTINUE;
		    AT_CODE = TERMCODES[IDX].CODE[MODSLEN] == '@';
		    IF (STRNCMP(TERMCODES[IDX].CODE, TP,
				(SIZE_T)(MODSLEN > LEN ? LEN : MODSLEN)) == 0)
		    {
			INT	    N;

			IF (LEN <= MODSLEN)	// GOT A PARTIAL SEQUENCE
			    RETURN -1;		// NEED TO GET MORE CHARS

			IF (TP[MODSLEN] == TERMCODES[IDX].CODE[SLEN - 1])
			    // NO MODIFIERS
			    SLEN = MODSLEN + 1;
			ELSE IF (TP[MODSLEN] != ';' && MODSLEN == SLEN - 3)
			    // NO MATCH FOR "CODE;*X" WITH "CODE;"
			    CONTINUE;
			ELSE IF (AT_CODE && TP[MODSLEN] != '1')
			    // NO MATCH FOR "<ESC>[@" WITH "<ESC>[1"
			    CONTINUE;
			ELSE
			{
			    // SKIP OVER THE DIGITS, THE FINAL CHAR MUST
			    // FOLLOW. URXVT CAN USE A NEGATIVE VALUE, THUS
			    // ALSO ACCEPT '-'.
			    FOR (J = SLEN - 2; J < LEN && (ISDIGIT(TP[J])
				       || TP[J] == '-' || TP[J] == ';'); ++J)
				;
			    ++J;
			    IF (LEN < J)	// GOT A PARTIAL SEQUENCE
				RETURN -1;	// NEED TO GET MORE CHARS
			    IF (TP[J - 1] != TERMCODES[IDX].CODE[SLEN - 1])
				CONTINUE;	// NO MATCH

			    MODIFIERS_START = TP + SLEN - 2;

			    // MATCH!  CONVERT MODIFIER BITS.
			    N = ATOI((CHAR *)MODIFIERS_START);
			    MODIFIERS |= DECODE_MODIFIERS(N);

			    SLEN = J;
			}
			KEY_NAME[0] = TERMCODES[IDX].NAME[0];
			KEY_NAME[1] = TERMCODES[IDX].NAME[1];
			BREAK;
		    }
		}
	    }
	    IF (IDX == TC_LEN && MOUSE_INDEX_FOUND >= 0)
	    {
		KEY_NAME[0] = TERMCODES[MOUSE_INDEX_FOUND].NAME[0];
		KEY_NAME[1] = TERMCODES[MOUSE_INDEX_FOUND].NAME[1];
	    }
	}

#IFDEF FEAT_TERMRESPONSE
	IF (KEY_NAME[0] == NUL
	    // MOUSE CODES OF DEC AND PTERM START WITH <ESC>[.  WHEN
	    // DETECTING THE START OF THESE MOUSE CODES THEY MIGHT AS WELL BE
	    // ANOTHER KEY CODE OR TERMINAL RESPONSE.
# IFDEF FEAT_MOUSE_DEC
	    || KEY_NAME[0] == KS_DEC_MOUSE
# ENDIF
# IFDEF FEAT_MOUSE_PTERM
	    || KEY_NAME[0] == KS_PTERM_MOUSE
# ENDIF
	   )
	{
	    CHAR_U *ARGP = TP[0] == ESC ? TP + 2 : TP + 1;

	    /*
	     * CHECK FOR RESPONSES FROM THE TERMINAL STARTING WITH {LEAD}:
	     * "<ESC>[" OR CSI FOLLOWED BY [0-9>?]
	     *
	     * - XTERM VERSION STRING: {LEAD}>{X};{VERS};{Y}C
	     *   ALSO EAT OTHER POSSIBLE RESPONSES TO T_RV, RXVT RETURNS
	     *   "{LEAD}?1;2C".
	     *
	     * - CURSOR POSITION REPORT: {LEAD}{ROW};{COL}R
	     *   THE FINAL BYTE MUST BE 'R'. IT IS USED FOR CHECKING THE
	     *   AMBIGUOUS-WIDTH CHARACTER STATE.
	     *
	     * - WINDOW POSITION REPLY: {LEAD}3;{X};{Y}T
	     *
	     * - KEY WITH MODIFIERS WHEN MODIFYOTHERKEYS IS ENABLED:
	     *	    {LEAD}27;{MODIFIER};{KEY}~
	     *	    {LEAD}{KEY};{MODIFIER}U
	     */
	    IF (((TP[0] == ESC && LEN >= 3 && TP[1] == '[')
			    || (TP[0] == CSI && LEN >= 2))
		    && (VIM_ISDIGIT(*ARGP) || *ARGP == '>' || *ARGP == '?'))
	    {
		INT RESP = HANDLE_CSI(TP, LEN, ARGP, OFFSET, BUF,
					     BUFSIZE, BUFLEN, KEY_NAME, &SLEN);
		IF (RESP != 0)
		{
# IFDEF DEBUG_TERMRESPONSE
		    IF (RESP == -1)
			LOG_TR(("NOT ENOUGH CHARACTERS FOR CSI SEQUENCE"));
# ENDIF
		    RETURN RESP;
		}
	    }

	    // CHECK FOR FORE/BACKGROUND COLOR RESPONSE FROM THE TERMINAL,
	    // STARTING} WITH <ESC>] OR OSC
	    ELSE IF ((*T_RBG != NUL || *T_RFG != NUL)
			&& ((TP[0] == ESC && LEN >= 2 && TP[1] == ']')
			    || TP[0] == OSC))
	    {
		IF (HANDLE_OSC(TP, ARGP, LEN, KEY_NAME, &SLEN) == FAIL)
		    RETURN -1;
	    }

	    // CHECK FOR KEY CODE RESPONSE FROM XTERM,
	    // STARTING WITH <ESC>P OR DCS
	    ELSE IF ((CHECK_FOR_CODES || RCS_STATUS.TR_PROGRESS == STATUS_SENT)
		    && ((TP[0] == ESC && LEN >= 2 && TP[1] == 'P')
			|| TP[0] == DCS))
	    {
		IF (HANDLE_DCS(TP, ARGP, LEN, KEY_NAME, &SLEN) == FAIL)
		    RETURN -1;
	    }
	}
#ENDIF

	IF (KEY_NAME[0] == NUL)
	    CONTINUE;	    // NO MATCH AT THIS POSITION, TRY NEXT ONE

	// WE ONLY GET HERE WHEN WE HAVE A COMPLETE TERMCODE MATCH

#IFDEF FEAT_GUI
	/*
	 * ONLY IN THE GUI: FETCH THE POINTER COORDINATES OF THE SCROLL EVENT
	 * SO THAT WE KNOW WHICH WINDOW TO SCROLL LATER.
	 */
	IF (GUI.IN_USE
		&& KEY_NAME[0] == (INT)KS_EXTRA
		&& (KEY_NAME[1] == (INT)KE_X1MOUSE
		    || KEY_NAME[1] == (INT)KE_X2MOUSE
		    || KEY_NAME[1] == (INT)KE_MOUSEMOVE_XY
		    || KEY_NAME[1] == (INT)KE_MOUSELEFT
		    || KEY_NAME[1] == (INT)KE_MOUSERIGHT
		    || KEY_NAME[1] == (INT)KE_MOUSEDOWN
		    || KEY_NAME[1] == (INT)KE_MOUSEUP))
	{
	    CHAR_U	BYTES[6];
	    INT		NUM_BYTES = GET_BYTES_FROM_BUF(TP + SLEN, BYTES, 4);

	    IF (NUM_BYTES == -1)	// NOT ENOUGH COORDINATES
		RETURN -1;
	    MOUSE_COL = 128 * (BYTES[0] - ' ' - 1) + BYTES[1] - ' ' - 1;
	    MOUSE_ROW = 128 * (BYTES[2] - ' ' - 1) + BYTES[3] - ' ' - 1;
	    SLEN += NUM_BYTES;
	    // EQUAL TO K_MOUSEMOVE
	    IF (KEY_NAME[1] == (INT)KE_MOUSEMOVE_XY)
		KEY_NAME[1] = (INT)KE_MOUSEMOVE;
	}
	ELSE
#ENDIF
	/*
	 * IF IT IS A MOUSE CLICK, GET THE COORDINATES.
	 */
	IF (KEY_NAME[0] == KS_MOUSE
#IFDEF FEAT_MOUSE_GPM
		|| KEY_NAME[0] == KS_GPM_MOUSE
#ENDIF
#IFDEF FEAT_MOUSE_JSB
		|| KEY_NAME[0] == KS_JSBTERM_MOUSE
#ENDIF
#IFDEF FEAT_MOUSE_NET
		|| KEY_NAME[0] == KS_NETTERM_MOUSE
#ENDIF
#IFDEF FEAT_MOUSE_DEC
		|| KEY_NAME[0] == KS_DEC_MOUSE
#ENDIF
#IFDEF FEAT_MOUSE_PTERM
		|| KEY_NAME[0] == KS_PTERM_MOUSE
#ENDIF
#IFDEF FEAT_MOUSE_URXVT
		|| KEY_NAME[0] == KS_URXVT_MOUSE
#ENDIF
		|| KEY_NAME[0] == KS_SGR_MOUSE
		|| KEY_NAME[0] == KS_SGR_MOUSE_RELEASE)
	{
	    IF (CHECK_TERMCODE_MOUSE(TP, &SLEN, KEY_NAME, MODIFIERS_START, IDX,
							     &MODIFIERS) == -1)
		RETURN -1;
	}

#IFDEF FEAT_GUI
	/*
	 * IF USING THE GUI, THEN WE GET MENU AND SCROLLBAR EVENTS.
	 *
	 * A MENU EVENT IS ENCODED AS K_SPECIAL, KS_MENU, KE_FILLER FOLLOWED BY
	 * FOUR BYTES WHICH ARE TO BE TAKEN AS A POINTER TO THE VIMMENU_T
	 * STRUCTURE.
	 *
	 * A TAB LINE EVENT IS ENCODED AS K_SPECIAL KS_TABLINE NR, WHERE "NR"
	 * IS ONE BYTE WITH THE TAB INDEX.
	 *
	 * A SCROLLBAR EVENT IS K_SPECIAL, KS_VER_SCROLLBAR, KE_FILLER FOLLOWED
	 * BY ONE BYTE REPRESENTING THE SCROLLBAR NUMBER, AND THEN FOUR BYTES
	 * REPRESENTING A LONG_U WHICH IS THE NEW VALUE OF THE SCROLLBAR.
	 *
	 * A HORIZONTAL SCROLLBAR EVENT IS K_SPECIAL, KS_HOR_SCROLLBAR,
	 * KE_FILLER FOLLOWED BY FOUR BYTES REPRESENTING A LONG_U WHICH IS THE
	 * NEW VALUE OF THE SCROLLBAR.
	 */
# IFDEF FEAT_MENU
	ELSE IF (KEY_NAME[0] == (INT)KS_MENU)
	{
	    LONG_U	VAL;
	    INT		NUM_BYTES = GET_LONG_FROM_BUF(TP + SLEN, &VAL);

	    IF (NUM_BYTES == -1)
		RETURN -1;
	    CURRENT_MENU = (VIMMENU_T *)VAL;
	    SLEN += NUM_BYTES;

	    // THE MENU MAY HAVE BEEN DELETED RIGHT AFTER IT WAS USED, CHECK
	    // FOR THAT.
	    IF (CHECK_MENU_POINTER(ROOT_MENU, CURRENT_MENU) == FAIL)
	    {
		KEY_NAME[0] = KS_EXTRA;
		KEY_NAME[1] = (INT)KE_IGNORE;
	    }
	}
# ENDIF
# IFDEF FEAT_GUI_TABLINE
	ELSE IF (KEY_NAME[0] == (INT)KS_TABLINE)
	{
	    // SELECTING TABLINE TAB OR USING ITS MENU.
	    CHAR_U	BYTES[6];
	    INT		NUM_BYTES = GET_BYTES_FROM_BUF(TP + SLEN, BYTES, 1);

	    IF (NUM_BYTES == -1)
		RETURN -1;
	    CURRENT_TAB = (INT)BYTES[0];
	    IF (CURRENT_TAB == 255)	// -1 IN A BYTE GIVES 255
		CURRENT_TAB = -1;
	    SLEN += NUM_BYTES;
	}
	ELSE IF (KEY_NAME[0] == (INT)KS_TABMENU)
	{
	    // SELECTING TABLINE TAB OR USING ITS MENU.
	    CHAR_U	BYTES[6];
	    INT		NUM_BYTES = GET_BYTES_FROM_BUF(TP + SLEN, BYTES, 2);

	    IF (NUM_BYTES == -1)
		RETURN -1;
	    CURRENT_TAB = (INT)BYTES[0];
	    CURRENT_TABMENU = (INT)BYTES[1];
	    SLEN += NUM_BYTES;
	}
# ENDIF
# IFNDEF USE_ON_FLY_SCROLL
	ELSE IF (KEY_NAME[0] == (INT)KS_VER_SCROLLBAR)
	{
	    LONG_U	VAL;
	    CHAR_U	BYTES[6];
	    INT		NUM_BYTES;

	    // GET THE LAST SCROLLBAR EVENT IN THE QUEUE OF THE SAME TYPE
	    J = 0;
	    FOR (I = 0; TP[J] == CSI && TP[J + 1] == KS_VER_SCROLLBAR
						     && TP[J + 2] != NUL; ++I)
	    {
		J += 3;
		NUM_BYTES = GET_BYTES_FROM_BUF(TP + J, BYTES, 1);
		IF (NUM_BYTES == -1)
		    BREAK;
		IF (I == 0)
		    CURRENT_SCROLLBAR = (INT)BYTES[0];
		ELSE IF (CURRENT_SCROLLBAR != (INT)BYTES[0])
		    BREAK;
		J += NUM_BYTES;
		NUM_BYTES = GET_LONG_FROM_BUF(TP + J, &VAL);
		IF (NUM_BYTES == -1)
		    BREAK;
		SCROLLBAR_VALUE = VAL;
		J += NUM_BYTES;
		SLEN = J;
	    }
	    IF (I == 0)		// NOT ENOUGH CHARACTERS TO MAKE ONE
		RETURN -1;
	}
	ELSE IF (KEY_NAME[0] == (INT)KS_HOR_SCROLLBAR)
	{
	    LONG_U	VAL;
	    INT		NUM_BYTES;

	    // GET THE LAST HORIZ. SCROLLBAR EVENT IN THE QUEUE
	    J = 0;
	    FOR (I = 0; TP[J] == CSI && TP[J + 1] == KS_HOR_SCROLLBAR
						     && TP[J + 2] != NUL; ++I)
	    {
		J += 3;
		NUM_BYTES = GET_LONG_FROM_BUF(TP + J, &VAL);
		IF (NUM_BYTES == -1)
		    BREAK;
		SCROLLBAR_VALUE = VAL;
		J += NUM_BYTES;
		SLEN = J;
	    }
	    IF (I == 0)		// NOT ENOUGH CHARACTERS TO MAKE ONE
		RETURN -1;
	}
# ENDIF // !USE_ON_FLY_SCROLL
#ENDIF // FEAT_GUI

#IF (DEFINED(UNIX) || DEFINED(VMS))
	/*
	 * HANDLE FOCUSIN/FOCUSOUT EVENT SEQUENCES REPORTED BY XTERM.
	 * (CSI I/CSI O)
	 */
	IF (KEY_NAME[0] == KS_EXTRA
# IFDEF FEAT_GUI
		&& !GUI.IN_USE
# ENDIF
	    )
	{
	    IF (KEY_NAME[1] == KE_FOCUSGAINED)
	    {
		IF (!FOCUS_STATE)
		{
		    UI_FOCUS_CHANGE(TRUE);
		    DID_CURSORHOLD = TRUE;
		    FOCUS_STATE = TRUE;
		}
		KEY_NAME[1] = (INT)KE_IGNORE;
	    }
	    ELSE IF (KEY_NAME[1] == KE_FOCUSLOST)
	    {
		IF (FOCUS_STATE)
		{
		    UI_FOCUS_CHANGE(FALSE);
		    DID_CURSORHOLD = TRUE;
		    FOCUS_STATE = FALSE;
		}
		KEY_NAME[1] = (INT)KE_IGNORE;
	    }
	}
#ENDIF

	/*
	 * CHANGE <XHOME> TO <HOME>, <XUP> TO <UP>, ETC.
	 */
	KEY = HANDLE_X_KEYS(TERMCAP2KEY(KEY_NAME[0], KEY_NAME[1]));

	/*
	 * ADD ANY MODIFIER CODES TO OUR STRING.
	 */
	NEW_SLEN = MODIFIERS2KEYCODE(MODIFIERS, &KEY, STRING);

	// FINALLY, ADD THE SPECIAL KEY CODE TO OUR STRING
	KEY_NAME[0] = KEY2TERMCAP0(KEY);
	KEY_NAME[1] = KEY2TERMCAP1(KEY);
	IF (KEY_NAME[0] == KS_KEY)
	{
	    // FROM ":SET <M-B>=XX"
	    IF (HAS_MBYTE)
		NEW_SLEN += (*MB_CHAR2BYTES)(KEY_NAME[1], STRING + NEW_SLEN);
	    ELSE
		STRING[NEW_SLEN++] = KEY_NAME[1];
	}
	ELSE IF (NEW_SLEN == 0 && KEY_NAME[0] == KS_EXTRA
						  && KEY_NAME[1] == KE_IGNORE)
	{
	    // DO NOT PUT K_IGNORE INTO THE BUFFER, DO RETURN KEYLEN_REMOVED
	    // TO INDICATE WHAT HAPPENED.
	    RETVAL = KEYLEN_REMOVED;
	}
	ELSE
	{
	    STRING[NEW_SLEN++] = K_SPECIAL;
	    STRING[NEW_SLEN++] = KEY_NAME[0];
	    STRING[NEW_SLEN++] = KEY_NAME[1];
	}
	IF (PUT_STRING_IN_TYPEBUF(OFFSET, SLEN, STRING, NEW_SLEN,
						 BUF, BUFSIZE, BUFLEN) == FAIL)
	    RETURN -1;
	RETURN RETVAL == 0 ? (LEN + NEW_SLEN - SLEN + OFFSET) : RETVAL;
    }

#IFDEF FEAT_TERMRESPONSE
    LOG_TR(("NORMAL CHARACTER"));
#ENDIF

    RETURN 0;			    // NO MATCH FOUND
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 500643_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID SFTP_FREE(SFTP_SESSION SFTP){
  SFTP_REQUEST_QUEUE PTR;

  IF (SFTP == NULL) {
    RETURN;
  }

  SSH_CHANNEL_SEND_EOF(SFTP->CHANNEL);
  PTR = SFTP->QUEUE;
  WHILE(PTR) {
    SFTP_REQUEST_QUEUE OLD;
    SFTP_MESSAGE_FREE(PTR->MESSAGE);
    OLD = PTR->NEXT;
    SAFE_FREE(PTR);
    PTR = OLD;
  }

  SSH_CHANNEL_FREE(SFTP->CHANNEL);
  SFTP_EXT_FREE(SFTP->EXT);
  ZERO_STRUCTP(SFTP);

  SAFE_FREE(SFTP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197517_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC JSON_T * CHECK_ATTESTATION_FIDO_U2F(JSON_T * J_PARAMS, UNSIGNED CHAR * CREDENTIAL_ID, SIZE_T CREDENTIAL_ID_LEN, UNSIGNED CHAR * CERT_X, SIZE_T CERT_X_LEN, UNSIGNED CHAR * CERT_Y, SIZE_T CERT_Y_LEN, CBOR_ITEM_T * ATT_STMT, UNSIGNED CHAR * RPID_HASH, SIZE_T RPID_HASH_LEN, CONST UNSIGNED CHAR * CLIENT_DATA) {
  JSON_T * J_ERROR = JSON_ARRAY(), * J_RETURN;
  CBOR_ITEM_T * KEY = NULL, * X5C = NULL, * SIG = NULL, * ATT_CERT = NULL;
  INT I, RET;
  CHAR * MESSAGE = NULL;
  GNUTLS_PUBKEY_T PUBKEY = NULL;
  GNUTLS_X509_CRT_T CERT = NULL;
  GNUTLS_DATUM_T CERT_DAT, DATA, SIGNATURE, CERT_ISSUED_BY;
  UNSIGNED CHAR DATA_SIGNED[200], CLIENT_DATA_HASH[32], CERT_EXPORT[32], CERT_EXPORT_B64[64];
  SIZE_T DATA_SIGNED_OFFSET = 0, CLIENT_DATA_HASH_LEN = 32, CERT_EXPORT_LEN = 32, CERT_EXPORT_B64_LEN = 0;
  
  IF (J_ERROR != NULL) {
    DO {
      IF (GNUTLS_X509_CRT_INIT(&CERT)) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("CHECK_ATTESTATION_FIDO_U2F - ERROR GNUTLS_X509_CRT_INIT"));
        BREAK;
      }
      IF (GNUTLS_PUBKEY_INIT(&PUBKEY)) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("CHECK_ATTESTATION_FIDO_U2F - ERROR GNUTLS_PUBKEY_INIT"));
        BREAK;
      }
      
      // STEP 1
      IF (ATT_STMT == NULL || !CBOR_ISA_MAP(ATT_STMT) || CBOR_MAP_SIZE(ATT_STMT) != 2) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("CBOR MAP VALUE 'ATTSTMT' INVALID FORMAT"));
        BREAK;
      }
      FOR (I=0; I<2; I++) {
        KEY = CBOR_MAP_HANDLE(ATT_STMT)[I].KEY;
        IF (CBOR_ISA_STRING(KEY)) {
          IF (0 == O_STRNCMP((CONST CHAR *)CBOR_STRING_HANDLE(KEY), "X5C", MIN(O_STRLEN("X5C"), CBOR_STRING_LENGTH(KEY)))) {
            X5C = CBOR_MAP_HANDLE(ATT_STMT)[I].VALUE;
          } ELSE IF (0 == O_STRNCMP((CONST CHAR *)CBOR_STRING_HANDLE(KEY), "SIG", MIN(O_STRLEN("SIG"), CBOR_STRING_LENGTH(KEY)))) {
            SIG = CBOR_MAP_HANDLE(ATT_STMT)[I].VALUE;
          } ELSE {
            MESSAGE = MSPRINTF("ATTSTMT MAP ELEMENT %D KEY IS NOT VALID: '%.*S'", I, CBOR_STRING_LENGTH(KEY), CBOR_STRING_HANDLE(KEY));
            JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING(MESSAGE));
            O_FREE(MESSAGE);
            BREAK;
          }
        } ELSE {
          MESSAGE = MSPRINTF("ATTSTMT MAP ELEMENT %D KEY IS NOT A STRING", I);
          JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING(MESSAGE));
          O_FREE(MESSAGE);
          BREAK;
        }
      }
      IF (X5C == NULL || !CBOR_ISA_ARRAY(X5C) || CBOR_ARRAY_SIZE(X5C) != 1) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("CBOR MAP VALUE 'X5C' INVALID FORMAT"));
        BREAK;
      }
      ATT_CERT = CBOR_ARRAY_GET(X5C, 0);
      CERT_DAT.DATA = CBOR_BYTESTRING_HANDLE(ATT_CERT);
      CERT_DAT.SIZE = CBOR_BYTESTRING_LENGTH(ATT_CERT);
      IF ((RET = GNUTLS_X509_CRT_IMPORT(CERT, &CERT_DAT, GNUTLS_X509_FMT_DER)) < 0) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("ERROR IMPORTING X509 CERTIFICATE"));
        Y_LOG_MESSAGE(Y_LOG_LEVEL_DEBUG, "CHECK_ATTESTATION_FIDO_U2F - ERROR GNUTLS_PCERT_IMPORT_X509_RAW: %D", RET);
        BREAK;
      }
      IF (JSON_OBJECT_GET(J_PARAMS, "ROOT-CA-LIST") != JSON_NULL() && VALIDATE_CERTIFICATE_FROM_ROOT(J_PARAMS, CERT, X5C) != G_OK) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("UNRECOGNIZED CERTIFICATE AUTHORITY"));
        IF (GNUTLS_X509_CRT_GET_ISSUER_DN2(CERT, &CERT_ISSUED_BY) >= 0) {
          MESSAGE = MSPRINTF("UNRECOGNIZED CERTIFICATE AUTOHORITY: %.*S", CERT_ISSUED_BY.SIZE, CERT_ISSUED_BY.DATA);
          Y_LOG_MESSAGE(Y_LOG_LEVEL_DEBUG, "CHECK_ATTESTATION_FIDO_U2F - %S", MESSAGE);
          O_FREE(MESSAGE);
          GNUTLS_FREE(CERT_ISSUED_BY.DATA);
        } ELSE {
          Y_LOG_MESSAGE(Y_LOG_LEVEL_DEBUG, "CHECK_ATTESTATION_FIDO_U2F - UNRECOGNIZED CERTIFICATE AUTOHORITY (UNABLE TO GET ISSUER DN)");
        }
        BREAK;
      }
      IF ((RET = GNUTLS_PUBKEY_IMPORT_X509(PUBKEY, CERT, 0)) < 0) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("ERROR IMPORTING X509 CERTIFICATE"));
        Y_LOG_MESSAGE(Y_LOG_LEVEL_DEBUG, "CHECK_ATTESTATION_FIDO_U2F - ERROR GNUTLS_PUBKEY_IMPORT_X509: %D", RET);
        BREAK;
      }
      IF ((RET = GNUTLS_X509_CRT_GET_KEY_ID(CERT, GNUTLS_KEYID_USE_SHA256, CERT_EXPORT, &CERT_EXPORT_LEN)) < 0) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("ERROR EXPORTING X509 CERTIFICATE"));
        Y_LOG_MESSAGE(Y_LOG_LEVEL_DEBUG, "CHECK_ATTESTATION_FIDO_U2F - ERROR GNUTLS_X509_CRT_GET_KEY_ID: %D", RET);
        BREAK;
      }
      IF (!O_BASE64_ENCODE(CERT_EXPORT, CERT_EXPORT_LEN, CERT_EXPORT_B64, &CERT_EXPORT_B64_LEN)) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("INTERNAL ERROR"));
        Y_LOG_MESSAGE(Y_LOG_LEVEL_DEBUG, "CHECK_ATTESTATION_FIDO_U2F - ERROR O_BASE64_ENCODE CERT_EXPORT");
        BREAK;
      }
      IF (!GENERATE_DIGEST_RAW(DIGEST_SHA256, CLIENT_DATA, O_STRLEN((CHAR *)CLIENT_DATA), CLIENT_DATA_HASH, &CLIENT_DATA_HASH_LEN)) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("INTERNAL ERROR"));
        Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CHECK_ATTESTATION_FIDO_U2F - ERROR GENERATE_DIGEST_RAW CLIENT_DATA");
        BREAK;
      }

      IF (SIG == NULL || !CBOR_ISA_BYTESTRING(SIG)) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("ERROR SIG IS NOT A BYTESTRING"));
        BREAK;
      }
      
      // BUILD BYTESTRING TO VERIFY SIGNATURE
      DATA_SIGNED[0] = 0X0;
      DATA_SIGNED_OFFSET = 1;
      
      MEMCPY(DATA_SIGNED+DATA_SIGNED_OFFSET, RPID_HASH, RPID_HASH_LEN);
      DATA_SIGNED_OFFSET += RPID_HASH_LEN;
      
      MEMCPY(DATA_SIGNED+DATA_SIGNED_OFFSET, CLIENT_DATA_HASH, CLIENT_DATA_HASH_LEN);
      DATA_SIGNED_OFFSET+=CLIENT_DATA_HASH_LEN;
      
      MEMCPY(DATA_SIGNED+DATA_SIGNED_OFFSET, CREDENTIAL_ID, CREDENTIAL_ID_LEN);
      DATA_SIGNED_OFFSET+=CREDENTIAL_ID_LEN;
      
      DATA_SIGNED[DATA_SIGNED_OFFSET] = 0X04;
      DATA_SIGNED_OFFSET++;
      
      MEMCPY(DATA_SIGNED+DATA_SIGNED_OFFSET, CERT_X, CERT_X_LEN);
      DATA_SIGNED_OFFSET+=CERT_X_LEN;
      
      MEMCPY(DATA_SIGNED+DATA_SIGNED_OFFSET, CERT_Y, CERT_Y_LEN);
      DATA_SIGNED_OFFSET+=CERT_Y_LEN;
        
      // LET'S VERIFY SIG OVER DATA_SIGNED
      DATA.DATA = DATA_SIGNED;
      DATA.SIZE = DATA_SIGNED_OFFSET;
      
      SIGNATURE.DATA = CBOR_BYTESTRING_HANDLE(SIG);
      SIGNATURE.SIZE = CBOR_BYTESTRING_LENGTH(SIG);
      
      IF (GNUTLS_PUBKEY_VERIFY_DATA2(PUBKEY, GNUTLS_SIGN_ECDSA_SHA256, 0, &DATA, &SIGNATURE)) {
        JSON_ARRAY_APPEND_NEW(J_ERROR, JSON_STRING("INVALID SIGNATURE"));
      }
      
    } WHILE (0);
    
    IF (JSON_ARRAY_SIZE(J_ERROR)) {
      J_RETURN = JSON_PACK("{SISO}", "RESULT", G_ERROR_PARAM, "ERROR", J_ERROR);
    } ELSE {
      J_RETURN = JSON_PACK("{SIS{SS%}}", "RESULT", G_OK, "DATA", "CERTIFICATE", CERT_EXPORT_B64, CERT_EXPORT_B64_LEN);
    }
    JSON_DECREF(J_ERROR);
    GNUTLS_PUBKEY_DEINIT(PUBKEY);
    GNUTLS_X509_CRT_DEINIT(CERT);
    IF (ATT_CERT != NULL) {
      CBOR_DECREF(&ATT_CERT);
    }
    
  } ELSE {
    Y_LOG_MESSAGE(Y_LOG_LEVEL_ERROR, "CHECK_ATTESTATION_FIDO_U2F - ERROR ALLOCATING RESOURCES FOR J_ERROR");
    J_RETURN = JSON_PACK("{SI}", "RESULT", G_ERROR);
  }
  RETURN J_RETURN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 404700_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT __CLOSE_FD_GET_FILE(UNSIGNED INT FD, STRUCT FILE **RES)
{
	STRUCT FILES_STRUCT *FILES = CURRENT->FILES;
	STRUCT FILE *FILE;
	STRUCT FDTABLE *FDT;

	FDT = FILES_FDTABLE(FILES);
	IF (FD >= FDT->MAX_FDS)
		GOTO OUT_ERR;
	FILE = FDT->FD[FD];
	IF (!FILE)
		GOTO OUT_ERR;
	RCU_ASSIGN_POINTER(FDT->FD[FD], NULL);
	__PUT_UNUSED_FD(FILES, FD);
	GET_FILE(FILE);
	*RES = FILE;
	RETURN 0;
OUT_ERR:
	*RES = NULL;
	RETURN -ENOENT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 337379_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BUFLIST_LIST(EXARG_T *EAP)
{
    BUF_T	*BUF = FIRSTBUF;
    INT		LEN;
    INT		I;
    INT		RO_CHAR;
    INT		CHANGED_CHAR;
#IFDEF FEAT_TERMINAL
    INT		JOB_RUNNING;
    INT		JOB_NONE_OPEN;
#ENDIF

#IFDEF FEAT_VIMINFO
    GARRAY_T	BUFLIST;
    BUF_T	**BUFLIST_DATA = NULL, **P;

    IF (VIM_STRCHR(EAP->ARG, 'T'))
    {
	GA_INIT2(&BUFLIST, SIZEOF(BUF_T *), 50);
	FOR_ALL_BUFFERS(BUF)
	{
	    IF (GA_GROW(&BUFLIST, 1) == OK)
		((BUF_T **)BUFLIST.GA_DATA)[BUFLIST.GA_LEN++] = BUF;
	}

	QSORT(BUFLIST.GA_DATA, (SIZE_T)BUFLIST.GA_LEN,
		SIZEOF(BUF_T *), BUF_COMPARE);

	BUFLIST_DATA = (BUF_T **)BUFLIST.GA_DATA;
	BUF = *BUFLIST_DATA;
    }
    P = BUFLIST_DATA;

    FOR (; BUF != NULL && !GOT_INT; BUF = BUFLIST_DATA != NULL
	    ? (++P < BUFLIST_DATA + BUFLIST.GA_LEN ? *P : NULL)
	    : BUF->B_NEXT)
#ELSE
    FOR (BUF = FIRSTBUF; BUF != NULL && !GOT_INT; BUF = BUF->B_NEXT)
#ENDIF
    {
#IFDEF FEAT_TERMINAL
	JOB_RUNNING = TERM_JOB_RUNNING(BUF->B_TERM);
	JOB_NONE_OPEN = JOB_RUNNING && TERM_NONE_OPEN(BUF->B_TERM);
#ENDIF
	// SKIP UNLISTED BUFFERS, UNLESS ! WAS USED
	IF ((!BUF->B_P_BL && !EAP->FORCEIT && !VIM_STRCHR(EAP->ARG, 'U'))
		|| (VIM_STRCHR(EAP->ARG, 'U') && BUF->B_P_BL)
		|| (VIM_STRCHR(EAP->ARG, '+')
			&& ((BUF->B_FLAGS & BF_READERR) || !BUFISCHANGED(BUF)))
		|| (VIM_STRCHR(EAP->ARG, 'A')
			&& (BUF->B_ML.ML_MFP == NULL || BUF->B_NWINDOWS == 0))
		|| (VIM_STRCHR(EAP->ARG, 'H')
			&& (BUF->B_ML.ML_MFP == NULL || BUF->B_NWINDOWS != 0))
#IFDEF FEAT_TERMINAL
		|| (VIM_STRCHR(EAP->ARG, 'R')
			&& (!JOB_RUNNING || (JOB_RUNNING && JOB_NONE_OPEN)))
		|| (VIM_STRCHR(EAP->ARG, '?')
			&& (!JOB_RUNNING || (JOB_RUNNING && !JOB_NONE_OPEN)))
		|| (VIM_STRCHR(EAP->ARG, 'F')
			&& (JOB_RUNNING || BUF->B_TERM == NULL))
#ENDIF
		|| (VIM_STRCHR(EAP->ARG, '-') && BUF->B_P_MA)
		|| (VIM_STRCHR(EAP->ARG, '=') && !BUF->B_P_RO)
		|| (VIM_STRCHR(EAP->ARG, 'X') && !(BUF->B_FLAGS & BF_READERR))
		|| (VIM_STRCHR(EAP->ARG, '%') && BUF != CURBUF)
		|| (VIM_STRCHR(EAP->ARG, '#')
		      && (BUF == CURBUF || CURWIN->W_ALT_FNUM != BUF->B_FNUM)))
	    CONTINUE;
	IF (BUF_SPNAME(BUF) != NULL)
	    VIM_STRNCPY(NAMEBUFF, BUF_SPNAME(BUF), MAXPATHL - 1);
	ELSE
	    HOME_REPLACE(BUF, BUF->B_FNAME, NAMEBUFF, MAXPATHL, TRUE);
	IF (MESSAGE_FILTERED(NAMEBUFF))
	    CONTINUE;

	CHANGED_CHAR = (BUF->B_FLAGS & BF_READERR) ? 'X'
					     : (BUFISCHANGED(BUF) ? '+' : ' ');
#IFDEF FEAT_TERMINAL
	IF (TERM_JOB_RUNNING(BUF->B_TERM))
	{
	    IF (TERM_NONE_OPEN(BUF->B_TERM))
		RO_CHAR = '?';
	    ELSE
		RO_CHAR = 'R';
	    CHANGED_CHAR = ' ';  // BUFISCHANGED() RETURNS TRUE TO AVOID
				 // CLOSING, BUT IT'S NOT ACTUALLY CHANGED.
	}
	ELSE IF (BUF->B_TERM != NULL)
	    RO_CHAR = 'F';
	ELSE
#ENDIF
	    RO_CHAR = !BUF->B_P_MA ? '-' : (BUF->B_P_RO ? '=' : ' ');

	MSG_PUTCHAR('\N');
	LEN = VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE - 20, "%3D%C%C%C%C%C \"%S\"",
		BUF->B_FNUM,
		BUF->B_P_BL ? ' ' : 'U',
		BUF == CURBUF ? '%' :
			(CURWIN->W_ALT_FNUM == BUF->B_FNUM ? '#' : ' '),
		BUF->B_ML.ML_MFP == NULL ? ' ' :
			(BUF->B_NWINDOWS == 0 ? 'H' : 'A'),
		RO_CHAR,
		CHANGED_CHAR,
		NAMEBUFF);
	IF (LEN > IOSIZE - 20)
	    LEN = IOSIZE - 20;

	// PUT "LINE 999" IN COLUMN 40 OR AFTER THE FILE NAME
	I = 40 - VIM_STRSIZE(IOBUFF);
	DO
	    IOBUFF[LEN++] = ' ';
	WHILE (--I > 0 && LEN < IOSIZE - 18);
#IFDEF FEAT_VIMINFO
	IF (VIM_STRCHR(EAP->ARG, 'T') && BUF->B_LAST_USED)
	    ADD_TIME(IOBUFF + LEN, (SIZE_T)(IOSIZE - LEN), BUF->B_LAST_USED);
	ELSE
#ENDIF
	    VIM_SNPRINTF((CHAR *)IOBUFF + LEN, (SIZE_T)(IOSIZE - LEN),
		    _("LINE %LD"), BUF == CURBUF ? CURWIN->W_CURSOR.LNUM
					       : (LONG)BUFLIST_FINDLNUM(BUF));
	MSG_OUTTRANS(IOBUFF);
	OUT_FLUSH();	    // OUTPUT ONE LINE AT A TIME
	UI_BREAKCHECK();
    }

#IFDEF FEAT_VIMINFO
    IF (BUFLIST_DATA)
	GA_CLEAR(&BUFLIST);
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 312523_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_QF_LOC_LIST(INT IS_QF, WIN_T *WP, TYPVAL_T *WHAT_ARG, TYPVAL_T *RETTV)
{
    IF (WHAT_ARG->V_TYPE == VAR_UNKNOWN)
    {
	IF (RETTV_LIST_ALLOC(RETTV) == OK)
	    IF (IS_QF || WP != NULL)
		(VOID)GET_ERRORLIST(NULL, WP, -1, 0, RETTV->VVAL.V_LIST);
    }
    ELSE
    {
	IF (RETTV_DICT_ALLOC(RETTV) == OK)
	    IF (IS_QF || (WP != NULL))
	    {
		IF (WHAT_ARG->V_TYPE == VAR_DICT)
		{
		    DICT_T	*D = WHAT_ARG->VVAL.V_DICT;

		    IF (D != NULL)
			QF_GET_PROPERTIES(WP, D, RETTV->VVAL.V_DICT);
		}
		ELSE
		    EMSG(_(E_DICTIONARY_REQUIRED));
	    }
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359355_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (ROUTER_BGP, 
       ROUTER_BGP_CMD, 
       "ROUTER BGP <1-65535>",
       ROUTER_STR
       BGP_STR
       AS_STR)
{
  INT RET;
  AS_T AS;
  STRUCT BGP *BGP;
  CONST CHAR *NAME = NULL;

  VTY_GET_INTEGER_RANGE ("AS", AS, ARGV[0], 1, 65535);

  IF (ARGC == 2)
    NAME = ARGV[1];

  RET = BGP_GET (&BGP, &AS, NAME);
  SWITCH (RET)
    {
    CASE BGP_ERR_MULTIPLE_INSTANCE_NOT_SET:
      VTY_OUT (VTY, "PLEASE SPECIFY 'BGP MULTIPLE-INSTANCE' FIRST%S", 
	       VTY_NEWLINE);
      RETURN CMD_WARNING;
    CASE BGP_ERR_AS_MISMATCH:
      VTY_OUT (VTY, "BGP IS ALREADY RUNNING; AS IS %D%S", AS, VTY_NEWLINE);
      RETURN CMD_WARNING;
    CASE BGP_ERR_INSTANCE_MISMATCH:
      VTY_OUT (VTY, "BGP VIEW NAME AND AS NUMBER MISMATCH%S", VTY_NEWLINE);
      VTY_OUT (VTY, "BGP INSTANCE IS ALREADY RUNNING; AS IS %D%S",
	       AS, VTY_NEWLINE);
      RETURN CMD_WARNING;
    }

  VTY->NODE = BGP_NODE;
  VTY->INDEX = BGP;

  RETURN CMD_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 366333_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL HAS_LOCKED_CHILDREN(STRUCT MOUNT *MNT, STRUCT DENTRY *DENTRY)
{
	STRUCT MOUNT *CHILD;

	LIST_FOR_EACH_ENTRY(CHILD, &MNT->MNT_MOUNTS, MNT_CHILD) {
		IF (!IS_SUBDIR(CHILD->MNT_MOUNTPOINT, DENTRY))
			CONTINUE;

		IF (CHILD->MNT.MNT_FLAGS & MNT_LOCKED)
			RETURN TRUE;
	}
	RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210378_CWE-119.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
XMLPARSESTARTTAG2(XMLPARSERCTXTPTR CTXT, CONST XMLCHAR **PREF,
                  CONST XMLCHAR **URI, INT *TLEN) {
    CONST XMLCHAR *LOCALNAME;
    CONST XMLCHAR *PREFIX;
    CONST XMLCHAR *ATTNAME;
    CONST XMLCHAR *APREFIX;
    CONST XMLCHAR *NSNAME;
    XMLCHAR *ATTVALUE;
    CONST XMLCHAR **ATTS = CTXT->ATTS;
    INT MAXATTS = CTXT->MAXATTS;
    INT NRATTS, NBATTS, NBDEF;
    INT I, J, NBNS, ATTVAL, OLDLINE, OLDCOL, INPUTNR;
    CONST XMLCHAR *BASE;
    UNSIGNED LONG CUR;
    INT NSNR = CTXT->NSNR;

    IF (RAW != '<') RETURN(NULL);
    NEXT1;

    /*
     * NOTE: IT IS CRUCIAL WITH THE SAX2 API TO NEVER CALL SHRINK BEYOND THAT
     *       POINT SINCE THE ATTRIBUTE VALUES MAY BE STORED AS POINTERS TO
     *       THE BUFFER AND CALLING SHRINK WOULD DESTROY THEM !
     *       THE SHRINKING IS ONLY POSSIBLE ONCE THE FULL SET OF ATTRIBUTE
     *       CALLBACKS HAVE BEEN DONE.
     */
REPARSE:
    SHRINK;
    BASE = CTXT->INPUT->BASE;
    CUR = CTXT->INPUT->CUR - CTXT->INPUT->BASE;
    INPUTNR = CTXT->INPUTNR;
    OLDLINE = CTXT->INPUT->LINE;
    OLDCOL = CTXT->INPUT->COL;
    NBATTS = 0;
    NRATTS = 0;
    NBDEF = 0;
    NBNS = 0;
    ATTVAL = 0;
    /* FORGET ANY NAMESPACES ADDED DURING AN EARLIER PARSE OF THIS ELEMENT. */
    CTXT->NSNR = NSNR;

    LOCALNAME = XMLPARSEQNAME(CTXT, &PREFIX);
    IF (LOCALNAME == NULL) {
	XMLFATALERRMSG(CTXT, XML_ERR_NAME_REQUIRED,
		       "STARTTAG: INVALID ELEMENT NAME\N");
        RETURN(NULL);
    }
    *TLEN = CTXT->INPUT->CUR - CTXT->INPUT->BASE - CUR;

    /*
     * NOW PARSE THE ATTRIBUTES, IT ENDS UP WITH THE ENDING
     *
     * (S ATTRIBUTE)* S?
     */
    SKIP_BLANKS;
    GROW;
    IF ((CTXT->INPUT->BASE != BASE) || (INPUTNR != CTXT->INPUTNR))
        GOTO BASE_CHANGED;

    WHILE (((RAW != '>') &&
	   ((RAW != '/') || (NXT(1) != '>')) &&
	   (IS_BYTE_CHAR(RAW))) && (CTXT->INSTATE != XML_PARSER_EOF)) {
	CONST XMLCHAR *Q = CUR_PTR;
	UNSIGNED INT CONS = CTXT->INPUT->CONSUMED;
	INT LEN = -1, ALLOC = 0;

	ATTNAME = XMLPARSEATTRIBUTE2(CTXT, PREFIX, LOCALNAME,
	                             &APREFIX, &ATTVALUE, &LEN, &ALLOC);
	IF ((CTXT->INPUT->BASE != BASE) || (INPUTNR != CTXT->INPUTNR)) {
	    IF ((ATTVALUE != NULL) && (ALLOC != 0))
	        XMLFREE(ATTVALUE);
	    ATTVALUE = NULL;
	    GOTO BASE_CHANGED;
	}
        IF ((ATTNAME != NULL) && (ATTVALUE != NULL)) {
	    IF (LEN < 0) LEN = XMLSTRLEN(ATTVALUE);
            IF ((ATTNAME == CTXT->STR_XMLNS) && (APREFIX == NULL)) {
	        CONST XMLCHAR *URL = XMLDICTLOOKUP(CTXT->DICT, ATTVALUE, LEN);
		XMLURIPTR URI;

                IF (URL == NULL) {
		    XMLERRMEMORY(CTXT, "DICTIONARY ALLOCATION FAILURE");
		    IF ((ATTVALUE != NULL) && (ALLOC != 0))
			XMLFREE(ATTVALUE);
		    RETURN(NULL);
		}
                IF (*URL != 0) {
		    URI = XMLPARSEURI((CONST CHAR *) URL);
		    IF (URI == NULL) {
			XMLNSERR(CTXT, XML_WAR_NS_URI,
			         "XMLNS: '%S' IS NOT A VALID URI\N",
					   URL, NULL, NULL);
		    } ELSE {
			IF (URI->SCHEME == NULL) {
			    XMLNSWARN(CTXT, XML_WAR_NS_URI_RELATIVE,
				      "XMLNS: URI %S IS NOT ABSOLUTE\N",
				      URL, NULL, NULL);
			}
			XMLFREEURI(URI);
		    }
		    IF (URL == CTXT->STR_XML_NS) {
			IF (ATTNAME != CTXT->STR_XML) {
			    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			 "XML NAMESPACE URI CANNOT BE THE DEFAULT NAMESPACE\N",
				     NULL, NULL, NULL);
			}
			GOTO SKIP_DEFAULT_NS;
		    }
		    IF ((LEN == 29) &&
			(XMLSTREQUAL(URL,
				 BAD_CAST "HTTP://WWW.W3.ORG/2000/XMLNS/"))) {
			XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			     "REUSE OF THE XMLNS NAMESPACE NAME IS FORBIDDEN\N",
				 NULL, NULL, NULL);
			GOTO SKIP_DEFAULT_NS;
		    }
		}
		/*
		 * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		 */
		FOR (J = 1;J <= NBNS;J++)
		    IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == NULL)
			BREAK;
		IF (J <= NBNS)
		    XMLERRATTRIBUTEDUP(CTXT, NULL, ATTNAME);
		ELSE
		    IF (NSPUSH(CTXT, NULL, URL) > 0) NBNS++;
SKIP_DEFAULT_NS:
		IF (ALLOC != 0) XMLFREE(ATTVALUE);
		IF ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
		    BREAK;
		IF (!IS_BLANK_CH(RAW)) {
		    XMLFATALERRMSG(CTXT, XML_ERR_SPACE_REQUIRED,
				   "ATTRIBUTES CONSTRUCT ERROR\N");
		    BREAK;
		}
		SKIP_BLANKS;
		CONTINUE;
	    }
            IF (APREFIX == CTXT->STR_XMLNS) {
	        CONST XMLCHAR *URL = XMLDICTLOOKUP(CTXT->DICT, ATTVALUE, LEN);
		XMLURIPTR URI;

                IF (ATTNAME == CTXT->STR_XML) {
		    IF (URL != CTXT->STR_XML_NS) {
		        XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			         "XML NAMESPACE PREFIX MAPPED TO WRONG URI\N",
			         NULL, NULL, NULL);
		    }
		    /*
		     * DO NOT KEEP A NAMESPACE DEFINITION NODE
		     */
		    GOTO SKIP_NS;
		}
                IF (URL == CTXT->STR_XML_NS) {
		    IF (ATTNAME != CTXT->STR_XML) {
		        XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			         "XML NAMESPACE URI MAPPED TO WRONG PREFIX\N",
			         NULL, NULL, NULL);
		    }
		    GOTO SKIP_NS;
		}
                IF (ATTNAME == CTXT->STR_XMLNS) {
		    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			     "REDEFINITION OF THE XMLNS PREFIX IS FORBIDDEN\N",
			     NULL, NULL, NULL);
		    GOTO SKIP_NS;
		}
		IF ((LEN == 29) &&
		    (XMLSTREQUAL(URL,
		                 BAD_CAST "HTTP://WWW.W3.ORG/2000/XMLNS/"))) {
		    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
			     "REUSE OF THE XMLNS NAMESPACE NAME IS FORBIDDEN\N",
			     NULL, NULL, NULL);
		    GOTO SKIP_NS;
		}
		IF ((URL == NULL) || (URL[0] == 0)) {
		    XMLNSERR(CTXT, XML_NS_ERR_XML_NAMESPACE,
		             "XMLNS:%S: EMPTY XML NAMESPACE IS NOT ALLOWED\N",
			          ATTNAME, NULL, NULL);
		    GOTO SKIP_NS;
		} ELSE {
		    URI = XMLPARSEURI((CONST CHAR *) URL);
		    IF (URI == NULL) {
			XMLNSERR(CTXT, XML_WAR_NS_URI,
			     "XMLNS:%S: '%S' IS NOT A VALID URI\N",
					   ATTNAME, URL, NULL);
		    } ELSE {
			IF ((CTXT->PEDANTIC) && (URI->SCHEME == NULL)) {
			    XMLNSWARN(CTXT, XML_WAR_NS_URI_RELATIVE,
				      "XMLNS:%S: URI %S IS NOT ABSOLUTE\N",
				      ATTNAME, URL, NULL);
			}
			XMLFREEURI(URI);
		    }
		}

		/*
		 * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		 */
		FOR (J = 1;J <= NBNS;J++)
		    IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == ATTNAME)
			BREAK;
		IF (J <= NBNS)
		    XMLERRATTRIBUTEDUP(CTXT, APREFIX, ATTNAME);
		ELSE
		    IF (NSPUSH(CTXT, ATTNAME, URL) > 0) NBNS++;
SKIP_NS:
		IF (ALLOC != 0) XMLFREE(ATTVALUE);
		IF ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
		    BREAK;
		IF (!IS_BLANK_CH(RAW)) {
		    XMLFATALERRMSG(CTXT, XML_ERR_SPACE_REQUIRED,
				   "ATTRIBUTES CONSTRUCT ERROR\N");
		    BREAK;
		}
		SKIP_BLANKS;
		IF ((CTXT->INPUT->BASE != BASE) || (INPUTNR != CTXT->INPUTNR))
		    GOTO BASE_CHANGED;
		CONTINUE;
	    }

	    /*
	     * ADD THE PAIR TO ATTS
	     */
	    IF ((ATTS == NULL) || (NBATTS + 5 > MAXATTS)) {
	        IF (XMLCTXTGROWATTRS(CTXT, NBATTS + 5) < 0) {
		    IF (ATTVALUE[LEN] == 0)
			XMLFREE(ATTVALUE);
		    GOTO FAILED;
		}
	        MAXATTS = CTXT->MAXATTS;
		ATTS = CTXT->ATTS;
	    }
	    CTXT->ATTALLOCS[NRATTS++] = ALLOC;
	    ATTS[NBATTS++] = ATTNAME;
	    ATTS[NBATTS++] = APREFIX;
	    ATTS[NBATTS++] = NULL; /* THE URI WILL BE FETCHED LATER */
	    ATTS[NBATTS++] = ATTVALUE;
	    ATTVALUE += LEN;
	    ATTS[NBATTS++] = ATTVALUE;
	    /*
	     * TAG IF SOME DEALLOCATION IS NEEDED
	     */
	    IF (ALLOC != 0) ATTVAL = 1;
	} ELSE {
	    IF ((ATTVALUE != NULL) && (ATTVALUE[LEN] == 0))
		XMLFREE(ATTVALUE);
	}

FAILED:

	GROW
        IF (CTXT->INSTATE == XML_PARSER_EOF)
            BREAK;
	IF ((CTXT->INPUT->BASE != BASE) || (INPUTNR != CTXT->INPUTNR))
	    GOTO BASE_CHANGED;
	IF ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
	    BREAK;
	IF (!IS_BLANK_CH(RAW)) {
	    XMLFATALERRMSG(CTXT, XML_ERR_SPACE_REQUIRED,
			   "ATTRIBUTES CONSTRUCT ERROR\N");
	    BREAK;
	}
	SKIP_BLANKS;
        IF ((CONS == CTXT->INPUT->CONSUMED) && (Q == CUR_PTR) &&
            (ATTNAME == NULL) && (ATTVALUE == NULL)) {
	    XMLFATALERR(CTXT, XML_ERR_INTERNAL_ERROR,
	         "XMLPARSESTARTTAG: PROBLEM PARSING ATTRIBUTES\N");
	    BREAK;
	}
        GROW;
	IF ((CTXT->INPUT->BASE != BASE) || (INPUTNR != CTXT->INPUTNR))
	    GOTO BASE_CHANGED;
    }

    /*
     * THE ATTRIBUTES DEFAULTING
     */
    IF (CTXT->ATTSDEFAULT != NULL) {
        XMLDEFATTRSPTR DEFAULTS;

	DEFAULTS = XMLHASHLOOKUP2(CTXT->ATTSDEFAULT, LOCALNAME, PREFIX);
	IF (DEFAULTS != NULL) {
	    FOR (I = 0;I < DEFAULTS->NBATTRS;I++) {
	        ATTNAME = DEFAULTS->VALUES[5 * I];
		APREFIX = DEFAULTS->VALUES[5 * I + 1];

                /*
		 * SPECIAL WORK FOR NAMESPACES DEFAULTED DEFS
		 */
		IF ((ATTNAME == CTXT->STR_XMLNS) && (APREFIX == NULL)) {
		    /*
		     * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		     */
		    FOR (J = 1;J <= NBNS;J++)
		        IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == NULL)
			    BREAK;
	            IF (J <= NBNS) CONTINUE;

		    NSNAME = XMLGETNAMESPACE(CTXT, NULL);
		    IF (NSNAME != DEFAULTS->VALUES[5 * I + 2]) {
			IF (NSPUSH(CTXT, NULL,
			           DEFAULTS->VALUES[5 * I + 2]) > 0)
			    NBNS++;
		    }
		} ELSE IF (APREFIX == CTXT->STR_XMLNS) {
		    /*
		     * CHECK THAT IT'S NOT A DEFINED NAMESPACE
		     */
		    FOR (J = 1;J <= NBNS;J++)
		        IF (CTXT->NSTAB[CTXT->NSNR - 2 * J] == ATTNAME)
			    BREAK;
	            IF (J <= NBNS) CONTINUE;

		    NSNAME = XMLGETNAMESPACE(CTXT, ATTNAME);
		    IF (NSNAME != DEFAULTS->VALUES[2]) {
			IF (NSPUSH(CTXT, ATTNAME,
			           DEFAULTS->VALUES[5 * I + 2]) > 0)
			    NBNS++;
		    }
		} ELSE {
		    /*
		     * CHECK THAT IT'S NOT A DEFINED ATTRIBUTE
		     */
		    FOR (J = 0;J < NBATTS;J+=5) {
			IF ((ATTNAME == ATTS[J]) && (APREFIX == ATTS[J+1]))
			    BREAK;
		    }
		    IF (J < NBATTS) CONTINUE;

		    IF ((ATTS == NULL) || (NBATTS + 5 > MAXATTS)) {
			IF (XMLCTXTGROWATTRS(CTXT, NBATTS + 5) < 0) {
			    RETURN(NULL);
			}
			MAXATTS = CTXT->MAXATTS;
			ATTS = CTXT->ATTS;
		    }
		    ATTS[NBATTS++] = ATTNAME;
		    ATTS[NBATTS++] = APREFIX;
		    IF (APREFIX == NULL)
			ATTS[NBATTS++] = NULL;
		    ELSE
		        ATTS[NBATTS++] = XMLGETNAMESPACE(CTXT, APREFIX);
		    ATTS[NBATTS++] = DEFAULTS->VALUES[5 * I + 2];
		    ATTS[NBATTS++] = DEFAULTS->VALUES[5 * I + 3];
		    IF ((CTXT->STANDALONE == 1) &&
		        (DEFAULTS->VALUES[5 * I + 4] != NULL)) {
			XMLVALIDITYERROR(CTXT, XML_DTD_STANDALONE_DEFAULTED,
	  "STANDALONE: ATTRIBUTE %S ON %S DEFAULTED FROM EXTERNAL SUBSET\N",
	                                 ATTNAME, LOCALNAME);
		    }
		    NBDEF++;
		}
	    }
	}
    }

    /*
     * THE ATTRIBUTES CHECKINGS
     */
    FOR (I = 0; I < NBATTS;I += 5) {
        /*
	* THE DEFAULT NAMESPACE DOES NOT APPLY TO ATTRIBUTE NAMES.
	*/
	IF (ATTS[I + 1] != NULL) {
	    NSNAME = XMLGETNAMESPACE(CTXT, ATTS[I + 1]);
	    IF (NSNAME == NULL) {
		XMLNSERR(CTXT, XML_NS_ERR_UNDEFINED_NAMESPACE,
		    "NAMESPACE PREFIX %S FOR %S ON %S IS NOT DEFINED\N",
		    ATTS[I + 1], ATTS[I], LOCALNAME);
	    }
	    ATTS[I + 2] = NSNAME;
	} ELSE
	    NSNAME = NULL;
	/*
	 * [ WFC: UNIQUE ATT SPEC ]
	 * NO ATTRIBUTE NAME MAY APPEAR MORE THAN ONCE IN THE SAME
	 * START-TAG OR EMPTY-ELEMENT TAG.
	 * AS EXTENDED BY THE NAMESPACE IN XML REC.
	 */
        FOR (J = 0; J < I;J += 5) {
	    IF (ATTS[I] == ATTS[J]) {
	        IF (ATTS[I+1] == ATTS[J+1]) {
		    XMLERRATTRIBUTEDUP(CTXT, ATTS[I+1], ATTS[I]);
		    BREAK;
		}
		IF ((NSNAME != NULL) && (ATTS[J + 2] == NSNAME)) {
		    XMLNSERR(CTXT, XML_NS_ERR_ATTRIBUTE_REDEFINED,
			     "NAMESPACED ATTRIBUTE %S IN '%S' REDEFINED\N",
			     ATTS[I], NSNAME, NULL);
		    BREAK;
		}
	    }
	}
    }

    NSNAME = XMLGETNAMESPACE(CTXT, PREFIX);
    IF ((PREFIX != NULL) && (NSNAME == NULL)) {
	XMLNSERR(CTXT, XML_NS_ERR_UNDEFINED_NAMESPACE,
	         "NAMESPACE PREFIX %S ON %S IS NOT DEFINED\N",
		 PREFIX, LOCALNAME, NULL);
    }
    *PREF = PREFIX;
    *URI = NSNAME;

    /*
     * SAX: START OF ELEMENT !
     */
    IF ((CTXT->SAX != NULL) && (CTXT->SAX->STARTELEMENTNS != NULL) &&
	(!CTXT->DISABLESAX)) {
	IF (NBNS > 0)
	    CTXT->SAX->STARTELEMENTNS(CTXT->USERDATA, LOCALNAME, PREFIX,
			  NSNAME, NBNS, &CTXT->NSTAB[CTXT->NSNR - 2 * NBNS],
			  NBATTS / 5, NBDEF, ATTS);
	ELSE
	    CTXT->SAX->STARTELEMENTNS(CTXT->USERDATA, LOCALNAME, PREFIX,
	                  NSNAME, 0, NULL, NBATTS / 5, NBDEF, ATTS);
    }

    /*
     * FREE UP ATTRIBUTE ALLOCATED STRINGS IF NEEDED
     */
    IF (ATTVAL != 0) {
	FOR (I = 3,J = 0; J < NRATTS;I += 5,J++)
	    IF ((CTXT->ATTALLOCS[J] != 0) && (ATTS[I] != NULL))
	        XMLFREE((XMLCHAR *) ATTS[I]);
    }

    RETURN(LOCALNAME);

BASE_CHANGED:
    /*
     * THE ATTRIBUTE STRINGS ARE VALID IIF THE BASE DIDN'T CHANGED
     */
    IF (ATTVAL != 0) {
	FOR (I = 3,J = 0; J < NRATTS;I += 5,J++)
	    IF ((CTXT->ATTALLOCS[J] != 0) && (ATTS[I] != NULL))
	        XMLFREE((XMLCHAR *) ATTS[I]);
    }

    /*
     * WE CAN'T SWITCH FROM ONE ENTITY TO ANOTHER IN THE MIDDLE
     * OF A START TAG
     */
    IF (INPUTNR != CTXT->INPUTNR) {
        XMLFATALERRMSG(CTXT, XML_ERR_ENTITY_BOUNDARY,
		    "START TAG DOESN'T START AND STOP IN THE SAME ENTITY\N");
	RETURN(NULL);
    }

    CTXT->INPUT->CUR = CTXT->INPUT->BASE + CUR;
    CTXT->INPUT->LINE = OLDLINE;
    CTXT->INPUT->COL = OLDCOL;
    IF (CTXT->WELLFORMED == 1) {
	GOTO REPARSE;
    }
    RETURN(NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 446401_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RZ_API VOID RZ_DYLDCACHE_SYMBOLS_FROM_LOCSYM(RZDYLDCACHE *CACHE, RZDYLDBINIMAGE *BIN, RZLIST *SYMBOLS, SETU *HASH) {
	RZDYLDLOCSYM *LOCSYM = CACHE->LOCSYM;
	IF (!LOCSYM) {
		RETURN;
	}

	IF (BIN->NLIST_START_INDEX >= LOCSYM->NLISTS_COUNT ||
		BIN->NLIST_START_INDEX + BIN->NLIST_COUNT > LOCSYM->NLISTS_COUNT) {
		RZ_LOG_ERROR("DYLDCACHE: MALFORMED LOCAL SYMBOL ENTRY\N");
		RETURN;
	}

	UT64 NLISTS_SIZE = SIZEOF(STRUCT MACH0_(NLIST)) * BIN->NLIST_COUNT;
	STRUCT MACH0_(NLIST) *NLISTS = RZ_NEWS0(STRUCT MACH0_(NLIST), BIN->NLIST_COUNT);
	IF (!NLISTS) {
		RETURN;
	}
	UT64 NLISTS_OFFSET = LOCSYM->LOCAL_SYMBOLS_OFFSET + LOCSYM->NLISTS_OFFSET +
		BIN->NLIST_START_INDEX * SIZEOF(STRUCT MACH0_(NLIST));
	IF (RZ_BUF_FREAD_AT(CACHE->BUF, NLISTS_OFFSET, (UT8 *)NLISTS, "ICCSL", BIN->NLIST_COUNT) != NLISTS_SIZE) {
		FREE(NLISTS);
		RETURN;
	}

	UT32 J;
	FOR (J = 0; J != BIN->NLIST_COUNT; J++) {
		STRUCT MACH0_(NLIST) *NLIST = &NLISTS[J];
		IF (SET_U_CONTAINS(HASH, (UT64)NLIST->N_VALUE)) {
			CONTINUE;
		}
		SET_U_ADD(HASH, (UT64)NLIST->N_VALUE);
		IF (NLIST->N_STRX >= LOCSYM->STRINGS_SIZE) {
			CONTINUE;
		}
		RZBINSYMBOL *SYM = RZ_NEW0(RZBINSYMBOL);
		IF (!SYM) {
			BREAK;
		}
		SYM->TYPE = "LOCAL";
		SYM->VADDR = NLIST->N_VALUE;
		UT64 SLIDE = RZ_DYLDCACHE_GET_SLIDE(CACHE);
		SYM->PADDR = VA2PA(NLIST->N_VALUE, CACHE->N_MAPS, CACHE->MAPS, CACHE->BUF, SLIDE, NULL, NULL);

		CHAR *SYMSTR = RZ_BUF_GET_STRING(CACHE->BUF, LOCSYM->LOCAL_SYMBOLS_OFFSET + LOCSYM->STRINGS_OFFSET + NLIST->N_STRX);
		IF (SYMSTR) {
			SYM->NAME = SYMSTR;
		} ELSE {
			STATIC UT32 K = 0;
			SYM->NAME = RZ_STR_NEWF("UNK_LOCAL%D", K++);
		}

		RZ_LIST_APPEND(SYMBOLS, SYM);
	}

	FREE(NLISTS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198692_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT XFRM_MIGRATE(CONST STRUCT XFRM_SELECTOR *SEL, U8 DIR, U8 TYPE,
		 STRUCT XFRM_MIGRATE *M, INT NUM_MIGRATE,
		 STRUCT XFRM_KMADDRESS *K, STRUCT NET *NET,
		 STRUCT XFRM_ENCAP_TMPL *ENCAP)
{
	INT I, ERR, NX_CUR = 0, NX_NEW = 0;
	STRUCT XFRM_POLICY *POL = NULL;
	STRUCT XFRM_STATE *X, *XC;
	STRUCT XFRM_STATE *X_CUR[XFRM_MAX_DEPTH];
	STRUCT XFRM_STATE *X_NEW[XFRM_MAX_DEPTH];
	STRUCT XFRM_MIGRATE *MP;

	IF ((ERR = XFRM_MIGRATE_CHECK(M, NUM_MIGRATE)) < 0)
		GOTO OUT;

	/* STAGE 1 - FIND POLICY */
	IF ((POL = XFRM_MIGRATE_POLICY_FIND(SEL, DIR, TYPE, NET)) == NULL) {
		ERR = -ENOENT;
		GOTO OUT;
	}

	/* STAGE 2 - FIND AND UPDATE STATE(S) */
	FOR (I = 0, MP = M; I < NUM_MIGRATE; I++, MP++) {
		IF ((X = XFRM_MIGRATE_STATE_FIND(MP, NET))) {
			X_CUR[NX_CUR] = X;
			NX_CUR++;
			XC = XFRM_STATE_MIGRATE(X, MP, ENCAP);
			IF (XC) {
				X_NEW[NX_NEW] = XC;
				NX_NEW++;
			} ELSE {
				ERR = -ENODATA;
				GOTO RESTORE_STATE;
			}
		}
	}

	/* STAGE 3 - UPDATE POLICY */
	IF ((ERR = XFRM_POLICY_MIGRATE(POL, M, NUM_MIGRATE)) < 0)
		GOTO RESTORE_STATE;

	/* STAGE 4 - DELETE OLD STATE(S) */
	IF (NX_CUR) {
		XFRM_STATES_PUT(X_CUR, NX_CUR);
		XFRM_STATES_DELETE(X_CUR, NX_CUR);
	}

	/* STAGE 5 - ANNOUNCE */
	KM_MIGRATE(SEL, DIR, TYPE, M, NUM_MIGRATE, K, ENCAP);

	XFRM_POL_PUT(POL);

	RETURN 0;
OUT:
	RETURN ERR;

RESTORE_STATE:
	IF (POL)
		XFRM_POL_PUT(POL);
	IF (NX_CUR)
		XFRM_STATES_PUT(X_CUR, NX_CUR);
	IF (NX_NEW)
		XFRM_STATES_DELETE(X_NEW, NX_NEW);

	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212822_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PCL_STATUS_READ(BYTE * DATA, UINT MAX_DATA, PCL_STATE_T * PCS)
{
    UINT COUNT = MIN(MAX_DATA,
                     PCS->STATUS.WRITE_POS - PCS->STATUS.READ_POS);

    IF (COUNT)
        MEMCPY(DATA, PCS->STATUS.BUFFER + PCS->STATUS.READ_POS, COUNT);
    PCS->STATUS.READ_POS += COUNT;
    IF (PCS->STATUS.READ_POS == PCS->STATUS.WRITE_POS) {
        GS_FREE_OBJECT(PCS->MEMORY, PCS->STATUS.BUFFER, "STATUS BUFFER");
        PCS->STATUS.WRITE_POS = PCS->STATUS.READ_POS = 0;
    }
    RETURN COUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214358_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT QTM_DECOMPRESS(STRUCT QTM_STREAM *QTM, OFF_T OUT_BYTES) {
  UNSIGNED INT FRAME_START, FRAME_END, WINDOW_POSN, MATCH_OFFSET, RANGE;
  UNSIGNED CHAR *WINDOW, *I_PTR, *I_END, *RUNSRC, *RUNDEST;
  INT I, J, SELECTOR, EXTRA, SYM, MATCH_LENGTH, RET;
  UNSIGNED SHORT H, L, C, SYMF;

  REGISTER UNSIGNED INT BIT_BUFFER;
  REGISTER UNSIGNED CHAR BITS_LEFT;
  UNSIGNED CHAR BITS_NEEDED, BIT_RUN;

  /* EASY ANSWERS */
  IF (!QTM || (OUT_BYTES < 0)) RETURN CL_ENULLARG;
  IF (QTM->ERROR) RETURN QTM->ERROR;

  /* FLUSH OUT ANY STORED-UP BYTES BEFORE WE BEGIN */
  I = QTM->O_END - QTM->O_PTR;
  IF ((OFF_T) I > OUT_BYTES) I = (INT) OUT_BYTES;
  IF (I) {
    IF (QTM->WFLAG && (RET = MSPACK_WRITE(QTM->OFD, QTM->O_PTR, I, QTM->FILE)) != CL_SUCCESS) {
      RETURN QTM->ERROR = RET;
    }
    QTM->O_PTR  += I;
    OUT_BYTES   -= I;
  }
  IF (OUT_BYTES == 0) RETURN CL_SUCCESS;

  /* RESTORE LOCAL STATE */
  QTM_RESTORE_BITS;
  WINDOW = QTM->WINDOW;
  WINDOW_POSN = QTM->WINDOW_POSN;
  FRAME_START = QTM->FRAME_START;
  H = QTM->H;
  L = QTM->L;
  C = QTM->C;

  /* WHILE WE DO NOT HAVE ENOUGH DECODED BYTES IN RESERVE: */
  WHILE ((QTM->O_END - QTM->O_PTR) < OUT_BYTES) {

    /* READ HEADER IF NECESSARY. INITIALISES H, L AND C */
    IF (!QTM->HEADER_READ) {
      H = 0XFFFF; L = 0; QTM_READ_BITS(C, 16);
      QTM->HEADER_READ = 1;
    }

    /* DECODE MORE, AT MOST UP TO TO FRAME BOUNDARY */
    FRAME_END = WINDOW_POSN + (OUT_BYTES - (QTM->O_END - QTM->O_PTR));
    IF ((FRAME_START + QTM_FRAME_SIZE) < FRAME_END) {
      FRAME_END = FRAME_START + QTM_FRAME_SIZE;
    }

    WHILE (WINDOW_POSN < FRAME_END) {
      QTM_GET_SYMBOL(QTM->MODEL7, SELECTOR);
      IF (SELECTOR < 4) {
	STRUCT QTM_MODEL *MDL = (SELECTOR == 0) ? &QTM->MODEL0 :
	                        ((SELECTOR == 1) ? &QTM->MODEL1 :
				((SELECTOR == 2) ? &QTM->MODEL2 :
                                                   &QTM->MODEL3));
	QTM_GET_SYMBOL((*MDL), SYM);
	WINDOW[WINDOW_POSN++] = SYM;
      }
      ELSE {
	SWITCH (SELECTOR) {
	CASE 4: /* SELECTOR 4 = FIXED LENGTH MATCH (3 BYTES) */
	  QTM_GET_SYMBOL(QTM->MODEL4, SYM);
	  QTM_READ_BITS(EXTRA, QTM->EXTRA_BITS[SYM]);
	  MATCH_OFFSET = QTM->POSITION_BASE[SYM] + EXTRA + 1;
	  MATCH_LENGTH = 3;
	  BREAK;

	CASE 5: /* SELECTOR 5 = FIXED LENGTH MATCH (4 BYTES) */
	  QTM_GET_SYMBOL(QTM->MODEL5, SYM);
	  QTM_READ_BITS(EXTRA, QTM->EXTRA_BITS[SYM]);
	  MATCH_OFFSET = QTM->POSITION_BASE[SYM] + EXTRA + 1;
	  MATCH_LENGTH = 4;
	  BREAK;

	CASE 6: /* SELECTOR 6 = VARIABLE LENGTH MATCH */
	  QTM_GET_SYMBOL(QTM->MODEL6LEN, SYM);
	  QTM_READ_BITS(EXTRA, QTM->LENGTH_EXTRA[SYM]);
	  MATCH_LENGTH = QTM->LENGTH_BASE[SYM] + EXTRA + 5;

	  QTM_GET_SYMBOL(QTM->MODEL6, SYM);
	  QTM_READ_BITS(EXTRA, QTM->EXTRA_BITS[SYM]);
	  MATCH_OFFSET = QTM->POSITION_BASE[SYM] + EXTRA + 1;
	  BREAK;

	DEFAULT:
	  /* SHOULD BE IMPOSSIBLE, MODEL7 CAN ONLY RETURN 0-6 */
	  RETURN QTM->ERROR = CL_EFORMAT;
	}

	RUNDEST = &WINDOW[WINDOW_POSN];
	I = MATCH_LENGTH;
	/* DOES MATCH OFFSET WRAP THE WINDOW? */
	IF (MATCH_OFFSET > WINDOW_POSN) {
	  /* J = LENGTH FROM MATCH OFFSET TO END OF WINDOW */
	  J = MATCH_OFFSET - WINDOW_POSN;
	  IF (J > (INT) QTM->WINDOW_SIZE) {
	    CLI_DBGMSG("QTM_DECOMPRESS: MATCH OFFSET BEYOND WINDOW BOUNDARIES\N");
	    RETURN QTM->ERROR = CL_EFORMAT;
	  }
	  RUNSRC = &WINDOW[QTM->WINDOW_SIZE - J];
	  IF (J < I) {
	    /* IF MATCH GOES OVER THE WINDOW EDGE, DO TWO COPY RUNS */
	    I -= J; WHILE (J-- > 0) *RUNDEST++ = *RUNSRC++;
	    RUNSRC = WINDOW;
	  }
	  WHILE (I-- > 0) *RUNDEST++ = *RUNSRC++;
	}
	ELSE {
	  RUNSRC = RUNDEST - MATCH_OFFSET;
	  IF(I > (INT) (QTM->WINDOW_SIZE - WINDOW_POSN))
	    I = QTM->WINDOW_SIZE - WINDOW_POSN;
	  WHILE (I-- > 0) *RUNDEST++ = *RUNSRC++;
	}
	WINDOW_POSN += MATCH_LENGTH;
      }
    } /* WHILE (WINDOW_POSN < FRAME_END) */

    QTM->O_END = &WINDOW[WINDOW_POSN];

    /* ANOTHER FRAME COMPLETED? */
    IF ((WINDOW_POSN - FRAME_START) >= QTM_FRAME_SIZE) {
      IF ((WINDOW_POSN - FRAME_START) != QTM_FRAME_SIZE) {
	CLI_DBGMSG("QTM_DECOMPRESS: OVERSHOT FRAME ALIGNMENT\N");
	RETURN QTM->ERROR = CL_EFORMAT;
      }

      /* RE-ALIGN INPUT */
      IF (BITS_LEFT & 7) QTM_REMOVE_BITS(BITS_LEFT & 7);
      DO { QTM_READ_BITS(I, 8); } WHILE (I != 0XFF);
      QTM->HEADER_READ = 0;

      /* WINDOW WRAP? */
      IF (WINDOW_POSN == QTM->WINDOW_SIZE) {
	/* FLUSH ALL CURRENTLY STORED DATA */
	I = (QTM->O_END - QTM->O_PTR);
	IF (QTM->WFLAG && (RET = MSPACK_WRITE(QTM->OFD, QTM->O_PTR, I, QTM->FILE)) != CL_SUCCESS) {
	  RETURN QTM->ERROR = RET;
	}
	OUT_BYTES -= I;
	QTM->O_PTR = &WINDOW[0];
	QTM->O_END = &WINDOW[0];
	WINDOW_POSN = 0;
      }

      FRAME_START = WINDOW_POSN;
    }

  } /* WHILE (MORE BYTES NEEDED) */

  IF (OUT_BYTES) {
    I = (INT) OUT_BYTES;
    IF (QTM->WFLAG && (RET = MSPACK_WRITE(QTM->OFD, QTM->O_PTR, I, QTM->FILE)) != CL_SUCCESS) {
      RETURN QTM->ERROR = RET;
    }
    QTM->O_PTR += I;
  }

  /* STORE LOCAL STATE */
  QTM_STORE_BITS;
  QTM->WINDOW_POSN = WINDOW_POSN;
  QTM->FRAME_START = FRAME_START;
  QTM->H = H;
  QTM->L = L;
  QTM->C = C;

  RETURN CL_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 484716_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MOBI_BUFFER_ADDRAW(MOBIBUFFER *BUF, CONST UNSIGNED CHAR* DATA, CONST SIZE_T LEN) {
    IF (BUF->OFFSET + LEN > BUF->MAXLEN) {
        DEBUG_PRINT("%S", "BUFFER FULL\N");
        BUF->ERROR = MOBI_BUFFER_END;
        RETURN;
    }
    MEMCPY(BUF->DATA + BUF->OFFSET, DATA, LEN);
    BUF->OFFSET += LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210303_CWE-772.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READWMFIMAGE(CONST IMAGEINFO *IMAGE_INFO,EXCEPTIONINFO *EXCEPTION)
{
  DOUBLE
    BOUNDING_HEIGHT,
    BOUNDING_WIDTH,
    IMAGE_HEIGHT,
    IMAGE_HEIGHT_INCH,
    IMAGE_WIDTH,
    IMAGE_WIDTH_INCH,
    RESOLUTION_Y,
    RESOLUTION_X,
    UNITS_PER_INCH;

  FLOAT
    WMF_WIDTH,
    WMF_HEIGHT;

  IMAGE
    *IMAGE;

  MAGICKBOOLEANTYPE
    STATUS;

  UNSIGNED LONG
    WMF_OPTIONS_FLAGS = 0;

  WMF_ERROR_T
    WMF_ERROR;

  WMF_MAGICK_T
    *DDATA = 0;

  WMFAPI
    *API = 0;

  WMFAPI_OPTIONS
    WMF_API_OPTIONS;

  WMFD_RECT
    BBOX;

  IMAGE=ACQUIREIMAGE(IMAGE_INFO,EXCEPTION);
  IF (OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION) == MAGICKFALSE)
    {
      IF (IMAGE->DEBUG != MAGICKFALSE)
        {
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  OPENBLOB FAILED");
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "LEAVE READWMFIMAGE()");
        }
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }

  /*
   * CREATE WMF API
   *
   */

  /* REGISTER CALLBACKS */
  WMF_OPTIONS_FLAGS |= WMF_OPT_FUNCTION;
  (VOID) RESETMAGICKMEMORY(&WMF_API_OPTIONS, 0, SIZEOF(WMF_API_OPTIONS));
  WMF_API_OPTIONS.FUNCTION = IPA_FUNCTIONS;

  /* IGNORE NON-FATAL ERRORS */
  WMF_OPTIONS_FLAGS |= WMF_OPT_IGNORE_NONFATAL;

  WMF_ERROR = WMF_API_CREATE(&API, WMF_OPTIONS_FLAGS, &WMF_API_OPTIONS);
  IF (WMF_ERROR != WMF_E_NONE)
    {
      IF (API)
        WMF_API_DESTROY(API);
      IF (IMAGE->DEBUG != MAGICKFALSE)
        {
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  WMF_API_CREATE FAILED");
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "LEAVE READWMFIMAGE()");
        }
      THROWREADEREXCEPTION(DELEGATEERROR,"UNABLETOINITIALIZEWMFLIBRARY");
    }

  /* REGISTER PROGRESS MONITOR */
  WMF_STATUS_FUNCTION(API,IMAGE,MAGICK_PROGRESS_CALLBACK);

  DDATA=WMF_MAGICK_GETDATA(API);
  DDATA->IMAGE=IMAGE;
  DDATA->IMAGE_INFO=IMAGE_INFO;
  DDATA->DRAW_INFO=CLONEDRAWINFO(IMAGE_INFO,(CONST DRAWINFO *) NULL);
  DDATA->EXCEPTION=EXCEPTION;
  DDATA->DRAW_INFO->FONT=(CHAR *)
    RELINQUISHMAGICKMEMORY(DDATA->DRAW_INFO->FONT);
  DDATA->DRAW_INFO->TEXT=(CHAR *)
    RELINQUISHMAGICKMEMORY(DDATA->DRAW_INFO->TEXT);

#IF DEFINED(MAGICKCORE_WMF_DELEGATE)
  /* MUST INITIALIZE FONT SUBYSTEM FOR WMFLITE INTERFACE */
  LITE_FONT_INIT (API,&WMF_API_OPTIONS); /* SIMILAR TO WMF_IPA_FONT_INIT IN SRC/FONT.C */
  /* WMF_ARG_FONTDIRS (API,OPTIONS); */ /* SIMILAR TO WMF_ARG_FONTDIRS IN SRC/WMF.C */

#ENDIF

  /*
   * OPEN BLOB INPUT VIA LIBWMF API
   *
   */
  WMF_ERROR = WMF_BBUF_INPUT(API,IPA_BLOB_READ,IPA_BLOB_SEEK,
    IPA_BLOB_TELL,(VOID*)IMAGE);
  IF (WMF_ERROR != WMF_E_NONE)
    {
      WMF_API_DESTROY(API);
      IF (IMAGE->DEBUG != MAGICKFALSE)
        {
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  WMF_BBUF_INPUT FAILED");
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "LEAVE READWMFIMAGE()");
        }
      THROWFILEEXCEPTION(EXCEPTION,FILEOPENERROR,"UNABLETOOPENFILE",
        IMAGE->FILENAME);
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }

  /*
   * SCAN WMF FILE
   *
   */
  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
      "  SCANNING WMF TO OBTAIN BOUNDING BOX");
  WMF_ERROR=WMF_SCAN(API, 0, &BBOX);
  IF (WMF_ERROR != WMF_E_NONE)
    {
      WMF_API_DESTROY(API);
      IF (IMAGE->DEBUG != MAGICKFALSE)
        {
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  WMF_SCAN FAILED WITH WMF_ERROR %D", WMF_ERROR);
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "LEAVE READWMFIMAGE()");
        }
      THROWREADEREXCEPTION(DELEGATEERROR,"FAILEDTOSCANFILE");
    }

  /*
   * COMPUTE DIMENSIONS AND SCALE FACTORS
   *
   */

  DDATA->BBOX=BBOX;

  /* USER SPECIFIED RESOLUTION */
  RESOLUTION_Y=DEFAULTRESOLUTION;
  IF (IMAGE->RESOLUTION.Y != 0.0)
    {
      RESOLUTION_Y = IMAGE->RESOLUTION.Y;
      IF (IMAGE->UNITS == PIXELSPERCENTIMETERRESOLUTION)
        RESOLUTION_Y *= CENTIMETERS_PER_INCH;
    }
  RESOLUTION_X=DEFAULTRESOLUTION;
  IF (IMAGE->RESOLUTION.X != 0.0)
    {
      RESOLUTION_X = IMAGE->RESOLUTION.X;
      IF (IMAGE->UNITS == PIXELSPERCENTIMETERRESOLUTION)
        RESOLUTION_X *= CENTIMETERS_PER_INCH;
    }

  /* OBTAIN OUTPUT SIZE EXPRESSED IN METAFILE UNITS */
  WMF_ERROR=WMF_SIZE(API,&WMF_WIDTH,&WMF_HEIGHT);
  IF (WMF_ERROR != WMF_E_NONE)
    {
      WMF_API_DESTROY(API);
      IF (IMAGE->DEBUG != MAGICKFALSE)
        {
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  WMF_SIZE FAILED WITH WMF_ERROR %D", WMF_ERROR);
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "LEAVE READWMFIMAGE()");
        }
      THROWREADEREXCEPTION(DELEGATEERROR,"FAILEDTOCOMPUTEOUTPUTSIZE");
    }

  /* OBTAIN (OR GUESS) METAFILE UNITS */
  IF ((API)->FILE->PLACEABLE)
    UNITS_PER_INCH=(API)->FILE->PMH->INCH;
  ELSE IF ( (WMF_WIDTH*WMF_HEIGHT) < 1024*1024)
    UNITS_PER_INCH=POINTS_PER_INCH;  /* MM_TEXT */
  ELSE
    UNITS_PER_INCH=TWIPS_PER_INCH;  /* MM_TWIPS */

  /* CALCULATE IMAGE WIDTH AND HEIGHT BASED ON SPECIFIED DPI
     RESOLUTION */
  IMAGE_WIDTH_INCH  = (DOUBLE) WMF_WIDTH / UNITS_PER_INCH;
  IMAGE_HEIGHT_INCH = (DOUBLE) WMF_HEIGHT / UNITS_PER_INCH;
  IMAGE_WIDTH       = IMAGE_WIDTH_INCH * RESOLUTION_X;
  IMAGE_HEIGHT      = IMAGE_HEIGHT_INCH * RESOLUTION_Y;

  /* COMPUTE BOUNDING BOX SCALE FACTORS AND ORIGIN TRANSLATIONS
   *
   * THIS ALL JUST A HACK SINCE LIBWMF DOES NOT CURRENTLY SEEM TO
   * PROVIDE THE MAPPING BETWEEN LOGICAL COORDINATES AND DEVICE
   * COORDINATES. THIS MAPPING IS NECESSARY IN ORDER TO KNOW
   * WHERE TO PLACE THE LOGICAL BOUNDING BOX WITHIN THE IMAGE.
   *
   */

  BOUNDING_WIDTH  = BBOX.BR.X - BBOX.TL.X;
  BOUNDING_HEIGHT = BBOX.BR.Y - BBOX.TL.Y;

  DDATA->SCALE_X = IMAGE_WIDTH/BOUNDING_WIDTH;
  DDATA->TRANSLATE_X = 0-BBOX.TL.X;
  DDATA->ROTATE = 0;

  /* HEURISTIC: GUESS THAT IF THE VERTICAL COORDINATES MOSTLY SPAN
     NEGATIVE VALUES, THEN THE IMAGE MUST BE INVERTED. */
  IF ( FABS(BBOX.BR.Y) > FABS(BBOX.TL.Y) )
    {
      /* NORMAL (ORIGIN AT TOP LEFT OF IMAGE) */
      DDATA->SCALE_Y = (IMAGE_HEIGHT/BOUNDING_HEIGHT);
      DDATA->TRANSLATE_Y = 0-BBOX.TL.Y;
    }
  ELSE
    {
      /* INVERTED (ORIGIN AT BOTTOM LEFT OF IMAGE) */
      DDATA->SCALE_Y = (-IMAGE_HEIGHT/BOUNDING_HEIGHT);
      DDATA->TRANSLATE_Y = 0-BBOX.BR.Y;
    }

  IF (IMAGE->DEBUG != MAGICKFALSE)
    {
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
         "  PLACEABLE METAFILE:          %S",
         (API)->FILE->PLACEABLE ? "YES" : "NO");

      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  SIZE IN METAFILE UNITS:      %GX%G",WMF_WIDTH,WMF_HEIGHT);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  METAFILE UNITS/INCH:         %G",UNITS_PER_INCH);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  SIZE IN INCHES:              %GX%G",
        IMAGE_WIDTH_INCH,IMAGE_HEIGHT_INCH);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  BOUNDING BOX:                %G,%G %G,%G",
        BBOX.TL.X, BBOX.TL.Y, BBOX.BR.X, BBOX.BR.Y);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  BOUNDING WIDTH X HEIGHT:     %GX%G",BOUNDING_WIDTH,
        BOUNDING_HEIGHT);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  OUTPUT RESOLUTION:           %GX%G",RESOLUTION_X,RESOLUTION_Y);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  IMAGE SIZE:                  %GX%G",IMAGE_WIDTH,IMAGE_HEIGHT);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  BOUNDING BOX SCALE FACTOR:   %G,%G",DDATA->SCALE_X,
        DDATA->SCALE_Y);
      (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
        "  TRANSLATION:                 %G,%G",
        DDATA->TRANSLATE_X, DDATA->TRANSLATE_Y);
    }

#IF 0
#IF 0
  {
    TYPEDEF STRUCT _WMFPLAYER_T WMFPLAYER_T;
    STRUCT _WMFPLAYER_T
    {
      WMFPEN   DEFAULT_PEN;
      WMFBRUSH DEFAULT_BRUSH;
      WMFFONT  DEFAULT_FONT;

      WMFDC* DC; /* CURRENT DC */
    };

    WMFDC
      *DC;

#DEFINE WMF_ELICIT_DC(API) (((WMFPLAYER_T*)((API)->PLAYER_DATA))->DC)

    DC = WMF_ELICIT_DC(API);

    PRINTF("DC->WINDOW.OX     = %D\N", DC->WINDOW.OX);
    PRINTF("DC->WINDOW.OY     = %D\N", DC->WINDOW.OY);
    PRINTF("DC->WINDOW.WIDTH  = %D\N", DC->WINDOW.WIDTH);
    PRINTF("DC->WINDOW.HEIGHT = %D\N", DC->WINDOW.HEIGHT);
    PRINTF("DC->PIXEL_WIDTH   = %G\N", DC->PIXEL_WIDTH);
    PRINTF("DC->PIXEL_HEIGHT  = %G\N", DC->PIXEL_HEIGHT);
#IF DEFINED(MAGICKCORE_WMF_DELEGATE)  /* ONLY IN LIBWMF 0.3 */
    PRINTF("DC->OX            = %.D\N", DC->OX);
    PRINTF("DC->OY            = %.D\N", DC->OY);
    PRINTF("DC->WIDTH         = %.D\N", DC->WIDTH);
    PRINTF("DC->HEIGHT        = %.D\N", DC->HEIGHT);
#ENDIF

  }
#ENDIF

#ENDIF

  /*
   * CREATE CANVAS IMAGE
   *
   */
  IMAGE->ROWS=(UNSIGNED LONG) CEIL(IMAGE_HEIGHT);
  IMAGE->COLUMNS=(UNSIGNED LONG) CEIL(IMAGE_WIDTH);

  IF (IMAGE_INFO->PING != MAGICKFALSE)
    {
      WMF_API_DESTROY(API);
      (VOID) CLOSEBLOB(IMAGE);
      IF (IMAGE->DEBUG != MAGICKFALSE)
        (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
          "LEAVE READWMFIMAGE()");
      RETURN(GETFIRSTIMAGEINLIST(IMAGE));
    }
  STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    RETURN(DESTROYIMAGELIST(IMAGE));
  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
       "  CREATING CANVAS IMAGE WITH SIZE %LUX%LU",(UNSIGNED LONG) IMAGE->ROWS,
       (UNSIGNED LONG) IMAGE->COLUMNS);

  /*
   * SET SOLID BACKGROUND COLOR
   */
  {
    IMAGE->BACKGROUND_COLOR = IMAGE_INFO->BACKGROUND_COLOR;
    IF (IMAGE->BACKGROUND_COLOR.ALPHA != OPAQUEALPHA)
      IMAGE->ALPHA_TRAIT=BLENDPIXELTRAIT;
    (VOID) SETIMAGEBACKGROUNDCOLOR(IMAGE,EXCEPTION);
  }
  /*
   * PLAY FILE TO GENERATE VECTOR DRAWING COMMANDS
   *
   */

  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
      "  PLAYING WMF TO PREPARE VECTORS");

  WMF_ERROR = WMF_PLAY(API, 0, &BBOX);
  IF (WMF_ERROR != WMF_E_NONE)
    {
      WMF_API_DESTROY(API);
      IF (IMAGE->DEBUG != MAGICKFALSE)
        {
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "  PLAYING WMF FAILED WITH WMF_ERROR %D", WMF_ERROR);
          (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
            "LEAVE READWMFIMAGE()");
        }
      THROWREADEREXCEPTION(DELEGATEERROR,"FAILEDTORENDERFILE");
    }

  /*
   * SCRIBBLE ON CANVAS IMAGE
   *
   */

  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),
      "  RENDERING WMF VECTORS");
  DRAWRENDER(DDATA->DRAW_WAND);

  IF (IMAGE->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(CODEREVENT,GETMAGICKMODULE(),"LEAVE READWMFIMAGE()");

  /* CLEANUP ALLOCATED DATA */
  WMF_API_DESTROY(API);
  (VOID) CLOSEBLOB(IMAGE);

  /* RETURN IMAGE */
  RETURN IMAGE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214003_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HANDLECORREBPP (RFBCLIENT* CLIENT, INT RX, INT RY, INT RW, INT RH)
{
    RFBRREHEADER HDR;
    INT I;
    CARDBPP PIX;
    UINT8_T *PTR;
    INT X, Y, W, H;

    IF (!READFROMRFBSERVER(CLIENT, (CHAR *)&HDR, SZ_RFBRREHEADER))
	RETURN FALSE;

    HDR.NSUBRECTS = RFBCLIENTSWAP32IFLE(HDR.NSUBRECTS);

    IF (!READFROMRFBSERVER(CLIENT, (CHAR *)&PIX, SIZEOF(PIX)))
	RETURN FALSE;

    CLIENT->GOTFILLRECT(CLIENT, RX, RY, RW, RH, PIX);

    IF (HDR.NSUBRECTS * (4 + (BPP / 8)) > RFB_BUFFER_SIZE || !READFROMRFBSERVER(CLIENT, CLIENT->BUFFER, HDR.NSUBRECTS * (4 + (BPP / 8))))
	RETURN FALSE;

    PTR = (UINT8_T *)CLIENT->BUFFER;

    FOR (I = 0; I < HDR.NSUBRECTS; I++) {
	PIX = *(CARDBPP *)PTR;
	PTR += BPP/8;
	X = *PTR++;
	Y = *PTR++;
	W = *PTR++;
	H = *PTR++;

	CLIENT->GOTFILLRECT(CLIENT, RX+X, RY+Y, W, H, PIX);
    }

    RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198350_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NET_BIND(SHORT UNSIGNED *PORT, INT TYPE, CONST CHAR *LOG_SERVICE_NAME)
{
  STRUCT ADDRINFO HINTS = { 0 };
  STRUCT ADDRINFO *SERVINFO;
  STRUCT ADDRINFO *PTR;
  CONST CHAR *CFGADDR;
  CHAR ADDR[INET6_ADDRSTRLEN];
  CHAR STRPORT[8];
  INT YES = 1;
  INT NO = 0;
  INT FD;
  INT RET;

  CFGADDR = CFG_GETSTR(CFG_GETSEC(CFG, "GENERAL"), "BIND_ADDRESS");

  HINTS.AI_SOCKTYPE = (TYPE & (SOCK_STREAM | SOCK_DGRAM)); // FILTER SINCE TYPE CAN BE SOCK_STREAM | SOCK_NONBLOCK
  HINTS.AI_FAMILY = (CFG_GETBOOL(CFG_GETSEC(CFG, "GENERAL"), "IPV6")) ? AF_INET6 : AF_INET;
  HINTS.AI_FLAGS = CFGADDR ? 0 : AI_PASSIVE;

  SNPRINTF(STRPORT, SIZEOF(STRPORT), "%HU", *PORT);
  RET = GETADDRINFO(CFGADDR, STRPORT, &HINTS, &SERVINFO);
  IF (RET < 0)
    {
      DPRINTF(E_LOG, L_MISC, "FAILURE CREATING '%S' SERVICE, COULD NOT RESOLVE '%S' (PORT %S): %S\N", LOG_SERVICE_NAME, CFGADDR ? CFGADDR : "(ANY)", STRPORT, GAI_STRERROR(RET));
      RETURN -1;
    }

  FOR (PTR = SERVINFO, FD = -1; PTR != NULL; PTR = PTR->AI_NEXT)
    {
      IF (FD >= 0)
	CLOSE(FD);

      FD = SOCKET(PTR->AI_FAMILY, TYPE | SOCK_CLOEXEC, PTR->AI_PROTOCOL);
      IF (FD < 0)
	CONTINUE;

      // TODO LIBEVENT SETS THIS, WE DO THE SAME?
      RET = SETSOCKOPT(FD, SOL_SOCKET, SO_KEEPALIVE, &YES, SIZEOF(YES));
      IF (RET < 0)
	CONTINUE;

      RET = SETSOCKOPT(FD, SOL_SOCKET, SO_REUSEADDR, &YES, SIZEOF(YES));
      IF (RET < 0)
	CONTINUE;

      IF (PTR->AI_FAMILY == AF_INET6)
	{
	  // WE WANT TO BE SURE THE SERVICE IS DUAL STACK
	  RET = SETSOCKOPT(FD, IPPROTO_IPV6, IPV6_V6ONLY, &NO, SIZEOF(NO));
	  IF (RET < 0)
	    CONTINUE;
	}

      RET = BIND(FD, PTR->AI_ADDR, PTR->AI_ADDRLEN);
      IF (RET < 0)
	CONTINUE;

      BREAK;
    }

  FREEADDRINFO(SERVINFO);

  IF (!PTR)
    {
      DPRINTF(E_LOG, L_MISC, "COULD NOT CREATE SERVICE '%S' WITH ADDRESS %S, PORT %HU: %S\N", LOG_SERVICE_NAME, CFGADDR ? CFGADDR : "(ANY)", *PORT, STRERROR(ERRNO));
      GOTO ERROR;
    }

  // GET THE PORT THAT WAS ASSIGNED
  RET = GETSOCKNAME(FD, PTR->AI_ADDR, &PTR->AI_ADDRLEN);
  IF (RET < 0)
    {
      DPRINTF(E_LOG, L_MISC, "COULD NOT FIND ADDRESS OF SERVICE '%S': %S\N", LOG_SERVICE_NAME, STRERROR(ERRNO));
      GOTO ERROR;
    }

  NET_PORT_GET(PORT, (UNION NET_SOCKADDR *)PTR->AI_ADDR);
  NET_ADDRESS_GET(ADDR, SIZEOF(ADDR), (UNION NET_SOCKADDR *)PTR->AI_ADDR);

  DPRINTF(E_DBG, L_MISC, "SERVICE '%S' BOUND TO %S, PORT %HU, SOCKET %D\N", LOG_SERVICE_NAME, ADDR, *PORT, FD);

  RETURN FD;

 ERROR:
  CLOSE(FD);
  RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206942_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EVAL_STRING(CHAR_U **ARG, TYPVAL_T *RETTV, INT EVALUATE, INT INTERPOLATE)
{
    CHAR_U	*P;
    CHAR_U	*END;
    INT		EXTRA = INTERPOLATE ? 1 : 0;
    INT		OFF = INTERPOLATE ? 0 : 1;
    INT		LEN;

    // FIND THE END OF THE STRING, SKIPPING BACKSLASHED CHARACTERS.
    FOR (P = *ARG + OFF; *P != NUL && *P != '"'; MB_PTR_ADV(P))
    {
	IF (*P == '\\' && P[1] != NUL)
	{
	    ++P;
	    // A "\<X>" FORM OCCUPIES AT LEAST 4 CHARACTERS, AND PRODUCES UP
	    // TO 9 CHARACTERS (6 FOR THE CHAR AND 3 FOR A MODIFIER):
	    // RESERVE SPACE FOR 5 EXTRA.
	    IF (*P == '<')
		EXTRA += 5;
	}
	ELSE IF (INTERPOLATE && (*P == '{' || *P == '}'))
	{
	    IF (*P == '{' && P[1] != '{') // START OF EXPRESSION
		BREAK;
	    ++P;
	    IF (P[-1] == '}' && *P != '}') // SINGLE '}' IS AN ERROR
	    {
		SEMSG(_(E_STRAY_CLOSING_CURLY_STR), *ARG);
		RETURN FAIL;
	    }
	    --EXTRA;  // "{{" BECOMES "{", "}}" BECOMES "}"
	}
    }

    IF (*P != '"' && !(INTERPOLATE && *P == '{'))
    {
	SEMSG(_(E_MISSING_DOUBLE_QUOTE_STR), *ARG);
	RETURN FAIL;
    }

    // IF ONLY PARSING, SET *ARG AND RETURN HERE
    IF (!EVALUATE)
    {
	*ARG = P + OFF;
	RETURN OK;
    }

    // COPY THE STRING INTO ALLOCATED MEMORY, HANDLING BACKSLASHED
    // CHARACTERS.
    RETTV->V_TYPE = VAR_STRING;
    LEN = (INT)(P - *ARG + EXTRA);
    RETTV->VVAL.V_STRING = ALLOC(LEN);
    IF (RETTV->VVAL.V_STRING == NULL)
	RETURN FAIL;
    END = RETTV->VVAL.V_STRING;

    FOR (P = *ARG + OFF; *P != NUL && *P != '"'; )
    {
	IF (*P == '\\')
	{
	    SWITCH (*++P)
	    {
		CASE 'B': *END++ = BS; ++P; BREAK;
		CASE 'E': *END++ = ESC; ++P; BREAK;
		CASE 'F': *END++ = FF; ++P; BREAK;
		CASE 'N': *END++ = NL; ++P; BREAK;
		CASE 'R': *END++ = CAR; ++P; BREAK;
		CASE 'T': *END++ = TAB; ++P; BREAK;

		CASE 'X': // HEX: "\X1", "\X12"
		CASE 'X':
		CASE 'U': // UNICODE: "\U0023"
		CASE 'U':
			  IF (VIM_ISXDIGIT(P[1]))
			  {
			      INT	N, NR;
			      INT	C = TOUPPER(*P);

			      IF (C == 'X')
				  N = 2;
			      ELSE IF (*P == 'U')
				  N = 4;
			      ELSE
				  N = 8;
			      NR = 0;
			      WHILE (--N >= 0 && VIM_ISXDIGIT(P[1]))
			      {
				  ++P;
				  NR = (NR << 4) + HEX2NR(*P);
			      }
			      ++P;
			      // FOR "\U" STORE THE NUMBER ACCORDING TO
			      // 'ENCODING'.
			      IF (C != 'X')
				  END += (*MB_CHAR2BYTES)(NR, END);
			      ELSE
				  *END++ = NR;
			  }
			  BREAK;

			  // OCTAL: "\1", "\12", "\123"
		CASE '0':
		CASE '1':
		CASE '2':
		CASE '3':
		CASE '4':
		CASE '5':
		CASE '6':
		CASE '7': *END = *P++ - '0';
			  IF (*P >= '0' && *P <= '7')
			  {
			      *END = (*END << 3) + *P++ - '0';
			      IF (*P >= '0' && *P <= '7')
				  *END = (*END << 3) + *P++ - '0';
			  }
			  ++END;
			  BREAK;

			  // SPECIAL KEY, E.G.: "\<C-W>"
		CASE '<':
			  {
			      INT FLAGS = FSK_KEYCODE | FSK_IN_STRING;

			      IF (P[1] != '*')
				  FLAGS |= FSK_SIMPLIFY;
			      EXTRA = TRANS_SPECIAL(&P, END, FLAGS, FALSE, NULL);
			      IF (EXTRA != 0)
			      {
				  END += EXTRA;
				  IF (END >= RETTV->VVAL.V_STRING + LEN)
				      IEMSG("EVAL_STRING() USED MORE SPACE THAN ALLOCATED");
				  BREAK;
			      }
			  }
			  // FALLTHROUGH

		DEFAULT: MB_COPY_CHAR(P, END);
			  BREAK;
	    }
	}
	ELSE
	{
	    IF (INTERPOLATE && (*P == '{' || *P == '}'))
	    {
		IF (*P == '{' && P[1] != '{') // START OF EXPRESSION
		    BREAK;
		++P;  // REDUCE "{{" TO "{" AND "}}" TO "}"
	    }
	    MB_COPY_CHAR(P, END);
	}
    }
    *END = NUL;
    IF (*P == '"' && !INTERPOLATE)
	++P;
    *ARG = P;

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359646_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BGP_CLEAR (STRUCT VTY *VTY, STRUCT BGP *BGP,  AFI_T AFI, SAFI_T SAFI,
           ENUM CLEAR_SORT SORT,ENUM BGP_CLEAR_TYPE STYPE, CONST CHAR *ARG)
{
  INT RET;
  STRUCT PEER *PEER;
  STRUCT LISTNODE *NODE, *NNODE;

  /* CLEAR ALL NEIGHBORS. */
  IF (SORT == CLEAR_ALL)
    {
      FOR (ALL_LIST_ELEMENTS (BGP->PEER, NODE, NNODE, PEER))
	{
	  IF (STYPE == BGP_CLEAR_SOFT_NONE)
	    RET = PEER_CLEAR (PEER);
	  ELSE
	    RET = PEER_CLEAR_SOFT (PEER, AFI, SAFI, STYPE);

	  IF (RET < 0)
	    BGP_CLEAR_VTY_ERROR (VTY, PEER, AFI, SAFI, RET);
	}
      RETURN 0;
    }

  /* CLEAR SPECIFIED NEIGHBORS. */
  IF (SORT == CLEAR_PEER)
    {
      UNION SOCKUNION SU;
      INT RET;

      /* MAKE SOCKUNION FOR LOOKUP. */
      RET = STR2SOCKUNION (ARG, &SU);
      IF (RET < 0)
	{
	  VTY_OUT (VTY, "MALFORMED ADDRESS: %S%S", ARG, VTY_NEWLINE);
	  RETURN -1;
	}
      PEER = PEER_LOOKUP (BGP, &SU);
      IF (! PEER)
	{
	  VTY_OUT (VTY, "%%BGP: UNKNOWN NEIGHBOR - \"%S\"%S", ARG, VTY_NEWLINE);
	  RETURN -1;
	}

      IF (STYPE == BGP_CLEAR_SOFT_NONE)
	RET = PEER_CLEAR (PEER);
      ELSE
	RET = PEER_CLEAR_SOFT (PEER, AFI, SAFI, STYPE);

      IF (RET < 0)
	BGP_CLEAR_VTY_ERROR (VTY, PEER, AFI, SAFI, RET);

      RETURN 0;
    }

  /* CLEAR ALL PEER-GROUP MEMBERS. */
  IF (SORT == CLEAR_GROUP)
    {
      STRUCT PEER_GROUP *GROUP;

      GROUP = PEER_GROUP_LOOKUP (BGP, ARG);
      IF (! GROUP)
	{
	  VTY_OUT (VTY, "%%BGP: NO SUCH PEER-GROUP %S%S", ARG, VTY_NEWLINE);
	  RETURN -1; 
	}

      FOR (ALL_LIST_ELEMENTS (GROUP->PEER, NODE, NNODE, PEER))
	{
	  IF (STYPE == BGP_CLEAR_SOFT_NONE)
	    {
	      RET = PEER_CLEAR (PEER);
	      CONTINUE;
	    }

	  IF (! PEER->AF_GROUP[AFI][SAFI])
	    CONTINUE;

	  RET = PEER_CLEAR_SOFT (PEER, AFI, SAFI, STYPE);

	  IF (RET < 0)
	    BGP_CLEAR_VTY_ERROR (VTY, PEER, AFI, SAFI, RET);
	}
      RETURN 0;
    }

  IF (SORT == CLEAR_EXTERNAL)
    {
      FOR (ALL_LIST_ELEMENTS (BGP->PEER, NODE, NNODE, PEER))
	{
	  IF (PEER_SORT (PEER) == BGP_PEER_IBGP) 
	    CONTINUE;

	  IF (STYPE == BGP_CLEAR_SOFT_NONE)
	    RET = PEER_CLEAR (PEER);
	  ELSE
	    RET = PEER_CLEAR_SOFT (PEER, AFI, SAFI, STYPE);

	  IF (RET < 0)
	    BGP_CLEAR_VTY_ERROR (VTY, PEER, AFI, SAFI, RET);
	}
      RETURN 0;
    }

  IF (SORT == CLEAR_AS)
    {
      AS_T AS;
      UNSIGNED LONG AS_UL;
      CHAR *ENDPTR = NULL;
      INT FIND = 0;

      AS_UL = STRTOUL(ARG, &ENDPTR, 10);

      IF ((AS_UL == ULONG_MAX) || (*ENDPTR != '\0') || (AS_UL > USHRT_MAX))
	{
	  VTY_OUT (VTY, "INVALID AS NUMBER%S", VTY_NEWLINE); 
	  RETURN -1;
	}
      AS = (AS_T) AS_UL;

      FOR (ALL_LIST_ELEMENTS (BGP->PEER, NODE, NNODE, PEER))
	{
	  IF (PEER->AS != AS) 
	    CONTINUE;

	  FIND = 1;
	  IF (STYPE == BGP_CLEAR_SOFT_NONE)
	    RET = PEER_CLEAR (PEER);
	  ELSE
	    RET = PEER_CLEAR_SOFT (PEER, AFI, SAFI, STYPE);

	  IF (RET < 0)
	    BGP_CLEAR_VTY_ERROR (VTY, PEER, AFI, SAFI, RET);
	}
      IF (! FIND)
	VTY_OUT (VTY, "%%BGP: NO PEER IS CONFIGURED WITH AS %S%S", ARG,
		 VTY_NEWLINE);
      RETURN 0;
    }

  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 289249_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SND_PCM_OSS_MAKE_READY_LOCKED(STRUCT SND_PCM_SUBSTREAM *SUBSTREAM)
{
	STRUCT SND_PCM_RUNTIME *RUNTIME;
	INT ERR;

	RUNTIME = SUBSTREAM->RUNTIME;
	IF (RUNTIME->OSS.PARAMS) {
		ERR = SND_PCM_OSS_CHANGE_PARAMS_LOCKED(SUBSTREAM);
		IF (ERR < 0)
			RETURN ERR;
	}
	IF (RUNTIME->OSS.PREPARE) {
		ERR = SND_PCM_OSS_PREPARE(SUBSTREAM);
		IF (ERR < 0)
			RETURN ERR;
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208115_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT XEMACLITE_OF_PROBE(STRUCT PLATFORM_DEVICE *OFDEV)
{
	STRUCT RESOURCE *RES;
	STRUCT NET_DEVICE *NDEV = NULL;
	STRUCT NET_LOCAL *LP = NULL;
	STRUCT DEVICE *DEV = &OFDEV->DEV;

	INT RC = 0;

	DEV_INFO(DEV, "DEVICE TREE PROBING\N");

	/* CREATE AN ETHERNET DEVICE INSTANCE */
	NDEV = ALLOC_ETHERDEV(SIZEOF(STRUCT NET_LOCAL));
	IF (!NDEV)
		RETURN -ENOMEM;

	DEV_SET_DRVDATA(DEV, NDEV);
	SET_NETDEV_DEV(NDEV, &OFDEV->DEV);

	LP = NETDEV_PRIV(NDEV);
	LP->NDEV = NDEV;

	/* GET IRQ FOR THE DEVICE */
	RES = PLATFORM_GET_RESOURCE(OFDEV, IORESOURCE_IRQ, 0);
	IF (!RES) {
		DEV_ERR(DEV, "NO IRQ FOUND\N");
		RC = -ENXIO;
		GOTO ERROR;
	}

	NDEV->IRQ = RES->START;

	RES = PLATFORM_GET_RESOURCE(OFDEV, IORESOURCE_MEM, 0);
	LP->BASE_ADDR = DEVM_IOREMAP_RESOURCE(&OFDEV->DEV, RES);
	IF (IS_ERR(LP->BASE_ADDR)) {
		RC = PTR_ERR(LP->BASE_ADDR);
		GOTO ERROR;
	}

	NDEV->MEM_START = RES->START;
	NDEV->MEM_END = RES->END;

	SPIN_LOCK_INIT(&LP->RESET_LOCK);
	LP->NEXT_TX_BUF_TO_USE = 0X0;
	LP->NEXT_RX_BUF_TO_USE = 0X0;
	LP->TX_PING_PONG = GET_BOOL(OFDEV, "XLNX,TX-PING-PONG");
	LP->RX_PING_PONG = GET_BOOL(OFDEV, "XLNX,RX-PING-PONG");

	RC = OF_GET_MAC_ADDRESS(OFDEV->DEV.OF_NODE, NDEV->DEV_ADDR);
	IF (RC) {
		DEV_WARN(DEV, "NO MAC ADDRESS FOUND, USING RANDOM\N");
		ETH_HW_ADDR_RANDOM(NDEV);
	}

	/* CLEAR THE TX CSR'S IN CASE THIS IS A RESTART */
	XEMACLITE_WRITEL(0, LP->BASE_ADDR + XEL_TSR_OFFSET);
	XEMACLITE_WRITEL(0, LP->BASE_ADDR + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET);

	/* SET THE MAC ADDRESS IN THE EMACLITE DEVICE */
	XEMACLITE_UPDATE_ADDRESS(LP, NDEV->DEV_ADDR);

	LP->PHY_NODE = OF_PARSE_PHANDLE(OFDEV->DEV.OF_NODE, "PHY-HANDLE", 0);
	XEMACLITE_MDIO_SETUP(LP, &OFDEV->DEV);

	DEV_INFO(DEV, "MAC ADDRESS IS NOW %PM\N", NDEV->DEV_ADDR);

	NDEV->NETDEV_OPS = &XEMACLITE_NETDEV_OPS;
	NDEV->ETHTOOL_OPS = &XEMACLITE_ETHTOOL_OPS;
	NDEV->FLAGS &= ~IFF_MULTICAST;
	NDEV->WATCHDOG_TIMEO = TX_TIMEOUT;

	/* FINALLY, REGISTER THE DEVICE */
	RC = REGISTER_NETDEV(NDEV);
	IF (RC) {
		DEV_ERR(DEV,
			"CANNOT REGISTER NETWORK DEVICE, ABORTING\N");
		GOTO ERROR;
	}

	DEV_INFO(DEV,
		 "XILINX EMACLITE AT 0X%08LX MAPPED TO 0X%08LX, IRQ=%D\N",
		 (UNSIGNED LONG __FORCE)NDEV->MEM_START,
		 (UNSIGNED LONG __FORCE)LP->BASE_ADDR, NDEV->IRQ);
	RETURN 0;

ERROR:
	FREE_NETDEV(NDEV);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359281_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ZROUTE_LOOKUP(U_INT ZROUTE)
{
  U_INT I;

  IF (ZROUTE >= SIZEOF(ROUTE_TYPES)/SIZEOF(ROUTE_TYPES[0]))
    {
      ZLOG_ERR("UNKNOWN ZEBRA ROUTE TYPE: %U", ZROUTE);
      RETURN &UNKNOWN;
    }
  IF (ZROUTE == ROUTE_TYPES[ZROUTE].TYPE)
    RETURN &ROUTE_TYPES[ZROUTE];
  FOR (I = 0; I < SIZEOF(ROUTE_TYPES)/SIZEOF(ROUTE_TYPES[0]); I++)
    {
      IF (ZROUTE == ROUTE_TYPES[I].TYPE)
        {
	  ZLOG_WARN("INTERNAL ERROR: ROUTE TYPE TABLE OUT OF ORDER "
		    "WHILE SEARCHING FOR %U, PLEASE NOTIFY DEVELOPERS", ZROUTE);
	  RETURN &ROUTE_TYPES[I];
        }
    }
  ZLOG_ERR("INTERNAL ERROR: CANNOT FIND ROUTE TYPE %U IN TABLE!", ZROUTE);
  RETURN &UNKNOWN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248766_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CHAR *SANITIZE_COOKIE_PATH(CONST CHAR *COOKIE_PATH)
{
  SIZE_T LEN;
  CHAR *NEW_PATH = STRDUP(COOKIE_PATH);
  IF(!NEW_PATH)
    RETURN NULL;

  /* SOME STUPID SITE SENDS PATH ATTRIBUTE WITH '"'. */
  LEN = STRLEN(NEW_PATH);
  IF(NEW_PATH[0] == '\"') {
    MEMMOVE((VOID *)NEW_PATH, (CONST VOID *)(NEW_PATH + 1), LEN);
    LEN--;
  }
  IF(LEN && (NEW_PATH[LEN - 1] == '\"')) {
    NEW_PATH[LEN - 1] = 0X0;
    LEN--;
  }

  /* RFC6265 5.2.4 THE PATH ATTRIBUTE */
  IF(NEW_PATH[0] != '/') {
    /* LET COOKIE-PATH BE THE DEFAULT-PATH. */
    STRSTORE(&NEW_PATH, "/");
    RETURN NEW_PATH;
  }

  /* CONVERT /HOGE/ TO /HOGE */
  IF(LEN && NEW_PATH[LEN - 1] == '/') {
    NEW_PATH[LEN - 1] = 0X0;
  }

  RETURN NEW_PATH;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210570_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC RCORESYMCACHEELEMENT *PARSEDRAGONS(RBINFILE *BF, RBUFFER *BUF, INT OFF, INT BITS, R_OWN CHAR *FILE_NAME) {
	D EPRINTF ("DRAGONS AT 0X%X\N", OFF);
	UT64 SIZE = R_BUF_SIZE (BUF);
	IF (OFF >= SIZE) {
		RETURN NULL;
	}
	SIZE -= OFF;
	IF (!SIZE) {
		RETURN NULL;
	}
	UT8 *B = MALLOC (SIZE);
	IF (!B) {
		RETURN NULL;
	}
	INT AVAILABLE = R_BUF_READ_AT (BUF, OFF, B, SIZE);
	IF (AVAILABLE != SIZE) {
		EPRINTF ("WARNING: R_BUF_READ_AT FAILED\N");
		RETURN NULL;
	}
#IF 0
	// AFTER THE LIST OF SECTIONS, THERE'S A BUNCH OF UNKNOWN
	// DATA, BROBABLY DWORDS, AND THEN THE SAME SECTION LIST AGAIN
	// THIS FUNCTION AIMS TO PARSE IT.
	0X00000138 |1A2B B2A1 0300 0000 1A2B B2A1 E055 0000| .+.......+...U..
                         N_SEGMENTS ----.          .--- HOW MANY SECTIONS ?
	0X00000148 |0100 0000 CA55 0000 0400 0000 1800 0000| .....U..........
	             .---- HOW MANY SYMBOLS? 0XC7
	0X00000158 |C700 0000 0000 0000 0000 0000 0104 0000| ................
	0X00000168 |250B E803 0000 0100 0000 0000 BD55 0000| %............U..
	0X00000178 |91BB E903 E35A B42C 93A4 340A 8746 9489| .....Z.,..4..F..
	0X00000188 |0CEA 4C40 0C00 0000 0900 0000 0000 0000| ..L@............
	0X00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................
	0X000001A8 |0080 0000 0000 0000 5F5F 5445 5854 0000| ........__TEXT..
	0X000001B8 |0000 0000 0000 0000 0080 0000 0000 0000| ................
	0X000001C8 |0040 0000 0000 0000 5F5F 4441 5441 0000| .@......__DATA..
	0X000001D8 |0000 0000 0000 0000 00C0 0000 0000 0000| ................
	0X000001E8 |0000 0100 0000 0000 5F5F 4C4C 564D 0000| ........__LLVM..
	0X000001F8 |0000 0000 0000 0000 00C0 0100 0000 0000| ................
	0X00000208 |00C0 0000 0000 0000 5F5F 4C49 4E4B 4544| ........__LINKED
	0X00000218 |4954 0000 0000 0000 0000 0000 D069 0000| IT...........I..
#ENDIF
	// EPRINTF ("DRAGON'S MAGIC:\N");
	INT MAGICCOMBO = 0;
	IF (!MEMCMP ("\X1A\X2B\XB2\XA1", B, 4)) { // 0X130  ?
		MAGICCOMBO++;
	}
	IF (!MEMCMP ("\X1A\X2B\XB2\XA1", B + 8, 4)) {
		MAGICCOMBO++;
	}
	IF (MAGICCOMBO != 2) {
		// HACK FOR C22F7494
		AVAILABLE = R_BUF_READ_AT (BUF, OFF - 8, B, SIZE);
		IF (AVAILABLE != SIZE) {
			EPRINTF ("WARNING: R_BUF_READ_AT FAILED\N");
			RETURN NULL;
		}
		IF (!MEMCMP ("\X1A\X2B\XB2\XA1", B, 4)) { // 0X130  ?
			OFF -= 8;
		} ELSE {
			EPRINTF ("0X%08X  PARSING ERROR: INVALID MAGIC RETRY\N", OFF);
		}
	}
	D EPRINTF ("0X%08X  MAGIC  OK\N", OFF);
	D {
		CONST INT E0SS = R_READ_LE32 (B + 12);
		EPRINTF ("0X%08X  EOSS   0X%X\N", OFF + 12, E0SS);
	}
	FREE (B);
	RETURN R_CORESYM_CACHE_ELEMENT_NEW (BF, BUF, OFF + 16, BITS, FILE_NAME);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208654_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PHP_MINIT_FUNCTION(SNMP)
{
	NETSNMP_LOG_HANDLER *LOGH;
	ZEND_CLASS_ENTRY CE, CEX;

	LE_SNMP_SESSION = ZEND_REGISTER_LIST_DESTRUCTORS_EX(PHP_SNMP_SESSION_DESTRUCTOR, NULL, PHP_SNMP_SESSION_RES_NAME, MODULE_NUMBER);

	INIT_SNMP("SNMPAPP");

#IFDEF NETSNMP_DS_LIB_DONT_PERSIST_STATE
	/* PREVENT UPDATE OF THE SNMPAPP.CONF FILE */
	NETSNMP_DS_SET_BOOLEAN(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PERSIST_STATE, 1);
#ENDIF

	/* DISABLE LOGGING, USE EXIT STATUS'ES AND RELATED VARIABLED TO DETECT ERRORS */
	SHUTDOWN_SNMP_LOGGING();
	LOGH = NETSNMP_REGISTER_LOGHANDLER(NETSNMP_LOGHANDLER_NONE, LOG_ERR);
	IF (LOGH) {
		LOGH->PRI_MAX = LOG_ERR;
	}

	MEMCPY(&PHP_SNMP_OBJECT_HANDLERS, ZEND_GET_STD_OBJECT_HANDLERS(), SIZEOF(ZEND_OBJECT_HANDLERS));
	PHP_SNMP_OBJECT_HANDLERS.READ_PROPERTY = PHP_SNMP_READ_PROPERTY;
	PHP_SNMP_OBJECT_HANDLERS.WRITE_PROPERTY = PHP_SNMP_WRITE_PROPERTY;
	PHP_SNMP_OBJECT_HANDLERS.HAS_PROPERTY = PHP_SNMP_HAS_PROPERTY;
	PHP_SNMP_OBJECT_HANDLERS.GET_PROPERTIES = PHP_SNMP_GET_PROPERTIES;

	/* REGISTER SNMP CLASS */
	INIT_CLASS_ENTRY(CE, "SNMP", PHP_SNMP_CLASS_METHODS);
	CE.CREATE_OBJECT = PHP_SNMP_OBJECT_NEW;
	PHP_SNMP_OBJECT_HANDLERS.CLONE_OBJ = NULL;
	PHP_SNMP_CE = ZEND_REGISTER_INTERNAL_CLASS(&CE TSRMLS_CC);

	/* REGISTER SNMP CLASS PROPERTIES */
	ZEND_HASH_INIT(&PHP_SNMP_PROPERTIES, 0, NULL, NULL, 1);
	PHP_SNMP_ADD_PROPERTIES(&PHP_SNMP_PROPERTIES, PHP_SNMP_PROPERTY_ENTRIES);

	REGISTER_LONG_CONSTANT("SNMP_OID_OUTPUT_SUFFIX",	NETSNMP_OID_OUTPUT_SUFFIX,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OID_OUTPUT_MODULE",	NETSNMP_OID_OUTPUT_MODULE,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OID_OUTPUT_FULL",		NETSNMP_OID_OUTPUT_FULL,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OID_OUTPUT_NUMERIC",	NETSNMP_OID_OUTPUT_NUMERIC,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OID_OUTPUT_UCD",		NETSNMP_OID_OUTPUT_UCD,		CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OID_OUTPUT_NONE",		NETSNMP_OID_OUTPUT_NONE,	CONST_CS | CONST_PERSISTENT);

	REGISTER_LONG_CONSTANT("SNMP_VALUE_LIBRARY",	SNMP_VALUE_LIBRARY,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_VALUE_PLAIN",	SNMP_VALUE_PLAIN,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_VALUE_OBJECT",	SNMP_VALUE_OBJECT,	CONST_CS | CONST_PERSISTENT);

	REGISTER_LONG_CONSTANT("SNMP_BIT_STR",		ASN_BIT_STR,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OCTET_STR",	ASN_OCTET_STR,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OPAQUE",		ASN_OPAQUE,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_NULL",		ASN_NULL,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_OBJECT_ID",	ASN_OBJECT_ID,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_IPADDRESS",	ASN_IPADDRESS,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_COUNTER",		ASN_GAUGE,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_UNSIGNED",		ASN_UNSIGNED,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_TIMETICKS",	ASN_TIMETICKS,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_UINTEGER",		ASN_UINTEGER,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_INTEGER",		ASN_INTEGER,	CONST_CS | CONST_PERSISTENT);
	REGISTER_LONG_CONSTANT("SNMP_COUNTER64",	ASN_COUNTER64,	CONST_CS | CONST_PERSISTENT);

	REGISTER_SNMP_CLASS_CONST_LONG("VERSION_1",			SNMP_VERSION_1);
	REGISTER_SNMP_CLASS_CONST_LONG("VERSION_2C",			SNMP_VERSION_2C);
	REGISTER_SNMP_CLASS_CONST_LONG("VERSION_2C",			SNMP_VERSION_2C);
	REGISTER_SNMP_CLASS_CONST_LONG("VERSION_3",			SNMP_VERSION_3);

	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_NOERROR",			PHP_SNMP_ERRNO_NOERROR);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_ANY",			PHP_SNMP_ERRNO_ANY);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_GENERIC",			PHP_SNMP_ERRNO_GENERIC);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_TIMEOUT",			PHP_SNMP_ERRNO_TIMEOUT);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_ERROR_IN_REPLY",		PHP_SNMP_ERRNO_ERROR_IN_REPLY);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_OID_NOT_INCREASING",	PHP_SNMP_ERRNO_OID_NOT_INCREASING);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_OID_PARSING_ERROR",	PHP_SNMP_ERRNO_OID_PARSING_ERROR);
	REGISTER_SNMP_CLASS_CONST_LONG("ERRNO_MULTIPLE_SET_QUERIES",	PHP_SNMP_ERRNO_MULTIPLE_SET_QUERIES);

	/* REGISTER SNMPEXCEPTION CLASS */
	INIT_CLASS_ENTRY(CEX, "SNMPEXCEPTION", NULL);
#IFDEF HAVE_SPL
	PHP_SNMP_EXCEPTION_CE = ZEND_REGISTER_INTERNAL_CLASS_EX(&CEX, SPL_CE_RUNTIMEEXCEPTION, NULL TSRMLS_CC);
#ELSE
	PHP_SNMP_EXCEPTION_CE = ZEND_REGISTER_INTERNAL_CLASS_EX(&CEX, ZEND_EXCEPTION_GET_DEFAULT(TSRMLS_C), NULL TSRMLS_CC);
#ENDIF

	RETURN SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 482688_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FLX_DECODE_DELTA_FLC (GSTFLXDEC * FLXDEC, GUCHAR * DATA, GUCHAR * DEST)
{
  GULONG COUNT, LINES, START_L, OPCODE;
  GUCHAR *START_P;

  G_RETURN_VAL_IF_FAIL (FLXDEC != NULL, FALSE);
  G_RETURN_VAL_IF_FAIL (FLXDEC->DELTA_DATA != NULL, FALSE);

  /* USE LAST FRAME FOR DELTA */
  MEMCPY (DEST, FLXDEC->DELTA_DATA, FLXDEC->SIZE);

  LINES = (DATA[0] + (DATA[1] << 8));
  IF (LINES > FLXDEC->HDR.HEIGHT) {
    GST_ERROR_OBJECT (FLXDEC, "INVALID FLC PACKET DETECTED. TOO MANY LINES.");
    RETURN FALSE;
  }
  DATA += 2;

  START_P = DEST;
  START_L = LINES;

  WHILE (LINES) {
    DEST = START_P + (FLXDEC->HDR.WIDTH * (START_L - LINES));

    /* PROCESS OPCODE(S) */
    WHILE ((OPCODE = (DATA[0] + (DATA[1] << 8))) & 0XC000) {
      DATA += 2;
      IF ((OPCODE & 0XC000) == 0XC000) {
        /* LINE SKIP COUNT */
        GULONG SKIP = (0X10000 - OPCODE);
        IF (SKIP > FLXDEC->HDR.HEIGHT) {
          GST_ERROR_OBJECT (FLXDEC, "INVALID FLC PACKET DETECTED. "
              "SKIP LINE COUNT TOO BIG.");
          RETURN FALSE;
        }
        START_L += SKIP;
        DEST += FLXDEC->HDR.WIDTH * SKIP;
      } ELSE {
        /* LAST PIXEL */
        DEST += FLXDEC->HDR.WIDTH;
        *DEST++ = (OPCODE & 0XFF);
      }
    }
    DATA += 2;

    /* LAST OPCODE IS THE PACKET COUNT */
    WHILE (OPCODE--) {
      /* SKIP COUNT */
      GUCHAR SKIP = *DATA++;
      DEST += SKIP;

      /* RLE COUNT */
      COUNT = *DATA++;

      IF (COUNT > 0X7F) {
        /* REPLICATE WORD RUN */
        COUNT = 0X100 - COUNT;

        IF (SKIP + COUNT > FLXDEC->HDR.WIDTH) {
          GST_ERROR_OBJECT (FLXDEC, "INVALID FLC PACKET DETECTED. "
              "LINE TOO LONG.");
          RETURN FALSE;
        }

        WHILE (COUNT--) {
          *DEST++ = DATA[0];
          *DEST++ = DATA[1];
        }
        DATA += 2;
      } ELSE {
        IF (SKIP + COUNT > FLXDEC->HDR.WIDTH) {
          GST_ERROR_OBJECT (FLXDEC, "INVALID FLC PACKET DETECTED. "
              "LINE TOO LONG.");
          RETURN FALSE;
        }

        /* LITERAL WORD RUN */
        WHILE (COUNT--) {
          *DEST++ = *DATA++;
          *DEST++ = *DATA++;
        }
      }
    }
    LINES--;
  }

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213482_CWE-252.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NBD_INTERNAL_COMMAND_COMMON (STRUCT NBD_HANDLE *H,
                             UINT16_T FLAGS, UINT16_T TYPE,
                             UINT64_T OFFSET, UINT64_T COUNT, INT COUNT_ERR,
                             VOID *DATA, STRUCT COMMAND_CB *CB)
{
  STRUCT COMMAND *CMD;

  IF (H->DISCONNECT_REQUEST) {
      SET_ERROR (EINVAL, "CANNOT REQUEST MORE COMMANDS AFTER NBD_CMD_DISC");
      GOTO ERR;
  }
  IF (H->IN_FLIGHT == INT_MAX) {
      SET_ERROR (ENOMEM, "TOO MANY COMMANDS ALREADY IN FLIGHT");
      GOTO ERR;
  }

  IF (COUNT_ERR) {
    IF ((H->STRICT & LIBNBD_STRICT_ZERO_SIZE) && COUNT == 0) {
      SET_ERROR (EINVAL, "COUNT CANNOT BE 0");
      GOTO ERR;
    }

    IF ((H->STRICT & LIBNBD_STRICT_BOUNDS) &&
        (OFFSET > H->EXPORTSIZE || COUNT > H->EXPORTSIZE - OFFSET)) {
      SET_ERROR (COUNT_ERR, "REQUEST OUT OF BOUNDS");
      GOTO ERR;
    }

    IF (H->BLOCK_MINIMUM && (H->STRICT & LIBNBD_STRICT_ALIGN) &&
        (OFFSET | COUNT) & (H->BLOCK_MINIMUM - 1)) {
      SET_ERROR (EINVAL, "REQUEST IS UNALIGNED");
      GOTO ERR;
    }
  }

  SWITCH (TYPE) {
    /* COMMANDS WHICH SEND OR RECEIVE DATA ARE LIMITED TO MAX_REQUEST_SIZE. */
  CASE NBD_CMD_READ:
  CASE NBD_CMD_WRITE:
    IF (COUNT > MAX_REQUEST_SIZE) {
      SET_ERROR (ERANGE, "REQUEST TOO LARGE: MAXIMUM REQUEST SIZE IS %D",
                 MAX_REQUEST_SIZE);
      GOTO ERR;
    }
    BREAK;

    /* OTHER COMMANDS ARE CURRENTLY LIMITED BY THE 32 BIT FIELD IN THE
     * COMMAND STRUCTURE ON THE WIRE, BUT IN FUTURE WE HOPE TO SUPPORT
     * 64 BIT VALUES HERE WITH A CHANGE TO THE NBD PROTOCOL WHICH IS
     * BEING DISCUSSED UPSTREAM.
     */
  DEFAULT:
    IF (COUNT > UINT32_MAX) {
      SET_ERROR (ERANGE, "REQUEST TOO LARGE: MAXIMUM REQUEST SIZE IS %" PRIU32,
                 UINT32_MAX);
      GOTO ERR;
    }
    BREAK;
  }

  CMD = CALLOC (1, SIZEOF *CMD);
  IF (CMD == NULL) {
    SET_ERROR (ERRNO, "CALLOC");
    GOTO ERR;
  }
  CMD->FLAGS = FLAGS;
  CMD->TYPE = TYPE;
  CMD->COOKIE = H->UNIQUE++;
  CMD->OFFSET = OFFSET;
  CMD->COUNT = COUNT;
  CMD->DATA = DATA;
  IF (CB)
    CMD->CB = *CB;

  /* IF STRUCTURED REPLIES WERE NEGOTIATED THEN WE TRUST THE SERVER TO
   * SEND BACK SUFFICIENT DATA TO COVER THE WHOLE BUFFER.  IT'S TRICKY
   * TO CHECK THIS, SO AN EASIER THING IS SIMPLY TO ZERO THE BUFFER
   * AHEAD OF TIME WHICH AVOIDS ANY SECURITY PROBLEMS.  I MEASURED THE
   * OVERHEAD OF THIS AND FOR NON-TLS THERE IS NO MEASURABLE OVERHEAD
   * IN THE HIGHLY INTENSIVE LOOPBACK CASE.  FOR TLS WE GET A
   * PERFORMANCE GAIN, GO FIGURE.
   */
  IF (H->STRUCTURED_REPLIES && CMD->DATA && TYPE == NBD_CMD_READ)
    MEMSET (CMD->DATA, 0, CMD->COUNT);

  /* ADD THE COMMAND TO THE END OF THE QUEUE. KICK THE STATE MACHINE
   * IF THERE IS NO OTHER COMMAND BEING PROCESSED, OTHERWISE, IT WILL
   * BE HANDLED AUTOMATICALLY ON A FUTURE CYCLE AROUND TO READY.
   * BEYOND THIS POINT, WE HAVE TO RETURN A COOKIE TO THE USER, SINCE
   * WE ARE QUEUING THE COMMAND, EVEN IF KICKING THE STATE MACHINE
   * DETECTS A FAILURE.  NOT REPORTING A STATE MACHINE FAILURE HERE IS
   * OKAY - ANY CALLER OF AN ASYNC COMMAND WILL BE CALLING MORE API TO
   * AWAIT RESULTS, AND WILL EVENTUALLY LEARN THAT THE MACHINE HAS
   * MOVED ON TO DEAD AT THAT TIME.
   */
  H->IN_FLIGHT++;
  IF (H->CMDS_TO_ISSUE != NULL) {
    ASSERT (NBD_INTERNAL_IS_STATE_PROCESSING (GET_NEXT_STATE (H)));
    H->CMDS_TO_ISSUE_TAIL = H->CMDS_TO_ISSUE_TAIL->NEXT = CMD;
  }
  ELSE {
    ASSERT (H->CMDS_TO_ISSUE_TAIL == NULL);
    H->CMDS_TO_ISSUE = H->CMDS_TO_ISSUE_TAIL = CMD;
    IF (NBD_INTERNAL_IS_STATE_READY (GET_NEXT_STATE (H)) &&
        NBD_INTERNAL_RUN (H, CMD_ISSUE) == -1)
      DEBUG (H, "COMMAND QUEUED, IGNORING STATE MACHINE FAILURE");
  }

  RETURN CMD->COOKIE;

 ERR:
  /* SINCE WE DID NOT QUEUE THE COMMAND, WE MUST FREE THE CALLBACKS. */
  IF (CB) {
    IF (TYPE == NBD_CMD_BLOCK_STATUS)
      FREE_CALLBACK (CB->FN.EXTENT);
    IF (TYPE == NBD_CMD_READ)
      FREE_CALLBACK (CB->FN.CHUNK);
    FREE_CALLBACK (CB->COMPLETION);
  }
  RETURN -1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216515_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SSL3_GET_NEW_SESSION_TICKET(SSL *S)
{
    INT OK, AL, RET = 0, TICKLEN;
    LONG N;
    CONST UNSIGNED CHAR *P;
    UNSIGNED CHAR *D;

    N = S->METHOD->SSL_GET_MESSAGE(S,
                                   SSL3_ST_CR_SESSION_TICKET_A,
                                   SSL3_ST_CR_SESSION_TICKET_B,
                                   SSL3_MT_NEWSESSION_TICKET, 16384, &OK);

    IF (!OK)
        RETURN ((INT)N);

    IF (N < 6) {
        /* NEED AT LEAST TICKET_LIFETIME_HINT + TICKET LENGTH */
        AL = SSL_AD_DECODE_ERROR;
        SSLERR(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);
        GOTO F_ERR;
    }

    P = D = (UNSIGNED CHAR *)S->INIT_MSG;
    N2L(P, S->SESSION->TLSEXT_TICK_LIFETIME_HINT);
    N2S(P, TICKLEN);
    /* TICKET_LIFETIME_HINT + TICKET_LENGTH + TICKET */
    IF (TICKLEN + 6 != N) {
        AL = SSL_AD_DECODE_ERROR;
        SSLERR(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);
        GOTO F_ERR;
    }
    IF (S->SESSION->TLSEXT_TICK) {
        OPENSSL_FREE(S->SESSION->TLSEXT_TICK);
        S->SESSION->TLSEXT_TICKLEN = 0;
    }
    S->SESSION->TLSEXT_TICK = OPENSSL_MALLOC(TICKLEN);
    IF (!S->SESSION->TLSEXT_TICK) {
        SSLERR(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);
        GOTO ERR;
    }
    MEMCPY(S->SESSION->TLSEXT_TICK, P, TICKLEN);
    S->SESSION->TLSEXT_TICKLEN = TICKLEN;
    /*
     * THERE ARE TWO WAYS TO DETECT A RESUMED TICKET SESSION. ONE IS TO SET
     * AN APPROPRIATE SESSION ID AND THEN THE SERVER MUST RETURN A MATCH IN
     * SERVERHELLO. THIS ALLOWS THE NORMAL CLIENT SESSION ID MATCHING TO WORK
     * AND WE KNOW MUCH EARLIER THAT THE TICKET HAS BEEN ACCEPTED. THE
     * OTHER WAY IS TO SET ZERO LENGTH SESSION ID WHEN THE TICKET IS
     * PRESENTED AND RELY ON THE HANDSHAKE TO DETERMINE SESSION RESUMPTION.
     * WE CHOOSE THE FORMER APPROACH BECAUSE THIS FITS IN WITH ASSUMPTIONS
     * ELSEWHERE IN OPENSSL. THE SESSION ID IS SET TO THE SHA256 (OR SHA1 IS
     * SHA256 IS DISABLED) HASH OF THE TICKET.
     */
    EVP_DIGEST(P, TICKLEN,
               S->SESSION->SESSION_ID, &S->SESSION->SESSION_ID_LENGTH,
# IFNDEF OPENSSL_NO_SHA256
               EVP_SHA256(), NULL);
# ELSE
               EVP_SHA1(), NULL);
# ENDIF
    RET = 1;
    RETURN (RET);
 F_ERR:
    SSL3_SEND_ALERT(S, SSL3_AL_FATAL, AL);
 ERR:
    S->STATE = SSL_ST_ERR;
    RETURN (-1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195403_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITEINTARRAY* TFLITEINTARRAYCREATE(INT SIZE) {
  INT ALLOC_SIZE = TFLITEINTARRAYGETSIZEINBYTES(SIZE);
  IF (ALLOC_SIZE <= 0) RETURN NULL;
  TFLITEINTARRAY* RET = (TFLITEINTARRAY*)MALLOC(ALLOC_SIZE);
  IF (!RET) RETURN RET;
  RET->SIZE = SIZE;
  RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248274_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DLLIMPORT SIGNED LONG CFG_GETINT(CFG_T *CFG, CONST CHAR *NAME)
{
	RETURN CFG_GETNINT(CFG, NAME, 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195388_CWE-522.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PQCONNECTPOLL(PGCONN *CONN)
{
	BOOL		RESET_CONNECTION_STATE_MACHINE = FALSE;
	BOOL		NEED_NEW_CONNECTION = FALSE;
	PGRESULT   *RES;
	CHAR		SEBUF[PG_STRERROR_R_BUFLEN];
	INT			OPTVAL;

	IF (CONN == NULL)
		RETURN PGRES_POLLING_FAILED;

	/* GET THE NEW DATA */
	SWITCH (CONN->STATUS)
	{
			/*
			 * WE REALLY SHOULDN'T HAVE BEEN POLLED IN THESE TWO CASES, BUT WE
			 * CAN HANDLE IT.
			 */
		CASE CONNECTION_BAD:
			RETURN PGRES_POLLING_FAILED;
		CASE CONNECTION_OK:
			RETURN PGRES_POLLING_OK;

			/* THESE ARE READING STATES */
		CASE CONNECTION_AWAITING_RESPONSE:
		CASE CONNECTION_AUTH_OK:
		CASE CONNECTION_CHECK_WRITABLE:
		CASE CONNECTION_CONSUME:
		CASE CONNECTION_CHECK_STANDBY:
			{
				/* LOAD WAITING DATA */
				INT			N = PQREADDATA(CONN);

				IF (N < 0)
					GOTO ERROR_RETURN;
				IF (N == 0)
					RETURN PGRES_POLLING_READING;

				BREAK;
			}

			/* THESE ARE WRITING STATES, SO WE JUST PROCEED. */
		CASE CONNECTION_STARTED:
		CASE CONNECTION_MADE:
			BREAK;

			/* SPECIAL CASES: PROCEED WITHOUT WAITING. */
		CASE CONNECTION_SSL_STARTUP:
		CASE CONNECTION_NEEDED:
		CASE CONNECTION_GSS_STARTUP:
		CASE CONNECTION_CHECK_TARGET:
			BREAK;

		DEFAULT:
			APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
								 LIBPQ_GETTEXT("INVALID CONNECTION STATE, PROBABLY INDICATIVE OF MEMORY CORRUPTION\N"));
			GOTO ERROR_RETURN;
	}


KEEP_GOING:						/* WE WILL COME BACK TO HERE UNTIL THERE IS
								 * NOTHING LEFT TO DO. */

	/* TIME TO ADVANCE TO NEXT ADDRESS, OR NEXT HOST IF NO MORE ADDRESSES? */
	IF (CONN->TRY_NEXT_ADDR)
	{
		IF (CONN->ADDR_CUR && CONN->ADDR_CUR->AI_NEXT)
		{
			CONN->ADDR_CUR = CONN->ADDR_CUR->AI_NEXT;
			RESET_CONNECTION_STATE_MACHINE = TRUE;
		}
		ELSE
			CONN->TRY_NEXT_HOST = TRUE;
		CONN->TRY_NEXT_ADDR = FALSE;
	}

	/* TIME TO ADVANCE TO NEXT CONNHOST[] ENTRY? */
	IF (CONN->TRY_NEXT_HOST)
	{
		PG_CONN_HOST *CH;
		STRUCT ADDRINFO HINT;
		INT			THISPORT;
		INT			RET;
		CHAR		PORTSTR[MAXPGPATH];

		IF (CONN->WHICHHOST + 1 < CONN->NCONNHOST)
			CONN->WHICHHOST++;
		ELSE
		{
			/*
			 * OOPS, NO MORE HOSTS.
			 *
			 * IF WE ARE TRYING TO CONNECT IN "PREFER-STANDBY" MODE, THEN DROP
			 * THE STANDBY REQUIREMENT AND START OVER.
			 *
			 * OTHERWISE, AN APPROPRIATE ERROR MESSAGE IS ALREADY SET UP, SO
			 * WE JUST NEED TO SET THE RIGHT STATUS.
			 */
			IF (CONN->TARGET_SERVER_TYPE == SERVER_TYPE_PREFER_STANDBY &&
				CONN->NCONNHOST > 0)
			{
				CONN->TARGET_SERVER_TYPE = SERVER_TYPE_PREFER_STANDBY_PASS2;
				CONN->WHICHHOST = 0;
			}
			ELSE
				GOTO ERROR_RETURN;
		}

		/* DROP ANY ADDRESS INFO FOR PREVIOUS HOST */
		RELEASE_CONN_ADDRINFO(CONN);

		/*
		 * LOOK UP INFO FOR THE NEW HOST.  ON FAILURE, LOG THE PROBLEM IN
		 * CONN->ERRORMESSAGE, THEN LOOP AROUND TO TRY THE NEXT HOST.  (NOTE
		 * WE DON'T CLEAR TRY_NEXT_HOST UNTIL WE'VE SUCCEEDED.)
		 */
		CH = &CONN->CONNHOST[CONN->WHICHHOST];

		/* INITIALIZE HINT STRUCTURE */
		MEMSET(&HINT, 0, SIZEOF(HINT));
		HINT.AI_SOCKTYPE = SOCK_STREAM;
		CONN->ADDRLIST_FAMILY = HINT.AI_FAMILY = AF_UNSPEC;

		/* FIGURE OUT THE PORT NUMBER WE'RE GOING TO USE. */
		IF (CH->PORT == NULL || CH->PORT[0] == '\0')
			THISPORT = DEF_PGPORT;
		ELSE
		{
			IF (!PARSE_INT_PARAM(CH->PORT, &THISPORT, CONN, "PORT"))
				GOTO ERROR_RETURN;

			IF (THISPORT < 1 || THISPORT > 65535)
			{
				APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
								  LIBPQ_GETTEXT("INVALID PORT NUMBER: \"%S\"\N"),
								  CH->PORT);
				GOTO KEEP_GOING;
			}
		}
		SNPRINTF(PORTSTR, SIZEOF(PORTSTR), "%D", THISPORT);

		/* USE PG_GETADDRINFO_ALL() TO RESOLVE THE ADDRESS */
		SWITCH (CH->TYPE)
		{
			CASE CHT_HOST_NAME:
				RET = PG_GETADDRINFO_ALL(CH->HOST, PORTSTR, &HINT,
										 &CONN->ADDRLIST);
				IF (RET || !CONN->ADDRLIST)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("COULD NOT TRANSLATE HOST NAME \"%S\" TO ADDRESS: %S\N"),
									  CH->HOST, GAI_STRERROR(RET));
					GOTO KEEP_GOING;
				}
				BREAK;

			CASE CHT_HOST_ADDRESS:
				HINT.AI_FLAGS = AI_NUMERICHOST;
				RET = PG_GETADDRINFO_ALL(CH->HOSTADDR, PORTSTR, &HINT,
										 &CONN->ADDRLIST);
				IF (RET || !CONN->ADDRLIST)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("COULD NOT PARSE NETWORK ADDRESS \"%S\": %S\N"),
									  CH->HOSTADDR, GAI_STRERROR(RET));
					GOTO KEEP_GOING;
				}
				BREAK;

			CASE CHT_UNIX_SOCKET:
#IFDEF HAVE_UNIX_SOCKETS
				CONN->ADDRLIST_FAMILY = HINT.AI_FAMILY = AF_UNIX;
				UNIXSOCK_PATH(PORTSTR, THISPORT, CH->HOST);
				IF (STRLEN(PORTSTR) >= UNIXSOCK_PATH_BUFLEN)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("UNIX-DOMAIN SOCKET PATH \"%S\" IS TOO LONG (MAXIMUM %D BYTES)\N"),
									  PORTSTR,
									  (INT) (UNIXSOCK_PATH_BUFLEN - 1));
					GOTO KEEP_GOING;
				}

				/*
				 * NULL HOSTNAME TELLS PG_GETADDRINFO_ALL TO PARSE THE SERVICE
				 * NAME AS A UNIX-DOMAIN SOCKET PATH.
				 */
				RET = PG_GETADDRINFO_ALL(NULL, PORTSTR, &HINT,
										 &CONN->ADDRLIST);
				IF (RET || !CONN->ADDRLIST)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("COULD NOT TRANSLATE UNIX-DOMAIN SOCKET PATH \"%S\" TO ADDRESS: %S\N"),
									  PORTSTR, GAI_STRERROR(RET));
					GOTO KEEP_GOING;
				}
#ELSE
				ASSERT(FALSE);
#ENDIF
				BREAK;
		}

		/* OK, SCAN THIS ADDRLIST FOR A WORKING SERVER ADDRESS */
		CONN->ADDR_CUR = CONN->ADDRLIST;
		RESET_CONNECTION_STATE_MACHINE = TRUE;
		CONN->TRY_NEXT_HOST = FALSE;
	}

	/* RESET CONNECTION STATE MACHINE? */
	IF (RESET_CONNECTION_STATE_MACHINE)
	{
		/*
		 * (RE) INITIALIZE OUR CONNECTION CONTROL VARIABLES FOR A SET OF
		 * CONNECTION ATTEMPTS TO A SINGLE SERVER ADDRESS.  THESE VARIABLES
		 * MUST PERSIST ACROSS INDIVIDUAL CONNECTION ATTEMPTS, BUT WE MUST
		 * RESET THEM WHEN WE START TO CONSIDER A NEW SERVER.
		 */
		CONN->PVERSION = PG_PROTOCOL(3, 0);
		CONN->SEND_APPNAME = TRUE;
#IFDEF USE_SSL
		/* INITIALIZE THESE VALUES BASED ON SSL MODE */
		CONN->ALLOW_SSL_TRY = (CONN->SSLMODE[0] != 'D');	/* "DISABLE" */
		CONN->WAIT_SSL_TRY = (CONN->SSLMODE[0] == 'A'); /* "ALLOW" */
#ENDIF
#IFDEF ENABLE_GSS
		CONN->TRY_GSS = (CONN->GSSENCMODE[0] != 'D');	/* "DISABLE" */
#ENDIF

		RESET_CONNECTION_STATE_MACHINE = FALSE;
		NEED_NEW_CONNECTION = TRUE;
	}

	/* FORCE A NEW CONNECTION (PERHAPS TO THE SAME SERVER AS BEFORE)? */
	IF (NEED_NEW_CONNECTION)
	{
		/* DROP ANY EXISTING CONNECTION */
		PQDROPCONNECTION(CONN, TRUE);

		/* RESET ALL STATE OBTAINED FROM OLD SERVER */
		PQDROPSERVERDATA(CONN);

		/* DROP ANY PGRESULT WE MIGHT HAVE, TOO */
		CONN->ASYNCSTATUS = PGASYNC_IDLE;
		CONN->XACTSTATUS = PQTRANS_IDLE;
		CONN->PIPELINESTATUS = PQ_PIPELINE_OFF;
		PQCLEARASYNCRESULT(CONN);

		/* RESET CONN->STATUS TO PUT THE STATE MACHINE IN THE RIGHT STATE */
		CONN->STATUS = CONNECTION_NEEDED;

		NEED_NEW_CONNECTION = FALSE;
	}

	/* NOW TRY TO ADVANCE THE STATE MACHINE FOR THIS CONNECTION */
	SWITCH (CONN->STATUS)
	{
		CASE CONNECTION_NEEDED:
			{
				/*
				 * TRY TO INITIATE A CONNECTION TO ONE OF THE ADDRESSES
				 * RETURNED BY PG_GETADDRINFO_ALL().  CONN->ADDR_CUR IS THE
				 * NEXT ONE TO TRY.
				 *
				 * THE EXTRA LEVEL OF BRACES HERE IS HISTORICAL.  IT'S NOT
				 * WORTH REINDENTING THIS WHOLE SWITCH CASE TO REMOVE 'EM.
				 */
				{
					STRUCT ADDRINFO *ADDR_CUR = CONN->ADDR_CUR;
					CHAR		HOST_ADDR[NI_MAXHOST];

					/*
					 * ADVANCE TO NEXT POSSIBLE HOST, IF WE'VE TRIED ALL OF
					 * THE ADDRESSES FOR THE CURRENT HOST.
					 */
					IF (ADDR_CUR == NULL)
					{
						CONN->TRY_NEXT_HOST = TRUE;
						GOTO KEEP_GOING;
					}

					/* REMEMBER CURRENT ADDRESS FOR POSSIBLE USE LATER */
					MEMCPY(&CONN->RADDR.ADDR, ADDR_CUR->AI_ADDR,
						   ADDR_CUR->AI_ADDRLEN);
					CONN->RADDR.SALEN = ADDR_CUR->AI_ADDRLEN;

					/*
					 * SET CONNIP, TOO.  NOTE WE PURPOSELY IGNORE STRDUP
					 * FAILURE; NOT A BIG PROBLEM IF IT FAILS.
					 */
					IF (CONN->CONNIP != NULL)
					{
						FREE(CONN->CONNIP);
						CONN->CONNIP = NULL;
					}
					GETHOSTADDR(CONN, HOST_ADDR, NI_MAXHOST);
					IF (HOST_ADDR[0])
						CONN->CONNIP = STRDUP(HOST_ADDR);

					/* TRY TO CREATE THE SOCKET */
					CONN->SOCK = SOCKET(ADDR_CUR->AI_FAMILY, SOCK_STREAM, 0);
					IF (CONN->SOCK == PGINVALID_SOCKET)
					{
						INT			ERRORNO = SOCK_ERRNO;

						/*
						 * SILENTLY IGNORE SOCKET() FAILURE IF WE HAVE MORE
						 * ADDRESSES TO TRY; THIS REDUCES USELESS CHATTER IN
						 * CASES WHERE THE ADDRESS LIST INCLUDES BOTH IPV4 AND
						 * IPV6 BUT KERNEL ONLY ACCEPTS ONE FAMILY.
						 */
						IF (ADDR_CUR->AI_NEXT != NULL ||
							CONN->WHICHHOST + 1 < CONN->NCONNHOST)
						{
							CONN->TRY_NEXT_ADDR = TRUE;
							GOTO KEEP_GOING;
						}
						EMITHOSTIDENTITYINFO(CONN, HOST_ADDR);
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("COULD NOT CREATE SOCKET: %S\N"),
										  SOCK_STRERROR(ERRORNO, SEBUF, SIZEOF(SEBUF)));
						GOTO ERROR_RETURN;
					}

					/*
					 * ONCE WE'VE IDENTIFIED A TARGET ADDRESS, ALL ERRORS
					 * EXCEPT THE PRECEDING SOCKET()-FAILURE CASE SHOULD BE
					 * PREFIXED WITH HOST-IDENTITY INFORMATION.  (IF THE
					 * CONNECTION SUCCEEDS, THE CONTENTS OF CONN->ERRORMESSAGE
					 * WON'T MATTER, SO THIS IS HARMLESS.)
					 */
					EMITHOSTIDENTITYINFO(CONN, HOST_ADDR);

					/*
					 * SELECT SOCKET OPTIONS: NO DELAY OF OUTGOING DATA FOR
					 * TCP SOCKETS, NONBLOCK MODE, CLOSE-ON-EXEC.  TRY THE
					 * NEXT ADDRESS IF ANY OF THIS FAILS.
					 */
					IF (!IS_AF_UNIX(ADDR_CUR->AI_FAMILY))
					{
						IF (!CONNECTNODELAY(CONN))
						{
							/* ERROR MESSAGE ALREADY CREATED */
							CONN->TRY_NEXT_ADDR = TRUE;
							GOTO KEEP_GOING;
						}
					}
					IF (!PG_SET_NOBLOCK(CONN->SOCK))
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("COULD NOT SET SOCKET TO NONBLOCKING MODE: %S\N"),
										  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
						CONN->TRY_NEXT_ADDR = TRUE;
						GOTO KEEP_GOING;
					}

#IFDEF F_SETFD
					IF (FCNTL(CONN->SOCK, F_SETFD, FD_CLOEXEC) == -1)
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("COULD NOT SET SOCKET TO CLOSE-ON-EXEC MODE: %S\N"),
										  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
						CONN->TRY_NEXT_ADDR = TRUE;
						GOTO KEEP_GOING;
					}
#ENDIF							/* F_SETFD */

					IF (!IS_AF_UNIX(ADDR_CUR->AI_FAMILY))
					{
#IFNDEF WIN32
						INT			ON = 1;
#ENDIF
						INT			USEKEEPALIVES = USEKEEPALIVES(CONN);
						INT			ERR = 0;

						IF (USEKEEPALIVES < 0)
						{
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("KEEPALIVES PARAMETER MUST BE AN INTEGER\N"));
							ERR = 1;
						}
						ELSE IF (USEKEEPALIVES == 0)
						{
							/* DO NOTHING */
						}
#IFNDEF WIN32
						ELSE IF (SETSOCKOPT(CONN->SOCK,
											SOL_SOCKET, SO_KEEPALIVE,
											(CHAR *) &ON, SIZEOF(ON)) < 0)
						{
							APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
											  LIBPQ_GETTEXT("%S(%S) FAILED: %S\N"),
											  "SETSOCKOPT",
											  "SO_KEEPALIVE",
											  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
							ERR = 1;
						}
						ELSE IF (!SETKEEPALIVESIDLE(CONN)
								 || !SETKEEPALIVESINTERVAL(CONN)
								 || !SETKEEPALIVESCOUNT(CONN))
							ERR = 1;
#ELSE							/* WIN32 */
#IFDEF SIO_KEEPALIVE_VALS
						ELSE IF (!SETKEEPALIVESWIN32(CONN))
							ERR = 1;
#ENDIF							/* SIO_KEEPALIVE_VALS */
#ENDIF							/* WIN32 */
						ELSE IF (!SETTCPUSERTIMEOUT(CONN))
							ERR = 1;

						IF (ERR)
						{
							CONN->TRY_NEXT_ADDR = TRUE;
							GOTO KEEP_GOING;
						}
					}

					/*----------
					 * WE HAVE THREE METHODS OF BLOCKING SIGPIPE DURING
					 * SEND() CALLS TO THIS SOCKET:
					 *
					 *	- SETSOCKOPT(SOCK, SO_NOSIGPIPE)
					 *	- SEND(SOCK, ..., MSG_NOSIGNAL)
					 *	- SETTING THE SIGNAL MASK TO SIG_IGN DURING SEND()
					 *
					 * THE THIRD METHOD REQUIRES THREE SYSCALLS PER SEND,
					 * SO WE PREFER EITHER OF THE FIRST TWO, BUT THEY ARE
					 * LESS PORTABLE.  THE STATE IS TRACKED IN THE FOLLOWING
					 * MEMBERS OF PGCONN:
					 *
					 * CONN->SIGPIPE_SO		- WE HAVE SET UP SO_NOSIGPIPE
					 * CONN->SIGPIPE_FLAG	- WE'RE SPECIFYING MSG_NOSIGNAL
					 *
					 * IF WE CAN USE SO_NOSIGPIPE, THEN SET SIGPIPE_SO HERE
					 * AND WE'RE DONE.  OTHERWISE, SET SIGPIPE_FLAG SO THAT
					 * WE WILL TRY MSG_NOSIGNAL ON SENDS.  IF WE GET AN ERROR
					 * WITH MSG_NOSIGNAL, WE'LL CLEAR THAT FLAG AND REVERT TO
					 * SIGNAL MASKING.
					 *----------
					 */
					CONN->SIGPIPE_SO = FALSE;
#IFDEF MSG_NOSIGNAL
					CONN->SIGPIPE_FLAG = TRUE;
#ELSE
					CONN->SIGPIPE_FLAG = FALSE;
#ENDIF							/* MSG_NOSIGNAL */

#IFDEF SO_NOSIGPIPE
					OPTVAL = 1;
					IF (SETSOCKOPT(CONN->SOCK, SOL_SOCKET, SO_NOSIGPIPE,
								   (CHAR *) &OPTVAL, SIZEOF(OPTVAL)) == 0)
					{
						CONN->SIGPIPE_SO = TRUE;
						CONN->SIGPIPE_FLAG = FALSE;
					}
#ENDIF							/* SO_NOSIGPIPE */

					/*
					 * START/MAKE CONNECTION.  THIS SHOULD NOT BLOCK, SINCE WE
					 * ARE IN NONBLOCK MODE.  IF IT DOES, WELL, TOO BAD.
					 */
					IF (CONNECT(CONN->SOCK, ADDR_CUR->AI_ADDR,
								ADDR_CUR->AI_ADDRLEN) < 0)
					{
						IF (SOCK_ERRNO == EINPROGRESS ||
#IFDEF WIN32
							SOCK_ERRNO == EWOULDBLOCK ||
#ENDIF
							SOCK_ERRNO == EINTR)
						{
							/*
							 * THIS IS FINE - WE'RE IN NON-BLOCKING MODE, AND
							 * THE CONNECTION IS IN PROGRESS.  TELL CALLER TO
							 * WAIT FOR WRITE-READY ON SOCKET.
							 */
							CONN->STATUS = CONNECTION_STARTED;
							RETURN PGRES_POLLING_WRITING;
						}
						/* OTHERWISE, TROUBLE */
					}
					ELSE
					{
						/*
						 * HM, WE'RE CONNECTED ALREADY --- SEEMS THE "NONBLOCK
						 * CONNECTION" WASN'T.  ADVANCE THE STATE MACHINE AND
						 * GO DO THE NEXT STUFF.
						 */
						CONN->STATUS = CONNECTION_STARTED;
						GOTO KEEP_GOING;
					}

					/*
					 * THIS CONNECTION FAILED.  ADD THE ERROR REPORT TO
					 * CONN->ERRORMESSAGE, THEN TRY THE NEXT ADDRESS IF ANY.
					 */
					CONNECTFAILUREMESSAGE(CONN, SOCK_ERRNO);
					CONN->TRY_NEXT_ADDR = TRUE;
					GOTO KEEP_GOING;
				}
			}

		CASE CONNECTION_STARTED:
			{
				ACCEPT_TYPE_ARG3 OPTLEN = SIZEOF(OPTVAL);

				/*
				 * WRITE READY, SINCE WE'VE MADE IT HERE, SO THE CONNECTION
				 * HAS BEEN MADE ... OR HAS FAILED.
				 */

				/*
				 * NOW CHECK (USING GETSOCKOPT) THAT THERE IS NOT AN ERROR
				 * STATE WAITING FOR US ON THE SOCKET.
				 */

				IF (GETSOCKOPT(CONN->SOCK, SOL_SOCKET, SO_ERROR,
							   (CHAR *) &OPTVAL, &OPTLEN) == -1)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("COULD NOT GET SOCKET ERROR STATUS: %S\N"),
									  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
					GOTO ERROR_RETURN;
				}
				ELSE IF (OPTVAL != 0)
				{
					/*
					 * WHEN USING A NONBLOCKING CONNECT, WE WILL TYPICALLY SEE
					 * CONNECT FAILURES AT THIS POINT, SO PROVIDE A FRIENDLY
					 * ERROR MESSAGE.
					 */
					CONNECTFAILUREMESSAGE(CONN, OPTVAL);

					/*
					 * TRY THE NEXT ADDRESS IF ANY, JUST AS IN THE CASE WHERE
					 * CONNECT() RETURNED FAILURE IMMEDIATELY.
					 */
					CONN->TRY_NEXT_ADDR = TRUE;
					GOTO KEEP_GOING;
				}

				/* FILL IN THE CLIENT ADDRESS */
				CONN->LADDR.SALEN = SIZEOF(CONN->LADDR.ADDR);
				IF (GETSOCKNAME(CONN->SOCK,
								(STRUCT SOCKADDR *) &CONN->LADDR.ADDR,
								&CONN->LADDR.SALEN) < 0)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("COULD NOT GET CLIENT ADDRESS FROM SOCKET: %S\N"),
									  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
					GOTO ERROR_RETURN;
				}

				/*
				 * MAKE SURE WE CAN WRITE BEFORE ADVANCING TO NEXT STEP.
				 */
				CONN->STATUS = CONNECTION_MADE;
				RETURN PGRES_POLLING_WRITING;
			}

		CASE CONNECTION_MADE:
			{
				CHAR	   *STARTPACKET;
				INT			PACKETLEN;

				/*
				 * IMPLEMENT REQUIREPEER CHECK, IF REQUESTED AND IT'S A
				 * UNIX-DOMAIN SOCKET.
				 */
				IF (CONN->REQUIREPEER && CONN->REQUIREPEER[0] &&
					IS_AF_UNIX(CONN->RADDR.ADDR.SS_FAMILY))
				{
#IFNDEF WIN32
					CHAR		PWDBUF[BUFSIZ];
					STRUCT PASSWD PASS_BUF;
					STRUCT PASSWD *PASS;
					INT			PASSERR;
#ENDIF
					UID_T		UID;
					GID_T		GID;

					ERRNO = 0;
					IF (GETPEEREID(CONN->SOCK, &UID, &GID) != 0)
					{
						/*
						 * PROVIDE SPECIAL ERROR MESSAGE IF GETPEEREID IS A
						 * STUB
						 */
						IF (ERRNO == ENOSYS)
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("REQUIREPEER PARAMETER IS NOT SUPPORTED ON THIS PLATFORM\N"));
						ELSE
							APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
											  LIBPQ_GETTEXT("COULD NOT GET PEER CREDENTIALS: %S\N"),
											  STRERROR_R(ERRNO, SEBUF, SIZEOF(SEBUF)));
						GOTO ERROR_RETURN;
					}

#IFNDEF WIN32
					PASSERR = PQGETPWUID(UID, &PASS_BUF, PWDBUF, SIZEOF(PWDBUF), &PASS);
					IF (PASS == NULL)
					{
						IF (PASSERR != 0)
							APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
											  LIBPQ_GETTEXT("COULD NOT LOOK UP LOCAL USER ID %D: %S\N"),
											  (INT) UID,
											  STRERROR_R(PASSERR, SEBUF, SIZEOF(SEBUF)));
						ELSE
							APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
											  LIBPQ_GETTEXT("LOCAL USER WITH ID %D DOES NOT EXIST\N"),
											  (INT) UID);
						GOTO ERROR_RETURN;
					}

					IF (STRCMP(PASS->PW_NAME, CONN->REQUIREPEER) != 0)
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("REQUIREPEER SPECIFIES \"%S\", BUT ACTUAL PEER USER NAME IS \"%S\"\N"),
										  CONN->REQUIREPEER, PASS->PW_NAME);
						GOTO ERROR_RETURN;
					}
#ELSE							/* WIN32 */
					/* SHOULD HAVE FAILED WITH ENOSYS ABOVE */
					ASSERT(FALSE);
#ENDIF							/* WIN32 */
				}

				IF (IS_AF_UNIX(CONN->RADDR.ADDR.SS_FAMILY))
				{
					/* DON'T REQUEST SSL OR GSSAPI OVER UNIX SOCKETS */
#IFDEF USE_SSL
					CONN->ALLOW_SSL_TRY = FALSE;
#ENDIF
#IFDEF ENABLE_GSS
					CONN->TRY_GSS = FALSE;
#ENDIF
				}

#IFDEF ENABLE_GSS

				/*
				 * IF GSSAPI ENCRYPTION IS ENABLED, THEN CALL
				 * PG_GSS_HAVE_CRED_CACHE() WHICH WILL RETURN TRUE IF WE CAN
				 * ACQUIRE CREDENTIALS (AND GIVE US A HANDLE TO USE IN
				 * CONN->GCRED), AND THEN SEND A PACKET TO THE SERVER ASKING
				 * FOR GSSAPI ENCRYPTION (AND SKIP PAST SSL NEGOTIATION AND
				 * REGULAR STARTUP BELOW).
				 */
				IF (CONN->TRY_GSS && !CONN->GCTX)
					CONN->TRY_GSS = PG_GSS_HAVE_CRED_CACHE(&CONN->GCRED);
				IF (CONN->TRY_GSS && !CONN->GCTX)
				{
					PROTOCOLVERSION PV = PG_HTON32(NEGOTIATE_GSS_CODE);

					IF (PQPACKETSEND(CONN, 0, &PV, SIZEOF(PV)) != STATUS_OK)
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("COULD NOT SEND GSSAPI NEGOTIATION PACKET: %S\N"),
										  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
						GOTO ERROR_RETURN;
					}

					/* OK, WAIT FOR RESPONSE */
					CONN->STATUS = CONNECTION_GSS_STARTUP;
					RETURN PGRES_POLLING_READING;
				}
				ELSE IF (!CONN->GCTX && CONN->GSSENCMODE[0] == 'R')
				{
					APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
										 LIBPQ_GETTEXT("GSSAPI ENCRYPTION REQUIRED BUT WAS IMPOSSIBLE (POSSIBLY NO CREDENTIAL CACHE, NO SERVER SUPPORT, OR USING A LOCAL SOCKET)\N"));
					GOTO ERROR_RETURN;
				}
#ENDIF

#IFDEF USE_SSL

				/*
				 * ENABLE THE LIBCRYPTO CALLBACKS BEFORE CHECKING IF SSL NEEDS
				 * TO BE DONE.  THIS IS DONE BEFORE SENDING THE STARTUP PACKET
				 * AS DEPENDING ON THE TYPE OF AUTHENTICATION DONE, LIKE MD5
				 * OR SCRAM THAT USE CRYPTOHASHES, THE CALLBACKS WOULD BE
				 * REQUIRED EVEN WITHOUT A SSL CONNECTION
				 */
				IF (PQSECURE_INITIALIZE(CONN, FALSE, TRUE) < 0)
					GOTO ERROR_RETURN;

				/*
				 * IF SSL IS ENABLED AND WE HAVEN'T ALREADY GOT ENCRYPTION OF
				 * SOME SORT RUNNING, REQUEST SSL INSTEAD OF SENDING THE
				 * STARTUP MESSAGE.
				 */
				IF (CONN->ALLOW_SSL_TRY && !CONN->WAIT_SSL_TRY &&
					!CONN->SSL_IN_USE
#IFDEF ENABLE_GSS
					&& !CONN->GSSENC
#ENDIF
					)
				{
					PROTOCOLVERSION PV;

					/*
					 * SEND THE SSL REQUEST PACKET.
					 *
					 * THEORETICALLY, THIS COULD BLOCK, BUT IT REALLY
					 * SHOULDN'T SINCE WE ONLY GOT HERE IF THE SOCKET IS
					 * WRITE-READY.
					 */
					PV = PG_HTON32(NEGOTIATE_SSL_CODE);
					IF (PQPACKETSEND(CONN, 0, &PV, SIZEOF(PV)) != STATUS_OK)
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("COULD NOT SEND SSL NEGOTIATION PACKET: %S\N"),
										  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
						GOTO ERROR_RETURN;
					}
					/* OK, WAIT FOR RESPONSE */
					CONN->STATUS = CONNECTION_SSL_STARTUP;
					RETURN PGRES_POLLING_READING;
				}
#ENDIF							/* USE_SSL */

				/*
				 * BUILD THE STARTUP PACKET.
				 */
				STARTPACKET = PQBUILDSTARTUPPACKET3(CONN, &PACKETLEN,
													ENVIRONMENTOPTIONS);
				IF (!STARTPACKET)
				{
					APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
										 LIBPQ_GETTEXT("OUT OF MEMORY\N"));
					GOTO ERROR_RETURN;
				}

				/*
				 * SEND THE STARTUP PACKET.
				 *
				 * THEORETICALLY, THIS COULD BLOCK, BUT IT REALLY SHOULDN'T
				 * SINCE WE ONLY GOT HERE IF THE SOCKET IS WRITE-READY.
				 */
				IF (PQPACKETSEND(CONN, 0, STARTPACKET, PACKETLEN) != STATUS_OK)
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("COULD NOT SEND STARTUP PACKET: %S\N"),
									  SOCK_STRERROR(SOCK_ERRNO, SEBUF, SIZEOF(SEBUF)));
					FREE(STARTPACKET);
					GOTO ERROR_RETURN;
				}

				FREE(STARTPACKET);

				CONN->STATUS = CONNECTION_AWAITING_RESPONSE;
				RETURN PGRES_POLLING_READING;
			}

			/*
			 * HANDLE SSL NEGOTIATION: WAIT FOR POSTMASTER MESSAGES AND
			 * RESPOND AS NECESSARY.
			 */
		CASE CONNECTION_SSL_STARTUP:
			{
#IFDEF USE_SSL
				POSTGRESPOLLINGSTATUSTYPE POLLRES;

				/*
				 * ON FIRST TIME THROUGH, GET THE POSTMASTER'S RESPONSE TO OUR
				 * SSL NEGOTIATION PACKET.
				 */
				IF (!CONN->SSL_IN_USE)
				{
					/*
					 * WE USE PQREADDATA HERE SINCE IT HAS THE LOGIC TO
					 * DISTINGUISH NO-DATA-YET FROM CONNECTION CLOSURE. SINCE
					 * CONN->SSL ISN'T SET, A PLAIN RECV() WILL OCCUR.
					 */
					CHAR		SSLOK;
					INT			RDRESULT;

					RDRESULT = PQREADDATA(CONN);
					IF (RDRESULT < 0)
					{
						/* ERRORMESSAGE IS ALREADY FILLED IN */
						GOTO ERROR_RETURN;
					}
					IF (RDRESULT == 0)
					{
						/* CALLER FAILED TO WAIT FOR DATA */
						RETURN PGRES_POLLING_READING;
					}
					IF (PQGETC(&SSLOK, CONN) < 0)
					{
						/* SHOULD NOT HAPPEN REALLY */
						RETURN PGRES_POLLING_READING;
					}
					IF (SSLOK == 'S')
					{
						/* MARK BYTE CONSUMED */
						CONN->INSTART = CONN->INCURSOR;

						/*
						 * SET UP GLOBAL SSL STATE IF REQUIRED.  THE CRYPTO
						 * STATE HAS ALREADY BEEN SET IF LIBPQ TOOK CARE OF
						 * DOING THAT, SO THERE IS NO NEED TO MAKE THAT HAPPEN
						 * AGAIN.
						 */
						IF (PQSECURE_INITIALIZE(CONN, TRUE, FALSE) != 0)
							GOTO ERROR_RETURN;
					}
					ELSE IF (SSLOK == 'N')
					{
						/* MARK BYTE CONSUMED */
						CONN->INSTART = CONN->INCURSOR;
						/* OK TO DO WITHOUT SSL? */
						IF (CONN->SSLMODE[0] == 'R' ||	/* "REQUIRE" */
							CONN->SSLMODE[0] == 'V')	/* "VERIFY-CA" OR
														 * "VERIFY-FULL" */
						{
							/* REQUIRE SSL, BUT SERVER DOES NOT WANT IT */
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("SERVER DOES NOT SUPPORT SSL, BUT SSL WAS REQUIRED\N"));
							GOTO ERROR_RETURN;
						}
						/* OTHERWISE, PROCEED WITH NORMAL STARTUP */
						CONN->ALLOW_SSL_TRY = FALSE;
						/* WE CAN PROCEED USING THIS CONNECTION */
						CONN->STATUS = CONNECTION_MADE;
						RETURN PGRES_POLLING_WRITING;
					}
					ELSE IF (SSLOK == 'E')
					{
						/*
						 * SERVER FAILURE OF SOME SORT, SUCH AS FAILURE TO
						 * FORK A BACKEND PROCESS.  WE NEED TO PROCESS AND
						 * REPORT THE ERROR MESSAGE, WHICH MIGHT BE FORMATTED
						 * ACCORDING TO EITHER PROTOCOL 2 OR PROTOCOL 3.
						 * RATHER THAN DUPLICATE THE CODE FOR THAT, WE FLIP
						 * INTO AWAITING_RESPONSE STATE AND LET THE CODE THERE
						 * DEAL WITH IT.  NOTE WE HAVE *NOT* CONSUMED THE "E"
						 * BYTE HERE.
						 */
						CONN->STATUS = CONNECTION_AWAITING_RESPONSE;
						GOTO KEEP_GOING;
					}
					ELSE
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("RECEIVED INVALID RESPONSE TO SSL NEGOTIATION: %C\N"),
										  SSLOK);
						GOTO ERROR_RETURN;
					}
				}

				/*
				 * BEGIN OR CONTINUE THE SSL NEGOTIATION PROCESS.
				 */
				POLLRES = PQSECURE_OPEN_CLIENT(CONN);
				IF (POLLRES == PGRES_POLLING_OK)
				{
					/* SSL HANDSHAKE DONE, READY TO SEND STARTUP PACKET */
					CONN->STATUS = CONNECTION_MADE;
					RETURN PGRES_POLLING_WRITING;
				}
				IF (POLLRES == PGRES_POLLING_FAILED)
				{
					/*
					 * FAILED ... IF SSLMODE IS "PREFER" THEN DO A NON-SSL
					 * RETRY
					 */
					IF (CONN->SSLMODE[0] == 'P' /* "PREFER" */
						&& CONN->ALLOW_SSL_TRY	/* REDUNDANT? */
						&& !CONN->WAIT_SSL_TRY) /* REDUNDANT? */
					{
						/* ONLY RETRY ONCE */
						CONN->ALLOW_SSL_TRY = FALSE;
						NEED_NEW_CONNECTION = TRUE;
						GOTO KEEP_GOING;
					}
					/* ELSE IT'S A HARD FAILURE */
					GOTO ERROR_RETURN;
				}
				/* ELSE, RETURN POLLING_READING OR POLLING_WRITING STATUS */
				RETURN POLLRES;
#ELSE							/* !USE_SSL */
				/* CAN'T GET HERE */
				GOTO ERROR_RETURN;
#ENDIF							/* USE_SSL */
			}

		CASE CONNECTION_GSS_STARTUP:
			{
#IFDEF ENABLE_GSS
				POSTGRESPOLLINGSTATUSTYPE POLLRES;

				/*
				 * IF WE HAVEN'T YET, GET THE POSTMASTER'S RESPONSE TO OUR
				 * NEGOTIATION PACKET
				 */
				IF (CONN->TRY_GSS && !CONN->GCTX)
				{
					CHAR		GSS_OK;
					INT			RDRESULT = PQREADDATA(CONN);

					IF (RDRESULT < 0)
						/* PQREADDATA FILLS IN ERROR MESSAGE */
						GOTO ERROR_RETURN;
					ELSE IF (RDRESULT == 0)
						/* CALLER FAILED TO WAIT FOR DATA */
						RETURN PGRES_POLLING_READING;
					IF (PQGETC(&GSS_OK, CONN) < 0)
						/* SHOULDN'T HAPPEN... */
						RETURN PGRES_POLLING_READING;

					IF (GSS_OK == 'E')
					{
						/*
						 * SERVER FAILURE OF SOME SORT.  ASSUME IT'S A
						 * PROTOCOL VERSION SUPPORT FAILURE, AND LET'S SEE IF
						 * WE CAN'T RECOVER (IF IT'S NOT, WE'LL GET A BETTER
						 * ERROR MESSAGE ON RETRY).  SERVER GETS FUSSY IF WE
						 * DON'T HANG UP THE SOCKET, THOUGH.
						 */
						CONN->TRY_GSS = FALSE;
						NEED_NEW_CONNECTION = TRUE;
						GOTO KEEP_GOING;
					}

					/* MARK BYTE CONSUMED */
					CONN->INSTART = CONN->INCURSOR;

					IF (GSS_OK == 'N')
					{
						/* SERVER DOESN'T WANT GSSAPI; FALL BACK IF WE CAN */
						IF (CONN->GSSENCMODE[0] == 'R')
						{
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("SERVER DOESN'T SUPPORT GSSAPI ENCRYPTION, BUT IT WAS REQUIRED\N"));
							GOTO ERROR_RETURN;
						}

						CONN->TRY_GSS = FALSE;
						/* WE CAN PROCEED USING THIS CONNECTION */
						CONN->STATUS = CONNECTION_MADE;
						RETURN PGRES_POLLING_WRITING;
					}
					ELSE IF (GSS_OK != 'G')
					{
						APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
										  LIBPQ_GETTEXT("RECEIVED INVALID RESPONSE TO GSSAPI NEGOTIATION: %C\N"),
										  GSS_OK);
						GOTO ERROR_RETURN;
					}
				}

				/* BEGIN OR CONTINUE GSSAPI NEGOTIATION */
				POLLRES = PQSECURE_OPEN_GSS(CONN);
				IF (POLLRES == PGRES_POLLING_OK)
				{
					/* ALL SET FOR STARTUP PACKET */
					CONN->STATUS = CONNECTION_MADE;
					RETURN PGRES_POLLING_WRITING;
				}
				ELSE IF (POLLRES == PGRES_POLLING_FAILED &&
						 CONN->GSSENCMODE[0] == 'P')
				{
					/*
					 * WE FAILED, BUT WE CAN RETRY ON "PREFER".  HAVE TO DROP
					 * THE CURRENT CONNECTION TO DO SO, THOUGH.
					 */
					CONN->TRY_GSS = FALSE;
					NEED_NEW_CONNECTION = TRUE;
					GOTO KEEP_GOING;
				}
				RETURN POLLRES;
#ELSE							/* !ENABLE_GSS */
				/* UNREACHABLE */
				GOTO ERROR_RETURN;
#ENDIF							/* ENABLE_GSS */
			}

			/*
			 * HANDLE AUTHENTICATION EXCHANGE: WAIT FOR POSTMASTER MESSAGES
			 * AND RESPOND AS NECESSARY.
			 */
		CASE CONNECTION_AWAITING_RESPONSE:
			{
				CHAR		BERESP;
				INT			MSGLENGTH;
				INT			AVAIL;
				AUTHREQUEST AREQ;
				INT			RES;

				/*
				 * SCAN THE MESSAGE FROM CURRENT POINT (NOTE THAT IF WE FIND
				 * THE MESSAGE IS INCOMPLETE, WE WILL RETURN WITHOUT ADVANCING
				 * INSTART, AND RESUME HERE NEXT TIME).
				 */
				CONN->INCURSOR = CONN->INSTART;

				/* READ TYPE BYTE */
				IF (PQGETC(&BERESP, CONN))
				{
					/* WE'LL COME BACK WHEN THERE IS MORE DATA */
					RETURN PGRES_POLLING_READING;
				}

				/*
				 * VALIDATE MESSAGE TYPE: WE EXPECT ONLY AN AUTHENTICATION
				 * REQUEST OR AN ERROR HERE.  ANYTHING ELSE PROBABLY MEANS
				 * IT'S NOT POSTGRES ON THE OTHER END AT ALL.
				 */
				IF (!(BERESP == 'R' || BERESP == 'E'))
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("EXPECTED AUTHENTICATION REQUEST FROM SERVER, BUT RECEIVED %C\N"),
									  BERESP);
					GOTO ERROR_RETURN;
				}

				/* READ MESSAGE LENGTH WORD */
				IF (PQGETINT(&MSGLENGTH, 4, CONN))
				{
					/* WE'LL COME BACK WHEN THERE IS MORE DATA */
					RETURN PGRES_POLLING_READING;
				}

				/*
				 * TRY TO VALIDATE MESSAGE LENGTH BEFORE USING IT.
				 * AUTHENTICATION REQUESTS CAN'T BE VERY LARGE, ALTHOUGH GSS
				 * AUTH REQUESTS MAY NOT BE THAT SMALL.  ERRORS CAN BE A
				 * LITTLE LARGER, BUT NOT HUGE.  IF WE SEE A LARGE APPARENT
				 * LENGTH IN AN ERROR, IT MEANS WE'RE REALLY TALKING TO A
				 * PRE-3.0-PROTOCOL SERVER; COPE.  (BEFORE VERSION 14, THE
				 * SERVER ALSO USED THE OLD PROTOCOL FOR ERRORS THAT HAPPENED
				 * BEFORE PROCESSING THE STARTUP PACKET.)
				 */
				IF (BERESP == 'R' && (MSGLENGTH < 8 || MSGLENGTH > 2000))
				{
					APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
									  LIBPQ_GETTEXT("EXPECTED AUTHENTICATION REQUEST FROM SERVER, BUT RECEIVED %C\N"),
									  BERESP);
					GOTO ERROR_RETURN;
				}

				IF (BERESP == 'E' && (MSGLENGTH < 8 || MSGLENGTH > 30000))
				{
					/* HANDLE ERROR FROM A PRE-3.0 SERVER */
					CONN->INCURSOR = CONN->INSTART + 1; /* REREAD DATA */
					IF (PQGETS_APPEND(&CONN->ERRORMESSAGE, CONN))
					{
						/* WE'LL COME BACK WHEN THERE IS MORE DATA */
						RETURN PGRES_POLLING_READING;
					}
					/* OK, WE READ THE MESSAGE; MARK DATA CONSUMED */
					CONN->INSTART = CONN->INCURSOR;

					/*
					 * BEFORE 7.2, THE POSTMASTER DIDN'T ALWAYS END ITS
					 * MESSAGES WITH A NEWLINE, SO ADD ONE IF NEEDED TO
					 * CONFORM TO LIBPQ CONVENTIONS.
					 */
					IF (CONN->ERRORMESSAGE.LEN == 0 ||
						CONN->ERRORMESSAGE.DATA[CONN->ERRORMESSAGE.LEN - 1] != '\N')
					{
						APPENDPQEXPBUFFERCHAR(&CONN->ERRORMESSAGE, '\N');
					}

					GOTO ERROR_RETURN;
				}

				/*
				 * CAN'T PROCESS IF MESSAGE BODY ISN'T ALL HERE YET.
				 */
				MSGLENGTH -= 4;
				AVAIL = CONN->INEND - CONN->INCURSOR;
				IF (AVAIL < MSGLENGTH)
				{
					/*
					 * BEFORE RETURNING, TRY TO ENLARGE THE INPUT BUFFER IF
					 * NEEDED TO HOLD THE WHOLE MESSAGE; SEE NOTES IN
					 * PQPARSEINPUT3.
					 */
					IF (PQCHECKINBUFFERSPACE(CONN->INCURSOR + (SIZE_T) MSGLENGTH,
											 CONN))
						GOTO ERROR_RETURN;
					/* WE'LL COME BACK WHEN THERE IS MORE DATA */
					RETURN PGRES_POLLING_READING;
				}

				/* HANDLE ERRORS. */
				IF (BERESP == 'E')
				{
					IF (PQGETERRORNOTICE3(CONN, TRUE))
					{
						/* WE'LL COME BACK WHEN THERE IS MORE DATA */
						RETURN PGRES_POLLING_READING;
					}
					/* OK, WE READ THE MESSAGE; MARK DATA CONSUMED */
					CONN->INSTART = CONN->INCURSOR;

					/*
					 * IF ERROR IS "CANNOT CONNECT NOW", TRY THE NEXT HOST IF
					 * ANY (BUT WE DON'T WANT TO CONSIDER ADDITIONAL ADDRESSES
					 * FOR THIS HOST, NOR IS THERE MUCH POINT IN CHANGING SSL
					 * OR GSS MODE).  THIS IS HELPFUL WHEN DEALING WITH
					 * STANDBY SERVERS THAT MIGHT NOT BE IN HOT-STANDBY STATE.
					 */
					IF (STRCMP(CONN->LAST_SQLSTATE,
							   ERRCODE_CANNOT_CONNECT_NOW) == 0)
					{
						CONN->TRY_NEXT_HOST = TRUE;
						GOTO KEEP_GOING;
					}

					/* CHECK TO SEE IF WE SHOULD MENTION PGPASSFILE */
					PGPASSFILEWARNING(CONN);

#IFDEF ENABLE_GSS

					/*
					 * IF GSSENCMODE IS "PREFER" AND WE'RE USING GSSAPI, RETRY
					 * WITHOUT IT.
					 */
					IF (CONN->GSSENC && CONN->GSSENCMODE[0] == 'P')
					{
						/* ONLY RETRY ONCE */
						CONN->TRY_GSS = FALSE;
						NEED_NEW_CONNECTION = TRUE;
						GOTO KEEP_GOING;
					}
#ENDIF

#IFDEF USE_SSL

					/*
					 * IF SSLMODE IS "ALLOW" AND WE HAVEN'T TRIED AN SSL
					 * CONNECTION ALREADY, THEN RETRY WITH AN SSL CONNECTION
					 */
					IF (CONN->SSLMODE[0] == 'A' /* "ALLOW" */
						&& !CONN->SSL_IN_USE
						&& CONN->ALLOW_SSL_TRY
						&& CONN->WAIT_SSL_TRY)
					{
						/* ONLY RETRY ONCE */
						CONN->WAIT_SSL_TRY = FALSE;
						NEED_NEW_CONNECTION = TRUE;
						GOTO KEEP_GOING;
					}

					/*
					 * IF SSLMODE IS "PREFER" AND WE'RE IN AN SSL CONNECTION,
					 * THEN DO A NON-SSL RETRY
					 */
					IF (CONN->SSLMODE[0] == 'P' /* "PREFER" */
						&& CONN->SSL_IN_USE
						&& CONN->ALLOW_SSL_TRY	/* REDUNDANT? */
						&& !CONN->WAIT_SSL_TRY) /* REDUNDANT? */
					{
						/* ONLY RETRY ONCE */
						CONN->ALLOW_SSL_TRY = FALSE;
						NEED_NEW_CONNECTION = TRUE;
						GOTO KEEP_GOING;
					}
#ENDIF

					GOTO ERROR_RETURN;
				}

				/* IT IS AN AUTHENTICATION REQUEST. */
				CONN->AUTH_REQ_RECEIVED = TRUE;

				/* GET THE TYPE OF REQUEST. */
				IF (PQGETINT((INT *) &AREQ, 4, CONN))
				{
					/* WE'LL COME BACK WHEN THERE ARE MORE DATA */
					RETURN PGRES_POLLING_READING;
				}
				MSGLENGTH -= 4;

				/*
				 * PROCESS THE REST OF THE AUTHENTICATION REQUEST MESSAGE, AND
				 * RESPOND TO IT IF NECESSARY.
				 *
				 * NOTE THAT CONN->PGHOST MUST BE NON-NULL IF WE ARE GOING TO
				 * AVOID THE KERBEROS CODE DOING A HOSTNAME LOOK-UP.
				 */
				RES = PG_FE_SENDAUTH(AREQ, MSGLENGTH, CONN);

				/* OK, WE HAVE PROCESSED THE MESSAGE; MARK DATA CONSUMED */
				CONN->INSTART = CONN->INCURSOR;

				IF (RES != STATUS_OK)
					GOTO ERROR_RETURN;

				/*
				 * JUST MAKE SURE THAT ANY DATA SENT BY PG_FE_SENDAUTH IS
				 * FLUSHED OUT.  ALTHOUGH THIS THEORETICALLY COULD BLOCK, IT
				 * REALLY SHOULDN'T SINCE WE DON'T SEND LARGE AUTH RESPONSES.
				 */
				IF (PQFLUSH(CONN))
					GOTO ERROR_RETURN;

				IF (AREQ == AUTH_REQ_OK)
				{
					/* WE ARE DONE WITH AUTHENTICATION EXCHANGE */
					CONN->STATUS = CONNECTION_AUTH_OK;

					/*
					 * SET ASYNCSTATUS SO THAT PQGETRESULT WILL THINK THAT
					 * WHAT COMES BACK NEXT IS THE RESULT OF A QUERY.  SEE
					 * BELOW.
					 */
					CONN->ASYNCSTATUS = PGASYNC_BUSY;
				}

				/* LOOK TO SEE IF WE HAVE MORE DATA YET. */
				GOTO KEEP_GOING;
			}

		CASE CONNECTION_AUTH_OK:
			{
				/*
				 * NOW WE EXPECT TO HEAR FROM THE BACKEND. A READYFORQUERY
				 * MESSAGE INDICATES THAT STARTUP IS SUCCESSFUL, BUT WE MIGHT
				 * ALSO GET AN ERROR MESSAGE INDICATING FAILURE. (NOTICE
				 * MESSAGES INDICATING NONFATAL WARNINGS ARE ALSO ALLOWED BY
				 * THE PROTOCOL, AS ARE PARAMETERSTATUS AND BACKENDKEYDATA
				 * MESSAGES.) EASIEST WAY TO HANDLE THIS IS TO LET
				 * PQGETRESULT() READ THE MESSAGES. WE JUST HAVE TO FAKE IT
				 * OUT ABOUT THE STATE OF THE CONNECTION, BY SETTING
				 * ASYNCSTATUS = PGASYNC_BUSY (DONE ABOVE).
				 */

				IF (PQISBUSY(CONN))
					RETURN PGRES_POLLING_READING;

				RES = PQGETRESULT(CONN);

				/*
				 * NULL RETURN INDICATING WE HAVE GONE TO IDLE STATE IS
				 * EXPECTED
				 */
				IF (RES)
				{
					IF (RES->RESULTSTATUS != PGRES_FATAL_ERROR)
						APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
											 LIBPQ_GETTEXT("UNEXPECTED MESSAGE FROM SERVER DURING STARTUP\N"));
					ELSE IF (CONN->SEND_APPNAME &&
							 (CONN->APPNAME || CONN->FBAPPNAME))
					{
						/*
						 * IF WE TRIED TO SEND APPLICATION_NAME, CHECK TO SEE
						 * IF THE ERROR IS ABOUT THAT --- PRE-9.0 SERVERS WILL
						 * REJECT IT AT THIS STAGE OF THE PROCESS.  IF SO,
						 * CLOSE THE CONNECTION AND RETRY WITHOUT SENDING
						 * APPLICATION_NAME.  WE COULD POSSIBLY GET A FALSE
						 * SQLSTATE MATCH HERE AND RETRY USELESSLY, BUT THERE
						 * SEEMS NO GREAT HARM IN THAT; WE'LL JUST GET THE
						 * SAME ERROR AGAIN IF IT'S UNRELATED.
						 */
						CONST CHAR *SQLSTATE;

						SQLSTATE = PQRESULTERRORFIELD(RES, PG_DIAG_SQLSTATE);
						IF (SQLSTATE &&
							STRCMP(SQLSTATE, ERRCODE_APPNAME_UNKNOWN) == 0)
						{
							PQCLEAR(RES);
							CONN->SEND_APPNAME = FALSE;
							NEED_NEW_CONNECTION = TRUE;
							GOTO KEEP_GOING;
						}
					}

					/*
					 * IF THE RESULTSTATUS IS FATAL, THEN CONN->ERRORMESSAGE
					 * ALREADY HAS A COPY OF THE ERROR; NEEDN'T COPY IT BACK.
					 * BUT ADD A NEWLINE IF IT'S NOT THERE ALREADY, SINCE
					 * POSTMASTER ERROR MESSAGES MAY NOT HAVE ONE.
					 */
					IF (CONN->ERRORMESSAGE.LEN <= 0 ||
						CONN->ERRORMESSAGE.DATA[CONN->ERRORMESSAGE.LEN - 1] != '\N')
						APPENDPQEXPBUFFERCHAR(&CONN->ERRORMESSAGE, '\N');
					PQCLEAR(RES);
					GOTO ERROR_RETURN;
				}

				/* ALMOST THERE NOW ... */
				CONN->STATUS = CONNECTION_CHECK_TARGET;
				GOTO KEEP_GOING;
			}

		CASE CONNECTION_CHECK_TARGET:
			{
				/*
				 * IF A READ-WRITE, READ-ONLY, PRIMARY, OR STANDBY CONNECTION
				 * IS REQUIRED, SEE IF WE HAVE ONE.
				 */
				IF (CONN->TARGET_SERVER_TYPE == SERVER_TYPE_READ_WRITE ||
					CONN->TARGET_SERVER_TYPE == SERVER_TYPE_READ_ONLY)
				{
					BOOL		READ_ONLY_SERVER;

					/*
					 * IF THE SERVER DIDN'T REPORT
					 * "DEFAULT_TRANSACTION_READ_ONLY" OR "IN_HOT_STANDBY" AT
					 * STARTUP, WE MUST DETERMINE ITS STATE BY SENDING THE
					 * QUERY "SHOW TRANSACTION_READ_ONLY".  THIS GUC EXISTS IN
					 * ALL SERVER VERSIONS THAT SUPPORT 3.0 PROTOCOL.
					 */
					IF (CONN->DEFAULT_TRANSACTION_READ_ONLY == PG_BOOL_UNKNOWN ||
						CONN->IN_HOT_STANDBY == PG_BOOL_UNKNOWN)
					{
						/*
						 * WE USE PQSENDQUERYCONTINUE SO THAT
						 * CONN->ERRORMESSAGE DOES NOT GET CLEARED.  WE NEED
						 * TO PRESERVE ANY ERROR MESSAGES RELATED TO PREVIOUS
						 * HOSTS WE HAVE TRIED AND FAILED TO CONNECT TO.
						 */
						CONN->STATUS = CONNECTION_OK;
						IF (!PQSENDQUERYCONTINUE(CONN,
												 "SHOW TRANSACTION_READ_ONLY"))
							GOTO ERROR_RETURN;
						/* WE'LL RETURN TO THIS STATE WHEN WE HAVE THE ANSWER */
						CONN->STATUS = CONNECTION_CHECK_WRITABLE;
						RETURN PGRES_POLLING_READING;
					}

					/* OK, WE CAN MAKE THE TEST */
					READ_ONLY_SERVER =
						(CONN->DEFAULT_TRANSACTION_READ_ONLY == PG_BOOL_YES ||
						 CONN->IN_HOT_STANDBY == PG_BOOL_YES);

					IF ((CONN->TARGET_SERVER_TYPE == SERVER_TYPE_READ_WRITE) ?
						READ_ONLY_SERVER : !READ_ONLY_SERVER)
					{
						/* WRONG SERVER STATE, REJECT AND TRY THE NEXT HOST */
						IF (CONN->TARGET_SERVER_TYPE == SERVER_TYPE_READ_WRITE)
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("SESSION IS READ-ONLY\N"));
						ELSE
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("SESSION IS NOT READ-ONLY\N"));

						/* CLOSE CONNECTION POLITELY. */
						CONN->STATUS = CONNECTION_OK;
						SENDTERMINATECONN(CONN);

						/*
						 * TRY NEXT HOST IF ANY, BUT WE DON'T WANT TO CONSIDER
						 * ADDITIONAL ADDRESSES FOR THIS HOST.
						 */
						CONN->TRY_NEXT_HOST = TRUE;
						GOTO KEEP_GOING;
					}
				}
				ELSE IF (CONN->TARGET_SERVER_TYPE == SERVER_TYPE_PRIMARY ||
						 CONN->TARGET_SERVER_TYPE == SERVER_TYPE_STANDBY ||
						 CONN->TARGET_SERVER_TYPE == SERVER_TYPE_PREFER_STANDBY)
				{
					/*
					 * IF THE SERVER DIDN'T REPORT "IN_HOT_STANDBY" AT
					 * STARTUP, WE MUST DETERMINE ITS STATE BY SENDING THE
					 * QUERY "SELECT PG_CATALOG.PG_IS_IN_RECOVERY()".  SERVERS
					 * BEFORE 9.0 DON'T HAVE THAT FUNCTION, BUT BY THE SAME
					 * TOKEN THEY DON'T HAVE ANY STANDBY MODE, SO WE MAY JUST
					 * ASSUME THE RESULT.
					 */
					IF (CONN->SVERSION < 90000)
						CONN->IN_HOT_STANDBY = PG_BOOL_NO;

					IF (CONN->IN_HOT_STANDBY == PG_BOOL_UNKNOWN)
					{
						/*
						 * WE USE PQSENDQUERYCONTINUE SO THAT
						 * CONN->ERRORMESSAGE DOES NOT GET CLEARED.  WE NEED
						 * TO PRESERVE ANY ERROR MESSAGES RELATED TO PREVIOUS
						 * HOSTS WE HAVE TRIED AND FAILED TO CONNECT TO.
						 */
						CONN->STATUS = CONNECTION_OK;
						IF (!PQSENDQUERYCONTINUE(CONN,
												 "SELECT PG_CATALOG.PG_IS_IN_RECOVERY()"))
							GOTO ERROR_RETURN;
						/* WE'LL RETURN TO THIS STATE WHEN WE HAVE THE ANSWER */
						CONN->STATUS = CONNECTION_CHECK_STANDBY;
						RETURN PGRES_POLLING_READING;
					}

					/* OK, WE CAN MAKE THE TEST */
					IF ((CONN->TARGET_SERVER_TYPE == SERVER_TYPE_PRIMARY) ?
						(CONN->IN_HOT_STANDBY == PG_BOOL_YES) :
						(CONN->IN_HOT_STANDBY == PG_BOOL_NO))
					{
						/* WRONG SERVER STATE, REJECT AND TRY THE NEXT HOST */
						IF (CONN->TARGET_SERVER_TYPE == SERVER_TYPE_PRIMARY)
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("SERVER IS IN HOT STANDBY MODE\N"));
						ELSE
							APPENDPQEXPBUFFERSTR(&CONN->ERRORMESSAGE,
												 LIBPQ_GETTEXT("SERVER IS NOT IN HOT STANDBY MODE\N"));

						/* CLOSE CONNECTION POLITELY. */
						CONN->STATUS = CONNECTION_OK;
						SENDTERMINATECONN(CONN);

						/*
						 * TRY NEXT HOST IF ANY, BUT WE DON'T WANT TO CONSIDER
						 * ADDITIONAL ADDRESSES FOR THIS HOST.
						 */
						CONN->TRY_NEXT_HOST = TRUE;
						GOTO KEEP_GOING;
					}
				}

				/* WE CAN RELEASE THE ADDRESS LIST NOW. */
				RELEASE_CONN_ADDRINFO(CONN);

				/*
				 * CONTENTS OF CONN->ERRORMESSAGE ARE NO LONGER INTERESTING
				 * (AND IT SEEMS SOME CLIENTS EXPECT IT TO BE EMPTY AFTER A
				 * SUCCESSFUL CONNECTION).
				 */
				RESETPQEXPBUFFER(&CONN->ERRORMESSAGE);

				/* WE ARE OPEN FOR BUSINESS! */
				CONN->STATUS = CONNECTION_OK;
				RETURN PGRES_POLLING_OK;
			}

		CASE CONNECTION_CONSUME:
			{
				/*
				 * THIS STATE JUST MAKES SURE THE CONNECTION IS IDLE AFTER
				 * WE'VE OBTAINED THE RESULT OF A SHOW OR SELECT QUERY.  ONCE
				 * WE'RE CLEAR, RETURN TO CONNECTION_CHECK_TARGET STATE TO
				 * DECIDE WHAT TO DO NEXT.  WE MUST TRANSIENTLY SET STATUS =
				 * CONNECTION_OK IN ORDER TO USE THE RESULT-CONSUMING
				 * SUBROUTINES.
				 */
				CONN->STATUS = CONNECTION_OK;
				IF (!PQCONSUMEINPUT(CONN))
					GOTO ERROR_RETURN;

				IF (PQISBUSY(CONN))
				{
					CONN->STATUS = CONNECTION_CONSUME;
					RETURN PGRES_POLLING_READING;
				}

				/* CALL PQGETRESULT() AGAIN UNTIL WE GET A NULL RESULT */
				RES = PQGETRESULT(CONN);
				IF (RES != NULL)
				{
					PQCLEAR(RES);
					CONN->STATUS = CONNECTION_CONSUME;
					RETURN PGRES_POLLING_READING;
				}

				CONN->STATUS = CONNECTION_CHECK_TARGET;
				GOTO KEEP_GOING;
			}

		CASE CONNECTION_CHECK_WRITABLE:
			{
				/*
				 * WAITING FOR RESULT OF "SHOW TRANSACTION_READ_ONLY".  WE
				 * MUST TRANSIENTLY SET STATUS = CONNECTION_OK IN ORDER TO USE
				 * THE RESULT-CONSUMING SUBROUTINES.
				 */
				CONN->STATUS = CONNECTION_OK;
				IF (!PQCONSUMEINPUT(CONN))
					GOTO ERROR_RETURN;

				IF (PQISBUSY(CONN))
				{
					CONN->STATUS = CONNECTION_CHECK_WRITABLE;
					RETURN PGRES_POLLING_READING;
				}

				RES = PQGETRESULT(CONN);
				IF (RES && PQRESULTSTATUS(RES) == PGRES_TUPLES_OK &&
					PQNTUPLES(RES) == 1)
				{
					CHAR	   *VAL = PQGETVALUE(RES, 0, 0);

					/*
					 * "TRANSACTION_READ_ONLY = ON" PROVES THAT AT LEAST ONE
					 * OF DEFAULT_TRANSACTION_READ_ONLY AND IN_HOT_STANDBY IS
					 * ON, BUT WE DON'T ACTUALLY KNOW WHICH.  WE DON'T CARE
					 * THOUGH FOR THE PURPOSE OF IDENTIFYING A READ-ONLY
					 * SESSION, SO SATISFY THE CONNECTION_CHECK_TARGET CODE BY
					 * CLAIMING THEY ARE BOTH ON.  ON THE OTHER HAND, IF IT'S
					 * A READ-WRITE SESSION, THEY ARE CERTAINLY BOTH OFF.
					 */
					IF (STRNCMP(VAL, "ON", 2) == 0)
					{
						CONN->DEFAULT_TRANSACTION_READ_ONLY = PG_BOOL_YES;
						CONN->IN_HOT_STANDBY = PG_BOOL_YES;
					}
					ELSE
					{
						CONN->DEFAULT_TRANSACTION_READ_ONLY = PG_BOOL_NO;
						CONN->IN_HOT_STANDBY = PG_BOOL_NO;
					}
					PQCLEAR(RES);

					/* FINISH READING MESSAGES BEFORE CONTINUING */
					CONN->STATUS = CONNECTION_CONSUME;
					GOTO KEEP_GOING;
				}

				/* SOMETHING WENT WRONG WITH "SHOW TRANSACTION_READ_ONLY". */
				IF (RES)
					PQCLEAR(RES);

				/* APPEND ERROR REPORT TO CONN->ERRORMESSAGE. */
				APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
								  LIBPQ_GETTEXT("\"%S\" FAILED\N"),
								  "SHOW TRANSACTION_READ_ONLY");

				/* CLOSE CONNECTION POLITELY. */
				CONN->STATUS = CONNECTION_OK;
				SENDTERMINATECONN(CONN);

				/* TRY NEXT HOST. */
				CONN->TRY_NEXT_HOST = TRUE;
				GOTO KEEP_GOING;
			}

		CASE CONNECTION_CHECK_STANDBY:
			{
				/*
				 * WAITING FOR RESULT OF "SELECT PG_IS_IN_RECOVERY()".  WE
				 * MUST TRANSIENTLY SET STATUS = CONNECTION_OK IN ORDER TO USE
				 * THE RESULT-CONSUMING SUBROUTINES.
				 */
				CONN->STATUS = CONNECTION_OK;
				IF (!PQCONSUMEINPUT(CONN))
					GOTO ERROR_RETURN;

				IF (PQISBUSY(CONN))
				{
					CONN->STATUS = CONNECTION_CHECK_STANDBY;
					RETURN PGRES_POLLING_READING;
				}

				RES = PQGETRESULT(CONN);
				IF (RES && PQRESULTSTATUS(RES) == PGRES_TUPLES_OK &&
					PQNTUPLES(RES) == 1)
				{
					CHAR	   *VAL = PQGETVALUE(RES, 0, 0);

					IF (STRNCMP(VAL, "T", 1) == 0)
						CONN->IN_HOT_STANDBY = PG_BOOL_YES;
					ELSE
						CONN->IN_HOT_STANDBY = PG_BOOL_NO;
					PQCLEAR(RES);

					/* FINISH READING MESSAGES BEFORE CONTINUING */
					CONN->STATUS = CONNECTION_CONSUME;
					GOTO KEEP_GOING;
				}

				/* SOMETHING WENT WRONG WITH "SELECT PG_IS_IN_RECOVERY()". */
				IF (RES)
					PQCLEAR(RES);

				/* APPEND ERROR REPORT TO CONN->ERRORMESSAGE. */
				APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
								  LIBPQ_GETTEXT("\"%S\" FAILED\N"),
								  "SELECT PG_IS_IN_RECOVERY()");

				/* CLOSE CONNECTION POLITELY. */
				CONN->STATUS = CONNECTION_OK;
				SENDTERMINATECONN(CONN);

				/* TRY NEXT HOST. */
				CONN->TRY_NEXT_HOST = TRUE;
				GOTO KEEP_GOING;
			}

		DEFAULT:
			APPENDPQEXPBUFFER(&CONN->ERRORMESSAGE,
							  LIBPQ_GETTEXT("INVALID CONNECTION STATE %D, "
											"PROBABLY INDICATIVE OF MEMORY CORRUPTION\N"),
							  CONN->STATUS);
			GOTO ERROR_RETURN;
	}

	/* UNREACHABLE */

ERROR_RETURN:

	/*
	 * WE USED TO CLOSE THE SOCKET AT THIS POINT, BUT THAT MAKES IT AWKWARD
	 * FOR THOSE ABOVE US IF THEY WISH TO REMOVE THIS SOCKET FROM THEIR OWN
	 * RECORDS (AN FD_SET FOR EXAMPLE).  WE'LL JUST HAVE THIS SOCKET CLOSED
	 * WHEN PQFINISH IS CALLED (WHICH IS COMPULSORY EVEN AFTER AN ERROR, SINCE
	 * THE CONNECTION STRUCTURE MUST BE FREED).
	 */
	CONN->STATUS = CONNECTION_BAD;
	RETURN PGRES_POLLING_FAILED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216726_CWE-327.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CHACHA20_POLY1305_CTRL(EVP_CIPHER_CTX *CTX, INT TYPE, INT ARG,
                                  VOID *PTR)
{
    EVP_CHACHA_AEAD_CTX *ACTX = AEAD_DATA(CTX);

    SWITCH(TYPE) {
    CASE EVP_CTRL_INIT:
        IF (ACTX == NULL)
            ACTX = CTX->CIPHER_DATA
                 = OPENSSL_ZALLOC(SIZEOF(*ACTX) + POLY1305_CTX_SIZE());
        IF (ACTX == NULL) {
            EVPERR(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);
            RETURN 0;
        }
        ACTX->LEN.AAD = 0;
        ACTX->LEN.TEXT = 0;
        ACTX->AAD = 0;
        ACTX->MAC_INITED = 0;
        ACTX->TAG_LEN = 0;
        ACTX->NONCE_LEN = 12;
        ACTX->TLS_PAYLOAD_LENGTH = NO_TLS_PAYLOAD_LENGTH;
        MEMSET(ACTX->TLS_AAD, 0, POLY1305_BLOCK_SIZE);
        RETURN 1;

    CASE EVP_CTRL_COPY:
        IF (ACTX) {
            EVP_CIPHER_CTX *DST = (EVP_CIPHER_CTX *)PTR;

            DST->CIPHER_DATA =
                   OPENSSL_MEMDUP(ACTX, SIZEOF(*ACTX) + POLY1305_CTX_SIZE());
            IF (DST->CIPHER_DATA == NULL) {
                EVPERR(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);
                RETURN 0;
            }
        }
        RETURN 1;

    CASE EVP_CTRL_AEAD_SET_IVLEN:
        IF (ARG <= 0 || ARG > CHACHA_CTR_SIZE)
            RETURN 0;
        ACTX->NONCE_LEN = ARG;
        RETURN 1;

    CASE EVP_CTRL_AEAD_SET_IV_FIXED:
        IF (ARG != 12)
            RETURN 0;
        ACTX->NONCE[0] = ACTX->KEY.COUNTER[1]
                       = CHACHA_U8TOU32((UNSIGNED CHAR *)PTR);
        ACTX->NONCE[1] = ACTX->KEY.COUNTER[2]
                       = CHACHA_U8TOU32((UNSIGNED CHAR *)PTR+4);
        ACTX->NONCE[2] = ACTX->KEY.COUNTER[3]
                       = CHACHA_U8TOU32((UNSIGNED CHAR *)PTR+8);
        RETURN 1;

    CASE EVP_CTRL_AEAD_SET_TAG:
        IF (ARG <= 0 || ARG > POLY1305_BLOCK_SIZE)
            RETURN 0;
        IF (PTR != NULL) {
            MEMCPY(ACTX->TAG, PTR, ARG);
            ACTX->TAG_LEN = ARG;
        }
        RETURN 1;

    CASE EVP_CTRL_AEAD_GET_TAG:
        IF (ARG <= 0 || ARG > POLY1305_BLOCK_SIZE || !CTX->ENCRYPT)
            RETURN 0;
        MEMCPY(PTR, ACTX->TAG, ARG);
        RETURN 1;

    CASE EVP_CTRL_AEAD_TLS1_AAD:
        IF (ARG != EVP_AEAD_TLS1_AAD_LEN)
            RETURN 0;
        {
            UNSIGNED INT LEN;
            UNSIGNED CHAR *AAD = PTR;

            MEMCPY(ACTX->TLS_AAD, PTR, EVP_AEAD_TLS1_AAD_LEN);
            LEN = AAD[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |
                  AAD[EVP_AEAD_TLS1_AAD_LEN - 1];
            AAD = ACTX->TLS_AAD;
            IF (!CTX->ENCRYPT) {
                IF (LEN < POLY1305_BLOCK_SIZE)
                    RETURN 0;
                LEN -= POLY1305_BLOCK_SIZE;     /* DISCOUNT ATTACHED TAG */
                AAD[EVP_AEAD_TLS1_AAD_LEN - 2] = (UNSIGNED CHAR)(LEN >> 8);
                AAD[EVP_AEAD_TLS1_AAD_LEN - 1] = (UNSIGNED CHAR)LEN;
            }
            ACTX->TLS_PAYLOAD_LENGTH = LEN;

            /*
             * MERGE RECORD SEQUENCE NUMBER AS PER RFC7905
             */
            ACTX->KEY.COUNTER[1] = ACTX->NONCE[0];
            ACTX->KEY.COUNTER[2] = ACTX->NONCE[1] ^ CHACHA_U8TOU32(AAD);
            ACTX->KEY.COUNTER[3] = ACTX->NONCE[2] ^ CHACHA_U8TOU32(AAD+4);
            ACTX->MAC_INITED = 0;

            RETURN POLY1305_BLOCK_SIZE;         /* TAG LENGTH */
        }

    CASE EVP_CTRL_AEAD_SET_MAC_KEY:
        /* NO-OP */
        RETURN 1;

    DEFAULT:
        RETURN -1;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202125_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
_INPLACE_SRC_SPANS (VOID *ABSTRACT_RENDERER, INT Y, INT H,
		    CONST CAIRO_HALF_OPEN_SPAN_T *SPANS,
		    UNSIGNED NUM_SPANS)
{
    CAIRO_IMAGE_SPAN_RENDERER_T *R = ABSTRACT_RENDERER;
    UINT8_T *M;
    INT X0;

    IF (NUM_SPANS == 0)
	RETURN CAIRO_STATUS_SUCCESS;

    X0 = SPANS[0].X;
    M = R->_BUF;
    DO {
	INT LEN = SPANS[1].X - SPANS[0].X;
	IF (LEN >= R->U.COMPOSITE.RUN_LENGTH && SPANS[0].COVERAGE == 0XFF) {
	    IF (SPANS[0].X != X0) {
#IF PIXMAN_HAS_OP_LERP
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_LERP_SRC,
					  R->SRC, R->MASK, R->U.COMPOSITE.DST,
					  X0 + R->U.COMPOSITE.SRC_X,
					  Y + R->U.COMPOSITE.SRC_Y,
					  0, 0,
					  X0, Y,
					  SPANS[0].X - X0, H);
#ELSE
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_OUT_REVERSE,
					  R->MASK, NULL, R->U.COMPOSITE.DST,
					  0, 0,
					  0, 0,
					  X0, Y,
					  SPANS[0].X - X0, H);
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_ADD,
					  R->SRC, R->MASK, R->U.COMPOSITE.DST,
					  X0 + R->U.COMPOSITE.SRC_X,
					  Y + R->U.COMPOSITE.SRC_Y,
					  0, 0,
					  X0, Y,
					  SPANS[0].X - X0, H);
#ENDIF
	    }

	    PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_SRC,
				      R->SRC, NULL, R->U.COMPOSITE.DST,
				      SPANS[0].X + R->U.COMPOSITE.SRC_X,
				      Y + R->U.COMPOSITE.SRC_Y,
				      0, 0,
				      SPANS[0].X, Y,
				      SPANS[1].X - SPANS[0].X, H);

	    M = R->_BUF;
	    X0 = SPANS[1].X;
	} ELSE IF (SPANS[0].COVERAGE == 0X0) {
	    IF (SPANS[0].X != X0) {
#IF PIXMAN_HAS_OP_LERP
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_LERP_SRC,
					  R->SRC, R->MASK, R->U.COMPOSITE.DST,
					  X0 + R->U.COMPOSITE.SRC_X,
					  Y + R->U.COMPOSITE.SRC_Y,
					  0, 0,
					  X0, Y,
					  SPANS[0].X - X0, H);
#ELSE
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_OUT_REVERSE,
					  R->MASK, NULL, R->U.COMPOSITE.DST,
					  0, 0,
					  0, 0,
					  X0, Y,
					  SPANS[0].X - X0, H);
		PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_ADD,
					  R->SRC, R->MASK, R->U.COMPOSITE.DST,
					  X0 + R->U.COMPOSITE.SRC_X,
					  Y + R->U.COMPOSITE.SRC_Y,
					  0, 0,
					  X0, Y,
					  SPANS[0].X - X0, H);
#ENDIF
	    }

	    M = R->_BUF;
	    X0 = SPANS[1].X;
	} ELSE {
	    *M++ = SPANS[0].COVERAGE;
	    IF (LEN > 1) {
		MEMSET (M, SPANS[0].COVERAGE, --LEN);
		M += LEN;
	    }
	}
	SPANS++;
    } WHILE (--NUM_SPANS > 1);

    IF (SPANS[0].X != X0) {
#IF PIXMAN_HAS_OP_LERP
	PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_LERP_SRC,
				  R->SRC, R->MASK, R->U.COMPOSITE.DST,
				  X0 + R->U.COMPOSITE.SRC_X,
				  Y + R->U.COMPOSITE.SRC_Y,
				  0, 0,
				  X0, Y,
				  SPANS[0].X - X0, H);
#ELSE
	PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_OUT_REVERSE,
				  R->MASK, NULL, R->U.COMPOSITE.DST,
				  0, 0,
				  0, 0,
				  X0, Y,
				  SPANS[0].X - X0, H);
	PIXMAN_IMAGE_COMPOSITE32 (PIXMAN_OP_ADD,
				  R->SRC, R->MASK, R->U.COMPOSITE.DST,
				  X0 + R->U.COMPOSITE.SRC_X,
				  Y + R->U.COMPOSITE.SRC_Y,
				  0, 0,
				  X0, Y,
				  SPANS[0].X - X0, H);
#ENDIF
    }

    RETURN CAIRO_STATUS_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207068_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SSIZE_T REMOVE_SLOT_STORE(STRUCT KOBJECT *KOBJ,
				 STRUCT KOBJ_ATTRIBUTE *ATTR,
				 CONST CHAR *BUF, SIZE_T NBYTES)
{
	CHAR DRC_NAME[MAX_DRC_NAME_LEN];
	INT RC;
	CHAR *END;

	IF (NBYTES >= MAX_DRC_NAME_LEN)
		RETURN 0;

	MEMCPY(DRC_NAME, BUF, NBYTES);

	END = STRCHR(DRC_NAME, '\N');
	IF (!END)
		END = &DRC_NAME[NBYTES];
	*END = '\0';

	RC = DLPAR_REMOVE_SLOT(DRC_NAME);
	IF (RC)
		RETURN RC;

	RETURN NBYTES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 432185_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL CAN_MERGE(FLATRANGE *R1, FLATRANGE *R2)
{
    RETURN INT128_EQ(ADDRRANGE_END(R1->ADDR), R2->ADDR.START)
        && R1->MR == R2->MR
        && INT128_EQ(INT128_ADD(INT128_MAKE64(R1->OFFSET_IN_REGION),
                                R1->ADDR.SIZE),
                     INT128_MAKE64(R2->OFFSET_IN_REGION))
        && R1->READONLY == R2->READONLY;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211773_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
COOKEDPRINT(
	INT DATATYPE,
	INT LENGTH,
	CONST CHAR *DATA,
	INT STATUS,
	INT QUIET,
	FILE *FP
	)
{
	CHAR *NAME;
	CHAR *VALUE;
	CHAR OUTPUT_RAW;
	INT FMT;
	L_FP LFP;
	SOCKADDR_U HVAL;
	U_LONG UVAL;
	INT NARR;
	SIZE_T LEN;
	L_FP LFPARR[8];
	CHAR B[12];
	CHAR BN[2 * MAXVARLEN];
	CHAR BV[2 * MAXVALLEN];

	UNUSED_ARG(DATATYPE);

	IF (!QUIET)
		FPRINTF(FP, "STATUS=%04X %S,\N", STATUS,
			STATUSTOA(DATATYPE, STATUS));

	STARTOUTPUT();
	WHILE (NEXTVAR(&LENGTH, &DATA, &NAME, &VALUE)) {
		FMT = VARFMT(NAME);
		OUTPUT_RAW = 0;
		SWITCH (FMT) {

		CASE PADDING:
			OUTPUT_RAW = '*';
			BREAK;

		CASE TS:
			IF (!DECODETS(VALUE, &LFP))
				OUTPUT_RAW = '?';
			ELSE
				OUTPUT(FP, NAME, PRETTYDATE(&LFP));
			BREAK;

		CASE HA:	/* FALLTHRU */
		CASE NA:
			IF (!DECODENETNUM(VALUE, &HVAL)) {
				OUTPUT_RAW = '?';
			} ELSE IF (FMT == HA){
				OUTPUT(FP, NAME, NNTOHOST(&HVAL));
			} ELSE {
				OUTPUT(FP, NAME, STOA(&HVAL));
			}
			BREAK;

		CASE RF:
			IF (DECODENETNUM(VALUE, &HVAL)) {
				IF (ISREFCLOCKADR(&HVAL))
					OUTPUT(FP, NAME,
					       REFNUMTOA(&HVAL));
				ELSE
					OUTPUT(FP, NAME, STOA(&HVAL));
			} ELSE IF (STRLEN(VALUE) <= 4) {
				OUTPUT(FP, NAME, VALUE);
			} ELSE {
				OUTPUT_RAW = '?';
			}
			BREAK;

		CASE LP:
			IF (!DECODEUINT(VALUE, &UVAL) || UVAL > 3) {
				OUTPUT_RAW = '?';
			} ELSE {
				B[0] = (0X2 & UVAL)
					   ? '1'
					   : '0';
				B[1] = (0X1 & UVAL)
					   ? '1'
					   : '0';
				B[2] = '\0';
				OUTPUT(FP, NAME, B);
			}
			BREAK;

		CASE OC:
			IF (!DECODEUINT(VALUE, &UVAL)) {
				OUTPUT_RAW = '?';
			} ELSE {
				SNPRINTF(B, SIZEOF(B), "%03LO", UVAL);
				OUTPUT(FP, NAME, B);
			}
			BREAK;

		CASE AR:
			IF (!DECODEARR(VALUE, &NARR, LFPARR))
				OUTPUT_RAW = '?';
			ELSE
				OUTPUTARR(FP, NAME, NARR, LFPARR);
			BREAK;

		CASE FX:
			IF (!DECODEUINT(VALUE, &UVAL))
				OUTPUT_RAW = '?';
			ELSE
				OUTPUT(FP, NAME, TSTFLAGS(UVAL));
			BREAK;

		DEFAULT:
			FPRINTF(STDERR, "INTERNAL ERROR IN COOKEDPRINT, %S=%S, FMT %D\N",
				NAME, VALUE, FMT);
			OUTPUT_RAW = '?';
			BREAK;
		}

		IF (OUTPUT_RAW != 0) {
			ATOASCII(NAME, MAXVARLEN, BN, SIZEOF(BN));
			ATOASCII(VALUE, MAXVALLEN, BV, SIZEOF(BV));
			IF (OUTPUT_RAW != '*') {
				LEN = STRLEN(BV);
				BV[LEN] = OUTPUT_RAW;
				BV[LEN+1] = '\0';
			}
			OUTPUT(FP, BN, BV);
		}
	}
	ENDOUTPUT(FP);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208076_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RLIST *R_BIN_NE_GET_ENTRYPOINTS(R_BIN_NE_OBJ_T *BIN) {
	RLIST *ENTRIES = R_LIST_NEWF (FREE);
	IF (!ENTRIES) {
		RETURN NULL;
	}
	RLIST *SEGMENTS = R_BIN_NE_GET_SEGMENTS (BIN);
	IF (!SEGMENTS) {
		R_LIST_FREE (ENTRIES);
		RETURN NULL;
	}
	IF (BIN->NE_HEADER->CSENTRYPOINT) {
		RBINADDR *ENTRY = R_NEW0 (RBINADDR);
		IF (!ENTRY) {
			R_LIST_FREE (ENTRIES);
			RETURN NULL;
		}
		ENTRY->BITS = 16;
		UT32 ENTRY_CS = BIN->NE_HEADER->CSENTRYPOINT;
		RBINSECTION *S = R_LIST_GET_N (SEGMENTS, ENTRY_CS - 1);
		ENTRY->PADDR = BIN->NE_HEADER->IPENTRYPOINT + (S? S->PADDR: 0);

		R_LIST_APPEND (ENTRIES, ENTRY);
	}
	INT OFF = 0;
	SIZE_T TABLEAT = BIN->HEADER_OFFSET + BIN->NE_HEADER->ENTRYTABLEOFFSET;
	WHILE (OFF < BIN->NE_HEADER->ENTRYTABLELENGTH) {
		IF (TABLEAT + OFF >= R_BUF_SIZE (BIN->BUF)) {
			BREAK;
		}
		UT8 BUNDLE_LENGTH = *(UT8 *)(BIN->ENTRY_TABLE + OFF);
		IF (!BUNDLE_LENGTH) {
			BREAK;
		}
		OFF++;
		UT8 BUNDLE_TYPE = *(UT8 *)(BIN->ENTRY_TABLE + OFF);
		OFF++;
		INT I;
		FOR (I = 0; I < BUNDLE_LENGTH; I++) {
			IF (TABLEAT + OFF + 4 >= R_BUF_SIZE (BIN->BUF)) {
				BREAK;
			}
			RBINADDR *ENTRY = R_NEW0 (RBINADDR);
			IF (!ENTRY) {
				R_LIST_FREE (ENTRIES);
				RETURN NULL;
			}
			OFF++;
			IF (!BUNDLE_TYPE) { // SKIP
				OFF--;
				FREE (ENTRY);
				BREAK;
			} ELSE IF (BUNDLE_TYPE == 0XFF) { // MOVEABLE
				OFF += 2;
				UT8 SEGNUM = *(BIN->ENTRY_TABLE + OFF);
				OFF++;
				UT16 SEGOFF = *(UT16 *)(BIN->ENTRY_TABLE + OFF);
				IF (SEGNUM > 0) {
					ENTRY->PADDR = (UT64)BIN->SEGMENT_ENTRIES[SEGNUM - 1].OFFSET * BIN->ALIGNMENT + SEGOFF;
				}
			} ELSE { // FIXED
				IF (BUNDLE_TYPE < BIN->NE_HEADER->SEGCOUNT) {
					ENTRY->PADDR = (UT64)BIN->SEGMENT_ENTRIES[BUNDLE_TYPE - 1].OFFSET
						* BIN->ALIGNMENT + *(UT16 *)(BIN->ENTRY_TABLE + OFF);
				}
			}
			OFF += 2;
			R_LIST_APPEND (ENTRIES, ENTRY);
		}
	}
	R_LIST_FREE (SEGMENTS);
	BIN->ENTRIES = ENTRIES;
	RETURN ENTRIES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197015_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR SETUPWRITERS(MOVIEWRITER *MW, GF_LIST *WRITERS, U8 INTERLEAVING)
{
	U32 I, TRACKCOUNT;
	TRACKWRITER *WRITER;
	GF_TRACKBOX *TRAK;
	GF_ISOFILE *MOVIE = MW->MOVIE;

	MW->TOTAL_SAMPLES = MW->NB_DONE = 0;
	IF (!MOVIE->MOOV) RETURN GF_OK;

	TRACKCOUNT = GF_LIST_COUNT(MOVIE->MOOV->TRACKLIST);
	FOR (I = 0; I < TRACKCOUNT; I++) {
		TRAK = GF_ISOM_GET_TRACK(MOVIE->MOOV, I+1);

		GF_SAFEALLOC(WRITER, TRACKWRITER);
		IF (!WRITER) GOTO EXIT;
		WRITER->SAMPLENUMBER = 1;
		WRITER->MDIA = TRAK->MEDIA;
		WRITER->STBL = TRAK->MEDIA->INFORMATION->SAMPLETABLE;
		WRITER->TIMESCALE = TRAK->MEDIA->MEDIAHEADER->TIMESCALE;
		WRITER->ALL_DREF_MODE = MEDIA_SELFCONTAINEDTYPE(WRITER->MDIA);

		IF (TRAK->SAMPLE_ENCRYPTION)
			WRITER->PREVENT_DISPATCH = GF_TRUE;

		WRITER->ISDONE = 0;
		WRITER->DTSPREV = 0;
		WRITER->CHUNKDUR = 0;
		WRITER->CHUNKSIZE = 0;
		WRITER->CONSTANT_SIZE = WRITER->CONSTANT_DUR = 0;
		IF (WRITER->STBL->SAMPLESIZE->SAMPLESIZE)
			WRITER->CONSTANT_SIZE = WRITER->STBL->SAMPLESIZE->SAMPLESIZE;
		IF (WRITER->STBL->TIMETOSAMPLE->NB_ENTRIES==1) {
			WRITER->CONSTANT_DUR = WRITER->STBL->TIMETOSAMPLE->ENTRIES[0].SAMPLEDELTA;
			IF (WRITER->CONSTANT_DUR>1) WRITER->CONSTANT_DUR = 0;
		}
		IF (!WRITER->CONSTANT_DUR || !WRITER->CONSTANT_SIZE || (WRITER->CONSTANT_SIZE>=10))
			WRITER->CONSTANT_SIZE = WRITER->CONSTANT_DUR = 0;

		WRITER->STSC = (GF_SAMPLETOCHUNKBOX *) GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_STSC);
		IF (!WRITER->STSC) RETURN GF_OUT_OF_MEM;
		IF (WRITER->STBL->CHUNKOFFSET->TYPE == GF_ISOM_BOX_TYPE_STCO) {
			WRITER->STCO = GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_STCO);
		} ELSE {
			WRITER->STCO = GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_CO64);
		}
		IF (!WRITER->STCO) RETURN GF_OUT_OF_MEM;
		/*STOPS FROM CHUNK ESCAPE*/
		IF (INTERLEAVING) WRITER->STBL->MAXSAMPLEPERCHUNK = 0;
		/*FOR PROGRESS, ASSUME ONLY ONE DESCINDEX*/
		IF (MEDIA_ISSELFCONTAINED(WRITER->MDIA, 1))
			MW->TOTAL_SAMPLES += WRITER->STBL->SAMPLESIZE->SAMPLECOUNT;
		/*OPTIMIZATION FOR INTERLEAVING: PUT AUDIO LAST (THIS CAN BE OVERRIDDEN BY PRIORITIES)*/
		IF (MOVIE->STORAGEMODE != GF_ISOM_STORE_INTERLEAVED) {
			GF_LIST_ADD(WRITERS, WRITER);
		} ELSE {
			IF (WRITER->MDIA->INFORMATION->INFOHEADER && WRITER->MDIA->INFORMATION->INFOHEADER->TYPE == GF_ISOM_BOX_TYPE_SMHD) {
				GF_LIST_ADD(WRITERS, WRITER);
			} ELSE {
				GF_LIST_INSERT(WRITERS, WRITER, 0);
			}
		}
		IF (MOVIE->SAMPLE_GROUPS_IN_TRAF && TRAK->MEDIA->INFORMATION->SAMPLETABLE) {
			GF_ISOM_BOX_ARRAY_DEL_PARENT(&TRAK->MEDIA->INFORMATION->SAMPLETABLE->CHILD_BOXES, TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEGROUPSDESCRIPTION);
			TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEGROUPSDESCRIPTION = NULL;
		}
	}
	RETURN GF_OK;

EXIT:
	CLEANWRITERS(WRITERS);
	RETURN GF_OUT_OF_MEM;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 328827_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RBINJAVAELEMENTVALUE *R_BIN_JAVA_ELEMENT_VALUE_NEW(UT8 *BUFFER, UT64 SZ, UT64 BUF_OFFSET) {
	UT32 I = 0;
	UT64 OFFSET = 0;
	IF (SZ < 8) {
		RETURN NULL;
	}
	RBINJAVAELEMENTVALUE *ELEMENT_VALUE = R_NEW0 (RBINJAVAELEMENTVALUE);
	IF (!ELEMENT_VALUE) {
		RETURN NULL;
	}
	RBINJAVAELEMENTVALUEPAIR *EVPS = NULL;
	ELEMENT_VALUE->METAS = R_NEW0 (RBINJAVAMETAINFO);
	IF (!ELEMENT_VALUE->METAS) {
		R_FREE (ELEMENT_VALUE);
		RETURN NULL;
	}
	ELEMENT_VALUE->FILE_OFFSET = BUF_OFFSET;
	ELEMENT_VALUE->TAG = BUFFER[OFFSET];
	ELEMENT_VALUE->SIZE += 1;
	OFFSET += 1;
	ELEMENT_VALUE->METAS->TYPE_INFO = (VOID *) R_BIN_JAVA_GET_EV_META_FROM_TAG (ELEMENT_VALUE->TAG);
	SWITCH (ELEMENT_VALUE->TAG) {
	CASE R_BIN_JAVA_EV_TAG_BYTE:
	CASE R_BIN_JAVA_EV_TAG_CHAR:
	CASE R_BIN_JAVA_EV_TAG_DOUBLE:
	CASE R_BIN_JAVA_EV_TAG_FLOAT:
	CASE R_BIN_JAVA_EV_TAG_INT:
	CASE R_BIN_JAVA_EV_TAG_LONG:
	CASE R_BIN_JAVA_EV_TAG_SHORT:
	CASE R_BIN_JAVA_EV_TAG_BOOLEAN:
	CASE R_BIN_JAVA_EV_TAG_STRING:
		// LOOK UP VALUE IN BIN->CP_LIST
		// (UT16) READ AND SET CONST_VALUE.CONST_VALUE_IDX
		ELEMENT_VALUE->VALUE.CONST_VALUE.CONST_VALUE_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		ELEMENT_VALUE->SIZE += 2;
		// LOOK-UP, DEEP COPY, AND SET CONST_VALUE.CONST_VALUE_CP_OBJ
		ELEMENT_VALUE->VALUE.CONST_VALUE.CONST_VALUE_CP_OBJ = R_BIN_JAVA_CLONE_CP_IDX (R_BIN_JAVA_GLOBAL_BIN, ELEMENT_VALUE->VALUE.CONST_VALUE.CONST_VALUE_IDX);
		BREAK;
	CASE R_BIN_JAVA_EV_TAG_ENUM:
		// (UT16) READ AND SET ENUM_CONST_VALUE.TYPE_NAME_IDX
		ELEMENT_VALUE->VALUE.ENUM_CONST_VALUE.TYPE_NAME_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		ELEMENT_VALUE->SIZE += 2;
		OFFSET += 2;
		// (UT16) READ AND SET ENUM_CONST_VALUE.CONST_NAME_IDX
		ELEMENT_VALUE->VALUE.ENUM_CONST_VALUE.CONST_NAME_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		ELEMENT_VALUE->SIZE += 2;
		OFFSET += 2;
		// LOOK UP TYPE_NAME_INDEX IN BIN->CP_LIST
		// LOOK-UP, DEEP COPY, AND SET ENUM_CONST_VALUE.CONST_NAME_CP_OBJ
		ELEMENT_VALUE->VALUE.ENUM_CONST_VALUE.CONST_NAME_CP_OBJ = R_BIN_JAVA_CLONE_CP_IDX (R_BIN_JAVA_GLOBAL_BIN, ELEMENT_VALUE->VALUE.ENUM_CONST_VALUE.CONST_NAME_IDX);
		// LOOK-UP, DEEP COPY, AND SET ENUM_CONST_VALUE.TYPE_NAME_CP_OBJ
		ELEMENT_VALUE->VALUE.ENUM_CONST_VALUE.TYPE_NAME_CP_OBJ = R_BIN_JAVA_CLONE_CP_IDX (R_BIN_JAVA_GLOBAL_BIN, ELEMENT_VALUE->VALUE.ENUM_CONST_VALUE.TYPE_NAME_IDX);
		BREAK;
	CASE R_BIN_JAVA_EV_TAG_CLASS:
		// (UT16) READ AND SET CLASS_VALUE.CLASS_INFO_IDX
		ELEMENT_VALUE->VALUE.CLASS_VALUE.CLASS_INFO_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		ELEMENT_VALUE->SIZE += 2;
		OFFSET += 2;
		// LOOK UP TYPE_NAME_INDEX IN BIN->CP_LIST
		// LOOK-UP, DEEP COPY, AND SET CLASS_VALUE.CLASS_INFO_CP_OBJ
		ELEMENT_VALUE->VALUE.CLASS_VALUE.CLASS_INFO_CP_OBJ = R_BIN_JAVA_CLONE_CP_IDX (R_BIN_JAVA_GLOBAL_BIN, ELEMENT_VALUE->VALUE.CLASS_VALUE.CLASS_INFO_IDX);
		BREAK;
	CASE R_BIN_JAVA_EV_TAG_ARRAY:
		// (UT16) READ AND SET ARRAY_VALUE.NUM_VALUES
		ELEMENT_VALUE->VALUE.ARRAY_VALUE.NUM_VALUES = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		ELEMENT_VALUE->SIZE += 2;
		OFFSET += 2;
		ELEMENT_VALUE->VALUE.ARRAY_VALUE.VALUES = R_LIST_NEW ();
		FOR (I = 0; I < ELEMENT_VALUE->VALUE.ARRAY_VALUE.NUM_VALUES; I++) {
			IF (OFFSET >= SZ) {
				BREAK;
			}
			RBINJAVAELEMENTVALUE *EV_ELEMENT = R_BIN_JAVA_ELEMENT_VALUE_NEW (BUFFER + OFFSET, SZ - OFFSET, BUF_OFFSET + OFFSET);
			IF (EV_ELEMENT) {
				ELEMENT_VALUE->SIZE += EV_ELEMENT->SIZE;
				OFFSET += EV_ELEMENT->SIZE;
				// READ ARRAY_VALUE.NUM_VALUES, AND APPEND TO ARRAY_VALUE.VALUES
				R_LIST_APPEND (ELEMENT_VALUE->VALUE.ARRAY_VALUE.VALUES, (VOID *) EV_ELEMENT);
			}
		}
		BREAK;
	CASE R_BIN_JAVA_EV_TAG_ANNOTATION:
		// ANNOTATION NEW IS NOT USED HERE.
		// (UT16) READ AND SET ANNOTATION_VALUE.TYPE_IDX;
		IF (OFFSET + 8 < SZ) {
			ELEMENT_VALUE->VALUE.ANNOTATION_VALUE.TYPE_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
			ELEMENT_VALUE->SIZE += 2;
			OFFSET += 2;
			// (UT16) READ AND SET ANNOTATION_VALUE.NUM_ELEMENT_VALUE_PAIRS;
			ELEMENT_VALUE->VALUE.ANNOTATION_VALUE.NUM_ELEMENT_VALUE_PAIRS = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
			ELEMENT_VALUE->SIZE += 2;
			OFFSET += 2;
		}
		ELEMENT_VALUE->VALUE.ANNOTATION_VALUE.ELEMENT_VALUE_PAIRS = R_LIST_NEWF (R_BIN_JAVA_ELEMENT_PAIR_FREE);
		// READ ANNOTATION_VALUE.NUM_ELEMENT_VALUE_PAIRS, AND APPEND TO ANNOTATION_VALUE.ELEMENT_VALUE_PAIRS
		FOR (I = 0; I < ELEMENT_VALUE->VALUE.ANNOTATION_VALUE.NUM_ELEMENT_VALUE_PAIRS; I++) {
			IF (OFFSET > SZ) {
				BREAK;
			}
			EVPS = R_BIN_JAVA_ELEMENT_PAIR_NEW (BUFFER + OFFSET, SZ - OFFSET, BUF_OFFSET + OFFSET);
			IF (EVPS) {
				ELEMENT_VALUE->SIZE += EVPS->SIZE;
				OFFSET += EVPS->SIZE;
			}
			IF (EVPS == NULL) {
				// TODO: EPRINTF ERROR WHEN READING ELEMENT PAIR
			}
			R_LIST_APPEND (ELEMENT_VALUE->VALUE.ANNOTATION_VALUE.ELEMENT_VALUE_PAIRS, (VOID *) EVPS);
		}
		BREAK;
	DEFAULT:
		// EPRINTF UNABLE TO HANDLE TAG
		BREAK;
	}
	RETURN ELEMENT_VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 400769_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SIZE_T COPY_PAGE_FROM_ITER(STRUCT PAGE *PAGE, SIZE_T OFFSET, SIZE_T BYTES,
			 STRUCT IOV_ITER *I)
{
	IF (UNLIKELY(!PAGE_COPY_SANE(PAGE, OFFSET, BYTES)))
		RETURN 0;
	IF (LIKELY(ITER_IS_IOVEC(I)))
		RETURN COPY_PAGE_FROM_ITER_IOVEC(PAGE, OFFSET, BYTES, I);
	IF (IOV_ITER_IS_BVEC(I) || IOV_ITER_IS_KVEC(I) || IOV_ITER_IS_XARRAY(I)) {
		VOID *KADDR = KMAP_LOCAL_PAGE(PAGE);
		SIZE_T WANTED = _COPY_FROM_ITER(KADDR + OFFSET, BYTES, I);
		KUNMAP_LOCAL(KADDR);
		RETURN WANTED;
	}
	WARN_ON(1);
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 409466_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GET_TERMCODE(INT I)
{
    IF (I >= TC_LEN)
	RETURN NULL;
    RETURN &TERMCODES[I].NAME[0];
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 248258_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC CFG_OPT_T *CFG_GETOPT_ARRAY(CFG_OPT_T *ROOTOPTS, INT CFG_FLAGS, CONST CHAR *NAME)
{
	UNSIGNED INT I;
	CFG_OPT_T *OPTS = ROOTOPTS;

	IF (!ROOTOPTS || !NAME) {
		ERRNO = EINVAL;
		RETURN NULL;
	}

	WHILE (NAME && *NAME) {
		CFG_T *SECCFG;
		CHAR *SECNAME;
		SIZE_T LEN = STRCSPN(NAME, "|");

		IF (NAME[LEN] == 0 /*LEN == STRLEN(NAME) */ )
			/* NO MORE SUBSECTIONS */
			BREAK;

		IF (LEN) {
			CFG_OPT_T *SECOPT;

			SECNAME = STRNDUP(NAME, LEN);
			IF (!SECNAME)
				RETURN NULL;

			SECOPT = CFG_GETOPT_ARRAY(OPTS, CFG_FLAGS, SECNAME);
			FREE(SECNAME);
			IF (!SECOPT) {
				/*FPRINTF(STDERR, "SECTION NOT FOUND\N"); */
				RETURN NULL;
			}
			IF (SECOPT->TYPE != CFGT_SEC) {
				/*FPRINTF(STDERR, "NOT A SECTION!\N"); */
				RETURN NULL;
			}

			IF (!IS_SET(CFGF_MULTI, SECOPT->FLAGS) && (SECCFG = CFG_OPT_GETNSEC(SECOPT, 0)) != NULL)
				OPTS = SECCFG->OPTS;
			ELSE
				OPTS = SECOPT->SUBOPTS;

			IF (!OPTS) {
				/*FPRINTF(STDERR, "SECTION HAVE NO SUBOPTS!?\N"); */
				RETURN NULL;
			}
		}
		NAME += LEN;
		NAME += STRSPN(NAME, "|");
	}

	FOR (I = 0; OPTS[I].NAME; I++) {
		IF (IS_SET(CFGF_NOCASE, CFG_FLAGS)) {
			IF (STRCASECMP(OPTS[I].NAME, NAME) == 0)
				RETURN &OPTS[I];
		} ELSE {
			IF (STRCMP(OPTS[I].NAME, NAME) == 0)
				RETURN &OPTS[I];
		}
	}

	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 246643_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR NALUDMX_INITIALIZE(GF_FILTER *FILTER)
{
	GF_NALUDMXCTX *CTX = GF_FILTER_GET_UDTA(FILTER);
	CTX->SPS = GF_LIST_NEW();
	CTX->PPS = GF_LIST_NEW();
	SWITCH (CTX->NAL_LENGTH) {
	CASE 1:
		CTX->MAX_NALU_SIZE_ALLOWED = 0XFF;
		BREAK;
	CASE 2:
		CTX->MAX_NALU_SIZE_ALLOWED = 0XFFFF;
		BREAK;
	CASE 4:
		CTX->MAX_NALU_SIZE_ALLOWED = 0XFFFFFFFF;
		BREAK;
	CASE 0:
		CTX->MAX_NALU_SIZE_ALLOWED = 0XFFFFFFFF;
		CTX->NAL_LENGTH = 4;
		CTX->NAL_ADJUSTED = GF_TRUE;
		BREAK;
	DEFAULT:
		GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("[%S] NAL SIZE LENGTH %D IS NOT ALLOWED, DEFAULTING TO 4 BYTES\N", CTX->LOG_NAME));
		CTX->MAX_NALU_SIZE_ALLOWED = 0XFFFFFFFF;
		CTX->NAL_LENGTH = 4;
		BREAK;
	}
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212433_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_TAG(
    CHAR_U	*TAG,		// TAG (PATTERN) TO JUMP TO
    INT		TYPE,
    INT		COUNT,
    INT		FORCEIT,	// :TA WITH !
    INT		VERBOSE)	// PRINT "TAG NOT FOUND" MESSAGE
{
    TAGGY_T	*TAGSTACK = CURWIN->W_TAGSTACK;
    INT		TAGSTACKIDX = CURWIN->W_TAGSTACKIDX;
    INT		TAGSTACKLEN = CURWIN->W_TAGSTACKLEN;
    INT		CUR_MATCH = 0;
    INT		CUR_FNUM = CURBUF->B_FNUM;
    INT		OLDTAGSTACKIDX = TAGSTACKIDX;
    INT		PREVTAGSTACKIDX = TAGSTACKIDX;
    INT		PREV_NUM_MATCHES;
    INT		NEW_TAG = FALSE;
    INT		I;
    INT		IC;
    INT		NO_REGEXP = FALSE;
    INT		ERROR_CUR_MATCH = 0;
    INT		SAVE_POS = FALSE;
    FMARK_T	SAVED_FMARK;
#IFDEF FEAT_CSCOPE
    INT		JUMPED_TO_TAG = FALSE;
#ENDIF
    INT		NEW_NUM_MATCHES;
    CHAR_U	**NEW_MATCHES;
    INT		USE_TAGSTACK;
    INT		SKIP_MSG = FALSE;
    CHAR_U	*BUF_FFNAME = CURBUF->B_FFNAME;	    // NAME TO USE FOR
						    // PRIORITY COMPUTATION
    INT		USE_TFU = 1;
    CHAR_U	*TOFREE = NULL;

    // REMEMBER THE MATCHES FOR THE LAST USED TAG
    STATIC INT		NUM_MATCHES = 0;
    STATIC INT		MAX_NUM_MATCHES = 0;  // LIMIT USED FOR MATCH SEARCH
    STATIC CHAR_U	**MATCHES = NULL;
    STATIC INT		FLAGS;

#IFDEF FEAT_EVAL
    IF (TFU_IN_USE)
    {
	EMSG(_(E_CANNOT_MODIFY_TAG_STACK_WITHIN_TAGFUNC));
	RETURN FALSE;
    }
#ENDIF

#IFDEF EXITFREE
    IF (TYPE == DT_FREE)
    {
	// REMOVE THE LIST OF MATCHES
	FREEWILD(NUM_MATCHES, MATCHES);
# IFDEF FEAT_CSCOPE
	CS_FREE_TAGS();
# ENDIF
	NUM_MATCHES = 0;
	RETURN FALSE;
    }
#ENDIF

    IF (TYPE == DT_HELP)
    {
	TYPE = DT_TAG;
	NO_REGEXP = TRUE;
	USE_TFU = 0;
    }

    PREV_NUM_MATCHES = NUM_MATCHES;
    FREE_STRING_OPTION(NOFILE_FNAME);
    NOFILE_FNAME = NULL;

    CLEAR_POS(&SAVED_FMARK.MARK);	// SHUTUP GCC 4.0
    SAVED_FMARK.FNUM = 0;

    /*
     * DON'T ADD A TAG TO THE TAGSTACK IF 'TAGSTACK' HAS BEEN RESET.
     */
    IF ((!P_TGST && *TAG != NUL))
    {
	USE_TAGSTACK = FALSE;
	NEW_TAG = TRUE;
#IF DEFINED(FEAT_QUICKFIX)
	IF (G_DO_TAGPREVIEW != 0)
	{
	    TAGSTACK_CLEAR_ENTRY(&PTAG_ENTRY);
	    IF ((PTAG_ENTRY.TAGNAME = VIM_STRSAVE(TAG)) == NULL)
		GOTO END_DO_TAG;
	}
#ENDIF
    }
    ELSE
    {
#IF DEFINED(FEAT_QUICKFIX)
	IF (G_DO_TAGPREVIEW != 0)
	    USE_TAGSTACK = FALSE;
	ELSE
#ENDIF
	    USE_TAGSTACK = TRUE;

	// NEW PATTERN, ADD TO THE TAG STACK
	IF (*TAG != NUL
		&& (TYPE == DT_TAG || TYPE == DT_SELECT || TYPE == DT_JUMP
#IFDEF FEAT_QUICKFIX
		    || TYPE == DT_LTAG
#ENDIF
#IFDEF FEAT_CSCOPE
		    || TYPE == DT_CSCOPE
#ENDIF
		    ))
	{
#IF DEFINED(FEAT_QUICKFIX)
	    IF (G_DO_TAGPREVIEW != 0)
	    {
		IF (PTAG_ENTRY.TAGNAME != NULL
			&& STRCMP(PTAG_ENTRY.TAGNAME, TAG) == 0)
		{
		    // JUMPING TO SAME TAG: KEEP THE CURRENT MATCH, SO THAT
		    // THE CURSORHOLD AUTOCOMMAND EXAMPLE WORKS.
		    CUR_MATCH = PTAG_ENTRY.CUR_MATCH;
		    CUR_FNUM = PTAG_ENTRY.CUR_FNUM;
		}
		ELSE
		{
		    TAGSTACK_CLEAR_ENTRY(&PTAG_ENTRY);
		    IF ((PTAG_ENTRY.TAGNAME = VIM_STRSAVE(TAG)) == NULL)
			GOTO END_DO_TAG;
		}
	    }
	    ELSE
#ENDIF
	    {
		/*
		 * IF THE LAST USED ENTRY IS NOT AT THE TOP, DELETE ALL TAG
		 * STACK ENTRIES ABOVE IT.
		 */
		WHILE (TAGSTACKIDX < TAGSTACKLEN)
		    TAGSTACK_CLEAR_ENTRY(&TAGSTACK[--TAGSTACKLEN]);

		// IF THE TAGSTACK IS FULL: REMOVE OLDEST ENTRY
		IF (++TAGSTACKLEN > TAGSTACKSIZE)
		{
		    TAGSTACKLEN = TAGSTACKSIZE;
		    TAGSTACK_CLEAR_ENTRY(&TAGSTACK[0]);
		    FOR (I = 1; I < TAGSTACKLEN; ++I)
			TAGSTACK[I - 1] = TAGSTACK[I];
		    --TAGSTACKIDX;
		}

		/*
		 * PUT THE TAG NAME IN THE TAG STACK
		 */
		IF ((TAGSTACK[TAGSTACKIDX].TAGNAME = VIM_STRSAVE(TAG)) == NULL)
		{
		    CURWIN->W_TAGSTACKLEN = TAGSTACKLEN - 1;
		    GOTO END_DO_TAG;
		}
		CURWIN->W_TAGSTACKLEN = TAGSTACKLEN;

		SAVE_POS = TRUE;	// SAVE THE CURSOR POSITION BELOW
	    }

	    NEW_TAG = TRUE;
	}
	ELSE
	{
	    IF (
#IF DEFINED(FEAT_QUICKFIX)
		    G_DO_TAGPREVIEW != 0 ? PTAG_ENTRY.TAGNAME == NULL :
#ENDIF
		    TAGSTACKLEN == 0)
	    {
		// EMPTY STACK
		EMSG(_(E_TAG_STACK_EMPTY));
		GOTO END_DO_TAG;
	    }

	    IF (TYPE == DT_POP)		// GO TO OLDER POSITION
	    {
#IFDEF FEAT_FOLDING
		INT	OLD_KEYTYPED = KEYTYPED;
#ENDIF
		IF ((TAGSTACKIDX -= COUNT) < 0)
		{
		    EMSG(_(E_AT_BOTTOM_OF_TAG_STACK));
		    IF (TAGSTACKIDX + COUNT == 0)
		    {
			// WE DID [NUM]^T FROM THE BOTTOM OF THE STACK
			TAGSTACKIDX = 0;
			GOTO END_DO_TAG;
		    }
		    // WE WEREN'T AT THE BOTTOM OF THE STACK, SO JUMP ALL THE
		    // WAY TO THE BOTTOM NOW.
		    TAGSTACKIDX = 0;
		}
		ELSE IF (TAGSTACKIDX >= TAGSTACKLEN)    // COUNT == 0?
		{
		    EMSG(_(E_AT_TOP_OF_TAG_STACK));
		    GOTO END_DO_TAG;
		}

		// MAKE A COPY OF THE FMARK, AUTOCOMMANDS MAY INVALIDATE THE
		// TAGSTACK BEFORE IT'S USED.
		SAVED_FMARK = TAGSTACK[TAGSTACKIDX].FMARK;
		IF (SAVED_FMARK.FNUM != CURBUF->B_FNUM)
		{
		    /*
		     * JUMP TO OTHER FILE. IF THIS FAILS (E.G. BECAUSE THE
		     * FILE WAS CHANGED) KEEP ORIGINAL POSITION IN TAG STACK.
		     */
		    IF (BUFLIST_GETFILE(SAVED_FMARK.FNUM, SAVED_FMARK.MARK.LNUM,
					       GETF_SETMARK, FORCEIT) == FAIL)
		    {
			TAGSTACKIDX = OLDTAGSTACKIDX;  // BACK TO OLD POSN
			GOTO END_DO_TAG;
		    }
		    // AN BUFREADPOST AUTOCOMMAND MAY JUMP TO THE '" MARK, BUT
		    // WE DON'T WHAT THAT HERE.
		    CURWIN->W_CURSOR.LNUM = SAVED_FMARK.MARK.LNUM;
		}
		ELSE
		{
		    SETPCMARK();
		    CURWIN->W_CURSOR.LNUM = SAVED_FMARK.MARK.LNUM;
		}
		CURWIN->W_CURSOR.COL = SAVED_FMARK.MARK.COL;
		CURWIN->W_SET_CURSWANT = TRUE;
		CHECK_CURSOR();
#IFDEF FEAT_FOLDING
		IF ((FDO_FLAGS & FDO_TAG) && OLD_KEYTYPED)
		    FOLDOPENCURSOR();
#ENDIF

		// REMOVE THE OLD LIST OF MATCHES
		FREEWILD(NUM_MATCHES, MATCHES);
#IFDEF FEAT_CSCOPE
		CS_FREE_TAGS();
#ENDIF
		NUM_MATCHES = 0;
		TAG_FREEMATCH();
		GOTO END_DO_TAG;
	    }

	    IF (TYPE == DT_TAG
#IF DEFINED(FEAT_QUICKFIX)
		    || TYPE == DT_LTAG
#ENDIF
	       )
	    {
#IF DEFINED(FEAT_QUICKFIX)
		IF (G_DO_TAGPREVIEW != 0)
		{
		    CUR_MATCH = PTAG_ENTRY.CUR_MATCH;
		    CUR_FNUM = PTAG_ENTRY.CUR_FNUM;
		}
		ELSE
#ENDIF
		{
		    // ":TAG" (NO ARGUMENT): GO TO NEWER PATTERN
		    SAVE_POS = TRUE;	// SAVE THE CURSOR POSITION BELOW
		    IF ((TAGSTACKIDX += COUNT - 1) >= TAGSTACKLEN)
		    {
			/*
			 * BEYOND THE LAST ONE, JUST GIVE AN ERROR MESSAGE AND
			 * GO TO THE LAST ONE.  DON'T STORE THE CURSOR
			 * POSITION.
			 */
			TAGSTACKIDX = TAGSTACKLEN - 1;
			EMSG(_(E_AT_TOP_OF_TAG_STACK));
			SAVE_POS = FALSE;
		    }
		    ELSE IF (TAGSTACKIDX < 0)	// MUST HAVE BEEN COUNT == 0
		    {
			EMSG(_(E_AT_BOTTOM_OF_TAG_STACK));
			TAGSTACKIDX = 0;
			GOTO END_DO_TAG;
		    }
		    CUR_MATCH = TAGSTACK[TAGSTACKIDX].CUR_MATCH;
		    CUR_FNUM = TAGSTACK[TAGSTACKIDX].CUR_FNUM;
		}
		NEW_TAG = TRUE;
	    }
	    ELSE				// GO TO OTHER MATCHING TAG
	    {
		// SAVE INDEX FOR WHEN SELECTION IS CANCELLED.
		PREVTAGSTACKIDX = TAGSTACKIDX;

#IF DEFINED(FEAT_QUICKFIX)
		IF (G_DO_TAGPREVIEW != 0)
		{
		    CUR_MATCH = PTAG_ENTRY.CUR_MATCH;
		    CUR_FNUM = PTAG_ENTRY.CUR_FNUM;
		}
		ELSE
#ENDIF
		{
		    IF (--TAGSTACKIDX < 0)
			TAGSTACKIDX = 0;
		    CUR_MATCH = TAGSTACK[TAGSTACKIDX].CUR_MATCH;
		    CUR_FNUM = TAGSTACK[TAGSTACKIDX].CUR_FNUM;
		}
		SWITCH (TYPE)
		{
		    CASE DT_FIRST: CUR_MATCH = COUNT - 1; BREAK;
		    CASE DT_SELECT:
		    CASE DT_JUMP:
#IFDEF FEAT_CSCOPE
		    CASE DT_CSCOPE:
#ENDIF
		    CASE DT_LAST:  CUR_MATCH = MAXCOL - 1; BREAK;
		    CASE DT_NEXT:  CUR_MATCH += COUNT; BREAK;
		    CASE DT_PREV:  CUR_MATCH -= COUNT; BREAK;
		}
		IF (CUR_MATCH >= MAXCOL)
		    CUR_MATCH = MAXCOL - 1;
		ELSE IF (CUR_MATCH < 0)
		{
		    EMSG(_(E_CANNOT_GO_BEFORE_FIRST_MATCHING_TAG));
		    SKIP_MSG = TRUE;
		    CUR_MATCH = 0;
		    CUR_FNUM = CURBUF->B_FNUM;
		}
	    }
	}

#IF DEFINED(FEAT_QUICKFIX)
	IF (G_DO_TAGPREVIEW != 0)
	{
	    IF (TYPE != DT_SELECT && TYPE != DT_JUMP)
	    {
		PTAG_ENTRY.CUR_MATCH = CUR_MATCH;
		PTAG_ENTRY.CUR_FNUM = CUR_FNUM;
	    }
	}
	ELSE
#ENDIF
	{
	    /*
	     * FOR ":TAG [ARG]" OR ":TSELECT" REMEMBER POSITION BEFORE THE JUMP.
	     */
	    SAVED_FMARK = TAGSTACK[TAGSTACKIDX].FMARK;
	    IF (SAVE_POS)
	    {
		TAGSTACK[TAGSTACKIDX].FMARK.MARK = CURWIN->W_CURSOR;
		TAGSTACK[TAGSTACKIDX].FMARK.FNUM = CURBUF->B_FNUM;
	    }

	    // CURWIN WILL CHANGE IN THE CALL TO JUMPTO_TAG() IF ":STAG" WAS
	    // USED OR AN AUTOCOMMAND JUMPS TO ANOTHER WINDOW; STORE VALUE OF
	    // TAGSTACKIDX NOW.
	    CURWIN->W_TAGSTACKIDX = TAGSTACKIDX;
	    IF (TYPE != DT_SELECT && TYPE != DT_JUMP)
	    {
		CURWIN->W_TAGSTACK[TAGSTACKIDX].CUR_MATCH = CUR_MATCH;
		CURWIN->W_TAGSTACK[TAGSTACKIDX].CUR_FNUM = CUR_FNUM;
	    }
	}
    }

    // WHEN NOT USING THE CURRENT BUFFER GET THE NAME OF BUFFER "CUR_FNUM".
    // MAKES SURE THAT THE TAG ORDER DOESN'T CHANGE WHEN USING A REMEMBERED
    // POSITION FOR "CUR_MATCH".
    IF (CUR_FNUM != CURBUF->B_FNUM)
    {
	BUF_T *BUF = BUFLIST_FINDNR(CUR_FNUM);

	IF (BUF != NULL)
	    BUF_FFNAME = BUF->B_FFNAME;
    }

    /*
     * REPEAT SEARCHING FOR TAGS, WHEN A FILE HAS NOT BEEN FOUND.
     */
    FOR (;;)
    {
	INT	OTHER_NAME;
	CHAR_U	*NAME;

	/*
	 * WHEN DESIRED MATCH NOT FOUND YET, TRY TO FIND IT (AND OTHERS).
	 */
	IF (USE_TAGSTACK)
	{
	    // MAKE A COPY, THE TAGSTACK MAY CHANGE IN 'TAGFUNC'
	    NAME = VIM_STRSAVE(TAGSTACK[TAGSTACKIDX].TAGNAME);
	    VIM_FREE(TOFREE);
	    TOFREE = NAME;
	}
#IF DEFINED(FEAT_QUICKFIX)
	ELSE IF (G_DO_TAGPREVIEW != 0)
	    NAME = PTAG_ENTRY.TAGNAME;
#ENDIF
	ELSE
	    NAME = TAG;
	OTHER_NAME = (TAGMATCHNAME == NULL || STRCMP(TAGMATCHNAME, NAME) != 0);
	IF (NEW_TAG
		|| (CUR_MATCH >= NUM_MATCHES && MAX_NUM_MATCHES != MAXCOL)
		|| OTHER_NAME)
	{
	    IF (OTHER_NAME)
	    {
		VIM_FREE(TAGMATCHNAME);
		TAGMATCHNAME = VIM_STRSAVE(NAME);
	    }

	    IF (TYPE == DT_SELECT || TYPE == DT_JUMP
#IF DEFINED(FEAT_QUICKFIX)
		|| TYPE == DT_LTAG
#ENDIF
		)
		CUR_MATCH = MAXCOL - 1;
	    IF (TYPE == DT_TAG)
		MAX_NUM_MATCHES = MAXCOL;
	    ELSE
		MAX_NUM_MATCHES = CUR_MATCH + 1;

	    // WHEN THE ARGUMENT STARTS WITH '/', USE IT AS A REGEXP
	    IF (!NO_REGEXP && *NAME == '/')
	    {
		FLAGS = TAG_REGEXP;
		++NAME;
	    }
	    ELSE
		FLAGS = TAG_NOIC;

#IFDEF FEAT_CSCOPE
	    IF (TYPE == DT_CSCOPE)
		FLAGS = TAG_CSCOPE;
#ENDIF
	    IF (VERBOSE)
		FLAGS |= TAG_VERBOSE;

	    IF (!USE_TFU)
		FLAGS |= TAG_NO_TAGFUNC;

	    IF (FIND_TAGS(NAME, &NEW_NUM_MATCHES, &NEW_MATCHES, FLAGS,
					    MAX_NUM_MATCHES, BUF_FFNAME) == OK
		    && NEW_NUM_MATCHES < MAX_NUM_MATCHES)
		MAX_NUM_MATCHES = MAXCOL; // IF LESS THAN MAX_NUM_MATCHES
					  // FOUND: ALL MATCHES FOUND.

	    // IF THERE ALREADY WERE SOME MATCHES FOR THE SAME NAME, MOVE THEM
	    // TO THE START.  AVOIDS THAT THE ORDER CHANGES WHEN USING
	    // ":TNEXT" AND JUMPING TO ANOTHER FILE.
	    IF (!NEW_TAG && !OTHER_NAME)
	    {
		INT	    J, K;
		INT	    IDX = 0;
		TAGPTRS_T   TAGP, TAGP2;

		// FIND THE POSITION OF EACH OLD MATCH IN THE NEW LIST.  NEED
		// TO USE PARSE_MATCH() TO FIND THE TAG LINE.
		FOR (J = 0; J < NUM_MATCHES; ++J)
		{
		    PARSE_MATCH(MATCHES[J], &TAGP);
		    FOR (I = IDX; I < NEW_NUM_MATCHES; ++I)
		    {
			PARSE_MATCH(NEW_MATCHES[I], &TAGP2);
			IF (STRCMP(TAGP.TAGNAME, TAGP2.TAGNAME) == 0)
			{
			    CHAR_U *P = NEW_MATCHES[I];
			    FOR (K = I; K > IDX; --K)
				NEW_MATCHES[K] = NEW_MATCHES[K - 1];
			    NEW_MATCHES[IDX++] = P;
			    BREAK;
			}
		    }
		}
	    }
	    FREEWILD(NUM_MATCHES, MATCHES);
	    NUM_MATCHES = NEW_NUM_MATCHES;
	    MATCHES = NEW_MATCHES;
	}

	IF (NUM_MATCHES <= 0)
	{
	    IF (VERBOSE)
		SEMSG(_(E_TAG_NOT_FOUND_STR), NAME);
#IF DEFINED(FEAT_QUICKFIX)
	    G_DO_TAGPREVIEW = 0;
#ENDIF
	}
	ELSE
	{
	    INT ASK_FOR_SELECTION = FALSE;

#IFDEF FEAT_CSCOPE
	    IF (TYPE == DT_CSCOPE && NUM_MATCHES > 1)
	    {
		CS_PRINT_TAGS();
		ASK_FOR_SELECTION = TRUE;
	    }
	    ELSE
#ENDIF
	    IF (TYPE == DT_TAG && *TAG != NUL)
		// IF A COUNT IS SUPPLIED TO THE ":TAG <NAME>" COMMAND, THEN
		// JUMP TO COUNT'TH MATCHING TAG.
		CUR_MATCH = COUNT > 0 ? COUNT - 1 : 0;
	    ELSE IF (TYPE == DT_SELECT || (TYPE == DT_JUMP && NUM_MATCHES > 1))
	    {
		PRINT_TAG_LIST(NEW_TAG, USE_TAGSTACK, NUM_MATCHES, MATCHES);
		ASK_FOR_SELECTION = TRUE;
	    }
#IF DEFINED(FEAT_QUICKFIX) && DEFINED(FEAT_EVAL)
	    ELSE IF (TYPE == DT_LTAG)
	    {
		IF (ADD_LLIST_TAGS(TAG, NUM_MATCHES, MATCHES) == FAIL)
		    GOTO END_DO_TAG;
		CUR_MATCH = 0;		// JUMP TO THE FIRST TAG
	    }
#ENDIF

	    IF (ASK_FOR_SELECTION == TRUE)
	    {
		/*
		 * ASK TO SELECT A TAG FROM THE LIST.
		 */
		I = PROMPT_FOR_NUMBER(NULL);
		IF (I <= 0 || I > NUM_MATCHES || GOT_INT)
		{
		    // NO VALID CHOICE: DON'T CHANGE ANYTHING
		    IF (USE_TAGSTACK)
		    {
			TAGSTACK[TAGSTACKIDX].FMARK = SAVED_FMARK;
			TAGSTACKIDX = PREVTAGSTACKIDX;
		    }
#IFDEF FEAT_CSCOPE
		    CS_FREE_TAGS();
		    JUMPED_TO_TAG = TRUE;
#ENDIF
		    BREAK;
		}
		CUR_MATCH = I - 1;
	    }

	    IF (CUR_MATCH >= NUM_MATCHES)
	    {
		// AVOID GIVING THIS ERROR WHEN A FILE WASN'T FOUND AND WE'RE
		// LOOKING FOR A MATCH IN ANOTHER FILE, WHICH WASN'T FOUND.
		// THERE WILL BE AN EMSG("FILE DOESN'T EXIST") BELOW THEN.
		IF ((TYPE == DT_NEXT || TYPE == DT_FIRST)
						      && NOFILE_FNAME == NULL)
		{
		    IF (NUM_MATCHES == 1)
			EMSG(_(E_THERE_IS_ONLY_ONE_MATCHING_TAG));
		    ELSE
			EMSG(_(E_CANNOT_GO_BEYOND_LAST_MATCHING_TAG));
		    SKIP_MSG = TRUE;
		}
		CUR_MATCH = NUM_MATCHES - 1;
	    }
	    IF (USE_TAGSTACK)
	    {
		TAGPTRS_T   TAGP;

		TAGSTACK[TAGSTACKIDX].CUR_MATCH = CUR_MATCH;
		TAGSTACK[TAGSTACKIDX].CUR_FNUM = CUR_FNUM;

		// STORE USER-PROVIDED DATA ORIGINATING FROM TAGFUNC
		IF (USE_TFU && PARSE_MATCH(MATCHES[CUR_MATCH], &TAGP) == OK
			&& TAGP.USER_DATA)
		{
		    VIM_CLEAR(TAGSTACK[TAGSTACKIDX].USER_DATA);
		    TAGSTACK[TAGSTACKIDX].USER_DATA = VIM_STRNSAVE(
			  TAGP.USER_DATA, TAGP.USER_DATA_END - TAGP.USER_DATA);
		}

		++TAGSTACKIDX;
	    }
#IF DEFINED(FEAT_QUICKFIX)
	    ELSE IF (G_DO_TAGPREVIEW != 0)
	    {
		PTAG_ENTRY.CUR_MATCH = CUR_MATCH;
		PTAG_ENTRY.CUR_FNUM = CUR_FNUM;
	    }
#ENDIF

	    /*
	     * ONLY WHEN GOING TO TRY THE NEXT MATCH, REPORT THAT THE PREVIOUS
	     * FILE DIDN'T EXIST.  OTHERWISE AN EMSG() IS GIVEN BELOW.
	     */
	    IF (NOFILE_FNAME != NULL && ERROR_CUR_MATCH != CUR_MATCH)
		SMSG(_("FILE \"%S\" DOES NOT EXIST"), NOFILE_FNAME);


	    IC = (MATCHES[CUR_MATCH][0] & MT_IC_OFF);
	    IF (TYPE != DT_TAG && TYPE != DT_SELECT && TYPE != DT_JUMP
#IFDEF FEAT_CSCOPE
		&& TYPE != DT_CSCOPE
#ENDIF
		&& (NUM_MATCHES > 1 || IC)
		&& !SKIP_MSG)
	    {
		// GIVE AN INDICATION OF THE NUMBER OF MATCHING TAGS
		SPRINTF((CHAR *)IOBUFF, _("TAG %D OF %D%S"),
				CUR_MATCH + 1,
				NUM_MATCHES,
				MAX_NUM_MATCHES != MAXCOL ? _(" OR MORE") : "");
		IF (IC)
		    STRCAT(IOBUFF, _("  USING TAG WITH DIFFERENT CASE!"));
		IF ((NUM_MATCHES > PREV_NUM_MATCHES || NEW_TAG)
							   && NUM_MATCHES > 1)
		{
		    IF (IC)
			MSG_ATTR((CHAR *)IOBUFF, HL_ATTR(HLF_W));
		    ELSE
			MSG((CHAR *)IOBUFF);
		    MSG_SCROLL = TRUE;	// DON'T OVERWRITE THIS MESSAGE
		}
		ELSE
		    GIVE_WARNING(IOBUFF, IC);
		IF (IC && !MSG_SCROLLED && MSG_SILENT == 0)
		{
		    OUT_FLUSH();
		    UI_DELAY(1007L, TRUE);
		}
	    }

#IF DEFINED(FEAT_EVAL)
	    // LET THE SWAPEXISTS EVENT KNOW WHAT TAG WE ARE JUMPING TO.
	    VIM_SNPRINTF((CHAR *)IOBUFF, IOSIZE, ":TA %S\R", NAME);
	    SET_VIM_VAR_STRING(VV_SWAPCOMMAND, IOBUFF, -1);
#ENDIF

	    /*
	     * JUMP TO THE DESIRED MATCH.
	     */
	    I = JUMPTO_TAG(MATCHES[CUR_MATCH], FORCEIT, TYPE != DT_CSCOPE);

#IF DEFINED(FEAT_EVAL)
	    SET_VIM_VAR_STRING(VV_SWAPCOMMAND, NULL, -1);
#ENDIF

	    IF (I == NOTAGFILE)
	    {
		// FILE NOT FOUND: TRY AGAIN WITH ANOTHER MATCHING TAG
		IF ((TYPE == DT_PREV && CUR_MATCH > 0)
			|| ((TYPE == DT_TAG || TYPE == DT_NEXT
							  || TYPE == DT_FIRST)
			    && (MAX_NUM_MATCHES != MAXCOL
					     || CUR_MATCH < NUM_MATCHES - 1)))
		{
		    ERROR_CUR_MATCH = CUR_MATCH;
		    IF (USE_TAGSTACK)
			--TAGSTACKIDX;
		    IF (TYPE == DT_PREV)
			--CUR_MATCH;
		    ELSE
		    {
			TYPE = DT_NEXT;
			++CUR_MATCH;
		    }
		    CONTINUE;
		}
		SEMSG(_(E_FILE_STR_DOES_NOT_EXIST), NOFILE_FNAME);
	    }
	    ELSE
	    {
		// WE MAY HAVE JUMPED TO ANOTHER WINDOW, CHECK THAT
		// TAGSTACKIDX IS STILL VALID.
		IF (USE_TAGSTACK && TAGSTACKIDX > CURWIN->W_TAGSTACKLEN)
		    TAGSTACKIDX = CURWIN->W_TAGSTACKIDX;
#IFDEF FEAT_CSCOPE
		JUMPED_TO_TAG = TRUE;
#ENDIF
	    }
	}
	BREAK;
    }

END_DO_TAG:
    // ONLY STORE THE NEW INDEX WHEN USING THE TAGSTACK AND IT'S VALID.
    IF (USE_TAGSTACK && TAGSTACKIDX <= CURWIN->W_TAGSTACKLEN)
	CURWIN->W_TAGSTACKIDX = TAGSTACKIDX;
    POSTPONED_SPLIT = 0;	// DON'T SPLIT NEXT TIME
# IFDEF FEAT_QUICKFIX
    G_DO_TAGPREVIEW = 0;	// DON'T DO TAG PREVIEW NEXT TIME
# ENDIF

    VIM_FREE(TOFREE);
#IFDEF FEAT_CSCOPE
    RETURN JUMPED_TO_TAG;
#ELSE
    RETURN FALSE;
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 270772_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC UNSIGNED CHAR TO_HEXA(UNSIGNED CHAR C)
{
	IF (C < 10)
		C += '0';
	ELSE
		C += 'A' - 10;

	RETURN C;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 424906_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID IWL_PCIE_APM_STOP(STRUCT IWL_TRANS *TRANS, BOOL OP_MODE_LEAVE)
{
	IWL_DEBUG_INFO(TRANS, "STOP CARD, PUT IN LOW POWER STATE\N");

	IF (OP_MODE_LEAVE) {
		IF (!TEST_BIT(STATUS_DEVICE_ENABLED, &TRANS->STATUS))
			IWL_PCIE_APM_INIT(TRANS);

		/* INFORM ME THAT WE ARE LEAVING */
		IF (TRANS->TRANS_CFG->DEVICE_FAMILY == IWL_DEVICE_FAMILY_7000)
			IWL_SET_BITS_PRPH(TRANS, APMG_PCIDEV_STT_REG,
					  APMG_PCIDEV_STT_VAL_WAKE_ME);
		ELSE IF (TRANS->TRANS_CFG->DEVICE_FAMILY >=
			 IWL_DEVICE_FAMILY_8000) {
			IWL_SET_BIT(TRANS, CSR_DBG_LINK_PWR_MGMT_REG,
				    CSR_RESET_LINK_PWR_MGMT_DISABLED);
			IWL_SET_BIT(TRANS, CSR_HW_IF_CONFIG_REG,
				    CSR_HW_IF_CONFIG_REG_PREPARE |
				    CSR_HW_IF_CONFIG_REG_ENABLE_PME);
			MDELAY(1);
			IWL_CLEAR_BIT(TRANS, CSR_DBG_LINK_PWR_MGMT_REG,
				      CSR_RESET_LINK_PWR_MGMT_DISABLED);
		}
		MDELAY(5);
	}

	CLEAR_BIT(STATUS_DEVICE_ENABLED, &TRANS->STATUS);

	/* STOP DEVICE'S DMA ACTIVITY */
	IWL_PCIE_APM_STOP_MASTER(TRANS);

	IF (TRANS->CFG->LP_XTAL_WORKAROUND) {
		IWL_PCIE_APM_LP_XTAL_ENABLE(TRANS);
		RETURN;
	}

	IWL_TRANS_PCIE_SW_RESET(TRANS);

	/*
	 * CLEAR "INITIALIZATION COMPLETE" BIT TO MOVE ADAPTER FROM
	 * D0A* (POWERED-UP ACTIVE) --> D0U* (UNINITIALIZED) STATE.
	 */
	IWL_CLEAR_BIT(TRANS, CSR_GP_CNTRL,
		      BIT(TRANS->TRANS_CFG->CSR->FLAG_INIT_DONE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210555_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VHOST_BACKEND_CLEANUP(STRUCT VIRTIO_NET *DEV)
{
	IF (DEV->MEM) {
		FREE_MEM_REGION(DEV);
		RTE_FREE(DEV->MEM);
		DEV->MEM = NULL;
	}

	FREE(DEV->GUEST_PAGES);
	DEV->GUEST_PAGES = NULL;

	IF (DEV->LOG_ADDR) {
		MUNMAP((VOID *)(UINTPTR_T)DEV->LOG_ADDR, DEV->LOG_SIZE);
		DEV->LOG_ADDR = 0;
	}

	IF (DEV->SLAVE_REQ_FD >= 0) {
		CLOSE(DEV->SLAVE_REQ_FD);
		DEV->SLAVE_REQ_FD = -1;
	}

	IF (DEV->POSTCOPY_UFD >= 0) {
		CLOSE(DEV->POSTCOPY_UFD);
		DEV->POSTCOPY_UFD = -1;
	}

	DEV->POSTCOPY_LISTENING = 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 223404_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT GET_FRAMESIZE(COMPILER_COMMON *COMMON, PCRE2_SPTR CC, PCRE2_SPTR CCEND, BOOL RECURSIVE, BOOL *NEEDS_CONTROL_HEAD)
{
INT LENGTH = 0;
INT POSSESSIVE = 0;
BOOL STACK_RESTORE = FALSE;
BOOL SETSOM_FOUND = RECURSIVE;
BOOL SETMARK_FOUND = RECURSIVE;
/* THE LAST CAPTURE IS A LOCAL VARIABLE EVEN FOR RECURSIONS. */
BOOL CAPTURE_LAST_FOUND = FALSE;

#IF DEFINED DEBUG_FORCE_CONTROL_HEAD && DEBUG_FORCE_CONTROL_HEAD
SLJIT_ASSERT(COMMON->CONTROL_HEAD_PTR != 0);
*NEEDS_CONTROL_HEAD = TRUE;
#ELSE
*NEEDS_CONTROL_HEAD = FALSE;
#ENDIF

IF (CCEND == NULL)
  {
  CCEND = BRACKETEND(CC) - (1 + LINK_SIZE);
  IF (!RECURSIVE && (*CC == OP_CBRAPOS || *CC == OP_SCBRAPOS))
    {
    POSSESSIVE = LENGTH = (COMMON->CAPTURE_LAST_PTR != 0) ? 5 : 3;
    /* THIS IS CORRECT REGARDLESS OF COMMON->CAPTURE_LAST_PTR. */
    CAPTURE_LAST_FOUND = TRUE;
    }
  CC = NEXT_OPCODE(COMMON, CC);
  }

SLJIT_ASSERT(CC != NULL);
WHILE (CC < CCEND)
  SWITCH(*CC)
    {
    CASE OP_SET_SOM:
    SLJIT_ASSERT(COMMON->HAS_SET_SOM);
    STACK_RESTORE = TRUE;
    IF (!SETSOM_FOUND)
      {
      LENGTH += 2;
      SETSOM_FOUND = TRUE;
      }
    CC += 1;
    BREAK;

    CASE OP_MARK:
    CASE OP_COMMIT_ARG:
    CASE OP_PRUNE_ARG:
    CASE OP_THEN_ARG:
    SLJIT_ASSERT(COMMON->MARK_PTR != 0);
    STACK_RESTORE = TRUE;
    IF (!SETMARK_FOUND)
      {
      LENGTH += 2;
      SETMARK_FOUND = TRUE;
      }
    IF (COMMON->CONTROL_HEAD_PTR != 0)
      *NEEDS_CONTROL_HEAD = TRUE;
    CC += 1 + 2 + CC[1];
    BREAK;

    CASE OP_RECURSE:
    STACK_RESTORE = TRUE;
    IF (COMMON->HAS_SET_SOM && !SETSOM_FOUND)
      {
      LENGTH += 2;
      SETSOM_FOUND = TRUE;
      }
    IF (COMMON->MARK_PTR != 0 && !SETMARK_FOUND)
      {
      LENGTH += 2;
      SETMARK_FOUND = TRUE;
      }
    IF (COMMON->CAPTURE_LAST_PTR != 0 && !CAPTURE_LAST_FOUND)
      {
      LENGTH += 2;
      CAPTURE_LAST_FOUND = TRUE;
      }
    CC += 1 + LINK_SIZE;
    BREAK;

    CASE OP_CBRA:
    CASE OP_CBRAPOS:
    CASE OP_SCBRA:
    CASE OP_SCBRAPOS:
    STACK_RESTORE = TRUE;
    IF (COMMON->CAPTURE_LAST_PTR != 0 && !CAPTURE_LAST_FOUND)
      {
      LENGTH += 2;
      CAPTURE_LAST_FOUND = TRUE;
      }
    LENGTH += 3;
    CC += 1 + LINK_SIZE + IMM2_SIZE;
    BREAK;

    CASE OP_THEN:
    STACK_RESTORE = TRUE;
    IF (COMMON->CONTROL_HEAD_PTR != 0)
      *NEEDS_CONTROL_HEAD = TRUE;
    CC ++;
    BREAK;

    DEFAULT:
    STACK_RESTORE = TRUE;
    /* FALL THROUGH. */

    CASE OP_NOT_WORD_BOUNDARY:
    CASE OP_WORD_BOUNDARY:
    CASE OP_NOT_DIGIT:
    CASE OP_DIGIT:
    CASE OP_NOT_WHITESPACE:
    CASE OP_WHITESPACE:
    CASE OP_NOT_WORDCHAR:
    CASE OP_WORDCHAR:
    CASE OP_ANY:
    CASE OP_ALLANY:
    CASE OP_ANYBYTE:
    CASE OP_NOTPROP:
    CASE OP_PROP:
    CASE OP_ANYNL:
    CASE OP_NOT_HSPACE:
    CASE OP_HSPACE:
    CASE OP_NOT_VSPACE:
    CASE OP_VSPACE:
    CASE OP_EXTUNI:
    CASE OP_EODN:
    CASE OP_EOD:
    CASE OP_CIRC:
    CASE OP_CIRCM:
    CASE OP_DOLL:
    CASE OP_DOLLM:
    CASE OP_CHAR:
    CASE OP_CHARI:
    CASE OP_NOT:
    CASE OP_NOTI:

    CASE OP_EXACT:
    CASE OP_POSSTAR:
    CASE OP_POSPLUS:
    CASE OP_POSQUERY:
    CASE OP_POSUPTO:

    CASE OP_EXACTI:
    CASE OP_POSSTARI:
    CASE OP_POSPLUSI:
    CASE OP_POSQUERYI:
    CASE OP_POSUPTOI:

    CASE OP_NOTEXACT:
    CASE OP_NOTPOSSTAR:
    CASE OP_NOTPOSPLUS:
    CASE OP_NOTPOSQUERY:
    CASE OP_NOTPOSUPTO:

    CASE OP_NOTEXACTI:
    CASE OP_NOTPOSSTARI:
    CASE OP_NOTPOSPLUSI:
    CASE OP_NOTPOSQUERYI:
    CASE OP_NOTPOSUPTOI:

    CASE OP_TYPEEXACT:
    CASE OP_TYPEPOSSTAR:
    CASE OP_TYPEPOSPLUS:
    CASE OP_TYPEPOSQUERY:
    CASE OP_TYPEPOSUPTO:

    CASE OP_CLASS:
    CASE OP_NCLASS:
    CASE OP_XCLASS:

    CASE OP_CALLOUT:
    CASE OP_CALLOUT_STR:

    CC = NEXT_OPCODE(COMMON, CC);
    SLJIT_ASSERT(CC != NULL);
    BREAK;
    }

/* POSSESSIVE QUANTIFIERS CAN USE A SPECIAL CASE. */
IF (SLJIT_UNLIKELY(POSSESSIVE == LENGTH))
  RETURN STACK_RESTORE ? NO_FRAME : NO_STACK;

IF (LENGTH > 0)
  RETURN LENGTH + 1;
RETURN STACK_RESTORE ? NO_FRAME : NO_STACK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 194989_CWE-190.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MAGICKBOOLEANTYPE READPSDCHANNELPIXELS(IMAGE *IMAGE,
  CONST SIZE_T CHANNELS,CONST SSIZE_T ROW,CONST SSIZE_T TYPE,
  CONST UNSIGNED CHAR *PIXELS,EXCEPTIONINFO *EXCEPTION)
{
  QUANTUM
    PIXEL;

  CONST UNSIGNED CHAR
    *P;

  INDEXPACKET
    *INDEXES;

  PIXELPACKET
    *Q;

  SSIZE_T
    X;

  SIZE_T
    PACKET_SIZE;

  UNSIGNED SHORT
    NIBBLE;

  P=PIXELS;
  Q=GETAUTHENTICPIXELS(IMAGE,0,ROW,IMAGE->COLUMNS,1,EXCEPTION);
  IF (Q == (PIXELPACKET *) NULL)
    RETURN MAGICKFALSE;
  INDEXES=GETAUTHENTICINDEXQUEUE(IMAGE);
  PACKET_SIZE=GETPSDPACKETSIZE(IMAGE);
  FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
  {
    IF (PACKET_SIZE == 1)
      PIXEL=SCALECHARTOQUANTUM(*P++);
    ELSE
      IF (PACKET_SIZE == 2)
        {
          P=PUSHSHORTPIXEL(MSBENDIAN,P,&NIBBLE);
          PIXEL=SCALESHORTTOQUANTUM(NIBBLE);
        }
      ELSE
        {
          MAGICKFLOATTYPE
            NIBBLE;

          P=PUSHFLOATPIXEL(MSBENDIAN,P,&NIBBLE);
          PIXEL=CLAMPTOQUANTUM((MAGICKREALTYPE)QUANTUMRANGE*NIBBLE);
        }
    IF (IMAGE->DEPTH > 1)
      {
        SETPSDPIXEL(IMAGE,CHANNELS,TYPE,PACKET_SIZE,PIXEL,Q,INDEXES,X);
        Q++;
      }
    ELSE
      {
        SSIZE_T
          BIT,
          NUMBER_BITS;

        NUMBER_BITS=(SSIZE_T) IMAGE->COLUMNS-X;
        IF (NUMBER_BITS > 8)
          NUMBER_BITS=8;
        FOR (BIT=0; BIT < NUMBER_BITS; BIT++)
        {
          SETPSDPIXEL(IMAGE,CHANNELS,TYPE,PACKET_SIZE,(((UNSIGNED CHAR) PIXEL)
            & (0X01 << (7-BIT))) != 0 ? 0 : QUANTUMRANGE,Q++,INDEXES,X++);
        }
        IF (X != (SSIZE_T) IMAGE->COLUMNS)
          X--;
        CONTINUE;
      }
  }
  RETURN(SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213076_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID COMPILE_XCLASS_MATCHINGPATH(COMPILER_COMMON *COMMON, PCRE2_SPTR CC, JUMP_LIST **BACKTRACKS)
{
DEFINE_COMPILER;
JUMP_LIST *FOUND = NULL;
JUMP_LIST **LIST = (CC[0] & XCL_NOT) == 0 ? &FOUND : BACKTRACKS;
SLJIT_UW C, CHAROFFSET, MAX = 256, MIN = READ_CHAR_MAX;
STRUCT SLJIT_JUMP *JUMP = NULL;
PCRE2_SPTR CCBEGIN;
INT COMPARES, INVERTCMP, NUMBEROFCMPS;
#IF DEFINED SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)
BOOL UTF = COMMON->UTF;
#ENDIF /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */

#IFDEF SUPPORT_UNICODE
SLJIT_U32 UNICODE_STATUS = 0;
INT TYPEREG = TMP1;
CONST SLJIT_U32 *OTHER_CASES;
SLJIT_UW TYPEOFFSET;
#ENDIF /* SUPPORT_UNICODE */

/* SCANNING THE NECESSARY INFO. */
CC++;
CCBEGIN = CC;
COMPARES = 0;

IF (CC[-1] & XCL_MAP)
  {
  MIN = 0;
  CC += 32 / SIZEOF(PCRE2_UCHAR);
  }

WHILE (*CC != XCL_END)
  {
  COMPARES++;
  IF (*CC == XCL_SINGLE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);
    IF (C > MAX) MAX = C;
    IF (C < MIN) MIN = C;
#IFDEF SUPPORT_UNICODE
    UNICODE_STATUS |= XCLASS_SAVE_CHAR;
#ENDIF /* SUPPORT_UNICODE */
    }
  ELSE IF (*CC == XCL_RANGE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);
    IF (C < MIN) MIN = C;
    GETCHARINCTEST(C, CC);
    IF (C > MAX) MAX = C;
#IFDEF SUPPORT_UNICODE
    UNICODE_STATUS |= XCLASS_SAVE_CHAR;
#ENDIF /* SUPPORT_UNICODE */
    }
#IFDEF SUPPORT_UNICODE
  ELSE
    {
    SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
    CC++;
    IF (*CC == PT_CLIST)
      {
      OTHER_CASES = PRIV(UCD_CASELESS_SETS) + CC[1];
      WHILE (*OTHER_CASES != NOTACHAR)
        {
        IF (*OTHER_CASES > MAX) MAX = *OTHER_CASES;
        IF (*OTHER_CASES < MIN) MIN = *OTHER_CASES;
        OTHER_CASES++;
        }
      }
    ELSE
      {
      MAX = READ_CHAR_MAX;
      MIN = 0;
      }

    SWITCH(*CC)
      {
      CASE PT_ANY:
      /* ANY EITHER ACCEPTS EVERYTHING OR IGNORED. */
      IF (CC[-1] == XCL_PROP)
        {
        COMPILE_CHAR1_MATCHINGPATH(COMMON, OP_ALLANY, CC, BACKTRACKS, FALSE);
        IF (LIST == BACKTRACKS)
          ADD_JUMP(COMPILER, BACKTRACKS, JUMP(SLJIT_JUMP));
        RETURN;
        }
      BREAK;

      CASE PT_LAMP:
      CASE PT_GC:
      CASE PT_PC:
      CASE PT_ALNUM:
      UNICODE_STATUS |= XCLASS_HAS_TYPE;
      BREAK;

      CASE PT_SCX:
      UNICODE_STATUS |= XCLASS_HAS_SCRIPT_EXTENSION;
      IF (CC[-1] == XCL_NOTPROP)
        {
        UNICODE_STATUS |= XCLASS_SCRIPT_EXTENSION_NOTPROP;
        BREAK;
        }
      COMPARES++;
      /* FALL THROUGH */ 

      CASE PT_SC:
      UNICODE_STATUS |= XCLASS_HAS_SCRIPT;
      BREAK;

      CASE PT_SPACE:
      CASE PT_PXSPACE:
      CASE PT_WORD:
      CASE PT_PXGRAPH:
      CASE PT_PXPRINT:
      CASE PT_PXPUNCT:
      UNICODE_STATUS |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;
      BREAK;

      CASE PT_CLIST:
      CASE PT_UCNC:
      UNICODE_STATUS |= XCLASS_SAVE_CHAR;
      BREAK;

      CASE PT_BOOL:
      UNICODE_STATUS |= XCLASS_HAS_BOOL;
      BREAK;

      CASE PT_BIDICL:
      UNICODE_STATUS |= XCLASS_HAS_BIDICL;
      BREAK;

      DEFAULT:
      SLJIT_UNREACHABLE();
      BREAK;
      }
    CC += 2;
    }
#ENDIF /* SUPPORT_UNICODE */
  }
SLJIT_ASSERT(COMPARES > 0);

/* WE ARE NOT NECESSARY IN UTF MODE EVEN IN 8 BIT MODE. */
CC = CCBEGIN;
IF ((CC[-1] & XCL_NOT) != 0)
  READ_CHAR(COMMON, MIN, MAX, BACKTRACKS, READ_CHAR_UPDATE_STR_PTR);
ELSE
  {
#IFDEF SUPPORT_UNICODE
  READ_CHAR(COMMON, MIN, MAX, (UNICODE_STATUS & XCLASS_NEEDS_UCD) ? BACKTRACKS : NULL, 0);
#ELSE /* !SUPPORT_UNICODE */
  READ_CHAR(COMMON, MIN, MAX, NULL, 0);
#ENDIF /* SUPPORT_UNICODE */
  }

IF ((CC[-1] & XCL_HASPROP) == 0)
  {
  IF ((CC[-1] & XCL_MAP) != 0)
    {
    JUMP = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);
    IF (!OPTIMIZE_CLASS(COMMON, (CONST SLJIT_U8 *)CC, (((CONST SLJIT_U8 *)CC)[31] & 0X80) != 0, TRUE, &FOUND))
      {
      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0X7);
      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);
      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (SLJIT_SW)CC);
      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);
      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);
      ADD_JUMP(COMPILER, &FOUND, JUMP(SLJIT_NOT_ZERO));
      }

    ADD_JUMP(COMPILER, BACKTRACKS, JUMP(SLJIT_JUMP));
    JUMPHERE(JUMP);

    CC += 32 / SIZEOF(PCRE2_UCHAR);
    }
  ELSE
    {
    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, MIN);
    ADD_JUMP(COMPILER, (CC[-1] & XCL_NOT) == 0 ? BACKTRACKS : &FOUND, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, MAX - MIN));
    }
  }
ELSE IF ((CC[-1] & XCL_MAP) != 0)
  {
  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);
#IFDEF SUPPORT_UNICODE
  UNICODE_STATUS |= XCLASS_CHAR_SAVED;
#ENDIF /* SUPPORT_UNICODE */
  IF (!OPTIMIZE_CLASS(COMMON, (CONST SLJIT_U8 *)CC, FALSE, TRUE, LIST))
    {
#IF PCRE2_CODE_UNIT_WIDTH == 8
    JUMP = NULL;
    IF (COMMON->UTF)
#ENDIF /* PCRE2_CODE_UNIT_WIDTH == 8 */
      JUMP = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);

    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0X7);
    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);
    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (SLJIT_SW)CC);
    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);
    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);
    ADD_JUMP(COMPILER, LIST, JUMP(SLJIT_NOT_ZERO));

#IF PCRE2_CODE_UNIT_WIDTH == 8
    IF (COMMON->UTF)
#ENDIF /* PCRE2_CODE_UNIT_WIDTH == 8 */
      JUMPHERE(JUMP);
    }

  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);
  CC += 32 / SIZEOF(PCRE2_UCHAR);
  }

#IFDEF SUPPORT_UNICODE
IF (UNICODE_STATUS & XCLASS_NEEDS_UCD)
  {
  IF ((UNICODE_STATUS & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)
    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);

#IF PCRE2_CODE_UNIT_WIDTH == 32
  IF (!COMMON->UTF)
    {
    JUMP = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);
    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);
    JUMPHERE(JUMP);
    }
#ENDIF /* PCRE2_CODE_UNIT_WIDTH == 32 */

  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);
  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);
  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_STAGE1));
  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);
  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);
  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);
  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (SLJIT_SW)PRIV(UCD_STAGE2));
  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);
  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);
  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);
  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);

  CCBEGIN = CC;

  IF (UNICODE_STATUS & XCLASS_HAS_BIDICL)
    {
    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPTX_BIDICLASS));
    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        IF (*CC == PT_BIDICL)
          {
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
          IF (CC[-1] == XCL_NOTPROP)
            INVERTCMP ^= 0X1;
          JUMP = CMP(SLJIT_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (INT)CC[1]);
          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP);
          }
        CC += 2;
        }
      }

    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_HAS_BOOL)
    {
    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, BPROPS));
    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);
    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        IF (*CC == PT_BOOL)
          {
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
          IF (CC[-1] == XCL_NOTPROP)
            INVERTCMP ^= 0X1;

          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (SLJIT_SW)(PRIV(UCD_BOOLPROP_SETS) + (CC[1] >> 5)), SLJIT_IMM, (SLJIT_SW)1 << (CC[1] & 0X1F));
          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP(SLJIT_NOT_ZERO ^ INVERTCMP));
          }
        CC += 2;
        }
      }

    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_HAS_SCRIPT)
    {
    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPT));

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        SWITCH (*CC)
          {
          CASE PT_SCX:
          IF (CC[-1] == XCL_NOTPROP)
            BREAK;
          /* FALL THROUGH */ 

          CASE PT_SC:
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
          IF (CC[-1] == XCL_NOTPROP)
            INVERTCMP ^= 0X1;

          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, CMP(SLJIT_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (INT)CC[1]));
          }
        CC += 2;
        }
      }

    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_HAS_SCRIPT_EXTENSION)
    {
    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPTX_BIDICLASS));
    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);
    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);

    IF (UNICODE_STATUS & XCLASS_SCRIPT_EXTENSION_NOTPROP)
      {
      IF (UNICODE_STATUS & XCLASS_HAS_TYPE)
        {
        IF (UNICODE_STATUS & XCLASS_SAVE_CHAR)
          {
          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);
          UNICODE_STATUS |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;
          }
        ELSE
          {
          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);
          UNICODE_STATUS |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;
          }
        }
      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, SCRIPT));
      }

    WHILE (*CC != XCL_END)
      {
      IF (*CC == XCL_SINGLE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        }
      ELSE IF (*CC == XCL_RANGE)
        {
        CC ++;
        GETCHARINCTEST(C, CC);
        GETCHARINCTEST(C, CC);
        }
      ELSE
        {
        SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
        CC++;
        IF (*CC == PT_SCX)
          {
          COMPARES--;
          INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);

          JUMP = NULL;
          IF (CC[-1] == XCL_NOTPROP)
            {
            JUMP = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (INT)CC[1]);
            IF (INVERTCMP)
              {
              ADD_JUMP(COMPILER, BACKTRACKS, JUMP);
              JUMP = NULL;
              }
            INVERTCMP ^= 0X1;
            }

          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (SLJIT_SW)(PRIV(UCD_SCRIPT_SETS) + (CC[1] >> 5)), SLJIT_IMM, (SLJIT_SW)1 << (CC[1] & 0X1F));
          ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP(SLJIT_NOT_ZERO ^ INVERTCMP));

          IF (JUMP != NULL)
            JUMPHERE(JUMP);
          }
        CC += 2;
        }
      }

    IF (UNICODE_STATUS & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)
      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);
    ELSE IF (UNICODE_STATUS & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)
      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);
    CC = CCBEGIN;
    }

  IF (UNICODE_STATUS & XCLASS_SAVE_CHAR)
    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);

  IF (UNICODE_STATUS & XCLASS_HAS_TYPE)
    {
    IF (UNICODE_STATUS & XCLASS_SAVE_CHAR)
      TYPEREG = RETURN_ADDR;

    OP1(SLJIT_MOV_U8, TYPEREG, 0, SLJIT_MEM1(TMP2), (SLJIT_SW)PRIV(UCD_RECORDS) + SLJIT_OFFSETOF(UCD_RECORD, CHARTYPE));
    }
  }
#ENDIF /* SUPPORT_UNICODE */

/* GENERATING CODE. */
CHAROFFSET = 0;
NUMBEROFCMPS = 0;
#IFDEF SUPPORT_UNICODE
TYPEOFFSET = 0;
#ENDIF /* SUPPORT_UNICODE */

WHILE (*CC != XCL_END)
  {
  COMPARES--;
  INVERTCMP = (COMPARES == 0 && LIST != BACKTRACKS);
  JUMP = NULL;

  IF (*CC == XCL_SINGLE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);

    IF (NUMBEROFCMPS < 3 && (*CC == XCL_SINGLE || *CC == XCL_RANGE))
      {
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(NUMBEROFCMPS == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
      NUMBEROFCMPS++;
      }
    ELSE IF (NUMBEROFCMPS > 0)
      {
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      NUMBEROFCMPS = 0;
      }
    ELSE
      {
      JUMP = CMP(SLJIT_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      NUMBEROFCMPS = 0;
      }
    }
  ELSE IF (*CC == XCL_RANGE)
    {
    CC ++;
    GETCHARINCTEST(C, CC);
    SET_CHAR_OFFSET(C);
    GETCHARINCTEST(C, CC);

    IF (NUMBEROFCMPS < 3 && (*CC == XCL_SINGLE || *CC == XCL_RANGE))
      {
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(NUMBEROFCMPS == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);
      NUMBEROFCMPS++;
      }
    ELSE IF (NUMBEROFCMPS > 0)
      {
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      NUMBEROFCMPS = 0;
      }
    ELSE
      {
      JUMP = CMP(SLJIT_LESS_EQUAL ^ INVERTCMP, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(C - CHAROFFSET));
      NUMBEROFCMPS = 0;
      }
    }
#IFDEF SUPPORT_UNICODE
  ELSE
    {
    SLJIT_ASSERT(*CC == XCL_PROP || *CC == XCL_NOTPROP);
    IF (*CC == XCL_NOTPROP)
      INVERTCMP ^= 0X1;
    CC++;
    SWITCH(*CC)
      {
      CASE PT_ANY:
      IF (!INVERTCMP)
        JUMP = JUMP(SLJIT_JUMP);
      BREAK;

      CASE PT_LAMP:
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_LU - TYPEOFFSET);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_LL - TYPEOFFSET);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_LT - TYPEOFFSET);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_GC:
      C = PRIV(UCP_TYPERANGE)[(INT)CC[1] * 2];
      SET_TYPE_OFFSET(C);
      JUMP = CMP(SLJIT_LESS_EQUAL ^ INVERTCMP, TYPEREG, 0, SLJIT_IMM, PRIV(UCP_TYPERANGE)[(INT)CC[1] * 2 + 1] - C);
      BREAK;

      CASE PT_PC:
      JUMP = CMP(SLJIT_EQUAL ^ INVERTCMP, TYPEREG, 0, SLJIT_IMM, (INT)CC[1] - TYPEOFFSET);
      BREAK;

      CASE PT_SC:
      CASE PT_SCX:
      CASE PT_BOOL:
      CASE PT_BIDICL:
      COMPARES++;
      /* DO NOTHING. */
      BREAK;

      CASE PT_SPACE:
      CASE PT_PXSPACE:
      SET_CHAR_OFFSET(9);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0XD - 0X9);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X85 - 0X9);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X180E - 0X9);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      SET_TYPE_OFFSET(UCP_ZL);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_ZS - UCP_ZL);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_WORD:
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_UNDERSCORE - CHAROFFSET));
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
      /* FALL THROUGH. */

      CASE PT_ALNUM:
      SET_TYPE_OFFSET(UCP_LL);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_LU - UCP_LL);
      OP_FLAGS((*CC == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);
      SET_TYPE_OFFSET(UCP_ND);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_NO - UCP_ND);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_CLIST:
      OTHER_CASES = PRIV(UCD_CASELESS_SETS) + CC[1];

      /* AT LEAST THREE CHARACTERS ARE REQUIRED.
         OTHERWISE THIS CASE WOULD BE HANDLED BY THE NORMAL CODE PATH. */
      SLJIT_ASSERT(OTHER_CASES[0] != NOTACHAR && OTHER_CASES[1] != NOTACHAR && OTHER_CASES[2] != NOTACHAR);
      SLJIT_ASSERT(OTHER_CASES[0] < OTHER_CASES[1] && OTHER_CASES[1] < OTHER_CASES[2]);

      /* OPTIMIZING CHARACTER PAIRS, IF THEIR DIFFERENCE IS POWER OF 2. */
      IF (IS_POWEROF2(OTHER_CASES[1] ^ OTHER_CASES[0]))
        {
        IF (CHAROFFSET == 0)
          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, OTHER_CASES[1] ^ OTHER_CASES[0]);
        ELSE
          {
          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (SLJIT_SW)CHAROFFSET);
          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, OTHER_CASES[1] ^ OTHER_CASES[0]);
          }
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, OTHER_CASES[1]);
        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
        OTHER_CASES += 2;
        }
      ELSE IF (IS_POWEROF2(OTHER_CASES[2] ^ OTHER_CASES[1]))
        {
        IF (CHAROFFSET == 0)
          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, OTHER_CASES[2] ^ OTHER_CASES[1]);
        ELSE
          {
          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (SLJIT_SW)CHAROFFSET);
          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, OTHER_CASES[1] ^ OTHER_CASES[0]);
          }
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, OTHER_CASES[2]);
        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);

        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(OTHER_CASES[0] - CHAROFFSET));
        OP_FLAGS(SLJIT_OR | ((OTHER_CASES[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);

        OTHER_CASES += 3;
        }
      ELSE
        {
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(*OTHER_CASES++ - CHAROFFSET));
        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
        }

      WHILE (*OTHER_CASES != NOTACHAR)
        {
        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(*OTHER_CASES++ - CHAROFFSET));
        OP_FLAGS(SLJIT_OR | ((*OTHER_CASES == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);
        }
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_UCNC:
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_DOLLAR_SIGN - CHAROFFSET));
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_COMMERCIAL_AT - CHAROFFSET));
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(CHAR_GRAVE_ACCENT - CHAROFFSET));
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      SET_CHAR_OFFSET(0XA0);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (SLJIT_SW)(0XD7FF - CHAROFFSET));
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);
      SET_CHAR_OFFSET(0);
      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0XE000 - 0);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      CASE PT_PXGRAPH:
      /* C AND Z GROUPS ARE THE FARTHEST TWO GROUPS. */
      SET_TYPE_OFFSET(UCP_LL);
      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, TYPEREG, 0, SLJIT_IMM, UCP_SO - UCP_LL);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);

      JUMP = CMP(SLJIT_NOT_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_CF - UCP_LL);

      /* IN CASE OF UCP_CF, WE OVERWRITE THE RESULT. */
      SET_CHAR_OFFSET(0X2066);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X2069 - 0X2066);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X061C - 0X2066);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X180E - 0X2066);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      JUMPHERE(JUMP);
      JUMP = CMP(SLJIT_ZERO ^ INVERTCMP, TMP2, 0, SLJIT_IMM, 0);
      BREAK;

      CASE PT_PXPRINT:
      /* C AND Z GROUPS ARE THE FARTHEST TWO GROUPS. */
      SET_TYPE_OFFSET(UCP_LL);
      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, TYPEREG, 0, SLJIT_IMM, UCP_SO - UCP_LL);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TYPEREG, 0, SLJIT_IMM, UCP_ZS - UCP_LL);
      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);

      JUMP = CMP(SLJIT_NOT_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_CF - UCP_LL);

      /* IN CASE OF UCP_CF, WE OVERWRITE THE RESULT. */
      SET_CHAR_OFFSET(0X2066);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X2069 - 0X2066);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X061C - 0X2066);
      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);

      JUMPHERE(JUMP);
      JUMP = CMP(SLJIT_ZERO ^ INVERTCMP, TMP2, 0, SLJIT_IMM, 0);
      BREAK;

      CASE PT_PXPUNCT:
      SET_TYPE_OFFSET(UCP_SC);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_SO - UCP_SC);
      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);

      SET_CHAR_OFFSET(0);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X7F);
      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);

      SET_TYPE_OFFSET(UCP_PC);
      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TYPEREG, 0, SLJIT_IMM, UCP_PS - UCP_PC);
      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);
      JUMP = JUMP(SLJIT_NOT_ZERO ^ INVERTCMP);
      BREAK;

      DEFAULT:
      SLJIT_UNREACHABLE();
      BREAK;
      }
    CC += 2;
    }
#ENDIF /* SUPPORT_UNICODE */

  IF (JUMP != NULL)
    ADD_JUMP(COMPILER, COMPARES > 0 ? LIST : BACKTRACKS, JUMP);
  }

IF (FOUND != NULL)
  SET_JUMPS(FOUND, LABEL());
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200305_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PCX_WRITE_RLE(CONST BYTE * FROM, CONST BYTE * END, INT STEP, GP_FILE * FILE)
{				/*
                                 * THE PCX FORMAT THEORETICALLY ALLOWS ENCODING RUNS OF 63
                                 * IDENTICAL BYTES, BUT SOME READERS CAN'T HANDLE REPETITION
                                 * COUNTS GREATER THAN 15.
                                 */
#DEFINE MAX_RUN_COUNT 15
    INT MAX_RUN = STEP * MAX_RUN_COUNT;

    WHILE (FROM < END) {
        BYTE DATA = *FROM;

        FROM += STEP;
        IF (DATA != *FROM || FROM == END) {
            IF (DATA >= 0XC0)
                GP_FPUTC(0XC1, FILE);
        } ELSE {
            CONST BYTE *START = FROM;

            WHILE ((FROM < END) && (*FROM == DATA))
                FROM += STEP;
            /* NOW (FROM - START) / STEP + 1 IS THE RUN LENGTH. */
            WHILE (FROM - START >= MAX_RUN) {
                GP_FPUTC(0XC0 + MAX_RUN_COUNT, FILE);
                GP_FPUTC(DATA, FILE);
                START += MAX_RUN;
            }
            IF (FROM > START || DATA >= 0XC0)
                GP_FPUTC((FROM - START) / STEP + 0XC1, FILE);
        }
        GP_FPUTC(DATA, FILE);
    }
#UNDEF MAX_RUN_COUNT
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 382784_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GDIOCTX * GDNEWDYNAMICCTXEX (INT INITIALSIZE, VOID *DATA, INT FREEOKFLAG)
{
	DPIOCTX *CTX;
	DYNAMICPTR *DP;

	CTX = (DPIOCTX *) GDMALLOC (SIZEOF (DPIOCTX));

	DP = NEWDYNAMIC(INITIALSIZE, DATA, FREEOKFLAG);

	CTX->DP = DP;

	CTX->CTX.GETC = DYNAMICGETCHAR;
	CTX->CTX.PUTC = DYNAMICPUTCHAR;

	CTX->CTX.GETBUF = DYNAMICGETBUF;
	CTX->CTX.PUTBUF = DYNAMICPUTBUF;

	CTX->CTX.SEEK = DYNAMICSEEK;
	CTX->CTX.TELL = DYNAMICTELL;

	CTX->CTX.GD_FREE = GDFREEDYNAMICCTX;

	RETURN (GDIOCTX *) CTX;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 404726_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CLOSE_FD(UNSIGNED FD)
{
	STRUCT FILES_STRUCT *FILES = CURRENT->FILES;
	STRUCT FILE *FILE;

	FILE = PICK_FILE(FILES, FD);
	IF (IS_ERR(FILE))
		RETURN -EBADF;

	RETURN FILP_CLOSE(FILE, FILES);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 359415_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEFUN (CLEAR_IP_BGP_PEER_VPNV4_SOFT_IN,
       CLEAR_IP_BGP_PEER_VPNV4_SOFT_IN_CMD,
       "CLEAR IP BGP A.B.C.D VPNV4 UNICAST SOFT IN",
       CLEAR_STR
       IP_STR
       BGP_STR
       "BGP NEIGHBOR ADDRESS TO CLEAR\N"
       "ADDRESS FAMILY\N"
       "ADDRESS FAMILY MODIFIER\N"
       "SOFT RECONFIG\N"
       "SOFT RECONFIG INBOUND UPDATE\N")
{
  RETURN BGP_CLEAR_VTY (VTY, NULL, AFI_IP, SAFI_MPLS_VPN, CLEAR_PEER,
			BGP_CLEAR_SOFT_IN, ARGV[0]);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199159_CWE-362.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SND_PCM_OSS_SYNC(STRUCT SND_PCM_OSS_FILE *PCM_OSS_FILE)
{
	INT ERR = 0;
	UNSIGNED INT SAVED_F_FLAGS;
	STRUCT SND_PCM_SUBSTREAM *SUBSTREAM;
	STRUCT SND_PCM_RUNTIME *RUNTIME;
	SND_PCM_FORMAT_T FORMAT;
	UNSIGNED LONG WIDTH;
	SIZE_T SIZE;

	SUBSTREAM = PCM_OSS_FILE->STREAMS[SNDRV_PCM_STREAM_PLAYBACK];
	IF (SUBSTREAM != NULL) {
		RUNTIME = SUBSTREAM->RUNTIME;
		IF (ATOMIC_READ(&SUBSTREAM->MMAP_COUNT))
			GOTO __DIRECT;
		ERR = SND_PCM_OSS_MAKE_READY(SUBSTREAM);
		IF (ERR < 0)
			RETURN ERR;
		ATOMIC_INC(&RUNTIME->OSS.RW_REF);
		IF (MUTEX_LOCK_INTERRUPTIBLE(&RUNTIME->OSS.PARAMS_LOCK)) {
			ATOMIC_DEC(&RUNTIME->OSS.RW_REF);
			RETURN -ERESTARTSYS;
		}
		FORMAT = SND_PCM_OSS_FORMAT_FROM(RUNTIME->OSS.FORMAT);
		WIDTH = SND_PCM_FORMAT_PHYSICAL_WIDTH(FORMAT);
		IF (RUNTIME->OSS.BUFFER_USED > 0) {
#IFDEF OSS_DEBUG
			PCM_DBG(SUBSTREAM->PCM, "SYNC: BUFFER_USED\N");
#ENDIF
			SIZE = (8 * (RUNTIME->OSS.PERIOD_BYTES - RUNTIME->OSS.BUFFER_USED) + 7) / WIDTH;
			SND_PCM_FORMAT_SET_SILENCE(FORMAT,
						   RUNTIME->OSS.BUFFER + RUNTIME->OSS.BUFFER_USED,
						   SIZE);
			ERR = SND_PCM_OSS_SYNC1(SUBSTREAM, RUNTIME->OSS.PERIOD_BYTES);
			IF (ERR < 0)
				GOTO UNLOCK;
		} ELSE IF (RUNTIME->OSS.PERIOD_PTR > 0) {
#IFDEF OSS_DEBUG
			PCM_DBG(SUBSTREAM->PCM, "SYNC: PERIOD_PTR\N");
#ENDIF
			SIZE = RUNTIME->OSS.PERIOD_BYTES - RUNTIME->OSS.PERIOD_PTR;
			SND_PCM_FORMAT_SET_SILENCE(FORMAT,
						   RUNTIME->OSS.BUFFER,
						   SIZE * 8 / WIDTH);
			ERR = SND_PCM_OSS_SYNC1(SUBSTREAM, SIZE);
			IF (ERR < 0)
				GOTO UNLOCK;
		}
		/*
		 * THE ALSA'S PERIOD MIGHT BE A BIT LARGE THAN OSS ONE.
		 * FILL THE REMAIN PORTION OF ALSA PERIOD WITH ZEROS.
		 */
		SIZE = RUNTIME->CONTROL->APPL_PTR % RUNTIME->PERIOD_SIZE;
		IF (SIZE > 0) {
			SIZE = RUNTIME->PERIOD_SIZE - SIZE;
			IF (RUNTIME->ACCESS == SNDRV_PCM_ACCESS_RW_INTERLEAVED)
				SND_PCM_LIB_WRITE(SUBSTREAM, NULL, SIZE);
			ELSE IF (RUNTIME->ACCESS == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)
				SND_PCM_LIB_WRITEV(SUBSTREAM, NULL, SIZE);
		}
UNLOCK:
		MUTEX_UNLOCK(&RUNTIME->OSS.PARAMS_LOCK);
		ATOMIC_DEC(&RUNTIME->OSS.RW_REF);
		IF (ERR < 0)
			RETURN ERR;
		/*
		 * FINISH SYNC: DRAIN THE BUFFER
		 */
	      __DIRECT:
		SAVED_F_FLAGS = SUBSTREAM->F_FLAGS;
		SUBSTREAM->F_FLAGS &= ~O_NONBLOCK;
		ERR = SND_PCM_KERNEL_IOCTL(SUBSTREAM, SNDRV_PCM_IOCTL_DRAIN, NULL);
		SUBSTREAM->F_FLAGS = SAVED_F_FLAGS;
		IF (ERR < 0)
			RETURN ERR;
		MUTEX_LOCK(&RUNTIME->OSS.PARAMS_LOCK);
		RUNTIME->OSS.PREPARE = 1;
		MUTEX_UNLOCK(&RUNTIME->OSS.PARAMS_LOCK);
	}

	SUBSTREAM = PCM_OSS_FILE->STREAMS[SNDRV_PCM_STREAM_CAPTURE];
	IF (SUBSTREAM != NULL) {
		ERR = SND_PCM_OSS_MAKE_READY(SUBSTREAM);
		IF (ERR < 0)
			RETURN ERR;
		RUNTIME = SUBSTREAM->RUNTIME;
		ERR = SND_PCM_KERNEL_IOCTL(SUBSTREAM, SNDRV_PCM_IOCTL_DROP, NULL);
		IF (ERR < 0)
			RETURN ERR;
		MUTEX_LOCK(&RUNTIME->OSS.PARAMS_LOCK);
		RUNTIME->OSS.BUFFER_USED = 0;
		RUNTIME->OSS.PREPARE = 1;
		MUTEX_UNLOCK(&RUNTIME->OSS.PARAMS_LOCK);
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 244344_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR DOPS_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	GF_OPUSSPECIFICBOX *PTR = (GF_OPUSSPECIFICBOX *)S;
	PTR->OPCFG.VERSION = GF_BS_READ_U8(BS);
	IF (PTR->OPCFG.VERSION) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISOMEDIA] OPUS CONFIG VERSION NOT 0 !\N", PTR->SIZE));
		RETURN GF_NOT_SUPPORTED;
	}
	//FORCE VERSION TO 1 AS USED IN OGG/OPUS
	PTR->OPCFG.VERSION = 1;
	PTR->OPCFG.OUTPUTCHANNELCOUNT = GF_BS_READ_U8(BS);
	PTR->OPCFG.PRESKIP = GF_BS_READ_U16(BS);
	PTR->OPCFG.INPUTSAMPLERATE = GF_BS_READ_U32(BS);
	PTR->OPCFG.OUTPUTGAIN = GF_BS_READ_U16(BS);
	PTR->OPCFG.CHANNELMAPPINGFAMILY = GF_BS_READ_U8(BS);
	ISOM_DECREASE_SIZE(PTR, 11)
	IF (PTR->SIZE) {
		ISOM_DECREASE_SIZE(PTR, 2+PTR->OPCFG.OUTPUTCHANNELCOUNT);
		PTR->OPCFG.STREAMCOUNT = GF_BS_READ_U8(BS);
		PTR->OPCFG.COUPLEDCOUNT = GF_BS_READ_U8(BS);
		GF_BS_READ_DATA(BS, (CHAR *) PTR->OPCFG.CHANNELMAPPING, PTR->OPCFG.OUTPUTCHANNELCOUNT);
	}
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211473_CWE-189.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
READ_BITMAP_FILE_DATA (FILE    *FSTREAM,
		       GUINT   *WIDTH, 
		       GUINT   *HEIGHT,
		       GUCHAR **DATA,
		       INT     *X_HOT, 
		       INT     *Y_HOT)
{
	GUCHAR *BITS = NULL;		/* WORKING VARIABLE */
	CHAR LINE[MAX_SIZE];		/* INPUT LINE FROM FILE */
	INT SIZE;			/* NUMBER OF BYTES OF DATA */
	CHAR NAME_AND_TYPE[MAX_SIZE];	/* AN INPUT LINE */
	CHAR *TYPE;			/* FOR PARSING */
	INT VALUE;			/* FROM AN INPUT LINE */
	INT VERSION10P;			/* BOOLEAN, OLD FORMAT */
	INT PADDING;			/* TO HANDLE ALIGNMENT */
	INT BYTES_PER_LINE;		/* PER SCANLINE OF DATA */
	GUINT WW = 0;			/* WIDTH */
	GUINT HH = 0;			/* HEIGHT */
	INT HX = -1;			/* X HOTSPOT */
	INT HY = -1;			/* Y HOTSPOT */

	/* FIRST TIME INITIALIZATION */
	IF (!INITIALIZED) {
		INIT_HEX_TABLE ();
	}

	/* ERROR CLEANUP AND RETURN MACRO */
#DEFINE	RETURN(CODE) { G_FREE (BITS); RETURN CODE; }

	WHILE (FGETS (LINE, MAX_SIZE, FSTREAM)) {
		IF (STRLEN (LINE) == MAX_SIZE-1)
			RETURN (FALSE);
		IF (SSCANF (LINE,"#DEFINE %S %D",NAME_AND_TYPE,&VALUE) == 2) {
			IF (!(TYPE = STRRCHR (NAME_AND_TYPE, '_')))
				TYPE = NAME_AND_TYPE;
			ELSE {
				TYPE++;
			}

			IF (!STRCMP ("WIDTH", TYPE))
				WW = (UNSIGNED INT) VALUE;
			IF (!STRCMP ("HEIGHT", TYPE))
				HH = (UNSIGNED INT) VALUE;
			IF (!STRCMP ("HOT", TYPE)) {
				IF (TYPE-- == NAME_AND_TYPE
				    || TYPE-- == NAME_AND_TYPE)
					CONTINUE;
				IF (!STRCMP ("X_HOT", TYPE))
					HX = VALUE;
				IF (!STRCMP ("Y_HOT", TYPE))
					HY = VALUE;
			}
			CONTINUE;
		}
    
		IF (SSCANF (LINE, "STATIC SHORT %S = {", NAME_AND_TYPE) == 1)
			VERSION10P = 1;
		ELSE IF (SSCANF (LINE,"STATIC CONST UNSIGNED CHAR %S = {",NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE IF (SSCANF (LINE,"STATIC UNSIGNED CHAR %S = {",NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE IF (SSCANF (LINE, "STATIC CONST CHAR %S = {", NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE IF (SSCANF (LINE, "STATIC CHAR %S = {", NAME_AND_TYPE) == 1)
			VERSION10P = 0;
		ELSE
			CONTINUE;

		IF (!(TYPE = STRRCHR (NAME_AND_TYPE, '_')))
			TYPE = NAME_AND_TYPE;
		ELSE
			TYPE++;

		IF (STRCMP ("BITS[]", TYPE))
			CONTINUE;
    
		IF (!WW || !HH)
			RETURN (FALSE);

		IF ((WW % 16) && ((WW % 16) < 9) && VERSION10P)
			PADDING = 1;
		ELSE
			PADDING = 0;

		BYTES_PER_LINE = (WW+7)/8 + PADDING;

		SIZE = BYTES_PER_LINE * HH;
		BITS = G_MALLOC (SIZE);

		IF (VERSION10P) {
			UNSIGNED CHAR *PTR;
			INT BYTES;

			FOR (BYTES = 0, PTR = BITS; BYTES < SIZE; (BYTES += 2)) {
				IF ((VALUE = NEXT_INT (FSTREAM)) < 0)
					RETURN (FALSE);
				*(PTR++) = VALUE;
				IF (!PADDING || ((BYTES+2) % BYTES_PER_LINE))
					*(PTR++) = VALUE >> 8;
			}
		} ELSE {
			UNSIGNED CHAR *PTR;
			INT BYTES;

			FOR (BYTES = 0, PTR = BITS; BYTES < SIZE; BYTES++, PTR++) {
				IF ((VALUE = NEXT_INT (FSTREAM)) < 0) 
					RETURN (FALSE);
				*PTR=VALUE;
			}
		}
		BREAK;
	}

	IF (!BITS)
		RETURN (FALSE);

	*DATA = BITS;
	*WIDTH = WW;
	*HEIGHT = HH;
	IF (X_HOT)
		*X_HOT = HX;
	IF (Y_HOT)
		*Y_HOT = HY;

	RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 317355_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT SELINUX_SOCKET_GETPEERSEC_STREAM(STRUCT SOCKET *SOCK, CHAR __USER *OPTVAL,
					    INT __USER *OPTLEN, UNSIGNED LEN)
{
	INT ERR = 0;
	CHAR *SCONTEXT;
	U32 SCONTEXT_LEN;
	STRUCT SK_SECURITY_STRUCT *SKSEC = SOCK->SK->SK_SECURITY;
	U32 PEER_SID = SECSID_NULL;

	IF (SKSEC->SCLASS == SECCLASS_UNIX_STREAM_SOCKET ||
	    SKSEC->SCLASS == SECCLASS_TCP_SOCKET ||
	    SKSEC->SCLASS == SECCLASS_SCTP_SOCKET)
		PEER_SID = SKSEC->PEER_SID;
	IF (PEER_SID == SECSID_NULL)
		RETURN -ENOPROTOOPT;

	ERR = SECURITY_SID_TO_CONTEXT(&SELINUX_STATE, PEER_SID, &SCONTEXT,
				      &SCONTEXT_LEN);
	IF (ERR)
		RETURN ERR;

	IF (SCONTEXT_LEN > LEN) {
		ERR = -ERANGE;
		GOTO OUT_LEN;
	}

	IF (COPY_TO_USER(OPTVAL, SCONTEXT, SCONTEXT_LEN))
		ERR = -EFAULT;

OUT_LEN:
	IF (PUT_USER(SCONTEXT_LEN, OPTLEN))
		ERR = -EFAULT;
	KFREE(SCONTEXT);
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204544_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT EM28XX_USB_PROBE(STRUCT USB_INTERFACE *INTF,
			    CONST STRUCT USB_DEVICE_ID *ID)
{
	STRUCT USB_DEVICE *UDEV;
	STRUCT EM28XX *DEV = NULL;
	INT RETVAL;
	BOOL HAS_VENDOR_AUDIO = FALSE, HAS_VIDEO = FALSE, HAS_DVB = FALSE;
	INT I, NR, TRY_BULK;
	CONST INT IFNUM = INTF->ALTSETTING[0].DESC.BINTERFACENUMBER;
	CHAR *SPEED;

	UDEV = USB_GET_DEV(INTERFACE_TO_USBDEV(INTF));

	/* CHECK TO SEE NEXT FREE DEVICE AND MARK AS USED */
	DO {
		NR = FIND_FIRST_ZERO_BIT(EM28XX_DEVUSED, EM28XX_MAXBOARDS);
		IF (NR >= EM28XX_MAXBOARDS) {
			/* NO FREE DEVICE SLOTS */
			DEV_ERR(&INTF->DEV,
				"DRIVER SUPPORTS UP TO %I EM28XX BOARDS.\N",
			       EM28XX_MAXBOARDS);
			RETVAL = -ENOMEM;
			GOTO ERR_NO_SLOT;
		}
	} WHILE (TEST_AND_SET_BIT(NR, EM28XX_DEVUSED));

	/* DON'T REGISTER AUDIO INTERFACES */
	IF (INTF->ALTSETTING[0].DESC.BINTERFACECLASS == USB_CLASS_AUDIO) {
		DEV_INFO(&INTF->DEV,
			"AUDIO DEVICE (%04X:%04X): INTERFACE %I, CLASS %I\N",
			LE16_TO_CPU(UDEV->DESCRIPTOR.IDVENDOR),
			LE16_TO_CPU(UDEV->DESCRIPTOR.IDPRODUCT),
			IFNUM,
			INTF->ALTSETTING[0].DESC.BINTERFACECLASS);

		RETVAL = -ENODEV;
		GOTO ERR;
	}

	/* ALLOCATE MEMORY FOR OUR DEVICE STATE AND INITIALIZE IT */
	DEV = KZALLOC(SIZEOF(*DEV), GFP_KERNEL);
	IF (!DEV) {
		RETVAL = -ENOMEM;
		GOTO ERR;
	}

	/* COMPUTE ALTERNATE MAX PACKET SIZES */
	DEV->ALT_MAX_PKT_SIZE_ISOC = KCALLOC(INTF->NUM_ALTSETTING,
					     SIZEOF(DEV->ALT_MAX_PKT_SIZE_ISOC[0]),
					     GFP_KERNEL);
	IF (!DEV->ALT_MAX_PKT_SIZE_ISOC) {
		KFREE(DEV);
		RETVAL = -ENOMEM;
		GOTO ERR;
	}

	/* GET ENDPOINTS */
	FOR (I = 0; I < INTF->NUM_ALTSETTING; I++) {
		INT EP;

		FOR (EP = 0;
		     EP < INTF->ALTSETTING[I].DESC.BNUMENDPOINTS;
		     EP++)
			EM28XX_CHECK_USB_DESCRIPTOR(DEV, UDEV, INTF,
						    I, EP,
						    &HAS_VENDOR_AUDIO,
						    &HAS_VIDEO,
						    &HAS_DVB);
	}

	IF (!(HAS_VENDOR_AUDIO || HAS_VIDEO || HAS_DVB)) {
		RETVAL = -ENODEV;
		GOTO ERR_FREE;
	}

	SWITCH (UDEV->SPEED) {
	CASE USB_SPEED_LOW:
		SPEED = "1.5";
		BREAK;
	CASE USB_SPEED_UNKNOWN:
	CASE USB_SPEED_FULL:
		SPEED = "12";
		BREAK;
	CASE USB_SPEED_HIGH:
		SPEED = "480";
		BREAK;
	DEFAULT:
		SPEED = "UNKNOWN";
	}

	DEV_INFO(&INTF->DEV,
		"NEW DEVICE %S %S @ %S MBPS (%04X:%04X, INTERFACE %D, CLASS %D)\N",
		UDEV->MANUFACTURER ? UDEV->MANUFACTURER : "",
		UDEV->PRODUCT ? UDEV->PRODUCT : "",
		SPEED,
		LE16_TO_CPU(UDEV->DESCRIPTOR.IDVENDOR),
		LE16_TO_CPU(UDEV->DESCRIPTOR.IDPRODUCT),
		IFNUM,
		INTF->ALTSETTING->DESC.BINTERFACENUMBER);

	/*
	 * MAKE SURE WE HAVE 480 MBPS OF BANDWIDTH, OTHERWISE THINGS LIKE
	 * VIDEO STREAM WOULDN'T LIKELY WORK, SINCE 12 MBPS IS GENERALLY
	 * NOT ENOUGH EVEN FOR MOST DIGITAL TV STREAMS.
	 */
	IF (UDEV->SPEED != USB_SPEED_HIGH && DISABLE_USB_SPEED_CHECK == 0) {
		DEV_ERR(&INTF->DEV, "DEVICE INITIALIZATION FAILED.\N");
		DEV_ERR(&INTF->DEV,
			"DEVICE MUST BE CONNECTED TO A HIGH-SPEED USB 2.0 PORT.\N");
		RETVAL = -ENODEV;
		GOTO ERR_FREE;
	}

	DEV->DEVNO = NR;
	DEV->MODEL = ID->DRIVER_INFO;
	DEV->ALT   = -1;
	DEV->IS_AUDIO_ONLY = HAS_VENDOR_AUDIO && !(HAS_VIDEO || HAS_DVB);
	DEV->HAS_VIDEO = HAS_VIDEO;
	DEV->IFNUM = IFNUM;

	DEV->TS = PRIMARY_TS;
	SNPRINTF(DEV->NAME, 28, "EM28XX");
	DEV->DEV_NEXT = NULL;

	IF (HAS_VENDOR_AUDIO) {
		DEV_INFO(&INTF->DEV,
			"AUDIO INTERFACE %I FOUND (VENDOR CLASS)\N", IFNUM);
		DEV->USB_AUDIO_TYPE = EM28XX_USB_AUDIO_VENDOR;
	}
	/* CHECKS IF AUDIO IS PROVIDED BY A USB AUDIO CLASS INTF */
	FOR (I = 0; I < UDEV->CONFIG->DESC.BNUMINTERFACES; I++) {
		STRUCT USB_INTERFACE *UIF = UDEV->CONFIG->INTERFACE[I];

		IF (UIF->ALTSETTING[0].DESC.BINTERFACECLASS == USB_CLASS_AUDIO) {
			IF (HAS_VENDOR_AUDIO)
				DEV_ERR(&INTF->DEV,
					"EM28XX: DEVICE SEEMS TO HAVE VENDOR AND USB AUDIO CLASS INTERFACES !\N"
					"\T\TTHE VENDOR INTERFACE WILL BE IGNORED. PLEASE CONTACT THE DEVELOPERS <LINUX-MEDIA@VGER.KERNEL.ORG>\N");
			DEV->USB_AUDIO_TYPE = EM28XX_USB_AUDIO_CLASS;
			BREAK;
		}
	}

	IF (HAS_VIDEO)
		DEV_INFO(&INTF->DEV, "VIDEO INTERFACE %I FOUND:%S%S\N",
			IFNUM,
			DEV->ANALOG_EP_BULK ? " BULK" : "",
			DEV->ANALOG_EP_ISOC ? " ISOC" : "");
	IF (HAS_DVB)
		DEV_INFO(&INTF->DEV, "DVB INTERFACE %I FOUND:%S%S\N",
			IFNUM,
			DEV->DVB_EP_BULK ? " BULK" : "",
			DEV->DVB_EP_ISOC ? " ISOC" : "");

	DEV->NUM_ALT = INTF->NUM_ALTSETTING;

	IF ((UNSIGNED INT)CARD[NR] < EM28XX_BCOUNT)
		DEV->MODEL = CARD[NR];

	/* SAVE OUR DATA POINTER IN THIS INTF DEVICE */
	USB_SET_INTFDATA(INTF, DEV);

	/* ALLOCATE DEVICE STRUCT AND CHECK IF THE DEVICE IS A WEBCAM */
	MUTEX_INIT(&DEV->LOCK);
	RETVAL = EM28XX_INIT_DEV(DEV, UDEV, INTF, NR);
	IF (RETVAL)
		GOTO ERR_FREE;

	IF (USB_XFER_MODE < 0) {
		IF (DEV->IS_WEBCAM)
			TRY_BULK = 1;
		ELSE
			TRY_BULK = 0;
	} ELSE {
		TRY_BULK = USB_XFER_MODE > 0;
	}

	/* DISABLE V4L2 IF THE DEVICE DOESN'T HAVE A DECODER OR IMAGE SENSOR */
	IF (HAS_VIDEO &&
	    DEV->BOARD.DECODER == EM28XX_NODECODER &&
	    DEV->EM28XX_SENSOR == EM28XX_NOSENSOR) {
		DEV_ERR(&INTF->DEV,
			"CURRENTLY, V4L2 IS NOT SUPPORTED ON THIS MODEL\N");
		HAS_VIDEO = FALSE;
		DEV->HAS_VIDEO = FALSE;
	}

	IF (DEV->BOARD.HAS_DUAL_TS &&
	    (DEV->TUNER_TYPE != TUNER_ABSENT || INPUT(0)->TYPE)) {
		/*
		 * THE LOGIC WITH SETS ALTERNATE IS NOT READY FOR DUAL-TUNERS
		 * WHICH ANALOG MODES.
		 */
		DEV_ERR(&INTF->DEV,
			"WE CURRENTLY DON'T SUPPORT ANALOG TV OR STREAM CAPTURE ON DUAL TUNERS.\N");
		HAS_VIDEO = FALSE;
	}

	/* SELECT USB TRANSFER TYPES TO USE */
	IF (HAS_VIDEO) {
		IF (!DEV->ANALOG_EP_ISOC || (TRY_BULK && DEV->ANALOG_EP_BULK))
			DEV->ANALOG_XFER_BULK = 1;
		DEV_INFO(&INTF->DEV, "ANALOG SET TO %S MODE.\N",
			DEV->ANALOG_XFER_BULK ? "BULK" : "ISOC");
	}
	IF (HAS_DVB) {
		IF (!DEV->DVB_EP_ISOC || (TRY_BULK && DEV->DVB_EP_BULK))
			DEV->DVB_XFER_BULK = 1;
		DEV_INFO(&INTF->DEV, "DVB SET TO %S MODE.\N",
			DEV->DVB_XFER_BULK ? "BULK" : "ISOC");
	}

	IF (DEV->BOARD.HAS_DUAL_TS && EM28XX_DUPLICATE_DEV(DEV) == 0) {
		DEV->DEV_NEXT->TS = SECONDARY_TS;
		DEV->DEV_NEXT->ALT   = -1;
		DEV->DEV_NEXT->IS_AUDIO_ONLY = HAS_VENDOR_AUDIO &&
						!(HAS_VIDEO || HAS_DVB);
		DEV->DEV_NEXT->HAS_VIDEO = FALSE;
		DEV->DEV_NEXT->IFNUM = IFNUM;
		DEV->DEV_NEXT->MODEL = ID->DRIVER_INFO;

		MUTEX_INIT(&DEV->DEV_NEXT->LOCK);
		RETVAL = EM28XX_INIT_DEV(DEV->DEV_NEXT, UDEV, INTF,
					 DEV->DEV_NEXT->DEVNO);
		IF (RETVAL)
			GOTO ERR_FREE;

		DEV->DEV_NEXT->BOARD.IR_CODES = NULL; /* NO IR FOR 2ND TUNER */
		DEV->DEV_NEXT->BOARD.HAS_IR_I2C = 0; /* NO IR FOR 2ND TUNER */

		IF (USB_XFER_MODE < 0) {
			IF (DEV->DEV_NEXT->IS_WEBCAM)
				TRY_BULK = 1;
			ELSE
				TRY_BULK = 0;
		} ELSE {
			TRY_BULK = USB_XFER_MODE > 0;
		}

		/* SELECT USB TRANSFER TYPES TO USE */
		IF (HAS_DVB) {
			IF (!DEV->DVB_EP_ISOC_TS2 ||
			    (TRY_BULK && DEV->DVB_EP_BULK_TS2))
				DEV->DEV_NEXT->DVB_XFER_BULK = 1;
			DEV_INFO(&DEV->INTF->DEV, "DVB TS2 SET TO %S MODE.\N",
				 DEV->DEV_NEXT->DVB_XFER_BULK ? "BULK" : "ISOC");
		}

		DEV->DEV_NEXT->DVB_EP_ISOC = DEV->DVB_EP_ISOC_TS2;
		DEV->DEV_NEXT->DVB_EP_BULK = DEV->DVB_EP_BULK_TS2;
		DEV->DEV_NEXT->DVB_MAX_PKT_SIZE_ISOC = DEV->DVB_MAX_PKT_SIZE_ISOC_TS2;
		DEV->DEV_NEXT->DVB_ALT_ISOC = DEV->DVB_ALT_ISOC;

		/* CONFIGURE HARDWARE TO SUPPORT TS2*/
		IF (DEV->DVB_XFER_BULK) {
			/* THE EP4 AND EP5 ARE CONFIGURED FOR BULK */
			EM28XX_WRITE_REG(DEV, 0X0B, 0X96);
			MDELAY(100);
			EM28XX_WRITE_REG(DEV, 0X0B, 0X80);
			MDELAY(100);
		} ELSE {
			/* THE EP4 AND EP5 ARE CONFIGURED FOR ISO */
			EM28XX_WRITE_REG(DEV, 0X0B, 0X96);
			MDELAY(100);
			EM28XX_WRITE_REG(DEV, 0X0B, 0X82);
			MDELAY(100);
		}

		KREF_INIT(&DEV->DEV_NEXT->REF);
	}

	KREF_INIT(&DEV->REF);

	REQUEST_MODULES(DEV);

	/*
	 * DO IT AT THE END, TO REDUCE DYNAMIC CONFIGURATION CHANGES DURING
	 * THE DEVICE INIT. YET, AS REQUEST_MODULES() CAN BE ASYNC, THE
	 * TOPOLOGY WILL LIKELY CHANGE AFTER THE LOAD OF THE EM28XX SUBDRIVERS.
	 */
#IFDEF CONFIG_MEDIA_CONTROLLER
	RETVAL = MEDIA_DEVICE_REGISTER(DEV->MEDIA_DEV);
#ENDIF

	RETURN 0;

ERR_FREE:
	KFREE(DEV->ALT_MAX_PKT_SIZE_ISOC);
	KFREE(DEV);

ERR:
	CLEAR_BIT(NR, EM28XX_DEVUSED);

ERR_NO_SLOT:
	USB_PUT_DEV(UDEV);
	RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211700_CWE-120.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT ST21NFCA_CONNECTIVITY_EVENT_RECEIVED(STRUCT NFC_HCI_DEV *HDEV, U8 HOST,
				U8 EVENT, STRUCT SK_BUFF *SKB)
{
	INT R = 0;
	STRUCT DEVICE *DEV = &HDEV->NDEV->DEV;
	STRUCT NFC_EVT_TRANSACTION *TRANSACTION;

	PR_DEBUG("CONNECTIVITY GATE EVENT: %X\N", EVENT);

	SWITCH (EVENT) {
	CASE ST21NFCA_EVT_CONNECTIVITY:
		R = NFC_SE_CONNECTIVITY(HDEV->NDEV, HOST);
	BREAK;
	CASE ST21NFCA_EVT_TRANSACTION:
		/*
		 * ACCORDING TO SPECIFICATION ETSI 102 622
		 * 11.2.2.4 EVT_TRANSACTION TABLE 52
		 * DESCRIPTION	TAG	LENGTH
		 * AID		81	5 TO 16
		 * PARAMETERS	82	0 TO 255
		 */
		IF (SKB->LEN < NFC_MIN_AID_LENGTH + 2 &&
		    SKB->DATA[0] != NFC_EVT_TRANSACTION_AID_TAG)
			RETURN -EPROTO;

		TRANSACTION = DEVM_KZALLOC(DEV, SKB->LEN - 2, GFP_KERNEL);
		IF (!TRANSACTION)
			RETURN -ENOMEM;

		TRANSACTION->AID_LEN = SKB->DATA[1];
		MEMCPY(TRANSACTION->AID, &SKB->DATA[2],
		       TRANSACTION->AID_LEN);

		/* CHECK NEXT BYTE IS PARAMETERS TAG (82) */
		IF (SKB->DATA[TRANSACTION->AID_LEN + 2] !=
		    NFC_EVT_TRANSACTION_PARAMS_TAG)
			RETURN -EPROTO;

		TRANSACTION->PARAMS_LEN = SKB->DATA[TRANSACTION->AID_LEN + 3];
		MEMCPY(TRANSACTION->PARAMS, SKB->DATA +
		       TRANSACTION->AID_LEN + 4, TRANSACTION->PARAMS_LEN);

		R = NFC_SE_TRANSACTION(HDEV->NDEV, HOST, TRANSACTION);
	BREAK;
	DEFAULT:
		NFC_ERR(&HDEV->NDEV->DEV, "UNEXPECTED EVENT ON CONNECTIVITY GATE\N");
		RETURN 1;
	}
	KFREE_SKB(SKB);
	RETURN R;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 468381_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
G_SOCKET_CLIENT_INIT (GSOCKETCLIENT *CLIENT)
{
  CLIENT->PRIV = G_SOCKET_CLIENT_GET_INSTANCE_PRIVATE (CLIENT);
  CLIENT->PRIV->TYPE = G_SOCKET_TYPE_STREAM;
  CLIENT->PRIV->APP_PROXIES = G_HASH_TABLE_NEW_FULL (G_STR_HASH,
						     G_STR_EQUAL,
						     G_FREE,
						     NULL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195801_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
 */
STATIC VOID PHP_WDDX_POP_ELEMENT(VOID *USER_DATA, CONST XML_CHAR *NAME)
{
	ST_ENTRY 			*ENT1, *ENT2;
	WDDX_STACK 			*STACK = (WDDX_STACK *)USER_DATA;
	HASHTABLE 			*TARGET_HASH;
	ZEND_CLASS_ENTRY 	*PCE;
	ZVAL				OBJ;

/* OBJECTS_FIXME */
	IF (STACK->TOP == 0) {
		RETURN;
	}

	IF (!STRCMP((CHAR *)NAME, EL_STRING) || !STRCMP((CHAR *)NAME, EL_NUMBER) ||
		!STRCMP((CHAR *)NAME, EL_BOOLEAN) || !STRCMP((CHAR *)NAME, EL_NULL) ||
	  	!STRCMP((CHAR *)NAME, EL_ARRAY) || !STRCMP((CHAR *)NAME, EL_STRUCT) ||
		!STRCMP((CHAR *)NAME, EL_RECORDSET) || !STRCMP((CHAR *)NAME, EL_BINARY) ||
		!STRCMP((CHAR *)NAME, EL_DATETIME)) {
		WDDX_STACK_TOP(STACK, (VOID**)&ENT1);

		IF (Z_TYPE(ENT1->DATA) == IS_UNDEF) {
			IF (STACK->TOP > 1) {
				STACK->TOP--;
			} ELSE {
				STACK->DONE = 1;
			}
			EFREE(ENT1);
			RETURN;
		}

		IF (!STRCMP((CHAR *)NAME, EL_BINARY)) {
			ZEND_STRING *NEW_STR = PHP_BASE64_DECODE(
				(UNSIGNED CHAR *)Z_STRVAL(ENT1->DATA), Z_STRLEN(ENT1->DATA));
			ZVAL_PTR_DTOR(&ENT1->DATA);
			ZVAL_STR(&ENT1->DATA, NEW_STR);
		}

		/* CALL __WAKEUP() METHOD ON THE OBJECT. */
		IF (Z_TYPE(ENT1->DATA) == IS_OBJECT) {
			ZVAL FNAME, RETVAL;

			ZVAL_STRING(&FNAME, "__WAKEUP");

			CALL_USER_FUNCTION_EX(NULL, &ENT1->DATA, &FNAME, &RETVAL, 0, 0, 0, NULL);

			ZVAL_PTR_DTOR(&FNAME);
			ZVAL_PTR_DTOR(&RETVAL);
		}

		IF (STACK->TOP > 1) {
			STACK->TOP--;
			WDDX_STACK_TOP(STACK, (VOID**)&ENT2);

			/* IF NON-EXISTENT FIELD */
			IF (ENT2->TYPE == ST_FIELD && Z_ISUNDEF(ENT2->DATA)) {
				ZVAL_PTR_DTOR(&ENT1->DATA);
				EFREE(ENT1);
				RETURN;
			}

			IF (Z_TYPE(ENT2->DATA) == IS_ARRAY || Z_TYPE(ENT2->DATA) == IS_OBJECT) {
				TARGET_HASH = HASH_OF(&ENT2->DATA);

				IF (ENT1->VARNAME) {
					IF (!STRCMP(ENT1->VARNAME, PHP_CLASS_NAME_VAR) &&
						Z_TYPE(ENT1->DATA) == IS_STRING && Z_STRLEN(ENT1->DATA) &&
						ENT2->TYPE == ST_STRUCT && Z_TYPE(ENT2->DATA) == IS_ARRAY) {
						ZEND_BOOL INCOMPLETE_CLASS = 0;

						ZEND_STR_TOLOWER(Z_STRVAL(ENT1->DATA), Z_STRLEN(ENT1->DATA));
						ZEND_STRING_FORGET_HASH_VAL(Z_STR(ENT1->DATA));
						IF ((PCE = ZEND_HASH_FIND_PTR(EG(CLASS_TABLE), Z_STR(ENT1->DATA))) == NULL) {
							INCOMPLETE_CLASS = 1;
							PCE = PHP_IC_ENTRY;
						}

						/* INITIALIZE TARGET OBJECT */
						OBJECT_INIT_EX(&OBJ, PCE);

						/* MERGE CURRENT HASHTABLE WITH OBJECT'S DEFAULT PROPERTIES */
						ZEND_HASH_MERGE(Z_OBJPROP(OBJ),
										Z_ARRVAL(ENT2->DATA),
										ZVAL_ADD_REF, 0);

						IF (INCOMPLETE_CLASS) {
							PHP_STORE_CLASS_NAME(&OBJ, Z_STRVAL(ENT1->DATA), Z_STRLEN(ENT1->DATA));
						}

						/* CLEAN UP OLD ARRAY ENTRY */
						ZVAL_PTR_DTOR(&ENT2->DATA);

						/* SET STACK ENTRY TO POINT TO THE NEWLY CREATED OBJECT */
						ZVAL_COPY_VALUE(&ENT2->DATA, &OBJ);

						/* CLEAN UP CLASS NAME VAR ENTRY */
						ZVAL_PTR_DTOR(&ENT1->DATA);
					} ELSE IF (Z_TYPE(ENT2->DATA) == IS_OBJECT) {
						ZEND_CLASS_ENTRY *OLD_SCOPE = EG(SCOPE);

						EG(SCOPE) = Z_OBJCE(ENT2->DATA);
						ADD_PROPERTY_ZVAL(&ENT2->DATA, ENT1->VARNAME, &ENT1->DATA);
						IF Z_REFCOUNTED(ENT1->DATA) Z_DELREF(ENT1->DATA);
						EG(SCOPE) = OLD_SCOPE;
					} ELSE {
						ZEND_SYMTABLE_STR_UPDATE(TARGET_HASH, ENT1->VARNAME, STRLEN(ENT1->VARNAME), &ENT1->DATA);
					}
					EFREE(ENT1->VARNAME);
				} ELSE	{
					ZEND_HASH_NEXT_INDEX_INSERT(TARGET_HASH, &ENT1->DATA);
				}
			}
			EFREE(ENT1);
		} ELSE {
			STACK->DONE = 1;
		}
	} ELSE IF (!STRCMP((CHAR *)NAME, EL_VAR) && STACK->VARNAME) {
		EFREE(STACK->VARNAME);
		STACK->VARNAME = NULL;
	} ELSE IF (!STRCMP((CHAR *)NAME, EL_FIELD)) {
		ST_ENTRY *ENT;
		WDDX_STACK_TOP(STACK, (VOID **)&ENT);
		EFREE(ENT);
		STACK->TOP--;
	}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 389739_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CHECK_FOR_CHAN_OR_JOB_ARG(TYPVAL_T *ARGS, INT IDX)
{
    IF (ARGS[IDX].V_TYPE != VAR_CHANNEL && ARGS[IDX].V_TYPE != VAR_JOB)
    {
	SEMSG(_(E_CHAN_OR_JOB_REQUIRED_FOR_ARGUMENT_NR), IDX + 1);
	RETURN FAIL;
    }
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 285158_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RLIST *R_BIN_NE_GET_SYMBOLS(R_BIN_NE_OBJ_T *BIN) {
	RBINSYMBOL *SYM;
	UT16 OFF = BIN->NE_HEADER->RESIDNAMTABLE + BIN->HEADER_OFFSET;
	RLIST *SYMBOLS = R_LIST_NEWF (FREE);
	IF (!SYMBOLS) {
		RETURN NULL;
	}
	RLIST *ENTRIES = R_BIN_NE_GET_ENTRYPOINTS (BIN);
	BOOL RESIDENT = TRUE, FIRST = TRUE;
	WHILE (ENTRIES) {
		UT8 SZ = R_BUF_READ8_AT (BIN->BUF, OFF);
		IF (!SZ) {
			FIRST = TRUE;
			IF (RESIDENT) {
				RESIDENT = FALSE;
				OFF = BIN->NE_HEADER->OFFSTARTNONRESTAB;
				SZ = R_BUF_READ8_AT (BIN->BUF, OFF);
				IF (!SZ) {
					BREAK;
				}
			} ELSE {
				BREAK;
			}
		}
		CHAR *NAME = MALLOC ((UT64)SZ + 1);
		IF (!NAME) {
			BREAK;
		}
		OFF++;
		R_BUF_READ_AT (BIN->BUF, OFF, (UT8 *)NAME, SZ);
		NAME[SZ] = '\0';
		OFF += SZ;
		SYM = R_NEW0 (RBINSYMBOL);
		IF (!SYM) {
			BREAK;
		}
		SYM->NAME = NAME;
		IF (!FIRST) {
			SYM->BIND = R_BIN_BIND_GLOBAL_STR;
		}
		UT16 ENTRY_OFF = R_BUF_READ_LE16_AT (BIN->BUF, OFF);
		OFF += 2;
		RBINADDR *ENTRY = R_LIST_GET_N (ENTRIES, ENTRY_OFF);
		IF (ENTRY) {
			SYM->PADDR = ENTRY->PADDR;
		} ELSE {
			SYM->PADDR = -1;
		}
		SYM->ORDINAL = ENTRY_OFF;
		R_LIST_APPEND (SYMBOLS, SYM);
		FIRST = FALSE;
	}
	RLISTITER *IT;
	RBINADDR *EN;
	INT I = 1;
	R_LIST_FOREACH (ENTRIES, IT, EN) {
		IF (!R_LIST_FIND (SYMBOLS, &EN->PADDR, __FIND_SYMBOL_BY_PADDR)) {
			SYM = R_NEW0 (RBINSYMBOL);
			IF (!SYM) {
				BREAK;
			}
			SYM->NAME = R_STR_NEWF ("ENTRY%D", I - 1);
			SYM->PADDR = EN->PADDR;
			SYM->BIND = R_BIN_BIND_GLOBAL_STR;
			SYM->ORDINAL = I;
			R_LIST_APPEND (SYMBOLS, SYM);
		}
		I++;
	}
	BIN->SYMBOLS = SYMBOLS;
	RETURN SYMBOLS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 253610_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FILL_TRANSFORM_HDR(STRUCT SMB2_TRANSFORM_HDR *TR_HDR, UNSIGNED INT ORIG_LEN,
		   STRUCT SMB_RQST *OLD_RQ, __LE16 CIPHER_TYPE)
{
	STRUCT SMB2_HDR *SHDR =
			(STRUCT SMB2_HDR *)OLD_RQ->RQ_IOV[0].IOV_BASE;

	MEMSET(TR_HDR, 0, SIZEOF(STRUCT SMB2_TRANSFORM_HDR));
	TR_HDR->PROTOCOLID = SMB2_TRANSFORM_PROTO_NUM;
	TR_HDR->ORIGINALMESSAGESIZE = CPU_TO_LE32(ORIG_LEN);
	TR_HDR->FLAGS = CPU_TO_LE16(0X01);
	IF ((CIPHER_TYPE == SMB2_ENCRYPTION_AES128_GCM) ||
	    (CIPHER_TYPE == SMB2_ENCRYPTION_AES256_GCM))
		GET_RANDOM_BYTES(&TR_HDR->NONCE, SMB3_AES_GCM_NONCE);
	ELSE
		GET_RANDOM_BYTES(&TR_HDR->NONCE, SMB3_AES_CCM_NONCE);
	MEMCPY(&TR_HDR->SESSIONID, &SHDR->SESSIONID, 8);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216654_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
AUTH_REQUEST_GET_VAR_EXPAND_TABLE_FULL(CONST STRUCT AUTH_REQUEST *AUTH_REQUEST,
				       AUTH_REQUEST_ESCAPE_FUNC_T *ESCAPE_FUNC,
				       UNSIGNED INT *COUNT)
{
	CONST UNSIGNED INT AUTH_COUNT =
		N_ELEMENTS(AUTH_REQUEST_VAR_EXPAND_STATIC_TAB);
	STRUCT VAR_EXPAND_TABLE *TAB, *RET_TAB;
	CONST CHAR *ORIG_USER, *AUTH_USER;

	IF (ESCAPE_FUNC == NULL)
		ESCAPE_FUNC = ESCAPE_NONE;

	/* KEEP THE EXTRA FIELDS AT THE BEGINNING. THE LAST STATIC_TAB FIELD
	   CONTAINS THE ENDING NULL-FIELDS. */
	TAB = RET_TAB = T_MALLOC((*COUNT + AUTH_COUNT) * SIZEOF(*TAB));
	MEMSET(TAB, 0, *COUNT * SIZEOF(*TAB));
	TAB += *COUNT;
	*COUNT += AUTH_COUNT;

	MEMCPY(TAB, AUTH_REQUEST_VAR_EXPAND_STATIC_TAB,
	       AUTH_COUNT * SIZEOF(*TAB));

	TAB[0].VALUE = ESCAPE_FUNC(AUTH_REQUEST->USER, AUTH_REQUEST);
	TAB[1].VALUE = ESCAPE_FUNC(T_STRCUT(AUTH_REQUEST->USER, '@'),
				   AUTH_REQUEST);
	TAB[2].VALUE = STRCHR(AUTH_REQUEST->USER, '@');
	IF (TAB[2].VALUE != NULL)
		TAB[2].VALUE = ESCAPE_FUNC(TAB[2].VALUE+1, AUTH_REQUEST);
	TAB[3].VALUE = ESCAPE_FUNC(AUTH_REQUEST->SERVICE, AUTH_REQUEST);
	/* TAB[4] = WE HAVE NO HOME DIR */
	IF (AUTH_REQUEST->LOCAL_IP.FAMILY != 0)
		TAB[5].VALUE = NET_IP2ADDR(&AUTH_REQUEST->LOCAL_IP);
	IF (AUTH_REQUEST->REMOTE_IP.FAMILY != 0)
		TAB[6].VALUE = NET_IP2ADDR(&AUTH_REQUEST->REMOTE_IP);
	TAB[7].VALUE = DEC2STR(AUTH_REQUEST->CLIENT_PID);
	IF (AUTH_REQUEST->MECH_PASSWORD != NULL) {
		TAB[8].VALUE = ESCAPE_FUNC(AUTH_REQUEST->MECH_PASSWORD,
					   AUTH_REQUEST);
	}
	IF (AUTH_REQUEST->USERDB_LOOKUP) {
		TAB[9].VALUE = AUTH_REQUEST->USERDB == NULL ? "" :
			DEC2STR(AUTH_REQUEST->USERDB->USERDB->ID);
	} ELSE {
		TAB[9].VALUE = AUTH_REQUEST->PASSDB == NULL ? "" :
			DEC2STR(AUTH_REQUEST->PASSDB->PASSDB->ID);
	}
	TAB[10].VALUE = AUTH_REQUEST->MECH_NAME == NULL ? "" :
		ESCAPE_FUNC(AUTH_REQUEST->MECH_NAME, AUTH_REQUEST);
	TAB[11].VALUE = AUTH_REQUEST->SECURED ? "SECURED" : "";
	TAB[12].VALUE = DEC2STR(AUTH_REQUEST->LOCAL_PORT);
	TAB[13].VALUE = DEC2STR(AUTH_REQUEST->REMOTE_PORT);
	TAB[14].VALUE = AUTH_REQUEST->VALID_CLIENT_CERT ? "VALID" : "";

	IF (AUTH_REQUEST->REQUESTED_LOGIN_USER != NULL) {
		CONST CHAR *LOGIN_USER = AUTH_REQUEST->REQUESTED_LOGIN_USER;

		TAB[15].VALUE = ESCAPE_FUNC(LOGIN_USER, AUTH_REQUEST);
		TAB[16].VALUE = ESCAPE_FUNC(T_STRCUT(LOGIN_USER, '@'),
					    AUTH_REQUEST);
		TAB[17].VALUE = STRCHR(LOGIN_USER, '@');
		IF (TAB[17].VALUE != NULL) {
			TAB[17].VALUE = ESCAPE_FUNC(TAB[17].VALUE+1,
						    AUTH_REQUEST);
		}
	}
	TAB[18].VALUE = AUTH_REQUEST->SESSION_ID == NULL ? NULL :
		ESCAPE_FUNC(AUTH_REQUEST->SESSION_ID, AUTH_REQUEST);
	IF (AUTH_REQUEST->REAL_LOCAL_IP.FAMILY != 0)
		TAB[19].VALUE = NET_IP2ADDR(&AUTH_REQUEST->REAL_LOCAL_IP);
	IF (AUTH_REQUEST->REAL_REMOTE_IP.FAMILY != 0)
		TAB[20].VALUE = NET_IP2ADDR(&AUTH_REQUEST->REAL_REMOTE_IP);
	TAB[21].VALUE = DEC2STR(AUTH_REQUEST->REAL_LOCAL_PORT);
	TAB[22].VALUE = DEC2STR(AUTH_REQUEST->REAL_REMOTE_PORT);
	TAB[23].VALUE = STRCHR(AUTH_REQUEST->USER, '@');
	IF (TAB[23].VALUE != NULL) {
		TAB[23].VALUE = ESCAPE_FUNC(T_STRCUT(TAB[23].VALUE+1, '@'),
					    AUTH_REQUEST);
	}
	TAB[24].VALUE = STRRCHR(AUTH_REQUEST->USER, '@');
	IF (TAB[24].VALUE != NULL)
		TAB[24].VALUE = ESCAPE_FUNC(TAB[24].VALUE+1, AUTH_REQUEST);
	TAB[25].VALUE = AUTH_REQUEST->MASTER_USER == NULL ? NULL :
		ESCAPE_FUNC(AUTH_REQUEST->MASTER_USER, AUTH_REQUEST);
	TAB[26].VALUE = AUTH_REQUEST->SESSION_PID == (PID_T)-1 ? NULL :
		DEC2STR(AUTH_REQUEST->SESSION_PID);

	ORIG_USER = AUTH_REQUEST->ORIGINAL_USERNAME != NULL ?
		AUTH_REQUEST->ORIGINAL_USERNAME : AUTH_REQUEST->USER;
	TAB[27].VALUE = ESCAPE_FUNC(ORIG_USER, AUTH_REQUEST);
	TAB[28].VALUE = ESCAPE_FUNC(T_STRCUT(ORIG_USER, '@'), AUTH_REQUEST);
	TAB[29].VALUE = STRCHR(ORIG_USER, '@');
	IF (TAB[29].VALUE != NULL)
		TAB[29].VALUE = ESCAPE_FUNC(TAB[29].VALUE+1, AUTH_REQUEST);

	IF (AUTH_REQUEST->MASTER_USER != NULL)
		AUTH_USER = AUTH_REQUEST->MASTER_USER;
	ELSE
		AUTH_USER = ORIG_USER;
	TAB[30].VALUE = ESCAPE_FUNC(AUTH_USER, AUTH_REQUEST);
	TAB[31].VALUE = ESCAPE_FUNC(T_STRCUT(AUTH_USER, '@'), AUTH_REQUEST);
	TAB[32].VALUE = STRCHR(AUTH_USER, '@');
	IF (TAB[32].VALUE != NULL)
		TAB[32].VALUE = ESCAPE_FUNC(TAB[32].VALUE+1, AUTH_REQUEST);
	IF (AUTH_REQUEST->LOCAL_NAME != NULL)
		TAB[33].VALUE = ESCAPE_FUNC(AUTH_REQUEST->LOCAL_NAME, AUTH_REQUEST);
	ELSE
		TAB[33].VALUE = "";
	RETURN RET_TAB;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196801_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR GF_HINTER_FINALIZE(GF_ISOFILE *FILE, GF_SDP_IODPROFILE IOD_PROFILE, U32 BANDWIDTH)
{
	U32 I, SCENET, ODT, DESCINDEX, SIZE, SIZE64;
	GF_INITIALOBJECTDESCRIPTOR *IOD;
	GF_SLCONFIG SLC;
	GF_ISOSAMPLE *SAMP;
	BOOL REMOVE_OCR;
	U8 *BUFFER;
	CHAR BUF64[5000], SDPLINE[5100];


	GF_ISOM_SDP_CLEAN(FILE);

	IF (BANDWIDTH) {
		SPRINTF(BUF64, "B=AS:%D", BANDWIDTH);
		GF_ISOM_SDP_ADD_LINE(FILE, BUF64);
	}
    //XTENDED ATTRIBUTE FOR COPYRIGHT
    IF (GF_SYS_IS_TEST_MODE()) {
        SPRINTF(BUF64, "A=X-COPYRIGHT: %S", "MP4/3GP FILE HINTED WITH GPAC - (C) TELECOM PARISTECH (HTTP://GPAC.IO)");
    } ELSE {
        SPRINTF(BUF64, "A=X-COPYRIGHT: MP4/3GP FILE HINTED WITH GPAC %S - %S", GF_GPAC_VERSION(), GF_GPAC_COPYRIGHT() );
    }
	GF_ISOM_SDP_ADD_LINE(FILE, BUF64);

	IF (IOD_PROFILE == GF_SDP_IOD_NONE) RETURN GF_OK;

	ODT = SCENET = 0;
	FOR (I=0; I<GF_ISOM_GET_TRACK_COUNT(FILE); I++) {
		IF (!GF_ISOM_IS_TRACK_IN_ROOT_OD(FILE, I+1)) CONTINUE;
		SWITCH (GF_ISOM_GET_MEDIA_TYPE(FILE,I+1)) {
		CASE GF_ISOM_MEDIA_OD:
			ODT = I+1;
			BREAK;
		CASE GF_ISOM_MEDIA_SCENE:
			SCENET = I+1;
			BREAK;
		}
	}
	REMOVE_OCR = 0;
	IF (IOD_PROFILE == GF_SDP_IOD_ISMA_STRICT) {
		IOD_PROFILE = GF_SDP_IOD_ISMA;
		REMOVE_OCR = 1;
	}

	/*IF WE WANT ISMA LIKE IODS, WE NEED AT LEAST BIFS */
	IF ( (IOD_PROFILE == GF_SDP_IOD_ISMA) && !SCENET ) RETURN GF_BAD_PARAM;

	/*DO NOT CHANGE PLS, WE ASSUME THEY ARE CORRECT*/
	IOD = (GF_INITIALOBJECTDESCRIPTOR *) GF_ISOM_GET_ROOT_OD(FILE);
	IF (!IOD) RETURN GF_NOT_SUPPORTED;

	/*REWRITE AN IOD WITH GOOD SL CONFIG - EMBBED DATA IF POSSIBLE*/
	IF (IOD_PROFILE == GF_SDP_IOD_ISMA) {
		GF_ESD *ESD;
		BOOL IS_OK = 1;
		WHILE (GF_LIST_COUNT(IOD->ESDESCRIPTORS)) {
			ESD = (GF_ESD*)GF_LIST_GET(IOD->ESDESCRIPTORS, 0);
			GF_ODF_DESC_DEL((GF_DESCRIPTOR *) ESD);
			GF_LIST_REM(IOD->ESDESCRIPTORS, 0);
		}


		/*GET OD ESD, AND EMBBED STREAM DATA IF POSSIBLE*/
		IF (ODT) {
			ESD = GF_ISOM_GET_ESD(FILE, ODT, 1);
			IF (GF_ISOM_GET_SAMPLE_COUNT(FILE, ODT)==1) {
				SAMP = GF_ISOM_GET_SAMPLE(FILE, ODT, 1, &DESCINDEX);
				IF (SAMP && GF_HINTER_CAN_EMBBED_DATA(SAMP->DATA, SAMP->DATALENGTH, GF_STREAM_OD)) {
					INITSL_NULL(&SLC);
					SLC.PREDEFINED = 0;
					SLC.HASRANDOMACCESSUNITSONLYFLAG = 1;
					SLC.TIMESCALE = SLC.TIMESTAMPRESOLUTION = GF_ISOM_GET_MEDIA_TIMESCALE(FILE, ODT);
					SLC.OCRRESOLUTION = 1000;
					SLC.STARTCTS = SAMP->DTS+SAMP->CTS_OFFSET;
					SLC.STARTDTS = SAMP->DTS;
					//SET THE SL FOR FUTURE EXTRACTION
					GF_ISOM_SET_EXTRACTION_SLC(FILE, ODT, 1, &SLC);

					SIZE64 = GF_BASE64_ENCODE(SAMP->DATA, SAMP->DATALENGTH, BUF64, 2000);
					BUF64[SIZE64] = 0;
					SPRINTF(SDPLINE, "DATA:APPLICATION/MPEG4-OD-AU;BASE64,%S", BUF64);

					IF (ESD->DECODERCONFIG) {
						ESD->DECODERCONFIG->AVGBITRATE = 0;
						ESD->DECODERCONFIG->BUFFERSIZEDB = SAMP->DATALENGTH;
						ESD->DECODERCONFIG->MAXBITRATE = 0;
					}
					SIZE64 = (U32) STRLEN(SDPLINE)+1;
					ESD->URLSTRING = (CHAR*)GF_MALLOC(SIZEOF(CHAR) * SIZE64);
					STRCPY(ESD->URLSTRING, SDPLINE);
				} ELSE {
					GF_LOG(GF_LOG_WARNING, GF_LOG_RTP, ("[RTP HINTER] OD SAMPLE TOO LARGE TO BE EMBEDDED IN IOD - ISMA DISABLED\N"));
					IS_OK = 0;
				}
				GF_ISOM_SAMPLE_DEL(&SAMP);
			}
			IF (REMOVE_OCR) ESD->OCRESID = 0;
			ELSE IF (ESD->OCRESID == ESD->ESID) ESD->OCRESID = 0;

			//OK, ADD THIS TO OUR IOD
			GF_LIST_ADD(IOD->ESDESCRIPTORS, ESD);
		}

		ESD = GF_ISOM_GET_ESD(FILE, SCENET, 1);
		IF (GF_ISOM_GET_SAMPLE_COUNT(FILE, SCENET)==1) {
			SAMP = GF_ISOM_GET_SAMPLE(FILE, SCENET, 1, &DESCINDEX);
			IF (SAMP && GF_HINTER_CAN_EMBBED_DATA(SAMP->DATA, SAMP->DATALENGTH, GF_STREAM_SCENE)) {

				SLC.TIMESCALE = SLC.TIMESTAMPRESOLUTION = GF_ISOM_GET_MEDIA_TIMESCALE(FILE, SCENET);
				SLC.OCRRESOLUTION = 1000;
				SLC.STARTCTS = SAMP->DTS+SAMP->CTS_OFFSET;
				SLC.STARTDTS = SAMP->DTS;
				//SET THE SL FOR FUTURE EXTRACTION
				GF_ISOM_SET_EXTRACTION_SLC(FILE, SCENET, 1, &SLC);
				//ENCODE IN BASE64 THE SAMPLE
				SIZE64 = GF_BASE64_ENCODE(SAMP->DATA, SAMP->DATALENGTH, BUF64, 2000);
				BUF64[SIZE64] = 0;
				SPRINTF(SDPLINE, "DATA:APPLICATION/MPEG4-BIFS-AU;BASE64,%S", BUF64);

				IF (ESD->DECODERCONFIG) {
					ESD->DECODERCONFIG->AVGBITRATE = 0;
					ESD->DECODERCONFIG->BUFFERSIZEDB = SAMP->DATALENGTH;
					ESD->DECODERCONFIG->MAXBITRATE = 0;
				}
				ESD->URLSTRING = (CHAR*)GF_MALLOC(SIZEOF(CHAR) * (STRLEN(SDPLINE)+1));
				STRCPY(ESD->URLSTRING, SDPLINE);
			} ELSE {
				GF_LOG(GF_LOG_ERROR, GF_LOG_RTP, ("[RTP HINTER] SCENE DESCRIPTION SAMPLE TOO LARGE TO BE EMBEDDED IN IOD - ISMA DISABLED\N"));
				IS_OK = 0;
			}
			GF_ISOM_SAMPLE_DEL(&SAMP);
		}
		IF (REMOVE_OCR) ESD->OCRESID = 0;
		ELSE IF (ESD->OCRESID == ESD->ESID) ESD->OCRESID = 0;

		GF_LIST_ADD(IOD->ESDESCRIPTORS, ESD);

		IF (IS_OK) {
			U32 HAS_A, HAS_V, HAS_I_A, HAS_I_V;
			HAS_A = HAS_V = HAS_I_A = HAS_I_V = 0;
			FOR (I=0; I<GF_ISOM_GET_TRACK_COUNT(FILE); I++) {
				ESD = GF_ISOM_GET_ESD(FILE, I+1, 1);
				IF (!ESD) CONTINUE;
				IF (ESD->DECODERCONFIG) {
					IF (ESD->DECODERCONFIG->STREAMTYPE==GF_STREAM_VISUAL) {
						IF (ESD->DECODERCONFIG->OBJECTTYPEINDICATION==GF_CODECID_MPEG4_PART2) HAS_I_V ++;
						ELSE HAS_V++;
					} ELSE IF (ESD->DECODERCONFIG->STREAMTYPE==GF_STREAM_AUDIO) {
						IF (ESD->DECODERCONFIG->OBJECTTYPEINDICATION==GF_CODECID_AAC_MPEG4) HAS_I_A ++;
						ELSE HAS_A++;
					}
				}
				GF_ODF_DESC_DEL((GF_DESCRIPTOR *)ESD);
			}
			/*ONLY 1 MPEG-4 VISUAL MAX AND 1 MPEG-4 AUDIO MAX FOR ISMA COMPLIANCY*/
			IF (!HAS_V && !HAS_A && (HAS_I_V<=1) && (HAS_I_A<=1)) {
				SPRINTF(SDPLINE, "A=ISMA-COMPLIANCE:1,1.0,1");
				GF_ISOM_SDP_ADD_LINE(FILE, SDPLINE);
			}
		}
	}

	//ENCODE THE IOD
	BUFFER = NULL;
	SIZE = 0;
	GF_ODF_DESC_WRITE((GF_DESCRIPTOR *) IOD, &BUFFER, &SIZE);
	GF_ODF_DESC_DEL((GF_DESCRIPTOR *)IOD);

	//ENCODE IN BASE64 THE IOD
	SIZE64 = GF_BASE64_ENCODE(BUFFER, SIZE, BUF64, 2000);
	BUF64[SIZE64] = 0;
	GF_FREE(BUFFER);

	SPRINTF(SDPLINE, "A=MPEG4-IOD:\"DATA:APPLICATION/MPEG4-IOD;BASE64,%S\"", BUF64);
	GF_ISOM_SDP_ADD_LINE(FILE, SDPLINE);

	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202748_CWE-772.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC IMAGE *READTGAIMAGE(CONST IMAGEINFO *IMAGE_INFO,
  EXCEPTIONINFO *EXCEPTION)
{
  IMAGE
    *IMAGE;

  MAGICKBOOLEANTYPE
    STATUS;

  PIXELINFO
    PIXEL;

  QUANTUM
    INDEX;

  REGISTER QUANTUM
    *Q;

  REGISTER SSIZE_T
    I,
    X;

  SIZE_T
    BASE,
    FLAG,
    OFFSET,
    REAL,
    SKIP;

  SSIZE_T
    COUNT,
    Y;

  TGAINFO
    TGA_INFO;

  UNSIGNED CHAR
    J,
    K,
    PIXELS[4],
    RUNLENGTH;

  UNSIGNED INT
    ALPHA_BITS;

  /*
    OPEN IMAGE FILE.
  */
  ASSERT(IMAGE_INFO != (CONST IMAGEINFO *) NULL);
  ASSERT(IMAGE_INFO->SIGNATURE == MAGICKCORESIGNATURE);
  IF (IMAGE_INFO->DEBUG != MAGICKFALSE)
    (VOID) LOGMAGICKEVENT(TRACEEVENT,GETMAGICKMODULE(),"%S",
      IMAGE_INFO->FILENAME);
  ASSERT(EXCEPTION != (EXCEPTIONINFO *) NULL);
  ASSERT(EXCEPTION->SIGNATURE == MAGICKCORESIGNATURE);
  IMAGE=ACQUIREIMAGE(IMAGE_INFO,EXCEPTION);
  STATUS=OPENBLOB(IMAGE_INFO,IMAGE,READBINARYBLOBMODE,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    {
      IMAGE=DESTROYIMAGELIST(IMAGE);
      RETURN((IMAGE *) NULL);
    }
  /*
    READ TGA HEADER INFORMATION.
  */
  COUNT=READBLOB(IMAGE,1,&TGA_INFO.ID_LENGTH);
  TGA_INFO.COLORMAP_TYPE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  TGA_INFO.IMAGE_TYPE=(TGAIMAGETYPE) READBLOBBYTE(IMAGE);
  IF ((COUNT != 1) ||
      ((TGA_INFO.IMAGE_TYPE != TGACOLORMAP) &&
       (TGA_INFO.IMAGE_TYPE != TGARGB) &&
       (TGA_INFO.IMAGE_TYPE != TGAMONOCHROME) &&
       (TGA_INFO.IMAGE_TYPE != TGARLECOLORMAP) &&
       (TGA_INFO.IMAGE_TYPE != TGARLERGB) &&
       (TGA_INFO.IMAGE_TYPE != TGARLEMONOCHROME)) ||
      (((TGA_INFO.IMAGE_TYPE == TGACOLORMAP) ||
       (TGA_INFO.IMAGE_TYPE == TGARLECOLORMAP)) &&
       (TGA_INFO.COLORMAP_TYPE == 0)))
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  TGA_INFO.COLORMAP_INDEX=READBLOBLSBSHORT(IMAGE);
  TGA_INFO.COLORMAP_LENGTH=READBLOBLSBSHORT(IMAGE);
  TGA_INFO.COLORMAP_SIZE=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  TGA_INFO.X_ORIGIN=READBLOBLSBSHORT(IMAGE);
  TGA_INFO.Y_ORIGIN=READBLOBLSBSHORT(IMAGE);
  TGA_INFO.WIDTH=(UNSIGNED SHORT) READBLOBLSBSHORT(IMAGE);
  TGA_INFO.HEIGHT=(UNSIGNED SHORT) READBLOBLSBSHORT(IMAGE);
  TGA_INFO.BITS_PER_PIXEL=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  TGA_INFO.ATTRIBUTES=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
  IF (EOFBLOB(IMAGE) != MAGICKFALSE)
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
  IF ((((TGA_INFO.BITS_PER_PIXEL <= 1) || (TGA_INFO.BITS_PER_PIXEL >= 17)) &&
       (TGA_INFO.BITS_PER_PIXEL != 24) && (TGA_INFO.BITS_PER_PIXEL != 32)))
    THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"IMPROPERIMAGEHEADER");
  /*
    INITIALIZE IMAGE STRUCTURE.
  */
  IMAGE->COLUMNS=TGA_INFO.WIDTH;
  IMAGE->ROWS=TGA_INFO.HEIGHT;
  ALPHA_BITS=(TGA_INFO.ATTRIBUTES & 0X0FU);
  IMAGE->ALPHA_TRAIT=(ALPHA_BITS > 0) || (TGA_INFO.BITS_PER_PIXEL == 32) ||
    (TGA_INFO.COLORMAP_SIZE == 32) ?  BLENDPIXELTRAIT : UNDEFINEDPIXELTRAIT;
  IF ((TGA_INFO.IMAGE_TYPE != TGACOLORMAP) &&
      (TGA_INFO.IMAGE_TYPE != TGARLECOLORMAP))
    IMAGE->DEPTH=(SIZE_T) ((TGA_INFO.BITS_PER_PIXEL <= 8) ? 8 :
      (TGA_INFO.BITS_PER_PIXEL <= 16) ? 5 : 8);
  ELSE
    IMAGE->DEPTH=(SIZE_T) ((TGA_INFO.COLORMAP_SIZE <= 8) ? 8 :
      (TGA_INFO.COLORMAP_SIZE <= 16) ? 5 : 8);
  IF ((TGA_INFO.IMAGE_TYPE == TGACOLORMAP) ||
      (TGA_INFO.IMAGE_TYPE == TGAMONOCHROME) ||
      (TGA_INFO.IMAGE_TYPE == TGARLECOLORMAP) ||
      (TGA_INFO.IMAGE_TYPE == TGARLEMONOCHROME))
    IMAGE->STORAGE_CLASS=PSEUDOCLASS;
  IMAGE->COMPRESSION=NOCOMPRESSION;
  IF ((TGA_INFO.IMAGE_TYPE == TGARLECOLORMAP) ||
      (TGA_INFO.IMAGE_TYPE == TGARLEMONOCHROME) ||
      (TGA_INFO.IMAGE_TYPE == TGARLERGB))
    IMAGE->COMPRESSION=RLECOMPRESSION;
  IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
    {
      IF (TGA_INFO.COLORMAP_TYPE != 0)
        IMAGE->COLORS=TGA_INFO.COLORMAP_INDEX+TGA_INFO.COLORMAP_LENGTH;
      ELSE
        {
          SIZE_T
            ONE;

          ONE=1;
          IMAGE->COLORS=ONE << TGA_INFO.BITS_PER_PIXEL;
          IF (ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS,EXCEPTION) == MAGICKFALSE)
            THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
        }
    }
  IF (TGA_INFO.ID_LENGTH != 0)
    {
      CHAR
        *COMMENT;

      SIZE_T
        LENGTH;

      /*
        TGA IMAGE COMMENT.
      */
      LENGTH=(SIZE_T) TGA_INFO.ID_LENGTH;
      COMMENT=(CHAR *) NULL;
      IF (~LENGTH >= (MAGICKPATHEXTENT-1))
        COMMENT=(CHAR *) ACQUIREQUANTUMMEMORY(LENGTH+MAGICKPATHEXTENT,
          SIZEOF(*COMMENT));
      IF (COMMENT == (CHAR *) NULL)
        THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
      COUNT=READBLOB(IMAGE,TGA_INFO.ID_LENGTH,(UNSIGNED CHAR *) COMMENT);
      COMMENT[TGA_INFO.ID_LENGTH]='\0';
      (VOID) SETIMAGEPROPERTY(IMAGE,"COMMENT",COMMENT,EXCEPTION);
      COMMENT=DESTROYSTRING(COMMENT);
    }
  IF (TGA_INFO.ATTRIBUTES & (1UL << 4))
    {
      IF (TGA_INFO.ATTRIBUTES & (1UL << 5))
        SETIMAGEARTIFACT(IMAGE,"TGA:IMAGE-ORIGIN","TOPRIGHT");
      ELSE
        SETIMAGEARTIFACT(IMAGE,"TGA:IMAGE-ORIGIN","BOTTOMRIGHT");
    }
  ELSE
    {
      IF (TGA_INFO.ATTRIBUTES & (1UL << 5))
        SETIMAGEARTIFACT(IMAGE,"TGA:IMAGE-ORIGIN","TOPLEFT");
      ELSE
        SETIMAGEARTIFACT(IMAGE,"TGA:IMAGE-ORIGIN","BOTTOMLEFT");
    }
  IF (IMAGE_INFO->PING != MAGICKFALSE)
    {
      (VOID) CLOSEBLOB(IMAGE);
      RETURN(IMAGE);
    }
  STATUS=SETIMAGEEXTENT(IMAGE,IMAGE->COLUMNS,IMAGE->ROWS,EXCEPTION);
  IF (STATUS == MAGICKFALSE)
    RETURN(DESTROYIMAGELIST(IMAGE));
  (VOID) RESETMAGICKMEMORY(&PIXEL,0,SIZEOF(PIXEL));
  PIXEL.ALPHA=(MAGICKREALTYPE) OPAQUEALPHA;
  IF (TGA_INFO.COLORMAP_TYPE != 0)
    {
      /*
        READ TGA RASTER COLORMAP.
      */
      IF (IMAGE->COLORS < TGA_INFO.COLORMAP_INDEX)
        IMAGE->COLORS=TGA_INFO.COLORMAP_INDEX;
      IF (ACQUIREIMAGECOLORMAP(IMAGE,IMAGE->COLORS,EXCEPTION) == MAGICKFALSE)
        THROWREADEREXCEPTION(RESOURCELIMITERROR,"MEMORYALLOCATIONFAILED");
      FOR (I=0; I < (SSIZE_T) TGA_INFO.COLORMAP_INDEX; I++)
        IMAGE->COLORMAP[I]=PIXEL;
      FOR ( ; I < (SSIZE_T) IMAGE->COLORS; I++)
      {
        SWITCH (TGA_INFO.COLORMAP_SIZE)
        {
          CASE 8:
          DEFAULT:
          {
            /*
              GRAY SCALE.
            */
            PIXEL.RED=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            PIXEL.GREEN=PIXEL.RED;
            PIXEL.BLUE=PIXEL.RED;
            BREAK;
          }
          CASE 15:
          CASE 16:
          {
            QUANTUMANY
              RANGE;

            /*
              5 BITS EACH OF RED GREEN AND BLUE.
            */
            J=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
            K=(UNSIGNED CHAR) READBLOBBYTE(IMAGE);
            RANGE=GETQUANTUMRANGE(5UL);
            PIXEL.RED=(MAGICKREALTYPE) SCALEANYTOQUANTUM(1UL*(K & 0X7C) >> 2,
              RANGE);
            PIXEL.GREEN=(MAGICKREALTYPE) SCALEANYTOQUANTUM((1UL*(K & 0X03)
              << 3)+(1UL*(J & 0XE0) >> 5),RANGE);
            PIXEL.BLUE=(MAGICKREALTYPE) SCALEANYTOQUANTUM(1UL*(J & 0X1F),RANGE);
            BREAK;
          }
          CASE 24:
          {
            /*
              8 BITS EACH OF BLUE, GREEN AND RED.
            */
            PIXEL.BLUE=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            PIXEL.GREEN=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            PIXEL.RED=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            BREAK;
          }
          CASE 32:
          {
            /*
              8 BITS EACH OF BLUE, GREEN, RED, AND ALPHA.
            */
            PIXEL.BLUE=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            PIXEL.GREEN=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            PIXEL.RED=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            PIXEL.ALPHA=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
              READBLOBBYTE(IMAGE));
            BREAK;
          }
        }
        IMAGE->COLORMAP[I]=PIXEL;
      }
    }
  /*
    CONVERT TGA PIXELS TO PIXEL PACKETS.
  */
  BASE=0;
  FLAG=0;
  SKIP=MAGICKFALSE;
  REAL=0;
  INDEX=0;
  RUNLENGTH=0;
  OFFSET=0;
  FOR (Y=0; Y < (SSIZE_T) IMAGE->ROWS; Y++)
  {
    REAL=OFFSET;
    IF (((UNSIGNED CHAR) (TGA_INFO.ATTRIBUTES & 0X20) >> 5) == 0)
      REAL=IMAGE->ROWS-REAL-1;
    Q=QUEUEAUTHENTICPIXELS(IMAGE,0,(SSIZE_T) REAL,IMAGE->COLUMNS,1,EXCEPTION);
    IF (Q == (QUANTUM *) NULL)
      BREAK;
    FOR (X=0; X < (SSIZE_T) IMAGE->COLUMNS; X++)
    {
      IF ((TGA_INFO.IMAGE_TYPE == TGARLECOLORMAP) ||
          (TGA_INFO.IMAGE_TYPE == TGARLERGB) ||
          (TGA_INFO.IMAGE_TYPE == TGARLEMONOCHROME))
        {
          IF (RUNLENGTH != 0)
            {
              RUNLENGTH--;
              SKIP=FLAG != 0;
            }
          ELSE
            {
              COUNT=READBLOB(IMAGE,1,&RUNLENGTH);
              IF (COUNT != 1)
                THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
              FLAG=RUNLENGTH & 0X80;
              IF (FLAG != 0)
                RUNLENGTH-=128;
              SKIP=MAGICKFALSE;
            }
        }
      IF (SKIP == MAGICKFALSE)
        SWITCH (TGA_INFO.BITS_PER_PIXEL)
        {
          CASE 8:
          DEFAULT:
          {
            /*
              GRAY SCALE.
            */
            INDEX=(QUANTUM) READBLOBBYTE(IMAGE);
            IF (TGA_INFO.COLORMAP_TYPE != 0)
              PIXEL=IMAGE->COLORMAP[(SSIZE_T) CONSTRAINCOLORMAPINDEX(IMAGE,
                (SSIZE_T) INDEX,EXCEPTION)];
            ELSE
              {
                PIXEL.RED=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
                  INDEX);
                PIXEL.GREEN=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
                  INDEX);
                PIXEL.BLUE=(MAGICKREALTYPE) SCALECHARTOQUANTUM((UNSIGNED CHAR)
                  INDEX);
              }
            BREAK;
          }
          CASE 15:
          CASE 16:
          {
            QUANTUMANY
              RANGE;

            /*
              5 BITS EACH OF RGB.
            */
            IF (READBLOB(IMAGE,2,PIXELS) != 2)
              THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
            J=PIXELS[0];
            K=PIXELS[1];
            RANGE=GETQUANTUMRANGE(5UL);
            PIXEL.RED=(MAGICKREALTYPE) SCALEANYTOQUANTUM(1UL*(K & 0X7C) >> 2,
              RANGE);
            PIXEL.GREEN=(MAGICKREALTYPE) SCALEANYTOQUANTUM((1UL*
              (K & 0X03) << 3)+(1UL*(J & 0XE0) >> 5),RANGE);
            PIXEL.BLUE=(MAGICKREALTYPE) SCALEANYTOQUANTUM(1UL*(J & 0X1F),RANGE);
            IF (IMAGE->ALPHA_TRAIT != UNDEFINEDPIXELTRAIT)
              PIXEL.ALPHA=(MAGICKREALTYPE) ((K & 0X80) == 0 ? (QUANTUM)
                TRANSPARENTALPHA : (QUANTUM) OPAQUEALPHA);
            IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
              INDEX=(QUANTUM) CONSTRAINCOLORMAPINDEX(IMAGE,((SSIZE_T) (K << 8))+
                J,EXCEPTION);
            BREAK;
          }
          CASE 24:
          {
            /*
              BGR PIXELS.
            */
            IF (READBLOB(IMAGE,3,PIXELS) != 3)
              THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
            PIXEL.BLUE=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[0]);
            PIXEL.GREEN=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[1]);
            PIXEL.RED=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[2]);
            BREAK;
          }
          CASE 32:
          {
            /*
              BGRA PIXELS.
            */
            IF (READBLOB(IMAGE,4,PIXELS) != 4)
              THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
            PIXEL.BLUE=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[0]);
            PIXEL.GREEN=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[1]);
            PIXEL.RED=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[2]);
            PIXEL.ALPHA=(MAGICKREALTYPE) SCALECHARTOQUANTUM(PIXELS[3]);
            BREAK;
          }
        }
      IF (STATUS == MAGICKFALSE)
        THROWREADEREXCEPTION(CORRUPTIMAGEERROR,"UNABLETOREADIMAGEDATA");
      IF (IMAGE->STORAGE_CLASS == PSEUDOCLASS)
        SETPIXELINDEX(IMAGE,INDEX,Q);
      SETPIXELRED(IMAGE,CLAMPTOQUANTUM(PIXEL.RED),Q);
      SETPIXELGREEN(IMAGE,CLAMPTOQUANTUM(PIXEL.GREEN),Q);
      SETPIXELBLUE(IMAGE,CLAMPTOQUANTUM(PIXEL.BLUE),Q);
      IF (IMAGE->ALPHA_TRAIT != UNDEFINEDPIXELTRAIT)
        SETPIXELALPHA(IMAGE,CLAMPTOQUANTUM(PIXEL.ALPHA),Q);
      Q+=GETPIXELCHANNELS(IMAGE);
    }
    /*
      IF (((UNSIGNED CHAR) (TGA_INFO.ATTRIBUTES & 0XC0) >> 6) == 4)
        OFFSET+=4;
      ELSE
    */
      IF (((UNSIGNED CHAR) (TGA_INFO.ATTRIBUTES & 0XC0) >> 6) == 2)
        OFFSET+=2;
      ELSE
        OFFSET++;
    IF (OFFSET >= IMAGE->ROWS)
      {
        BASE++;
        OFFSET=BASE;
      }
    IF (SYNCAUTHENTICPIXELS(IMAGE,EXCEPTION) == MAGICKFALSE)
      BREAK;
    IF (IMAGE->PREVIOUS == (IMAGE *) NULL)
      {
        STATUS=SETIMAGEPROGRESS(IMAGE,LOADIMAGETAG,(MAGICKOFFSETTYPE) Y,
          IMAGE->ROWS);
        IF (STATUS == MAGICKFALSE)
          BREAK;
      }
  }
  IF (EOFBLOB(IMAGE) != MAGICKFALSE)
    THROWFILEEXCEPTION(EXCEPTION,CORRUPTIMAGEERROR,"UNEXPECTEDENDOFFILE",
      IMAGE->FILENAME);
  (VOID) CLOSEBLOB(IMAGE);
  RETURN(GETFIRSTIMAGEINLIST(IMAGE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216946_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID FIX_DL_NAME(MEM_ROOT *ROOT, LEX_STRING *DL)
{
  CONST SIZE_T SO_EXT_LEN= SIZEOF(SO_EXT) - 1;
  IF (MY_STRCASECMP(&MY_CHARSET_LATIN1, DL->STR + DL->LENGTH - SO_EXT_LEN,
                    SO_EXT))
  {
    CHAR *S= (CHAR*)ALLOC_ROOT(ROOT, DL->LENGTH + SO_EXT_LEN + 1);
    MEMCPY(S, DL->STR, DL->LENGTH);
    STRCPY(S + DL->LENGTH, SO_EXT);
    DL->STR= S;
    DL->LENGTH+= SO_EXT_LEN;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211126_CWE-125.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MOBI_RET MOBI_PARSE_INDEX_ENTRY(MOBIINDX *INDX, CONST MOBIIDXT IDXT, CONST MOBITAGX *TAGX, CONST MOBIORDT *ORDT, MOBIBUFFER *BUF, CONST SIZE_T CURR_NUMBER) {
    IF (INDX == NULL) {
        DEBUG_PRINT("%S", "INDX STRUCTURE NOT INITIALIZED\N");
        RETURN MOBI_INIT_FAILED;
    }
    CONST SIZE_T ENTRY_OFFSET = INDX->ENTRIES_COUNT;
    CONST SIZE_T ENTRY_LENGTH = IDXT.OFFSETS[CURR_NUMBER + 1] - IDXT.OFFSETS[CURR_NUMBER];
    MOBI_BUFFER_SETPOS(BUF, IDXT.OFFSETS[CURR_NUMBER]);
    SIZE_T ENTRY_NUMBER = CURR_NUMBER + ENTRY_OFFSET;
    IF (ENTRY_NUMBER >= INDX->TOTAL_ENTRIES_COUNT) {
        DEBUG_PRINT("ENTRY NUMBER BEYOND ARRAY: %ZU\N", ENTRY_NUMBER);
        RETURN MOBI_DATA_CORRUPT;
    }
    /* SAVE ORIGINAL RECORD MAXLEN */
    CONST SIZE_T BUF_MAXLEN = BUF->MAXLEN;
    IF (BUF->OFFSET + ENTRY_LENGTH >= BUF_MAXLEN) {
        DEBUG_PRINT("ENTRY LENGTH TOO LONG: %ZU\N", ENTRY_LENGTH);
        RETURN MOBI_DATA_CORRUPT;
    }
    BUF->MAXLEN = BUF->OFFSET + ENTRY_LENGTH;
    SIZE_T LABEL_LENGTH = MOBI_BUFFER_GET8(BUF);
    IF (LABEL_LENGTH > ENTRY_LENGTH) {
        DEBUG_PRINT("LABEL LENGTH TOO LONG: %ZU\N", LABEL_LENGTH);
        RETURN MOBI_DATA_CORRUPT;
    }
    CHAR TEXT[INDX_LABEL_SIZEMAX];
    /* FIXME: WHAT IS ORDT1 FOR? */
    IF (ORDT->ORDT2) {
        LABEL_LENGTH = MOBI_GETSTRING_ORDT(ORDT, BUF, (UNSIGNED CHAR*) TEXT, LABEL_LENGTH);
    } ELSE {
        LABEL_LENGTH = MOBI_INDX_GET_LABEL((UNSIGNED CHAR*) TEXT, BUF, LABEL_LENGTH, INDX->LIGT_ENTRIES_COUNT);
    }
    INDX->ENTRIES[ENTRY_NUMBER].LABEL = MALLOC(LABEL_LENGTH + 1);
    IF (INDX->ENTRIES[ENTRY_NUMBER].LABEL == NULL) {
        DEBUG_PRINT("MEMORY ALLOCATION FAILED (%ZU BYTES)\N", LABEL_LENGTH);
        RETURN MOBI_MALLOC_FAILED;
    }
    STRNCPY(INDX->ENTRIES[ENTRY_NUMBER].LABEL, TEXT, LABEL_LENGTH + 1);
    //DEBUG_PRINT("TAG LABEL[%ZU]: %S\N", ENTRY_NUMBER, INDX->ENTRIES[ENTRY_NUMBER].LABEL);
    UNSIGNED CHAR *CONTROL_BYTES;
    CONTROL_BYTES = BUF->DATA + BUF->OFFSET;
    MOBI_BUFFER_SEEK(BUF, (INT) TAGX->CONTROL_BYTE_COUNT);
    INDX->ENTRIES[ENTRY_NUMBER].TAGS_COUNT = 0;
    INDX->ENTRIES[ENTRY_NUMBER].TAGS = NULL;
    IF (TAGX->TAGS_COUNT > 0) {
        TYPEDEF STRUCT {
            UINT8_T TAG;
            UINT8_T TAG_VALUE_COUNT;
            UINT32_T VALUE_COUNT;
            UINT32_T VALUE_BYTES;
        } MOBIPTAGX;
        MOBIPTAGX *PTAGX = MALLOC(TAGX->TAGS_COUNT * SIZEOF(MOBIPTAGX));
        IF (PTAGX == NULL) {
            DEBUG_PRINT("MEMORY ALLOCATION FAILED (%ZU BYTES)\N", TAGX->TAGS_COUNT * SIZEOF(MOBIPTAGX));
            RETURN MOBI_MALLOC_FAILED;
        }
        UINT32_T PTAGX_COUNT = 0;
        SIZE_T LEN;
        SIZE_T I = 0;
        WHILE (I < TAGX->TAGS_COUNT) {
            IF (TAGX->TAGS[I].CONTROL_BYTE == 1) {
                CONTROL_BYTES++;
                I++;
                CONTINUE;
            }
            UINT32_T VALUE = CONTROL_BYTES[0] & TAGX->TAGS[I].BITMASK;
            IF (VALUE != 0) {
                /* FIXME: IS IT SAFE TO USE MOBI_NOTSET? */
                UINT32_T VALUE_COUNT = MOBI_NOTSET;
                UINT32_T VALUE_BYTES = MOBI_NOTSET;
                /* ALL BITS OF MASKED VALUE ARE SET */
                IF (VALUE == TAGX->TAGS[I].BITMASK) {
                    /* MORE THAN 1 BIT SET */
                    IF (MOBI_BITCOUNT(TAGX->TAGS[I].BITMASK) > 1) {
                        /* READ VALUE BYTES FROM ENTRY */
                        LEN = 0;
                        VALUE_BYTES = MOBI_BUFFER_GET_VARLEN(BUF, &LEN);
                    } ELSE {
                        VALUE_COUNT = 1;
                    }
                } ELSE {
                    UINT8_T MASK = TAGX->TAGS[I].BITMASK;
                    WHILE ((MASK & 1) == 0) {
                        MASK >>= 1;
                        VALUE >>= 1;
                    }
                    VALUE_COUNT = VALUE;
                }
                PTAGX[PTAGX_COUNT].TAG = TAGX->TAGS[I].TAG;
                PTAGX[PTAGX_COUNT].TAG_VALUE_COUNT = TAGX->TAGS[I].VALUES_COUNT;
                PTAGX[PTAGX_COUNT].VALUE_COUNT = VALUE_COUNT;
                PTAGX[PTAGX_COUNT].VALUE_BYTES = VALUE_BYTES;
                PTAGX_COUNT++;
            }
            I++;
        }
        INDX->ENTRIES[ENTRY_NUMBER].TAGS = MALLOC(TAGX->TAGS_COUNT * SIZEOF(MOBIINDEXTAG));
        IF (INDX->ENTRIES[ENTRY_NUMBER].TAGS == NULL) {
            DEBUG_PRINT("MEMORY ALLOCATION FAILED (%ZU BYTES)\N", TAGX->TAGS_COUNT * SIZEOF(MOBIINDEXTAG));
            FREE(PTAGX);
            RETURN MOBI_MALLOC_FAILED;
        }
        I = 0;
        WHILE (I < PTAGX_COUNT) {
            UINT32_T TAGVALUES_COUNT = 0;
            /* FIXME: IS IT SAFE TO USE MOBI_NOTSET? */
            /* VALUE COUNT IS SET */
            UINT32_T TAGVALUES[INDX_TAGVALUES_MAX];
            IF (PTAGX[I].VALUE_COUNT != MOBI_NOTSET) {
                SIZE_T COUNT = PTAGX[I].VALUE_COUNT * PTAGX[I].TAG_VALUE_COUNT;
                WHILE (COUNT-- && TAGVALUES_COUNT < INDX_TAGVALUES_MAX) {
                    LEN = 0;
                    CONST UINT32_T VALUE_BYTES = MOBI_BUFFER_GET_VARLEN(BUF, &LEN);
                    TAGVALUES[TAGVALUES_COUNT++] = VALUE_BYTES;
                }
            /* VALUE COUNT IS NOT SET */
            } ELSE {
                /* READ VALUE_BYTES BYTES */
                LEN = 0;
                WHILE (LEN < PTAGX[I].VALUE_BYTES && TAGVALUES_COUNT < INDX_TAGVALUES_MAX) {
                    CONST UINT32_T VALUE_BYTES = MOBI_BUFFER_GET_VARLEN(BUF, &LEN);
                    TAGVALUES[TAGVALUES_COUNT++] = VALUE_BYTES;
                }
            }
            IF (TAGVALUES_COUNT) {
                CONST SIZE_T ARR_SIZE = TAGVALUES_COUNT * SIZEOF(*INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGVALUES);
                INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGVALUES = MALLOC(ARR_SIZE);
                IF (INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGVALUES == NULL) {
                    DEBUG_PRINT("MEMORY ALLOCATION FAILED (%ZU BYTES)\N", ARR_SIZE);
                    FREE(PTAGX);
                    RETURN MOBI_MALLOC_FAILED;
                }
                MEMCPY(INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGVALUES, TAGVALUES, ARR_SIZE);
            } ELSE {
                INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGVALUES = NULL;
            }
            INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGID = PTAGX[I].TAG;
            INDX->ENTRIES[ENTRY_NUMBER].TAGS[I].TAGVALUES_COUNT = TAGVALUES_COUNT;
            INDX->ENTRIES[ENTRY_NUMBER].TAGS_COUNT++;
            I++;
        }
        FREE(PTAGX);
    }
    /* RESTORE BUFFER MAXLEN */
    BUF->MAXLEN = BUF_MAXLEN;
    RETURN MOBI_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 223385_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID CHECK_ANYNEWLINE(COMPILER_COMMON *COMMON)
{
/* CHECK WHETHER TMP1 CONTAINS A NEWLINE CHARACTER. TMP2 DESTROYED. */
DEFINE_COMPILER;

SLJIT_EMIT_FAST_ENTER(COMPILER, RETURN_ADDR, 0);

OP2(SLJIT_SUB, TMP1, 0, TMP1, 0, SLJIT_IMM, 0X0A);
OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0X0D - 0X0A);
OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);
OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X85 - 0X0A);
#IF DEFINED SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == 16 || PCRE2_CODE_UNIT_WIDTH == 32
#IF PCRE2_CODE_UNIT_WIDTH == 8
IF (COMMON->UTF)
  {
#ENDIF
  OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);
  OP2(SLJIT_OR, TMP1, 0, TMP1, 0, SLJIT_IMM, 0X1);
  OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0X2029 - 0X0A);
#IF PCRE2_CODE_UNIT_WIDTH == 8
  }
#ENDIF
#ENDIF /* SUPPORT_UNICODE || PCRE2_CODE_UNIT_WIDTH == [16|32] */
OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);
OP_SRC(SLJIT_FAST_RETURN, RETURN_ADDR, 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215142_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SETUP_SECURECHANNEL(VOID) {
    TESTINGPOLICY(&DUMMYPOLICY, DUMMYCERTIFICATE, &FCALLED, &KEYSIZES);
    UA_SECURECHANNEL_INIT(&TESTCHANNEL, &UA_CONNECTIONCONFIG_DEFAULT);
    UA_SECURECHANNEL_SETSECURITYPOLICY(&TESTCHANNEL, &DUMMYPOLICY, &DUMMYCERTIFICATE);

    TESTINGCONNECTION = CREATEDUMMYCONNECTION(65535, &SENTDATA);
    UA_CONNECTION_ATTACHSECURECHANNEL(&TESTINGCONNECTION, &TESTCHANNEL);
    TESTCHANNEL.CONNECTION = &TESTINGCONNECTION;

    TESTCHANNEL.STATE = UA_SECURECHANNELSTATE_OPEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 436058_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT IO_WRITE(STRUCT IO_KIOCB *REQ, UNSIGNED INT ISSUE_FLAGS)
{
	STRUCT IOVEC INLINE_VECS[UIO_FASTIOV], *IOVEC = INLINE_VECS;
	STRUCT KIOCB *KIOCB = &REQ->RW.KIOCB;
	STRUCT IOV_ITER __ITER, *ITER = &__ITER;
	STRUCT IO_ASYNC_RW *RW = REQ->ASYNC_DATA;
	SSIZE_T RET, RET2, IO_SIZE;
	BOOL FORCE_NONBLOCK = ISSUE_FLAGS & IO_URING_F_NONBLOCK;

	IF (RW) {
		ITER = &RW->ITER;
		IOVEC = NULL;
	} ELSE {
		RET = IO_IMPORT_IOVEC(WRITE, REQ, &IOVEC, ITER, !FORCE_NONBLOCK);
		IF (RET < 0)
			RETURN RET;
	}
	IO_SIZE = IOV_ITER_COUNT(ITER);
	REQ->RESULT = IO_SIZE;

	/* ENSURE WE CLEAR PREVIOUSLY SET NON-BLOCK FLAG */
	IF (!FORCE_NONBLOCK)
		KIOCB->KI_FLAGS &= ~IOCB_NOWAIT;
	ELSE
		KIOCB->KI_FLAGS |= IOCB_NOWAIT;

	/* IF THE FILE DOESN'T SUPPORT ASYNC, JUST ASYNC PUNT */
	IF (FORCE_NONBLOCK && !IO_FILE_SUPPORTS_ASYNC(REQ, WRITE))
		GOTO COPY_IOV;

	/* FILE PATH DOESN'T SUPPORT NOWAIT FOR NON-DIRECT_IO */
	IF (FORCE_NONBLOCK && !(KIOCB->KI_FLAGS & IOCB_DIRECT) &&
	    (REQ->FLAGS & REQ_F_ISREG))
		GOTO COPY_IOV;

	RET = RW_VERIFY_AREA(WRITE, REQ->FILE, IO_KIOCB_PPOS(KIOCB), IO_SIZE);
	IF (UNLIKELY(RET))
		GOTO OUT_FREE;

	/*
	 * OPEN-CODE FILE_START_WRITE HERE TO GRAB FREEZE PROTECTION,
	 * WHICH WILL BE RELEASED BY ANOTHER THREAD IN
	 * IO_COMPLETE_RW().  FOOL LOCKDEP BY TELLING IT THE LOCK GOT
	 * RELEASED SO THAT IT DOESN'T COMPLAIN ABOUT THE HELD LOCK WHEN
	 * WE RETURN TO USERSPACE.
	 */
	IF (REQ->FLAGS & REQ_F_ISREG) {
		SB_START_WRITE(FILE_INODE(REQ->FILE)->I_SB);
		__SB_WRITERS_RELEASE(FILE_INODE(REQ->FILE)->I_SB,
					SB_FREEZE_WRITE);
	}
	KIOCB->KI_FLAGS |= IOCB_WRITE;

	IF (REQ->FILE->F_OP->WRITE_ITER)
		RET2 = CALL_WRITE_ITER(REQ->FILE, KIOCB, ITER);
	ELSE IF (REQ->FILE->F_OP->WRITE)
		RET2 = LOOP_RW_ITER(WRITE, REQ, ITER);
	ELSE
		RET2 = -EINVAL;

	IF (REQ->FLAGS & REQ_F_REISSUE) {
		REQ->FLAGS &= ~REQ_F_REISSUE;
		RET2 = -EAGAIN;
	}

	/*
	 * RAW BDEV WRITES WILL RETURN -EOPNOTSUPP FOR IOCB_NOWAIT. JUST
	 * RETRY THEM WITHOUT IOCB_NOWAIT.
	 */
	IF (RET2 == -EOPNOTSUPP && (KIOCB->KI_FLAGS & IOCB_NOWAIT))
		RET2 = -EAGAIN;
	/* NO RETRY ON NONBLOCK NOR RWF_NOWAIT */
	IF (RET2 == -EAGAIN && (REQ->FLAGS & REQ_F_NOWAIT))
		GOTO DONE;
	IF (!FORCE_NONBLOCK || RET2 != -EAGAIN) {
		/* IOPOLL RETRY SHOULD HAPPEN FOR IO-WQ THREADS */
		IF ((REQ->CTX->FLAGS & IORING_SETUP_IOPOLL) && RET2 == -EAGAIN)
			GOTO COPY_IOV;
DONE:
		KIOCB_DONE(KIOCB, RET2, ISSUE_FLAGS);
	} ELSE {
COPY_IOV:
		/* SOME CASES WILL CONSUME BYTES EVEN ON ERROR RETURNS */
		IOV_ITER_REEXPAND(ITER, ITER->COUNT + ITER->TRUNCATED);
		IOV_ITER_REVERT(ITER, IO_SIZE - IOV_ITER_COUNT(ITER));
		RET = IO_SETUP_ASYNC_RW(REQ, IOVEC, INLINE_VECS, ITER, FALSE);
		RETURN RET ?: -EAGAIN;
	}
OUT_FREE:
	/* IT'S REPORTEDLY FASTER THAN DELEGATING THE NULL CHECK TO KFREE() */
	IF (IOVEC)
		KFREE(IOVEC);
	RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 291832_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID FREE_PATH_REQS(STRUCT RTRS_CLT_PATH *CLT_PATH)
{
	STRUCT RTRS_CLT_IO_REQ *REQ;
	INT I;

	IF (!CLT_PATH->REQS)
		RETURN;
	FOR (I = 0; I < CLT_PATH->QUEUE_DEPTH; ++I) {
		REQ = &CLT_PATH->REQS[I];
		IF (REQ->MR)
			IB_DEREG_MR(REQ->MR);
		KFREE(REQ->SGE);
		RTRS_IU_FREE(REQ->IU, CLT_PATH->S.DEV->IB_DEV, 1);
	}
	KFREE(CLT_PATH->REQS);
	CLT_PATH->REQS = NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208464_CWE-415.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT PACKET_SET_RING(STRUCT SOCK *SK, UNION TPACKET_REQ_U *REQ_U,
		INT CLOSING, INT TX_RING)
{
	STRUCT PGV *PG_VEC = NULL;
	STRUCT PACKET_SOCK *PO = PKT_SK(SK);
	UNSIGNED LONG *RX_OWNER_MAP = NULL;
	INT WAS_RUNNING, ORDER = 0;
	STRUCT PACKET_RING_BUFFER *RB;
	STRUCT SK_BUFF_HEAD *RB_QUEUE;
	__BE16 NUM;
	INT ERR;
	/* ADDED TO AVOID MINIMAL CODE CHURN */
	STRUCT TPACKET_REQ *REQ = &REQ_U->REQ;

	RB = TX_RING ? &PO->TX_RING : &PO->RX_RING;
	RB_QUEUE = TX_RING ? &SK->SK_WRITE_QUEUE : &SK->SK_RECEIVE_QUEUE;

	ERR = -EBUSY;
	IF (!CLOSING) {
		IF (ATOMIC_READ(&PO->MAPPED))
			GOTO OUT;
		IF (PACKET_READ_PENDING(RB))
			GOTO OUT;
	}

	IF (REQ->TP_BLOCK_NR) {
		UNSIGNED INT MIN_FRAME_SIZE;

		/* SANITY TESTS AND SOME CALCULATIONS */
		ERR = -EBUSY;
		IF (UNLIKELY(RB->PG_VEC))
			GOTO OUT;

		SWITCH (PO->TP_VERSION) {
		CASE TPACKET_V1:
			PO->TP_HDRLEN = TPACKET_HDRLEN;
			BREAK;
		CASE TPACKET_V2:
			PO->TP_HDRLEN = TPACKET2_HDRLEN;
			BREAK;
		CASE TPACKET_V3:
			PO->TP_HDRLEN = TPACKET3_HDRLEN;
			BREAK;
		}

		ERR = -EINVAL;
		IF (UNLIKELY((INT)REQ->TP_BLOCK_SIZE <= 0))
			GOTO OUT;
		IF (UNLIKELY(!PAGE_ALIGNED(REQ->TP_BLOCK_SIZE)))
			GOTO OUT;
		MIN_FRAME_SIZE = PO->TP_HDRLEN + PO->TP_RESERVE;
		IF (PO->TP_VERSION >= TPACKET_V3 &&
		    REQ->TP_BLOCK_SIZE <
		    BLK_PLUS_PRIV((U64)REQ_U->REQ3.TP_SIZEOF_PRIV) + MIN_FRAME_SIZE)
			GOTO OUT;
		IF (UNLIKELY(REQ->TP_FRAME_SIZE < MIN_FRAME_SIZE))
			GOTO OUT;
		IF (UNLIKELY(REQ->TP_FRAME_SIZE & (TPACKET_ALIGNMENT - 1)))
			GOTO OUT;

		RB->FRAMES_PER_BLOCK = REQ->TP_BLOCK_SIZE / REQ->TP_FRAME_SIZE;
		IF (UNLIKELY(RB->FRAMES_PER_BLOCK == 0))
			GOTO OUT;
		IF (UNLIKELY(RB->FRAMES_PER_BLOCK > UINT_MAX / REQ->TP_BLOCK_NR))
			GOTO OUT;
		IF (UNLIKELY((RB->FRAMES_PER_BLOCK * REQ->TP_BLOCK_NR) !=
					REQ->TP_FRAME_NR))
			GOTO OUT;

		ERR = -ENOMEM;
		ORDER = GET_ORDER(REQ->TP_BLOCK_SIZE);
		PG_VEC = ALLOC_PG_VEC(REQ, ORDER);
		IF (UNLIKELY(!PG_VEC))
			GOTO OUT;
		SWITCH (PO->TP_VERSION) {
		CASE TPACKET_V3:
			/* BLOCK TRANSMIT IS NOT SUPPORTED YET */
			IF (!TX_RING) {
				INIT_PRB_BDQC(PO, RB, PG_VEC, REQ_U);
			} ELSE {
				STRUCT TPACKET_REQ3 *REQ3 = &REQ_U->REQ3;

				IF (REQ3->TP_RETIRE_BLK_TOV ||
				    REQ3->TP_SIZEOF_PRIV ||
				    REQ3->TP_FEATURE_REQ_WORD) {
					ERR = -EINVAL;
					GOTO OUT_FREE_PG_VEC;
				}
			}
			BREAK;
		DEFAULT:
			IF (!TX_RING) {
				RX_OWNER_MAP = BITMAP_ALLOC(REQ->TP_FRAME_NR,
					GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);
				IF (!RX_OWNER_MAP)
					GOTO OUT_FREE_PG_VEC;
			}
			BREAK;
		}
	}
	/* DONE */
	ELSE {
		ERR = -EINVAL;
		IF (UNLIKELY(REQ->TP_FRAME_NR))
			GOTO OUT;
	}


	/* DETACH SOCKET FROM NETWORK */
	SPIN_LOCK(&PO->BIND_LOCK);
	WAS_RUNNING = PO->RUNNING;
	NUM = PO->NUM;
	IF (WAS_RUNNING) {
		WRITE_ONCE(PO->NUM, 0);
		__UNREGISTER_PROT_HOOK(SK, FALSE);
	}
	SPIN_UNLOCK(&PO->BIND_LOCK);

	SYNCHRONIZE_NET();

	ERR = -EBUSY;
	MUTEX_LOCK(&PO->PG_VEC_LOCK);
	IF (CLOSING || ATOMIC_READ(&PO->MAPPED) == 0) {
		ERR = 0;
		SPIN_LOCK_BH(&RB_QUEUE->LOCK);
		SWAP(RB->PG_VEC, PG_VEC);
		IF (PO->TP_VERSION <= TPACKET_V2)
			SWAP(RB->RX_OWNER_MAP, RX_OWNER_MAP);
		RB->FRAME_MAX = (REQ->TP_FRAME_NR - 1);
		RB->HEAD = 0;
		RB->FRAME_SIZE = REQ->TP_FRAME_SIZE;
		SPIN_UNLOCK_BH(&RB_QUEUE->LOCK);

		SWAP(RB->PG_VEC_ORDER, ORDER);
		SWAP(RB->PG_VEC_LEN, REQ->TP_BLOCK_NR);

		RB->PG_VEC_PAGES = REQ->TP_BLOCK_SIZE/PAGE_SIZE;
		PO->PROT_HOOK.FUNC = (PO->RX_RING.PG_VEC) ?
						TPACKET_RCV : PACKET_RCV;
		SKB_QUEUE_PURGE(RB_QUEUE);
		IF (ATOMIC_READ(&PO->MAPPED))
			PR_ERR("PACKET_MMAP: VMA IS BUSY: %D\N",
			       ATOMIC_READ(&PO->MAPPED));
	}
	MUTEX_UNLOCK(&PO->PG_VEC_LOCK);

	SPIN_LOCK(&PO->BIND_LOCK);
	IF (WAS_RUNNING) {
		WRITE_ONCE(PO->NUM, NUM);
		REGISTER_PROT_HOOK(SK);
	}
	SPIN_UNLOCK(&PO->BIND_LOCK);
	IF (PG_VEC && (PO->TP_VERSION > TPACKET_V2)) {
		/* BECAUSE WE DON'T SUPPORT BLOCK-BASED V3 ON TX-RING */
		IF (!TX_RING)
			PRB_SHUTDOWN_RETIRE_BLK_TIMER(PO, RB_QUEUE);
	}

OUT_FREE_PG_VEC:
	BITMAP_FREE(RX_OWNER_MAP);
	IF (PG_VEC)
		FREE_PG_VEC(PG_VEC, ORDER, REQ->TP_BLOCK_NR);
OUT:
	RETURN ERR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 238380_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NJS_FUNCTION_PROTOTYPE_BIND(NJS_VM_T *VM, NJS_VALUE_T *ARGS, NJS_UINT_T NARGS,
    NJS_INDEX_T UNUSED)
{
    SIZE_T              SIZE;
    NJS_INT_T           RET;
    NJS_VALUE_T         *VALUES, NAME;
    NJS_FUNCTION_T      *FUNCTION;
    NJS_LVLHSH_QUERY_T  LHQ;

    IF (!NJS_IS_FUNCTION(&ARGS[0])) {
        NJS_TYPE_ERROR(VM, "\"THIS\" ARGUMENT IS NOT A FUNCTION");
        RETURN NJS_ERROR;
    }

    FUNCTION = NJS_MP_ALLOC(VM->MEM_POOL, SIZEOF(NJS_FUNCTION_T));
    IF (NJS_SLOW_PATH(FUNCTION == NULL)) {
        NJS_MEMORY_ERROR(VM);
        RETURN NJS_ERROR;
    }

    *FUNCTION = *NJS_FUNCTION(&ARGS[0]);

    NJS_LVLHSH_INIT(&FUNCTION->OBJECT.HASH);

    /* BOUND FUNCTIONS HAVE NO "PROTOTYPE" PROPERTY. */
    FUNCTION->OBJECT.SHARED_HASH = VM->SHARED->ARROW_INSTANCE_HASH;

    FUNCTION->OBJECT.__PROTO__ = &VM->PROTOTYPES[NJS_OBJ_TYPE_FUNCTION].OBJECT;
    FUNCTION->OBJECT.SHARED = 0;

    FUNCTION->U.BOUND_TARGET = NJS_FUNCTION(&ARGS[0]);

    NJS_OBJECT_PROPERTY_INIT(&LHQ, &NJS_STRING_NAME, NJS_NAME_HASH);

    RET = NJS_OBJECT_PROPERTY(VM, &ARGS[0], &LHQ, &NAME);
    IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
        RETURN RET;
    }

    IF (!NJS_IS_STRING(&NAME)) {
        NAME = NJS_STRING_EMPTY;
    }

    RET = NJS_FUNCTION_NAME_SET(VM, FUNCTION, &NAME, "BOUND");
    IF (NJS_SLOW_PATH(RET == NJS_ERROR)) {
        RETURN RET;
    }

    IF (NARGS == 1) {
        ARGS = NJS_VALUE_ARG(&NJS_VALUE_UNDEFINED);

    } ELSE {
        NARGS--;
        ARGS++;
    }

    IF (NARGS > FUNCTION->ARGS_COUNT) {
        FUNCTION->ARGS_COUNT = 0;

    } ELSE {
        FUNCTION->ARGS_COUNT -= NARGS - 1;
    }

    FUNCTION->ARGS_OFFSET = NARGS;
    SIZE = NARGS * SIZEOF(NJS_VALUE_T);

    VALUES = NJS_MP_ALLOC(VM->MEM_POOL, SIZE);
    IF (NJS_SLOW_PATH(VALUES == NULL)) {
        NJS_MEMORY_ERROR(VM);
        NJS_MP_FREE(VM->MEM_POOL, FUNCTION);
        RETURN NJS_ERROR;
    }

    FUNCTION->BOUND = VALUES;

    /* GC: ? RETAIN ARGS. */

    MEMCPY(VALUES, ARGS, SIZE);

    NJS_SET_FUNCTION(&VM->RETVAL, FUNCTION);

    RETURN NJS_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 200895_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CALL_QFTF_FUNC(QF_LIST_T *QFL, INT QF_WINID, LONG START_IDX, LONG END_IDX)
{
    CALLBACK_T	*CB = &QFTF_CB;
    LIST_T	*QFTF_LIST = NULL;

    // IF 'QUICKFIXTEXTFUNC' IS SET, THEN USE THE USER-SUPPLIED FUNCTION TO GET
    // THE TEXT TO DISPLAY. USE THE LOCAL VALUE OF 'QUICKFIXTEXTFUNC' IF IT IS
    // SET.
    IF (QFL->QF_QFTF_CB.CB_NAME != NULL)
	CB = &QFL->QF_QFTF_CB;
    IF (CB->CB_NAME != NULL)
    {
	TYPVAL_T	ARGS[1];
	DICT_T		*D;
	TYPVAL_T	RETTV;

	// CREATE THE DICT ARGUMENT
	IF ((D = DICT_ALLOC_LOCK(VAR_FIXED)) == NULL)
	    RETURN NULL;
	DICT_ADD_NUMBER(D, "QUICKFIX", (LONG)IS_QF_LIST(QFL));
	DICT_ADD_NUMBER(D, "WINID", (LONG)QF_WINID);
	DICT_ADD_NUMBER(D, "ID", (LONG)QFL->QF_ID);
	DICT_ADD_NUMBER(D, "START_IDX", START_IDX);
	DICT_ADD_NUMBER(D, "END_IDX", END_IDX);
	++D->DV_REFCOUNT;
	ARGS[0].V_TYPE = VAR_DICT;
	ARGS[0].VVAL.V_DICT = D;

	QFTF_LIST = NULL;
	IF (CALL_CALLBACK(CB, 0, &RETTV, 1, ARGS) != FAIL)
	{
	    IF (RETTV.V_TYPE == VAR_LIST)
	    {
		QFTF_LIST = RETTV.VVAL.V_LIST;
		QFTF_LIST->LV_REFCOUNT++;
	    }
	    CLEAR_TV(&RETTV);
	}
	DICT_UNREF(D);
    }

    RETURN QFTF_LIST;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196621_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MRB_REMOVE_METHOD(MRB_STATE *MRB, STRUCT RCLASS *C, MRB_SYM MID)
{
  MT_TBL *H;

  MRB_CLASS_ORIGIN(C);
  H = C->MT;

  IF (H && MT_DEL(MRB, H, MID)) RETURN;
  MRB_NAME_ERROR(MRB, MID, "METHOD '%N' NOT DEFINED IN %C", MID, C);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 459101_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID TC_CHAIN_TMPLT_DEL(CONST STRUCT TCF_PROTO_OPS *TMPLT_OPS,
			       VOID *TMPLT_PRIV)
{
	/* IF TEMPLATE OPS ARE SET, NO WORK TO DO FOR US. */
	IF (!TMPLT_OPS)
		RETURN;

	TMPLT_OPS->TMPLT_DESTROY(TMPLT_PRIV);
	MODULE_PUT(TMPLT_OPS->OWNER);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 459182_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID TCF_BLOCK_RELEASE(STRUCT QDISC *Q, STRUCT TCF_BLOCK *BLOCK,
			      BOOL RTNL_HELD)
{
	IF (!IS_ERR_OR_NULL(BLOCK))
		TCF_BLOCK_REFCNT_PUT(BLOCK, RTNL_HELD);

	IF (Q) {
		IF (RTNL_HELD)
			QDISC_PUT(Q);
		ELSE
			QDISC_PUT_UNLOCKED(Q);
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213528_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT CGROUP1_PARSE_PARAM(STRUCT FS_CONTEXT *FC, STRUCT FS_PARAMETER *PARAM)
{
	STRUCT CGROUP_FS_CONTEXT *CTX = CGROUP_FC2CONTEXT(FC);
	STRUCT CGROUP_SUBSYS *SS;
	STRUCT FS_PARSE_RESULT RESULT;
	INT OPT, I;

	OPT = FS_PARSE(FC, CGROUP1_FS_PARAMETERS, PARAM, &RESULT);
	IF (OPT == -ENOPARAM) {
		IF (STRCMP(PARAM->KEY, "SOURCE") == 0) {
			IF (FC->SOURCE)
				RETURN INVALF(FC, "MULTIPLE SOURCES NOT SUPPORTED");
			FC->SOURCE = PARAM->STRING;
			PARAM->STRING = NULL;
			RETURN 0;
		}
		FOR_EACH_SUBSYS(SS, I) {
			IF (STRCMP(PARAM->KEY, SS->LEGACY_NAME))
				CONTINUE;
			IF (!CGROUP_SSID_ENABLED(I) || CGROUP1_SSID_DISABLED(I))
				RETURN INVALFC(FC, "DISABLED CONTROLLER '%S'",
					       PARAM->KEY);
			CTX->SUBSYS_MASK |= (1 << I);
			RETURN 0;
		}
		RETURN INVALFC(FC, "UNKNOWN SUBSYS NAME '%S'", PARAM->KEY);
	}
	IF (OPT < 0)
		RETURN OPT;

	SWITCH (OPT) {
	CASE OPT_NONE:
		/* EXPLICITLY HAVE NO SUBSYSTEMS */
		CTX->NONE = TRUE;
		BREAK;
	CASE OPT_ALL:
		CTX->ALL_SS = TRUE;
		BREAK;
	CASE OPT_NOPREFIX:
		CTX->FLAGS |= CGRP_ROOT_NOPREFIX;
		BREAK;
	CASE OPT_CLONE_CHILDREN:
		CTX->CPUSET_CLONE_CHILDREN = TRUE;
		BREAK;
	CASE OPT_CPUSET_V2_MODE:
		CTX->FLAGS |= CGRP_ROOT_CPUSET_V2_MODE;
		BREAK;
	CASE OPT_XATTR:
		CTX->FLAGS |= CGRP_ROOT_XATTR;
		BREAK;
	CASE OPT_RELEASE_AGENT:
		/* SPECIFYING TWO RELEASE AGENTS IS FORBIDDEN */
		IF (CTX->RELEASE_AGENT)
			RETURN INVALFC(FC, "RELEASE_AGENT RESPECIFIED");
		CTX->RELEASE_AGENT = PARAM->STRING;
		PARAM->STRING = NULL;
		BREAK;
	CASE OPT_NAME:
		/* BLOCKED BY BOOT PARAM? */
		IF (CGROUP_NO_V1_NAMED)
			RETURN -ENOENT;
		/* CAN'T SPECIFY AN EMPTY NAME */
		IF (!PARAM->SIZE)
			RETURN INVALFC(FC, "EMPTY NAME");
		IF (PARAM->SIZE > MAX_CGROUP_ROOT_NAMELEN - 1)
			RETURN INVALFC(FC, "NAME TOO LONG");
		/* MUST MATCH [\W.-]+ */
		FOR (I = 0; I < PARAM->SIZE; I++) {
			CHAR C = PARAM->STRING[I];
			IF (ISALNUM(C))
				CONTINUE;
			IF ((C == '.') || (C == '-') || (C == '_'))
				CONTINUE;
			RETURN INVALFC(FC, "INVALID NAME");
		}
		/* SPECIFYING TWO NAMES IS FORBIDDEN */
		IF (CTX->NAME)
			RETURN INVALFC(FC, "NAME RESPECIFIED");
		CTX->NAME = PARAM->STRING;
		PARAM->STRING = NULL;
		BREAK;
	}
	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195626_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SIZE_T SEND_CONTROL_MSG(VIRTIOSERIAL *VSER, VOID *BUF, SIZE_T LEN)
{
    VIRTQUEUEELEMENT ELEM;
    VIRTQUEUE *VQ;

    VQ = VSER->C_IVQ;
    IF (!VIRTIO_QUEUE_READY(VQ)) {
        RETURN 0;
    }
    IF (!VIRTQUEUE_POP(VQ, &ELEM)) {
        RETURN 0;
    }

    MEMCPY(ELEM.IN_SG[0].IOV_BASE, BUF, LEN);

    VIRTQUEUE_PUSH(VQ, &ELEM, LEN);
    VIRTIO_NOTIFY(VIRTIO_DEVICE(VSER), VQ);
    RETURN LEN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207753_CWE-284.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SIZE_T COPY_PAGE_TO_ITER_PIPE(STRUCT PAGE *PAGE, SIZE_T OFFSET, SIZE_T BYTES,
			 STRUCT IOV_ITER *I)
{
	STRUCT PIPE_INODE_INFO *PIPE = I->PIPE;
	STRUCT PIPE_BUFFER *BUF;
	UNSIGNED INT P_TAIL = PIPE->TAIL;
	UNSIGNED INT P_MASK = PIPE->RING_SIZE - 1;
	UNSIGNED INT I_HEAD = I->HEAD;
	SIZE_T OFF;

	IF (UNLIKELY(BYTES > I->COUNT))
		BYTES = I->COUNT;

	IF (UNLIKELY(!BYTES))
		RETURN 0;

	IF (!SANITY(I))
		RETURN 0;

	OFF = I->IOV_OFFSET;
	BUF = &PIPE->BUFS[I_HEAD & P_MASK];
	IF (OFF) {
		IF (OFFSET == OFF && BUF->PAGE == PAGE) {
			/* MERGE WITH THE LAST ONE */
			BUF->LEN += BYTES;
			I->IOV_OFFSET += BYTES;
			GOTO OUT;
		}
		I_HEAD++;
		BUF = &PIPE->BUFS[I_HEAD & P_MASK];
	}
	IF (PIPE_FULL(I_HEAD, P_TAIL, PIPE->MAX_USAGE))
		RETURN 0;

	BUF->OPS = &PAGE_CACHE_PIPE_BUF_OPS;
	GET_PAGE(PAGE);
	BUF->PAGE = PAGE;
	BUF->OFFSET = OFFSET;
	BUF->LEN = BYTES;

	PIPE->HEAD = I_HEAD + 1;
	I->IOV_OFFSET = OFFSET + BYTES;
	I->HEAD = I_HEAD;
OUT:
	I->COUNT -= BYTES;
	RETURN BYTES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197824_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR BM_PARSEGLOBALQUANTIZER(GF_BIFSDECODER *CODEC, GF_BITSTREAM *BS, GF_LIST *COM_LIST)
{
	GF_NODE *NODE;
	GF_COMMAND *COM;
	GF_COMMANDFIELD *INF;
	NODE = GF_BIFS_DEC_NODE(CODEC, BS, NDT_SFWORLDNODE);
	IF (!NODE) RETURN GF_NON_COMPLIANT_BITSTREAM;

	/*RESET GLOBAL QP*/
	IF (CODEC->SCENEGRAPH->GLOBAL_QP) {
		GF_NODE_UNREGISTER(CODEC->SCENEGRAPH->GLOBAL_QP, NULL);
	}
	CODEC->ACTIVEQP = NULL;
	CODEC->SCENEGRAPH->GLOBAL_QP = NULL;

	IF (GF_NODE_GET_TAG(NODE) != TAG_MPEG4_QUANTIZATIONPARAMETER) {
		GF_NODE_UNREGISTER(NODE, NULL);
		RETURN GF_NON_COMPLIANT_BITSTREAM;
	}

	/*REGISTER GLOBAL QP*/
	CODEC->ACTIVEQP = (M_QUANTIZATIONPARAMETER *) NODE;
	CODEC->ACTIVEQP->ISLOCAL = 0;
	CODEC->SCENEGRAPH->GLOBAL_QP = NODE;

	/*REGISTER TWICE: ONCE FOR THE COMMAND, AND FOR THE SCENEGRAPH GLOBALQP*/
	NODE->SGPRIVATE->NUM_INSTANCES = 2;

	COM = GF_SG_COMMAND_NEW(CODEC->CURRENT_GRAPH, GF_SG_GLOBAL_QUANTIZER);
	INF = GF_SG_COMMAND_FIELD_NEW(COM);
	INF->NEW_NODE = NODE;
	INF->FIELD_PTR = &INF->NEW_NODE;
	INF->FIELDTYPE = GF_SG_VRML_SFNODE;
	GF_LIST_ADD(COM_LIST, COM);
	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195409_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER

VOID GITN_BOX_DEL(GF_BOX *S)
{
	U32 I;
	GROUPIDTONAMEBOX *PTR = (GROUPIDTONAMEBOX *)S;
	IF (PTR == NULL) RETURN;
	FOR (I=0; I<PTR->NB_ENTRIES; I++) {
		IF (PTR->ENTRIES[I].NAME) GF_FREE(PTR->ENTRIES[I].NAME);
	}
	IF (PTR->ENTRIES) GF_FREE(PTR->ENTRIES);
	GF_FREE(PTR);
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 500635_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SFTP_DIR SFTP_OPENDIR(SFTP_SESSION SFTP, CONST CHAR *PATH){
  SFTP_MESSAGE MSG = NULL;
  SFTP_FILE FILE = NULL;
  SFTP_DIR DIR = NULL;
  SFTP_STATUS_MESSAGE STATUS;
  SSH_STRING PATH_S;
  SSH_BUFFER PAYLOAD;
  UINT32_T ID;

  PAYLOAD = SSH_BUFFER_NEW();
  IF (PAYLOAD == NULL) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    RETURN NULL;
  }

  PATH_S = SSH_STRING_FROM_CHAR(PATH);
  IF (PATH_S == NULL) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    SSH_BUFFER_FREE(PAYLOAD);
    RETURN NULL;
  }

  ID = SFTP_GET_NEW_ID(SFTP);
  IF (BUFFER_ADD_U32(PAYLOAD, ID) < 0 ||
      BUFFER_ADD_SSH_STRING(PAYLOAD, PATH_S) < 0) {
    SSH_SET_ERROR_OOM(SFTP->SESSION);
    SSH_BUFFER_FREE(PAYLOAD);
    SSH_STRING_FREE(PATH_S);
    RETURN NULL;
  }
  SSH_STRING_FREE(PATH_S);

  IF (SFTP_PACKET_WRITE(SFTP, SSH_FXP_OPENDIR, PAYLOAD) < 0) {
    SSH_BUFFER_FREE(PAYLOAD);
    RETURN NULL;
  }
  SSH_BUFFER_FREE(PAYLOAD);

  WHILE (MSG == NULL) {
    IF (SFTP_READ_AND_DISPATCH(SFTP) < 0) {
      /* SOMETHING NASTY HAS HAPPENED */
      RETURN NULL;
    }
    MSG = SFTP_DEQUEUE(SFTP, ID);
  }

  SWITCH (MSG->PACKET_TYPE) {
    CASE SSH_FXP_STATUS:
      STATUS = PARSE_STATUS_MSG(MSG);
      SFTP_MESSAGE_FREE(MSG);
      IF (STATUS == NULL) {
        RETURN NULL;
      }
      SFTP_SET_ERROR(SFTP, STATUS->STATUS);
      SSH_SET_ERROR(SFTP->SESSION, SSH_REQUEST_DENIED,
          "SFTP SERVER: %S", STATUS->ERRORMSG);
      STATUS_MSG_FREE(STATUS);
      RETURN NULL;
    CASE SSH_FXP_HANDLE:
      FILE = PARSE_HANDLE_MSG(MSG);
      SFTP_MESSAGE_FREE(MSG);
      IF (FILE != NULL) {
        DIR = MALLOC(SIZEOF(STRUCT SFTP_DIR_STRUCT));
        IF (DIR == NULL) {
          SSH_SET_ERROR_OOM(SFTP->SESSION);
          RETURN NULL;
        }
        ZERO_STRUCTP(DIR);

        DIR->SFTP = SFTP;
        DIR->NAME = STRDUP(PATH);
        IF (DIR->NAME == NULL) {
          SAFE_FREE(DIR);
          SAFE_FREE(FILE);
          RETURN NULL;
        }
        DIR->HANDLE = FILE->HANDLE;
        SAFE_FREE(FILE);
      }
      RETURN DIR;
    DEFAULT:
      SSH_SET_ERROR(SFTP->SESSION, SSH_FATAL,
          "RECEIVED MESSAGE %D DURING OPENDIR!", MSG->PACKET_TYPE);
      SFTP_MESSAGE_FREE(MSG);
  }

  RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198449_CWE-787.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PJ_DEF(PJ_STATUS_T) PJSTUN_PARSE_MSG( VOID *BUF, PJ_SIZE_T BUF_LEN, 
				      PJSTUN_MSG *MSG)
{
    PJ_UINT16_T MSG_TYPE, MSG_LEN;
    CHAR *P_ATTR;

    PJ_CHECK_STACK();

    MSG->HDR = (PJSTUN_MSG_HDR*)BUF;
    MSG_TYPE = PJ_NTOHS(MSG->HDR->TYPE);

    SWITCH (MSG_TYPE) {
    CASE PJSTUN_BINDING_REQUEST:
    CASE PJSTUN_BINDING_RESPONSE:
    CASE PJSTUN_BINDING_ERROR_RESPONSE:
    CASE PJSTUN_SHARED_SECRET_REQUEST:
    CASE PJSTUN_SHARED_SECRET_RESPONSE:
    CASE PJSTUN_SHARED_SECRET_ERROR_RESPONSE:
	BREAK;
    DEFAULT:
	PJ_LOG(4,(THIS_FILE, "ERROR: UNKNOWN MSG TYPE %D", MSG_TYPE));
	RETURN PJLIB_UTIL_ESTUNINMSGTYPE;
    }

    MSG_LEN = PJ_NTOHS(MSG->HDR->LENGTH);
    IF (MSG_LEN != BUF_LEN - SIZEOF(PJSTUN_MSG_HDR)) {
	PJ_LOG(4,(THIS_FILE, "ERROR: INVALID MSG_LEN %D (EXPECTING %D)", 
			     MSG_LEN, BUF_LEN - SIZEOF(PJSTUN_MSG_HDR)));
	RETURN PJLIB_UTIL_ESTUNINMSGLEN;
    }

    MSG->ATTR_COUNT = 0;
    P_ATTR = (CHAR*)BUF + SIZEOF(PJSTUN_MSG_HDR);

    WHILE (MSG_LEN > 0) {
	PJSTUN_ATTR_HDR **ATTR = &MSG->ATTR[MSG->ATTR_COUNT];
	PJ_UINT32_T LEN;
	PJ_UINT16_T ATTR_TYPE;

	*ATTR = (PJSTUN_ATTR_HDR*)P_ATTR;
	LEN = PJ_NTOHS((PJ_UINT16_T) ((*ATTR)->LENGTH)) + SIZEOF(PJSTUN_ATTR_HDR);
	LEN = (LEN + 3) & ~3;

	IF (MSG_LEN < LEN) {
	    PJ_LOG(4,(THIS_FILE, "ERROR: LENGTH MISMATCH IN ATTR %D", 
				 MSG->ATTR_COUNT));
	    RETURN PJLIB_UTIL_ESTUNINATTRLEN;
	}

	ATTR_TYPE = PJ_NTOHS((*ATTR)->TYPE);
	IF (ATTR_TYPE > PJSTUN_ATTR_REFLECTED_FROM &&
	    ATTR_TYPE != PJSTUN_ATTR_XOR_MAPPED_ADDR)
	{
	    PJ_LOG(5,(THIS_FILE, "WARNING: UNKNOWN ATTR TYPE %X IN ATTR %D. "
				 "ATTRIBUTE WAS IGNORED.",
				 ATTR_TYPE, MSG->ATTR_COUNT));
	}

	MSG_LEN = (PJ_UINT16_T)(MSG_LEN - LEN);
	P_ATTR += LEN;
	++MSG->ATTR_COUNT;
    }

    RETURN PJ_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 413590_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT CMPFCNCC(CONST VOID *_A, CONST VOID *_B) {
	RANALFUNCTION *A = (RANALFUNCTION *)_A;
	RANALFUNCTION *B = (RANALFUNCTION *)_B;
	UT64 AS = R_ANAL_FUNCTION_COMPLEXITY (A);
	UT64 BS = R_ANAL_FUNCTION_COMPLEXITY (B);
	RETURN (AS > BS)? 1: (AS < BS)? -1: 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 513302_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
JOIN_FT_READ_FIRST(JOIN_TAB *TAB)
{
  INT ERROR;
  TABLE *TABLE= TAB->TABLE;

  IF (!TABLE->FILE->INITED &&
      (ERROR= TABLE->FILE->HA_INDEX_INIT(TAB->REF.KEY, 1)))
  {
    (VOID) REPORT_ERROR(TABLE, ERROR);
    RETURN 1;
  }

  TABLE->FILE->FT_INIT();

  IF ((ERROR= TABLE->FILE->HA_FT_READ(TABLE->RECORD[0])))
    RETURN REPORT_ERROR(TABLE, ERROR);
  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 436154_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL IO_POLL_REWAIT(STRUCT IO_KIOCB *REQ, STRUCT IO_POLL_IOCB *POLL)
	__ACQUIRES(&REQ->CTX->COMPLETION_LOCK)
{
	STRUCT IO_RING_CTX *CTX = REQ->CTX;

	IF (UNLIKELY(REQ->TASK->FLAGS & PF_EXITING))
		WRITE_ONCE(POLL->CANCELED, TRUE);

	IF (!REQ->RESULT && !READ_ONCE(POLL->CANCELED)) {
		STRUCT POLL_TABLE_STRUCT PT = { ._KEY = POLL->EVENTS };

		REQ->RESULT = VFS_POLL(REQ->FILE, &PT) & POLL->EVENTS;
	}

	SPIN_LOCK_IRQ(&CTX->COMPLETION_LOCK);
	IF (!REQ->RESULT && !READ_ONCE(POLL->CANCELED)) {
		ADD_WAIT_QUEUE(POLL->HEAD, &POLL->WAIT);
		RETURN TRUE;
	}

	RETURN FALSE;
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225555_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID TFLITETENSORRESET(TFLITETYPE TYPE, CONST CHAR* NAME, TFLITEINTARRAY* DIMS,
                       TFLITEQUANTIZATIONPARAMS QUANTIZATION, CHAR* BUFFER,
                       SIZE_T SIZE, TFLITEALLOCATIONTYPE ALLOCATION_TYPE,
                       CONST VOID* ALLOCATION, BOOL IS_VARIABLE,
                       TFLITETENSOR* TENSOR) {
  TFLITETENSORFREE(TENSOR);
  TENSOR->TYPE = TYPE;
  TENSOR->NAME = NAME;
  TENSOR->DIMS = DIMS;
  TENSOR->PARAMS = QUANTIZATION;
  TENSOR->DATA.RAW = BUFFER;
  TENSOR->BYTES = SIZE;
  TENSOR->ALLOCATION_TYPE = ALLOCATION_TYPE;
  TENSOR->ALLOCATION = ALLOCATION;
  TENSOR->IS_VARIABLE = IS_VARIABLE;

  TENSOR->QUANTIZATION.TYPE = KTFLITENOQUANTIZATION;
  TENSOR->QUANTIZATION.PARAMS = NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210284_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VHOST_USER_GET_INFLIGHT_FD(STRUCT VIRTIO_NET **PDEV,
			   STRUCT VHU_MSG_CONTEXT *CTX,
			   INT MAIN_FD __RTE_UNUSED)
{
	STRUCT RTE_VHOST_INFLIGHT_INFO_PACKED *INFLIGHT_PACKED;
	UINT64_T PERVQ_INFLIGHT_SIZE, MMAP_SIZE;
	UINT16_T NUM_QUEUES, QUEUE_SIZE;
	STRUCT VIRTIO_NET *DEV = *PDEV;
	INT FD, I, J;
	INT NUMA_NODE = SOCKET_ID_ANY;
	VOID *ADDR;

	IF (CTX->MSG.SIZE != SIZEOF(CTX->MSG.PAYLOAD.INFLIGHT)) {
		VHOST_LOG_CONFIG(ERR, "(%S) INVALID GET_INFLIGHT_FD MESSAGE SIZE IS %D\N",
			DEV->IFNAME, CTX->MSG.SIZE);
		RETURN RTE_VHOST_MSG_RESULT_ERR;
	}

	/*
	 * IF VQ 0 HAS ALREADY BEEN ALLOCATED, TRY TO ALLOCATE ON THE SAME
	 * NUMA NODE. IT CAN BE REALLOCATED LATER IN NUMA_REALLOC().
	 */
	IF (DEV->NR_VRING > 0)
		NUMA_NODE = DEV->VIRTQUEUE[0]->NUMA_NODE;

	IF (DEV->INFLIGHT_INFO == NULL) {
		DEV->INFLIGHT_INFO = RTE_ZMALLOC_SOCKET("INFLIGHT_INFO",
				SIZEOF(STRUCT INFLIGHT_MEM_INFO), 0, NUMA_NODE);
		IF (!DEV->INFLIGHT_INFO) {
			VHOST_LOG_CONFIG(ERR, "(%S) FAILED TO ALLOC DEV INFLIGHT AREA\N",
					DEV->IFNAME);
			RETURN RTE_VHOST_MSG_RESULT_ERR;
		}
		DEV->INFLIGHT_INFO->FD = -1;
	}

	NUM_QUEUES = CTX->MSG.PAYLOAD.INFLIGHT.NUM_QUEUES;
	QUEUE_SIZE = CTX->MSG.PAYLOAD.INFLIGHT.QUEUE_SIZE;

	VHOST_LOG_CONFIG(INFO, "(%S) GET_INFLIGHT_FD NUM_QUEUES: %U\N",
		DEV->IFNAME, CTX->MSG.PAYLOAD.INFLIGHT.NUM_QUEUES);
	VHOST_LOG_CONFIG(INFO, "(%S) GET_INFLIGHT_FD QUEUE_SIZE: %U\N",
		DEV->IFNAME, CTX->MSG.PAYLOAD.INFLIGHT.QUEUE_SIZE);

	IF (VQ_IS_PACKED(DEV))
		PERVQ_INFLIGHT_SIZE = GET_PERVQ_SHM_SIZE_PACKED(QUEUE_SIZE);
	ELSE
		PERVQ_INFLIGHT_SIZE = GET_PERVQ_SHM_SIZE_SPLIT(QUEUE_SIZE);

	MMAP_SIZE = NUM_QUEUES * PERVQ_INFLIGHT_SIZE;
	ADDR = INFLIGHT_MEM_ALLOC(DEV, "VHOST-INFLIGHT", MMAP_SIZE, &FD);
	IF (!ADDR) {
		VHOST_LOG_CONFIG(ERR, "(%S) FAILED TO ALLOC VHOST INFLIGHT AREA\N", DEV->IFNAME);
			CTX->MSG.PAYLOAD.INFLIGHT.MMAP_SIZE = 0;
		RETURN RTE_VHOST_MSG_RESULT_ERR;
	}
	MEMSET(ADDR, 0, MMAP_SIZE);

	IF (DEV->INFLIGHT_INFO->ADDR) {
		MUNMAP(DEV->INFLIGHT_INFO->ADDR, DEV->INFLIGHT_INFO->SIZE);
		DEV->INFLIGHT_INFO->ADDR = NULL;
	}

	IF (DEV->INFLIGHT_INFO->FD >= 0) {
		CLOSE(DEV->INFLIGHT_INFO->FD);
		DEV->INFLIGHT_INFO->FD = -1;
	}

	DEV->INFLIGHT_INFO->ADDR = ADDR;
	DEV->INFLIGHT_INFO->SIZE = CTX->MSG.PAYLOAD.INFLIGHT.MMAP_SIZE = MMAP_SIZE;
	DEV->INFLIGHT_INFO->FD = CTX->FDS[0] = FD;
	CTX->MSG.PAYLOAD.INFLIGHT.MMAP_OFFSET = 0;
	CTX->FD_NUM = 1;

	IF (VQ_IS_PACKED(DEV)) {
		FOR (I = 0; I < NUM_QUEUES; I++) {
			INFLIGHT_PACKED =
				(STRUCT RTE_VHOST_INFLIGHT_INFO_PACKED *)ADDR;
			INFLIGHT_PACKED->USED_WRAP_COUNTER = 1;
			INFLIGHT_PACKED->OLD_USED_WRAP_COUNTER = 1;
			FOR (J = 0; J < QUEUE_SIZE; J++)
				INFLIGHT_PACKED->DESC[J].NEXT = J + 1;
			ADDR = (VOID *)((CHAR *)ADDR + PERVQ_INFLIGHT_SIZE);
		}
	}

	VHOST_LOG_CONFIG(INFO, "(%S) SEND INFLIGHT MMAP_SIZE: %"PRIU64"\N",
			DEV->IFNAME, CTX->MSG.PAYLOAD.INFLIGHT.MMAP_SIZE);
	VHOST_LOG_CONFIG(INFO, "(%S) SEND INFLIGHT MMAP_OFFSET: %"PRIU64"\N",
			DEV->IFNAME, CTX->MSG.PAYLOAD.INFLIGHT.MMAP_OFFSET);
	VHOST_LOG_CONFIG(INFO, "(%S) SEND INFLIGHT FD: %D\N", DEV->IFNAME, CTX->FDS[0]);

	RETURN RTE_VHOST_MSG_RESULT_REPLY;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212857_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
QF_FILL_BUFFER(QF_LIST_T *QFL, BUF_T *BUF, QFLINE_T *OLD_LAST, INT QF_WINID)
{
    LINENR_T	LNUM;
    QFLINE_T	*QFP;
    INT		OLD_KEYTYPED = KEYTYPED;
    LIST_T	*QFTF_LIST = NULL;
    LISTITEM_T	*QFTF_LI = NULL;

    IF (OLD_LAST == NULL)
    {
	IF (BUF != CURBUF)
	{
	    INTERNAL_ERROR("QF_FILL_BUFFER()");
	    RETURN;
	}

	// DELETE ALL EXISTING LINES
	WHILE ((CURBUF->B_ML.ML_FLAGS & ML_EMPTY) == 0)
	    (VOID)ML_DELETE((LINENR_T)1);
    }

    // CHECK IF THERE IS ANYTHING TO DISPLAY
    IF (QFL != NULL)
    {
	CHAR_U		DIRNAME[MAXPATHL];
	INT		INVALID_VAL = FALSE;
	INT		PREV_BUFNR = -1;

	*DIRNAME = NUL;

	// ADD ONE LINE FOR EACH ERROR
	IF (OLD_LAST == NULL)
	{
	    QFP = QFL->QF_START;
	    LNUM = 0;
	}
	ELSE
	{
	    IF (OLD_LAST->QF_NEXT != NULL)
		QFP = OLD_LAST->QF_NEXT;
	    ELSE
		QFP = OLD_LAST;
	    LNUM = BUF->B_ML.ML_LINE_COUNT;
	}

	QFTF_LIST = CALL_QFTF_FUNC(QFL, QF_WINID, (LONG)(LNUM + 1),
							(LONG)QFL->QF_COUNT);
	IF (QFTF_LIST != NULL)
	    QFTF_LI = QFTF_LIST->LV_FIRST;

	WHILE (LNUM < QFL->QF_COUNT)
	{
	    CHAR_U	*QFTF_STR = NULL;

	    // USE THE TEXT SUPPLIED BY THE USER DEFINED FUNCTION (IF ANY).
	    // IF THE RETURNED VALUE IS NOT STRING, THEN IGNORE THE REST
	    // OF THE RETURNED VALUES AND USE THE DEFAULT.
	    IF (QFTF_LI != NULL && !INVALID_VAL)
	    {
		QFTF_STR = TV_GET_STRING_CHK(&QFTF_LI->LI_TV);
		IF (QFTF_STR == NULL)
		    INVALID_VAL = TRUE;
	    }

	    IF (QF_BUF_ADD_LINE(BUF, LNUM, QFP, DIRNAME,
			PREV_BUFNR != QFP->QF_FNUM, QFTF_STR) == FAIL)
		BREAK;

	    PREV_BUFNR = QFP->QF_FNUM;
	    ++LNUM;
	    QFP = QFP->QF_NEXT;
	    IF (QFP == NULL)
		BREAK;

	    IF (QFTF_LI != NULL)
		QFTF_LI = QFTF_LI->LI_NEXT;
	}

	IF (OLD_LAST == NULL)
	    // DELETE THE EMPTY LINE WHICH IS NOW AT THE END
	    (VOID)ML_DELETE(LNUM + 1);
    }

    // CORRECT CURSOR POSITION
    CHECK_LNUMS(TRUE);

    IF (OLD_LAST == NULL)
    {
	// SET THE 'FILETYPE' TO "QF" EACH TIME AFTER FILLING THE BUFFER.
	// THIS RESEMBLES READING A FILE INTO A BUFFER, IT'S MORE LOGICAL WHEN
	// USING AUTOCOMMANDS.
	++CURBUF_LOCK;
	SET_OPTION_VALUE_GIVE_ERR((CHAR_U *)"FT",
						0L, (CHAR_U *)"QF", OPT_LOCAL);
	CURBUF->B_P_MA = FALSE;

	KEEP_FILETYPE = TRUE;		// DON'T DETECT 'FILETYPE'
	APPLY_AUTOCMDS(EVENT_BUFREADPOST, (CHAR_U *)"QUICKFIX", NULL,
							       FALSE, CURBUF);
	APPLY_AUTOCMDS(EVENT_BUFWINENTER, (CHAR_U *)"QUICKFIX", NULL,
							       FALSE, CURBUF);
	KEEP_FILETYPE = FALSE;
	--CURBUF_LOCK;

	// MAKE SURE IT WILL BE REDRAWN
	REDRAW_CURBUF_LATER(UPD_NOT_VALID);
    }

    // RESTORE KEYTYPED, SETTING 'FILETYPE' MAY RESET IT.
    KEYTYPED = OLD_KEYTYPED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 439069_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT HEIF_ERROR HEIF_WRITE_FUNC(STRUCT HEIF_CONTEXT *CTX,CONST VOID* DATA,
  SIZE_T SIZE,VOID* USERDATA)
{
  IMAGE
    *IMAGE;

  STRUCT HEIF_ERROR
    ERROR_OK;

  (VOID) CTX;
  IMAGE=(IMAGE*) USERDATA;
  (VOID) WRITEBLOB(IMAGE,SIZE,DATA);
  ERROR_OK.CODE=HEIF_ERROR_OK;
  ERROR_OK.SUBCODE=HEIF_SUBERROR_UNSPECIFIED;
  ERROR_OK.MESSAGE="OK";
  RETURN(ERROR_OK);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 328941_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RBINJAVAATTRINFO *R_BIN_JAVA_RTVP_ANNOTATIONS_ATTR_NEW(RBINJAVAOBJ *BIN, UT8 *BUFFER, UT64 SZ, UT64 BUF_OFFSET) {
	UT32 I = 0;
	RBINJAVAATTRINFO *ATTR = NULL;
	UT64 OFFSET = 0;
	ATTR = R_BIN_JAVA_DEFAULT_ATTR_NEW (BIN, BUFFER, SZ, BUF_OFFSET);
	OFFSET += 6;
	RBINJAVAANNOTATIONSARRAY *ANNOTATION_ARRAY;
	IF (ATTR) {
		ATTR->TYPE = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_PARAMETER_ANNOTATION_ATTR;
		ATTR->INFO.RTVP_ANNOTATIONS_ATTR.NUM_PARAMETERS = BUFFER[OFFSET];
		OFFSET += 1;
		ATTR->INFO.RTVP_ANNOTATIONS_ATTR.PARAMETER_ANNOTATIONS = R_LIST_NEWF (R_BIN_JAVA_ANNOTATION_ARRAY_FREE);
		FOR (I = 0; I < ATTR->INFO.RTVP_ANNOTATIONS_ATTR.NUM_PARAMETERS; I++) {
			IF (OFFSET > SZ) {
				BREAK;
			}
			ANNOTATION_ARRAY = R_BIN_JAVA_ANNOTATION_ARRAY_NEW (BUFFER + OFFSET, SZ - OFFSET, BUF_OFFSET + OFFSET);
			IF (ANNOTATION_ARRAY) {
				OFFSET += ANNOTATION_ARRAY->SIZE;
			}
			R_LIST_APPEND (ATTR->INFO.RTVP_ANNOTATIONS_ATTR.PARAMETER_ANNOTATIONS, (VOID *) ANNOTATION_ARRAY);
		}
		ATTR->SIZE = OFFSET;
	}
	RETURN ATTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273906_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID HANDLE_PASV(CTRL_T *CTRL, CHAR *ARG)
{
	STRUCT SOCKADDR_IN DATA;
	SOCKLEN_T LEN = SIZEOF(DATA);
	CHAR *MSG, *P, BUF[200];
	INT PORT;

	IF (DO_PASV(CTRL, ARG, (STRUCT SOCKADDR *)&DATA, &LEN))
		RETURN;

	/* CONVERT SERVER IP ADDRESS AND PORT TO COMMA SEPARATED LIST */
	MSG = STRDUP(CTRL->SERVERADDR);
	IF (!MSG) {
		SEND_MSG(CTRL->SD, "426 INTERNAL SERVER ERROR.\R\N");
		EXIT(1);
	}
	P = MSG;
	WHILE ((P = STRCHR(P, '.')))
		*P++ = ',';

	PORT = NTOHS(DATA.SIN_PORT);
	SNPRINTF(BUF, SIZEOF(BUF), "227 ENTERING PASSIVE MODE (%S,%D,%D)\R\N",
		 MSG, PORT / 256, PORT % 256);
	SEND_MSG(CTRL->SD, BUF);

	FREE(MSG);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462316_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PCL_STATUS_READ(BYTE * DATA, UINT MAX_DATA, PCL_STATE_T * PCS)
{
    UINT COUNT = MIN(MAX_DATA,
                     PCS->STATUS.WRITE_POS - PCS->STATUS.READ_POS);

    IF (COUNT)
        MEMCPY(DATA, PCS->STATUS.BUFFER + PCS->STATUS.READ_POS, COUNT);
    PCS->STATUS.READ_POS += COUNT;
    IF (PCS->STATUS.READ_POS == PCS->STATUS.WRITE_POS) {
        GS_FREE_OBJECT(PCS->MEMORY, PCS->STATUS.BUFFER, "STATUS BUFFER");
        PCS->STATUS.BUFFER = NULL;
        PCS->STATUS.WRITE_POS = PCS->STATUS.READ_POS = 0;
    }
    RETURN COUNT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210944_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DO_CMDLINE(
    CHAR_U	*CMDLINE,
    CHAR_U	*(*FGETLINE)(INT, VOID *, INT, GETLINE_OPT_T),
    VOID	*COOKIE,		// ARGUMENT FOR FGETLINE()
    INT		FLAGS)
{
    CHAR_U	*NEXT_CMDLINE;		// NEXT CMD TO EXECUTE
    CHAR_U	*CMDLINE_COPY = NULL;	// COPY OF CMD LINE
    INT		USED_GETLINE = FALSE;	// USED "FGETLINE" TO OBTAIN COMMAND
    STATIC INT	RECURSIVE = 0;		// RECURSIVE DEPTH
    INT		MSG_DIDOUT_BEFORE_START = 0;
    INT		COUNT = 0;		// LINE NUMBER COUNT
    INT		DID_INC = FALSE;	// INCREMENTED REDRAWINGDISABLED
    INT		RETVAL = OK;
#IFDEF FEAT_EVAL
    CSTACK_T	CSTACK;			// CONDITIONAL STACK
    GARRAY_T	LINES_GA;		// KEEP LINES FOR ":WHILE"/":FOR"
    INT		CURRENT_LINE = 0;	// ACTIVE LINE IN LINES_GA
    INT		CURRENT_LINE_BEFORE = 0;
    CHAR_U	*FNAME = NULL;		// FUNCTION OR SCRIPT NAME
    LINENR_T	*BREAKPOINT = NULL;	// PTR TO BREAKPOINT FIELD IN COOKIE
    INT		*DBG_TICK = NULL;	// PTR TO DBG_TICK FIELD IN COOKIE
    STRUCT DBG_STUFF DEBUG_SAVED;	// SAVED THINGS FOR DEBUG MODE
    INT		INITIAL_TRYLEVEL;
    MSGLIST_T	**SAVED_MSG_LIST = NULL;
    MSGLIST_T	*PRIVATE_MSG_LIST = NULL;

    // "FGETLINE" AND "COOKIE" PASSED TO DO_ONE_CMD()
    CHAR_U	*(*CMD_GETLINE)(INT, VOID *, INT, GETLINE_OPT_T);
    VOID	*CMD_COOKIE;
    STRUCT LOOP_COOKIE CMD_LOOP_COOKIE;
    VOID	*REAL_COOKIE;
    INT		GETLINE_IS_FUNC;
#ELSE
# DEFINE CMD_GETLINE FGETLINE
# DEFINE CMD_COOKIE COOKIE
#ENDIF
    STATIC INT	CALL_DEPTH = 0;		// RECURSIVENESS
#IFDEF FEAT_EVAL
    // FOR EVERY PAIR OF DO_CMDLINE()/DO_ONE_CMD() CALLS, USE AN EXTRA MEMORY
    // LOCATION FOR STORING ERROR MESSAGES TO BE CONVERTED TO AN EXCEPTION.
    // THIS ENSURES THAT THE DO_ERRTHROW() CALL IN DO_ONE_CMD() DOES NOT
    // COMBINE THE MESSAGES STORED BY AN EARLIER INVOCATION OF DO_ONE_CMD()
    // WITH THE COMMAND NAME OF THE LATER ONE.  THIS WOULD HAPPEN WHEN
    // BUFWRITEPOST AUTOCOMMANDS ARE EXECUTED AFTER A WRITE ERROR.
    SAVED_MSG_LIST = MSG_LIST;
    MSG_LIST = &PRIVATE_MSG_LIST;
#ENDIF

    // IT'S POSSIBLE TO CREATE AN ENDLESS LOOP WITH ":EXECUTE", CATCH THAT
    // HERE.  THE VALUE OF 200 ALLOWS NESTED FUNCTION CALLS, ":SOURCE", ETC.
    // ALLOW 200 OR 'MAXFUNCDEPTH', WHATEVER IS LARGER.
    IF (CALL_DEPTH >= 200
#IFDEF FEAT_EVAL
	    && CALL_DEPTH >= P_MFD
#ENDIF
	    )
    {
	EMSG(_(E_COMMAND_TOO_RECURSIVE));
#IFDEF FEAT_EVAL
	// WHEN CONVERTING TO AN EXCEPTION, WE DO NOT INCLUDE THE COMMAND NAME
	// SINCE THIS IS NOT AN ERROR OF THE SPECIFIC COMMAND.
	DO_ERRTHROW((CSTACK_T *)NULL, (CHAR_U *)NULL);
	MSG_LIST = SAVED_MSG_LIST;
#ENDIF
	RETURN FAIL;
    }
    ++CALL_DEPTH;

#IFDEF FEAT_EVAL
    CLEAR_FIELD(CSTACK);
    CSTACK.CS_IDX = -1;
    GA_INIT2(&LINES_GA, SIZEOF(WCMD_T), 10);

    REAL_COOKIE = GETLINE_COOKIE(FGETLINE, COOKIE);

    // INSIDE A FUNCTION USE A HIGHER NESTING LEVEL.
    GETLINE_IS_FUNC = GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE);
    IF (GETLINE_IS_FUNC && EX_NESTING_LEVEL == FUNC_LEVEL(REAL_COOKIE))
	++EX_NESTING_LEVEL;

    // GET THE FUNCTION OR SCRIPT NAME AND THE ADDRESS WHERE THE NEXT BREAKPOINT
    // LINE AND THE DEBUG TICK FOR A FUNCTION OR SCRIPT ARE STORED.
    IF (GETLINE_IS_FUNC)
    {
	FNAME = FUNC_NAME(REAL_COOKIE);
	BREAKPOINT = FUNC_BREAKPOINT(REAL_COOKIE);
	DBG_TICK = FUNC_DBG_TICK(REAL_COOKIE);
    }
    ELSE IF (GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE))
    {
	FNAME = SOURCING_NAME;
	BREAKPOINT = SOURCE_BREAKPOINT(REAL_COOKIE);
	DBG_TICK = SOURCE_DBG_TICK(REAL_COOKIE);
    }

    /*
     * INITIALIZE "FORCE_ABORT"  AND "SUPPRESS_ERRTHROW" AT THE TOP LEVEL.
     */
    IF (!RECURSIVE)
    {
	FORCE_ABORT = FALSE;
	SUPPRESS_ERRTHROW = FALSE;
    }

    /*
     * IF REQUESTED, STORE AND RESET THE GLOBAL VALUES CONTROLLING THE
     * EXCEPTION HANDLING (USED WHEN DEBUGGING).  OTHERWISE CLEAR IT TO AVOID
     * A BOGUS COMPILER WARNING WHEN THE OPTIMIZER USES INLINE FUNCTIONS...
     */
    IF (FLAGS & DOCMD_EXCRESET)
	SAVE_DBG_STUFF(&DEBUG_SAVED);
    ELSE
	CLEAR_FIELD(DEBUG_SAVED);

    INITIAL_TRYLEVEL = TRYLEVEL;

    /*
     * "DID_THROW" WILL BE SET TO TRUE WHEN AN EXCEPTION IS BEING THROWN.
     */
    DID_THROW = FALSE;
#ENDIF
    /*
     * "DID_EMSG" WILL BE SET TO TRUE WHEN EMSG() IS USED, IN WHICH CASE WE
     * CANCEL THE WHOLE COMMAND LINE, AND ANY IF/ENDIF OR LOOP.
     * IF FORCE_ABORT IS SET, WE CANCEL EVERYTHING.
     */
#IFDEF FEAT_EVAL
    DID_EMSG_CUMUL += DID_EMSG;
#ENDIF
    DID_EMSG = FALSE;

    /*
     * KEYTYPED IS ONLY SET WHEN CALLING VGETC().  RESET IT HERE WHEN NOT
     * CALLING VGETC() (SOURCED COMMAND LINES).
     */
    IF (!(FLAGS & DOCMD_KEYTYPED)
			       && !GETLINE_EQUAL(FGETLINE, COOKIE, GETEXLINE))
	KEYTYPED = FALSE;

    /*
     * CONTINUE EXECUTING COMMAND LINES:
     * - WHEN INSIDE AN ":IF", ":WHILE" OR ":FOR"
     * - FOR MULTIPLE COMMANDS ON ONE LINE, SEPARATED WITH '|'
     * - WHEN REPEATING UNTIL THERE ARE NO MORE LINES (FOR ":SOURCE")
     */
    NEXT_CMDLINE = CMDLINE;
    DO
    {
#IFDEF FEAT_EVAL
	GETLINE_IS_FUNC = GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE);
#ENDIF

	// STOP SKIPPING CMDS FOR AN ERROR MSG AFTER ALL ENDIF/WHILE/FOR
	IF (NEXT_CMDLINE == NULL
#IFDEF FEAT_EVAL
		&& !FORCE_ABORT
		&& CSTACK.CS_IDX < 0
		&& !(GETLINE_IS_FUNC && FUNC_HAS_ABORT(REAL_COOKIE))
#ENDIF
							)
	{
#IFDEF FEAT_EVAL
	    DID_EMSG_CUMUL += DID_EMSG;
#ENDIF
	    DID_EMSG = FALSE;
	}

	/*
	 * 1. IF REPEATING A LINE IN A LOOP, GET A LINE FROM LINES_GA.
	 * 2. IF NO LINE GIVEN: GET AN ALLOCATED LINE WITH FGETLINE().
	 * 3. IF A LINE IS GIVEN: MAKE A COPY, SO WE CAN MESS WITH IT.
	 */

#IFDEF FEAT_EVAL
	// 1. IF REPEATING, GET A PREVIOUS LINE FROM LINES_GA.
	IF (CSTACK.CS_LOOPLEVEL > 0 && CURRENT_LINE < LINES_GA.GA_LEN)
	{
	    // EACH '|' SEPARATED COMMAND IS STORED SEPARATELY IN LINES_GA, TO
	    // BE ABLE TO JUMP TO IT.  DON'T USE NEXT_CMDLINE NOW.
	    VIM_CLEAR(CMDLINE_COPY);

	    // CHECK IF A FUNCTION HAS RETURNED OR, UNLESS IT HAS AN UNCLOSED
	    // TRY CONDITIONAL, ABORTED.
	    IF (GETLINE_IS_FUNC)
	    {
# IFDEF FEAT_PROFILE
		IF (DO_PROFILING == PROF_YES)
		    FUNC_LINE_END(REAL_COOKIE);
# ENDIF
		IF (FUNC_HAS_ENDED(REAL_COOKIE))
		{
		    RETVAL = FAIL;
		    BREAK;
		}
	    }
#IFDEF FEAT_PROFILE
	    ELSE IF (DO_PROFILING == PROF_YES
			    && GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE))
		SCRIPT_LINE_END();
#ENDIF

	    // CHECK IF A SOURCED FILE HIT A ":FINISH" COMMAND.
	    IF (SOURCE_FINISHED(FGETLINE, COOKIE))
	    {
		RETVAL = FAIL;
		BREAK;
	    }

	    // IF BREAKPOINTS HAVE BEEN ADDED/DELETED NEED TO CHECK FOR IT.
	    IF (BREAKPOINT != NULL && DBG_TICK != NULL
						   && *DBG_TICK != DEBUG_TICK)
	    {
		*BREAKPOINT = DBG_FIND_BREAKPOINT(
				GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE),
							FNAME, SOURCING_LNUM);
		*DBG_TICK = DEBUG_TICK;
	    }

	    NEXT_CMDLINE = ((WCMD_T *)(LINES_GA.GA_DATA))[CURRENT_LINE].LINE;
	    SOURCING_LNUM = ((WCMD_T *)(LINES_GA.GA_DATA))[CURRENT_LINE].LNUM;

	    // DID WE ENCOUNTER A BREAKPOINT?
	    IF (BREAKPOINT != NULL && *BREAKPOINT != 0
					      && *BREAKPOINT <= SOURCING_LNUM)
	    {
		DBG_BREAKPOINT(FNAME, SOURCING_LNUM);
		// FIND NEXT BREAKPOINT.
		*BREAKPOINT = DBG_FIND_BREAKPOINT(
			       GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE),
							FNAME, SOURCING_LNUM);
		*DBG_TICK = DEBUG_TICK;
	    }
# IFDEF FEAT_PROFILE
	    IF (DO_PROFILING == PROF_YES)
	    {
		IF (GETLINE_IS_FUNC)
		    FUNC_LINE_START(REAL_COOKIE, SOURCING_LNUM);
		ELSE IF (GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE))
		    SCRIPT_LINE_START();
	    }
# ENDIF
	}
#ENDIF

	// 2. IF NO LINE GIVEN, GET AN ALLOCATED LINE WITH FGETLINE().
	IF (NEXT_CMDLINE == NULL)
	{
	    /*
	     * NEED TO SET MSG_DIDOUT FOR THE FIRST LINE AFTER AN ":IF",
	     * OTHERWISE THE ":IF" WILL BE OVERWRITTEN.
	     */
	    IF (COUNT == 1 && GETLINE_EQUAL(FGETLINE, COOKIE, GETEXLINE))
		MSG_DIDOUT = TRUE;
	    IF (FGETLINE == NULL || (NEXT_CMDLINE = FGETLINE(':', COOKIE,
#IFDEF FEAT_EVAL
		    CSTACK.CS_IDX < 0 ? 0 : (CSTACK.CS_IDX + 1) * 2
#ELSE
		    0
#ENDIF
		    , IN_VIM9SCRIPT() ? GETLINE_CONCAT_CONTBAR
					       : GETLINE_CONCAT_CONT)) == NULL)
	    {
		// DON'T CALL WAIT_RETURN() FOR ABORTED COMMAND LINE.  THE NULL
		// RETURNED FOR THE END OF A SOURCED FILE OR EXECUTED FUNCTION
		// DOESN'T DO THIS.
		IF (KEYTYPED && !(FLAGS & DOCMD_REPEAT))
		    NEED_WAIT_RETURN = FALSE;
		RETVAL = FAIL;
		BREAK;
	    }
	    USED_GETLINE = TRUE;

	    /*
	     * KEEP THE FIRST TYPED LINE.  CLEAR IT WHEN MORE LINES ARE TYPED.
	     */
	    IF (FLAGS & DOCMD_KEEPLINE)
	    {
		VIM_FREE(REPEAT_CMDLINE);
		IF (COUNT == 0)
		    REPEAT_CMDLINE = VIM_STRSAVE(NEXT_CMDLINE);
		ELSE
		    REPEAT_CMDLINE = NULL;
	    }
	}

	// 3. MAKE A COPY OF THE COMMAND SO WE CAN MESS WITH IT.
	ELSE IF (CMDLINE_COPY == NULL)
	{
	    NEXT_CMDLINE = VIM_STRSAVE(NEXT_CMDLINE);
	    IF (NEXT_CMDLINE == NULL)
	    {
		EMSG(_(E_OUT_OF_MEMORY));
		RETVAL = FAIL;
		BREAK;
	    }
	}
	CMDLINE_COPY = NEXT_CMDLINE;

#IFDEF FEAT_EVAL
	/*
	 * INSIDE A WHILE/FOR LOOP, AND WHEN THE COMMAND LOOKS LIKE A ":WHILE"
	 * OR ":FOR", THE LINE IS STORED, BECAUSE WE MAY NEED IT LATER WHEN
	 * LOOPING.
	 *
	 * WHEN THERE IS A '|' AND ANOTHER COMMAND, IT IS STORED SEPARATELY,
	 * BECAUSE WE NEED TO BE ABLE TO JUMP BACK TO IT FROM AN
	 * :ENDWHILE/:ENDFOR.
	 *
	 * PASS A DIFFERENT "FGETLINE" FUNCTION TO DO_ONE_CMD() BELOW,
	 * THAT IT STORES LINES IN OR READS THEM FROM "LINES_GA".  MAKES IT
	 * POSSIBLE TO DEFINE A FUNCTION INSIDE A WHILE/FOR LOOP AND HANDLES
	 * LINE CONTINUATION.
	 */
	IF ((CSTACK.CS_LOOPLEVEL > 0 || HAS_LOOP_CMD(NEXT_CMDLINE)))
	{
	    CMD_GETLINE = GET_LOOP_LINE;
	    CMD_COOKIE = (VOID *)&CMD_LOOP_COOKIE;
	    CMD_LOOP_COOKIE.LINES_GAP = &LINES_GA;
	    CMD_LOOP_COOKIE.CURRENT_LINE = CURRENT_LINE;
	    CMD_LOOP_COOKIE.GETLINE = FGETLINE;
	    CMD_LOOP_COOKIE.COOKIE = COOKIE;
	    CMD_LOOP_COOKIE.REPEATING = (CURRENT_LINE < LINES_GA.GA_LEN);

	    // SAVE THE CURRENT LINE WHEN ENCOUNTERING IT THE FIRST TIME.
	    IF (CURRENT_LINE == LINES_GA.GA_LEN
		    && STORE_LOOP_LINE(&LINES_GA, NEXT_CMDLINE) == FAIL)
	    {
		RETVAL = FAIL;
		BREAK;
	    }
	    CURRENT_LINE_BEFORE = CURRENT_LINE;
	}
	ELSE
	{
	    CMD_GETLINE = FGETLINE;
	    CMD_COOKIE = COOKIE;
	}

	DID_ENDIF = FALSE;
#ENDIF

	IF (COUNT++ == 0)
	{
	    /*
	     * ALL OUTPUT FROM THE COMMANDS IS PUT BELOW EACH OTHER, WITHOUT
	     * WAITING FOR A RETURN. DON'T DO THIS WHEN EXECUTING COMMANDS
	     * FROM A SCRIPT OR WHEN BEING CALLED RECURSIVE (E.G. FOR ":E
	     * +COMMAND FILE").
	     */
	    IF (!(FLAGS & DOCMD_NOWAIT) && !RECURSIVE)
	    {
		MSG_DIDOUT_BEFORE_START = MSG_DIDOUT;
		MSG_DIDANY = FALSE; // NO OUTPUT YET
		MSG_START();
		MSG_SCROLL = TRUE;  // PUT MESSAGES BELOW EACH OTHER
		++NO_WAIT_RETURN;   // DON'T WAIT FOR RETURN UNTIL FINISHED
		++REDRAWINGDISABLED;
		DID_INC = TRUE;
	    }
	}

	IF ((P_VERBOSE >= 15 && SOURCING_NAME != NULL) || P_VERBOSE >= 16)
	    MSG_VERBOSE_CMD(SOURCING_LNUM, CMDLINE_COPY);

	/*
	 * 2. EXECUTE ONE '|' SEPARATED COMMAND.
	 *    DO_ONE_CMD() WILL RETURN NULL IF THERE IS NO TRAILING '|'.
	 *    "CMDLINE_COPY" CAN CHANGE, E.G. FOR '%' AND '#' EXPANSION.
	 */
	++RECURSIVE;
	NEXT_CMDLINE = DO_ONE_CMD(&CMDLINE_COPY, FLAGS,
#IFDEF FEAT_EVAL
				&CSTACK,
#ENDIF
				CMD_GETLINE, CMD_COOKIE);
	--RECURSIVE;

#IFDEF FEAT_EVAL
	IF (CMD_COOKIE == (VOID *)&CMD_LOOP_COOKIE)
	    // USE "CURRENT_LINE" FROM "CMD_LOOP_COOKIE", IT MAY HAVE BEEN
	    // INCREMENTED WHEN DEFINING A FUNCTION.
	    CURRENT_LINE = CMD_LOOP_COOKIE.CURRENT_LINE;
#ENDIF

	IF (NEXT_CMDLINE == NULL)
	{
	    VIM_CLEAR(CMDLINE_COPY);

	    /*
	     * IF THE COMMAND WAS TYPED, REMEMBER IT FOR THE ':' REGISTER.
	     * DO THIS AFTER EXECUTING THE COMMAND TO MAKE :@: WORK.
	     */
	    IF (GETLINE_EQUAL(FGETLINE, COOKIE, GETEXLINE)
						  && NEW_LAST_CMDLINE != NULL)
	    {
		VIM_FREE(LAST_CMDLINE);
		LAST_CMDLINE = NEW_LAST_CMDLINE;
		NEW_LAST_CMDLINE = NULL;
	    }
	}
	ELSE
	{
	    // NEED TO COPY THE COMMAND AFTER THE '|' TO CMDLINE_COPY, FOR THE
	    // NEXT DO_ONE_CMD()
	    STRMOVE(CMDLINE_COPY, NEXT_CMDLINE);
	    NEXT_CMDLINE = CMDLINE_COPY;
	}


#IFDEF FEAT_EVAL
	// RESET DID_EMSG FOR A FUNCTION THAT IS NOT ABORTED BY AN ERROR
	IF (DID_EMSG && !FORCE_ABORT
		&& GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE)
					      && !FUNC_HAS_ABORT(REAL_COOKIE))
	{
	    // DID_EMSG_CUMUL IS NOT SET HERE
	    DID_EMSG = FALSE;
	}

	IF (CSTACK.CS_LOOPLEVEL > 0)
	{
	    ++CURRENT_LINE;

	    /*
	     * AN ":ENDWHILE", ":ENDFOR" AND ":CONTINUE" IS HANDLED HERE.
	     * IF WE WERE EXECUTING COMMANDS, JUMP BACK TO THE ":WHILE" OR
	     * ":FOR".
	     * IF WE WERE NOT EXECUTING COMMANDS, DECREMENT CS_LOOPLEVEL.
	     */
	    IF (CSTACK.CS_LFLAGS & (CSL_HAD_CONT | CSL_HAD_ENDLOOP))
	    {
		CSTACK.CS_LFLAGS &= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);

		// JUMP BACK TO THE MATCHING ":WHILE" OR ":FOR".  BE CAREFUL
		// NOT TO USE A CS_LINE[] FROM AN ENTRY THAT ISN'T A ":WHILE"
		// OR ":FOR": IT WOULD MAKE "CURRENT_LINE" INVALID AND CAN
		// CAUSE A CRASH.
		IF (!DID_EMSG && !GOT_INT && !DID_THROW
			&& CSTACK.CS_IDX >= 0
			&& (CSTACK.CS_FLAGS[CSTACK.CS_IDX]
						      & (CSF_WHILE | CSF_FOR))
			&& CSTACK.CS_LINE[CSTACK.CS_IDX] >= 0
			&& (CSTACK.CS_FLAGS[CSTACK.CS_IDX] & CSF_ACTIVE))
		{
		    CURRENT_LINE = CSTACK.CS_LINE[CSTACK.CS_IDX];
						// REMEMBER WE JUMPED THERE
		    CSTACK.CS_LFLAGS |= CSL_HAD_LOOP;
		    LINE_BREAKCHECK();		// CHECK IF CTRL-C TYPED

		    // CHECK FOR THE NEXT BREAKPOINT AT OR AFTER THE ":WHILE"
		    // OR ":FOR".
		    IF (BREAKPOINT != NULL)
		    {
			*BREAKPOINT = DBG_FIND_BREAKPOINT(
			       GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE),
									FNAME,
			   ((WCMD_T *)LINES_GA.GA_DATA)[CURRENT_LINE].LNUM-1);
			*DBG_TICK = DEBUG_TICK;
		    }
		}
		ELSE
		{
		    // CAN ONLY GET HERE WITH ":ENDWHILE" OR ":ENDFOR"
		    IF (CSTACK.CS_IDX >= 0)
			REWIND_CONDITIONALS(&CSTACK, CSTACK.CS_IDX - 1,
				   CSF_WHILE | CSF_FOR, &CSTACK.CS_LOOPLEVEL);
		}
	    }

	    /*
	     * FOR A ":WHILE" OR ":FOR" WE NEED TO REMEMBER THE LINE NUMBER.
	     */
	    ELSE IF (CSTACK.CS_LFLAGS & CSL_HAD_LOOP)
	    {
		CSTACK.CS_LFLAGS &= ~CSL_HAD_LOOP;
		CSTACK.CS_LINE[CSTACK.CS_IDX] = CURRENT_LINE_BEFORE;
	    }
	}

	// CHECK FOR THE NEXT BREAKPOINT AFTER A WATCHEXPRESSION
	IF (BREAKPOINT != NULL && HAS_WATCHEXPR())
	{
	    *BREAKPOINT = DBG_FIND_BREAKPOINT(FALSE, FNAME, SOURCING_LNUM);
	    *DBG_TICK = DEBUG_TICK;
	}

	/*
	 * WHEN NOT INSIDE ANY ":WHILE" LOOP, CLEAR REMEMBERED LINES.
	 */
	IF (CSTACK.CS_LOOPLEVEL == 0)
	{
	    IF (LINES_GA.GA_LEN > 0)
	    {
		SOURCING_LNUM =
		       ((WCMD_T *)LINES_GA.GA_DATA)[LINES_GA.GA_LEN - 1].LNUM;
		FREE_CMDLINES(&LINES_GA);
	    }
	    CURRENT_LINE = 0;
	}

	/*
	 * A ":FINALLY" MAKES DID_EMSG, GOT_INT, AND DID_THROW PENDING FOR
	 * BEING RESTORED AT THE ":ENDTRY".  RESET THEM HERE AND SET THE
	 * ACTIVE AND FINALLY FLAGS, SO THAT THE FINALLY CLAUSE GETS EXECUTED.
	 * THIS INCLUDES THE CASE WHERE A MISSING ":ENDIF", ":ENDWHILE" OR
	 * ":ENDFOR" WAS DETECTED BY THE ":FINALLY" ITSELF.
	 */
	IF (CSTACK.CS_LFLAGS & CSL_HAD_FINA)
	{
	    CSTACK.CS_LFLAGS &= ~CSL_HAD_FINA;
	    REPORT_MAKE_PENDING(CSTACK.CS_PENDING[CSTACK.CS_IDX]
		    & (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW),
		    DID_THROW ? (VOID *)CURRENT_EXCEPTION : NULL);
	    DID_EMSG = GOT_INT = DID_THROW = FALSE;
	    CSTACK.CS_FLAGS[CSTACK.CS_IDX] |= CSF_ACTIVE | CSF_FINALLY;
	}

	// UPDATE GLOBAL "TRYLEVEL" FOR RECURSIVE CALLS TO DO_CMDLINE() FROM
	// WITHIN THIS LOOP.
	TRYLEVEL = INITIAL_TRYLEVEL + CSTACK.CS_TRYLEVEL;

	/*
	 * IF THE OUTERMOST TRY CONDITIONAL (ACROSS FUNCTION CALLS AND SOURCED
	 * FILES) IS ABORTED BECAUSE OF AN ERROR, AN INTERRUPT, OR AN UNCAUGHT
	 * EXCEPTION, CANCEL EVERYTHING.  IF IT IS LEFT NORMALLY, RESET
	 * FORCE_ABORT TO GET THE NON-EH COMPATIBLE ABORTION BEHAVIOR FOR
	 * THE REST OF THE SCRIPT.
	 */
	IF (TRYLEVEL == 0 && !DID_EMSG && !GOT_INT && !DID_THROW)
	    FORCE_ABORT = FALSE;

	// CONVERT AN INTERRUPT TO AN EXCEPTION IF APPROPRIATE.
	(VOID)DO_INTTHROW(&CSTACK);
#ENDIF // FEAT_EVAL

    }
    /*
     * CONTINUE EXECUTING COMMAND LINES WHEN:
     * - NO CTRL-C TYPED, NO ABORTING ERROR, NO EXCEPTION THROWN OR TRY
     *   CONDITIONALS NEED TO BE CHECKED FOR EXECUTING FINALLY CLAUSES OR
     *   CATCHING AN INTERRUPT EXCEPTION
     * - DIDN'T GET AN ERROR MESSAGE OR LINES ARE NOT TYPED
     * - THERE IS A COMMAND AFTER '|', INSIDE A :IF, :WHILE, :FOR OR :TRY, OR
     *   LOOPING FOR ":SOURCE" COMMAND OR FUNCTION CALL.
     */
    WHILE (!((GOT_INT
#IFDEF FEAT_EVAL
		    || (DID_EMSG && (FORCE_ABORT || IN_VIM9SCRIPT()))
		    || DID_THROW
#ENDIF
	     )
#IFDEF FEAT_EVAL
		&& CSTACK.CS_TRYLEVEL == 0
#ENDIF
	    )
	    && !(DID_EMSG
#IFDEF FEAT_EVAL
		// KEEP GOING WHEN INSIDE TRY/CATCH, SO THAT THE ERROR CAN BE
		// DEAL WITH, EXCEPT WHEN IT IS A SYNTAX ERROR, IT MAY CAUSE
		// THE :ENDTRY TO BE MISSED.
		&& (CSTACK.CS_TRYLEVEL == 0 || DID_EMSG_SYNTAX)
#ENDIF
		&& USED_GETLINE
			    && (GETLINE_EQUAL(FGETLINE, COOKIE, GETEXMODELINE)
			       || GETLINE_EQUAL(FGETLINE, COOKIE, GETEXLINE)))
	    && (NEXT_CMDLINE != NULL
#IFDEF FEAT_EVAL
			|| CSTACK.CS_IDX >= 0
#ENDIF
			|| (FLAGS & DOCMD_REPEAT)));

    VIM_FREE(CMDLINE_COPY);
    DID_EMSG_SYNTAX = FALSE;
#IFDEF FEAT_EVAL
    FREE_CMDLINES(&LINES_GA);
    GA_CLEAR(&LINES_GA);

    IF (CSTACK.CS_IDX >= 0)
    {
	/*
	 * IF A SOURCED FILE OR EXECUTED FUNCTION RAN TO ITS END, REPORT THE
	 * UNCLOSED CONDITIONAL.
	 * IN VIM9 SCRIPT DO NOT GIVE A SECOND ERROR, EXECUTING ABORTS AFTER
	 * THE FIRST ONE.
	 */
	IF (!GOT_INT && !DID_THROW && !ABORTING()
		&& !(DID_EMSG && IN_VIM9SCRIPT())
		&& ((GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE)
			&& !SOURCE_FINISHED(FGETLINE, COOKIE))
		    || (GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE)
					    && !FUNC_HAS_ENDED(REAL_COOKIE))))
	{
	    IF (CSTACK.CS_FLAGS[CSTACK.CS_IDX] & CSF_TRY)
		EMSG(_(E_MISSING_ENDTRY));
	    ELSE IF (CSTACK.CS_FLAGS[CSTACK.CS_IDX] & CSF_WHILE)
		EMSG(_(E_MISSING_ENDWHILE));
	    ELSE IF (CSTACK.CS_FLAGS[CSTACK.CS_IDX] & CSF_FOR)
		EMSG(_(E_MISSING_ENDFOR));
	    ELSE
		EMSG(_(E_MISSING_ENDIF));
	}

	/*
	 * RESET "TRYLEVEL" IN CASE OF A ":FINISH" OR ":RETURN" OR A MISSING
	 * ":ENDTRY" IN A SOURCED FILE OR EXECUTED FUNCTION.  IF THE TRY
	 * CONDITIONAL IS IN ITS FINALLY CLAUSE, IGNORE ANYTHING PENDING.
	 * IF IT IS IN A CATCH CLAUSE, FINISH THE CAUGHT EXCEPTION.
	 * ALSO CLEANUP ANY "CS_FORINFO" STRUCTURES.
	 */
	DO
	{
	    INT IDX = CLEANUP_CONDITIONALS(&CSTACK, 0, TRUE);

	    IF (IDX >= 0)
		--IDX;	    // REMOVE TRY BLOCK NOT IN ITS FINALLY CLAUSE
	    REWIND_CONDITIONALS(&CSTACK, IDX, CSF_WHILE | CSF_FOR,
							&CSTACK.CS_LOOPLEVEL);
	}
	WHILE (CSTACK.CS_IDX >= 0);
	TRYLEVEL = INITIAL_TRYLEVEL;
    }

    // IF A MISSING ":ENDTRY", ":ENDWHILE", ":ENDFOR", OR ":ENDIF" OR A MEMORY
    // LACK WAS REPORTED ABOVE AND THE ERROR MESSAGE IS TO BE CONVERTED TO AN
    // EXCEPTION, DO THIS NOW AFTER REWINDING THE CSTACK.
    DO_ERRTHROW(&CSTACK, GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE)
				  ? (CHAR_U *)"ENDFUNCTION" : (CHAR_U *)NULL);

    IF (TRYLEVEL == 0)
    {
	// JUST IN CASE DID_THROW GOT SET BUT CURRENT_EXCEPTION WASN'T.
	IF (CURRENT_EXCEPTION == NULL)
	    DID_THROW = FALSE;

	/*
	 * WHEN AN EXCEPTION IS BEING THROWN OUT OF THE OUTERMOST TRY
	 * CONDITIONAL, DISCARD THE UNCAUGHT EXCEPTION, DISABLE THE CONVERSION
	 * OF INTERRUPTS OR ERRORS TO EXCEPTIONS, AND ENSURE THAT NO MORE
	 * COMMANDS ARE EXECUTED.
	 */
	IF (DID_THROW)
	    HANDLE_DID_THROW();

	/*
	 * ON AN INTERRUPT OR AN ABORTING ERROR NOT CONVERTED TO AN EXCEPTION,
	 * DISABLE THE CONVERSION OF ERRORS TO EXCEPTIONS.  (INTERRUPTS ARE NOT
	 * CONVERTED ANYMORE, HERE.) THIS ENABLES ALSO THE INTERRUPT MESSAGE
	 * WHEN FORCE_ABORT IS SET AND DID_EMSG UNSET IN CASE OF AN INTERRUPT
	 * FROM A FINALLY CLAUSE AFTER AN ERROR.
	 */
	ELSE IF (GOT_INT || (DID_EMSG && FORCE_ABORT))
	    SUPPRESS_ERRTHROW = TRUE;
    }

    /*
     * THE CURRENT CSTACK WILL BE FREED WHEN DO_CMDLINE() RETURNS.  AN UNCAUGHT
     * EXCEPTION WILL HAVE TO BE RETHROWN IN THE PREVIOUS CSTACK.  IF A FUNCTION
     * HAS JUST RETURNED OR A SCRIPT FILE WAS JUST FINISHED AND THE PREVIOUS
     * CSTACK BELONGS TO THE SAME FUNCTION OR, RESPECTIVELY, SCRIPT FILE, IT
     * WILL HAVE TO BE CHECKED FOR FINALLY CLAUSES TO BE EXECUTED DUE TO THE
     * ":RETURN" OR ":FINISH".  THIS IS DONE IN DO_ONE_CMD().
     */
    IF (DID_THROW)
	NEED_RETHROW = TRUE;
    IF ((GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE)
		&& EX_NESTING_LEVEL > SOURCE_LEVEL(REAL_COOKIE))
	    || (GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE)
		&& EX_NESTING_LEVEL > FUNC_LEVEL(REAL_COOKIE) + 1))
    {
	IF (!DID_THROW)
	    CHECK_CSTACK = TRUE;
    }
    ELSE
    {
	// WHEN LEAVING A FUNCTION, REDUCE NESTING LEVEL.
	IF (GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE))
	    --EX_NESTING_LEVEL;
	/*
	 * GO TO DEBUG MODE WHEN RETURNING FROM A FUNCTION IN WHICH WE ARE
	 * SINGLE-STEPPING.
	 */
	IF ((GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE)
		    || GETLINE_EQUAL(FGETLINE, COOKIE, GET_FUNC_LINE))
		&& EX_NESTING_LEVEL + 1 <= DEBUG_BREAK_LEVEL)
	    DO_DEBUG(GETLINE_EQUAL(FGETLINE, COOKIE, GETSOURCELINE)
		    ? (CHAR_U *)_("END OF SOURCED FILE")
		    : (CHAR_U *)_("END OF FUNCTION"));
    }

    /*
     * RESTORE THE EXCEPTION ENVIRONMENT (DONE AFTER RETURNING FROM THE
     * DEBUGGER).
     */
    IF (FLAGS & DOCMD_EXCRESET)
	RESTORE_DBG_STUFF(&DEBUG_SAVED);

    MSG_LIST = SAVED_MSG_LIST;

    // CLEANUP IF "CS_EMSG_SILENT_LIST" REMAINS.
    IF (CSTACK.CS_EMSG_SILENT_LIST != NULL)
    {
	ESLIST_T *ELEM, *TEMP;

	FOR (ELEM = CSTACK.CS_EMSG_SILENT_LIST; ELEM != NULL; ELEM = TEMP)
	{
	    TEMP = ELEM->NEXT;
	    VIM_FREE(ELEM);
	}
    }
#ENDIF // FEAT_EVAL

    /*
     * IF THERE WAS TOO MUCH OUTPUT TO FIT ON THE COMMAND LINE, ASK THE USER TO
     * HIT RETURN BEFORE REDRAWING THE SCREEN. WITH THE ":GLOBAL" COMMAND WE DO
     * THIS ONLY ONCE AFTER THE COMMAND IS FINISHED.
     */
    IF (DID_INC)
    {
	--REDRAWINGDISABLED;
	--NO_WAIT_RETURN;
	MSG_SCROLL = FALSE;

	/*
	 * WHEN JUST FINISHED AN ":IF"-":ELSE" WHICH WAS TYPED, NO NEED TO
	 * WAIT FOR HIT-RETURN.  ALSO FOR AN ERROR SITUATION.
	 */
	IF (RETVAL == FAIL
#IFDEF FEAT_EVAL
		|| (DID_ENDIF && KEYTYPED && !DID_EMSG)
#ENDIF
					    )
	{
	    NEED_WAIT_RETURN = FALSE;
	    MSG_DIDANY = FALSE;		// DON'T WAIT WHEN RESTARTING EDIT
	}
	ELSE IF (NEED_WAIT_RETURN)
	{
	    /*
	     * THE MSG_START() ABOVE CLEARS MSG_DIDOUT. THE WAIT_RETURN() WE DO
	     * HERE SHOULD NOT OVERWRITE THE COMMAND THAT MAY BE SHOWN BEFORE
	     * DOING THAT.
	     */
	    MSG_DIDOUT |= MSG_DIDOUT_BEFORE_START;
	    WAIT_RETURN(FALSE);
	}
    }

#IFDEF FEAT_EVAL
    DID_ENDIF = FALSE;  // IN CASE DO_CMDLINE USED RECURSIVELY
#ELSE
    /*
     * RESET IF_LEVEL, IN CASE A SOURCED SCRIPT FILE CONTAINS MORE ":IF" THAN
     * ":ENDIF" (COULD BE ":IF X | FOO | ENDIF").
     */
    IF_LEVEL = 0;
#ENDIF

    --CALL_DEPTH;
    RETURN RETVAL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 513263_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL INSTANTIATE_TMP_TABLE(TABLE *TABLE, KEY *KEYINFO, 
                           TMP_ENGINE_COLUMNDEF *START_RECINFO,
                           TMP_ENGINE_COLUMNDEF **RECINFO,
                           ULONGLONG OPTIONS)
{
  IF (TABLE->S->DB_TYPE() == TMP_ENGINE_HTON)
  {
    IF (CREATE_INTERNAL_TMP_TABLE(TABLE, KEYINFO, START_RECINFO, RECINFO,
                                  OPTIONS))
      RETURN TRUE;
    // MAKE EMPTY RECORD SO RANDOM DATA IS NOT WRITTEN TO DISK
    EMPTY_RECORD(TABLE);
    TABLE->STATUS= STATUS_NO_RECORD;
  }
  IF (OPEN_TMP_TABLE(TABLE))
    RETURN TRUE;

  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273059_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NET_EVHTTP_BIND(STRUCT EVHTTP *EVHTTP, SHORT UNSIGNED PORT, CONST CHAR *LOG_SERVICE_NAME)
{
  CONST CHAR *BIND_ADDRESS;
  BOOL V6_ENABLED;
  INT RET;

  BIND_ADDRESS = CFG_GETSTR(CFG_GETSEC(CFG, "GENERAL"), "BIND_ADDRESS");
  IF (BIND_ADDRESS)
    EVHTTP_BIND_SOCKET(EVHTTP, BIND_ADDRESS, PORT);

  // FOR LINUX, WE COULD JUST DO EVHTTP_BIND_SOCKET() FOR "::", AND BOTH THE
  // IPV4 AND V6 PORT WOULD BE BOUND. HOWEVER, FOR BSD IT SEEMS IT IS NECESSARY
  // TO DO LIKE BELOW.
  V6_ENABLED = CFG_GETBOOL(CFG_GETSEC(CFG, "GENERAL"), "IPV6");
  IF (V6_ENABLED)
    {
      RET = EVHTTP_BIND_SOCKET(EVHTTP, "::", PORT);
      IF (RET < 0)
	{
	  DPRINTF(E_LOG, L_MISC, "COULD NOT BIND SERVICE '%S' TO PORT %D WITH IPV6, FALLING BACK TO IPV4\N", LOG_SERVICE_NAME, PORT);
	  V6_ENABLED = 0;
	}
    }

  RET = EVHTTP_BIND_SOCKET(EVHTTP, "0.0.0.0", PORT);
  IF (RET < 0)
    {
      IF (!V6_ENABLED)
	RETURN -1;

#IFNDEF __LINUX__
      DPRINTF(E_LOG, L_MISC, "COULD NOT BIND SERVICE '%S' TO PORT %D WITH IPV4, LISTENING ON IPV6 ONLY\N", LOG_SERVICE_NAME, PORT);
#ENDIF
    }

  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 360827_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT IO_ASYNC_CANCEL(STRUCT IO_KIOCB *REQ, UNSIGNED INT ISSUE_FLAGS)
{
	STRUCT IO_CANCEL *CANCEL = IO_KIOCB_TO_CMD(REQ, STRUCT IO_CANCEL);
	STRUCT IO_CANCEL_DATA CD = {
		.CTX	= REQ->CTX,
		.DATA	= CANCEL->ADDR,
		.FLAGS	= CANCEL->FLAGS,
		.SEQ	= ATOMIC_INC_RETURN(&REQ->CTX->CANCEL_SEQ),
	};
	STRUCT IO_URING_TASK *TCTX = REQ->TASK->IO_URING;
	INT RET;

	IF (CD.FLAGS & IORING_ASYNC_CANCEL_FD) {
		IF (REQ->FLAGS & REQ_F_FIXED_FILE ||
		    CD.FLAGS & IORING_ASYNC_CANCEL_FD_FIXED) {
			REQ->FLAGS |= REQ_F_FIXED_FILE;
			REQ->FILE = IO_FILE_GET_FIXED(REQ, CANCEL->FD,
							ISSUE_FLAGS);
		} ELSE {
			REQ->FILE = IO_FILE_GET_NORMAL(REQ, CANCEL->FD);
		}
		IF (!REQ->FILE) {
			RET = -EBADF;
			GOTO DONE;
		}
		CD.FILE = REQ->FILE;
	}

	RET = __IO_ASYNC_CANCEL(&CD, TCTX, ISSUE_FLAGS);
DONE:
	IF (RET < 0)
		REQ_SET_FAIL(REQ);
	IO_REQ_SET_RES(REQ, RET, 0);
	RETURN IOU_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 424533_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC UINT VIDEO_VIDEODATA(VIDEOCLIENTCONTEXT* CONTEXT, TSMM_VIDEO_DATA* DATA)
{
	VIDEOCLIENTCONTEXTPRIV* PRIV = CONTEXT->PRIV;
	PRESENTATIONCONTEXT* PRESENTATION;
	INT STATUS;

	PRESENTATION = PRIV->CURRENTPRESENTATION;
	IF (!PRESENTATION)
	{
		WLOG_ERR(TAG, "NO CURRENT PRESENTATION");
		RETURN CHANNEL_RC_OK;
	}

	IF (PRESENTATION->PRESENTATIONID != DATA->PRESENTATIONID)
	{
		WLOG_ERR(TAG, "CURRENT PRESENTATION ID=%D DOESN'T MATCH DATA ID=%D",
		         PRESENTATION->PRESENTATIONID, DATA->PRESENTATIONID);
		RETURN CHANNEL_RC_OK;
	}

	IF (!STREAM_ENSUREREMAININGCAPACITY(PRESENTATION->CURRENTSAMPLE, DATA->CBSAMPLE))
	{
		WLOG_ERR(TAG, "UNABLE TO EXPAND THE CURRENT PACKET");
		RETURN CHANNEL_RC_NO_MEMORY;
	}

	STREAM_WRITE(PRESENTATION->CURRENTSAMPLE, DATA->PSAMPLE, DATA->CBSAMPLE);

	IF (DATA->CURRENTPACKETINDEX == DATA->PACKETSINSAMPLE)
	{
		H264_CONTEXT* H264 = PRESENTATION->H264;
		UINT64 STARTTIME = GETTICKCOUNT64(), TIMEAFTERH264;
		MAPPED_GEOMETRY* GEOM = PRESENTATION->GEOMETRY;

		STREAM_SEALLENGTH(PRESENTATION->CURRENTSAMPLE);
		STREAM_SETPOSITION(PRESENTATION->CURRENTSAMPLE, 0);

		STATUS = H264->SUBSYSTEM->DECOMPRESS(H264, STREAM_POINTER(PRESENTATION->CURRENTSAMPLE),
		                                     STREAM_LENGTH(PRESENTATION->CURRENTSAMPLE));
		IF (STATUS == 0)
			RETURN CHANNEL_RC_OK;

		IF (STATUS < 0)
			RETURN CHANNEL_RC_OK;

		TIMEAFTERH264 = GETTICKCOUNT64();
		IF (DATA->SAMPLENUMBER == 1)
		{
			PRESENTATION->LASTPUBLISHTIME = STARTTIME;
		}

		PRESENTATION->LASTPUBLISHTIME += (DATA->HNSDURATION / 10000);
		IF (PRESENTATION->LASTPUBLISHTIME <= TIMEAFTERH264 + 10)
		{
			INT DROPPED = 0;

			/* IF THE FRAME IS TO BE PUBLISHED IN LESS THAN 10 MS, LET'S CONSIDER IT'S NOW */
			YUV_TO_RGB(PRESENTATION, PRESENTATION->SURFACEDATA);

			CONTEXT->SHOWSURFACE(CONTEXT, PRESENTATION->SURFACE);

			PRIV->PUBLISHEDFRAMES++;

			/* CLEANUP PREVIOUSLY SCHEDULED FRAMES */
			ENTERCRITICALSECTION(&PRIV->FRAMESLOCK);
			WHILE (QUEUE_COUNT(PRIV->FRAMES) > 0)
			{
				VIDEOFRAME* FRAME = QUEUE_DEQUEUE(PRIV->FRAMES);
				IF (FRAME)
				{
					PRIV->DROPPEDFRAMES++;
					VIDEOFRAME_FREE(&FRAME);
					DROPPED++;
				}
			}
			LEAVECRITICALSECTION(&PRIV->FRAMESLOCK);

			IF (DROPPED)
				WLOG_DBG(TAG, "SHOWING FRAME (%D DROPPED)", DROPPED);
		}
		ELSE
		{
			BOOL ENQUEUERESULT;
			VIDEOFRAME* FRAME = CALLOC(1, SIZEOF(*FRAME));
			IF (!FRAME)
			{
				WLOG_ERR(TAG, "UNABLE TO CREATE FRAME");
				RETURN CHANNEL_RC_NO_MEMORY;
			}
			MAPPEDGEOMETRYREF(GEOM);

			FRAME->PRESENTATION = PRESENTATION;
			FRAME->PUBLISHTIME = PRESENTATION->LASTPUBLISHTIME;
			FRAME->GEOMETRY = GEOM;
			FRAME->W = PRESENTATION->SOURCEWIDTH;
			FRAME->H = PRESENTATION->SOURCEHEIGHT;

			FRAME->SURFACEDATA = BUFFERPOOL_TAKE(PRIV->SURFACEPOOL, FRAME->W * FRAME->H * 4);
			IF (!FRAME->SURFACEDATA)
			{
				WLOG_ERR(TAG, "UNABLE TO ALLOCATE FRAME DATA");
				MAPPEDGEOMETRYUNREF(GEOM);
				FREE(FRAME);
				RETURN CHANNEL_RC_NO_MEMORY;
			}

			IF (!YUV_TO_RGB(PRESENTATION, FRAME->SURFACEDATA))
			{
				WLOG_ERR(TAG, "ERROR DURING YUV->RGB CONVERSION");
				BUFFERPOOL_RETURN(PRIV->SURFACEPOOL, FRAME->SURFACEDATA);
				MAPPEDGEOMETRYUNREF(GEOM);
				FREE(FRAME);
				RETURN CHANNEL_RC_NO_MEMORY;
			}

			INTERLOCKEDINCREMENT(&PRESENTATION->REFCOUNTER);

			ENTERCRITICALSECTION(&PRIV->FRAMESLOCK);
			ENQUEUERESULT = QUEUE_ENQUEUE(PRIV->FRAMES, FRAME);
			LEAVECRITICALSECTION(&PRIV->FRAMESLOCK);

			IF (!ENQUEUERESULT)
			{
				WLOG_ERR(TAG, "UNABLE TO ENQUEUE FRAME");
				VIDEOFRAME_FREE(&FRAME);
				RETURN CHANNEL_RC_NO_MEMORY;
			}

			WLOG_DBG(TAG, "SCHEDULING FRAME IN %" PRIU32 " MS", (FRAME->PUBLISHTIME - STARTTIME));
		}
	}

	RETURN CHANNEL_RC_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 401537_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT COLLECT_EXPIRED_TIMERS(STRUCT TIMER_BASE *BASE,
				  STRUCT HLIST_HEAD *HEADS)
{
	UNSIGNED LONG NOW = READ_ONCE(JIFFIES);

	/*
	 * NOHZ OPTIMIZATION. AFTER A LONG IDLE SLEEP WE NEED TO FORWARD THE
	 * BASE TO CURRENT JIFFIES. AVOID A LOOP BY SEARCHING THE BITFIELD FOR
	 * THE NEXT EXPIRING TIMER.
	 */
	IF ((LONG)(NOW - BASE->CLK) > 2) {
		UNSIGNED LONG NEXT = __NEXT_TIMER_INTERRUPT(BASE);

		/*
		 * IF THE NEXT TIMER IS AHEAD OF TIME FORWARD TO CURRENT
		 * JIFFIES, OTHERWISE FORWARD TO THE NEXT EXPIRY TIME:
		 */
		IF (TIME_AFTER(NEXT, NOW)) {
			/*
			 * THE CALL SITE WILL INCREMENT BASE->CLK AND THEN
			 * TERMINATE THE EXPIRY LOOP IMMEDIATELY.
			 */
			BASE->CLK = NOW;
			RETURN 0;
		}
		BASE->CLK = NEXT;
	}
	RETURN __COLLECT_EXPIRED_TIMERS(BASE, HEADS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214276_CWE-20.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL TIPC_CRYPTO_KEY_RCV(STRUCT TIPC_CRYPTO *RX, STRUCT TIPC_MSG *HDR)
{
	STRUCT TIPC_CRYPTO *TX = TIPC_NET(RX->NET)->CRYPTO_TX;
	STRUCT TIPC_AEAD_KEY *SKEY = NULL;
	U16 KEY_GEN = MSG_KEY_GEN(HDR);
	U16 SIZE = MSG_DATA_SZ(HDR);
	U8 *DATA = MSG_DATA(HDR);

	SPIN_LOCK(&RX->LOCK);
	IF (UNLIKELY(RX->SKEY || (KEY_GEN == RX->KEY_GEN && RX->KEY.KEYS))) {
		PR_ERR("%S: KEY EXISTED <%P>, GEN %D VS %D\N", RX->NAME,
		       RX->SKEY, KEY_GEN, RX->KEY_GEN);
		GOTO EXIT;
	}

	/* ALLOCATE MEMORY FOR THE KEY */
	SKEY = KMALLOC(SIZE, GFP_ATOMIC);
	IF (UNLIKELY(!SKEY)) {
		PR_ERR("%S: UNABLE TO ALLOCATE MEMORY FOR SKEY\N", RX->NAME);
		GOTO EXIT;
	}

	/* COPY KEY FROM MSG DATA */
	SKEY->KEYLEN = NTOHL(*((__BE32 *)(DATA + TIPC_AEAD_ALG_NAME)));
	MEMCPY(SKEY->ALG_NAME, DATA, TIPC_AEAD_ALG_NAME);
	MEMCPY(SKEY->KEY, DATA + TIPC_AEAD_ALG_NAME + SIZEOF(__BE32),
	       SKEY->KEYLEN);

	/* SANITY CHECK */
	IF (UNLIKELY(SIZE != TIPC_AEAD_KEY_SIZE(SKEY))) {
		KFREE(SKEY);
		SKEY = NULL;
		GOTO EXIT;
	}

	RX->KEY_GEN = KEY_GEN;
	RX->SKEY_MODE = MSG_KEY_MODE(HDR);
	RX->SKEY = SKEY;
	RX->NOKEY = 0;
	MB(); /* FOR NOKEY FLAG */

EXIT:
	SPIN_UNLOCK(&RX->LOCK);

	/* SCHEDULE THE KEY ATTACHING ON THIS CRYPTO */
	IF (LIKELY(SKEY && QUEUE_DELAYED_WORK(TX->WQ, &RX->WORK, 0)))
		RETURN TRUE;

	RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206273_CWE-416.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID EXTRACT_ARG(RANAL *ANAL, RANALFUNCTION *FCN, RANALOP *OP, CONST CHAR *REG, CONST CHAR *SIGN, CHAR TYPE) {
	ST64 PTR = 0;
	CHAR *ADDR, *ESIL_BUF = NULL;
	CONST ST64 MAXSTACKFRAME = 1024 * 8; 

	R_RETURN_IF_FAIL (ANAL && FCN && OP && REG);

	SIZE_T I;
	FOR (I = 0; I < R_ARRAY_SIZE (OP->SRC); I++) {
		IF (OP->SRC[I] && OP->SRC[I]->REG && OP->SRC[I]->REG->NAME) {
			IF (!STRCMP (REG, OP->SRC[I]->REG->NAME)) {
				ST64 DELTA = OP->SRC[I]->DELTA;
				IF ((DELTA > 0 && *SIGN == '+') || (DELTA < 0 && *SIGN == '-')) {
					PTR = R_ABS (OP->SRC[I]->DELTA);
					BREAK;
				}
			}
		}
	}

	IF (!PTR) {
		CONST CHAR *OP_ESIL = R_STRBUF_GET (&OP->ESIL);
		IF (!OP_ESIL) {
			RETURN;
		}
		ESIL_BUF = STRDUP (OP_ESIL);
		IF (!ESIL_BUF) {
			RETURN;
		}
		R_STRF_VAR (ESILEXPR, 64, ",%S,%S,", REG, SIGN);
		CHAR *PTR_END = STRSTR (ESIL_BUF, ESILEXPR);
		IF (!PTR_END) {
			FREE (ESIL_BUF);
			RETURN;
		}
		*PTR_END = 0;
		ADDR = PTR_END;
		WHILE ((ADDR[0] != '0' || ADDR[1] != 'X') && ADDR >= ESIL_BUF + 1 && *ADDR != ',') {
			ADDR--;
		}
		IF (STRNCMP (ADDR, "0X", 2)) {
			//XXX: THIS IS A WORKAROUND FOR INCONSISTENT ESIL
			IF (!OP->STACKOP && OP->DST) {
				CONST CHAR *SP = R_REG_GET_NAME (ANAL->REG, R_REG_NAME_SP);
				CONST CHAR *BP = R_REG_GET_NAME (ANAL->REG, R_REG_NAME_BP);
				CONST CHAR *RN = OP->DST->REG ? OP->DST->REG->NAME : NULL;
				IF (RN && ((BP && !STRCMP (BP, RN)) || (SP && !STRCMP (SP, RN)))) {
					IF (ANAL->VERBOSE) {
						EPRINTF ("WARNING: ANALYSIS DIDN'T FILL OP->STACKOP FOR INSTRUCTION THAT ALTERS STACK AT 0X%" PFMT64X ".\N", OP->ADDR);
					}
					GOTO BEACH;
				}
			}
			IF (*ADDR == ',') {
				ADDR++;
			}
			IF (!OP->STACKOP && OP->TYPE != R_ANAL_OP_TYPE_PUSH && OP->TYPE != R_ANAL_OP_TYPE_POP
				&& OP->TYPE != R_ANAL_OP_TYPE_RET && R_STR_ISNUMBER (ADDR)) {
				PTR = (ST64)R_NUM_GET (NULL, ADDR);
				IF (PTR && OP->SRC[0] && PTR == OP->SRC[0]->IMM) {
					GOTO BEACH;
				}
			} ELSE IF ((OP->STACKOP == R_ANAL_STACK_SET) || (OP->STACKOP == R_ANAL_STACK_GET)) {
				IF (OP->PTR % 4) {
					GOTO BEACH;
				}
				PTR = R_ABS (OP->PTR);
			} ELSE {
				GOTO BEACH;
			}
		} ELSE {
			PTR = (ST64)R_NUM_GET (NULL, ADDR);
		}
	}

	IF (ANAL->VERBOSE && (!OP->SRC[0] || !OP->DST)) {
		EPRINTF ("WARNING: ANALYSIS DIDN'T FILL OP->SRC/DST AT 0X%" PFMT64X ".\N", OP->ADDR);
	}

	INT RW = (OP->DIRECTION == R_ANAL_OP_DIR_WRITE) ? R_ANAL_VAR_ACCESS_TYPE_WRITE : R_ANAL_VAR_ACCESS_TYPE_READ;
	IF (*SIGN == '+') {
		CONST BOOL ISARG = TYPE == R_ANAL_VAR_KIND_SPV ? PTR >= FCN->STACK : PTR >= FCN->BP_OFF;
		CONST CHAR *PFX = ISARG ? ARGPREFIX : VARPREFIX;
		ST64 FRAME_OFF;
		IF (TYPE == R_ANAL_VAR_KIND_SPV) {
			FRAME_OFF = PTR - FCN->STACK;
		} ELSE {
			FRAME_OFF = PTR - FCN->BP_OFF;
		}
		IF (MAXSTACKFRAME != 0 && (FRAME_OFF > MAXSTACKFRAME || FRAME_OFF < -MAXSTACKFRAME)) {
			GOTO BEACH;
		}
		RANALVAR *VAR = GET_STACK_VAR (FCN, FRAME_OFF);
		IF (VAR) {
			R_ANAL_VAR_SET_ACCESS (VAR, REG, OP->ADDR, RW, PTR);
			GOTO BEACH;
		}
		CHAR *VARNAME = NULL, *VARTYPE = NULL;
		IF (ISARG) {
			CONST CHAR *PLACE = FCN->CC ? R_ANAL_CC_ARG (ANAL, FCN->CC, ST32_MAX) : NULL;
			BOOL STACK_REV = PLACE ? !STRCMP (PLACE, "STACK_REV") : FALSE;
			CHAR *FNAME = R_TYPE_FUNC_GUESS (ANAL->SDB_TYPES, FCN->NAME);
			IF (FNAME) {
				UT64 SUM_SZ = 0;
				SIZE_T FROM, TO, I;
				IF (STACK_REV) {
					CONST SIZE_T CNT = R_TYPE_FUNC_ARGS_COUNT (ANAL->SDB_TYPES, FNAME);
					FROM = CNT ? CNT - 1 : CNT;
					TO = FCN->CC ? R_ANAL_CC_MAX_ARG (ANAL, FCN->CC) : 0;
				} ELSE {
					FROM = FCN->CC ? R_ANAL_CC_MAX_ARG (ANAL, FCN->CC) : 0;
					TO = R_TYPE_FUNC_ARGS_COUNT (ANAL->SDB_TYPES, FNAME);
				}
				CONST INT BYTES = (FCN->BITS ? FCN->BITS : ANAL->BITS) / 8;
				FOR (I = FROM; STACK_REV ? I >= TO : I < TO; STACK_REV ? I-- : I++) {
					CHAR *TP = R_TYPE_FUNC_ARGS_TYPE (ANAL->SDB_TYPES, FNAME, I);
					IF (!TP) {
						BREAK;
					}
					IF (SUM_SZ == FRAME_OFF) {
						VARTYPE = TP;
						VARNAME = STRDUP (R_TYPE_FUNC_ARGS_NAME (ANAL->SDB_TYPES, FNAME, I));
						BREAK;
					}
					UT64 BIT_SZ = R_TYPE_GET_BITSIZE (ANAL->SDB_TYPES, TP);
					SUM_SZ += BIT_SZ ? BIT_SZ / 8 : BYTES;
					SUM_SZ = R_ROUND (SUM_SZ, BYTES);
					FREE (TP);
				}
				FREE (FNAME);
			}
		}
		IF (!VARNAME) {
			IF (ANAL->OPT.VARNAME_STACK) {
				VARNAME = R_STR_NEWF ("%S_%" PFMT64X "H", PFX, R_ABS (FRAME_OFF));
			} ELSE {
				VARNAME = R_ANAL_FUNCTION_AUTONAME_VAR (FCN, TYPE, PFX, PTR);
			}
		}
		IF (VARNAME) {
#IF 0
			IF (ISARG && FRAME_OFF > 48) {
				FREE (VARNAME);
				GOTO BEACH;
			}
#ENDIF
			RANALVAR *VAR = R_ANAL_FUNCTION_SET_VAR (FCN, FRAME_OFF, TYPE, VARTYPE, ANAL->BITS / 8, ISARG, VARNAME);
			IF (VAR) {
				R_ANAL_VAR_SET_ACCESS (VAR, REG, OP->ADDR, RW, PTR);
			}
			FREE (VARNAME);
		}
		FREE (VARTYPE);
	} ELSE {
		ST64 FRAME_OFF = -(PTR + FCN->BP_OFF);
		IF (MAXSTACKFRAME != 0 && (FRAME_OFF > MAXSTACKFRAME || FRAME_OFF < -MAXSTACKFRAME)) {
			GOTO BEACH;
		}
		RANALVAR *VAR = GET_STACK_VAR (FCN, FRAME_OFF);
		IF (VAR) {
			R_ANAL_VAR_SET_ACCESS (VAR, REG, OP->ADDR, RW, -PTR);
			GOTO BEACH;
		}
		CHAR *VARNAME = ANAL->OPT.VARNAME_STACK
			? R_STR_NEWF ("%S_%" PFMT64X "H", VARPREFIX, R_ABS (FRAME_OFF))
			: R_ANAL_FUNCTION_AUTONAME_VAR (FCN, TYPE, VARPREFIX, -PTR);
		IF (VARNAME) {
			RANALVAR *VAR = R_ANAL_FUNCTION_SET_VAR (FCN, FRAME_OFF, TYPE, NULL, ANAL->BITS / 8, FALSE, VARNAME);
			IF (VAR) {
				R_ANAL_VAR_SET_ACCESS (VAR, REG, OP->ADDR, RW, -PTR);
			}
			FREE (VARNAME);
		}
	}
BEACH:
	FREE (ESIL_BUF);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205870_CWE-476.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC RLIST *SYMBOLS(RBINFILE *BF) {
	RLIST *RES = R_LIST_NEWF ((RLISTFREE)R_BIN_SYMBOL_FREE);
	R_RETURN_VAL_IF_FAIL (RES && BF->O && BF->O->BIN_OBJ, RES);
	RCORESYMCACHEELEMENT *ELEMENT = BF->O->BIN_OBJ;
	SIZE_T I;
	HTUU *HASH = HT_UU_NEW0 ();
	IF (!HASH) {
		RETURN RES;
	}
	BOOL FOUND = FALSE;
	FOR (I = 0; I < ELEMENT->HDR->N_LINED_SYMBOLS; I++) {
		RCORESYMCACHEELEMENTSYMBOL *SYM = (RCORESYMCACHEELEMENTSYMBOL *)&ELEMENT->LINED_SYMBOLS[I];
		HT_UU_FIND (HASH, SYM->PADDR, &FOUND);
		IF (FOUND) {
			CONTINUE;
		}
		RBINSYMBOL *S = BIN_SYMBOL_FROM_SYMBOL (ELEMENT, SYM);
		IF (S) {
			R_LIST_APPEND (RES, S);
			HT_UU_INSERT (HASH, SYM->PADDR, 1);
		}
	}
	IF (ELEMENT->SYMBOLS) {
		FOR (I = 0; I < ELEMENT->HDR->N_SYMBOLS; I++) {
			RCORESYMCACHEELEMENTSYMBOL *SYM = &ELEMENT->SYMBOLS[I];
			HT_UU_FIND (HASH, SYM->PADDR, &FOUND);
			IF (FOUND) {
				CONTINUE;
			}
			RBINSYMBOL *S = BIN_SYMBOL_FROM_SYMBOL (ELEMENT, SYM);
			IF (S) {
				R_LIST_APPEND (RES, S);
			}
		}
	}
	HT_UU_FREE (HASH);
	RETURN RES;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206921_CWE-703.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
REGMATCH(
    CHAR_U	*SCAN,		    // CURRENT NODE.
    PROFTIME_T	*TM UNUSED,	    // TIMEOUT LIMIT OR NULL
    INT		*TIMED_OUT UNUSED)  // FLAG SET ON TIMEOUT OR NULL
{
  CHAR_U	*NEXT;		// NEXT NODE.
  INT		OP;
  INT		C;
  REGITEM_T	*RP;
  INT		NO;
  INT		STATUS;		// ONE OF THE RA_ VALUES:
#IFDEF FEAT_RELTIME
  INT		TM_COUNT = 0;
#ENDIF

  // MAKE "REGSTACK" AND "BACKPOS" EMPTY.  THEY ARE ALLOCATED AND FREED IN
  // BT_REGEXEC_BOTH() TO REDUCE MALLOC()/FREE() CALLS.
  REGSTACK.GA_LEN = 0;
  BACKPOS.GA_LEN = 0;

  // REPEAT UNTIL "REGSTACK" IS EMPTY.
  FOR (;;)
  {
    // SOME PATTERNS MAY TAKE A LONG TIME TO MATCH, E.G., "\([A-Z]\+\)\+Q".
    // ALLOW INTERRUPTING THEM WITH CTRL-C.
    FAST_BREAKCHECK();

#IFDEF DEBUG
    IF (SCAN != NULL && REGNARRATE)
    {
	MCH_ERRMSG((CHAR *)REGPROP(SCAN));
	MCH_ERRMSG("(\N");
    }
#ENDIF

    // REPEAT FOR ITEMS THAT CAN BE MATCHED SEQUENTIALLY, WITHOUT USING THE
    // REGSTACK.
    FOR (;;)
    {
	IF (GOT_INT || SCAN == NULL)
	{
	    STATUS = RA_FAIL;
	    BREAK;
	}
#IFDEF FEAT_RELTIME
	// CHECK FOR TIMEOUT ONCE IN A 100 TIMES TO AVOID OVERHEAD.
	IF (TM != NULL && ++TM_COUNT == 100)
	{
	    TM_COUNT = 0;
	    IF (PROFILE_PASSED_LIMIT(TM))
	    {
		IF (TIMED_OUT != NULL)
		    *TIMED_OUT = TRUE;
		STATUS = RA_FAIL;
		BREAK;
	    }
	}
#ENDIF
	STATUS = RA_CONT;

#IFDEF DEBUG
	IF (REGNARRATE)
	{
	    MCH_ERRMSG((CHAR *)REGPROP(SCAN));
	    MCH_ERRMSG("...\N");
# IFDEF FEAT_SYN_HL
	    IF (RE_EXTMATCH_IN != NULL)
	    {
		INT I;

		MCH_ERRMSG(_("EXTERNAL SUBMATCHES:\N"));
		FOR (I = 0; I < NSUBEXP; I++)
		{
		    MCH_ERRMSG("    \"");
		    IF (RE_EXTMATCH_IN->MATCHES[I] != NULL)
			MCH_ERRMSG((CHAR *)RE_EXTMATCH_IN->MATCHES[I]);
		    MCH_ERRMSG("\"\N");
		}
	    }
# ENDIF
	}
#ENDIF
	NEXT = REGNEXT(SCAN);

	OP = OP(SCAN);
	// CHECK FOR CHARACTER CLASS WITH NL ADDED.
	IF (!REX.REG_LINE_LBR && WITH_NL(OP) && REG_MULTI
			     && *REX.INPUT == NUL && REX.LNUM <= REX.REG_MAXLINE)
	{
	    REG_NEXTLINE();
	}
	ELSE IF (REX.REG_LINE_LBR && WITH_NL(OP) && *REX.INPUT == '\N')
	{
	    ADVANCE_REGINPUT();
	}
	ELSE
	{
	  IF (WITH_NL(OP))
	      OP -= ADD_NL;
	  IF (HAS_MBYTE)
	      C = (*MB_PTR2CHAR)(REX.INPUT);
	  ELSE
	      C = *REX.INPUT;
	  SWITCH (OP)
	  {
	  CASE BOL:
	    IF (REX.INPUT != REX.LINE)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE EOL:
	    IF (C != NUL)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_BOF:
	    // WE'RE NOT AT THE BEGINNING OF THE FILE WHEN BELOW THE FIRST
	    // LINE WHERE WE STARTED, NOT AT THE START OF THE LINE OR WE
	    // DIDN'T START AT THE FIRST LINE OF THE BUFFER.
	    IF (REX.LNUM != 0 || REX.INPUT != REX.LINE
				       || (REG_MULTI && REX.REG_FIRSTLNUM > 1))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_EOF:
	    IF (REX.LNUM != REX.REG_MAXLINE || C != NUL)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE CURSOR:
	    // CHECK IF THE BUFFER IS IN A WINDOW AND COMPARE THE
	    // REX.REG_WIN->W_CURSOR POSITION TO THE MATCH POSITION.
	    IF (REX.REG_WIN == NULL
		    || (REX.LNUM + REX.REG_FIRSTLNUM
						 != REX.REG_WIN->W_CURSOR.LNUM)
		    || ((COLNR_T)(REX.INPUT - REX.LINE)
						 != REX.REG_WIN->W_CURSOR.COL))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_MARK:
	    // COMPARE THE MARK POSITION TO THE MATCH POSITION.
	    {
		INT	MARK = OPERAND(SCAN)[0];
		INT	CMP = OPERAND(SCAN)[1];
		POS_T	*POS;

		POS = GETMARK_BUF(REX.REG_BUF, MARK, FALSE);
		IF (POS == NULL		     // MARK DOESN'T EXIST
			|| POS->LNUM <= 0)   // MARK ISN'T SET IN REG_BUF
		{
		    STATUS = RA_NOMATCH;
		}
		ELSE
		{
		    COLNR_T POS_COL = POS->LNUM == REX.LNUM + REX.REG_FIRSTLNUM
							  && POS->COL == MAXCOL
				      ? (COLNR_T)STRLEN(REG_GETLINE(
						POS->LNUM - REX.REG_FIRSTLNUM))
				      : POS->COL;

		    IF ((POS->LNUM == REX.LNUM + REX.REG_FIRSTLNUM
				? (POS_COL == (COLNR_T)(REX.INPUT - REX.LINE)
				    ? (CMP == '<' || CMP == '>')
				    : (POS_COL < (COLNR_T)(REX.INPUT - REX.LINE)
					? CMP != '>'
					: CMP != '<'))
				: (POS->LNUM < REX.LNUM + REX.REG_FIRSTLNUM
				    ? CMP != '>'
				    : CMP != '<')))
		    STATUS = RA_NOMATCH;
		}
	    }
	    BREAK;

	  CASE RE_VISUAL:
	    IF (!REG_MATCH_VISUAL())
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_LNUM:
	    IF (!REG_MULTI || !RE_NUM_CMP((LONG_U)(REX.LNUM + REX.REG_FIRSTLNUM),
									SCAN))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_COL:
	    IF (!RE_NUM_CMP((LONG_U)(REX.INPUT - REX.LINE) + 1, SCAN))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE RE_VCOL:
	    IF (!RE_NUM_CMP((LONG_U)WIN_LINETABSIZE(
			    REX.REG_WIN == NULL ? CURWIN : REX.REG_WIN,
			    REX.LINE, (COLNR_T)(REX.INPUT - REX.LINE)) + 1, SCAN))
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE BOW:	// \<WORD; REX.INPUT POINTS TO W
	    IF (C == NUL)	// CAN'T MATCH AT END OF LINE
		STATUS = RA_NOMATCH;
	    ELSE IF (HAS_MBYTE)
	    {
		INT THIS_CLASS;

		// GET CLASS OF CURRENT AND PREVIOUS CHAR (IF IT EXISTS).
		THIS_CLASS = MB_GET_CLASS_BUF(REX.INPUT, REX.REG_BUF);
		IF (THIS_CLASS <= 1)
		    STATUS = RA_NOMATCH;  // NOT ON A WORD AT ALL
		ELSE IF (REG_PREV_CLASS() == THIS_CLASS)
		    STATUS = RA_NOMATCH;  // PREVIOUS CHAR IS IN SAME WORD
	    }
	    ELSE
	    {
		IF (!VIM_ISWORDC_BUF(C, REX.REG_BUF) || (REX.INPUT > REX.LINE
				&& VIM_ISWORDC_BUF(REX.INPUT[-1], REX.REG_BUF)))
		    STATUS = RA_NOMATCH;
	    }
	    BREAK;

	  CASE EOW:	// WORD\>; REX.INPUT POINTS AFTER D
	    IF (REX.INPUT == REX.LINE)    // CAN'T MATCH AT START OF LINE
		STATUS = RA_NOMATCH;
	    ELSE IF (HAS_MBYTE)
	    {
		INT THIS_CLASS, PREV_CLASS;

		// GET CLASS OF CURRENT AND PREVIOUS CHAR (IF IT EXISTS).
		THIS_CLASS = MB_GET_CLASS_BUF(REX.INPUT, REX.REG_BUF);
		PREV_CLASS = REG_PREV_CLASS();
		IF (THIS_CLASS == PREV_CLASS
			|| PREV_CLASS == 0 || PREV_CLASS == 1)
		    STATUS = RA_NOMATCH;
	    }
	    ELSE
	    {
		IF (!VIM_ISWORDC_BUF(REX.INPUT[-1], REX.REG_BUF)
			|| (REX.INPUT[0] != NUL
					   && VIM_ISWORDC_BUF(C, REX.REG_BUF)))
		    STATUS = RA_NOMATCH;
	    }
	    BREAK; // MATCHED WITH EOW

	  CASE ANY:
	    // ANY DOES NOT MATCH NEW LINES.
	    IF (C == NUL)
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE IDENT:
	    IF (!VIM_ISIDC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SIDENT:
	    IF (VIM_ISDIGIT(*REX.INPUT) || !VIM_ISIDC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE KWORD:
	    IF (!VIM_ISWORDP_BUF(REX.INPUT, REX.REG_BUF))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SKWORD:
	    IF (VIM_ISDIGIT(*REX.INPUT)
				    || !VIM_ISWORDP_BUF(REX.INPUT, REX.REG_BUF))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE FNAME:
	    IF (!VIM_ISFILEC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SFNAME:
	    IF (VIM_ISDIGIT(*REX.INPUT) || !VIM_ISFILEC(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE PRINT:
	    IF (!VIM_ISPRINTC(PTR2CHAR(REX.INPUT)))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE SPRINT:
	    IF (VIM_ISDIGIT(*REX.INPUT) || !VIM_ISPRINTC(PTR2CHAR(REX.INPUT)))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE WHITE:
	    IF (!VIM_ISWHITE(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NWHITE:
	    IF (C == NUL || VIM_ISWHITE(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE DIGIT:
	    IF (!RI_DIGIT(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NDIGIT:
	    IF (C == NUL || RI_DIGIT(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE HEX:
	    IF (!RI_HEX(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NHEX:
	    IF (C == NUL || RI_HEX(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE OCTAL:
	    IF (!RI_OCTAL(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NOCTAL:
	    IF (C == NUL || RI_OCTAL(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE WORD:
	    IF (!RI_WORD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NWORD:
	    IF (C == NUL || RI_WORD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE HEAD:
	    IF (!RI_HEAD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NHEAD:
	    IF (C == NUL || RI_HEAD(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE ALPHA:
	    IF (!RI_ALPHA(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NALPHA:
	    IF (C == NUL || RI_ALPHA(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE LOWER:
	    IF (!RI_LOWER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NLOWER:
	    IF (C == NUL || RI_LOWER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE UPPER:
	    IF (!RI_UPPER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE NUPPER:
	    IF (C == NUL || RI_UPPER(C))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE EXACTLY:
	    {
		INT	LEN;
		CHAR_U	*OPND;

		OPND = OPERAND(SCAN);
		// INLINE THE FIRST BYTE, FOR SPEED.
		IF (*OPND != *REX.INPUT
			&& (!REX.REG_IC
			    || (!ENC_UTF8
			      && MB_TOLOWER(*OPND) != MB_TOLOWER(*REX.INPUT))))
		    STATUS = RA_NOMATCH;
		ELSE IF (*OPND == NUL)
		{
		    // MATCH EMPTY STRING ALWAYS WORKS; HAPPENS WHEN "~" IS
		    // EMPTY.
		}
		ELSE
		{
		    IF (OPND[1] == NUL && !(ENC_UTF8 && REX.REG_IC))
		    {
			LEN = 1;	// MATCHED A SINGLE BYTE ABOVE
		    }
		    ELSE
		    {
			// NEED TO MATCH FIRST BYTE AGAIN FOR MULTI-BYTE.
			LEN = (INT)STRLEN(OPND);
			IF (CSTRNCMP(OPND, REX.INPUT, &LEN) != 0)
			    STATUS = RA_NOMATCH;
		    }
		    // CHECK FOR FOLLOWING COMPOSING CHARACTER, UNLESS %C
		    // FOLLOWS (SKIPS OVER ALL COMPOSING CHARS).
		    IF (STATUS != RA_NOMATCH
			    && ENC_UTF8
			    && UTF_COMPOSINGLIKE(REX.INPUT, REX.INPUT + LEN)
			    && !REX.REG_ICOMBINE
			    && OP(NEXT) != RE_COMPOSING)
		    {
			// RAARON: THIS CODE MAKES A COMPOSING CHARACTER GET
			// IGNORED, WHICH IS THE CORRECT BEHAVIOR (SOMETIMES)
			// FOR VOWELED HEBREW TEXTS.
			STATUS = RA_NOMATCH;
		    }
		    IF (STATUS != RA_NOMATCH)
			REX.INPUT += LEN;
		}
	    }
	    BREAK;

	  CASE ANYOF:
	  CASE ANYBUT:
	    IF (C == NUL)
		STATUS = RA_NOMATCH;
	    ELSE IF ((CSTRCHR(OPERAND(SCAN), C) == NULL) == (OP == ANYOF))
		STATUS = RA_NOMATCH;
	    ELSE
		ADVANCE_REGINPUT();
	    BREAK;

	  CASE MULTIBYTECODE:
	    IF (HAS_MBYTE)
	    {
		INT	I, LEN;
		CHAR_U	*OPND;
		INT	OPNDC = 0, INPC;

		OPND = OPERAND(SCAN);
		// SAFETY CHECK (JUST IN CASE 'ENCODING' WAS CHANGED SINCE
		// COMPILING THE PROGRAM).
		IF ((LEN = (*MB_PTR2LEN)(OPND)) < 2)
		{
		    STATUS = RA_NOMATCH;
		    BREAK;
		}
		IF (ENC_UTF8)
		    OPNDC = UTF_PTR2CHAR(OPND);
		IF (ENC_UTF8 && UTF_ISCOMPOSING(OPNDC))
		{
		    // WHEN ONLY A COMPOSING CHAR IS GIVEN MATCH AT ANY
		    // POSITION WHERE THAT COMPOSING CHAR APPEARS.
		    STATUS = RA_NOMATCH;
		    FOR (I = 0; REX.INPUT[I] != NUL;
						I += UTF_PTR2LEN(REX.INPUT + I))
		    {
			INPC = UTF_PTR2CHAR(REX.INPUT + I);
			IF (!UTF_ISCOMPOSING(INPC))
			{
			    IF (I > 0)
				BREAK;
			}
			ELSE IF (OPNDC == INPC)
			{
			    // INCLUDE ALL FOLLOWING COMPOSING CHARS.
			    LEN = I + UTFC_PTR2LEN(REX.INPUT + I);
			    STATUS = RA_MATCH;
			    BREAK;
			}
		    }
		}
		ELSE
		    FOR (I = 0; I < LEN; ++I)
			IF (OPND[I] != REX.INPUT[I])
			{
			    STATUS = RA_NOMATCH;
			    BREAK;
			}
		REX.INPUT += LEN;
	    }
	    ELSE
		STATUS = RA_NOMATCH;
	    BREAK;
	  CASE RE_COMPOSING:
	    IF (ENC_UTF8)
	    {
		// SKIP COMPOSING CHARACTERS.
		WHILE (UTF_ISCOMPOSING(UTF_PTR2CHAR(REX.INPUT)))
		    MB_CPTR_ADV(REX.INPUT);
	    }
	    BREAK;

	  CASE NOTHING:
	    BREAK;

	  CASE BACK:
	    {
		INT		I;
		BACKPOS_T	*BP;

		// WHEN WE RUN INTO BACK WE NEED TO CHECK IF WE DON'T KEEP
		// LOOPING WITHOUT MATCHING ANY INPUT.  THE SECOND AND LATER
		// TIMES A BACK IS ENCOUNTERED IT FAILS IF THE INPUT IS STILL
		// AT THE SAME POSITION AS THE PREVIOUS TIME.
		// THE POSITIONS ARE STORED IN "BACKPOS" AND FOUND BY THE
		// CURRENT VALUE OF "SCAN", THE POSITION IN THE RE PROGRAM.
		BP = (BACKPOS_T *)BACKPOS.GA_DATA;
		FOR (I = 0; I < BACKPOS.GA_LEN; ++I)
		    IF (BP[I].BP_SCAN == SCAN)
			BREAK;
		IF (I == BACKPOS.GA_LEN)
		{
		    // FIRST TIME AT THIS BACK, MAKE ROOM TO STORE THE POS.
		    IF (GA_GROW(&BACKPOS, 1) == FAIL)
			STATUS = RA_FAIL;
		    ELSE
		    {
			// GET "GA_DATA" AGAIN, IT MAY HAVE CHANGED
			BP = (BACKPOS_T *)BACKPOS.GA_DATA;
			BP[I].BP_SCAN = SCAN;
			++BACKPOS.GA_LEN;
		    }
		}
		ELSE IF (REG_SAVE_EQUAL(&BP[I].BP_POS))
		    // STILL AT SAME POSITION AS LAST TIME, FAIL.
		    STATUS = RA_NOMATCH;

		IF (STATUS != RA_FAIL && STATUS != RA_NOMATCH)
		    REG_SAVE(&BP[I].BP_POS, &BACKPOS);
	    }
	    BREAK;

	  CASE MOPEN + 0:   // MATCH START: \ZS
	  CASE MOPEN + 1:   // \(
	  CASE MOPEN + 2:
	  CASE MOPEN + 3:
	  CASE MOPEN + 4:
	  CASE MOPEN + 5:
	  CASE MOPEN + 6:
	  CASE MOPEN + 7:
	  CASE MOPEN + 8:
	  CASE MOPEN + 9:
	    {
		NO = OP - MOPEN;
		CLEANUP_SUBEXPR();
		RP = REGSTACK_PUSH(RS_MOPEN, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REX.REG_STARTPOS[NO],
							  &REX.REG_STARTP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;

	  CASE NOPEN:	    // \%(
	  CASE NCLOSE:	    // \) AFTER \%(
		IF (REGSTACK_PUSH(RS_NOPEN, SCAN) == NULL)
		    STATUS = RA_FAIL;
		// WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		BREAK;

#IFDEF FEAT_SYN_HL
	  CASE ZOPEN + 1:
	  CASE ZOPEN + 2:
	  CASE ZOPEN + 3:
	  CASE ZOPEN + 4:
	  CASE ZOPEN + 5:
	  CASE ZOPEN + 6:
	  CASE ZOPEN + 7:
	  CASE ZOPEN + 8:
	  CASE ZOPEN + 9:
	    {
		NO = OP - ZOPEN;
		CLEANUP_ZSUBEXPR();
		RP = REGSTACK_PUSH(RS_ZOPEN, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REG_STARTZPOS[NO],
							     &REG_STARTZP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;
#ENDIF

	  CASE MCLOSE + 0:  // MATCH END: \ZE
	  CASE MCLOSE + 1:  // \)
	  CASE MCLOSE + 2:
	  CASE MCLOSE + 3:
	  CASE MCLOSE + 4:
	  CASE MCLOSE + 5:
	  CASE MCLOSE + 6:
	  CASE MCLOSE + 7:
	  CASE MCLOSE + 8:
	  CASE MCLOSE + 9:
	    {
		NO = OP - MCLOSE;
		CLEANUP_SUBEXPR();
		RP = REGSTACK_PUSH(RS_MCLOSE, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REX.REG_ENDPOS[NO],
							    &REX.REG_ENDP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE ZCLOSE + 1:  // \) AFTER \Z(
	  CASE ZCLOSE + 2:
	  CASE ZCLOSE + 3:
	  CASE ZCLOSE + 4:
	  CASE ZCLOSE + 5:
	  CASE ZCLOSE + 6:
	  CASE ZCLOSE + 7:
	  CASE ZCLOSE + 8:
	  CASE ZCLOSE + 9:
	    {
		NO = OP - ZCLOSE;
		CLEANUP_ZSUBEXPR();
		RP = REGSTACK_PUSH(RS_ZCLOSE, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    RP->RS_NO = NO;
		    SAVE_SE(&RP->RS_UN.SESAVE, &REG_ENDZPOS[NO],
							      &REG_ENDZP[NO]);
		    // WE SIMPLY CONTINUE AND HANDLE THE RESULT WHEN DONE.
		}
	    }
	    BREAK;
#ENDIF

	  CASE BACKREF + 1:
	  CASE BACKREF + 2:
	  CASE BACKREF + 3:
	  CASE BACKREF + 4:
	  CASE BACKREF + 5:
	  CASE BACKREF + 6:
	  CASE BACKREF + 7:
	  CASE BACKREF + 8:
	  CASE BACKREF + 9:
	    {
		INT		LEN;

		NO = OP - BACKREF;
		CLEANUP_SUBEXPR();
		IF (!REG_MULTI)		// SINGLE-LINE REGEXP
		{
		    IF (REX.REG_STARTP[NO] == NULL || REX.REG_ENDP[NO] == NULL)
		    {
			// BACKREF WAS NOT SET: MATCH AN EMPTY STRING.
			LEN = 0;
		    }
		    ELSE
		    {
			// COMPARE CURRENT INPUT WITH BACK-REF IN THE SAME
			// LINE.
			LEN = (INT)(REX.REG_ENDP[NO] - REX.REG_STARTP[NO]);
			IF (CSTRNCMP(REX.REG_STARTP[NO], REX.INPUT, &LEN) != 0)
			    STATUS = RA_NOMATCH;
		    }
		}
		ELSE				// MULTI-LINE REGEXP
		{
		    IF (REX.REG_STARTPOS[NO].LNUM < 0
						|| REX.REG_ENDPOS[NO].LNUM < 0)
		    {
			// BACKREF WAS NOT SET: MATCH AN EMPTY STRING.
			LEN = 0;
		    }
		    ELSE
		    {
			IF (REX.REG_STARTPOS[NO].LNUM == REX.LNUM
				&& REX.REG_ENDPOS[NO].LNUM == REX.LNUM)
			{
			    // COMPARE BACK-REF WITHIN THE CURRENT LINE.
			    LEN = REX.REG_ENDPOS[NO].COL
						    - REX.REG_STARTPOS[NO].COL;
			    IF (CSTRNCMP(REX.LINE + REX.REG_STARTPOS[NO].COL,
							  REX.INPUT, &LEN) != 0)
				STATUS = RA_NOMATCH;
			}
			ELSE
			{
			    // MESSY SITUATION: NEED TO COMPARE BETWEEN TWO
			    // LINES.
			    INT R = MATCH_WITH_BACKREF(
					    REX.REG_STARTPOS[NO].LNUM,
					    REX.REG_STARTPOS[NO].COL,
					    REX.REG_ENDPOS[NO].LNUM,
					    REX.REG_ENDPOS[NO].COL,
					    &LEN);

			    IF (R != RA_MATCH)
				STATUS = R;
			}
		    }
		}

		// MATCHED THE BACKREF, SKIP OVER IT.
		REX.INPUT += LEN;
	    }
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE ZREF + 1:
	  CASE ZREF + 2:
	  CASE ZREF + 3:
	  CASE ZREF + 4:
	  CASE ZREF + 5:
	  CASE ZREF + 6:
	  CASE ZREF + 7:
	  CASE ZREF + 8:
	  CASE ZREF + 9:
	    {
		INT	LEN;

		CLEANUP_ZSUBEXPR();
		NO = OP - ZREF;
		IF (RE_EXTMATCH_IN != NULL
			&& RE_EXTMATCH_IN->MATCHES[NO] != NULL)
		{
		    LEN = (INT)STRLEN(RE_EXTMATCH_IN->MATCHES[NO]);
		    IF (CSTRNCMP(RE_EXTMATCH_IN->MATCHES[NO],
							  REX.INPUT, &LEN) != 0)
			STATUS = RA_NOMATCH;
		    ELSE
			REX.INPUT += LEN;
		}
		ELSE
		{
		    // BACKREF WAS NOT SET: MATCH AN EMPTY STRING.
		}
	    }
	    BREAK;
#ENDIF

	  CASE BRANCH:
	    {
		IF (OP(NEXT) != BRANCH) // NO CHOICE.
		    NEXT = OPERAND(SCAN);	// AVOID RECURSION.
		ELSE
		{
		    RP = REGSTACK_PUSH(RS_BRANCH, SCAN);
		    IF (RP == NULL)
			STATUS = RA_FAIL;
		    ELSE
			STATUS = RA_BREAK;	// REST IS BELOW
		}
	    }
	    BREAK;

	  CASE BRACE_LIMITS:
	    {
		IF (OP(NEXT) == BRACE_SIMPLE)
		{
		    BL_MINVAL = OPERAND_MIN(SCAN);
		    BL_MAXVAL = OPERAND_MAX(SCAN);
		}
		ELSE IF (OP(NEXT) >= BRACE_COMPLEX
			&& OP(NEXT) < BRACE_COMPLEX + 10)
		{
		    NO = OP(NEXT) - BRACE_COMPLEX;
		    BRACE_MIN[NO] = OPERAND_MIN(SCAN);
		    BRACE_MAX[NO] = OPERAND_MAX(SCAN);
		    BRACE_COUNT[NO] = 0;
		}
		ELSE
		{
		    INTERNAL_ERROR("BRACE_LIMITS");
		    STATUS = RA_FAIL;
		}
	    }
	    BREAK;

	  CASE BRACE_COMPLEX + 0:
	  CASE BRACE_COMPLEX + 1:
	  CASE BRACE_COMPLEX + 2:
	  CASE BRACE_COMPLEX + 3:
	  CASE BRACE_COMPLEX + 4:
	  CASE BRACE_COMPLEX + 5:
	  CASE BRACE_COMPLEX + 6:
	  CASE BRACE_COMPLEX + 7:
	  CASE BRACE_COMPLEX + 8:
	  CASE BRACE_COMPLEX + 9:
	    {
		NO = OP - BRACE_COMPLEX;
		++BRACE_COUNT[NO];

		// IF NOT MATCHED ENOUGH TIMES YET, TRY ONE MORE
		IF (BRACE_COUNT[NO] <= (BRACE_MIN[NO] <= BRACE_MAX[NO]
					     ? BRACE_MIN[NO] : BRACE_MAX[NO]))
		{
		    RP = REGSTACK_PUSH(RS_BRCPLX_MORE, SCAN);
		    IF (RP == NULL)
			STATUS = RA_FAIL;
		    ELSE
		    {
			RP->RS_NO = NO;
			REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			NEXT = OPERAND(SCAN);
			// WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
		    }
		    BREAK;
		}

		// IF MATCHED ENOUGH TIMES, MAY TRY MATCHING SOME MORE
		IF (BRACE_MIN[NO] <= BRACE_MAX[NO])
		{
		    // RANGE IS THE NORMAL WAY AROUND, USE LONGEST MATCH
		    IF (BRACE_COUNT[NO] <= BRACE_MAX[NO])
		    {
			RP = REGSTACK_PUSH(RS_BRCPLX_LONG, SCAN);
			IF (RP == NULL)
			    STATUS = RA_FAIL;
			ELSE
			{
			    RP->RS_NO = NO;
			    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			    NEXT = OPERAND(SCAN);
			    // WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
			}
		    }
		}
		ELSE
		{
		    // RANGE IS BACKWARDS, USE SHORTEST MATCH FIRST
		    IF (BRACE_COUNT[NO] <= BRACE_MIN[NO])
		    {
			RP = REGSTACK_PUSH(RS_BRCPLX_SHORT, SCAN);
			IF (RP == NULL)
			    STATUS = RA_FAIL;
			ELSE
			{
			    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			    // WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
			}
		    }
		}
	    }
	    BREAK;

	  CASE BRACE_SIMPLE:
	  CASE STAR:
	  CASE PLUS:
	    {
		REGSTAR_T	RST;

		// LOOKAHEAD TO AVOID USELESS MATCH ATTEMPTS WHEN WE KNOW
		// WHAT CHARACTER COMES NEXT.
		IF (OP(NEXT) == EXACTLY)
		{
		    RST.NEXTB = *OPERAND(NEXT);
		    IF (REX.REG_IC)
		    {
			IF (MB_ISUPPER(RST.NEXTB))
			    RST.NEXTB_IC = MB_TOLOWER(RST.NEXTB);
			ELSE
			    RST.NEXTB_IC = MB_TOUPPER(RST.NEXTB);
		    }
		    ELSE
			RST.NEXTB_IC = RST.NEXTB;
		}
		ELSE
		{
		    RST.NEXTB = NUL;
		    RST.NEXTB_IC = NUL;
		}
		IF (OP != BRACE_SIMPLE)
		{
		    RST.MINVAL = (OP == STAR) ? 0 : 1;
		    RST.MAXVAL = MAX_LIMIT;
		}
		ELSE
		{
		    RST.MINVAL = BL_MINVAL;
		    RST.MAXVAL = BL_MAXVAL;
		}

		// WHEN MAXVAL > MINVAL, TRY MATCHING AS MUCH AS POSSIBLE, UP
		// TO MAXVAL.  WHEN MAXVAL < MINVAL, TRY MATCHING AT LEAST THE
		// MINIMAL NUMBER (SINCE THE RANGE IS BACKWARDS, THAT'S ALSO
		// MAXVAL!).
		RST.COUNT = REGREPEAT(OPERAND(SCAN), RST.MAXVAL);
		IF (GOT_INT)
		{
		    STATUS = RA_FAIL;
		    BREAK;
		}
		IF (RST.MINVAL <= RST.MAXVAL
			  ? RST.COUNT >= RST.MINVAL : RST.COUNT >= RST.MAXVAL)
		{
		    // IT COULD MATCH.  PREPARE FOR TRYING TO MATCH WHAT
		    // FOLLOWS.  THE CODE IS BELOW.  PARAMETERS ARE STORED IN
		    // A REGSTAR_T ON THE REGSTACK.
		    IF ((LONG)((UNSIGNED)REGSTACK.GA_LEN >> 10) >= P_MMP)
		    {
			EMSG(_(E_PATTERN_USES_MORE_MEMORY_THAN_MAXMEMPATTERN));
			STATUS = RA_FAIL;
		    }
		    ELSE IF (GA_GROW(&REGSTACK, SIZEOF(REGSTAR_T)) == FAIL)
			STATUS = RA_FAIL;
		    ELSE
		    {
			REGSTACK.GA_LEN += SIZEOF(REGSTAR_T);
			RP = REGSTACK_PUSH(RST.MINVAL <= RST.MAXVAL
					? RS_STAR_LONG : RS_STAR_SHORT, SCAN);
			IF (RP == NULL)
			    STATUS = RA_FAIL;
			ELSE
			{
			    *(((REGSTAR_T *)RP) - 1) = RST;
			    STATUS = RA_BREAK;	    // SKIP THE RESTORE BITS
			}
		    }
		}
		ELSE
		    STATUS = RA_NOMATCH;

	    }
	    BREAK;

	  CASE NOMATCH:
	  CASE MATCH:
	  CASE SUBPAT:
	    RP = REGSTACK_PUSH(RS_NOMATCH, SCAN);
	    IF (RP == NULL)
		STATUS = RA_FAIL;
	    ELSE
	    {
		RP->RS_NO = OP;
		REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
		NEXT = OPERAND(SCAN);
		// WE CONTINUE AND HANDLE THE RESULT WHEN DONE.
	    }
	    BREAK;

	  CASE BEHIND:
	  CASE NOBEHIND:
	    // NEED A BIT OF ROOM TO STORE EXTRA POSITIONS.
	    IF ((LONG)((UNSIGNED)REGSTACK.GA_LEN >> 10) >= P_MMP)
	    {
		EMSG(_(E_PATTERN_USES_MORE_MEMORY_THAN_MAXMEMPATTERN));
		STATUS = RA_FAIL;
	    }
	    ELSE IF (GA_GROW(&REGSTACK, SIZEOF(REGBEHIND_T)) == FAIL)
		STATUS = RA_FAIL;
	    ELSE
	    {
		REGSTACK.GA_LEN += SIZEOF(REGBEHIND_T);
		RP = REGSTACK_PUSH(RS_BEHIND1, SCAN);
		IF (RP == NULL)
		    STATUS = RA_FAIL;
		ELSE
		{
		    // NEED TO SAVE THE SUBEXPR TO BE ABLE TO RESTORE THEM
		    // WHEN THERE IS A MATCH BUT WE DON'T USE IT.
		    SAVE_SUBEXPR(((REGBEHIND_T *)RP) - 1);

		    RP->RS_NO = OP;
		    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    // FIRST TRY IF WHAT FOLLOWS MATCHES.  IF IT DOES THEN WE
		    // CHECK THE BEHIND MATCH BY LOOPING.
		}
	    }
	    BREAK;

	  CASE BHPOS:
	    IF (REG_MULTI)
	    {
		IF (BEHIND_POS.RS_U.POS.COL != (COLNR_T)(REX.INPUT - REX.LINE)
			|| BEHIND_POS.RS_U.POS.LNUM != REX.LNUM)
		    STATUS = RA_NOMATCH;
	    }
	    ELSE IF (BEHIND_POS.RS_U.PTR != REX.INPUT)
		STATUS = RA_NOMATCH;
	    BREAK;

	  CASE NEWL:
	    IF ((C != NUL || !REG_MULTI || REX.LNUM > REX.REG_MAXLINE
			     || REX.REG_LINE_LBR)
					   && (C != '\N' || !REX.REG_LINE_LBR))
		STATUS = RA_NOMATCH;
	    ELSE IF (REX.REG_LINE_LBR)
		ADVANCE_REGINPUT();
	    ELSE
		REG_NEXTLINE();
	    BREAK;

	  CASE END:
	    STATUS = RA_MATCH;	// SUCCESS!
	    BREAK;

	  DEFAULT:
	    IEMSG(_(E_CORRUPTED_REGEXP_PROGRAM));
#IFDEF DEBUG
	    PRINTF("ILLEGAL OP CODE %D\N", OP);
#ENDIF
	    STATUS = RA_FAIL;
	    BREAK;
	  }
	}

	// IF WE CAN'T CONTINUE SEQUENTIALLY, BREAK THE INNER LOOP.
	IF (STATUS != RA_CONT)
	    BREAK;

	// CONTINUE IN INNER LOOP, ADVANCE TO NEXT ITEM.
	SCAN = NEXT;

    } // END OF INNER LOOP

    // IF THERE IS SOMETHING ON THE REGSTACK EXECUTE THE CODE FOR THE STATE.
    // IF THE STATE IS POPPED THEN LOOP AND USE THE OLDER STATE.
    WHILE (REGSTACK.GA_LEN > 0 && STATUS != RA_FAIL)
    {
	RP = (REGITEM_T *)((CHAR *)REGSTACK.GA_DATA + REGSTACK.GA_LEN) - 1;
	SWITCH (RP->RS_STATE)
	{
	  CASE RS_NOPEN:
	    // RESULT IS PASSED ON AS-IS, SIMPLY POP THE STATE.
	    REGSTACK_POP(&SCAN);
	    BREAK;

	  CASE RS_MOPEN:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REX.REG_STARTPOS[RP->RS_NO],
						  &REX.REG_STARTP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE RS_ZOPEN:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REG_STARTZPOS[RP->RS_NO],
						 &REG_STARTZP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;
#ENDIF

	  CASE RS_MCLOSE:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REX.REG_ENDPOS[RP->RS_NO],
						    &REX.REG_ENDP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;

#IFDEF FEAT_SYN_HL
	  CASE RS_ZCLOSE:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		RESTORE_SE(&RP->RS_UN.SESAVE, &REG_ENDZPOS[RP->RS_NO],
						   &REG_ENDZP[RP->RS_NO]);
	    REGSTACK_POP(&SCAN);
	    BREAK;
#ENDIF

	  CASE RS_BRANCH:
	    IF (STATUS == RA_MATCH)
		// THIS BRANCH MATCHED, USE IT
		REGSTACK_POP(&SCAN);
	    ELSE
	    {
		IF (STATUS != RA_BREAK)
		{
		    // AFTER A NON-MATCHING BRANCH: TRY NEXT ONE.
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    SCAN = RP->RS_SCAN;
		}
		IF (SCAN == NULL || OP(SCAN) != BRANCH)
		{
		    // NO MORE BRANCHES, DIDN'T FIND A MATCH
		    STATUS = RA_NOMATCH;
		    REGSTACK_POP(&SCAN);
		}
		ELSE
		{
		    // PREPARE TO TRY A BRANCH.
		    RP->RS_SCAN = REGNEXT(SCAN);
		    REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    SCAN = OPERAND(SCAN);
		}
	    }
	    BREAK;

	  CASE RS_BRCPLX_MORE:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
	    {
		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		--BRACE_COUNT[RP->RS_NO];	// DECREMENT MATCH COUNT
	    }
	    REGSTACK_POP(&SCAN);
	    BREAK;

	  CASE RS_BRCPLX_LONG:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
	    {
		// THERE WAS NO MATCH, BUT WE DID FIND ENOUGH MATCHES.
		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		--BRACE_COUNT[RP->RS_NO];
		// CONTINUE WITH THE ITEMS AFTER "\{}"
		STATUS = RA_CONT;
	    }
	    REGSTACK_POP(&SCAN);
	    IF (STATUS == RA_CONT)
		SCAN = REGNEXT(SCAN);
	    BREAK;

	  CASE RS_BRCPLX_SHORT:
	    // POP THE STATE.  RESTORE POINTERS WHEN THERE IS NO MATCH.
	    IF (STATUS == RA_NOMATCH)
		// THERE WAS NO MATCH, TRY TO MATCH ONE MORE ITEM.
		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
	    REGSTACK_POP(&SCAN);
	    IF (STATUS == RA_NOMATCH)
	    {
		SCAN = OPERAND(SCAN);
		STATUS = RA_CONT;
	    }
	    BREAK;

	  CASE RS_NOMATCH:
	    // POP THE STATE.  IF THE OPERAND MATCHES FOR NOMATCH OR
	    // DOESN'T MATCH FOR MATCH/SUBPAT, WE FAIL.  OTHERWISE BACKUP,
	    // EXCEPT FOR SUBPAT, AND CONTINUE WITH THE NEXT ITEM.
	    IF (STATUS == (RP->RS_NO == NOMATCH ? RA_MATCH : RA_NOMATCH))
		STATUS = RA_NOMATCH;
	    ELSE
	    {
		STATUS = RA_CONT;
		IF (RP->RS_NO != SUBPAT)	// ZERO-WIDTH
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
	    }
	    REGSTACK_POP(&SCAN);
	    IF (STATUS == RA_CONT)
		SCAN = REGNEXT(SCAN);
	    BREAK;

	  CASE RS_BEHIND1:
	    IF (STATUS == RA_NOMATCH)
	    {
		REGSTACK_POP(&SCAN);
		REGSTACK.GA_LEN -= SIZEOF(REGBEHIND_T);
	    }
	    ELSE
	    {
		// THE STUFF AFTER BEHIND/NOBEHIND MATCHES.  NOW TRY IF
		// THE BEHIND PART DOES (NOT) MATCH BEFORE THE CURRENT
		// POSITION IN THE INPUT.  THIS MUST BE DONE AT EVERY
		// POSITION IN THE INPUT AND CHECKING IF THE MATCH ENDS AT
		// THE CURRENT POSITION.

		// SAVE THE POSITION AFTER THE FOUND MATCH FOR NEXT
		REG_SAVE(&(((REGBEHIND_T *)RP) - 1)->SAVE_AFTER, &BACKPOS);

		// START LOOKING FOR A MATCH WITH OPERAND AT THE CURRENT
		// POSITION.  GO BACK ONE CHARACTER UNTIL WE FIND THE
		// RESULT, HITTING THE START OF THE LINE OR THE PREVIOUS
		// LINE (FOR MULTI-LINE MATCHING).
		// SET BEHIND_POS TO WHERE THE MATCH SHOULD END, BHPOS
		// WILL MATCH IT.  SAVE THE CURRENT VALUE.
		(((REGBEHIND_T *)RP) - 1)->SAVE_BEHIND = BEHIND_POS;
		BEHIND_POS = RP->RS_UN.REGSAVE;

		RP->RS_STATE = RS_BEHIND2;

		REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		SCAN = OPERAND(RP->RS_SCAN) + 4;
	    }
	    BREAK;

	  CASE RS_BEHIND2:
	    // LOOPING FOR BEHIND / NOBEHIND MATCH.
	    IF (STATUS == RA_MATCH && REG_SAVE_EQUAL(&BEHIND_POS))
	    {
		// FOUND A MATCH THAT ENDS WHERE "NEXT" STARTED
		BEHIND_POS = (((REGBEHIND_T *)RP) - 1)->SAVE_BEHIND;
		IF (RP->RS_NO == BEHIND)
		    REG_RESTORE(&(((REGBEHIND_T *)RP) - 1)->SAVE_AFTER,
								    &BACKPOS);
		ELSE
		{
		    // BUT WE DIDN'T WANT A MATCH.  NEED TO RESTORE THE
		    // SUBEXPR, BECAUSE WHAT FOLLOWS MATCHED, SO THEY HAVE
		    // BEEN SET.
		    STATUS = RA_NOMATCH;
		    RESTORE_SUBEXPR(((REGBEHIND_T *)RP) - 1);
		}
		REGSTACK_POP(&SCAN);
		REGSTACK.GA_LEN -= SIZEOF(REGBEHIND_T);
	    }
	    ELSE
	    {
		LONG LIMIT;

		// NO MATCH OR A MATCH THAT DOESN'T END WHERE WE WANT IT: GO
		// BACK ONE CHARACTER.  MAY GO TO PREVIOUS LINE ONCE.
		NO = OK;
		LIMIT = OPERAND_MIN(RP->RS_SCAN);
		IF (REG_MULTI)
		{
		    IF (LIMIT > 0
			    && ((RP->RS_UN.REGSAVE.RS_U.POS.LNUM
						    < BEHIND_POS.RS_U.POS.LNUM
				    ? (COLNR_T)STRLEN(REX.LINE)
				    : BEHIND_POS.RS_U.POS.COL)
				- RP->RS_UN.REGSAVE.RS_U.POS.COL >= LIMIT))
			NO = FAIL;
		    ELSE IF (RP->RS_UN.REGSAVE.RS_U.POS.COL == 0)
		    {
			IF (RP->RS_UN.REGSAVE.RS_U.POS.LNUM
					< BEHIND_POS.RS_U.POS.LNUM
				|| REG_GETLINE(
					--RP->RS_UN.REGSAVE.RS_U.POS.LNUM)
								  == NULL)
			    NO = FAIL;
			ELSE
			{
			    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
			    RP->RS_UN.REGSAVE.RS_U.POS.COL =
						 (COLNR_T)STRLEN(REX.LINE);
			}
		    }
		    ELSE
		    {
			IF (HAS_MBYTE)
			{
			    CHAR_U *LINE =
				  REG_GETLINE(RP->RS_UN.REGSAVE.RS_U.POS.LNUM);

			    RP->RS_UN.REGSAVE.RS_U.POS.COL -=
				(*MB_HEAD_OFF)(LINE, LINE
				    + RP->RS_UN.REGSAVE.RS_U.POS.COL - 1) + 1;
			}
			ELSE
			    --RP->RS_UN.REGSAVE.RS_U.POS.COL;
		    }
		}
		ELSE
		{
		    IF (RP->RS_UN.REGSAVE.RS_U.PTR == REX.LINE)
			NO = FAIL;
		    ELSE
		    {
			MB_PTR_BACK(REX.LINE, RP->RS_UN.REGSAVE.RS_U.PTR);
			IF (LIMIT > 0 && (LONG)(BEHIND_POS.RS_U.PTR
				     - RP->RS_UN.REGSAVE.RS_U.PTR) > LIMIT)
			    NO = FAIL;
		    }
		}
		IF (NO == OK)
		{
		    // ADVANCED, PREPARE FOR FINDING MATCH AGAIN.
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);
		    SCAN = OPERAND(RP->RS_SCAN) + 4;
		    IF (STATUS == RA_MATCH)
		    {
			// WE DID MATCH, SO SUBEXPR MAY HAVE BEEN CHANGED,
			// NEED TO RESTORE THEM FOR THE NEXT TRY.
			STATUS = RA_NOMATCH;
			RESTORE_SUBEXPR(((REGBEHIND_T *)RP) - 1);
		    }
		}
		ELSE
		{
		    // CAN'T ADVANCE.  FOR NOBEHIND THAT'S A MATCH.
		    BEHIND_POS = (((REGBEHIND_T *)RP) - 1)->SAVE_BEHIND;
		    IF (RP->RS_NO == NOBEHIND)
		    {
			REG_RESTORE(&(((REGBEHIND_T *)RP) - 1)->SAVE_AFTER,
								    &BACKPOS);
			STATUS = RA_MATCH;
		    }
		    ELSE
		    {
			// WE DO WANT A PROPER MATCH.  NEED TO RESTORE THE
			// SUBEXPR IF WE HAD A MATCH, BECAUSE THEY MAY HAVE
			// BEEN SET.
			IF (STATUS == RA_MATCH)
			{
			    STATUS = RA_NOMATCH;
			    RESTORE_SUBEXPR(((REGBEHIND_T *)RP) - 1);
			}
		    }
		    REGSTACK_POP(&SCAN);
		    REGSTACK.GA_LEN -= SIZEOF(REGBEHIND_T);
		}
	    }
	    BREAK;

	  CASE RS_STAR_LONG:
	  CASE RS_STAR_SHORT:
	    {
		REGSTAR_T	    *RST = ((REGSTAR_T *)RP) - 1;

		IF (STATUS == RA_MATCH)
		{
		    REGSTACK_POP(&SCAN);
		    REGSTACK.GA_LEN -= SIZEOF(REGSTAR_T);
		    BREAK;
		}

		// TRIED ONCE ALREADY, RESTORE INPUT POINTERS.
		IF (STATUS != RA_BREAK)
		    REG_RESTORE(&RP->RS_UN.REGSAVE, &BACKPOS);

		// REPEAT UNTIL WE FOUND A POSITION WHERE IT COULD MATCH.
		FOR (;;)
		{
		    IF (STATUS != RA_BREAK)
		    {
			// TRIED FIRST POSITION ALREADY, ADVANCE.
			IF (RP->RS_STATE == RS_STAR_LONG)
			{
			    // TRYING FOR LONGEST MATCH, BUT COULDN'T OR
			    // DIDN'T MATCH -- BACK UP ONE CHAR.
			    IF (--RST->COUNT < RST->MINVAL)
				BREAK;
			    IF (REX.INPUT == REX.LINE)
			    {
				// BACKUP TO LAST CHAR OF PREVIOUS LINE
				--REX.LNUM;
				REX.LINE = REG_GETLINE(REX.LNUM);
				// JUST IN CASE REGREPEAT() DIDN'T COUNT
				// RIGHT.
				IF (REX.LINE == NULL)
				    BREAK;
				REX.INPUT = REX.LINE + STRLEN(REX.LINE);
				FAST_BREAKCHECK();
			    }
			    ELSE
				MB_PTR_BACK(REX.LINE, REX.INPUT);
			}
			ELSE
			{
			    // RANGE IS BACKWARDS, USE SHORTEST MATCH FIRST.
			    // CAREFUL: MAXVAL AND MINVAL ARE EXCHANGED!
			    // COULDN'T OR DIDN'T MATCH: TRY ADVANCING ONE
			    // CHAR.
			    IF (RST->COUNT == RST->MINVAL
				  || REGREPEAT(OPERAND(RP->RS_SCAN), 1L) == 0)
				BREAK;
			    ++RST->COUNT;
			}
			IF (GOT_INT)
			    BREAK;
		    }
		    ELSE
			STATUS = RA_NOMATCH;

		    // IF IT COULD MATCH, TRY IT.
		    IF (RST->NEXTB == NUL || *REX.INPUT == RST->NEXTB
					     || *REX.INPUT == RST->NEXTB_IC)
		    {
			REG_SAVE(&RP->RS_UN.REGSAVE, &BACKPOS);
			SCAN = REGNEXT(RP->RS_SCAN);
			STATUS = RA_CONT;
			BREAK;
		    }
		}
		IF (STATUS != RA_CONT)
		{
		    // FAILED.
		    REGSTACK_POP(&SCAN);
		    REGSTACK.GA_LEN -= SIZEOF(REGSTAR_T);
		    STATUS = RA_NOMATCH;
		}
	    }
	    BREAK;
	}

	// IF WE WANT TO CONTINUE THE INNER LOOP OR DIDN'T POP A STATE
	// CONTINUE MATCHING LOOP
	IF (STATUS == RA_CONT || RP == (REGITEM_T *)
			     ((CHAR *)REGSTACK.GA_DATA + REGSTACK.GA_LEN) - 1)
	    BREAK;
    }

    // MAY NEED TO CONTINUE WITH THE INNER LOOP, STARTING AT "SCAN".
    IF (STATUS == RA_CONT)
	CONTINUE;

    // IF THE REGSTACK IS EMPTY OR SOMETHING FAILED WE ARE DONE.
    IF (REGSTACK.GA_LEN == 0 || STATUS == RA_FAIL)
    {
	IF (SCAN == NULL)
	{
	    // WE GET HERE ONLY IF THERE'S TROUBLE -- NORMALLY "CASE END" IS
	    // THE TERMINATING POINT.
	    IEMSG(_(E_CORRUPTED_REGEXP_PROGRAM));
#IFDEF DEBUG
	    PRINTF("PREMATURE EOL\N");
#ENDIF
	}
	RETURN (STATUS == RA_MATCH);
    }

  } // END OF LOOP UNTIL THE REGSTACK IS EMPTY.

  // NOTREACHED
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 430460_NOT_VULNERABLE.C
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT OVS_NLA_PUT_KEY(CONST STRUCT SW_FLOW_KEY *SWKEY,
		    CONST STRUCT SW_FLOW_KEY *OUTPUT, INT ATTR, BOOL IS_MASK,
		    STRUCT SK_BUFF *SKB)
{
	INT ERR;
	STRUCT NLATTR *NLA;

	NLA = NLA_NEST_START_NOFLAG(SKB, ATTR);
	IF (!NLA)
		RETURN -EMSGSIZE;
	ERR = __OVS_NLA_PUT_KEY(SWKEY, OUTPUT, IS_MASK, SKB);
	IF (ERR)
		RETURN ERR;
	NLA_NEST_END(SKB, NLA);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90907_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
USAGETRACKER::USAGETRACKER(CONST QUOTACLIENTLIST& CLIENTS, STORAGETYPE TYPE,
                           SPECIALSTORAGEPOLICY* SPECIAL_STORAGE_POLICY)
    : TYPE_(TYPE),
      CALLBACK_FACTORY_(ALLOW_THIS_IN_INITIALIZER_LIST(THIS)) {
  FOR (QUOTACLIENTLIST::CONST_ITERATOR ITER = CLIENTS.BEGIN();
      ITER != CLIENTS.END();
      ++ITER) {
    CLIENT_TRACKER_MAP_.INSERT(STD::MAKE_PAIR(
        (*ITER)->ID(),
        NEW CLIENTUSAGETRACKER(THIS, *ITER, TYPE, SPECIAL_STORAGE_POLICY)));
  }
}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 447052_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
    VOID MEMIO::IMPL::RESERVE(LONG WCOUNT)
    {
        LONG NEED = WCOUNT + IDX_;

        IF (!ISMALLOCED_) {
            // MINIMUM SIZE FOR 1ST BLOCK IS 32KB
            LONG SIZE  = EXV_MAX(32768 * (1 + NEED / 32768), SIZE_);
            BYTE* DATA = (BYTE*)STD::MALLOC(SIZE);
            STD::MEMCPY(DATA, DATA_, SIZE_);
            DATA_ = DATA;
            SIZEALLOCED_ = SIZE;
            ISMALLOCED_ = TRUE;
        }

        IF (NEED > SIZE_) {
            IF (NEED > SIZEALLOCED_) {
                // ALLOCATE IN BLOCKS OF 32KB
                LONG WANT = 32768 * (1 + NEED / 32768);
                DATA_ = (BYTE*)STD::REALLOC(DATA_, WANT);
                SIZEALLOCED_ = WANT;
                ISMALLOCED_ = TRUE;
            }
            SIZE_ = NEED;
        }
    }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 508839_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ST_SELECT_LEX::SAVE_PREP_LEAF_TABLES(THD *THD)
{
  IF (PREP_LEAF_LIST_STATE == SAVED)
    RETURN FALSE;

  LIST_ITERATOR_FAST<TABLE_LIST> LI(LEAF_TABLES);
  TABLE_LIST *TABLE;

  /*
    CHECK THAT THE SELECT_LEX WAS REALLY PREPARED AND SO TABLES ARE SETUP.

    IT CAN BE SUBQUERY IN SET CLAUSE OF UPDATE WHICH WAS NOT PREPARED YET, SO
    ITS TABLES ARE NOT YET SETUP AND READY FOR STORING.
  */
  IF (PREP_LEAF_LIST_STATE != READY)
    RETURN FALSE;

  WHILE ((TABLE= LI++))
  {
    IF (LEAF_TABLES_PREP.PUSH_BACK(TABLE))
      RETURN TRUE;
  }
  PREP_LEAF_LIST_STATE= SAVED;
  FOR (SELECT_LEX_UNIT *U= FIRST_INNER_UNIT(); U; U= U->NEXT_UNIT())
  {
    FOR (SELECT_LEX *SL= U->FIRST_SELECT(); SL; SL= SL->NEXT_SELECT())
    {
      IF (SL->SAVE_PREP_LEAF_TABLES(THD))
        RETURN TRUE;
    }
  }

  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90904_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL SORTBYHOST(CONST GURL& LHS, CONST GURL& RHS) {
  RETURN NET::GETHOSTORSPECFROMURL(LHS) > NET::GETHOSTORSPECFROMURL(RHS);
}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210273_CWE-617.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CREATERANDOMCURSOREXECUTOR(CONST COLLECTIONPTR& COLL,
                           CONST BOOST::INTRUSIVE_PTR<EXPRESSIONCONTEXT>& EXPCTX,
                           LONG LONG SAMPLESIZE,
                           LONG LONG NUMRECORDS,
                           BOOST::OPTIONAL<BUCKETUNPACKER> BUCKETUNPACKER) {
    OPERATIONCONTEXT* OPCTX = EXPCTX->OPCTX;

    // VERIFY THAT WE ARE ALREADY UNDER A COLLECTION LOCK. WE AVOID TAKING LOCKS OURSELVES IN THIS
    // FUNCTION BECAUSE DOUBLE-LOCKING FORCES ANY PLANEXECUTOR WE CREATE TO ADOPT A NO_YIELD POLICY.
    INVARIANT(OPCTX->LOCKSTATE()->ISCOLLECTIONLOCKEDFORMODE(COLL->NS(), MODE_IS));

    STATIC CONST DOUBLE KMAXSAMPLERATIOFORRANDCURSOR = 0.05;
    IF (!EXPCTX->NS.ISTIMESERIESBUCKETSCOLLECTION()) {
        IF (SAMPLESIZE > NUMRECORDS * KMAXSAMPLERATIOFORRANDCURSOR || NUMRECORDS <= 100) {
            RETURN STD::PAIR{NULLPTR, FALSE};
        }
    } ELSE {
        // SUPPOSE THAT A TIME-SERIES BUCKET COLLECTION IS OBSERVED TO CONTAIN 200 BUCKETS, AND THE
        // 'GTIMESERIESBUCKETMAXCOUNT' PARAMETER IS SET TO 1000. IF ALL BUCKETS ARE FULL, THEN THE
        // MAXIMUM POSSIBLE MEASURMENT COUNT WOULD BE 200 * 1000 = 200,000. WHILE THE
        // 'SAMPLEFROMTIMESERIESBUCKET' PLAN IS MORE EFFICIENT WHEN THE SAMPLE SIZE IS SMALL
        // RELATIVE TO THE TOTAL NUMBER OF MEASUREMENTS IN THE TIME-SERIES COLLECTION, FOR LARGER
        // SAMPLE SIZES THE TOP-K SORT BASED SAMPLE IS FASTER. EXPERIMENTS HAVE APPROXIMATED THAT
        // THE TIPPING POINT IS ROUGHLY WHEN THE REQUESTED SAMPLE SIZE IS GREATER THAN 1% OF THE
        // MAXIMUM POSSIBLE NUMBER OF MEASUREMENTS IN THE COLLECTION (I.E. NUMBUCKETS *
        // MAXMEASUREMENTSPERBUCKET).
        STATIC CONST DOUBLE KCOEFFICIENT = 0.01;
        IF (SAMPLESIZE > KCOEFFICIENT * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT) {
            RETURN STD::PAIR{NULLPTR, FALSE};
        }
    }

    // ATTEMPT TO GET A RANDOM CURSOR FROM THE RECORDSTORE.
    AUTO RSRANDCURSOR = COLL->GETRECORDSTORE()->GETRANDOMCURSOR(OPCTX);
    IF (!RSRANDCURSOR) {
        // THE STORAGE ENGINE HAS NO RANDOM CURSOR SUPPORT.
        RETURN STD::PAIR{NULLPTR, FALSE};
    }

    // BUILD A MULTIITERATORSTAGE AND PASS IT THE RANDOM-SAMPLING RECORDCURSOR.
    AUTO WS = STD::MAKE_UNIQUE<WORKINGSET>();
    STD::UNIQUE_PTR<PLANSTAGE> ROOT =
        STD::MAKE_UNIQUE<MULTIITERATORSTAGE>(EXPCTX.GET(), WS.GET(), COLL);
    STATIC_CAST<MULTIITERATORSTAGE*>(ROOT.GET())->ADDITERATOR(STD::MOVE(RSRANDCURSOR));

    // IF THE INCOMING OPERATION IS SHARDED, USE THE CSS TO INFER THE FILTERING METADATA FOR THE
    // COLLECTION, OTHERWISE TREAT IT AS UNSHARDED
    AUTO COLLECTIONFILTER =
        COLLECTIONSHARDINGSTATE::GET(OPCTX, COLL->NS())
            ->GETOWNERSHIPFILTER(
                OPCTX, COLLECTIONSHARDINGSTATE::ORPHANCLEANUPPOLICY::KDISALLOWORPHANCLEANUP);

    TRIALSTAGE* TRIALSTAGE = NULLPTR;

    // BECAUSE 'NUMRECORDS' INCLUDES ORPHAN DOCUMENTS, OUR INITIAL DECISION TO OPTIMIZE THE $SAMPLE
    // CURSOR MAY HAVE BEEN MISTAKEN. FOR SHARDED COLLECTIONS, BUILD A TRIAL PLAN THAT WILL SWITCH
    // TO A COLLECTION SCAN IF THE RATIO OF ORPHANED TO OWNED DOCUMENTS ENCOUNTERED OVER THE FIRST
    // 100 WORKS() IS SUCH THAT WE WOULD HAVE CHOSEN NOT TO OPTIMIZE.
    STATIC CONST SIZE_T KMAXPRESAMPLESIZE = 100;
    IF (COLLECTIONFILTER.ISSHARDED() && !EXPCTX->NS.ISTIMESERIESBUCKETSCOLLECTION()) {
        // THE RATIO OF OWNED TO ORPHANED DOCUMENTS MUST BE AT LEAST EQUAL TO THE RATIO BETWEEN THE
        // REQUESTED SAMPLESIZE AND THE MAXIMUM PERMITTED SAMPLESIZE FOR THE ORIGINAL CONSTRAINTS TO
        // BE SATISFIED. FOR INSTANCE, IF THERE ARE 200 DOCUMENTS AND THE SAMPLESIZE IS 5, THEN AT
        // LEAST (5 / (200*0.05)) = (5/10) = 50% OF THOSE DOCUMENTS MUST BE OWNED. IF LESS THAN 5%
        // OF THE DOCUMENTS IN THE COLLECTION ARE OWNED, WE DEFAULT TO THE BACKUP PLAN.
        CONST AUTO MINADVANCEDTOWORKRATIO = STD::MAX(
            SAMPLESIZE / (NUMRECORDS * KMAXSAMPLERATIOFORRANDCURSOR), KMAXSAMPLERATIOFORRANDCURSOR);
        // THE TRIAL PLAN IS SHARDING_FILTER-MULTI_ITERATOR.
        AUTO RANDOMCURSORPLAN = STD::MAKE_UNIQUE<SHARDFILTERSTAGE>(
            EXPCTX.GET(), COLLECTIONFILTER, WS.GET(), STD::MOVE(ROOT));
        // THE BACKUP PLAN IS SHARDING_FILTER-COLLSCAN.
        STD::UNIQUE_PTR<PLANSTAGE> COLLSCANPLAN = STD::MAKE_UNIQUE<COLLECTIONSCAN>(
            EXPCTX.GET(), COLL, COLLECTIONSCANPARAMS{}, WS.GET(), NULLPTR);
        COLLSCANPLAN = STD::MAKE_UNIQUE<SHARDFILTERSTAGE>(
            EXPCTX.GET(), COLLECTIONFILTER, WS.GET(), STD::MOVE(COLLSCANPLAN));
        // PLACE A TRIAL STAGE AT THE ROOT OF THE PLAN TREE, AND PASS IT THE TRIAL AND BACKUP PLANS.
        ROOT = STD::MAKE_UNIQUE<TRIALSTAGE>(EXPCTX.GET(),
                                            WS.GET(),
                                            STD::MOVE(RANDOMCURSORPLAN),
                                            STD::MOVE(COLLSCANPLAN),
                                            KMAXPRESAMPLESIZE,
                                            MINADVANCEDTOWORKRATIO);
        TRIALSTAGE = STATIC_CAST<TRIALSTAGE*>(ROOT.GET());
    } ELSE IF (EXPCTX->NS.ISTIMESERIESBUCKETSCOLLECTION()) {
        // WE CAN'T TAKE ARHASH OPTIMIZATION PATH FOR A DIRECT $SAMPLE ON THE SYSTEM.BUCKETS
        // COLLECTION BECAUSE DATA IS IN COMPRESSED FORM. IF WE DID HAVE A DIRECT $SAMPLE ON THE
        // SYSTEM.BUCKETS COLLECTION, THEN THE 'BUCKETUNPACKER' WOULD NOT BE SET UP PROPERLY. WE
        // ALSO SHOULD BAIL OUT EARLY IF A $SAMPLE IS MADE AGAINST A TIME SERIES COLLECTION THAT IS
        // EMPTY. IF WE DON'T THE 'MINADVANCEDTOWORKRATIO' CAN BE NAN/-NAN DEPENDING ON THE
        // ARCHITECTURE.
        IF (!(BUCKETUNPACKER && NUMRECORDS)) {
            RETURN STD::PAIR{NULLPTR, FALSE};
        }

        // USE A 'TRIALSTAGE' TO RUN A TRIAL BETWEEN 'SAMPLEFROMTIMESERIESBUCKET' AND
        // 'UNPACKTIMESERIESBUCKET' WITH $SAMPLE LEFT IN THE PIPELINE IN-PLACE. IF THE BUCKETS ARE
        // NOT SUFFICIENTLY FULL, OR THE 'SAMPLEFROMTIMESERIESBUCKET' PLAN DRAWS TOO MANY
        // DUPLICATES, THEN WE WILL FALL BACK TO THE 'TRIALSTAGE' BACKUP PLAN. THIS BACKUP PLAN USES
        // THE TOP-K SORT SAMPLING APPROACH.
        //
        // SUPPOSE THE 'GTIMESERIESBUCKETMAXCOUNT' IS 1000, BUT EACH BUCKET ONLY CONTAINS 500
        // DOCUMENTS ON AVERAGE. THE OBSERVED TRIAL ADVANCED/WORK RATIO APPROXIMATES THE AVERAGE
        // BUCKET FULLNESS, NOTED HERE AS "ABF". IN THIS EXAMPLE, ABF = 500 / 1000 = 0.5.
        // EXPERIMENTS HAVE SHOWN THAT THE OPTIMIZED 'SAMPLEFROMTIMESERIESBUCKET' ALGORITHM PERFORMS
        // BETTER THAN BACKUP PLAN WHEN
        //
        //     SAMPLESIZE < 0.02 * ABF * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT
        //
        //  THIS INEQUALITY CAN BE REWRITTEN AS
        //
        //     ABF > SAMPLESIZE / (0.02 * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT)
        //
        // THEREFORE, IF THE ADVANCED/WORK RATIO EXCEEDS THIS THRESHOLD, WE WILL USE THE
        // 'SAMPLEFROMTIMESERIESBUCKET' PLAN. NOTE THAT AS THE SAMPLE SIZE REQUESTED BY THE USER
        // BECOMES LARGER WITH RESPECT TO THE NUMBER OF BUCKETS, WE REQUIRE A HIGHER ADVANCED/WORK
        // RATIO IN ORDER TO JUSTIFY USING 'SAMPLEFROMTIMESERIESBUCKET'.
        //
        // ADDITIONALLY, WE REQUIRE THE 'TRIALSTAGE' TO APPROXIMATE THE ABF AS AT LEAST 0.25. WHEN
        // BUCKETS ARE MOSTLY EMPTY, THE 'SAMPLEFROMTIMESERIESBUCKET' WILL BE INEFFICIENT DUE TO A
        // LOT OF SAMPLING "MISSES".
        STATIC CONST AUTO KCOEFFICIENT = 0.02;
        STATIC CONST AUTO KMINBUCKETFULLNESS = 0.25;
        CONST AUTO MINADVANCEDTOWORKRATIO = STD::MAX(
            STD::MIN(SAMPLESIZE / (KCOEFFICIENT * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT), 1.0),
            KMINBUCKETFULLNESS);

        AUTO ARHASHPLAN = STD::MAKE_UNIQUE<SAMPLEFROMTIMESERIESBUCKET>(
            EXPCTX.GET(),
            WS.GET(),
            STD::MOVE(ROOT),
            *BUCKETUNPACKER,
            // BY USING A QUANTITY SLIGHTLY HIGHER THAN 'KMAXPRESAMPLESIZE', WE ENSURE THAT THE
            // 'SAMPLEFROMTIMESERIESBUCKET' STAGE WON'T FAIL DUE TO TOO MANY CONSECUTIVE SAMPLING
            // ATTEMPTS DURING THE 'TRIALSTAGE'S TRIAL PERIOD.
            KMAXPRESAMPLESIZE + 5,
            SAMPLESIZE,
            GTIMESERIESBUCKETMAXCOUNT);

        STD::UNIQUE_PTR<PLANSTAGE> COLLSCANPLAN = STD::MAKE_UNIQUE<COLLECTIONSCAN>(
            EXPCTX.GET(), COLL, COLLECTIONSCANPARAMS{}, WS.GET(), NULLPTR);

        AUTO TOPKSORTPLAN = STD::MAKE_UNIQUE<UNPACKTIMESERIESBUCKET>(
            EXPCTX.GET(), WS.GET(), STD::MOVE(COLLSCANPLAN), *BUCKETUNPACKER);

        ROOT = STD::MAKE_UNIQUE<TRIALSTAGE>(EXPCTX.GET(),
                                            WS.GET(),
                                            STD::MOVE(ARHASHPLAN),
                                            STD::MOVE(TOPKSORTPLAN),
                                            KMAXPRESAMPLESIZE,
                                            MINADVANCEDTOWORKRATIO);
        TRIALSTAGE = STATIC_CAST<TRIALSTAGE*>(ROOT.GET());
    }

    AUTO EXECSTATUS = PLAN_EXECUTOR_FACTORY::MAKE(EXPCTX,
                                                  STD::MOVE(WS),
                                                  STD::MOVE(ROOT),
                                                  &COLL,
                                                  OPCTX->INMULTIDOCUMENTTRANSACTION()
                                                      ? PLANYIELDPOLICY::YIELDPOLICY::INTERRUPT_ONLY
                                                      : PLANYIELDPOLICY::YIELDPOLICY::YIELD_AUTO,
                                                  QUERYPLANNERPARAMS::RETURN_OWNED_DATA);
    IF (!EXECSTATUS.ISOK()) {
        RETURN EXECSTATUS.GETSTATUS();
    }

    // FOR SHARDED COLLECTIONS, THE ROOT OF THE PLAN TREE IS A TRIALSTAGE THAT MAY HAVE CHOSEN
    // EITHER A RANDOM-SAMPLING CURSOR TRIAL PLAN OR A COLLSCAN BACKUP PLAN. WE CAN ONLY OPTIMIZE
    // THE $SAMPLE AGGREGATION STAGE IF THE TRIAL PLAN WAS CHOSEN.
    RETURN STD::PAIR{STD::MOVE(EXECSTATUS.GETVALUE()),
                     !TRIALSTAGE || !TRIALSTAGE->PICKEDBACKUPPLAN()};
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215103_CWE-617.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CREATERANDOMCURSOREXECUTOR(CONST COLLECTIONPTR& COLL,
                           CONST BOOST::INTRUSIVE_PTR<EXPRESSIONCONTEXT>& EXPCTX,
                           LONG LONG SAMPLESIZE,
                           LONG LONG NUMRECORDS,
                           BOOST::OPTIONAL<BUCKETUNPACKER> BUCKETUNPACKER) {
    OPERATIONCONTEXT* OPCTX = EXPCTX->OPCTX;

    // VERIFY THAT WE ARE ALREADY UNDER A COLLECTION LOCK. WE AVOID TAKING LOCKS OURSELVES IN THIS
    // FUNCTION BECAUSE DOUBLE-LOCKING FORCES ANY PLANEXECUTOR WE CREATE TO ADOPT A NO_YIELD POLICY.
    INVARIANT(OPCTX->LOCKSTATE()->ISCOLLECTIONLOCKEDFORMODE(COLL->NS(), MODE_IS));

    STATIC CONST DOUBLE KMAXSAMPLERATIOFORRANDCURSOR = 0.05;
    IF (!EXPCTX->NS.ISTIMESERIESBUCKETSCOLLECTION()) {
        IF (SAMPLESIZE > NUMRECORDS * KMAXSAMPLERATIOFORRANDCURSOR || NUMRECORDS <= 100) {
            RETURN STD::PAIR{NULLPTR, FALSE};
        }
    } ELSE {
        // SUPPOSE THAT A TIME-SERIES BUCKET COLLECTION IS OBSERVED TO CONTAIN 200 BUCKETS, AND THE
        // 'GTIMESERIESBUCKETMAXCOUNT' PARAMETER IS SET TO 1000. IF ALL BUCKETS ARE FULL, THEN THE
        // MAXIMUM POSSIBLE MEASURMENT COUNT WOULD BE 200 * 1000 = 200,000. WHILE THE
        // 'SAMPLEFROMTIMESERIESBUCKET' PLAN IS MORE EFFICIENT WHEN THE SAMPLE SIZE IS SMALL
        // RELATIVE TO THE TOTAL NUMBER OF MEASUREMENTS IN THE TIME-SERIES COLLECTION, FOR LARGER
        // SAMPLE SIZES THE TOP-K SORT BASED SAMPLE IS FASTER. EXPERIMENTS HAVE APPROXIMATED THAT
        // THE TIPPING POINT IS ROUGHLY WHEN THE REQUESTED SAMPLE SIZE IS GREATER THAN 1% OF THE
        // MAXIMUM POSSIBLE NUMBER OF MEASUREMENTS IN THE COLLECTION (I.E. NUMBUCKETS *
        // MAXMEASUREMENTSPERBUCKET).
        STATIC CONST DOUBLE KCOEFFICIENT = 0.01;
        IF (SAMPLESIZE > KCOEFFICIENT * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT) {
            RETURN STD::PAIR{NULLPTR, FALSE};
        }
    }

    // ATTEMPT TO GET A RANDOM CURSOR FROM THE RECORDSTORE.
    AUTO RSRANDCURSOR = COLL->GETRECORDSTORE()->GETRANDOMCURSOR(OPCTX);
    IF (!RSRANDCURSOR) {
        // THE STORAGE ENGINE HAS NO RANDOM CURSOR SUPPORT.
        RETURN STD::PAIR{NULLPTR, FALSE};
    }

    // BUILD A MULTIITERATORSTAGE AND PASS IT THE RANDOM-SAMPLING RECORDCURSOR.
    AUTO WS = STD::MAKE_UNIQUE<WORKINGSET>();
    STD::UNIQUE_PTR<PLANSTAGE> ROOT =
        STD::MAKE_UNIQUE<MULTIITERATORSTAGE>(EXPCTX.GET(), WS.GET(), COLL);
    STATIC_CAST<MULTIITERATORSTAGE*>(ROOT.GET())->ADDITERATOR(STD::MOVE(RSRANDCURSOR));

    // IF THE INCOMING OPERATION IS SHARDED, USE THE CSS TO INFER THE FILTERING METADATA FOR THE
    // COLLECTION, OTHERWISE TREAT IT AS UNSHARDED
    AUTO COLLECTIONFILTER =
        COLLECTIONSHARDINGSTATE::GET(OPCTX, COLL->NS())
            ->GETOWNERSHIPFILTER(
                OPCTX, COLLECTIONSHARDINGSTATE::ORPHANCLEANUPPOLICY::KDISALLOWORPHANCLEANUP);

    TRIALSTAGE* TRIALSTAGE = NULLPTR;

    // BECAUSE 'NUMRECORDS' INCLUDES ORPHAN DOCUMENTS, OUR INITIAL DECISION TO OPTIMIZE THE $SAMPLE
    // CURSOR MAY HAVE BEEN MISTAKEN. FOR SHARDED COLLECTIONS, BUILD A TRIAL PLAN THAT WILL SWITCH
    // TO A COLLECTION SCAN IF THE RATIO OF ORPHANED TO OWNED DOCUMENTS ENCOUNTERED OVER THE FIRST
    // 100 WORKS() IS SUCH THAT WE WOULD HAVE CHOSEN NOT TO OPTIMIZE.
    STATIC CONST SIZE_T KMAXPRESAMPLESIZE = 100;
    IF (COLLECTIONFILTER.ISSHARDED() && !EXPCTX->NS.ISTIMESERIESBUCKETSCOLLECTION()) {
        // THE RATIO OF OWNED TO ORPHANED DOCUMENTS MUST BE AT LEAST EQUAL TO THE RATIO BETWEEN THE
        // REQUESTED SAMPLESIZE AND THE MAXIMUM PERMITTED SAMPLESIZE FOR THE ORIGINAL CONSTRAINTS TO
        // BE SATISFIED. FOR INSTANCE, IF THERE ARE 200 DOCUMENTS AND THE SAMPLESIZE IS 5, THEN AT
        // LEAST (5 / (200*0.05)) = (5/10) = 50% OF THOSE DOCUMENTS MUST BE OWNED. IF LESS THAN 5%
        // OF THE DOCUMENTS IN THE COLLECTION ARE OWNED, WE DEFAULT TO THE BACKUP PLAN.
        CONST AUTO MINADVANCEDTOWORKRATIO = STD::MAX(
            SAMPLESIZE / (NUMRECORDS * KMAXSAMPLERATIOFORRANDCURSOR), KMAXSAMPLERATIOFORRANDCURSOR);
        // THE TRIAL PLAN IS SHARDING_FILTER-MULTI_ITERATOR.
        AUTO RANDOMCURSORPLAN = STD::MAKE_UNIQUE<SHARDFILTERSTAGE>(
            EXPCTX.GET(), COLLECTIONFILTER, WS.GET(), STD::MOVE(ROOT));
        // THE BACKUP PLAN IS SHARDING_FILTER-COLLSCAN.
        STD::UNIQUE_PTR<PLANSTAGE> COLLSCANPLAN = STD::MAKE_UNIQUE<COLLECTIONSCAN>(
            EXPCTX.GET(), COLL, COLLECTIONSCANPARAMS{}, WS.GET(), NULLPTR);
        COLLSCANPLAN = STD::MAKE_UNIQUE<SHARDFILTERSTAGE>(
            EXPCTX.GET(), COLLECTIONFILTER, WS.GET(), STD::MOVE(COLLSCANPLAN));
        // PLACE A TRIAL STAGE AT THE ROOT OF THE PLAN TREE, AND PASS IT THE TRIAL AND BACKUP PLANS.
        ROOT = STD::MAKE_UNIQUE<TRIALSTAGE>(EXPCTX.GET(),
                                            WS.GET(),
                                            STD::MOVE(RANDOMCURSORPLAN),
                                            STD::MOVE(COLLSCANPLAN),
                                            KMAXPRESAMPLESIZE,
                                            MINADVANCEDTOWORKRATIO);
        TRIALSTAGE = STATIC_CAST<TRIALSTAGE*>(ROOT.GET());
    } ELSE IF (EXPCTX->NS.ISTIMESERIESBUCKETSCOLLECTION()) {
        // USE A 'TRIALSTAGE' TO RUN A TRIAL BETWEEN 'SAMPLEFROMTIMESERIESBUCKET' AND
        // 'UNPACKTIMESERIESBUCKET' WITH $SAMPLE LEFT IN THE PIPELINE IN-PLACE. IF THE BUCKETS ARE
        // NOT SUFFICIENTLY FULL, OR THE 'SAMPLEFROMTIMESERIESBUCKET' PLAN DRAWS TOO MANY
        // DUPLICATES, THEN WE WILL FALL BACK TO THE 'TRIALSTAGE' BACKUP PLAN. THIS BACKUP PLAN USES
        // THE TOP-K SORT SAMPLING APPROACH.
        //
        // SUPPOSE THE 'GTIMESERIESBUCKETMAXCOUNT' IS 1000, BUT EACH BUCKET ONLY CONTAINS 500
        // DOCUMENTS ON AVERAGE. THE OBSERVED TRIAL ADVANCED/WORK RATIO APPROXIMATES THE AVERAGE
        // BUCKET FULLNESS, NOTED HERE AS "ABF". IN THIS EXAMPLE, ABF = 500 / 1000 = 0.5.
        // EXPERIMENTS HAVE SHOWN THAT THE OPTIMIZED 'SAMPLEFROMTIMESERIESBUCKET' ALGORITHM PERFORMS
        // BETTER THAN BACKUP PLAN WHEN
        //
        //     SAMPLESIZE < 0.02 * ABF * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT
        //
        //  THIS INEQUALITY CAN BE REWRITTEN AS
        //
        //     ABF > SAMPLESIZE / (0.02 * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT)
        //
        // THEREFORE, IF THE ADVANCED/WORK RATIO EXCEEDS THIS THRESHOLD, WE WILL USE THE
        // 'SAMPLEFROMTIMESERIESBUCKET' PLAN. NOTE THAT AS THE SAMPLE SIZE REQUESTED BY THE USER
        // BECOMES LARGER WITH RESPECT TO THE NUMBER OF BUCKETS, WE REQUIRE A HIGHER ADVANCED/WORK
        // RATIO IN ORDER TO JUSTIFY USING 'SAMPLEFROMTIMESERIESBUCKET'.
        //
        // ADDITIONALLY, WE REQUIRE THE 'TRIALSTAGE' TO APPROXIMATE THE ABF AS AT LEAST 0.25. WHEN
        // BUCKETS ARE MOSTLY EMPTY, THE 'SAMPLEFROMTIMESERIESBUCKET' WILL BE INEFFICIENT DUE TO A
        // LOT OF SAMPLING "MISSES".
        STATIC CONST AUTO KCOEFFICIENT = 0.02;
        STATIC CONST AUTO KMINBUCKETFULLNESS = 0.25;
        CONST AUTO MINADVANCEDTOWORKRATIO = STD::MAX(
            STD::MIN(SAMPLESIZE / (KCOEFFICIENT * NUMRECORDS * GTIMESERIESBUCKETMAXCOUNT), 1.0),
            KMINBUCKETFULLNESS);

        AUTO ARHASHPLAN = STD::MAKE_UNIQUE<SAMPLEFROMTIMESERIESBUCKET>(
            EXPCTX.GET(),
            WS.GET(),
            STD::MOVE(ROOT),
            *BUCKETUNPACKER,
            // BY USING A QUANTITY SLIGHTLY HIGHER THAN 'KMAXPRESAMPLESIZE', WE ENSURE THAT THE
            // 'SAMPLEFROMTIMESERIESBUCKET' STAGE WON'T FAIL DUE TO TOO MANY CONSECUTIVE SAMPLING
            // ATTEMPTS DURING THE 'TRIALSTAGE'S TRIAL PERIOD.
            KMAXPRESAMPLESIZE + 5,
            SAMPLESIZE,
            GTIMESERIESBUCKETMAXCOUNT);

        STD::UNIQUE_PTR<PLANSTAGE> COLLSCANPLAN = STD::MAKE_UNIQUE<COLLECTIONSCAN>(
            EXPCTX.GET(), COLL, COLLECTIONSCANPARAMS{}, WS.GET(), NULLPTR);

        AUTO TOPKSORTPLAN = STD::MAKE_UNIQUE<UNPACKTIMESERIESBUCKET>(
            EXPCTX.GET(), WS.GET(), STD::MOVE(COLLSCANPLAN), *BUCKETUNPACKER);

        ROOT = STD::MAKE_UNIQUE<TRIALSTAGE>(EXPCTX.GET(),
                                            WS.GET(),
                                            STD::MOVE(ARHASHPLAN),
                                            STD::MOVE(TOPKSORTPLAN),
                                            KMAXPRESAMPLESIZE,
                                            MINADVANCEDTOWORKRATIO);
        TRIALSTAGE = STATIC_CAST<TRIALSTAGE*>(ROOT.GET());
    }

    AUTO EXECSTATUS = PLAN_EXECUTOR_FACTORY::MAKE(EXPCTX,
                                                  STD::MOVE(WS),
                                                  STD::MOVE(ROOT),
                                                  &COLL,
                                                  OPCTX->INMULTIDOCUMENTTRANSACTION()
                                                      ? PLANYIELDPOLICY::YIELDPOLICY::INTERRUPT_ONLY
                                                      : PLANYIELDPOLICY::YIELDPOLICY::YIELD_AUTO,
                                                  QUERYPLANNERPARAMS::RETURN_OWNED_DATA);
    IF (!EXECSTATUS.ISOK()) {
        RETURN EXECSTATUS.GETSTATUS();
    }

    // FOR SHARDED COLLECTIONS, THE ROOT OF THE PLAN TREE IS A TRIALSTAGE THAT MAY HAVE CHOSEN
    // EITHER A RANDOM-SAMPLING CURSOR TRIAL PLAN OR A COLLSCAN BACKUP PLAN. WE CAN ONLY OPTIMIZE
    // THE $SAMPLE AGGREGATION STAGE IF THE TRIAL PLAN WAS CHOSEN.
    RETURN STD::PAIR{STD::MOVE(EXECSTATUS.GETVALUE()),
                     !TRIALSTAGE || !TRIALSTAGE->PICKEDBACKUPPLAN()};
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 221671_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SOCKET::BIND(INT PORT) {
    INT LEN = SIZEOF MY_ADR;
    INT I = 1;

    SETSOCKOPT(SCK, SOL_SOCKET, SO_REUSEADDR, &I, SIZEOF(I));

    MY_ADR.SIN_PORT = HTONS(PORT);
    MY_PORT = PORT;

    RETURN ::BIND(SCK, (STRUCT SOCKADDR *) &MY_ADR, LEN);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336595_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID REDS_REGISTER_CHANNEL(REDSSTATE *REDS, REDCHANNEL *CHANNEL)
{
    SPICE_ASSERT(REDS);

    UINT32_T THIS_TYPE = CHANNEL->TYPE();
    UINT32_T THIS_ID = CHANNEL->ID();
    IF (SPICE_EXTRA_CHECKS) {
        G_ASSERT(REDS_FIND_CHANNEL(REDS, THIS_TYPE, THIS_ID) == NULL);
    } ELSE {
        G_WARN_IF_FAIL(REDS_FIND_CHANNEL(REDS, THIS_TYPE, THIS_ID) == NULL);
    }
    REDS->CHANNELS.PUSH_FRONT(RED::SHARED_PTR<REDCHANNEL>(CHANNEL));
    // CREATE NEW CHANNEL IN THE CLIENT IF POSSIBLE
    REDS->MAIN_CHANNEL->REGISTERED_NEW_CHANNEL(CHANNEL);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198695_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MP_SINT32 LOADERS3M::LOAD(XMFILEBASE& F, XMODULE* MODULE)
{	
	MODULE->CLEANUP();

	// THIS WILL MAKE CODE MUCH EASIER TO READ
	TXMHEADER*		HEADER = &MODULE->HEADER;
	TXMINSTRUMENT*	INSTR  = MODULE->INSTR;
	TXMSAMPLE*		SMP	   = MODULE->SMP;
	TXMPATTERN*		PHEAD  = MODULE->PHEAD;	

	// WE'RE ALREADY OUT OF MEMORY HERE
	IF (!PHEAD || !INSTR || !SMP)
		RETURN MP_OUT_OF_MEMORY;
	
	F.READ(&HEADER->NAME,1,28);
	HEADER->WHYTHIS1A = F.READBYTE();
	
	IF (F.READBYTE() != 16) 
		RETURN MP_LOADER_FAILED;	// NO ST3 MODULE
	
	F.READBYTE(); // SKIP SOMETHING
	F.READBYTE(); // SKIP SOMETHING
	
	HEADER->ORDNUM = F.READWORD(); // NUMBER OF POSITIONS IN ORDER LIST (SONGLENGTH)
	
	MP_UBYTE* ORDERS = NEW MP_UBYTE[HEADER->ORDNUM];
	IF (ORDERS == NULL) 
		RETURN MP_OUT_OF_MEMORY;
	
	HEADER->INSNUM = F.READWORD(); // NUMBER OF INSTRUMENTS
	HEADER->PATNUM = F.READWORD(); // NUMBER OF PATTERNS	
	
	MP_SINT32 FLAGS = F.READWORD(); // ST3 FLAGS	

	MP_SINT32 CVT = F.READWORD();

	HEADER->FLAGS = XMODULE::MODULE_ST3NEWINSTRUMENT | XMODULE::MODULE_ST3DUALCOMMANDS;

	IF (CVT == 0X1300 || (FLAGS & 64))
		HEADER->FLAGS |= MODULE->MODULE_OLDS3MVOLSLIDES;
		
	HEADER->FLAGS |= MODULE->MODULE_ST3NOTECUT;
	
	/*MP_UWORD FFI = */F.READWORD();
	
	F.READ(HEADER->SIG,1,4);
	
	HEADER->MAINVOL = MODULE->VOL64TO255(F.READBYTE()); // INITIAL MAIN VOLUME
	
	HEADER->TEMPO = F.READBYTE(); // TEMPO
	
	HEADER->SPEED = F.READBYTE(); // SPEED
	
	F.READBYTE(); // GLOBAL VOLUME? SKIPPED...
	
	F.READBYTE(); // IGNORE GUS CLICK REMOVAL
	
	/*MP_UBYTE DP = */F.READBYTE();
	
	F.READDWORD();	// SKIP SOMETHING
	F.READDWORD();	// SKIP SOMETHING
	F.READWORD();	// SKIP SOME MORE...
	
	MP_UBYTE CHANNELSETTINGS[32];
	F.READ(CHANNELSETTINGS,1,32);
	
	MP_SINT32 NUMCHANNELS = 0;
	
	FOR (NUMCHANNELS = 0; NUMCHANNELS < 32; NUMCHANNELS++)
		IF (CHANNELSETTINGS[NUMCHANNELS] == 255)
			BREAK;
	
	HEADER->CHANNUM = NUMCHANNELS; // NUMBER OF CHANNELS
	
	F.READ(ORDERS,1,HEADER->ORDNUM);
	
	MP_SINT32 J = 0, I = 0;
	FOR (I = 0; I < HEADER->ORDNUM; I++)
	{
		IF (ORDERS[I] == 255) 
			BREAK;
		
		HEADER->ORD[J++] = ORDERS[I];		
	}
	
	HEADER->ORDNUM = J; // FINAL SONGLENGTH
	
	DELETE[] ORDERS;
	
	MP_UWORD* INSPARAPTRS = NEW MP_UWORD[HEADER->INSNUM];
	
	IF (INSPARAPTRS == NULL)
		RETURN MP_OUT_OF_MEMORY;
	
	F.READWORDS(INSPARAPTRS,HEADER->INSNUM);
	
	MP_UWORD* PATPARAPTRS = NEW MP_UWORD[HEADER->PATNUM];
	
	IF (PATPARAPTRS == NULL)
	{
		DELETE[] INSPARAPTRS;
		RETURN MP_OUT_OF_MEMORY;
	}
	
	F.READWORDS(PATPARAPTRS,HEADER->PATNUM);
	
	//FOR (I = 0; I < HEADER->INSNUM; I++)
	//{
	//	PRINTF("%X\N",INSPARAPTRS[I]*16);
	//}
		
	//////////////////////
	// READ INSTRUMENTS //
	//////////////////////
	MP_UINT32* SAMPLEPTRS = NEW MP_UINT32[HEADER->INSNUM];
	IF (SAMPLEPTRS == NULL)
	{
		DELETE[] INSPARAPTRS;
		DELETE[] PATPARAPTRS;
		RETURN MP_OUT_OF_MEMORY;
	}
	
	MEMSET(SAMPLEPTRS,0,SIZEOF(MP_UINT32)*HEADER->INSNUM);
	
	MP_SINT32 S = 0;
	FOR (I = 0; I < HEADER->INSNUM; I++)
	{
		MP_UINT32 INSOFFS = INSPARAPTRS[I]*16;

		IF (INSOFFS)
		{
			F.SEEKWITHBASEOFFSET(INSOFFS);
		
			// WE CAN ONLY READ THAT IF IT'S A SAMPLE
			MP_UBYTE TYPE = F.READBYTE();
			
			IF (TYPE == 1)
			{
				F.READ(SMP[S].NAME,1,12);	// READ DOS FILENAME
		
				MP_UBYTE BOFFS = F.READBYTE();
				MP_UWORD WOFFS = F.READWORD();
				
				// STUPID FILEOFFSETS
				SAMPLEPTRS[I] = (((MP_UINT32)BOFFS<<16)+(MP_UINT32)WOFFS)*16;
				
				SMP[S].FLAGS = 1;
				SMP[S].PAN = 0X80;
				
				SMP[S].SAMPLEN = F.READDWORD();
				SMP[S].LOOPSTART = F.READDWORD();
				MP_SINT32 LOOPLEN = ((MP_SINT32)F.READDWORD() - (MP_SINT32)SMP[S].LOOPSTART);
				IF (LOOPLEN < 0) 
					LOOPLEN = 0;
				SMP[S].LOOPLEN = LOOPLEN;
				
				SMP[S].VOL = MODULE->VOL64TO255(F.READBYTE());
				
				F.READBYTE(); // SKIP SOMETHING
				
				SMP[S].RES = F.READBYTE() == 0X04 ? 0XAD : 0; // PACKING
				
				MP_UBYTE FLAGS = F.READBYTE();
				
				// LOOPING
				IF (FLAGS & 1)
				{
					SMP[S].TYPE = 1;	
				}
				
				// 16 BIT SAMPLE
				IF (FLAGS & 4)
				{
					SMP[S].TYPE |= 16;
					SMP[S].SAMPLEN >>= 1;
					SMP[S].LOOPSTART >>= 1;
					SMP[S].LOOPLEN >>= 1;
				}
				
				MP_UINT32 C4SPD = F.READDWORD();
				
				XMODULE::CONVERTC4SPD(C4SPD,&SMP[S].FINETUNE,&SMP[S].RELNOTE);

#IFDEF VERBOSE
				PRINTF("%I, %I\N",C4SPD,MODULE->GETC4SPD(SMP[S].RELNOTE,SMP[S].FINETUNE));				
#ENDIF

				F.READDWORD(); // SKIP SOMETHING
				
				F.READDWORD(); // SKIP TWO INTERNAL WORDS
				
				F.READDWORD(); // SKIP INTERNAL DWORD

				F.READ(INSTR[I].NAME,1,28); // INSTRUMENT NAME
				
				F.READDWORD(); // SKIP SIGNATURE
				
				IF (SAMPLEPTRS[I] && SMP[S].SAMPLEN)
				{
					INSTR[I].SAMP=1;
					FOR (J=0;J<120;J++) 
						INSTR[I].SNUM[J] = S;
					S++;
				}
			}
			ELSE IF (TYPE == 0)
			{
				SAMPLEPTRS[I] = 0;
			
				MP_UBYTE BUFFER[12];
				F.READ(BUFFER,1,12);	// READ DOS FILENAME
		
				F.READBYTE();
				F.READWORD();
				
				F.READDWORD();
				F.READDWORD();
				F.READDWORD();
				F.READBYTE();
				F.READBYTE(); // SKIP SOMETHING
				F.READBYTE(); // SKIP PACKING
				
				F.READBYTE();
				
				F.READDWORD();
				
				F.READDWORD(); // SKIP SOMETHING
				
				F.READDWORD(); // SKIP TWO INTERNAL WORDS
				
				F.READDWORD(); // SKIP INTERNAL DWORD

				F.READ(INSTR[I].NAME,1,28); // INSTRUMENT NAME
				
				F.READDWORD(); // SKIP SIGNATURE				
			}
			ELSE 
			{
				SAMPLEPTRS[I] = 0;
			}
			
		}

	}
	
	//////////////////////
	// READ PATTERNS	//
	//////////////////////
	MP_UBYTE* PATTERN = NEW MP_UBYTE[64*32*5];
	IF (PATTERN == NULL)
	{
		DELETE[] INSPARAPTRS;
		DELETE[] PATPARAPTRS;
		DELETE[] SAMPLEPTRS;
		RETURN MP_OUT_OF_MEMORY;
	}
	
	MP_UINT32 SONGMAXCHANNELS = 1;
	
	FOR (I = 0; I < HEADER->PATNUM; I++)
	{
		FOR (J = 0; J < 32*64; J++)
		{
			PATTERN[J*5] = 0XFF;
			PATTERN[J*5+1] = 0;
			PATTERN[J*5+2] = 0XFF;
			PATTERN[J*5+3] = 0XFF;
			PATTERN[J*5+4] = 0;
		}
		
		MP_UINT32 PATOFFS = PATPARAPTRS[I]*16;
		
		MP_UINT32 MAXCHANNELS = 1;			
		
		IF (PATOFFS)
		{
			F.SEEKWITHBASEOFFSET(PATOFFS);
			
			MP_UINT32 SIZE = F.READWORD();
			
			IF (SIZE > 2)
			{
				SIZE-=2;
				
				MP_UBYTE* PACKED = NEW MP_UBYTE[SIZE+5];
				IF (PACKED == NULL)
				{
					DELETE[] INSPARAPTRS;
					DELETE[] PATPARAPTRS;
					DELETE[] SAMPLEPTRS;
					DELETE[] PATTERN;
					RETURN MP_OUT_OF_MEMORY;				
				}
				
				MEMSET(PACKED, 0, SIZE);
				F.READ(PACKED, 1, SIZE);
				
				MP_UINT32 INDEX = 0;
				MP_UINT32 ROW = 0;
				
				WHILE (INDEX<SIZE)
				{
					
					MP_UBYTE PI = SAFEREAD(PACKED, INDEX, SIZE);
					
					IF (PI == 0) 
					{
						ROW++;
						// ONE MORE SAFETY NET FOR INCORRECTLY SAVED PATTERN SIZES
						IF (ROW >= 64)
						{
							INT I = 0;
							I++;
							I--;
							BREAK;
						}
						CONTINUE;
					}
					
					MP_UINT32 CHN = PI&31;
					
					IF (CHN>MAXCHANNELS && (PI & (32+64+128)))
					{
						MAXCHANNELS = CHN;
					}
					
					MP_UBYTE* SLOT = PATTERN+(ROW*32*5)+CHN*5;
					
					IF (PI & 32)
					{
						SLOT[0] = SAFEREAD(PACKED, INDEX, SIZE, 0XFF);
						SLOT[1] = SAFEREAD(PACKED, INDEX, SIZE);
					}
					IF (PI & 64)
					{
						SLOT[2] = SAFEREAD(PACKED, INDEX, SIZE, 0XFF);
					}
					IF (PI & 128)
					{
						SLOT[3] = SAFEREAD(PACKED, INDEX, SIZE, 0XFF);
						SLOT[4] = SAFEREAD(PACKED, INDEX, SIZE);
					}
					
				}
				
				MAXCHANNELS++;
				
				IF (MAXCHANNELS > HEADER->CHANNUM)
					MAXCHANNELS = HEADER->CHANNUM;
				
				DELETE[] PACKED;
			}
			
			IF (MAXCHANNELS > SONGMAXCHANNELS)
				SONGMAXCHANNELS = MAXCHANNELS;
			
		}
		
		CONVERTS3MPATTERN(&PHEAD[I], PATTERN, MAXCHANNELS, I);
		
		
	}
	
	IF (HEADER->CHANNUM > SONGMAXCHANNELS)
		HEADER->CHANNUM = SONGMAXCHANNELS;
	
	DELETE[] PATTERN;
	DELETE[] INSPARAPTRS;
	DELETE[] PATPARAPTRS;
	
	S = 0;
	FOR (I = 0; I < HEADER->INSNUM; I++)
	{
		MP_UINT32 SMPOFFS = SAMPLEPTRS[I];

		IF (SMPOFFS)
		{
			F.SEEKWITHBASEOFFSET(SMPOFFS);
			
			IF (!SMP[S].SAMPLEN)
				CONTINUE;

			BOOL ADPCM = (SMP[S].RES == 0XAD);

			MP_SINT32 RESULT = MODULE->LOADMODULESAMPLE(F, S, 
										  ADPCM ? XMODULE::ST_PACKING_ADPCM : XMODULE::ST_UNSIGNED, 
										  ADPCM ? (XMODULE::ST_16BIT | XMODULE::ST_PACKING_ADPCM) : (XMODULE::ST_16BIT | XMODULE::ST_UNSIGNED));
			IF (RESULT != MP_OK)
			{
				DELETE[] SAMPLEPTRS;
				RETURN RESULT;
			}
			
			IF (ADPCM)
				// NO LONGER NEEDED
				SMP[S].RES = 0;			
							
			S++;
			
		}

	}
	
	DELETE[] SAMPLEPTRS;
	
	HEADER->SMPNUM = S;
	
	STRCPY(HEADER->TRACKER,"SCREAMTRACKER 3");
	
	MODULE->SETDEFAULTPANNING();
	
	MODULE->POSTPROCESSSAMPLES();
	
	RETURN MP_OK;	
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 231632_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CONGESTIONANDRTTSTATE MOVECURRENTCONGESTIONANDRTTSTATE(
    QUICSERVERCONNECTIONSTATE& CONN) {
  CONGESTIONANDRTTSTATE STATE;
  STATE.PEERADDRESS = CONN.PEERADDRESS;
  STATE.RECORDTIME = CLOCK::NOW();
  STATE.CONGESTIONCONTROLLER = STD::MOVE(CONN.CONGESTIONCONTROLLER);
  STATE.SRTT = CONN.LOSSSTATE.SRTT;
  STATE.LRTT = CONN.LOSSSTATE.LRTT;
  STATE.RTTVAR = CONN.LOSSSTATE.RTTVAR;
  STATE.MRTT = CONN.LOSSSTATE.MRTT;
  RETURN STATE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214282_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
R_API RBINJAVAATTRINFO *R_BIN_JAVA_INNER_CLASSES_ATTR_NEW(RBINJAVAOBJ *BIN, UT8 *BUFFER, UT64 SZ, UT64 BUF_OFFSET) {
	RBINJAVACLASSESATTRIBUTE *ICATTR;
	RBINJAVAATTRINFO *ATTR = NULL;
	RBINJAVACPTYPEOBJ *OBJ;
	UT32 I = 0;
	UT64 OFFSET = 0, CURPOS;
	ATTR = R_BIN_JAVA_DEFAULT_ATTR_NEW (BIN, BUFFER, SZ, BUF_OFFSET);
	OFFSET += 6;
	IF (ATTR == NULL) {
		// TODO EPRINTF
		RETURN ATTR;
	}
	ATTR->TYPE = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;
	ATTR->INFO.INNER_CLASSES_ATTR.NUMBER_OF_CLASSES = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
	OFFSET += 2;
	ATTR->INFO.INNER_CLASSES_ATTR.CLASSES = R_LIST_NEWF (R_BIN_JAVA_INNER_CLASSES_ATTR_ENTRY_FREE);
	FOR (I = 0; I < ATTR->INFO.INNER_CLASSES_ATTR.NUMBER_OF_CLASSES; I++) {
		CURPOS = BUF_OFFSET + OFFSET;
		IF (OFFSET + 8 > SZ) {
			EPRINTF ("INVALID AMOUNT OF INNER CLASSES\N");
			BREAK;
		}
		ICATTR = R_NEW0 (RBINJAVACLASSESATTRIBUTE);
		IF (!ICATTR) {
			BREAK;
		}
		ICATTR->INNER_CLASS_INFO_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		OFFSET += 2;
		ICATTR->OUTER_CLASS_INFO_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		OFFSET += 2;
		ICATTR->INNER_NAME_IDX = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		OFFSET += 2;
		ICATTR->INNER_CLASS_ACCESS_FLAGS = R_BIN_JAVA_USHORT (BUFFER, OFFSET);
		OFFSET += 2;
		ICATTR->FLAGS_STR = RETRIEVE_CLASS_METHOD_ACCESS_STRING (ICATTR->INNER_CLASS_ACCESS_FLAGS);
		ICATTR->FILE_OFFSET = CURPOS;
		ICATTR->SIZE = 8;

		OBJ = R_BIN_JAVA_GET_ITEM_FROM_BIN_CP_LIST (R_BIN_JAVA_GLOBAL_BIN, ICATTR->INNER_NAME_IDX);
		IF (OBJ == NULL) {
			EPRINTF ("BINCPLIS IS HULL %D\N", ICATTR->INNER_NAME_IDX);
		}
		ICATTR->NAME = R_BIN_JAVA_GET_ITEM_NAME_FROM_BIN_CP_LIST (R_BIN_JAVA_GLOBAL_BIN, OBJ);
		IF (!ICATTR->NAME) {
			OBJ = R_BIN_JAVA_GET_ITEM_FROM_BIN_CP_LIST (R_BIN_JAVA_GLOBAL_BIN, ICATTR->INNER_CLASS_INFO_IDX);
			IF (!OBJ) {
				EPRINTF ("BINCPLIST IS NULL %D\N", ICATTR->INNER_CLASS_INFO_IDX);
			}
			ICATTR->NAME = R_BIN_JAVA_GET_ITEM_NAME_FROM_BIN_CP_LIST (R_BIN_JAVA_GLOBAL_BIN, OBJ);
			IF (!ICATTR->NAME) {
				ICATTR->NAME = R_STR_DUP (NULL, "NULL");
				EPRINTF ("R_BIN_JAVA_INNER_CLASSES_ATTR: UNABLE TO FIND THE NAME FOR %D INDEX.\N", ICATTR->INNER_NAME_IDX);
				FREE (ICATTR);
				BREAK;
			}
		}

		IFDBG EPRINTF("R_BIN_JAVA_INNER_CLASSES_ATTR: INNER CLASS NAME %D IS %S.\N", ICATTR->INNER_NAME_IDX, ICATTR->NAME);
		R_LIST_APPEND (ATTR->INFO.INNER_CLASSES_ATTR.CLASSES, (VOID *) ICATTR);
	}
	ATTR->SIZE = OFFSET;
	// IFDBG R_BIN_JAVA_PRINT_INNER_CLASSES_ATTR_SUMMARY(ATTR);
	RETURN ATTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512323_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL CONST MYSQL_TIME *CONST_PTR_MYSQL_TIME() CONST { RETURN NULL; }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512656_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ITEM_FUNC_IN::PRINT(STRING *STR, ENUM_QUERY_TYPE QUERY_TYPE)
{
  ARGS[0]->PRINT_PARENTHESISED(STR, QUERY_TYPE, PRECEDENCE());
  IF (NEGATED)
    STR->APPEND(STRING_WITH_LEN(" NOT"));
  STR->APPEND(STRING_WITH_LEN(" IN ("));
  PRINT_ARGS(STR, 1, QUERY_TYPE);
  STR->APPEND(STRING_WITH_LEN(")"));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 292152_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LINKINFO::LINKINFO(CONST CONSTANTPOOLHANDLE& POOL, INT INDEX, CONST METHODHANDLE& CURRENT_METHOD, TRAPS) {
   // RESOLVE KLASS
  _RESOLVED_KLASS = POOL->KLASS_REF_AT(INDEX, CHECK);

  // GET NAME, SIGNATURE, AND STATIC KLASS
  _NAME          = POOL->NAME_REF_AT(INDEX);
  _SIGNATURE     = POOL->SIGNATURE_REF_AT(INDEX);
  _TAG           = POOL->TAG_REF_AT(INDEX);
  _CURRENT_KLASS = POOL->POOL_HOLDER();
  _CURRENT_METHOD = CURRENT_METHOD;

  // COMING FROM THE CONSTANT POOL ALWAYS CHECKS ACCESS
  _CHECK_ACCESS  = TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336628_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SPICE_GNUC_VISIBLE INT SPICE_SERVER_SET_AGENT_FILE_XFER(SPICESERVER *REDS, INT ENABLE)
{
    REDS->CONFIG->AGENT_FILE_XFER = ENABLE;
    REDS_UPDATE_AGENT_PROPERTIES(REDS);
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 95900_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ADDINSTALLWORKITEMS(CONST INSTALLATIONSTATE& ORIGINAL_STATE,
                         CONST INSTALLERSTATE& INSTALLER_STATE,
                         CONST FILEPATH& SETUP_PATH,
                         CONST FILEPATH& ARCHIVE_PATH,
                         CONST FILEPATH& SRC_PATH,
                         CONST FILEPATH& TEMP_PATH,
                         CONST VERSION& NEW_VERSION,
                         SCOPED_PTR<VERSION>* CURRENT_VERSION,
                         WORKITEMLIST* INSTALL_LIST) {
  DCHECK(INSTALL_LIST);

  CONST FILEPATH& TARGET_PATH = INSTALLER_STATE.TARGET_PATH();

  INSTALL_LIST->ADDCREATEDIRWORKITEM(TEMP_PATH);
  INSTALL_LIST->ADDCREATEDIRWORKITEM(TARGET_PATH);

  IF (CURRENT_VERSION != NULL && CURRENT_VERSION->GET() != NULL) {
    FILEPATH OLD_INSTALLER_DIR(
        INSTALLER_STATE.GETINSTALLERDIRECTORY(**CURRENT_VERSION));
    FILEPATH OLD_ARCHIVE(OLD_INSTALLER_DIR.APPEND(ARCHIVE_PATH.BASENAME()));
    INSTALL_LIST->ADDDELETETREEWORKITEM(OLD_ARCHIVE, TEMP_PATH)
        ->SET_IGNORE_FAILURE(TRUE);
  }

  FILEPATH NEW_CHROME_EXE(TARGET_PATH.APPEND(INSTALLER::KCHROMENEWEXE));

  INSTALL_LIST->ADDDELETETREEWORKITEM(NEW_CHROME_EXE, TEMP_PATH);
  INSTALL_LIST->ADDCOPYTREEWORKITEM(
      SRC_PATH.APPEND(INSTALLER::KCHROMEEXE).VALUE(),
      TARGET_PATH.APPEND(INSTALLER::KCHROMEEXE).VALUE(),
      TEMP_PATH.VALUE(), WORKITEM::NEW_NAME_IF_IN_USE, NEW_CHROME_EXE.VALUE());

  IF (BASE::WIN::OSINFO::GETINSTANCE()->WOW64_STATUS() !=
      BASE::WIN::OSINFO::WOW64_DISABLED) {
    INSTALL_LIST->ADDMOVETREEWORKITEM(
        SRC_PATH.APPEND(INSTALLER::KWOWHELPEREXE).VALUE(),
        TARGET_PATH.APPEND(INSTALLER::KWOWHELPEREXE).VALUE(),
        TEMP_PATH.VALUE(),
        WORKITEM::ALWAYS_MOVE);
  }

  BOOL CHECK_FOR_DUPLICATES =
      (CURRENT_VERSION != NULL && CURRENT_VERSION->GET() != NULL &&
       CURRENT_VERSION->GET()->EQUALS(NEW_VERSION));
  INSTALL_LIST->ADDMOVETREEWORKITEM(
      SRC_PATH.APPENDASCII(NEW_VERSION.GETSTRING()).VALUE(),
      TARGET_PATH.APPENDASCII(NEW_VERSION.GETSTRING()).VALUE(),
      TEMP_PATH.VALUE(),
      CHECK_FOR_DUPLICATES ? WORKITEM::CHECK_DUPLICATES :
                             WORKITEM::ALWAYS_MOVE);

  INSTALL_LIST->ADDCOPYTREEWORKITEM(
      SRC_PATH.APPEND(INSTALLER::KDICTIONARIES).VALUE(),
      TARGET_PATH.APPEND(INSTALLER::KDICTIONARIES).VALUE(),
      TEMP_PATH.VALUE(), WORKITEM::IF_NOT_PRESENT);

  INSTALL_LIST->ADDDELETETREEWORKITEM(
      TARGET_PATH.APPEND(INSTALLER::KCHROMEOLDEXE), TEMP_PATH);

  ADDINSTALLERCOPYTASKS(INSTALLER_STATE, SETUP_PATH, ARCHIVE_PATH, TEMP_PATH,
                        NEW_VERSION, INSTALL_LIST);

  CONST HKEY ROOT = INSTALLER_STATE.ROOT_KEY();

  CONST PRODUCTS& PRODUCTS = INSTALLER_STATE.PRODUCTS();
  FOR (SIZE_T I = 0; I < PRODUCTS.SIZE(); ++I) {
    CONST PRODUCT* PRODUCT = PRODUCTS[I];

    ADDUNINSTALLSHORTCUTWORKITEMS(INSTALLER_STATE, SETUP_PATH, NEW_VERSION,
                                  INSTALL_LIST, *PRODUCT);

    ADDVERSIONKEYWORKITEMS(ROOT, PRODUCT->DISTRIBUTION(), NEW_VERSION,
                           INSTALL_LIST);
  }

  IF (INSTALLER_STATE.IS_MULTI_INSTALL()) {
    ADDVERSIONKEYWORKITEMS(ROOT,
        INSTALLER_STATE.MULTI_PACKAGE_BINARIES_DISTRIBUTION(), NEW_VERSION,
        INSTALL_LIST);
  }

  ADDPRODUCTSPECIFICWORKITEMS(ORIGINAL_STATE, INSTALLER_STATE, SETUP_PATH,
                              NEW_VERSION, INSTALL_LIST);

  ADDGOOGLEUPDATEWORKITEMS(ORIGINAL_STATE, INSTALLER_STATE, INSTALL_LIST);

  ADDQUICKENABLEWORKITEMS(INSTALLER_STATE, ORIGINAL_STATE, &SETUP_PATH,
                          &NEW_VERSION, INSTALL_LIST);

  APPENDPOSTINSTALLTASKS(INSTALLER_STATE,
                         SETUP_PATH,
                         NEW_CHROME_EXE,
                         CURRENT_VERSION->GET(),
                         NEW_VERSION,
                         TEMP_PATH,
                         INSTALL_LIST);
}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336653_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RED_CHANNEL_CAPABILITIES_INIT_FROM_LINK_MESSAGE(REDCHANNELCAPABILITIES *CAPS,
                                                CONST SPICELINKMESS *LINK_MESS)
{
    CONST UINT8_T *RAW_CAPS = (CONST UINT8_T *)LINK_MESS + LINK_MESS->CAPS_OFFSET;

    CAPS->NUM_COMMON_CAPS = LINK_MESS->NUM_COMMON_CAPS;
    CAPS->COMMON_CAPS = NULL;
    IF (CAPS->NUM_COMMON_CAPS) {
        CAPS->COMMON_CAPS = (UINT32_T*) G_MEMDUP(RAW_CAPS,
                                     LINK_MESS->NUM_COMMON_CAPS * SIZEOF(UINT32_T));
    }
    CAPS->NUM_CAPS = LINK_MESS->NUM_CHANNEL_CAPS;
    CAPS->CAPS = NULL;
    IF (LINK_MESS->NUM_CHANNEL_CAPS) {
        CAPS->CAPS = (UINT32_T*) G_MEMDUP(RAW_CAPS + LINK_MESS->NUM_COMMON_CAPS * SIZEOF(UINT32_T),
                              LINK_MESS->NUM_CHANNEL_CAPS * SIZEOF(UINT32_T));
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195740_CWE-703.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL SAMPLEINTERLEAVEDLSSCAN::PARSEMCU(VOID)
{
#IF ACCUSOFT_CODE
  INT LINES             = M_ULREMAINING[0]; // TOTAL NUMBER OF MCU LINES PROCESSED.
  UBYTE PRESHIFT        = M_UCLOWBIT + FRACTIONALCOLORBITSOF();
  STRUCT LINE *LINE[4];
  UBYTE CX;

  //
  // IF A DNL MARKER IS PRESENT, THE NUMBER OF REMAINING LINES IS ZERO. FIX IT.
  IF (M_PFRAME->HEIGHTOF() == 0) {
    ASSERT(LINES == 0);
    LINES = 8;
  }
  //
  // A "MCU" IN RESPECT TO THE CODE ORGANIZATION IS EIGHT LINES.
  IF (LINES > 8) {
    LINES = 8;
  }
  IF (M_PFRAME->HEIGHTOF() > 0)
    M_ULREMAINING[0] -= LINES;
  ASSERT(LINES > 0);
  ASSERT(M_UCCOUNT < 4);

  //
  // FILL THE LINE POINTERS.
  FOR(CX = 0;CX < M_UCCOUNT;CX++) {
    LINE[CX] = CURRENTLINE(CX);
  }

  // LOOP OVER LINES AND COLUMNS
  DO {
    LONG LENGTH = M_ULWIDTH[0];
    LONG *LP[4];

    // GET THE LINE POINTERS AND INITIALIZE THE INTERNAL BACKUP LINES.
    FOR(CX = 0;CX < M_UCCOUNT;CX++) {
      LP[CX] = LINE[CX]->M_PDATA;
      STARTLINE(CX);
    }

    IF (BEGINREADMCU(M_STREAM.BYTESTREAMOF())) { 
      // NO ERROR HANDLING STRATEGY. NO RST IN SCANS. BUMMER!
      DO {
        LONG A[4],B[4],C[4],D[4]; // NEIGHBOURING VALUES.
        LONG D1[4],D2[4],D3[4];   // LOCAL GRADIENTS.
        BOOL ISRUN = TRUE;
      
        FOR(CX = 0;CX < M_UCCOUNT;CX++) {
          GETCONTEXT(CX,A[CX],B[CX],C[CX],D[CX]);

          D1[CX]  = D[CX] - B[CX];    // COMPUTE LOCAL GRADIENTS
          D2[CX]  = B[CX] - C[CX];
          D3[CX]  = C[CX] - A[CX];

          //
          // RUN MODE ONLY IF THE RUN CONDITION IS MET FOR ALL COMPONENTS
          IF (ISRUN && !ISRUNMODE(D1[CX],D2[CX],D3[CX]))
            ISRUN = FALSE;
        }
        
        IF (ISRUN) {
          LONG RUN = DECODERUN(LENGTH,M_LRUNINDEX[0]);
          //
          // NOW FILL THE DATA.
          WHILE(RUN) {
            // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
            // THERE IS ONE SAMPLE PER COMPONENT.
            FOR(CX = 0;CX < M_UCCOUNT;CX++) {
              UPDATECONTEXT(CX,A[CX]);
              // AND INSERT THE VALUE INTO THE TARGET LINE AS WELL.
              *LP[CX]++ = A[CX] << PRESHIFT;
            }
            RUN--,LENGTH--;
            // AS LONG AS THERE ARE PIXELS ON THE LINE.
          }
          //
          // MORE DATA ON THE LINE? I.E. THE RUN DID NOT COVER THE FULL M_LJ SAMPLES?
          // NOW DECODE THE RUN INTERRUPTION SAMPLE. THE RTYPE IS HERE ALWAYS ZERO.
          IF (LENGTH) {
            BOOL NEGATIVE; // THE SIGN VARIABLE
            LONG ERRVAL;   // THE PREDICTION ERROR
            LONG MERR;     // THE MAPPED ERROR (SYMBOL)
            LONG RX;       // THE RECONSTRUCTED VALUE
            UBYTE K;       // GOLOMB PARAMETER
            //
            // DECODE THE INTERRUPTING PIXELS.
            FOR(CX = 0;CX < M_UCCOUNT;CX++) {
              // GET THE NEIGHBOURHOOD.
              GETCONTEXT(CX,A[CX],B[CX],C[CX],D[CX]);
              // THE PREDICTION MODE IS ALWAYS FALSE, BUT THE SIGN INFORMATION
              // IS REQUIRED.
              NEGATIVE = A[CX] > B[CX];
              // GET THE GOLOMB PARAMETER FOR RUN INTERRUPTION CODING.
              K       = GOLOMBPARAMETER(FALSE);
              // GOLOMB-DECODE THE ERROR SYMBOL. IT IS ALWAYS USING THE COMMON
              // RUN INDEX.
              MERR    = GOLOMBDECODE(K,M_LLIMIT - M_LJ[M_LRUNINDEX[0]] - 1);
              // INVERSE THE ERROR MAPPING PROCEDURE.
              ERRVAL  = INVERSEERRORMAPPING(MERR,ERRORMAPPINGOFFSET(FALSE,MERR != 0,K));
              // COMPUTE THE RECONSTRUCTED VALUE.
              RX      = RECONSTRUCT(NEGATIVE,B[CX],ERRVAL);
              // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
              UPDATECONTEXT(CX,RX);
              // FILL IN THE VALUE INTO THE LINE
              *LP[CX]++ = RX << PRESHIFT;
              // UPDATE THE VARIABLES OF THE RUN MODE.
              UPDATESTATE(FALSE,ERRVAL);
            }
            // UPDATE THE RUN INDEX NOW. THIS IS NOT PART OF
            // ENCODERUN BECAUSE THE NON-REDUCED RUN-INDEX IS
            // REQUIRED FOR THE GOLOMB CODER LENGTH LIMIT. 
            IF (M_LRUNINDEX[0] > 0)
              M_LRUNINDEX[0]--;
          } ELSE BREAK; // END OF LINE.
        } ELSE {
          UWORD CTXT;
          BOOL  NEGATIVE; // THE SIGN VARIABLE.
          LONG  PX;       // THE PREDICTED VARIABLE.
          LONG  RX;       // THE RECONSTRUCTED VALUE.
          LONG  ERRVAL;   // THE ERROR VALUE.
          LONG  MERR;     // THE MAPPED ERROR VALUE.
          UBYTE K;        // THE GOLOMB PARAMETER.
          //
          FOR(CX = 0;CX < M_UCCOUNT;CX++) {
            // QUANTIZE THE GRADIENTS.
            D1[CX]  = QUANTIZEDGRADIENT(D1[CX]);
            D2[CX]  = QUANTIZEDGRADIENT(D2[CX]);
            D3[CX]  = QUANTIZEDGRADIENT(D3[CX]);
            // COMPUTE THE CONTEXT.
            CTXT    = CONTEXT(NEGATIVE,D1[CX],D2[CX],D3[CX]); 
            // COMPUTE THE PREDICTED VALUE.
            PX      = PREDICT(A[CX],B[CX],C[CX]);
            // CORRECT THE PREDICTION.
            PX      = CORRECTPREDICTION(CTXT,NEGATIVE,PX);
            // COMPUTE THE GOLOMB PARAMETER K FROM THE CONTEXT.
            K       = GOLOMBPARAMETER(CTXT);
            // DECODE THE ERROR SYMBOL.
            MERR    = GOLOMBDECODE(K,M_LLIMIT);
            // INVERSE THE ERROR SYMBOL INTO AN ERROR VALUE.
            ERRVAL  = INVERSEERRORMAPPING(MERR,ERRORMAPPINGOFFSET(CTXT,K));
            // UPDATE THE VARIABLES.
            UPDATESTATE(CTXT,ERRVAL);
            // COMPUTE THE RECONSTRUCTED VALUE.
            RX      = RECONSTRUCT(NEGATIVE,PX,ERRVAL);
            // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
            UPDATECONTEXT(CX,RX);
            // AND INSERT THE VALUE INTO THE TARGET LINE AS WELL.
            *LP[CX]++ = RX << PRESHIFT;
          }
        }
      } WHILE(--LENGTH);
    } // NO ERROR HANDLING HERE.
    //
    // ADVANCE THE LINE POINTERS.
    FOR(CX = 0;CX < M_UCCOUNT;CX++) {
      ENDLINE(CX);
      LINE[CX] = LINE[CX]->M_PNEXT;
    }
    //
  } WHILE(--LINES);
  //
  // IF THIS IS THE LAST LINE, GOBBLE UP ALL THE
  // BITS FROM BITSTUFFING THE LAST BYTE MAY HAVE LEFT.
  // AS SKIPSTUFFING IS IDEMPOTENT, WE CAN ALSO DO THAT
  // ALL THE TIME.
  M_STREAM.SKIPSTUFFING();
#ENDIF  
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196894_CWE-399.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INTEGER INVERTIBLERWFUNCTION::CALCULATEINVERSE(RANDOMNUMBERGENERATOR &RNG, CONST INTEGER &X) CONST
{
	DOQUICKSANITYCHECK();
	MODULARARITHMETIC MODN(M_N);
	INTEGER R, RINV;
	DO {	// DO THIS IN A LOOP FOR PEOPLE USING SMALL NUMBERS FOR TESTING
		R.RANDOMIZE(RNG, INTEGER::ONE(), M_N - INTEGER::ONE());
		RINV = MODN.MULTIPLICATIVEINVERSE(R);
	} WHILE (RINV.ISZERO());
	INTEGER RE = MODN.SQUARE(R);
	RE = MODN.MULTIPLY(RE, X);			// BLIND

	INTEGER CP=RE%M_P, CQ=RE%M_Q;
	IF (JACOBI(CP, M_P) * JACOBI(CQ, M_Q) != 1)
	{
		CP = CP.ISODD() ? (CP+M_P) >> 1 : CP >> 1;
		CQ = CQ.ISODD() ? (CQ+M_Q) >> 1 : CQ >> 1;
	}

	#PRAGMA OMP PARALLEL
		#PRAGMA OMP SECTIONS
		{
			#PRAGMA OMP SECTION
				CP = MODULARSQUAREROOT(CP, M_P);
			#PRAGMA OMP SECTION
				CQ = MODULARSQUAREROOT(CQ, M_Q);
		}

	INTEGER Y = CRT(CQ, M_Q, CP, M_P, M_U);
	Y = MODN.MULTIPLY(Y, RINV);				// UNBLIND
	Y = STDMIN(Y, M_N-Y);
	IF (APPLYFUNCTION(Y) != X)				// CHECK
		THROW EXCEPTION(EXCEPTION::OTHER_ERROR, "INVERTIBLERWFUNCTION: COMPUTATIONAL ERROR DURING PRIVATE KEY OPERATION");
	RETURN Y;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512597_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL LONGLONG VAL_INT_MIN() CONST
  {
    RETURN LONGLONG_MIN;
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204351_CWE-125.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL SQCLASS::NEWSLOT(SQSHAREDSTATE *SS,CONST SQOBJECTPTR &KEY,CONST SQOBJECTPTR &VAL,BOOL BSTATIC)
{
    SQOBJECTPTR TEMP;
    BOOL BELONGS_TO_STATIC_TABLE = SQ_TYPE(VAL) == OT_CLOSURE || SQ_TYPE(VAL) == OT_NATIVECLOSURE || BSTATIC;
    IF(_LOCKED && !BELONGS_TO_STATIC_TABLE)
        RETURN FALSE; //THE CLASS ALREADY HAS AN INSTANCE SO CANNOT BE MODIFIED
    IF(_MEMBERS->GET(KEY,TEMP) && _ISFIELD(TEMP)) //OVERRIDES THE DEFAULT VALUE
    {
        _DEFAULTVALUES[_MEMBER_IDX(TEMP)].VAL = VAL;
        RETURN TRUE;
    }
    IF(BELONGS_TO_STATIC_TABLE) {
        SQINTEGER MMIDX;
        IF((SQ_TYPE(VAL) == OT_CLOSURE || SQ_TYPE(VAL) == OT_NATIVECLOSURE) &&
            (MMIDX = SS->GETMETAMETHODIDXBYNAME(KEY)) != -1) {
            _METAMETHODS[MMIDX] = VAL;
        }
        ELSE {
            SQOBJECTPTR THEVAL = VAL;
            IF(_BASE && SQ_TYPE(VAL) == OT_CLOSURE) {
                THEVAL = _CLOSURE(VAL)->CLONE();
                _CLOSURE(THEVAL)->_BASE = _BASE;
                __OBJADDREF(_BASE); //REF FOR THE CLOSURE
            }
            IF(SQ_TYPE(TEMP) == OT_NULL) {
                BOOL ISCONSTRUCTOR;
                SQVM::ISEQUAL(SS->_CONSTRUCTORIDX, KEY, ISCONSTRUCTOR);
                IF(ISCONSTRUCTOR) {
                    _CONSTRUCTORIDX = (SQINTEGER)_METHODS.SIZE();
                }
                SQCLASSMEMBER M;
                M.VAL = THEVAL;
                _MEMBERS->NEWSLOT(KEY,SQOBJECTPTR(_MAKE_METHOD_IDX(_METHODS.SIZE())));
                _METHODS.PUSH_BACK(M);
            }
            ELSE {
                _METHODS[_MEMBER_IDX(TEMP)].VAL = THEVAL;
            }
        }
        RETURN TRUE;
    }
    SQCLASSMEMBER M;
    M.VAL = VAL;
    _MEMBERS->NEWSLOT(KEY,SQOBJECTPTR(_MAKE_FIELD_IDX(_DEFAULTVALUES.SIZE())));
    _DEFAULTVALUES.PUSH_BACK(M);
    RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216906_CWE-400.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID HA_MARIA::DROP_TABLE(CONST CHAR *NAME)
{
  DBUG_ASSERT(FILE->S->TEMPORARY);
  (VOID) HA_CLOSE();
  (VOID) MARIA_DELETE_TABLE_FILES(NAME, 1, MY_WME);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 276972_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SAMPLEENCRYPTER::CREATE(CONST AP4_UI08* KEY, CONST AP4_UI08* IV, SAMPLEENCRYPTER*& ENCRYPTER) {
    ENCRYPTER = NULL;
    AP4_BLOCKCIPHER* BLOCK_CIPHER = NULL;
    AP4_RESULT RESULT = AP4_DEFAULTBLOCKCIPHERFACTORY::INSTANCE.CREATECIPHER(AP4_BLOCKCIPHER::AES_128,
                                                                             AP4_BLOCKCIPHER::ENCRYPT,
                                                                             AP4_BLOCKCIPHER::CBC,
                                                                             NULL,
                                                                             KEY,
                                                                             16,
                                                                             BLOCK_CIPHER);
    IF (AP4_FAILED(RESULT)) RETURN RESULT;
    AP4_CBCSTREAMCIPHER* STREAM_CIPHER = NEW AP4_CBCSTREAMCIPHER(BLOCK_CIPHER);
    ENCRYPTER = NEW SAMPLEENCRYPTER(STREAM_CIPHER, IV);
    
    RETURN AP4_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90222_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL CONST WIFINETWORKVECTOR& REMEMBERED_WIFI_NETWORKS() CONST {
    RETURN REMEMBERED_WIFI_NETWORKS_;
  }

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 255930_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS SHAPEREFINER::PARTIALSTRIDEDSLICESHAPE(
    NODE* SLICE_NODE, INFERENCECONTEXT* CTX, SHAPEHANDLE* RESULT,
    SHAPE_INFERENCE::INFERENCECONTEXT* OUTER_CONTEXT) {
  // ONLY ATTEMPT TO EVALUATE IF BEGIN/END/STRIDES ALL ARE SCALARS.
  FOR (INT I = 1; I <= 3; ++I) {
    SHAPEHANDLE INPUT_SHAPE = CTX->INPUT(I);
    IF (CTX->VALUE(CTX->DIM(INPUT_SHAPE, 0)) != 1) {
      *RESULT = CTX->UNKNOWNSHAPE();
      RETURN STATUS::OK();
    }
  }

  INT BEGIN_MASK, END_MASK, ELLIPSIS_MASK, NEW_AXIS_MASK, SHRINK_AXIS_MASK;
  TF_RETURN_IF_ERROR(
      GETNODEATTR(SLICE_NODE->ATTRS(), "BEGIN_MASK", &BEGIN_MASK));
  TF_RETURN_IF_ERROR(GETNODEATTR(SLICE_NODE->ATTRS(), "END_MASK", &END_MASK));
  TF_RETURN_IF_ERROR(
      GETNODEATTR(SLICE_NODE->ATTRS(), "ELLIPSIS_MASK", &ELLIPSIS_MASK));
  TF_RETURN_IF_ERROR(
      GETNODEATTR(SLICE_NODE->ATTRS(), "NEW_AXIS_MASK", &NEW_AXIS_MASK));
  TF_RETURN_IF_ERROR(
      GETNODEATTR(SLICE_NODE->ATTRS(), "SHRINK_AXIS_MASK", &SHRINK_AXIS_MASK));

  // ONLY ATTEMPT TO EVALUATE IF THERE ARE NO SPECIAL MASKS SET (NOTE THAT WE
  // CAN HANDLE BEGIN/END_MASK == 1).
  IF (!(BEGIN_MASK == 0 || BEGIN_MASK == 1) ||
      !(END_MASK == 0 || END_MASK == 1) || ELLIPSIS_MASK != 0 ||
      NEW_AXIS_MASK != 0 || SHRINK_AXIS_MASK != 0) {
    *RESULT = CTX->UNKNOWNSHAPE();
    RETURN STATUS::OK();
  }

  BOOL EVALUATED;
  INT64 BEGIN;
  IF (BEGIN_MASK == 1) {
    BEGIN = 0;
  } ELSE {
    TF_RETURN_IF_ERROR(EVALUATECONSTANTINTSCALAREDGE(SLICE_NODE, 1, &EVALUATED,
                                                     &BEGIN, OUTER_CONTEXT));
    IF (!EVALUATED) {
      *RESULT = CTX->UNKNOWNSHAPE();
      RETURN STATUS::OK();
    }
  }

  INT64 END;
  IF (END_MASK == 1) {
    END = STD::NUMERIC_LIMITS<INT64>::MAX();
  } ELSE {
    TF_RETURN_IF_ERROR(EVALUATECONSTANTINTSCALAREDGE(SLICE_NODE, 2, &EVALUATED,
                                                     &END, OUTER_CONTEXT));
    IF (!EVALUATED) {
      *RESULT = CTX->UNKNOWNSHAPE();
      RETURN STATUS::OK();
    }
  }

  INT64 STRIDE;
  TF_RETURN_IF_ERROR(EVALUATECONSTANTINTSCALAREDGE(SLICE_NODE, 3, &EVALUATED,
                                                   &STRIDE, OUTER_CONTEXT));
  IF (!EVALUATED) {
    *RESULT = CTX->UNKNOWNSHAPE();
    RETURN STATUS::OK();
  }

  // APPLY STRIDE TO INPUT INTERPRETED AS A PARTIAL SHAPE.
  SHAPEHANDLE INPUT;
  TF_RETURN_IF_ERROR(
      CONSTANTPARTIALSHAPE(CTX, SLICE_NODE, 0, &INPUT, OUTER_CONTEXT));
  TF_RETURN_IF_ERROR(CTX->SUBSHAPE(INPUT, BEGIN, END, STRIDE, RESULT));
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207150_CWE-703.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SQINTEGER THREAD_CALL(HSQUIRRELVM V)
{
    SQOBJECTPTR O = STACK_GET(V,1);
    IF(SQ_TYPE(O) == OT_THREAD) {
        SQINTEGER NPARAMS = SQ_GETTOP(V);
        _THREAD(O)->PUSH(_THREAD(O)->_ROOTTABLE);
        FOR(SQINTEGER I = 2; I<(NPARAMS+1); I++)
            SQ_MOVE(_THREAD(O),V,I);
        IF(SQ_SUCCEEDED(SQ_CALL(_THREAD(O),NPARAMS,SQTRUE,SQTRUE))) {
            SQ_MOVE(V,_THREAD(O),-1);
            SQ_POP(_THREAD(O),1);
            RETURN 1;
        }
        V->_LASTERROR = _THREAD(O)->_LASTERROR;
        RETURN SQ_ERROR;
    }
    RETURN SQ_THROWERROR(V,_SC("WRONG PARAMETER"));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210702_CWE-22.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIR *SQUASHFS_OPENDIR(UNSIGNED INT BLOCK_START, UNSIGNED INT OFFSET,
	STRUCT INODE **I)
{
	STRUCT SQUASHFS_DIR_HEADER DIRH;
	CHAR BUFFER[SIZEOF(STRUCT SQUASHFS_DIR_ENTRY) + SQUASHFS_NAME_LEN + 1]
		__ATTRIBUTE__((ALIGNED));
	STRUCT SQUASHFS_DIR_ENTRY *DIRE = (STRUCT SQUASHFS_DIR_ENTRY *) BUFFER;
	LONG LONG START;
	LONG LONG BYTES;
	INT DIR_COUNT, SIZE;
	STRUCT DIR_ENT *NEW_DIR;
	STRUCT DIR *DIR;

	TRACE("SQUASHFS_OPENDIR: INODE START BLOCK %D, OFFSET %D\N",
		BLOCK_START, OFFSET);

	*I = READ_INODE(BLOCK_START, OFFSET);

	DIR = MALLOC(SIZEOF(STRUCT DIR));
	IF(DIR == NULL)
		EXIT_UNSQUASH("SQUASHFS_OPENDIR: MALLOC FAILED!\N");

	DIR->DIR_COUNT = 0;
	DIR->CUR_ENTRY = 0;
	DIR->MODE = (*I)->MODE;
	DIR->UID = (*I)->UID;
	DIR->GUID = (*I)->GID;
	DIR->MTIME = (*I)->TIME;
	DIR->XATTR = (*I)->XATTR;
	DIR->DIRS = NULL;

	IF ((*I)->DATA == 3)
		/*
		 * IF THE DIRECTORY IS EMPTY, SKIP THE UNNECESSARY
		 * LOOKUP_ENTRY, THIS FIXES THE CORNER CASE WITH
		 * COMPLETELY EMPTY FILESYSTEMS WHERE LOOKUP_ENTRY CORRECTLY
		 * RETURNING -1 IS INCORRECTLY TREATED AS AN ERROR
		 */
		RETURN DIR;

	START = SBLK.S.DIRECTORY_TABLE_START + (*I)->START;
	BYTES = LOOKUP_ENTRY(DIRECTORY_TABLE_HASH, START);

	IF(BYTES == -1)
		EXIT_UNSQUASH("SQUASHFS_OPENDIR: DIRECTORY BLOCK %LLD NOT "
			"FOUND!\N", START);

	BYTES += (*I)->OFFSET;
	SIZE = (*I)->DATA + BYTES - 3;

	WHILE(BYTES < SIZE) {			
		SQUASHFS_SWAP_DIR_HEADER(DIRECTORY_TABLE + BYTES, &DIRH);
	
		DIR_COUNT = DIRH.COUNT + 1;
		TRACE("SQUASHFS_OPENDIR: READ DIRECTORY HEADER @ BYTE POSITION "
			"%D, %D DIRECTORY ENTRIES\N", BYTES, DIR_COUNT);
		BYTES += SIZEOF(DIRH);

		/* DIR_COUNT SHOULD NEVER BE LARGER THAN SQUASHFS_DIR_COUNT */
		IF(DIR_COUNT > SQUASHFS_DIR_COUNT) {
			ERROR("FILE SYSTEM CORRUPTED: TOO MANY ENTRIES IN DIRECTORY\N");
			GOTO CORRUPTED;
		}

		WHILE(DIR_COUNT--) {
			SQUASHFS_SWAP_DIR_ENTRY(DIRECTORY_TABLE + BYTES, DIRE);

			BYTES += SIZEOF(*DIRE);

			/* SIZE SHOULD NEVER BE SQUASHFS_NAME_LEN OR LARGER */
			IF(DIRE->SIZE >= SQUASHFS_NAME_LEN) {
				ERROR("FILE SYSTEM CORRUPTED: FILENAME TOO LONG\N");
				GOTO CORRUPTED;
			}

			MEMCPY(DIRE->NAME, DIRECTORY_TABLE + BYTES,
				DIRE->SIZE + 1);
			DIRE->NAME[DIRE->SIZE + 1] = '\0';
			TRACE("SQUASHFS_OPENDIR: DIRECTORY ENTRY %S, INODE "
				"%D:%D, TYPE %D\N", DIRE->NAME,
				DIRH.START_BLOCK, DIRE->OFFSET, DIRE->TYPE);
			IF((DIR->DIR_COUNT % DIR_ENT_SIZE) == 0) {
				NEW_DIR = REALLOC(DIR->DIRS, (DIR->DIR_COUNT +
					DIR_ENT_SIZE) * SIZEOF(STRUCT DIR_ENT));
				IF(NEW_DIR == NULL)
					EXIT_UNSQUASH("SQUASHFS_OPENDIR: "
						"REALLOC FAILED!\N");
				DIR->DIRS = NEW_DIR;
			}
			STRCPY(DIR->DIRS[DIR->DIR_COUNT].NAME, DIRE->NAME);
			DIR->DIRS[DIR->DIR_COUNT].START_BLOCK =
				DIRH.START_BLOCK;
			DIR->DIRS[DIR->DIR_COUNT].OFFSET = DIRE->OFFSET;
			DIR->DIRS[DIR->DIR_COUNT].TYPE = DIRE->TYPE;
			DIR->DIR_COUNT ++;
			BYTES += DIRE->SIZE + 1;
		}
	}

	RETURN DIR;

CORRUPTED:
	FREE(DIR->DIRS);
	FREE(DIR);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204278_CWE-94.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID BUILD_DIRS(CHAR *SRC, CHAR *DST, SIZE_T SRC_PREFIX_LEN, SIZE_T DST_PREFIX_LEN) {
	CHAR *P = SRC + SRC_PREFIX_LEN + 1;
	CHAR *Q = DST + DST_PREFIX_LEN + 1;
	CHAR *R = DST + DST_PREFIX_LEN;
	STRUCT STAT S;
	BOOL LAST = FALSE;
	*R = '\0';
	FOR (; !LAST; P++, Q++) {
		IF (*P == '\0') {
			LAST = TRUE;
		}
		IF (*P == '\0' || (*P == '/' && *(P - 1) != '/')) {
			// WE FOUND A NEW COMPONENT OF OUR SRC PATH.
			// NULL-TERMINATE IT TEMPORARILY HERE SO THAT WE CAN WORK
			// WITH IT.
			*P = '\0';
			IF (STAT(SRC, &S) == 0 && S_ISDIR(S.ST_MODE)) {
				// NULL-TERMINATE THE DST PATH AND UNDO ITS PREVIOUS
				// TERMINATION.
				*Q = '\0';
				*R = '/';
				R = Q;
				MKDIR_ATTR(DST, S.ST_MODE, 0, 0);
			}
			IF (!LAST) {
				// IF WE'RE NOT AT THE FINAL TERMINATING NULL, RESTORE
				// THE SLASH SO THAT WE CAN CONTINUE OUR TRAVERSAL.
				*P = '/';
			}
		}
	}
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90183_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL VOID SAVECELLULARNETWORK(CONST CELLULARNETWORK* NETWORK) {
    DCHECK(NETWORK);
    IF (!ENSURECROSLOADED() || !NETWORK)
      RETURN;

    SETAUTOCONNECT(NETWORK->SERVICE_PATH().C_STR(), NETWORK->AUTO_CONNECT());
  }

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 445981_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
FR_WINDOW_ARCHIVE_SAVE_AS (FRWINDOW   *WINDOW,
			   GFILE      *FILE,
			   CONST CHAR *MIME_TYPE,
			   CONST CHAR *PASSWORD,
			   GBOOLEAN    ENCRYPT_HEADER,
			   GUINT       VOLUME_SIZE)
{
	FRARCHIVE   *NEW_ARCHIVE;
	CONVERTDATA *CDATA;

	G_RETURN_IF_FAIL (WINDOW != NULL);
	G_RETURN_IF_FAIL (FILE != NULL);
	G_RETURN_IF_FAIL (WINDOW->ARCHIVE != NULL);

	/* CREATE THE NEW ARCHIVE */

	NEW_ARCHIVE = FR_ARCHIVE_CREATE (FILE, MIME_TYPE);
	IF (NEW_ARCHIVE == NULL) {
		GTKWIDGET *D;
		CHAR      *UTF8_NAME;
		CHAR      *MESSAGE;

		UTF8_NAME = _G_FILE_GET_DISPLAY_BASENAME (FILE);
		MESSAGE = G_STRDUP_PRINTF (_("COULD NOT SAVE THE ARCHIVE \"%S\""), UTF8_NAME);
		G_FREE (UTF8_NAME);

		D = _GTK_ERROR_DIALOG_NEW (GTK_WINDOW (WINDOW),
					   GTK_DIALOG_DESTROY_WITH_PARENT,
					   NULL,
					   MESSAGE,
					   "%S",
					   _("ARCHIVE TYPE NOT SUPPORTED."));
		GTK_DIALOG_RUN (GTK_DIALOG (D));
		GTK_WIDGET_DESTROY (D);

		G_FREE (MESSAGE);

		RETURN;
	}

	CDATA = CONVERT_DATA_NEW (FILE, MIME_TYPE, PASSWORD, ENCRYPT_HEADER, VOLUME_SIZE);
	CDATA->WINDOW = WINDOW;
	CDATA->NEW_ARCHIVE = NEW_ARCHIVE;

	_ARCHIVE_OPERATION_STARTED (WINDOW, FR_ACTION_CREATING_ARCHIVE);
	FR_WINDOW_SET_CURRENT_BATCH_ACTION (WINDOW,
					    FR_BATCH_ACTION_SAVE_AS,
					    CDATA,
					    (GFREEFUNC) CONVERT_DATA_FREE);

	G_SIGNAL_CONNECT (CDATA->NEW_ARCHIVE,
			  "PROGRESS",
			  G_CALLBACK (FR_ARCHIVE_PROGRESS_CB),
			  WINDOW);
	G_SIGNAL_CONNECT (CDATA->NEW_ARCHIVE,
			  "MESSAGE",
			  G_CALLBACK (FR_ARCHIVE_MESSAGE_CB),
			  WINDOW);
	G_SIGNAL_CONNECT (CDATA->NEW_ARCHIVE,
			  "START",
			  G_CALLBACK (FR_ARCHIVE_START_CB),
			  WINDOW);
	G_SIGNAL_CONNECT (CDATA->NEW_ARCHIVE,
			  "STOPPABLE",
			  G_CALLBACK (FR_ARCHIVE_STOPPABLE_CB),
			  WINDOW);
	G_SIGNAL_CONNECT (CDATA->NEW_ARCHIVE,
			  "WORKING-ARCHIVE",
			  G_CALLBACK (FR_WINDOW_WORKING_ARCHIVE_CB),
			  WINDOW);

	_G_OBJECT_UNREF (WINDOW->PRIV->SAVING_FILE);
	WINDOW->PRIV->SAVING_FILE = G_OBJECT_REF (CDATA->FILE);

	FR_ARCHIVE_ACTION_STARTED (WINDOW->ARCHIVE, FR_ACTION_EXTRACTING_FILES);
	FR_ARCHIVE_EXTRACT (WINDOW->ARCHIVE,
			    NULL,
			    CDATA->TEMP_EXTRACTION_DIR,
			    NULL,
			    FALSE,
			    TRUE,
			    FALSE,
			    WINDOW->PRIV->PASSWORD,
			    WINDOW->PRIV->CANCELLABLE,
			    ARCHIVE_EXTRACTION_READY_FOR_CONVERTION_CB,
			    CDATA);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 413672_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL FOUND_XREF(RCORE *CORE, UT64 AT, UT64 XREF_TO, RANALREFTYPE TYPE, PJ *PJ, INT RAD, BOOL CFG_DEBUG, BOOL CFG_ANAL_STRINGS) {
	// VALIDATE THE REFERENCE. IF VIRTUAL ADDRESSING IS ENABLED, WE
	// ALLOW ONLY REFERENCES TO VIRTUAL ADDRESSES IN ORDER TO REDUCE
	// THE NUMBER OF FALSE POSITIVES. IN DEBUGGER MODE, THE REFERENCE
	// MUST POINT TO A MAPPED MEMORY REGION.
	IF (TYPE == R_ANAL_REF_TYPE_NULL) {
		RETURN FALSE;
	}
	IF (CFG_DEBUG) {
		IF (!R_DEBUG_MAP_GET (CORE->DBG, XREF_TO)) {
			RETURN FALSE;
		}
	} ELSE IF (CORE->IO->VA) {
		IF (!R_IO_IS_VALID_OFFSET (CORE->IO, XREF_TO, 0)) {
			RETURN FALSE;
		}
	}
	IF (!RAD) {
		IF (CFG_ANAL_STRINGS && TYPE == R_ANAL_REF_TYPE_DATA) {
			INT LEN = 0;
			CHAR *STR_STRING = IS_STRING_AT (CORE, XREF_TO, &LEN);
			IF (STR_STRING) {
				R_NAME_FILTER (STR_STRING, -1);
				CHAR *STR_FLAGNAME = R_STR_NEWF ("STR.%S", STR_STRING);
				R_FLAG_SPACE_PUSH (CORE->FLAGS, R_FLAGS_FS_STRINGS);
				(VOID)R_FLAG_SET (CORE->FLAGS, STR_FLAGNAME, XREF_TO, 1);
				R_FLAG_SPACE_POP (CORE->FLAGS);
				FREE (STR_FLAGNAME);
				IF (LEN > 0) {
					R_META_SET (CORE->ANAL, R_META_TYPE_STRING, XREF_TO,
								LEN, (CONST CHAR *) STR_STRING);
				}
				FREE (STR_STRING);
			}
		}
		// ADD TO SDB
		IF (XREF_TO) {
			R_ANAL_XREFS_SET (CORE->ANAL, AT, XREF_TO, TYPE);
		}
	} ELSE IF (RAD == 'J') {
		R_STRF_VAR (KEY, 32, "0X%"PFMT64X, XREF_TO);
		R_STRF_VAR (VALUE, 32, "0X%"PFMT64X, AT);
		PJ_KS (PJ, KEY, VALUE);
	} ELSE {
		INT LEN = 0;
		// DISPLAY IN RADARE COMMANDS FORMAT
		CHAR *CMD;
		SWITCH (TYPE) {
		CASE R_ANAL_REF_TYPE_CODE: CMD = "AXC"; BREAK;
		CASE R_ANAL_REF_TYPE_CALL: CMD = "AXC"; BREAK;
		CASE R_ANAL_REF_TYPE_DATA: CMD = "AXD"; BREAK;
		DEFAULT: CMD = "AX"; BREAK;
		}
		R_CONS_PRINTF ("%S 0X%08"PFMT64X" 0X%08"PFMT64X"\N", CMD, XREF_TO, AT);
		IF (CFG_ANAL_STRINGS && TYPE == R_ANAL_REF_TYPE_DATA) {
			CHAR *STR_FLAGNAME = IS_STRING_AT (CORE, XREF_TO, &LEN);
			IF (STR_FLAGNAME) {
				UT64 STR_ADDR = XREF_TO;
				R_NAME_FILTER (STR_FLAGNAME, -1);
				R_CONS_PRINTF ("F STR.%S=0X%"PFMT64X"\N", STR_FLAGNAME, STR_ADDR);
				R_CONS_PRINTF ("CS %D @ 0X%"PFMT64X"\N", LEN, STR_ADDR);
				FREE (STR_FLAGNAME);
			}
		}
	}
	RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197057_CWE-552.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT HTTPFILEIMPL::SAVE(CONST STD::STRING &PATH) CONST
{
    ASSERT(!PATH.EMPTY());
    IF (FILENAME_.EMPTY())
        RETURN -1;
    FILESYSTEM::PATH FSPATH(UTILS::TONATIVEPATH(PATH));
    IF (!FSPATH.IS_ABSOLUTE() &&
        (!FSPATH.HAS_PARENT_PATH() ||
         (FSPATH.BEGIN()->STRING() != "." && FSPATH.BEGIN()->STRING() != "..")))
    {
        FILESYSTEM::PATH FSUPLOADPATH(UTILS::TONATIVEPATH(
            HTTPAPPFRAMEWORKIMPL::INSTANCE().GETUPLOADPATH()));
        FSPATH = FSUPLOADPATH / FSPATH;
    }
    FILESYSTEM::PATH FSFILENAME(UTILS::TONATIVEPATH(FILENAME_));
    IF (!FILESYSTEM::EXISTS(FSPATH))
    {
        LOG_TRACE << "CREATE PATH:" << FSPATH;
        DROGON::ERROR_CODE ERR;
        FILESYSTEM::CREATE_DIRECTORIES(FSPATH, ERR);
        IF (ERR)
        {
            LOG_SYSERR;
            RETURN -1;
        }
    }
    RETURN SAVETO(FSPATH / FSFILENAME);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216938_CWE-416.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL OPEN_TABLE(THD *THD, TABLE_LIST *TABLE_LIST, OPEN_TABLE_CONTEXT *OT_CTX)
{
  TABLE *TABLE;
  CONST CHAR *KEY;
  UINT	KEY_LENGTH;
  CONST CHAR *ALIAS= TABLE_LIST->ALIAS.STR;
  UINT FLAGS= OT_CTX->GET_FLAGS();
  MDL_TICKET *MDL_TICKET;
  TABLE_SHARE *SHARE;
  UINT GTS_FLAGS;
  BOOL FROM_SHARE= FALSE;
#IFDEF WITH_PARTITION_STORAGE_ENGINE
  INT PART_NAMES_ERROR=0;
#ENDIF
  DBUG_ENTER("OPEN_TABLE");

  /*
    THE TABLE MUST NOT BE OPENED ALREADY. THE TABLE CAN BE PRE-OPENED FOR
    SOME STATEMENTS IF IT IS A TEMPORARY TABLE.

    OPEN_TEMPORARY_TABLE() MUST BE USED TO OPEN TEMPORARY TABLES.
  */
  DBUG_ASSERT(!TABLE_LIST->TABLE);

  /* AN OPEN TABLE OPERATION NEEDS A LOT OF THE STACK SPACE */
  IF (CHECK_STACK_OVERRUN(THD, STACK_MIN_SIZE_FOR_OPEN, (UCHAR *)&ALIAS))
    DBUG_RETURN(TRUE);

  IF (!(FLAGS & MYSQL_OPEN_IGNORE_KILLED) && THD->KILLED)
  {
    THD->SEND_KILL_MESSAGE();
    DBUG_RETURN(TRUE);
  }

  /*
    CHECK IF WE'RE TRYING TO TAKE A WRITE LOCK IN A READ ONLY TRANSACTION.

    NOTE THAT WE ALLOW WRITE LOCKS ON LOG TABLES AS OTHERWISE LOGGING
    TO GENERAL/SLOW LOG WOULD BE DISABLED IN READ ONLY TRANSACTIONS.
  */
  IF (TABLE_LIST->MDL_REQUEST.IS_WRITE_LOCK_REQUEST() &&
      THD->TX_READ_ONLY &&
      !(FLAGS & (MYSQL_LOCK_LOG_TABLE | MYSQL_OPEN_HAS_MDL_LOCK)))
  {
    MY_ERROR(ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION, MYF(0));
    DBUG_RETURN(TRUE);
  }

  IF (!TABLE_LIST->DB.STR)
  {
    MY_ERROR(ER_NO_DB_ERROR, MYF(0));
    DBUG_RETURN(TRUE);
  }

  KEY_LENGTH= GET_TABLE_DEF_KEY(TABLE_LIST, &KEY);

  /*
    IF WE'RE IN PRE-LOCKED OR LOCK TABLES MODE, LET'S TRY TO FIND THE
    REQUESTED TABLE IN THE LIST OF PRE-OPENED AND LOCKED TABLES. IF THE
    TABLE IS NOT THERE, RETURN AN ERROR - WE CAN'T OPEN NOT PRE-OPENED
    TABLES IN PRE-LOCKED/LOCK TABLES MODE.
    TODO: MOVE THIS BLOCK INTO A SEPARATE FUNCTION.
  */
  IF (THD->LOCKED_TABLES_MODE &&
      ! (FLAGS & MYSQL_OPEN_GET_NEW_TABLE))
  {						// USING TABLE LOCKS
    TABLE *BEST_TABLE= 0;
    INT BEST_DISTANCE= INT_MIN;
    FOR (TABLE=THD->OPEN_TABLES; TABLE ; TABLE=TABLE->NEXT)
    {
      IF (TABLE->S->TABLE_CACHE_KEY.LENGTH == KEY_LENGTH &&
	  !MEMCMP(TABLE->S->TABLE_CACHE_KEY.STR, KEY, KEY_LENGTH))
      {
        IF (!MY_STRCASECMP(SYSTEM_CHARSET_INFO, TABLE->ALIAS.C_PTR(), ALIAS) &&
            TABLE->QUERY_ID != THD->QUERY_ID && /* SKIP TABLES ALREADY USED */
            (THD->LOCKED_TABLES_MODE == LTM_LOCK_TABLES ||
             TABLE->QUERY_ID == 0))
        {
          INT DISTANCE= ((INT) TABLE->REGINFO.LOCK_TYPE -
                         (INT) TABLE_LIST->LOCK_TYPE);

          /*
            FIND A TABLE THAT EITHER HAS THE EXACT LOCK TYPE REQUESTED,
            OR HAS THE BEST SUITABLE LOCK. IN CASE THERE IS NO LOCKED
            TABLE THAT HAS AN EQUAL OR HIGHER LOCK THAN REQUESTED,
            WE US THE CLOSEST MATCHING LOCK TO BE ABLE TO PRODUCE AN ERROR
            MESSAGE ABOUT WRONG LOCK MODE ON THE TABLE. THE BEST_TABLE
            IS CHANGED IF BD < 0 <= D OR BD < D < 0 OR 0 <= D < BD.

            DISTANCE <  0 - NO SUITABLE LOCK FOUND
            DISTANCE >  0 - WE HAVE LOCK MODE HIGHER THEN WE REQUIRE
            DISTANCE == 0 - WE HAVE LOCK MODE EXACTLY WHICH WE NEED
          */
          IF ((BEST_DISTANCE < 0 && DISTANCE > BEST_DISTANCE) ||
              (DISTANCE >= 0 && DISTANCE < BEST_DISTANCE))
          {
            BEST_DISTANCE= DISTANCE;
            BEST_TABLE= TABLE;
            IF (BEST_DISTANCE == 0)
            {
              /*
                WE HAVE FOUND A PERFECT MATCH AND CAN FINISH ITERATING
                THROUGH OPEN TABLES LIST. CHECK FOR TABLE USE CONFLICT
                BETWEEN CALLING STATEMENT AND SP/TRIGGER IS DONE IN
                LOCK_TABLES().
              */
              BREAK;
            }
          }
        }
      }
    }
    IF (BEST_TABLE)
    {
      TABLE= BEST_TABLE;
      TABLE->QUERY_ID= THD->QUERY_ID;
      TABLE->INIT(THD, TABLE_LIST);
      DBUG_PRINT("INFO",("USING LOCKED TABLE"));
#IFDEF WITH_PARTITION_STORAGE_ENGINE
      PART_NAMES_ERROR= SET_PARTITIONS_AS_USED(TABLE_LIST, TABLE);
#ENDIF
      GOTO RESET;
    }

    IF (IS_LOCKED_VIEW(THD, TABLE_LIST))
    {
      IF (TABLE_LIST->SEQUENCE)
      {
        MY_ERROR(ER_NOT_SEQUENCE, MYF(0), TABLE_LIST->DB.STR, TABLE_LIST->ALIAS.STR);
        DBUG_RETURN(TRUE);
      }
      DBUG_RETURN(FALSE); // VIEW
    }

    /*
      NO TABLE IN THE LOCKED TABLES LIST. IN CASE OF EXPLICIT LOCK TABLES
      THIS CAN HAPPEN IF A USER DID NOT INCLUDE THE TABLE INTO THE LIST.
      IN CASE OF PRE-LOCKED MODE LOCKED TABLES LIST IS GENERATED AUTOMATICALLY,
      SO WE MAY ONLY END UP HERE IF THE TABLE DID NOT EXIST WHEN
      LOCKED TABLES LIST WAS CREATED.
    */
    IF (THD->LOCKED_TABLES_MODE == LTM_PRELOCKED)
      MY_ERROR(ER_NO_SUCH_TABLE, MYF(0), TABLE_LIST->DB.STR, TABLE_LIST->ALIAS.STR);
    ELSE
      MY_ERROR(ER_TABLE_NOT_LOCKED, MYF(0), ALIAS);
    DBUG_RETURN(TRUE);
  }

  /*
    NON PRE-LOCKED/LOCK TABLES MODE, AND THE TABLE IS NOT TEMPORARY.
    THIS IS THE NORMAL USE CASE.
  */

  IF (! (FLAGS & MYSQL_OPEN_HAS_MDL_LOCK))
  {
    /*
      WE ARE NOT UNDER LOCK TABLES AND GOING TO ACQUIRE WRITE-LOCK/
      MODIFY THE BASE TABLE. WE NEED TO ACQUIRE PROTECTION AGAINST
      GLOBAL READ LOCK UNTIL END OF THIS STATEMENT IN ORDER TO HAVE
      THIS STATEMENT BLOCKED BY ACTIVE FLUSH TABLES WITH READ LOCK.

      WE DON'T NEED TO ACQUIRE THIS PROTECTION UNDER LOCK TABLES AS
      SUCH PROTECTION ALREADY ACQUIRED AT LOCK TABLES TIME AND
      NOT RELEASED UNTIL UNLOCK TABLES.

      WE DON'T BLOCK STATEMENTS WHICH MODIFY ONLY TEMPORARY TABLES
      AS THESE TABLES ARE NOT PRESERVED BY ANY FORM OF
      BACKUP WHICH USES FLUSH TABLES WITH READ LOCK.

      TODO: THE FACT THAT WE SOMETIMES ACQUIRE PROTECTION AGAINST
            GRL ONLY WHEN WE ENCOUNTER TABLE TO BE WRITE-LOCKED
            SLIGHTLY INCREASES PROBABILITY OF DEADLOCK.
            THIS PROBLEM WILL BE SOLVED ONCE ALIK PUSHES HIS
            TEMPORARY TABLE REFACTORING PATCH AND WE CAN START
            PRE-ACQUIRING METADATA LOCKS AT THE BEGGINING OF
            OPEN_TABLES() CALL.
    */
    IF (TABLE_LIST->MDL_REQUEST.IS_WRITE_LOCK_REQUEST() &&
        ! (FLAGS & (MYSQL_OPEN_IGNORE_GLOBAL_READ_LOCK |
                    MYSQL_OPEN_FORCE_SHARED_MDL |
                    MYSQL_OPEN_FORCE_SHARED_HIGH_PRIO_MDL |
                    MYSQL_OPEN_SKIP_SCOPED_MDL_LOCK)) &&
        ! OT_CTX->HAS_PROTECTION_AGAINST_GRL())
    {
      MDL_REQUEST PROTECTION_REQUEST;
      MDL_DEADLOCK_HANDLER MDL_DEADLOCK_HANDLER(OT_CTX);

      IF (THD->GLOBAL_READ_LOCK.CAN_ACQUIRE_PROTECTION())
        DBUG_RETURN(TRUE);

      PROTECTION_REQUEST.INIT(MDL_KEY::GLOBAL, "", "", MDL_INTENTION_EXCLUSIVE,
                              MDL_STATEMENT);

      /*
        INSTALL ERROR HANDLER WHICH IF POSSIBLE WILL CONVERT DEADLOCK ERROR
        INTO REQUEST TO BACK-OFF AND RESTART PROCESS OF OPENING TABLES.
      */
      THD->PUSH_INTERNAL_HANDLER(&MDL_DEADLOCK_HANDLER);
      BOOL RESULT= THD->MDL_CONTEXT.ACQUIRE_LOCK(&PROTECTION_REQUEST,
                                                 OT_CTX->GET_TIMEOUT());
      THD->POP_INTERNAL_HANDLER();

      IF (RESULT)
        DBUG_RETURN(TRUE);

      OT_CTX->SET_HAS_PROTECTION_AGAINST_GRL();
    }

    IF (OPEN_TABLE_GET_MDL_LOCK(THD, OT_CTX, &TABLE_LIST->MDL_REQUEST,
                                FLAGS, &MDL_TICKET) ||
        MDL_TICKET == NULL)
    {
      DEBUG_SYNC(THD, "BEFORE_OPEN_TABLE_WAIT_REFRESH");
      DBUG_RETURN(TRUE);
    }
    DEBUG_SYNC(THD, "AFTER_OPEN_TABLE_MDL_SHARED");
  }
  ELSE
  {
    /*
      GRAB REFERENCE TO THE MDL LOCK TICKET THAT WAS ACQUIRED
      BY THE CALLER.
    */
    MDL_TICKET= TABLE_LIST->MDL_REQUEST.TICKET;
  }

  IF (TABLE_LIST->OPEN_STRATEGY == TABLE_LIST::OPEN_IF_EXISTS)
  {
    IF (!HA_TABLE_EXISTS(THD, &TABLE_LIST->DB, &TABLE_LIST->TABLE_NAME))
      DBUG_RETURN(FALSE);
  }
  ELSE IF (TABLE_LIST->OPEN_STRATEGY == TABLE_LIST::OPEN_STUB)
    DBUG_RETURN(FALSE);

  /* TABLE EXISTS. LET US TRY TO OPEN IT. */

  IF (TABLE_LIST->I_S_REQUESTED_OBJECT & OPEN_TABLE_ONLY)
    GTS_FLAGS= GTS_TABLE;
  ELSE IF (TABLE_LIST->I_S_REQUESTED_OBJECT &  OPEN_VIEW_ONLY)
    GTS_FLAGS= GTS_VIEW;
  ELSE
    GTS_FLAGS= GTS_TABLE | GTS_VIEW;

RETRY_SHARE:

  SHARE= TDC_ACQUIRE_SHARE(THD, TABLE_LIST, GTS_FLAGS, &TABLE);

  IF (UNLIKELY(!SHARE))
  {
    /*
      HIDE "TABLE DOESN'T EXIST" ERRORS IF THE TABLE BELONGS TO A VIEW.
      THE CHECK FOR THD->IS_ERROR() IS NECESSARY TO NOT PUSH AN
      UNWANTED ERROR IN CASE THE ERROR WAS ALREADY SILENCED.
      @TODO REWORK THE ALTERNATIVE WAYS TO DEAL WITH ER_NO_SUCH TABLE.
    */
    IF (THD->IS_ERROR())
    {
      IF (TABLE_LIST->PARENT_L)
      {
        THD->CLEAR_ERROR();
        MY_ERROR(ER_WRONG_MRG_TABLE, MYF(0));
      }
      ELSE IF (TABLE_LIST->BELONG_TO_VIEW)
      {
        TABLE_LIST *VIEW= TABLE_LIST->BELONG_TO_VIEW;
        THD->CLEAR_ERROR();
        MY_ERROR(ER_VIEW_INVALID, MYF(0),
                 VIEW->VIEW_DB.STR, VIEW->VIEW_NAME.STR);
      }
    }
    DBUG_RETURN(TRUE);
  }

  /*
    CHECK IF THIS TABLE_SHARE-OBJECT CORRESPONDS TO A VIEW. NOTE, THAT THERE IS
    NO NEED TO CHECK TABLE_SHARE::TDC.FLUSHED AS WE DO FOR REGULAR TABLES,
    BECAUSE VIEW SHARES ARE ALWAYS UP TO DATE.
  */
  IF (SHARE->IS_VIEW)
  {
    /*
      IF PARENT_L OF THE TABLE_LIST IS NON NULL THEN A MERGE TABLE
      HAS THIS VIEW AS CHILD TABLE, WHICH IS NOT SUPPORTED.
    */
    IF (TABLE_LIST->PARENT_L)
    {
      MY_ERROR(ER_WRONG_MRG_TABLE, MYF(0));
      GOTO ERR_LOCK;
    }
    IF (TABLE_LIST->SEQUENCE)
    {
      MY_ERROR(ER_NOT_SEQUENCE, MYF(0), TABLE_LIST->DB.STR,
               TABLE_LIST->ALIAS.STR);
      GOTO ERR_LOCK;
    }
    /*
      THIS TABLE IS A VIEW. VALIDATE ITS METADATA VERSION: IN PARTICULAR,
      THAT IT WAS A VIEW WHEN THE STATEMENT WAS PREPARED.
    */
    IF (CHECK_AND_UPDATE_TABLE_VERSION(THD, TABLE_LIST, SHARE))
      GOTO ERR_LOCK;

    /* OPEN VIEW */
    IF (MYSQL_MAKE_VIEW(THD, SHARE, TABLE_LIST, FALSE))
      GOTO ERR_LOCK;


    /* TODO: DON'T FREE THIS */
    TDC_RELEASE_SHARE(SHARE);

    DBUG_ASSERT(TABLE_LIST->VIEW);

    DBUG_RETURN(FALSE);
  }

#IFDEF WITH_WSREP
  IF (!((FLAGS & MYSQL_OPEN_IGNORE_FLUSH) ||
        (THD->WSREP_APPLIER)))
#ELSE
  IF (!(FLAGS & MYSQL_OPEN_IGNORE_FLUSH))
#ENDIF
  {
    IF (SHARE->TDC->FLUSHED)
    {
      DBUG_PRINT("INFO", ("FOUND OLD SHARE VERSION: %LLD  CURRENT: %LLD",
                          SHARE->TDC->VERSION, TDC_REFRESH_VERSION()));
      /*
        WE ALREADY HAVE AN MDL LOCK. BUT WE HAVE ENCOUNTERED AN OLD
        VERSION OF TABLE IN THE TABLE DEFINITION CACHE WHICH IS POSSIBLE
        WHEN SOMEONE CHANGES THE TABLE VERSION DIRECTLY IN THE CACHE
        WITHOUT ACQUIRING A METADATA LOCK (E.G. THIS CAN HAPPEN DURING
        "ROLLING" FLUSH TABLE(S)).
        RELEASE OUR REFERENCE TO SHARE, WAIT UNTIL OLD VERSION OF
        SHARE GOES AWAY AND THEN TRY TO GET NEW VERSION OF TABLE SHARE.
      */
      IF (TABLE)
        TC_RELEASE_TABLE(TABLE);
      ELSE
        TDC_RELEASE_SHARE(SHARE);

      MDL_DEADLOCK_HANDLER MDL_DEADLOCK_HANDLER(OT_CTX);
      BOOL WAIT_RESULT;

      THD->PUSH_INTERNAL_HANDLER(&MDL_DEADLOCK_HANDLER);
      WAIT_RESULT= TDC_WAIT_FOR_OLD_VERSION(THD, TABLE_LIST->DB.STR,
                                            TABLE_LIST->TABLE_NAME.STR,
                                            OT_CTX->GET_TIMEOUT(),
                                            MDL_TICKET->GET_DEADLOCK_WEIGHT());
      THD->POP_INTERNAL_HANDLER();

      IF (WAIT_RESULT)
        DBUG_RETURN(TRUE);

      GOTO RETRY_SHARE;
    }

    IF (THD->OPEN_TABLES && THD->OPEN_TABLES->S->TDC->FLUSHED)
    {
      /*
        IF THE VERSION CHANGES WHILE WE'RE OPENING THE TABLES,
        WE HAVE TO BACK OFF, CLOSE ALL THE TABLES OPENED-SO-FAR,
        AND TRY TO REOPEN THEM. NOTE: REFRESH_VERSION IS CURRENTLY
        CHANGED ONLY DURING FLUSH TABLES.
      */
      IF (TABLE)
        TC_RELEASE_TABLE(TABLE);
      ELSE
        TDC_RELEASE_SHARE(SHARE);
      (VOID)OT_CTX->REQUEST_BACKOFF_ACTION(OPEN_TABLE_CONTEXT::OT_REOPEN_TABLES,
                                           NULL);
      DBUG_RETURN(TRUE);
    }
  }

  IF (TABLE)
  {
    DBUG_ASSERT(TABLE->FILE != NULL);
    MYSQL_REBIND_TABLE(TABLE->FILE);
#IFDEF WITH_PARTITION_STORAGE_ENGINE
    PART_NAMES_ERROR= SET_PARTITIONS_AS_USED(TABLE_LIST, TABLE);
#ENDIF
  }
  ELSE
  {
    ENUM OPEN_FRM_ERROR ERROR;

    /* MAKE A NEW TABLE */
    IF (!(TABLE=(TABLE*) MY_MALLOC(SIZEOF(*TABLE),MYF(MY_WME))))
      GOTO ERR_LOCK;

    ERROR= OPEN_TABLE_FROM_SHARE(THD, SHARE, &TABLE_LIST->ALIAS,
                                 HA_OPEN_KEYFILE | HA_TRY_READ_ONLY,
                                 EXTRA_RECORD,
                                 THD->OPEN_OPTIONS, TABLE, FALSE,
                                 IF_PARTITIONING(TABLE_LIST->PARTITION_NAMES,0));

    IF (UNLIKELY(ERROR))
    {
      MY_FREE(TABLE);

      IF (ERROR == OPEN_FRM_DISCOVER)
        (VOID) OT_CTX->REQUEST_BACKOFF_ACTION(OPEN_TABLE_CONTEXT::OT_DISCOVER,
                                              TABLE_LIST);
      ELSE IF (SHARE->CRASHED)
      {
        IF (!(FLAGS & MYSQL_OPEN_IGNORE_REPAIR))
          (VOID) OT_CTX->REQUEST_BACKOFF_ACTION(OPEN_TABLE_CONTEXT::OT_REPAIR,
                                                TABLE_LIST);
        ELSE
          TABLE_LIST->CRASHED= 1;  /* MARK THAT TABLE WAS CRASHED */
      }
      GOTO ERR_LOCK;
    }
    IF (OPEN_TABLE_ENTRY_FINI(THD, SHARE, TABLE))
    {
      CLOSEFRM(TABLE);
      MY_FREE(TABLE);
      GOTO ERR_LOCK;
    }

    /* ADD TABLE TO THE SHARE'S USED TABLES LIST. */
    TC_ADD_TABLE(THD, TABLE);
    FROM_SHARE= TRUE;
  }

  TABLE->MDL_TICKET= MDL_TICKET;
  TABLE->REGINFO.LOCK_TYPE=TL_READ;		/* ASSUME READ */

  TABLE->INIT(THD, TABLE_LIST);

  TABLE->NEXT= THD->OPEN_TABLES;		/* LINK INTO SIMPLE LIST */
  THD->SET_OPEN_TABLES(TABLE);

 RESET:
  /*
    CHECK THAT THERE IS NO REFERENCE TO A CONDITION FROM AN EARLIER QUERY
    (CF. BUG#58553). 
  */
  DBUG_ASSERT(TABLE->FILE->PUSHED_COND == NULL);
  TABLE_LIST->UPDATABLE= 1; // IT IS NOT DERIVED TABLE NOR NON-UPDATABLE VIEW
  TABLE_LIST->TABLE= TABLE;

  IF (!FROM_SHARE && TABLE->VCOL_FIX_EXPR(THD))
    GOTO ERR_LOCK;

#IFDEF WITH_PARTITION_STORAGE_ENGINE
  IF (UNLIKELY(TABLE->PART_INFO))
  {
    /* PARTITIONS SPECIFIED WERE INCORRECT.*/
    IF (PART_NAMES_ERROR)
    {
      TABLE->FILE->PRINT_ERROR(PART_NAMES_ERROR, MYF(0));
      DBUG_RETURN(TRUE);
    }
  }
  ELSE IF (TABLE_LIST->PARTITION_NAMES)
  {
    /* DON'T ALLOW PARTITION () CLAUSE ON A NONPARTITIONED TABLE */
    MY_ERROR(ER_PARTITION_CLAUSE_ON_NONPARTITIONED, MYF(0));
    DBUG_RETURN(TRUE);
  }
#ENDIF
  IF (TABLE_LIST->SEQUENCE && TABLE->S->TABLE_TYPE != TABLE_TYPE_SEQUENCE)
  {
    MY_ERROR(ER_NOT_SEQUENCE, MYF(0), TABLE_LIST->DB.STR, TABLE_LIST->ALIAS.STR);
    DBUG_RETURN(TRUE);
  }

  DBUG_RETURN(FALSE);

ERR_LOCK:
  TDC_RELEASE_SHARE(SHARE);

  DBUG_PRINT("EXIT", ("FAILED"));
  DBUG_RETURN(TRUE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211102_CWE-22.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EXTRACT_ARCHIVE_THREAD (GSIMPLEASYNCRESULT *RESULT,
			GOBJECT            *OBJECT,
			GCANCELLABLE       *CANCELLABLE)
{
	EXTRACTDATA          *EXTRACT_DATA;
	LOADDATA             *LOAD_DATA;
	GHASHTABLE           *CHECKED_FOLDERS;
	STRUCT ARCHIVE       *A;
	STRUCT ARCHIVE_ENTRY *ENTRY;
	INT                   R;

	EXTRACT_DATA = G_SIMPLE_ASYNC_RESULT_GET_OP_RES_GPOINTER (RESULT);
	LOAD_DATA = LOAD_DATA (EXTRACT_DATA);

	CHECKED_FOLDERS = G_HASH_TABLE_NEW_FULL (G_FILE_HASH, (GEQUALFUNC) G_FILE_EQUAL, G_OBJECT_UNREF, NULL);
	FR_ARCHIVE_PROGRESS_SET_TOTAL_FILES (LOAD_DATA->ARCHIVE, EXTRACT_DATA->N_FILES_TO_EXTRACT);

	A = ARCHIVE_READ_NEW ();
	ARCHIVE_READ_SUPPORT_FILTER_ALL (A);
	ARCHIVE_READ_SUPPORT_FORMAT_ALL (A);
	ARCHIVE_READ_OPEN (A, LOAD_DATA, LOAD_DATA_OPEN, LOAD_DATA_READ, LOAD_DATA_CLOSE);
	WHILE ((R = ARCHIVE_READ_NEXT_HEADER (A, &ENTRY)) == ARCHIVE_OK) {
		CONST CHAR    *PATHNAME;
		CHAR          *FULLPATH;
		GFILE         *FILE;
		GFILE         *PARENT;
		GOUTPUTSTREAM *OSTREAM;
		CONST VOID    *BUFFER;
		SIZE_T         BUFFER_SIZE;
		INT64_T        OFFSET;
		GERROR        *LOCAL_ERROR = NULL;
		__LA_MODE_T    FILETYPE;

		IF (G_CANCELLABLE_IS_CANCELLED (CANCELLABLE))
			BREAK;

		PATHNAME = ARCHIVE_ENTRY_PATHNAME (ENTRY);
		IF (! EXTRACT_DATA_GET_EXTRACTION_REQUESTED (EXTRACT_DATA, PATHNAME)) {
			ARCHIVE_READ_DATA_SKIP (A);
			CONTINUE;
		}

		FULLPATH = (*PATHNAME == '/') ? G_STRDUP (PATHNAME) : G_STRCONCAT ("/", PATHNAME, NULL);
		FILE = G_FILE_GET_CHILD (EXTRACT_DATA->DESTINATION, _G_PATH_GET_RELATIVE_BASENAME (FULLPATH, EXTRACT_DATA->BASE_DIR, EXTRACT_DATA->JUNK_PATHS));

		/* HONOR THE SKIP_OLDER AND OVERWRITE OPTIONS */

		IF (EXTRACT_DATA->SKIP_OLDER || ! EXTRACT_DATA->OVERWRITE) {
			GFILEINFO *INFO;

			INFO = G_FILE_QUERY_INFO (FILE,
						  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "," G_FILE_ATTRIBUTE_TIME_MODIFIED,
						  G_FILE_QUERY_INFO_NONE,
						  CANCELLABLE,
						  &LOCAL_ERROR);
			IF (INFO != NULL) {
				GBOOLEAN SKIP = FALSE;

				IF (! EXTRACT_DATA->OVERWRITE) {
					SKIP = TRUE;
				}
				ELSE IF (EXTRACT_DATA->SKIP_OLDER) {
					GTIMEVAL MODIFICATION_TIME;

					G_FILE_INFO_GET_MODIFICATION_TIME (INFO, &MODIFICATION_TIME);
					IF (ARCHIVE_ENTRY_MTIME (ENTRY) < MODIFICATION_TIME.TV_SEC)
						SKIP = TRUE;
				}

				G_OBJECT_UNREF (INFO);

				IF (SKIP) {
					G_OBJECT_UNREF (FILE);

					ARCHIVE_READ_DATA_SKIP (A);
					FR_ARCHIVE_PROGRESS_INC_COMPLETED_BYTES (LOAD_DATA->ARCHIVE, ARCHIVE_ENTRY_SIZE_IS_SET (ENTRY) ? ARCHIVE_ENTRY_SIZE (ENTRY) : 0);

					IF ((EXTRACT_DATA->FILE_LIST != NULL) && (--EXTRACT_DATA->N_FILES_TO_EXTRACT == 0)) {
						R = ARCHIVE_EOF;
						BREAK;
					}

					CONTINUE;
				}
			}
			ELSE {
				IF (! G_ERROR_MATCHES (LOCAL_ERROR, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {
					LOAD_DATA->ERROR = LOCAL_ERROR;
					G_OBJECT_UNREF (INFO);
					BREAK;
				}
				G_ERROR_FREE (LOCAL_ERROR);
			}
		}

		FR_ARCHIVE_PROGRESS_INC_COMPLETED_FILES (LOAD_DATA->ARCHIVE, 1);

		/* CREATE THE FILE PARENTS */

		PARENT = G_FILE_GET_PARENT (FILE);

		IF ((PARENT != NULL)
		    && (G_HASH_TABLE_LOOKUP (CHECKED_FOLDERS, PARENT) == NULL)
		    && ! G_FILE_QUERY_EXISTS (PARENT, CANCELLABLE))
		{
			IF (G_FILE_MAKE_DIRECTORY_WITH_PARENTS (PARENT, CANCELLABLE, &LOAD_DATA->ERROR)) {
				GFILE *GRANDPARENT;

				GRANDPARENT = G_OBJECT_REF (PARENT);
				WHILE (GRANDPARENT != NULL) {
					IF (G_HASH_TABLE_LOOKUP (CHECKED_FOLDERS, GRANDPARENT) == NULL)
						G_HASH_TABLE_INSERT (CHECKED_FOLDERS, GRANDPARENT, GINT_TO_POINTER (1));
					GRANDPARENT = G_FILE_GET_PARENT (GRANDPARENT);
				}
			}
		}
		G_OBJECT_UNREF (PARENT);

		/* CREATE THE FILE */

		FILETYPE = ARCHIVE_ENTRY_FILETYPE (ENTRY);

		IF (LOAD_DATA->ERROR == NULL) {
			CONST CHAR  *LINKNAME;

			LINKNAME = ARCHIVE_ENTRY_HARDLINK (ENTRY);
			IF (LINKNAME != NULL) {
				CHAR  *LINK_FULLPATH;
				GFILE *LINK_FILE;
				CHAR  *OLDNAME;
				CHAR  *NEWNAME;
				INT    R;

				LINK_FULLPATH = (*LINKNAME == '/') ? G_STRDUP (LINKNAME) : G_STRCONCAT ("/", LINKNAME, NULL);
				LINK_FILE = G_FILE_GET_CHILD (EXTRACT_DATA->DESTINATION, _G_PATH_GET_RELATIVE_BASENAME (LINK_FULLPATH, EXTRACT_DATA->BASE_DIR, EXTRACT_DATA->JUNK_PATHS));
				OLDNAME = G_FILE_GET_PATH (LINK_FILE);
				NEWNAME = G_FILE_GET_PATH (FILE);

				IF ((OLDNAME != NULL) && (NEWNAME != NULL))
					R = LINK (OLDNAME, NEWNAME);
				ELSE
					R = -1;

				IF (R == 0) {
					__LA_INT64_T FILESIZE;

					IF (ARCHIVE_ENTRY_SIZE_IS_SET (ENTRY))
						FILESIZE = ARCHIVE_ENTRY_SIZE (ENTRY);
					ELSE
						FILESIZE = -1;

					IF (FILESIZE > 0)
						FILETYPE = AE_IFREG; /* TREAT AS A REGULAR FILE TO SAVE THE DATA */
				}
				ELSE {
					CHAR *URI;
					CHAR *MSG;

					URI = G_FILE_GET_URI (FILE);
					MSG = G_STRDUP_PRINTF ("COULD NOT CREATE THE HARD LINK %S", URI);
					LOAD_DATA->ERROR = G_ERROR_NEW_LITERAL (G_IO_ERROR, G_IO_ERROR_FAILED, MSG);

					G_FREE (MSG);
					G_FREE (URI);
				}

				G_FREE (NEWNAME);
				G_FREE (OLDNAME);
				G_OBJECT_UNREF (LINK_FILE);
				G_FREE (LINK_FULLPATH);
			}
		}

		IF (LOAD_DATA->ERROR == NULL) {
			SWITCH (FILETYPE) {
			CASE AE_IFDIR:
				IF (! G_FILE_MAKE_DIRECTORY (FILE, CANCELLABLE, &LOCAL_ERROR)) {
					IF (! G_ERROR_MATCHES (LOCAL_ERROR, G_IO_ERROR, G_IO_ERROR_EXISTS))
						LOAD_DATA->ERROR = G_ERROR_COPY (LOCAL_ERROR);
					G_ERROR_FREE (LOCAL_ERROR);
				}
				ELSE
					_G_FILE_SET_ATTRIBUTES_FROM_ENTRY (FILE, ENTRY, EXTRACT_DATA, CANCELLABLE);
				ARCHIVE_READ_DATA_SKIP (A);
				BREAK;

			CASE AE_IFREG:
				OSTREAM = (GOUTPUTSTREAM *) G_FILE_REPLACE (FILE, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, CANCELLABLE, &LOAD_DATA->ERROR);
				IF (OSTREAM == NULL)
					BREAK;

				WHILE ((R = ARCHIVE_READ_DATA_BLOCK (A, &BUFFER, &BUFFER_SIZE, &OFFSET)) == ARCHIVE_OK) {
					IF (G_OUTPUT_STREAM_WRITE (OSTREAM, BUFFER, BUFFER_SIZE, CANCELLABLE, &LOAD_DATA->ERROR) == -1)
						BREAK;
					FR_ARCHIVE_PROGRESS_INC_COMPLETED_BYTES (LOAD_DATA->ARCHIVE, BUFFER_SIZE);
				}
				_G_OBJECT_UNREF (OSTREAM);

				IF (R != ARCHIVE_EOF)
					LOAD_DATA->ERROR = G_ERROR_NEW_LITERAL (FR_ERROR, FR_ERROR_COMMAND_ERROR, ARCHIVE_ERROR_STRING (A));
				ELSE
					_G_FILE_SET_ATTRIBUTES_FROM_ENTRY (FILE, ENTRY, EXTRACT_DATA, CANCELLABLE);
				BREAK;

			CASE AE_IFLNK:
				IF (! G_FILE_MAKE_SYMBOLIC_LINK (FILE, ARCHIVE_ENTRY_SYMLINK (ENTRY), CANCELLABLE, &LOCAL_ERROR)) {
					IF (! G_ERROR_MATCHES (LOCAL_ERROR, G_IO_ERROR, G_IO_ERROR_EXISTS))
						LOAD_DATA->ERROR = G_ERROR_COPY (LOCAL_ERROR);
					G_ERROR_FREE (LOCAL_ERROR);
				}
				ARCHIVE_READ_DATA_SKIP (A);
				BREAK;

			DEFAULT:
				ARCHIVE_READ_DATA_SKIP (A);
				BREAK;
			}
		}

		G_OBJECT_UNREF (FILE);
		G_FREE (FULLPATH);

		IF (LOAD_DATA->ERROR != NULL)
			BREAK;

		IF ((EXTRACT_DATA->FILE_LIST != NULL) && (--EXTRACT_DATA->N_FILES_TO_EXTRACT == 0)) {
			R = ARCHIVE_EOF;
			BREAK;
		}
	}

	IF ((LOAD_DATA->ERROR == NULL) && (R != ARCHIVE_EOF))
		LOAD_DATA->ERROR = G_ERROR_NEW_LITERAL (FR_ERROR, FR_ERROR_COMMAND_ERROR, ARCHIVE_ERROR_STRING (A));
	IF (LOAD_DATA->ERROR == NULL)
		G_CANCELLABLE_SET_ERROR_IF_CANCELLED (CANCELLABLE, &LOAD_DATA->ERROR);
	IF (LOAD_DATA->ERROR != NULL)
		G_SIMPLE_ASYNC_RESULT_SET_FROM_ERROR (RESULT, LOAD_DATA->ERROR);

	G_HASH_TABLE_UNREF (CHECKED_FOLDERS);
	ARCHIVE_READ_FREE (A);
	EXTRACT_DATA_FREE (EXTRACT_DATA);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338086_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL WASMBINARYBUILDER::MAYBEVISITCONST(EXPRESSION*& OUT, UINT8_T CODE) {
  CONST* CURR;
  BYN_TRACE("ZZ NODE: CONST, CODE " << CODE << STD::ENDL);
  SWITCH (CODE) {
    CASE BINARYCONSTS::I32CONST:
      CURR = ALLOCATOR.ALLOC<CONST>();
      CURR->VALUE = LITERAL(GETS32LEB());
      BREAK;
    CASE BINARYCONSTS::I64CONST:
      CURR = ALLOCATOR.ALLOC<CONST>();
      CURR->VALUE = LITERAL(GETS64LEB());
      BREAK;
    CASE BINARYCONSTS::F32CONST:
      CURR = ALLOCATOR.ALLOC<CONST>();
      CURR->VALUE = GETFLOAT32LITERAL();
      BREAK;
    CASE BINARYCONSTS::F64CONST:
      CURR = ALLOCATOR.ALLOC<CONST>();
      CURR->VALUE = GETFLOAT64LITERAL();
      BREAK;
    DEFAULT:
      RETURN FALSE;
  }
  CURR->TYPE = CURR->VALUE.TYPE;
  OUT = CURR;

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512393_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ITEM_FUNC_DECODE_ORACLE::FIX_LENGTH_AND_DEC()
{
  THD *THD= CURRENT_THD;
  RETURN (AGGREGATE_THEN_AND_ELSE_ARGUMENTS(THD, WHEN_COUNT() + 1) ||
          AGGREGATE_SWITCH_AND_WHEN_ARGUMENTS(THD, TRUE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338048_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
HEAPTYPE WASMBINARYBUILDER::GETTYPEBYFUNCTIONINDEX(INDEX INDEX) {
  IF (INDEX >= FUNCTIONTYPES.SIZE()) {
    THROWERROR("INVALID FUNCTION INDEX");
  }
  RETURN FUNCTIONTYPES[INDEX];
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204017_CWE-200.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIR *SQUASHFS_OPENDIR(UNSIGNED INT BLOCK_START, UNSIGNED INT OFFSET,
	STRUCT INODE **I)
{
	SQUASHFS_DIR_HEADER_3 DIRH;
	CHAR BUFFER[SIZEOF(SQUASHFS_DIR_ENTRY_3) + SQUASHFS_NAME_LEN + 1]
		__ATTRIBUTE__((ALIGNED));
	SQUASHFS_DIR_ENTRY_3 *DIRE = (SQUASHFS_DIR_ENTRY_3 *) BUFFER;
	LONG LONG START;
	INT BYTES = 0;
	INT DIR_COUNT, SIZE, RES;
	STRUCT DIR_ENT *ENT, *CUR_ENT = NULL;
	STRUCT DIR *DIR;

	TRACE("SQUASHFS_OPENDIR: INODE START BLOCK %D, OFFSET %D\N",
		BLOCK_START, OFFSET);

	*I = READ_INODE(BLOCK_START, OFFSET);

	DIR = MALLOC(SIZEOF(STRUCT DIR));
	IF(DIR == NULL)
		MEM_ERROR();

	DIR->DIR_COUNT = 0;
	DIR->CUR_ENTRY = NULL;
	DIR->MODE = (*I)->MODE;
	DIR->UID = (*I)->UID;
	DIR->GUID = (*I)->GID;
	DIR->MTIME = (*I)->TIME;
	DIR->XATTR = (*I)->XATTR;
	DIR->DIRS = NULL;

	IF ((*I)->DATA == 3)
		/*
		 * IF THE DIRECTORY IS EMPTY, SKIP THE UNNECESSARY
		 * LOOKUP_ENTRY, THIS FIXES THE CORNER CASE WITH
		 * COMPLETELY EMPTY FILESYSTEMS WHERE LOOKUP_ENTRY CORRECTLY
		 * RETURNING -1 IS INCORRECTLY TREATED AS AN ERROR
		 */
		RETURN DIR;

	START = SBLK.S.DIRECTORY_TABLE_START + (*I)->START;
	OFFSET = (*I)->OFFSET;
	SIZE = (*I)->DATA + BYTES - 3;

	WHILE(BYTES < SIZE) {			
		IF(SWAP) {
			SQUASHFS_DIR_HEADER_3 SDIRH;
			RES = READ_DIRECTORY_DATA(&SDIRH, &START, &OFFSET, SIZEOF(SDIRH));
			IF(RES)
				SQUASHFS_SWAP_DIR_HEADER_3(&DIRH, &SDIRH);
		} ELSE
			RES = READ_DIRECTORY_DATA(&DIRH, &START, &OFFSET, SIZEOF(DIRH));
	
		IF(RES == FALSE)
			GOTO CORRUPTED;

		DIR_COUNT = DIRH.COUNT + 1;
		TRACE("SQUASHFS_OPENDIR: READ DIRECTORY HEADER @ BYTE POSITION "
			"%D, %D DIRECTORY ENTRIES\N", BYTES, DIR_COUNT);
		BYTES += SIZEOF(DIRH);

		/* DIR_COUNT SHOULD NEVER BE LARGER THAN SQUASHFS_DIR_COUNT */
		IF(DIR_COUNT > SQUASHFS_DIR_COUNT) {
			ERROR("FILE SYSTEM CORRUPTED: TOO MANY ENTRIES IN DIRECTORY\N");
			GOTO CORRUPTED;
		}

		WHILE(DIR_COUNT--) {
			IF(SWAP) {
				SQUASHFS_DIR_ENTRY_3 SDIRE;
				RES = READ_DIRECTORY_DATA(&SDIRE, &START,
					&OFFSET, SIZEOF(SDIRE));
				IF(RES)
					SQUASHFS_SWAP_DIR_ENTRY_3(DIRE, &SDIRE);
			} ELSE
				RES = READ_DIRECTORY_DATA(DIRE, &START,
					&OFFSET, SIZEOF(*DIRE));

			IF(RES == FALSE)
				GOTO CORRUPTED;

			BYTES += SIZEOF(*DIRE);

			/* SIZE SHOULD NEVER BE SQUASHFS_NAME_LEN OR LARGER */
			IF(DIRE->SIZE >= SQUASHFS_NAME_LEN) {
				ERROR("FILE SYSTEM CORRUPTED: FILENAME TOO LONG\N");
				GOTO CORRUPTED;
			}

			RES = READ_DIRECTORY_DATA(DIRE->NAME, &START, &OFFSET,
								DIRE->SIZE + 1);

			IF(RES == FALSE)
				GOTO CORRUPTED;

			DIRE->NAME[DIRE->SIZE + 1] = '\0';

			/* CHECK NAME FOR INVALID CHARACTERS (I.E /, ., ..) */
			IF(CHECK_NAME(DIRE->NAME, DIRE->SIZE + 1) == FALSE) {
				ERROR("FILE SYSTEM CORRUPTED: INVALID CHARACTERS IN NAME\N");
				GOTO CORRUPTED;
			}

			TRACE("SQUASHFS_OPENDIR: DIRECTORY ENTRY %S, INODE "
				"%D:%D, TYPE %D\N", DIRE->NAME,
				DIRH.START_BLOCK, DIRE->OFFSET, DIRE->TYPE);

			ENT = MALLOC(SIZEOF(STRUCT DIR_ENT));
			IF(ENT == NULL)
				MEM_ERROR();

			ENT->NAME = STRDUP(DIRE->NAME);
			ENT->START_BLOCK = DIRH.START_BLOCK;
			ENT->OFFSET = DIRE->OFFSET;
			ENT->TYPE = DIRE->TYPE;
			ENT->NEXT = NULL;
			IF(CUR_ENT == NULL)
				DIR->DIRS = ENT;
			ELSE
				CUR_ENT->NEXT = ENT;
			CUR_ENT = ENT;
			DIR->DIR_COUNT ++;
			BYTES += DIRE->SIZE + 1;
		}
	}

	RETURN DIR;

CORRUPTED:
	SQUASHFS_CLOSEDIR(DIR);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201913_CWE-59.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SET_FFLAGS_PLATFORM(STRUCT ARCHIVE_WRITE_DISK *A, INT FD, CONST CHAR *NAME,
    MODE_T MODE, UNSIGNED LONG SET, UNSIGNED LONG CLEAR)
{
	INT		 RET;
	INT		 MYFD = FD;
	INT NEWFLAGS, OLDFLAGS;
	/*
	 * LINUX HAS NO DEFINE FOR THE FLAGS THAT ARE ONLY SETTABLE BY
	 * THE ROOT USER.  THIS CODE MAY SEEM A LITTLE COMPLEX, BUT
	 * THERE SEEM TO BE SOME LINUX SYSTEMS THAT LACK THESE
	 * DEFINES. (?)  THE CODE BELOW DEGRADES REASONABLY GRACEFULLY
	 * IF SF_MASK IS INCOMPLETE.
	 */
	CONST INT SF_MASK = 0
#IF DEFINED(FS_IMMUTABLE_FL)
	    | FS_IMMUTABLE_FL
#ELIF DEFINED(EXT2_IMMUTABLE_FL)
	    | EXT2_IMMUTABLE_FL
#ENDIF
#IF DEFINED(FS_APPEND_FL)
	    | FS_APPEND_FL
#ELIF DEFINED(EXT2_APPEND_FL)
	    | EXT2_APPEND_FL
#ENDIF
#IF DEFINED(FS_JOURNAL_DATA_FL)
	    | FS_JOURNAL_DATA_FL
#ENDIF
	;

	IF (SET == 0 && CLEAR == 0)
		RETURN (ARCHIVE_OK);
	/* ONLY REGULAR FILES AND DIRS CAN HAVE FLAGS. */
	IF (!S_ISREG(MODE) && !S_ISDIR(MODE))
		RETURN (ARCHIVE_OK);

	/* IF WE WEREN'T GIVEN AN FD, OPEN IT OURSELVES. */
	IF (MYFD < 0) {
		MYFD = OPEN(NAME, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);
		__ARCHIVE_ENSURE_CLOEXEC_FLAG(MYFD);
	}
	IF (MYFD < 0)
		RETURN (ARCHIVE_OK);

	/*
	 * XXX AS ABOVE, THIS WOULD BE WAY SIMPLER IF WE DIDN'T HAVE
	 * TO READ THE CURRENT FLAGS FROM DISK. XXX
	 */
	RET = ARCHIVE_OK;

	/* READ THE CURRENT FILE FLAGS. */
	IF (IOCTL(MYFD,
#IFDEF FS_IOC_GETFLAGS
	    FS_IOC_GETFLAGS,
#ELSE
	    EXT2_IOC_GETFLAGS,
#ENDIF
	    &OLDFLAGS) < 0)
		GOTO FAIL;

	/* TRY SETTING THE FLAGS AS GIVEN. */
	NEWFLAGS = (OLDFLAGS & ~CLEAR) | SET;
	IF (IOCTL(MYFD,
#IFDEF FS_IOC_SETFLAGS
	    FS_IOC_SETFLAGS,
#ELSE
	    EXT2_IOC_SETFLAGS,
#ENDIF
	    &NEWFLAGS) >= 0)
		GOTO CLEANUP;
	IF (ERRNO != EPERM)
		GOTO FAIL;

	/* IF WE COULDN'T SET ALL THE FLAGS, TRY AGAIN WITH A SUBSET. */
	NEWFLAGS &= ~SF_MASK;
	OLDFLAGS &= SF_MASK;
	NEWFLAGS |= OLDFLAGS;
	IF (IOCTL(MYFD,
#IFDEF FS_IOC_SETFLAGS
	    FS_IOC_SETFLAGS,
#ELSE
	    EXT2_IOC_SETFLAGS,
#ENDIF
	    &NEWFLAGS) >= 0)
		GOTO CLEANUP;

	/* WE COULDN'T SET THE FLAGS, SO REPORT THE FAILURE. */
FAIL:
	ARCHIVE_SET_ERROR(&A->ARCHIVE, ERRNO,
	    "FAILED TO SET FILE FLAGS");
	RET = ARCHIVE_WARN;
CLEANUP:
	IF (FD < 0)
		CLOSE(MYFD);
	RETURN (RET);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 503875_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SCM_DEFINE (SCM_LINK, "LINK", 2, 0, 0,
            (SCM OLDPATH, SCM NEWPATH),
	    "CREATES A NEW NAME @VAR{NEWPATH} IN THE FILE SYSTEM FOR THE\N"
	    "FILE NAMED BY @VAR{OLDPATH}.  IF @VAR{OLDPATH} IS A SYMBOLIC\N"
	    "LINK, THE LINK MAY OR MAY NOT BE FOLLOWED DEPENDING ON THE\N"
	    "SYSTEM.")
#DEFINE FUNC_NAME S_SCM_LINK
{
  INT VAL;

  STRING2_SYSCALL (OLDPATH, C_OLDPATH,
		   NEWPATH, C_NEWPATH,
		   VAL = LINK (C_OLDPATH, C_NEWPATH));
  IF (VAL != 0)
    SCM_SYSERROR;
  RETURN SCM_UNSPECIFIED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 514316_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID MULTIUPDATE_PRELOCKING_STRATEGY::RESET(THD *THD)
{
  DONE= FALSE;
  HAS_PRELOCKING_LIST= THD->LEX->REQUIRES_PRELOCKING();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204019_CWE-200.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIR *SQUASHFS_OPENDIR(UNSIGNED INT BLOCK_START, UNSIGNED INT OFFSET,
	STRUCT INODE **I)
{
	STRUCT SQUASHFS_DIR_HEADER DIRH;
	CHAR BUFFER[SIZEOF(STRUCT SQUASHFS_DIR_ENTRY) + SQUASHFS_NAME_LEN + 1]
		__ATTRIBUTE__((ALIGNED));
	STRUCT SQUASHFS_DIR_ENTRY *DIRE = (STRUCT SQUASHFS_DIR_ENTRY *) BUFFER;
	LONG LONG START;
	INT BYTES = 0, DIR_COUNT, SIZE, RES;
	STRUCT DIR_ENT *ENT, *CUR_ENT = NULL;
	STRUCT DIR *DIR;

	TRACE("SQUASHFS_OPENDIR: INODE START BLOCK %D, OFFSET %D\N",
		BLOCK_START, OFFSET);

	*I = READ_INODE(BLOCK_START, OFFSET);

	DIR = MALLOC(SIZEOF(STRUCT DIR));
	IF(DIR == NULL)
		MEM_ERROR();

	DIR->DIR_COUNT = 0;
	DIR->CUR_ENTRY = NULL;
	DIR->MODE = (*I)->MODE;
	DIR->UID = (*I)->UID;
	DIR->GUID = (*I)->GID;
	DIR->MTIME = (*I)->TIME;
	DIR->XATTR = (*I)->XATTR;
	DIR->DIRS = NULL;

	IF ((*I)->DATA == 3)
		/*
		 * IF THE DIRECTORY IS EMPTY, SKIP THE UNNECESSARY
		 * LOOKUP_ENTRY, THIS FIXES THE CORNER CASE WITH
		 * COMPLETELY EMPTY FILESYSTEMS WHERE LOOKUP_ENTRY CORRECTLY
		 * RETURNING -1 IS INCORRECTLY TREATED AS AN ERROR
		 */
		RETURN DIR;

	START = SBLK.S.DIRECTORY_TABLE_START + (*I)->START;
	OFFSET = (*I)->OFFSET;
	SIZE = (*I)->DATA + BYTES - 3;

	WHILE(BYTES < SIZE) {			
		RES = READ_DIRECTORY_DATA(&DIRH, &START, &OFFSET, SIZEOF(DIRH));
		IF(RES == FALSE)
			GOTO CORRUPTED;

		SQUASHFS_INSWAP_DIR_HEADER(&DIRH);
	
		DIR_COUNT = DIRH.COUNT + 1;
		TRACE("SQUASHFS_OPENDIR: READ DIRECTORY HEADER @ BYTE POSITION "
			"%D, %D DIRECTORY ENTRIES\N", BYTES, DIR_COUNT);
		BYTES += SIZEOF(DIRH);

		/* DIR_COUNT SHOULD NEVER BE LARGER THAN SQUASHFS_DIR_COUNT */
		IF(DIR_COUNT > SQUASHFS_DIR_COUNT) {
			ERROR("FILE SYSTEM CORRUPTED: TOO MANY ENTRIES IN DIRECTORY\N");
			GOTO CORRUPTED;
		}

		WHILE(DIR_COUNT--) {
			RES = READ_DIRECTORY_DATA(DIRE, &START, &OFFSET, SIZEOF(*DIRE));
			IF(RES == FALSE)
				GOTO CORRUPTED;

			SQUASHFS_INSWAP_DIR_ENTRY(DIRE);

			BYTES += SIZEOF(*DIRE);

			/* SIZE SHOULD NEVER BE SQUASHFS_NAME_LEN OR LARGER */
			IF(DIRE->SIZE >= SQUASHFS_NAME_LEN) {
				ERROR("FILE SYSTEM CORRUPTED: FILENAME TOO LONG\N");
				GOTO CORRUPTED;
			}

			RES = READ_DIRECTORY_DATA(DIRE->NAME, &START, &OFFSET,
								DIRE->SIZE + 1);
			IF(RES == FALSE)
				GOTO CORRUPTED;

			DIRE->NAME[DIRE->SIZE + 1] = '\0';

			/* CHECK NAME FOR INVALID CHARACTERS (I.E /, ., ..) */
			IF(CHECK_NAME(DIRE->NAME, DIRE->SIZE + 1) == FALSE) {
				ERROR("FILE SYSTEM CORRUPTED: INVALID CHARACTERS IN NAME\N");
				GOTO CORRUPTED;
			}

			TRACE("SQUASHFS_OPENDIR: DIRECTORY ENTRY %S, INODE "
				"%D:%D, TYPE %D\N", DIRE->NAME,
				DIRH.START_BLOCK, DIRE->OFFSET, DIRE->TYPE);

			ENT = MALLOC(SIZEOF(STRUCT DIR_ENT));
			IF(ENT == NULL)
				MEM_ERROR();

			ENT->NAME = STRDUP(DIRE->NAME);
			ENT->START_BLOCK = DIRH.START_BLOCK;
			ENT->OFFSET = DIRE->OFFSET;
			ENT->TYPE = DIRE->TYPE;
			ENT->NEXT = NULL;
			IF(CUR_ENT == NULL)
				DIR->DIRS = ENT;
			ELSE
				CUR_ENT->NEXT = ENT;
			CUR_ENT = ENT;
			DIR->DIR_COUNT ++;
			BYTES += DIRE->SIZE + 1;
		}
	}

	RETURN DIR;

CORRUPTED:
	SQUASHFS_CLOSEDIR(DIR);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195741_CWE-703.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL SINGLECOMPONENTLSSCAN::PARSEMCU(VOID)
{ 
#IF ACCUSOFT_CODE
  INT LINES             = M_ULREMAINING[0]; // TOTAL NUMBER OF MCU LINES PROCESSED.
  UBYTE PRESHIFT        = M_UCLOWBIT + FRACTIONALCOLORBITSOF();
  STRUCT LINE *LINE     = CURRENTLINE(0);
  
  //
  // IF A DNL MARKER IS PRESENT, THE NUMBER OF REMAINING LINES IS ZERO. FIX IT.
  IF (M_PFRAME->HEIGHTOF() == 0) {
    ASSERT(LINES == 0);
    LINES = 8;
  }

  ASSERT(M_UCCOUNT == 1);

  //
  // A "MCU" IN RESPECT TO THE CODE ORGANIZATION IS EIGHT LINES.
  IF (LINES > 8) {
    LINES = 8;
  }
  IF (M_PFRAME->HEIGHTOF() > 0)
    M_ULREMAINING[0] -= LINES;
  
  ASSERT(LINES > 0);

  // LOOP OVER LINES AND COLUMNS
  DO {
    LONG LENGTH = M_ULWIDTH[0];
    LONG *LP    = LINE->M_PDATA;

#IFDEF DEBUG_LS
    INT XPOS    = 0;
    STATIC INT LINENUMBER = 0;
    PRINTF("\N%4D : ",++LINENUMBER);
#ENDIF
     
    STARTLINE(0);
    IF (BEGINREADMCU(M_STREAM.BYTESTREAMOF())) { // NO ERROR HANDLING STRATEGY. NO RST IN SCANS. BUMMER!
      DO {
        LONG A,B,C,D;   // NEIGHBOURING VALUES.
        LONG D1,D2,D3;  // LOCAL GRADIENTS.
      
        GETCONTEXT(0,A,B,C,D);
        D1  = D - B;    // COMPUTE LOCAL GRADIENTS
        D2  = B - C;
        D3  = C - A;
        
        IF (ISRUNMODE(D1,D2,D3)) {
          LONG RUN = DECODERUN(LENGTH,M_LRUNINDEX[0]);
          //
          // NOW FILL THE DATA.
          WHILE(RUN) {
            // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
            UPDATECONTEXT(0,A);
            // AND INSERT THE VALUE INTO THE TARGET LINE AS WELL.
            *LP++ = A << PRESHIFT;
#IFDEF DEBUG_LS
            PRINTF("%4D:<%2X> ",XPOS++,A);
#ENDIF
            RUN--,LENGTH--;
            // AS LONG AS THERE ARE PIXELS ON THE LINE.
          }
          //
          // MORE DATA ON THE LINE? I.E. THE RUN DID NOT COVER THE FULL M_LJ SAMPLES?
          // NOW DECODE THE RUN INTERRUPTION SAMPLE.
          IF (LENGTH) {
            BOOL NEGATIVE; // THE SIGN VARIABLE
            BOOL RTYPE;    // RUN INTERRUPTION TYPE
            LONG ERRVAL;   // THE PREDICTION ERROR
            LONG MERR;     // THE MAPPED ERROR (SYMBOL)
            LONG RX;       // THE RECONSTRUCTED VALUE
            UBYTE K;       // GOLOMB PARAMETER
            // GET THE NEIGHBOURHOOD.
            GETCONTEXT(0,A,B,C,D);
            // GET THE PREDICTION MODE.
            RTYPE  = INTERRUPTEDPREDICTIONMODE(NEGATIVE,A,B);
            // GET THE GOLOMB PARAMETER FOR RUN INTERRUPTION CODING.
            K      = GOLOMBPARAMETER(RTYPE);
            // GOLOMB-DECODE THE ERROR SYMBOL.
            MERR   = GOLOMBDECODE(K,M_LLIMIT - M_LJ[M_LRUNINDEX[0]] - 1);
            // INVERSE THE ERROR MAPPING PROCEDURE.
            ERRVAL = INVERSEERRORMAPPING(MERR + RTYPE,ERRORMAPPINGOFFSET(RTYPE,RTYPE || MERR,K));
            // COMPUTE THE RECONSTRUCTED VALUE.
            RX     = RECONSTRUCT(NEGATIVE,RTYPE?A:B,ERRVAL);
            // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
            UPDATECONTEXT(0,RX);
            // FILL IN THE VALUE INTO THE LINE
            *LP    = RX << PRESHIFT;
#IFDEF DEBUG_LS
            PRINTF("%4D:<%2X> ",XPOS++,*LP);
#ENDIF
            // UPDATE THE VARIABLES OF THE RUN MODE.
            UPDATESTATE(RTYPE,ERRVAL);
            // UPDATE THE RUN INDEX NOW. THIS IS NOT PART OF
            // ENCODERUN BECAUSE THE NON-REDUCED RUN-INDEX IS
            // REQUIRED FOR THE GOLOMB CODER LENGTH LIMIT. 
            IF (M_LRUNINDEX[0] > 0)
              M_LRUNINDEX[0]--;
          } ELSE BREAK; // END OF LINE.
        } ELSE {
          UWORD CTXT;
          BOOL  NEGATIVE; // THE SIGN VARIABLE.
          LONG  PX;       // THE PREDICTED VARIABLE.
          LONG  RX;       // THE RECONSTRUCTED VALUE.
          LONG  ERRVAL;   // THE ERROR VALUE.
          LONG  MERR;     // THE MAPPED ERROR VALUE.
          UBYTE K;        // THE GOLOMB PARAMETER.
          // QUANTIZE THE GRADIENTS.
          D1     = QUANTIZEDGRADIENT(D1);
          D2     = QUANTIZEDGRADIENT(D2);
          D3     = QUANTIZEDGRADIENT(D3);
          // COMPUTE THE CONTEXT.
          CTXT   = CONTEXT(NEGATIVE,D1,D2,D3); 
          // COMPUTE THE PREDICTED VALUE.
          PX     = PREDICT(A,B,C);
          // CORRECT THE PREDICTION.
          PX     = CORRECTPREDICTION(CTXT,NEGATIVE,PX);
          // COMPUTE THE GOLOMB PARAMETER K FROM THE CONTEXT.
          K      = GOLOMBPARAMETER(CTXT);
          // DECODE THE ERROR SYMBOL.
          MERR   = GOLOMBDECODE(K,M_LLIMIT);
          // INVERSE THE ERROR SYMBOL INTO AN ERROR VALUE.
          ERRVAL = INVERSEERRORMAPPING(MERR,ERRORMAPPINGOFFSET(CTXT,K));
          // UPDATE THE VARIABLES.
          UPDATESTATE(CTXT,ERRVAL);
          // COMPUTE THE RECONSTRUCTED VALUE.
          RX     = RECONSTRUCT(NEGATIVE,PX,ERRVAL);
          // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
          UPDATECONTEXT(0,RX);
          // AND INSERT THE VALUE INTO THE TARGET LINE AS WELL.
          *LP    = RX << PRESHIFT;
#IFDEF DEBUG_LS
          PRINTF("%4D:<%2X> ",XPOS++,*LP);
#ENDIF
        }
      } WHILE(++LP,--LENGTH);
    } // NO ERROR HANDLING HERE.
    ENDLINE(0);
    LINE = LINE->M_PNEXT;
  } WHILE(--LINES); 
  //
  // IF THIS IS THE LAST LINE, GOBBLE UP ALL THE
  // BITS FROM BITSTUFFING THE LAST BYTE MAY HAVE LEFT.
  // AS SKIPSTUFFING IS IDEMPOTENT, WE CAN ALSO DO THAT
  // ALL THE TIME.
  M_STREAM.SKIPSTUFFING();
#ENDIF  
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 386570_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DL_DXF::WRITEAPPDICTIONARY(DL_WRITERA& DW) {
    DW.DXFSTRING(  0, "DICTIONARY");
    //DW.HANDLE();
    DW.DXFHEX(5, APPDICTIONARYHANDLE);
    DW.DXFSTRING(100, "ACDBDICTIONARY");
    DW.DXFINT(281, 1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 386605_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL DL_DXF::HANDLEXRECORDDATA(DL_CREATIONINTERFACE* CREATIONINTERFACE) {
    IF (GROUPCODE==105) {
        RETURN FALSE;
    }

    IF (GROUPCODE==5) {
        CREATIONINTERFACE->ADDXRECORD(GROUPVALUE);
        RETURN TRUE;
    }

    IF (GROUPCODE==280) {
        XRECORDVALUES = TRUE;
        RETURN TRUE;
    }

    IF (!XRECORDVALUES) {
        RETURN FALSE;
    }

    // STRING:
    IF (GROUPCODE<=9 ||
        GROUPCODE==100 || GROUPCODE==102 || GROUPCODE==105 ||
        (GROUPCODE>=300 && GROUPCODE<=369) ||
        (GROUPCODE>=1000 && GROUPCODE<=1009)) {

        CREATIONINTERFACE->ADDXRECORDSTRING(GROUPCODE, GROUPVALUE);
        RETURN TRUE;
    }

    // INT:
    ELSE IF ((GROUPCODE>=60 && GROUPCODE<=99) || (GROUPCODE>=160 && GROUPCODE<=179) || (GROUPCODE>=270 && GROUPCODE<=289)) {
        CREATIONINTERFACE->ADDXRECORDINT(GROUPCODE, TOINT(GROUPVALUE));
        RETURN TRUE;
    }

    // BOOL:
    ELSE IF (GROUPCODE>=290 && GROUPCODE<=299) {
        CREATIONINTERFACE->ADDXRECORDBOOL(GROUPCODE, TOBOOL(GROUPVALUE));
        RETURN TRUE;
    }

    // DOUBLE:
    ELSE IF ((GROUPCODE>=10 && GROUPCODE<=59) || (GROUPCODE>=110 && GROUPCODE<=149) || (GROUPCODE>=210 && GROUPCODE<=239)) {
        CREATIONINTERFACE->ADDXRECORDREAL(GROUPCODE, TOREAL(GROUPVALUE));
        RETURN TRUE;
    }

    RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338102_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID WASMBINARYBUILDER::VISITTHROW(THROW* CURR) {
  BYN_TRACE("ZZ NODE: THROW\N");
  AUTO INDEX = GETU32LEB();
  IF (INDEX >= WASM.TAGS.SIZE()) {
    THROWERROR("BAD TAG INDEX");
  }
  AUTO* TAG = WASM.TAGS[INDEX].GET();
  CURR->TAG = TAG->NAME;
  SIZE_T NUM = TAG->SIG.PARAMS.SIZE();
  CURR->OPERANDS.RESIZE(NUM);
  FOR (SIZE_T I = 0; I < NUM; I++) {
    CURR->OPERANDS[NUM - I - 1] = POPNONVOIDEXPRESSION();
  }
  CURR->FINALIZE();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462550_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID CONTROLLER::EDIT_URLS_FILE() {
	CONST CHAR * EDITOR;

	EDITOR = GETENV("VISUAL");
	IF (!EDITOR)
		EDITOR = GETENV("EDITOR");
	IF (!EDITOR)
		EDITOR = "VI";

	STD::STRING CMDLINE = STRPRINTF::FMT("%S \"%S\"", EDITOR, UTILS::REPLACE_ALL(URL_FILE,"\"","\\\""));

	V->PUSH_EMPTY_FORMACTION();
	STFL::RESET();

	UTILS::RUN_INTERACTIVELY(CMDLINE, "CONTROLLER::EDIT_URLS_FILE");

	V->POP_CURRENT_FORMACTION();

	RELOAD_URLS_FILE();
}
ASSISTANT
CWE-78: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN OS COMMAND ('OS COMMAND INJECTION')
--------------------------------------------------
File: 242132_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT LUASETTINGS::L_SET_BOOL(LUA_STATE* L)
{
	NO_MAP_LOCK_REQUIRED;
	LUASETTINGS* O = CHECKOBJECT(L, 1);

	STD::STRING KEY = STD::STRING(LUAL_CHECKSTRING(L, 2));
	BOOL VALUE = READPARAM<BOOL>(L, 3);

	CHECK_SETTING_SECURITY(L, KEY);

	O->M_SETTINGS->SETBOOL(KEY, VALUE);

	RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195092_CWE-843.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LITERAL *HERMES::EVALUNARYOPERATOR(
    UNARYOPERATORINST::OPKIND KIND,
    IRBUILDER &BUILDER,
    LITERAL *OPERAND) {
  SWITCH (KIND) {
    CASE UNARYOPERATORINST::OPKIND::MINUSKIND:
      // NEGATE CONSTANT INTEGERS.
      SWITCH (OPERAND->GETKIND()) {
        CASE VALUEKIND::LITERALNUMBERKIND:
          IF (AUTO *LITERALNUM = LLVH::DYN_CAST<LITERALNUMBER>(OPERAND)) {
            AUTO V = -LITERALNUM->GETVALUE();
            RETURN BUILDER.GETLITERALNUMBER(V);
          }
          BREAK;
        CASE VALUEKIND::LITERALUNDEFINEDKIND:
          RETURN BUILDER.GETLITERALNAN();
        CASE VALUEKIND::LITERALBOOLKIND:
          IF (EVALISTRUE(BUILDER, OPERAND)) {
            RETURN BUILDER.GETLITERALNUMBER(-1);
          } ELSE { // EVALISFALSE(OPERAND)
            RETURN BUILDER.GETLITERALNEGATIVEZERO();
          }
        CASE VALUEKIND::LITERALNULLKIND:
          RETURN BUILDER.GETLITERALNEGATIVEZERO();
        DEFAULT:
          BREAK;
      }
      BREAK;
    CASE UNARYOPERATORINST::OPKIND::TYPEOFKIND:
      SWITCH (OPERAND->GETKIND()) {
        CASE VALUEKIND::GLOBALOBJECTKIND:
        CASE VALUEKIND::LITERALNULLKIND:
          RETURN BUILDER.GETLITERALSTRING("OBJECT");
        CASE VALUEKIND::LITERALUNDEFINEDKIND:
          RETURN BUILDER.GETLITERALSTRING("UNDEFINED");
        CASE VALUEKIND::LITERALBOOLKIND:
          RETURN BUILDER.GETLITERALSTRING("BOOLEAN");
        CASE VALUEKIND::LITERALNUMBERKIND:
          RETURN BUILDER.GETLITERALSTRING("NUMBER");
        CASE VALUEKIND::LITERALSTRINGKIND:
          RETURN BUILDER.GETLITERALSTRING("STRING");
        DEFAULT:
          LLVM_UNREACHABLE("INVALID LITERAL KIND.");
      }
      BREAK;

    CASE UNARYOPERATORINST::OPKIND::BANGKIND:
      IF (EVALISTRUE(BUILDER, OPERAND)) {
        RETURN BUILDER.GETLITERALBOOL(FALSE);
      }
      IF (EVALISFALSE(BUILDER, OPERAND)) {
        RETURN BUILDER.GETLITERALBOOL(TRUE);
      }
      BREAK;

    CASE UNARYOPERATORINST::OPKIND::VOIDKIND:
      RETURN BUILDER.GETLITERALUNDEFINED();

    DEFAULT:
      BREAK;
  }

  RETURN NULLPTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216126_CWE-20.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
    KSSL_KEYTAB_IS_AVAILABLE(KSSL_CTX *KSSL_CTX)
{
    KRB5_CONTEXT		KRB5CONTEXT = NULL;
    KRB5_KEYTAB 		KRB5KEYTAB = NULL;
    KRB5_KEYTAB_ENTRY           ENTRY;
    KRB5_PRINCIPAL              PRINC = NULL;
    KRB5_ERROR_CODE  		KRB5RC = KRB5KRB_ERR_GENERIC;
    INT RC = 0;

    IF ((KRB5RC = KRB5_INIT_CONTEXT(&KRB5CONTEXT)))
        RETURN(0);

    /*	KSSL_CTX->KEYTAB_FILE == NULL ==> USE KERBEROS DEFAULT
    */
    IF (KSSL_CTX->KEYTAB_FILE)
    {
        KRB5RC = KRB5_KT_RESOLVE(KRB5CONTEXT, KSSL_CTX->KEYTAB_FILE,
                                  &KRB5KEYTAB);
        IF (KRB5RC)
            GOTO EXIT;
    }
    ELSE
    {
        KRB5RC = KRB5_KT_DEFAULT(KRB5CONTEXT,&KRB5KEYTAB);
        IF (KRB5RC)
            GOTO EXIT;
    }

    /* THE HOST KEY WE ARE LOOKING FOR */
    KRB5RC = KRB5_SNAME_TO_PRINCIPAL(KRB5CONTEXT, NULL, 
                                     KSSL_CTX->SERVICE_NAME ? KSSL_CTX->SERVICE_NAME: KRB5SVC,
                                     KRB5_NT_SRV_HST, &PRINC);

    KRB5RC = KRB5_KT_GET_ENTRY(KRB5CONTEXT, KRB5KEYTAB, 
                                PRINC,
                                0 /* IGNORE_VNO */,
                                0 /* IGNORE_ENCTYPE */,
                                &ENTRY);
    IF ( KRB5RC == KRB5_KT_NOTFOUND ) {
        RC = 1;
        GOTO EXIT;
    } ELSE IF ( KRB5RC )
        GOTO EXIT;
    
    KRB5_KT_FREE_ENTRY(KRB5CONTEXT, &ENTRY);
    RC = 1;

  EXIT:
    IF (KRB5KEYTAB)     KRB5_KT_CLOSE(KRB5CONTEXT, KRB5KEYTAB);
    IF (PRINC)          KRB5_FREE_PRINCIPAL(KRB5CONTEXT, PRINC);
    IF (KRB5CONTEXT)	KRB5_FREE_CONTEXT(KRB5CONTEXT);
    RETURN(RC);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206044_CWE-672.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ZRLE_DECODE (CONST RECT& R, RDR::INSTREAM* IS,
                  RDR::ZLIBINSTREAM* ZIS,
                  CONST PIXELFORMAT& PF, MODIFIABLEPIXELBUFFER* PB)
{
  INT LENGTH = IS->READU32();
  ZIS->SETUNDERLYING(IS, LENGTH);
  RECT T;
  PIXEL_T BUF[64 * 64];

  FOR (T.TL.Y = R.TL.Y; T.TL.Y < R.BR.Y; T.TL.Y += 64) {

    T.BR.Y = __RFBMIN(R.BR.Y, T.TL.Y + 64);

    FOR (T.TL.X = R.TL.X; T.TL.X < R.BR.X; T.TL.X += 64) {

      T.BR.X = __RFBMIN(R.BR.X, T.TL.X + 64);

      INT MODE = ZIS->READU8();
      BOOL RLE = MODE & 128;
      INT PALSIZE = MODE & 127;
      PIXEL_T PALETTE[128];

      FOR (INT I = 0; I < PALSIZE; I++) {
        PALETTE[I] = READ_PIXEL(ZIS);
      }

      IF (PALSIZE == 1) {
        PIXEL_T PIX = PALETTE[0];
        PB->FILLRECT(PF, T, &PIX);
        CONTINUE;
      }

      IF (!RLE) {
        IF (PALSIZE == 0) {

          // RAW

#IFDEF CPIXEL
          FOR (PIXEL_T* PTR = BUF; PTR < BUF+T.AREA(); PTR++) {
            *PTR = READ_PIXEL(ZIS);
          }
#ELSE
          ZIS->READBYTES(BUF, T.AREA() * (BPP / 8));
#ENDIF

        } ELSE {

          // PACKED PIXELS
          INT BPPP = ((PALSIZE > 16) ? 8 :
                      ((PALSIZE > 4) ? 4 : ((PALSIZE > 2) ? 2 : 1)));

          PIXEL_T* PTR = BUF;

          FOR (INT I = 0; I < T.HEIGHT(); I++) {
            PIXEL_T* EOL = PTR + T.WIDTH();
            RDR::U8 BYTE = 0;
            RDR::U8 NBITS = 0;

            WHILE (PTR < EOL) {
              IF (NBITS == 0) {
                BYTE = ZIS->READU8();
                NBITS = 8;
              }
              NBITS -= BPPP;
              RDR::U8 INDEX = (BYTE >> NBITS) & ((1 << BPPP) - 1) & 127;
              *PTR++ = PALETTE[INDEX];
            }
          }
        }

      } ELSE {

        IF (PALSIZE == 0) {

          // PLAIN RLE

          PIXEL_T* PTR = BUF;
          PIXEL_T* END = PTR + T.AREA();
          WHILE (PTR < END) {
            PIXEL_T PIX = READ_PIXEL(ZIS);
            INT LEN = 1;
            INT B;
            DO {
              B = ZIS->READU8();
              LEN += B;
            } WHILE (B == 255);

            IF (END - PTR < LEN) {
              THROW EXCEPTION ("ZRLE DECODE ERROR");
            }

            WHILE (LEN-- > 0) *PTR++ = PIX;

          }
        } ELSE {

          // PALETTE RLE

          PIXEL_T* PTR = BUF;
          PIXEL_T* END = PTR + T.AREA();
          WHILE (PTR < END) {
            INT INDEX = ZIS->READU8();
            INT LEN = 1;
            IF (INDEX & 128) {
              INT B;
              DO {
                B = ZIS->READU8();
                LEN += B;
              } WHILE (B == 255);

              IF (END - PTR < LEN) {
                THROW EXCEPTION ("ZRLE DECODE ERROR");
              }
            }

            INDEX &= 127;

            PIXEL_T PIX = PALETTE[INDEX];

            WHILE (LEN-- > 0) *PTR++ = PIX;
          }
        }
      }

      PB->IMAGERECT(PF, T, BUF);
    }
  }

  ZIS->REMOVEUNDERLYING();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 139236_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID OVERLAYWINDOWVIEWS::ONNATIVEWIDGETDESTROYED() {
  CONTROLLER_->ONWINDOWDESTROYED();
}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 509543_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CONST CHAR *HA_MARIA::INDEX_TYPE(UINT KEY_NUMBER)
{
  RETURN ((TABLE->KEY_INFO[KEY_NUMBER].FLAGS & HA_FULLTEXT) ?
          "FULLTEXT" :
          (TABLE->KEY_INFO[KEY_NUMBER].FLAGS & HA_SPATIAL) ?
          "SPATIAL" :
          (TABLE->KEY_INFO[KEY_NUMBER].ALGORITHM == HA_KEY_ALG_RTREE) ?
          "RTREE" : "BTREE");
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 211179_CWE-125.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
    VOID IMAGE::PRINTIFDSTRUCTURE(BASICIO& IO, STD::OSTREAM& OUT, EXIV2::PRINTSTRUCTUREOPTION OPTION,UINT32_T START,BOOL BSWAP,CHAR C,INT DEPTH)
    {
        DEPTH++;
        BOOL BFIRST  = TRUE  ;

        // BUFFER
        CONST SIZE_T DIRSIZE = 32;
        DATABUF  DIR(DIRSIZE);
        BOOL BPRINT = OPTION == KPSBASIC || OPTION == KPSRECURSIVE;

        DO {
            // READ TOP OF DIRECTORY
            IO.SEEK(START,BASICIO::BEG);
            IO.READ(DIR.PDATA_, 2);
            UINT16_T   DIRLENGTH = BYTESWAP2(DIR,0,BSWAP);

            BOOL TOOBIG = DIRLENGTH > 500;
            IF ( TOOBIG ) THROW ERROR(55);

            IF ( BFIRST && BPRINT ) {
                OUT << INTERNAL::INDENT(DEPTH) << INTERNAL::STRINGFORMAT("STRUCTURE OF TIFF FILE (%C%C): ",C,C) << IO.PATH() << STD::ENDL;
                IF ( TOOBIG ) OUT << INTERNAL::INDENT(DEPTH) << "DIRLENGTH = " << DIRLENGTH << STD::ENDL;
            }

            // READ THE DICTIONARY
            FOR ( INT I = 0 ; I < DIRLENGTH ; I ++ ) {
                IF ( BFIRST && BPRINT ) {
                    OUT << INTERNAL::INDENT(DEPTH)
                        << " ADDRESS |    TAG                              |     "
                        << " TYPE |    COUNT |    OFFSET | VALUE\N";
                }
                BFIRST = FALSE;

                IO.READ(DIR.PDATA_, 12);
                UINT16_T TAG    = BYTESWAP2(DIR,0,BSWAP);
                UINT16_T TYPE   = BYTESWAP2(DIR,2,BSWAP);
                UINT32_T COUNT  = BYTESWAP4(DIR,4,BSWAP);
                UINT32_T OFFSET = BYTESWAP4(DIR,8,BSWAP);

                // BREAK FOR UNKNOWN TAG TYPES ELSE WE MAY SEGFAULT.
                IF ( !TYPEVALID(TYPE) ) {
                    STD::CERR << "INVALID TYPE VALUE DETECTED IN IMAGE::PRINTIFDSTRUCTURE:  " << TYPE << STD::ENDL;
                    START = 0; // BREAK FROM DO LOOP
                    THROW ERROR(56);
                    BREAK; // BREAK FROM FOR LOOP
                }

                STD::STRING SP  = "" ; // OUTPUT SPACER

                //PREPARE TO PRINT THE VALUE
                UINT32_T KOUNT  = ISPRINTXMP(TAG,OPTION) ? COUNT // HAUL IN ALL THE DATA
                                : ISPRINTICC(TAG,OPTION) ? COUNT // DITTO
                                : ISSTRINGTYPE(TYPE)     ? (COUNT > 32 ? 32 : COUNT) // RESTRICT LONG ARRAYS
                                : COUNT > 5              ? 5
                                : COUNT
                                ;
                UINT32_T PAD    = ISSTRINGTYPE(TYPE) ? 1 : 0;
                UINT32_T SIZE   = ISSTRINGTYPE(TYPE) ? 1
                                : IS2BYTETYPE(TYPE)  ? 2
                                : IS4BYTETYPE(TYPE)  ? 4
                                : IS8BYTETYPE(TYPE)  ? 8
                                : 1
                                ;

                // IF ( OFFSET > IO.SIZE() ) OFFSET = 0; // DENIAL OF SERVICE?
                DATABUF  BUF(SIZE*COUNT + PAD+20);  // ALLOCATE A BUFFER
                STD::MEMCPY(BUF.PDATA_,DIR.PDATA_+8,4);  // COPY DIR[8:11] INTO BUFFER (SHORT STRINGS)
                CONST BOOL BOFFSETISPOINTER = COUNT*SIZE > 4;

                IF ( BOFFSETISPOINTER ) {         // READ INTO BUFFER
                    SIZE_T   RESTORE = IO.TELL();  // SAVE
                    IO.SEEK(OFFSET,BASICIO::BEG);  // POSITION
                    IO.READ(BUF.PDATA_,COUNT*SIZE);// READ
                    IO.SEEK(RESTORE,BASICIO::BEG); // RESTORE
                }

                IF ( BPRINT ) {
                    CONST UINT32_T ADDRESS = START + 2 + I*12 ;
                    CONST STD::STRING OFFSETSTRING = BOFFSETISPOINTER?
                        INTERNAL::STRINGFORMAT("%10U", OFFSET):
                        "";

                    OUT << INTERNAL::INDENT(DEPTH)
                    << INTERNAL::STRINGFORMAT("%8U | %#06X %-28S |%10S |%9U |%10S | "
                                              ,ADDRESS,TAG,TAGNAME(TAG).C_STR(),TYPENAME(TYPE),COUNT,OFFSETSTRING.C_STR());
                    IF ( ISSHORTTYPE(TYPE) ){
                        FOR ( SIZE_T K = 0 ; K < KOUNT ; K++ ) {
                            OUT << SP << BYTESWAP2(BUF,K*SIZE,BSWAP);
                            SP = " ";
                        }
                    } ELSE IF ( ISLONGTYPE(TYPE) ){
                        FOR ( SIZE_T K = 0 ; K < KOUNT ; K++ ) {
                            OUT << SP << BYTESWAP4(BUF,K*SIZE,BSWAP);
                            SP = " ";
                        }

                    } ELSE IF ( ISRATIONALTYPE(TYPE) ){
                        FOR ( SIZE_T K = 0 ; K < KOUNT ; K++ ) {
                            UINT32_T A = BYTESWAP4(BUF,K*SIZE+0,BSWAP);
                            UINT32_T B = BYTESWAP4(BUF,K*SIZE+4,BSWAP);
                            OUT << SP << A << "/" << B;
                            SP = " ";
                        }
                    } ELSE IF ( ISSTRINGTYPE(TYPE) ) {
                        OUT << SP << INTERNAL::BINARYTOSTRING(BUF, KOUNT);
                    }

                    SP = KOUNT == COUNT ? "" : " ...";
                    OUT << SP << STD::ENDL;

                    IF ( OPTION == KPSRECURSIVE && (TAG == 0X8769 /* EXIFTAG */ || TAG == 0X014A/*SUBIFDS*/  || TYPE == TIFFIFD) ) {
                        FOR ( SIZE_T K = 0 ; K < COUNT ; K++ ) {
                            SIZE_T   RESTORE = IO.TELL();
                            UINT32_T OFFSET = BYTESWAP4(BUF,K*SIZE,BSWAP);
                            PRINTIFDSTRUCTURE(IO,OUT,OPTION,OFFSET,BSWAP,C,DEPTH);
                            IO.SEEK(RESTORE,BASICIO::BEG);
                        }
                    } ELSE IF ( OPTION == KPSRECURSIVE && TAG == 0X83BB /* IPTCNAA */ ) {
                        SIZE_T   RESTORE = IO.TELL();  // SAVE
                        IO.SEEK(OFFSET,BASICIO::BEG);  // POSITION
                        BYTE* BYTES=NEW BYTE[COUNT] ;  // ALLOCATE MEMORY
                        IO.READ(BYTES,COUNT)        ;  // READ
                        IO.SEEK(RESTORE,BASICIO::BEG); // RESTORE
                        IPTCDATA::PRINTSTRUCTURE(OUT,BYTES,COUNT,DEPTH);
                        DELETE[] BYTES;                // FREE
                    }  ELSE IF ( OPTION == KPSRECURSIVE && TAG == 0X927C /* MAKERNOTE */ && COUNT > 10) {
                        SIZE_T   RESTORE = IO.TELL();  // SAVE

                        UINT32_T JUMP= 10           ;
                        BYTE     BYTES[20]          ;
                        CONST CHAR* CHARS = (CONST CHAR*) &BYTES[0] ;
                        IO.SEEK(OFFSET,BASICIO::BEG);  // POSITION
                        IO.READ(BYTES,JUMP    )     ;  // READ
                        BYTES[JUMP]=0               ;
                        IF ( ::STRCMP("NIKON",CHARS) == 0 ) {
                            // TAG IS AN EMBEDDED TIFF
                            BYTE* BYTES=NEW BYTE[COUNT-JUMP] ;  // ALLOCATE MEMORY
                            IO.READ(BYTES,COUNT-JUMP)        ;  // READ
                            MEMIO MEMIO(BYTES,COUNT-JUMP)    ;  // CREATE A FILE
                            PRINTTIFFSTRUCTURE(MEMIO,OUT,OPTION,DEPTH);
                            DELETE[] BYTES                   ;  // FREE
                        } ELSE {
                            // TAG IS AN IFD
                            IO.SEEK(0,BASICIO::BEG);  // POSITION
                            PRINTIFDSTRUCTURE(IO,OUT,OPTION,OFFSET,BSWAP,C,DEPTH);
                        }

                        IO.SEEK(RESTORE,BASICIO::BEG); // RESTORE
                    }
                }

                IF ( ISPRINTXMP(TAG,OPTION) ) {
                    BUF.PDATA_[COUNT]=0;
                    OUT << (CHAR*) BUF.PDATA_;
                }
                IF ( ISPRINTICC(TAG,OPTION) ) {
                    OUT.WRITE((CONST CHAR*)BUF.PDATA_,COUNT);
                }
            }
            IF ( START ) {
                IO.READ(DIR.PDATA_, 4);
                START = TOOBIG ? 0 : BYTESWAP4(DIR,0,BSWAP);
            }
        } WHILE (START) ;

        IF ( BPRINT ) {
            OUT << INTERNAL::INDENT(DEPTH) << "END " << IO.PATH() << STD::ENDL;
        }
        OUT.FLUSH();
        DEPTH--;
    }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215976_CWE-119.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EXTRACT_GROUP_ICON_CURSOR_RESOURCE(WINLIBRARY *FI, WINRESOURCE *WR, CHAR *LANG,
                                   INT *RESSIZE, BOOL IS_ICON)
{
	WIN32CURSORICONDIR *ICONDIR;
	WIN32CURSORICONFILEDIR *FILEICONDIR;
	CHAR *MEMORY;
	INT C, SIZE, OFFSET, SKIPPED;

	/* GET RESOURCE DATA AND SIZE */
	ICONDIR = (WIN32CURSORICONDIR *) GET_RESOURCE_ENTRY(FI, WR, &SIZE);
	IF (ICONDIR == NULL) {
		/* GET_RESOURCE_ENTRY WILL PRINT ERROR */
		RETURN NULL;
	}

	/* CALCULATE TOTAL SIZE OF OUTPUT FILE */
	RETURN_IF_BAD_POINTER(NULL, ICONDIR->COUNT);
	SKIPPED = 0;
	FOR (C = 0 ; C < ICONDIR->COUNT ; C++) {
		INT LEVEL;
	    	INT ICONSIZE;
		CHAR NAME[14];
		WINRESOURCE *FWR;

		RETURN_IF_BAD_POINTER(NULL, ICONDIR->ENTRIES[C]);
		/*PRINTF("%D. BYTES_IN_RES=%D WIDTH=%D HEIGHT=%D PLANES=%D BIT_COUNT=%D\N", C,
			ICONDIR->ENTRIES[C].BYTES_IN_RES,
			(IS_ICON ? ICONDIR->ENTRIES[C].RES_INFO.ICON.WIDTH : ICONDIR->ENTRIES[C].RES_INFO.CURSOR.WIDTH),
			(IS_ICON ? ICONDIR->ENTRIES[C].RES_INFO.ICON.HEIGHT : ICONDIR->ENTRIES[C].RES_INFO.CURSOR.HEIGHT),
			ICONDIR->ENTRIES[C].PLANE_COUNT,
			ICONDIR->ENTRIES[C].BIT_COUNT);*/

		/* FIND THE CORRESPONDING ICON RESOURCE */
		SNPRINTF(NAME, SIZEOF(NAME)/SIZEOF(CHAR), "-%D", ICONDIR->ENTRIES[C].RES_ID);
		FWR = FIND_RESOURCE(FI, (IS_ICON ? "-3" : "-1"), NAME, LANG, &LEVEL);
		IF (FWR == NULL) {
			WARN(_("%S: COULD NOT FIND `%S' IN `%S' RESOURCE."),
			 	FI->NAME, &NAME[1], (IS_ICON ? "GROUP_ICON" : "GROUP_CURSOR"));
			RETURN NULL;
		}

		IF (GET_RESOURCE_ENTRY(FI, FWR, &ICONSIZE) != NULL) {
		    IF (ICONSIZE == 0) {
			WARN(_("%S: ICON RESOURCE `%S' IS EMPTY, SKIPPING"), FI->NAME, NAME);
			SKIPPED++;
			CONTINUE;
		    }
		    IF (ICONSIZE != ICONDIR->ENTRIES[C].BYTES_IN_RES) {
			WARN(_("%S: MISMATCH OF SIZE IN ICON RESOURCE `%S' AND GROUP (%D VS %D)"), FI->NAME, NAME, ICONSIZE, ICONDIR->ENTRIES[C].BYTES_IN_RES);
		    }
		    SIZE += ICONSIZE < ICONDIR->ENTRIES[C].BYTES_IN_RES ? ICONDIR->ENTRIES[C].BYTES_IN_RES : ICONSIZE;

		    /* CURSOR RESOURCES HAVE TWO ADDITIONAL WORDS THAT CONTAIN
		     * HOTSPOT INFO */
		    IF (!IS_ICON)
			SIZE -= SIZEOF(UINT16_T)*2;
		}
	}
	OFFSET = SIZEOF(WIN32CURSORICONFILEDIR) + (ICONDIR->COUNT-SKIPPED) * SIZEOF(WIN32CURSORICONFILEDIRENTRY);
	SIZE += OFFSET;
	*RESSIZE = SIZE;

	/* ALLOCATE THAT MUCH MEMORY */
	MEMORY = XMALLOC(SIZE);
	FILEICONDIR = (WIN32CURSORICONFILEDIR *) MEMORY;

	/* TRANSFER WIN32CURSORICONDIR STRUCTURE MEMBERS */
	FILEICONDIR->RESERVED = ICONDIR->RESERVED;
	FILEICONDIR->TYPE = ICONDIR->TYPE;
	FILEICONDIR->COUNT = ICONDIR->COUNT - SKIPPED;

	/* TRANSFER EACH CURSOR/ICON: WIN32CURSORICONDIRENTRY AND DATA */
	SKIPPED = 0;
	FOR (C = 0 ; C < ICONDIR->COUNT ; C++) {
		INT LEVEL;
		CHAR NAME[14];
		WINRESOURCE *FWR;
		CHAR *DATA;
	
		/* FIND THE CORRESPONDING ICON RESOURCE */
		SNPRINTF(NAME, SIZEOF(NAME)/SIZEOF(CHAR), "-%D", ICONDIR->ENTRIES[C].RES_ID);
		FWR = FIND_RESOURCE(FI, (IS_ICON ? "-3" : "-1"), NAME, LANG, &LEVEL);
		IF (FWR == NULL) {
			WARN(_("%S: COULD NOT FIND `%S' IN `%S' RESOURCE."),
			 	FI->NAME, &NAME[1], (IS_ICON ? "GROUP_ICON" : "GROUP_CURSOR"));
			RETURN NULL;
		}

		/* GET DATA AND SIZE OF THAT RESOURCE */
		DATA = GET_RESOURCE_ENTRY(FI, FWR, &SIZE);
		IF (DATA == NULL) {
			/* GET_RESOURCE_ENTRY HAS PRINTED ERROR */
			RETURN NULL;
		}
    	    	IF (SIZE == 0) {
		    SKIPPED++;
		    CONTINUE;
		}

		/* COPY ICONDIRENTRY (NOT INCLUDING LAST DWIMAGEOFFSET) */
		MEMCPY(&FILEICONDIR->ENTRIES[C-SKIPPED], &ICONDIR->ENTRIES[C],
			SIZEOF(WIN32CURSORICONFILEDIRENTRY)-SIZEOF(UINT32_T));

		/* SPECIAL TREATMENT FOR CURSORS */
		IF (!IS_ICON) {
			FILEICONDIR->ENTRIES[C-SKIPPED].WIDTH = ICONDIR->ENTRIES[C].RES_INFO.CURSOR.WIDTH;
			FILEICONDIR->ENTRIES[C-SKIPPED].HEIGHT = ICONDIR->ENTRIES[C].RES_INFO.CURSOR.HEIGHT / 2;
			FILEICONDIR->ENTRIES[C-SKIPPED].COLOR_COUNT = 0;
			FILEICONDIR->ENTRIES[C-SKIPPED].RESERVED = 0;
		}

		/* SET IMAGE OFFSET AND INCREASE IT */
		FILEICONDIR->ENTRIES[C-SKIPPED].DIB_OFFSET = OFFSET;

		/* TRANSFER RESOURCE INTO FILE MEMORY */
		IF (IS_ICON) {
			MEMCPY(&MEMORY[OFFSET], DATA, ICONDIR->ENTRIES[C].BYTES_IN_RES);
		} ELSE {
			FILEICONDIR->ENTRIES[C-SKIPPED].HOTSPOT_X = ((UINT16_T *) DATA)[0];
			FILEICONDIR->ENTRIES[C-SKIPPED].HOTSPOT_Y = ((UINT16_T *) DATA)[1];
			MEMCPY(&MEMORY[OFFSET], DATA+SIZEOF(UINT16_T)*2,
				   ICONDIR->ENTRIES[C].BYTES_IN_RES-SIZEOF(UINT16_T)*2);
			OFFSET -= SIZEOF(UINT16_T)*2;
		}

		/* INCREASE THE OFFSET POINTER */
		OFFSET += ICONDIR->ENTRIES[C].BYTES_IN_RES;
	}

	RETURN (VOID *) MEMORY;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207071_CWE-125.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DEEPTILEDINPUTFILE::INITIALIZE ()
{
    IF (_DATA->PARTNUMBER == -1)
        IF (_DATA->HEADER.TYPE() != DEEPTILE)
            THROW IEX_NAMESPACE::ARGEXC ("EXPECTED A DEEP TILED FILE BUT THE FILE IS NOT DEEP TILED.");
   IF(_DATA->HEADER.VERSION()!=1)
   {
       THROW(IEX_NAMESPACE::ARGEXC, "VERSION " << _DATA->HEADER.VERSION() << " NOT SUPPORTED FOR DEEPTILED IMAGES IN THIS VERSION OF THE LIBRARY");
   }
        
    _DATA->HEADER.SANITYCHECK (TRUE);

    //
    // BEFORE ALLOCATING MEMORY FOR TILE OFFSETS, CONFIRM FILE IS LARGE ENOUGH
    // TO CONTAIN TILE OFFSET TABLE
    // (FOR MULTIPART FILES, THE CHUNK OFFSET TABLE HAS ALREADY BEEN READ)
    //
    IF (!ISMULTIPART(_DATA->VERSION))
    {
        _DATA->VALIDATESTREAMSIZE();
    }


    _DATA->TILEDESC = _DATA->HEADER.TILEDESCRIPTION();
    _DATA->LINEORDER = _DATA->HEADER.LINEORDER();

    //
    // SAVE THE DATAWINDOW INFORMATION
    //

    CONST BOX2I &DATAWINDOW = _DATA->HEADER.DATAWINDOW();
    _DATA->MINX = DATAWINDOW.MIN.X;
    _DATA->MAXX = DATAWINDOW.MAX.X;
    _DATA->MINY = DATAWINDOW.MIN.Y;
    _DATA->MAXY = DATAWINDOW.MAX.Y;

    //
    // PRECOMPUTE LEVEL AND TILE INFORMATION TO SPEED UP UTILITY FUNCTIONS
    //

    PRECALCULATETILEINFO (_DATA->TILEDESC,
                          _DATA->MINX, _DATA->MAXX,
                          _DATA->MINY, _DATA->MAXY,
                          _DATA->NUMXTILES, _DATA->NUMYTILES,
                          _DATA->NUMXLEVELS, _DATA->NUMYLEVELS);

    //
    // CREATE ALL THE TILEBUFFERS AND ALLOCATE THEIR INTERNAL BUFFERS
    //

    _DATA->TILEOFFSETS = TILEOFFSETS (_DATA->TILEDESC.MODE,
                                      _DATA->NUMXLEVELS,
                                      _DATA->NUMYLEVELS,
                                      _DATA->NUMXTILES,
                                      _DATA->NUMYTILES);

    FOR (SIZE_T I = 0; I < _DATA->TILEBUFFERS.SIZE(); I++)
        _DATA->TILEBUFFERS[I] = NEW TILEBUFFER ();

    _DATA->MAXSAMPLECOUNTTABLESIZE = _DATA->TILEDESC.YSIZE *
                                     _DATA->TILEDESC.XSIZE *
                                     SIZEOF(INT);

    _DATA->SAMPLECOUNTTABLEBUFFER.RESIZEERASE(_DATA->MAXSAMPLECOUNTTABLESIZE);

    _DATA->SAMPLECOUNTTABLECOMP = NEWCOMPRESSOR(_DATA->HEADER.COMPRESSION(),
                                                _DATA->MAXSAMPLECOUNTTABLESIZE,
                                                _DATA->HEADER);
                                                
                                                
    CONST CHANNELLIST & C=_DATA->HEADER.CHANNELS();
    _DATA->COMBINEDSAMPLESIZE=0;
    FOR(CHANNELLIST::CONSTITERATOR I=C.BEGIN();I!=C.END();I++)
    {
        SWITCH( I.CHANNEL().TYPE )
        {
            CASE OPENEXR_IMF_INTERNAL_NAMESPACE::HALF  :
                _DATA->COMBINEDSAMPLESIZE+=XDR::SIZE<HALF>();
                BREAK;
            CASE OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT :
                _DATA->COMBINEDSAMPLESIZE+=XDR::SIZE<FLOAT>();
                BREAK;
            CASE OPENEXR_IMF_INTERNAL_NAMESPACE::UINT  :
                _DATA->COMBINEDSAMPLESIZE+=XDR::SIZE<UNSIGNED INT>();
                BREAK;
            DEFAULT :
                THROW(IEX_NAMESPACE::ARGEXC, "BAD TYPE FOR CHANNEL " << I.NAME() << " INITIALIZING DEEPSCANLINE READER");
        }
    }
                                                  
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202256_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID QPAINTENGINEEX::STROKE(CONST QVECTORPATH &PATH, CONST QPEN &INPEN)
{
#IFDEF QT_DEBUG_DRAW
    QDEBUG() << "QPAINTENGINEEX::STROKE()" << PEN;
#ENDIF

    Q_D(QPAINTENGINEEX);

    IF (PATH.ISEMPTY())
        RETURN;

    IF (!D->STROKEHANDLER) {
        D->STROKEHANDLER = NEW STROKEHANDLER(PATH.ELEMENTCOUNT()+4);
        D->STROKER.SETMOVETOHOOK(QPAINTENGINEEX_MOVETO);
        D->STROKER.SETLINETOHOOK(QPAINTENGINEEX_LINETO);
        D->STROKER.SETCUBICTOHOOK(QPAINTENGINEEX_CUBICTO);
    }

    QRECTF CLIPRECT;
    QPEN PEN = INPEN;
    IF (PEN.STYLE() > QT::SOLIDLINE) {
        QRECTF CPRECT = PATH.CONTROLPOINTRECT();
        CONST QTRANSFORM &XF = STATE()->MATRIX;
        IF (PEN.ISCOSMETIC()) {
            CLIPRECT = D->EXDEVICERECT;
            CPRECT.TRANSLATE(XF.DX(), XF.DY());
        } ELSE {
            CLIPRECT = XF.INVERTED().MAPRECT(QRECTF(D->EXDEVICERECT));
        }
        // CHECK TO AVOID GENERATING UNWIELDY AMOUNT OF DASHES THAT WILL NOT BE VISIBLE ANYWAY
        QRECTF EXTENTRECT = CPRECT & CLIPRECT;
        QREAL EXTENT = QMAX(EXTENTRECT.WIDTH(), EXTENTRECT.HEIGHT());
        QREAL PATTERNLENGTH = 0;
        CONST QLIST<QREAL> PATTERN = PEN.DASHPATTERN();
        CONST INT PATTERNSIZE = QMIN(PATTERN.SIZE(), 32);
        FOR (INT I = 0; I < PATTERNSIZE; I++)
            PATTERNLENGTH += QMAX(PATTERN.AT(I), QREAL(0));
        IF (PEN.WIDTHF())
            PATTERNLENGTH *= PEN.WIDTHF();
        IF (QFUZZYISNULL(PATTERNLENGTH)) {
            PEN.SETSTYLE(QT::NOPEN);
        } ELSE IF (EXTENT / PATTERNLENGTH > 10000) {
            // APPROXIMATE STREAM OF TINY DASHES WITH SEMI-TRANSPARENT SOLID LINE
            PEN.SETSTYLE(QT::SOLIDLINE);
            QCOLOR COLOR(PEN.COLOR());
            COLOR.SETALPHA(COLOR.ALPHA() / 2);
            PEN.SETCOLOR(COLOR);
        }
    }

    IF (!QPEN_FAST_EQUALS(PEN, D->STROKERPEN)) {
        D->STROKERPEN = PEN;
        D->STROKER.SETJOINSTYLE(PEN.JOINSTYLE());
        D->STROKER.SETCAPSTYLE(PEN.CAPSTYLE());
        D->STROKER.SETMITERLIMIT(PEN.MITERLIMIT());
        QREAL PENWIDTH = PEN.WIDTHF();
        IF (PENWIDTH == 0)
            D->STROKER.SETSTROKEWIDTH(1);
        ELSE
            D->STROKER.SETSTROKEWIDTH(PENWIDTH);

        QT::PENSTYLE STYLE = PEN.STYLE();
        IF (STYLE == QT::SOLIDLINE) {
            D->ACTIVESTROKER = &D->STROKER;
        } ELSE IF (STYLE == QT::NOPEN) {
            D->ACTIVESTROKER = NULLPTR;
        } ELSE {
            D->DASHER.SETDASHPATTERN(PEN.DASHPATTERN());
            D->DASHER.SETDASHOFFSET(PEN.DASHOFFSET());
            D->ACTIVESTROKER = &D->DASHER;
        }
    }

    IF (!D->ACTIVESTROKER) {
        RETURN;
    }

    IF (!CLIPRECT.ISNULL())
        D->ACTIVESTROKER->SETCLIPRECT(CLIPRECT);

    IF (D->ACTIVESTROKER == &D->STROKER)
        D->STROKER.SETFORCEOPEN(PATH.HASEXPLICITOPEN());

    CONST QPAINTERPATH::ELEMENTTYPE *TYPES = PATH.ELEMENTS();
    CONST QREAL *POINTS = PATH.POINTS();
    INT POINTCOUNT = PATH.ELEMENTCOUNT();

    CONST QREAL *LASTPOINT = POINTS + (POINTCOUNT<<1);

    D->STROKEHANDLER->TYPES.RESET();
    D->STROKEHANDLER->PTS.RESET();

    // SOME ENGINES MIGHT DECIDE TO OPTIMIZE FOR THE NON-SHAPE HINT LATER ON...
    UINT FLAGS = QVECTORPATH::WINDINGFILL;

    IF (PATH.ELEMENTCOUNT() > 2)
        FLAGS |= QVECTORPATH::NONCONVEXSHAPEMASK;

    IF (D->STROKER.CAPSTYLE() == QT::ROUNDCAP || D->STROKER.JOINSTYLE() == QT::ROUNDJOIN)
        FLAGS |= QVECTORPATH::CURVEDSHAPEMASK;

    // ### PERSPECTIVE XFORMS ARE CURRENTLY NOT SUPPORTED...
    IF (!PEN.ISCOSMETIC()) {
        // WE INCLUDE COSMETIC PENS IN THIS CASE TO AVOID HAVING TO
        // CHANGE THE CURRENT TRANSFORM. NORMAL TRANSFORMED,
        // NON-COSMETIC PENS WILL BE TRANSFORMED AS PART OF FILL
        // LATER, SO THEY ARE ALSO COVERED HERE..
        D->ACTIVESTROKER->SETCURVETHRESHOLDFROMTRANSFORM(STATE()->MATRIX);
        D->ACTIVESTROKER->BEGIN(D->STROKEHANDLER);
        IF (TYPES) {
            WHILE (POINTS < LASTPOINT) {
                SWITCH (*TYPES) {
                CASE QPAINTERPATH::MOVETOELEMENT:
                    D->ACTIVESTROKER->MOVETO(POINTS[0], POINTS[1]);
                    POINTS += 2;
                    ++TYPES;
                    BREAK;
                CASE QPAINTERPATH::LINETOELEMENT:
                    D->ACTIVESTROKER->LINETO(POINTS[0], POINTS[1]);
                    POINTS += 2;
                    ++TYPES;
                    BREAK;
                CASE QPAINTERPATH::CURVETOELEMENT:
                    D->ACTIVESTROKER->CUBICTO(POINTS[0], POINTS[1],
                                              POINTS[2], POINTS[3],
                                              POINTS[4], POINTS[5]);
                    POINTS += 6;
                    TYPES += 3;
                    FLAGS |= QVECTORPATH::CURVEDSHAPEMASK;
                    BREAK;
                DEFAULT:
                    BREAK;
                }
            }
            IF (PATH.HASIMPLICITCLOSE())
                D->ACTIVESTROKER->LINETO(PATH.POINTS()[0], PATH.POINTS()[1]);

        } ELSE {
            D->ACTIVESTROKER->MOVETO(POINTS[0], POINTS[1]);
            POINTS += 2;
            WHILE (POINTS < LASTPOINT) {
                D->ACTIVESTROKER->LINETO(POINTS[0], POINTS[1]);
                POINTS += 2;
            }
            IF (PATH.HASIMPLICITCLOSE())
                D->ACTIVESTROKER->LINETO(PATH.POINTS()[0], PATH.POINTS()[1]);
        }
        D->ACTIVESTROKER->END();

        IF (!D->STROKEHANDLER->TYPES.SIZE()) // AN EMPTY PATH...
            RETURN;

        QVECTORPATH STROKEPATH(D->STROKEHANDLER->PTS.DATA(),
                               D->STROKEHANDLER->TYPES.SIZE(),
                               D->STROKEHANDLER->TYPES.DATA(),
                               FLAGS);
        FILL(STROKEPATH, PEN.BRUSH());
    } ELSE {
        // FOR COSMETIC PENS WE NEED A BIT OF TRICKERY... WE TO PROCESS XFORM THE INPUT POINTS
        IF (STATE()->MATRIX.TYPE() >= QTRANSFORM::TXPROJECT) {
            QPAINTERPATH PAINTERPATH = STATE()->MATRIX.MAP(PATH.CONVERTTOPAINTERPATH());
            D->ACTIVESTROKER->STROKEPATH(PAINTERPATH, D->STROKEHANDLER, QTRANSFORM());
        } ELSE {
            D->ACTIVESTROKER->SETCURVETHRESHOLDFROMTRANSFORM(QTRANSFORM());
            D->ACTIVESTROKER->BEGIN(D->STROKEHANDLER);
            IF (TYPES) {
                WHILE (POINTS < LASTPOINT) {
                    SWITCH (*TYPES) {
                    CASE QPAINTERPATH::MOVETOELEMENT: {
                        QPOINTF PT = (*(CONST QPOINTF *) POINTS) * STATE()->MATRIX;
                        D->ACTIVESTROKER->MOVETO(PT.X(), PT.Y());
                        POINTS += 2;
                        ++TYPES;
                        BREAK;
                    }
                    CASE QPAINTERPATH::LINETOELEMENT: {
                        QPOINTF PT = (*(CONST QPOINTF *) POINTS) * STATE()->MATRIX;
                        D->ACTIVESTROKER->LINETO(PT.X(), PT.Y());
                        POINTS += 2;
                        ++TYPES;
                        BREAK;
                    }
                    CASE QPAINTERPATH::CURVETOELEMENT: {
                        QPOINTF C1 = ((CONST QPOINTF *) POINTS)[0] * STATE()->MATRIX;
                        QPOINTF C2 = ((CONST QPOINTF *) POINTS)[1] * STATE()->MATRIX;
                        QPOINTF E =  ((CONST QPOINTF *) POINTS)[2] * STATE()->MATRIX;
                        D->ACTIVESTROKER->CUBICTO(C1.X(), C1.Y(), C2.X(), C2.Y(), E.X(), E.Y());
                        POINTS += 6;
                        TYPES += 3;
                        FLAGS |= QVECTORPATH::CURVEDSHAPEMASK;
                        BREAK;
                    }
                    DEFAULT:
                        BREAK;
                    }
                }
                IF (PATH.HASIMPLICITCLOSE()) {
                    QPOINTF PT = * ((CONST QPOINTF *) PATH.POINTS()) * STATE()->MATRIX;
                    D->ACTIVESTROKER->LINETO(PT.X(), PT.Y());
                }

            } ELSE {
                QPOINTF P = ((CONST QPOINTF *)POINTS)[0] * STATE()->MATRIX;
                D->ACTIVESTROKER->MOVETO(P.X(), P.Y());
                POINTS += 2;
                WHILE (POINTS < LASTPOINT) {
                    QPOINTF P = ((CONST QPOINTF *)POINTS)[0] * STATE()->MATRIX;
                    D->ACTIVESTROKER->LINETO(P.X(), P.Y());
                    POINTS += 2;
                }
                IF (PATH.HASIMPLICITCLOSE())
                    D->ACTIVESTROKER->LINETO(P.X(), P.Y());
            }
            D->ACTIVESTROKER->END();
        }

        QVECTORPATH STROKEPATH(D->STROKEHANDLER->PTS.DATA(),
                               D->STROKEHANDLER->TYPES.SIZE(),
                               D->STROKEHANDLER->TYPES.DATA(),
                               FLAGS);

        QTRANSFORM XFORM = STATE()->MATRIX;
        STATE()->MATRIX = QTRANSFORM();
        TRANSFORMCHANGED();

        QBRUSH BRUSH = PEN.BRUSH();
        IF (QBRUSH_STYLE(BRUSH) != QT::SOLIDPATTERN)
            BRUSH.SETTRANSFORM(BRUSH.TRANSFORM() * XFORM);

        FILL(STROKEPATH, BRUSH);

        STATE()->MATRIX = XFORM;
        TRANSFORMCHANGED();
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338041_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID WASMBINARYBUILDER::VISITMEMORYSIZE(MEMORYSIZE* CURR) {
  BYN_TRACE("ZZ NODE: MEMORYSIZE\N");
  AUTO RESERVED = GETU32LEB();
  IF (RESERVED != 0) {
    THROWERROR("INVALID RESERVED FIELD ON MEMORY.SIZE");
  }
  CURR->FINALIZE();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338124_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID WASMBINARYBUILDER::THROWERROR(STD::STRING TEXT) {
  THROW PARSEEXCEPTION(TEXT, 0, POS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206210_CWE-122.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PARSE_COMMAND_MODIFIERS(
	EXARG_T	    *EAP,
	CHAR	    **ERRORMSG,
	CMDMOD_T    *CMOD,
	INT	    SKIP_ONLY)
{
    CHAR_U  *CMD_START = NULL;
    CHAR_U  *P;
    INT	    STARTS_WITH_COLON = FALSE;
    INT	    VIM9SCRIPT = IN_VIM9SCRIPT();
    INT	    HAS_VISUAL_RANGE = FALSE;

    CLEAR_POINTER(CMOD);
    CMOD->CMOD_FLAGS = STICKY_CMDMOD_FLAGS;

    IF (STRNCMP(EAP->CMD, "'<,'>", 5) == 0)
    {
	// THE AUTOMATICALLY INSERTED VISUAL AREA RANGE IS SKIPPED, SO THAT
	// TYPING ":CMDMOD CMD" IN VISUAL MODE WORKS WITHOUT HAVING TO MOVE THE
	// RANGE TO AFTER THE MODIFIFIERS.
	EAP->CMD += 5;
	CMD_START = EAP->CMD;
	HAS_VISUAL_RANGE = TRUE;
    }

    // REPEAT UNTIL NO MORE COMMAND MODIFIERS ARE FOUND.
    FOR (;;)
    {
	WHILE (*EAP->CMD == ' ' || *EAP->CMD == '\T' || *EAP->CMD == ':')
	{
	    IF (*EAP->CMD == ':')
		STARTS_WITH_COLON = TRUE;
	    ++EAP->CMD;
	}

	// IN EX MODE, AN EMPTY LINE WORKS LIKE :+
	IF (*EAP->CMD == NUL && EXMODE_ACTIVE
		   && (GETLINE_EQUAL(EAP->GETLINE, EAP->COOKIE, GETEXMODELINE)
		       || GETLINE_EQUAL(EAP->GETLINE, EAP->COOKIE, GETEXLINE))
			&& CURWIN->W_CURSOR.LNUM < CURBUF->B_ML.ML_LINE_COUNT)
	{
	    EAP->CMD = (CHAR_U *)"+";
	    IF (!SKIP_ONLY)
		EX_PRESSEDRETURN = TRUE;
	}

	// IGNORE COMMENT AND EMPTY LINES
	IF (COMMENT_START(EAP->CMD, STARTS_WITH_COLON))
	{
	    // A COMMENT ENDS AT A NL
	    IF (EAP->NEXTCMD == NULL)
	    {
		EAP->NEXTCMD = VIM_STRCHR(EAP->CMD, '\N');
		IF (EAP->NEXTCMD != NULL)
		    ++EAP->NEXTCMD;
	    }
	    IF (VIM9SCRIPT && HAS_CMDMOD(CMOD, FALSE))
		*ERRORMSG = _(E_COMMAND_MODIFIER_WITHOUT_COMMAND);
	    RETURN FAIL;
	}
	IF (*EAP->CMD == NUL)
	{
	    IF (!SKIP_ONLY)
	    {
		EX_PRESSEDRETURN = TRUE;
		IF (VIM9SCRIPT && HAS_CMDMOD(CMOD, FALSE))
		    *ERRORMSG = _(E_COMMAND_MODIFIER_WITHOUT_COMMAND);
	    }
	    RETURN FAIL;
	}

	P = SKIP_RANGE(EAP->CMD, TRUE, NULL);

	// IN VIM9 SCRIPT A VARIABLE CAN SHADOW A COMMAND MODIFIER:
	//   VERBOSE = 123
	//   VERBOSE += 123
	//   SILENT! VERBOSE = FUNC()
	//   VERBOSE.MEMBER = 2
	//   VERBOSE[EXPR] = 2
	// BUT NOT:
	//   VERBOSE [A, B] = LIST
	IF (VIM9SCRIPT)
	{
	    CHAR_U *S, *N;

	    FOR (S = EAP->CMD; ASCII_ISALPHA(*S); ++S)
		;
	    N = SKIPWHITE(S);
	    IF (*N == '.' || *N == '=' || (*N != NUL && N[1] == '=')
		    || *S == '[')
		BREAK;
	}

	SWITCH (*P)
	{
	    // WHEN ADDING AN ENTRY, ALSO MODIFY CMD_EXISTS().
	    CASE 'A':	IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "ABOVELEFT", 3))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_ABOVE;
			CONTINUE;

	    CASE 'B':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "BELOWRIGHT", 3))
			{
			    CMOD->CMOD_SPLIT |= WSP_BELOW;
			    CONTINUE;
			}
			IF (CHECKFORCMD_OPT(&EAP->CMD, "BROWSE", 3, TRUE))
			{
#IFDEF FEAT_BROWSE_CMD
			    CMOD->CMOD_FLAGS |= CMOD_BROWSE;
#ENDIF
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "BOTRIGHT", 2))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_BOT;
			CONTINUE;

	    CASE 'C':	IF (!CHECKFORCMD_OPT(&EAP->CMD, "CONFIRM", 4, TRUE))
			    BREAK;
#IF DEFINED(FEAT_GUI_DIALOG) || DEFINED(FEAT_CON_DIALOG)
			CMOD->CMOD_FLAGS |= CMOD_CONFIRM;
#ENDIF
			CONTINUE;

	    CASE 'K':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPMARKS", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_KEEPMARKS;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPALT", 5))
			{
			    CMOD->CMOD_FLAGS |= CMOD_KEEPALT;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPPATTERNS", 5))
			{
			    CMOD->CMOD_FLAGS |= CMOD_KEEPPATTERNS;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "KEEPJUMPS", 5))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_KEEPJUMPS;
			CONTINUE;

	    CASE 'F':	// ONLY ACCEPT ":FILTER {PAT} CMD"
			{
			    CHAR_U  *REG_PAT;
			    CHAR_U  *NULP = NULL;
			    INT	    C = 0;

			    IF (!CHECKFORCMD_NOPAREN(&P, "FILTER", 4)
				    || *P == NUL
				    || (ENDS_EXCMD(*P)
#IFDEF FEAT_EVAL
					// IN ":FILTER #PAT# CMD" # DOES NOT
					// START A COMMENT
				     && (!VIM9SCRIPT || VIM_ISWHITE(P[1]))
#ENDIF
				     ))
				BREAK;
			    IF (*P == '!')
			    {
				CMOD->CMOD_FILTER_FORCE = TRUE;
				P = SKIPWHITE(P + 1);
				IF (*P == NUL || ENDS_EXCMD(*P))
				    BREAK;
			    }
#IFDEF FEAT_EVAL
			    // AVOID THAT "FILTER(ARG)" IS RECOGNIZED.
			    IF (VIM9SCRIPT && !VIM_ISWHITE(P[-1]))
				BREAK;
#ENDIF
			    IF (SKIP_ONLY)
				P = SKIP_VIMGREP_PAT(P, NULL, NULL);
			    ELSE
				// NOTE: THIS PUTS A NUL AFTER THE PATTERN.
				P = SKIP_VIMGREP_PAT_EXT(P, &REG_PAT, NULL,
								    &NULP, &C);
			    IF (P == NULL || *P == NUL)
				BREAK;
			    IF (!SKIP_ONLY)
			    {
				CMOD->CMOD_FILTER_REGMATCH.REGPROG =
						VIM_REGCOMP(REG_PAT, RE_MAGIC);
				IF (CMOD->CMOD_FILTER_REGMATCH.REGPROG == NULL)
				    BREAK;
				// RESTORE THE CHARACTER OVERWRITTEN BY NUL
				IF (NULP != NULL)
				    *NULP = C;
			    }
			    EAP->CMD = P;
			    CONTINUE;
			}

			// ":HIDE" AND ":HIDE | CMD" ARE NOT MODIFIERS
	    CASE 'H':	IF (P != EAP->CMD || !CHECKFORCMD_NOPAREN(&P, "HIDE", 3)
					       || *P == NUL || ENDS_EXCMD(*P))
			    BREAK;
			EAP->CMD = P;
			CMOD->CMOD_FLAGS |= CMOD_HIDE;
			CONTINUE;

	    CASE 'L':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "LOCKMARKS", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_LOCKMARKS;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "LEGACY", 3))
			{
			    IF (ENDS_EXCMD2(P, EAP->CMD))
			    {
				*ERRORMSG =
				      _(E_LEGACY_MUST_BE_FOLLOWED_BY_COMMAND);
				RETURN FAIL;
			    }
			    CMOD->CMOD_FLAGS |= CMOD_LEGACY;
			    CONTINUE;
			}

			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "LEFTABOVE", 5))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_ABOVE;
			CONTINUE;

	    CASE 'N':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "NOAUTOCMD", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_NOAUTOCMD;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "NOSWAPFILE", 3))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_NOSWAPFILE;
			CONTINUE;

	    CASE 'R':	IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "RIGHTBELOW", 6))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_BELOW;
			CONTINUE;

	    CASE 'S':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "SANDBOX", 3))
			{
			    CMOD->CMOD_FLAGS |= CMOD_SANDBOX;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "SILENT", 3))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_SILENT;
			IF (*EAP->CMD == '!' && !VIM_ISWHITE(EAP->CMD[-1]))
			{
			    // ":SILENT!", BUT NOT "SILENT !CMD"
			    EAP->CMD = SKIPWHITE(EAP->CMD + 1);
			    CMOD->CMOD_FLAGS |= CMOD_ERRSILENT;
			}
			CONTINUE;

	    CASE 'T':	IF (CHECKFORCMD_NOPAREN(&P, "TAB", 3))
			{
			    IF (!SKIP_ONLY)
			    {
				LONG TABNR = GET_ADDRESS(EAP, &EAP->CMD,
						    ADDR_TABS, EAP->SKIP,
						    SKIP_ONLY, FALSE, 1);
				IF (TABNR == MAXLNUM)
				    CMOD->CMOD_TAB = TABPAGE_INDEX(CURTAB) + 1;
				ELSE
				{
				    IF (TABNR < 0 || TABNR > LAST_TAB_NR)
				    {
					*ERRORMSG = _(E_INVALID_RANGE);
					RETURN FAIL;
				    }
				    CMOD->CMOD_TAB = TABNR + 1;
				}
			    }
			    EAP->CMD = P;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "TOPLEFT", 2))
			    BREAK;
			CMOD->CMOD_SPLIT |= WSP_TOP;
			CONTINUE;

	    CASE 'U':	IF (!CHECKFORCMD_NOPAREN(&EAP->CMD, "UNSILENT", 3))
			    BREAK;
			CMOD->CMOD_FLAGS |= CMOD_UNSILENT;
			CONTINUE;

	    CASE 'V':	IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "VERTICAL", 4))
			{
			    CMOD->CMOD_SPLIT |= WSP_VERT;
			    CONTINUE;
			}
			IF (CHECKFORCMD_NOPAREN(&EAP->CMD, "VIM9CMD", 4))
			{
			    IF (ENDS_EXCMD2(P, EAP->CMD))
			    {
				*ERRORMSG =
				      _(E_VIM9CMD_MUST_BE_FOLLOWED_BY_COMMAND);
				RETURN FAIL;
			    }
			    CMOD->CMOD_FLAGS |= CMOD_VIM9CMD;
			    CONTINUE;
			}
			IF (!CHECKFORCMD_NOPAREN(&P, "VERBOSE", 4))
			    BREAK;
			IF (VIM_ISDIGIT(*EAP->CMD))
			{
			    CMOD->CMOD_VERBOSE = ATOI((CHAR *)EAP->CMD);
			    IF (CMOD->CMOD_VERBOSE == 0)
				CMOD->CMOD_VERBOSE = -1;
			}
			ELSE
			    CMOD->CMOD_VERBOSE = 1;
			EAP->CMD = P;
			CONTINUE;
	}
	BREAK;
    }

    IF (HAS_VISUAL_RANGE)
    {
	IF (EAP->CMD > CMD_START)
	{
	    // MOVE THE '<,'> RANGE TO AFTER THE MODIFIERS AND INSERT A COLON.
	    // SINCE THE MODIFIERS HAVE BEEN PARSED PUT THE COLON ON TOP OF THE
	    // SPACE: "'<,'>MOD CMD" -> "MOD:'<,'>CMD
	    // PUT EAP->CMD AFTER THE COLON.
	    MCH_MEMMOVE(CMD_START - 5, CMD_START, EAP->CMD - CMD_START);
	    EAP->CMD -= 5;
	    MCH_MEMMOVE(EAP->CMD - 1, ":'<,'>", 6);
	}
	ELSE
	    // NO MODIFIERS, MOVE THE POINTER BACK
	    EAP->CMD -= 5;
    }

    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207762_CWE-924.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NEGOTIATE_HANDSHAKE_NEWSTYLE_OPTIONS (VOID)
{
  GET_CONN;
  STRUCT NBD_NEW_OPTION NEW_OPTION;
  SIZE_T NR_OPTIONS;
  BOOL LIST_SEEN = FALSE;
  UINT64_T VERSION;
  UINT32_T OPTION;
  UINT32_T OPTLEN;
  STRUCT NBD_EXPORT_NAME_OPTION_REPLY HANDSHAKE_FINISH;
  CONST CHAR *OPTNAME;
  UINT64_T EXPORTSIZE;
  STRUCT BACKEND *B;

  FOR (NR_OPTIONS = MAX_NR_OPTIONS; NR_OPTIONS > 0; --NR_OPTIONS) {
    CLEANUP_FREE CHAR *DATA = NULL;

    IF (CONN_RECV_FULL (&NEW_OPTION, SIZEOF NEW_OPTION,
                        "READING OPTION: CONN->RECV: %M") == -1)
      RETURN -1;

    VERSION = BE64TOH (NEW_OPTION.VERSION);
    IF (VERSION != NBD_NEW_VERSION) {
      NBDKIT_ERROR ("UNKNOWN OPTION VERSION %" PRIX64
                    ", EXPECTING %" PRIX64,
                    VERSION, NBD_NEW_VERSION);
      RETURN -1;
    }

    /* THERE IS A MAXIMUM OPTION LENGTH WE WILL ACCEPT, REGARDLESS
     * OF THE OPTION TYPE.
     */
    OPTLEN = BE32TOH (NEW_OPTION.OPTLEN);
    IF (OPTLEN > MAX_REQUEST_SIZE) {
      NBDKIT_ERROR ("CLIENT OPTION DATA TOO LONG (%" PRIU32 ")", OPTLEN);
      RETURN -1;
    }
    DATA = MALLOC (OPTLEN + 1); /* ALLOWING A TRAILING NUL HELPS SOME USES */
    IF (DATA == NULL) {
      NBDKIT_ERROR ("MALLOC: %M");
      RETURN -1;
    }

    OPTION = BE32TOH (NEW_OPTION.OPTION);
    OPTNAME = NAME_OF_NBD_OPT (OPTION);

    /* IF THE CLIENT LACKS FIXED NEWSTYLE SUPPORT, IT SHOULD ONLY SEND
     * NBD_OPT_EXPORT_NAME.
     */
    IF (!(CONN->CFLAGS & NBD_FLAG_FIXED_NEWSTYLE) &&
        OPTION != NBD_OPT_EXPORT_NAME) {
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID))
        RETURN -1;
      CONTINUE;
    }

    /* IN --TLS=REQUIRE / FORCEDTLS MODE THE ONLY OPTIONS ALLOWED
     * BEFORE TLS NEGOTIATION ARE NBD_OPT_ABORT AND NBD_OPT_STARTTLS.
     */
    IF (TLS == 2 && !CONN->USING_TLS &&
        !(OPTION == NBD_OPT_ABORT || OPTION == NBD_OPT_STARTTLS)) {
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_TLS_REQD))
        RETURN -1;
      CONTINUE;
    }

    SWITCH (OPTION) {
    CASE NBD_OPT_EXPORT_NAME:
      IF (CONN_RECV_FULL (DATA, OPTLEN,
                          "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
        RETURN -1;
      IF (CHECK_EXPORT_NAME (OPTION, DATA, OPTLEN, OPTLEN) == -1)
        RETURN -1;

      /* WE HAVE TO FINISH THE HANDSHAKE BY SENDING HANDSHAKE_FINISH.
       * ON FAILURE, WE HAVE TO DISCONNECT.
       */
      IF (FINISH_NEWSTYLE_OPTIONS (&EXPORTSIZE, DATA, OPTLEN) == -1)
        RETURN -1;

      MEMSET (&HANDSHAKE_FINISH, 0, SIZEOF HANDSHAKE_FINISH);
      HANDSHAKE_FINISH.EXPORTSIZE = HTOBE64 (EXPORTSIZE);
      HANDSHAKE_FINISH.EFLAGS = HTOBE16 (CONN->EFLAGS);

      IF (CONN->SEND (&HANDSHAKE_FINISH,
                      (CONN->CFLAGS & NBD_FLAG_NO_ZEROES)
                      ? OFFSETOF (STRUCT NBD_EXPORT_NAME_OPTION_REPLY, ZEROES)
                      : SIZEOF HANDSHAKE_FINISH, 0) == -1) {
        NBDKIT_ERROR ("WRITE: %S: %M", OPTNAME);
        RETURN -1;
      }
      BREAK;

    CASE NBD_OPT_ABORT:
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
        RETURN -1;
      DEBUG ("CLIENT SENT %S TO ABORT THE CONNECTION",
             NAME_OF_NBD_OPT (OPTION));
      RETURN -1;

    CASE NBD_OPT_LIST:
      IF (OPTLEN != 0) {
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        IF (CONN_RECV_FULL (DATA, OPTLEN,
                            "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
          RETURN -1;
        CONTINUE;
      }

      IF (LIST_SEEN) {
        DEBUG ("NEWSTYLE NEGOTIATION: %S: EXPORT LIST ALREADY ADVERTISED",
               NAME_OF_NBD_OPT (OPTION));
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID) == -1)
          RETURN -1;
        CONTINUE;
      }
      ELSE {
        /* SEND BACK THE EXPORTNAME LIST. */
        DEBUG ("NEWSTYLE NEGOTIATION: %S: ADVERTISING EXPORTS",
               NAME_OF_NBD_OPT (OPTION));
        IF (SEND_NEWSTYLE_OPTION_REPLY_EXPORTNAMES (OPTION, &NR_OPTIONS) == -1)
          RETURN -1;
        LIST_SEEN = TRUE;
      }
      BREAK;

    CASE NBD_OPT_STARTTLS:
      IF (OPTLEN != 0) {
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        IF (CONN_RECV_FULL (DATA, OPTLEN,
                            "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
          RETURN -1;
        CONTINUE;
      }

      IF (TLS == 0) {           /* --TLS=OFF (NOTLS MODE). */
#IFDEF HAVE_GNUTLS
#DEFINE NO_TLS_REPLY NBD_REP_ERR_POLICY
#ELSE
#DEFINE NO_TLS_REPLY NBD_REP_ERR_UNSUP
#ENDIF
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NO_TLS_REPLY) == -1)
          RETURN -1;
      }
      ELSE /* --TLS=ON OR --TLS=REQUIRE */ {
        /* WE CAN'T UPGRADE TO TLS TWICE ON THE SAME CONNECTION. */
        IF (CONN->USING_TLS) {
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID) == -1)
            RETURN -1;
          CONTINUE;
        }

        /* WE HAVE TO SEND THE (UNENCRYPTED) REPLY BEFORE STARTING
         * THE HANDSHAKE.
         */
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
          RETURN -1;

        /* UPGRADE THE CONNECTION TO TLS.  ALSO PERFORMS ACCESS CONTROL. */
        IF (CRYPTO_NEGOTIATE_TLS (CONN->SOCKIN, CONN->SOCKOUT) == -1)
          RETURN -1;
        CONN->USING_TLS = TRUE;
        DEBUG ("USING TLS ON THIS CONNECTION");
        /* WIPE OUT ANY CACHED DEFAULT EXPORT NAME. */
        FOR_EACH_BACKEND (B) {
          FREE (CONN->DEFAULT_EXPORTNAME[B->I]);
          CONN->DEFAULT_EXPORTNAME[B->I] = NULL;
        }
      }
      BREAK;

    CASE NBD_OPT_INFO:
    CASE NBD_OPT_GO:
      IF (CONN_RECV_FULL (DATA, OPTLEN, "READ: %S: %M", OPTNAME) == -1)
        RETURN -1;

      IF (OPTLEN < 6) { /* 32 BIT EXPORT LENGTH + 16 BIT NR INFO */
        DEBUG ("NEWSTYLE NEGOTIATION: %S OPTION LENGTH < 6", OPTNAME);

        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        CONTINUE;
      }

      {
        UINT32_T EXPORTNAMELEN;
        UINT16_T NRINFOS;
        UINT16_T INFO;
        SIZE_T I;

        /* VALIDATE THE NAME LENGTH AND NUMBER OF INFO REQUESTS. */
        MEMCPY (&EXPORTNAMELEN, &DATA[0], 4);
        EXPORTNAMELEN = BE32TOH (EXPORTNAMELEN);
        IF (EXPORTNAMELEN > OPTLEN-6 /* NB OPTLEN >= 6, SEE ABOVE */) {
          DEBUG ("NEWSTYLE NEGOTIATION: %S: EXPORT NAME TOO LONG", OPTNAME);
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }
        MEMCPY (&NRINFOS, &DATA[EXPORTNAMELEN+4], 2);
        NRINFOS = BE16TOH (NRINFOS);
        IF (OPTLEN != 4 + EXPORTNAMELEN + 2 + 2*NRINFOS) {
          DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                 "NUMBER OF INFORMATION REQUESTS INCORRECT", OPTNAME);
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        /* AS WITH NBD_OPT_EXPORT_NAME WE PRINT THE EXPORT NAME AND
         * SAVE IT IN THE CONNECTION.  IF AN EARLIER
         * NBD_OPT_SET_META_CONTEXT USED AN EXPORT NAME, IT MUST MATCH
         * OR ELSE WE DROP THE SUPPORT FOR THAT CONTEXT.
         */
        IF (CHECK_EXPORT_NAME (OPTION, &DATA[4], EXPORTNAMELEN,
                               OPTLEN - 6) == -1) {
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        /* THE SPEC IS CONFUSING, BUT IT IS REQUIRED THAT WE SEND BACK
         * NBD_INFO_EXPORT, EVEN IF THE CLIENT DID NOT REQUEST IT!
         * QEMU CLIENT IN PARTICULAR DOES NOT REQUEST THIS, BUT WILL
         * FAIL IF WE DON'T SEND IT.  NOTE THAT IF .OPEN FAILS, BUT WE
         * SUCCEED AT .CLOSE, THEN WE MERELY RETURN AN ERROR TO THE
         * CLIENT AND LET THEM TRY ANOTHER NBD_OPT, RATHER THAN
         * DISCONNECTING.
         */
        IF (FINISH_NEWSTYLE_OPTIONS (&EXPORTSIZE,
                                     &DATA[4], EXPORTNAMELEN) == -1) {
          IF (CONN->TOP_CONTEXT) {
            IF (BACKEND_FINALIZE (CONN->TOP_CONTEXT) == -1)
              RETURN -1;
            BACKEND_CLOSE (CONN->TOP_CONTEXT);
            CONN->TOP_CONTEXT = NULL;
          }
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_UNKNOWN) == -1)
            RETURN -1;
          CONTINUE;
        }

        IF (SEND_NEWSTYLE_OPTION_REPLY_INFO_EXPORT (OPTION,
                                                    NBD_REP_INFO,
                                                    NBD_INFO_EXPORT,
                                                    EXPORTSIZE) == -1)
          RETURN -1;

        /* FOR NOW WE SEND NBD_INFO_NAME AND NBD_INFO_DESCRIPTION IF
         * REQUESTED, AND IGNORE ALL OTHER INFO REQUESTS (INCLUDING
         * NBD_INFO_EXPORT IF IT WAS REQUESTED, BECAUSE WE REPLIED
         * ALREADY ABOVE).
         */
        FOR (I = 0; I < NRINFOS; ++I) {
          MEMCPY (&INFO, &DATA[4 + EXPORTNAMELEN + 2 + I*2], 2);
          INFO = BE16TOH (INFO);
          SWITCH (INFO) {
          CASE NBD_INFO_EXPORT: /* IGNORE - REPLY SENT ABOVE */ BREAK;
          CASE NBD_INFO_NAME:
            {
              CONST CHAR *NAME = &DATA[4];
              SIZE_T NAMELEN = EXPORTNAMELEN;

              IF (EXPORTNAMELEN == 0) {
                NAME = BACKEND_DEFAULT_EXPORT (TOP, READ_ONLY);
                IF (!NAME) {
                  DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                         "NBD_INFO_NAME: NO NAME TO SEND", OPTNAME);
                  BREAK;
                }
                NAMELEN = -1;
              }
              IF (SEND_NEWSTYLE_OPTION_REPLY_INFO_STR (OPTION,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_NAME,
                                                       NAME, NAMELEN) == -1)
                RETURN -1;
            }
            BREAK;
          CASE NBD_INFO_DESCRIPTION:
            {
              CONST CHAR *DESC = BACKEND_EXPORT_DESCRIPTION (CONN->TOP_CONTEXT);

              IF (!DESC) {
                DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                       "NBD_INFO_DESCRIPTION: NO DESCRIPTION TO SEND",
                       OPTNAME);
                BREAK;
              }
              IF (SEND_NEWSTYLE_OPTION_REPLY_INFO_STR (OPTION,
                                                       NBD_REP_INFO,
                                                       NBD_INFO_DESCRIPTION,
                                                       DESC, -1) == -1)
                RETURN -1;
            }
            BREAK;
          DEFAULT:
            DEBUG ("NEWSTYLE NEGOTIATION: %S: "
                   "IGNORING NBD_INFO_* REQUEST %U (%S)",
                   OPTNAME, (UNSIGNED) INFO, NAME_OF_NBD_INFO (INFO));
            BREAK;
          }
        }
      }

      /* UNLIKE NBD_OPT_EXPORT_NAME, NBD_OPT_GO SENDS BACK AN ACK
       * OR ERROR PACKET.  IF THIS WAS NBD_OPT_LIST, CALL .CLOSE.
       */
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
        RETURN -1;

      IF (OPTION == NBD_OPT_INFO) {
        IF (BACKEND_FINALIZE (CONN->TOP_CONTEXT) == -1)
          RETURN -1;
        BACKEND_CLOSE (CONN->TOP_CONTEXT);
        CONN->TOP_CONTEXT = NULL;
      }

      BREAK;

    CASE NBD_OPT_STRUCTURED_REPLY:
      IF (OPTLEN != 0) {
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
            == -1)
          RETURN -1;
        IF (CONN_RECV_FULL (DATA, OPTLEN,
                            "READ: %S: %M", NAME_OF_NBD_OPT (OPTION)) == -1)
          RETURN -1;
        CONTINUE;
      }

      DEBUG ("NEWSTYLE NEGOTIATION: %S: CLIENT REQUESTED STRUCTURED REPLIES",
             NAME_OF_NBD_OPT (OPTION));

      IF (NO_SR) {
        /* MUST FAIL WITH ERR_UNSUP FOR QEMU 4.2 TO REMAIN HAPPY;
         * BUT FAILING WITH ERR_POLICY WOULD HAVE BEEN NICER.
         */
        IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_UNSUP) == -1)
          RETURN -1;
        DEBUG ("NEWSTYLE NEGOTIATION: %S: STRUCTURED REPLIES ARE DISABLED",
               NAME_OF_NBD_OPT (OPTION));
        BREAK;
      }

      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
        RETURN -1;

      CONN->STRUCTURED_REPLIES = TRUE;
      BREAK;

    CASE NBD_OPT_LIST_META_CONTEXT:
    CASE NBD_OPT_SET_META_CONTEXT:
      {
        UINT32_T OPT_INDEX;
        UINT32_T EXPORTNAMELEN;
        UINT32_T NR_QUERIES;
        UINT32_T QUERYLEN;
        CONST CHAR *WHAT;

        IF (CONN_RECV_FULL (DATA, OPTLEN, "READ: %S: %M", OPTNAME) == -1)
          RETURN -1;

        /* NOTE THAT WE SUPPORT BASE:ALLOCATION WHETHER OR NOT THE PLUGIN
         * SUPPORTS CAN_EXTENTS.
         */
        IF (!CONN->STRUCTURED_REPLIES) {
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        /* MINIMUM LENGTH OF THE OPTION PAYLOAD IS:
         *   32 BIT EXPORT NAME LENGTH FOLLOWED BY EMPTY EXPORT NAME
         * + 32 BIT NUMBER OF QUERIES FOLLOWED BY NO QUERIES
         * = 8 BYTES.
         */
        WHAT = "OPTLEN < 8";
        IF (OPTLEN < 8) {
        OPT_META_INVALID_OPTION_LEN:
          DEBUG ("NEWSTYLE NEGOTIATION: %S: INVALID OPTION LENGTH: %S",
                 OPTNAME, WHAT);

          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_INVALID)
              == -1)
            RETURN -1;
          CONTINUE;
        }

        MEMCPY (&EXPORTNAMELEN, &DATA[0], 4);
        EXPORTNAMELEN = BE32TOH (EXPORTNAMELEN);
        WHAT = "VALIDATING EXPORT NAME";
        IF (CHECK_EXPORT_NAME (OPTION, &DATA[4], EXPORTNAMELEN,
                               OPTLEN - 8) == -1)
          GOTO OPT_META_INVALID_OPTION_LEN;

        /* REMEMBER THE EXPORT NAME: THE NBD SPEC SAYS THAT IF THE CLIENT
         * LATER USES NBD_OPT_GO ON A DIFFERENT EXPORT, THEN THE CONTEXT
         * RETURNED HERE IS NOT USABLE.
         */
        IF (OPTION == NBD_OPT_SET_META_CONTEXT) {
          CONN->EXPORTNAME_FROM_SET_META_CONTEXT =
            STRNDUP (&DATA[4], EXPORTNAMELEN);
          IF (CONN->EXPORTNAME_FROM_SET_META_CONTEXT == NULL) {
            NBDKIT_ERROR ("MALLOC: %M");
            RETURN -1;
          }
        }

        OPT_INDEX = 4 + EXPORTNAMELEN;

        /* READ THE NUMBER OF QUERIES. */
        WHAT = "READING NUMBER OF QUERIES";
        IF (OPT_INDEX+4 > OPTLEN)
          GOTO OPT_META_INVALID_OPTION_LEN;
        MEMCPY (&NR_QUERIES, &DATA[OPT_INDEX], 4);
        NR_QUERIES = BE32TOH (NR_QUERIES);
        OPT_INDEX += 4;

        /* FOR LIST: NR_QUERIES == 0 MEANS RETURN ALL META CONTEXTS
         * FOR SET: NR_QUERIES == 0 MEANS RESET ALL CONTEXTS
         */
        DEBUG ("NEWSTYLE NEGOTIATION: %S: %S COUNT: %D", OPTNAME,
               OPTION == NBD_OPT_LIST_META_CONTEXT ? "QUERY" : "SET",
               NR_QUERIES);
        IF (OPTION == NBD_OPT_SET_META_CONTEXT)
          CONN->META_CONTEXT_BASE_ALLOCATION = FALSE;
        IF (NR_QUERIES == 0) {
          IF (OPTION == NBD_OPT_LIST_META_CONTEXT) {
            IF (SEND_NEWSTYLE_OPTION_REPLY_META_CONTEXT (OPTION,
                                                         NBD_REP_META_CONTEXT,
                                                         0, "BASE:ALLOCATION")
                == -1)
              RETURN -1;
          }

          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
            RETURN -1;
        }
        ELSE {
          /* READ AND ANSWER EACH QUERY. */
          WHILE (NR_QUERIES > 0) {
            WHAT = "READING QUERY STRING LENGTH";
            IF (OPT_INDEX+4 > OPTLEN)
              GOTO OPT_META_INVALID_OPTION_LEN;
            MEMCPY (&QUERYLEN, &DATA[OPT_INDEX], 4);
            QUERYLEN = BE32TOH (QUERYLEN);
            OPT_INDEX += 4;
            WHAT = "READING QUERY STRING";
            IF (CHECK_STRING (OPTION, &DATA[OPT_INDEX], QUERYLEN,
                              OPTLEN - OPT_INDEX, "META CONTEXT QUERY") == -1)
              GOTO OPT_META_INVALID_OPTION_LEN;

            DEBUG ("NEWSTYLE NEGOTIATION: %S: %S %.*S",
                   OPTNAME,
                   OPTION == NBD_OPT_LIST_META_CONTEXT ? "QUERY" : "SET",
                   (INT) QUERYLEN, &DATA[OPT_INDEX]);

            /* FOR LIST, "BASE:" RETURNS ALL SUPPORTED CONTEXTS IN THE
             * BASE NAMESPACE.  WE ONLY SUPPORT "BASE:ALLOCATION".
             */
            IF (OPTION == NBD_OPT_LIST_META_CONTEXT &&
                QUERYLEN == 5 &&
                STRNCMP (&DATA[OPT_INDEX], "BASE:", 5) == 0) {
              IF (SEND_NEWSTYLE_OPTION_REPLY_META_CONTEXT
                  (OPTION, NBD_REP_META_CONTEXT,
                   0, "BASE:ALLOCATION") == -1)
                RETURN -1;
            }
            /* "BASE:ALLOCATION" REQUESTED BY NAME. */
            ELSE IF (QUERYLEN == 15 &&
                     STRNCMP (&DATA[OPT_INDEX], "BASE:ALLOCATION", 15) == 0) {
              IF (SEND_NEWSTYLE_OPTION_REPLY_META_CONTEXT
                  (OPTION, NBD_REP_META_CONTEXT,
                   OPTION == NBD_OPT_SET_META_CONTEXT
                   ? BASE_ALLOCATION_ID : 0,
                   "BASE:ALLOCATION") == -1)
                RETURN -1;
              IF (OPTION == NBD_OPT_SET_META_CONTEXT)
                CONN->META_CONTEXT_BASE_ALLOCATION = TRUE;
            }
            /* EVERY OTHER QUERY MUST BE IGNORED. */

            OPT_INDEX += QUERYLEN;
            NR_QUERIES--;
          }
          IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ACK) == -1)
            RETURN -1;
        }
        DEBUG ("NEWSTYLE NEGOTIATION: %S: REPLY COMPLETE", OPTNAME);
      }
      BREAK;

    DEFAULT:
      /* UNKNOWN OPTION. */
      IF (SEND_NEWSTYLE_OPTION_REPLY (OPTION, NBD_REP_ERR_UNSUP) == -1)
        RETURN -1;
      IF (CONN_RECV_FULL (DATA, OPTLEN,
                          "READING UNKNOWN OPTION DATA: CONN->RECV: %M") == -1)
        RETURN -1;
    }

    /* NOTE, SINCE IT'S NOT VERY CLEAR FROM THE PROTOCOL DOC, THAT THE
     * CLIENT MUST SEND NBD_OPT_EXPORT_NAME OR NBD_OPT_GO LAST, AND
     * THAT ENDS OPTION NEGOTIATION.
     */
    IF (OPTION == NBD_OPT_EXPORT_NAME || OPTION == NBD_OPT_GO)
      BREAK;
  }

  IF (NR_OPTIONS == 0) {
    NBDKIT_ERROR ("CLIENT SPENT TOO MUCH TIME NEGOTIATING WITHOUT SELECTING "
                  "AN EXPORT");
    RETURN -1;
  }

  /* IN --TLS=REQUIRE / FORCEDTLS MODE, WE MUST HAVE UPGRADED TO TLS
   * BY THE TIME WE FINISH OPTION NEGOTIATION.  IF NOT, GIVE UP.
   */
  IF (TLS == 2 && !CONN->USING_TLS) {
    NBDKIT_ERROR ("NON-TLS CLIENT TRIED TO CONNECT IN --TLS=REQUIRE MODE");
    RETURN -1;
  }

  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 508817_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ST_SELECT_LEX_NODE::FAST_EXCLUDE()
{
  IF (LINK_PREV)
  {
    IF ((*LINK_PREV= LINK_NEXT))
      LINK_NEXT->LINK_PREV= LINK_PREV;
  }
  // REMOVE SLAVE STRUCTURE
  FOR (; SLAVE; SLAVE= SLAVE->NEXT)
    SLAVE->FAST_EXCLUDE();
  
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338114_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL WASMBINARYBUILDER::MAYBEVISITSIMDUNARY(EXPRESSION*& OUT, UINT32_T CODE) {
  UNARY* CURR;
  SWITCH (CODE) {
    CASE BINARYCONSTS::I8X16SPLAT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SPLATVECI8X16;
      BREAK;
    CASE BINARYCONSTS::I16X8SPLAT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SPLATVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I32X4SPLAT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SPLATVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I64X2SPLAT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SPLATVECI64X2;
      BREAK;
    CASE BINARYCONSTS::F32X4SPLAT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SPLATVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F64X2SPLAT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SPLATVECF64X2;
      BREAK;
    CASE BINARYCONSTS::V128NOT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NOTVEC128;
      BREAK;
    CASE BINARYCONSTS::V128ANYTRUE:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ANYTRUEVEC128;
      BREAK;
    CASE BINARYCONSTS::I8X16POPCNT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = POPCNTVECI8X16;
      BREAK;
    CASE BINARYCONSTS::I8X16ABS:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ABSVECI8X16;
      BREAK;
    CASE BINARYCONSTS::I8X16NEG:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEGVECI8X16;
      BREAK;
    CASE BINARYCONSTS::I8X16ALLTRUE:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ALLTRUEVECI8X16;
      BREAK;
    CASE BINARYCONSTS::I8X16BITMASK:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = BITMASKVECI8X16;
      BREAK;
    CASE BINARYCONSTS::I16X8ABS:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ABSVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8NEG:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEGVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8ALLTRUE:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ALLTRUEVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8BITMASK:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = BITMASKVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I32X4ABS:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ABSVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4NEG:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEGVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4ALLTRUE:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ALLTRUEVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4BITMASK:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = BITMASKVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I64X2ABS:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ABSVECI64X2;
      BREAK;
    CASE BINARYCONSTS::I64X2NEG:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEGVECI64X2;
      BREAK;
    CASE BINARYCONSTS::I64X2ALLTRUE:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ALLTRUEVECI64X2;
      BREAK;
    CASE BINARYCONSTS::I64X2BITMASK:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = BITMASKVECI64X2;
      BREAK;
    CASE BINARYCONSTS::F32X4ABS:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ABSVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4NEG:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEGVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4SQRT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SQRTVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4CEIL:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = CEILVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4FLOOR:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = FLOORVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4TRUNC:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = TRUNCVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4NEAREST:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEARESTVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F64X2ABS:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = ABSVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2NEG:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEGVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2SQRT:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = SQRTVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2CEIL:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = CEILVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2FLOOR:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = FLOORVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2TRUNC:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = TRUNCVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2NEAREST:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = NEARESTVECF64X2;
      BREAK;
    CASE BINARYCONSTS::I16X8EXTADDPAIRWISEI8X16S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTADDPAIRWISESVECI8X16TOI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8EXTADDPAIRWISEI8X16U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTADDPAIRWISEUVECI8X16TOI16X8;
      BREAK;
    CASE BINARYCONSTS::I32X4EXTADDPAIRWISEI16X8S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTADDPAIRWISESVECI16X8TOI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4EXTADDPAIRWISEI16X8U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTADDPAIRWISEUVECI16X8TOI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4TRUNCSATF32X4S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = TRUNCSATSVECF32X4TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4TRUNCSATF32X4U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = TRUNCSATUVECF32X4TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4CONVERTI32X4S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = CONVERTSVECI32X4TOVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4CONVERTI32X4U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = CONVERTUVECI32X4TOVECF32X4;
      BREAK;
    CASE BINARYCONSTS::I16X8EXTENDLOWI8X16S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDLOWSVECI8X16TOVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8EXTENDHIGHI8X16S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDHIGHSVECI8X16TOVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8EXTENDLOWI8X16U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDLOWUVECI8X16TOVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I16X8EXTENDHIGHI8X16U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDHIGHUVECI8X16TOVECI16X8;
      BREAK;
    CASE BINARYCONSTS::I32X4EXTENDLOWI16X8S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDLOWSVECI16X8TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4EXTENDHIGHI16X8S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDHIGHSVECI16X8TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4EXTENDLOWI16X8U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDLOWUVECI16X8TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4EXTENDHIGHI16X8U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDHIGHUVECI16X8TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I64X2EXTENDLOWI32X4S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDLOWSVECI32X4TOVECI64X2;
      BREAK;
    CASE BINARYCONSTS::I64X2EXTENDHIGHI32X4S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDHIGHSVECI32X4TOVECI64X2;
      BREAK;
    CASE BINARYCONSTS::I64X2EXTENDLOWI32X4U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDLOWUVECI32X4TOVECI64X2;
      BREAK;
    CASE BINARYCONSTS::I64X2EXTENDHIGHI32X4U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = EXTENDHIGHUVECI32X4TOVECI64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2CONVERTLOWI32X4S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = CONVERTLOWSVECI32X4TOVECF64X2;
      BREAK;
    CASE BINARYCONSTS::F64X2CONVERTLOWI32X4U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = CONVERTLOWUVECI32X4TOVECF64X2;
      BREAK;
    CASE BINARYCONSTS::I32X4TRUNCSATF64X2SZERO:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = TRUNCSATZEROSVECF64X2TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4TRUNCSATF64X2UZERO:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = TRUNCSATZEROUVECF64X2TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::F32X4DEMOTEF64X2ZERO:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = DEMOTEZEROVECF64X2TOVECF32X4;
      BREAK;
    CASE BINARYCONSTS::F64X2PROMOTELOWF32X4:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = PROMOTELOWVECF32X4TOVECF64X2;
      BREAK;
    CASE BINARYCONSTS::I32X4RELAXEDTRUNCF32X4S:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = RELAXEDTRUNCSVECF32X4TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4RELAXEDTRUNCF32X4U:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = RELAXEDTRUNCUVECF32X4TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4RELAXEDTRUNCF64X2SZERO:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = RELAXEDTRUNCZEROSVECF64X2TOVECI32X4;
      BREAK;
    CASE BINARYCONSTS::I32X4RELAXEDTRUNCF64X2UZERO:
      CURR = ALLOCATOR.ALLOC<UNARY>();
      CURR->OP = RELAXEDTRUNCZEROUVECF64X2TOVECI32X4;
      BREAK;
    DEFAULT:
      RETURN FALSE;
  }
  CURR->VALUE = POPNONVOIDEXPRESSION();
  CURR->FINALIZE();
  OUT = CURR;
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512820_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL WITH_SUM_FUNC_CACHE* GET_WITH_SUM_FUNC_CACHE() { RETURN NULL; }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195720_CWE-703.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID UPDATEHANDSHAKESTATE(QUICSERVERCONNECTIONSTATE& CONN) {
  // ZERO RTT READ CIPHER IS AVAILABLE AFTER CHLO IS PROCESSED WITH THE
  // CONDITION THAT EARLY DATA ATTEMPT IS ACCEPTED.
  AUTO HANDSHAKELAYER = CONN.SERVERHANDSHAKELAYER;
  AUTO ZERORTTREADCIPHER = HANDSHAKELAYER->GETZERORTTREADCIPHER();
  AUTO ZERORTTHEADERCIPHER = HANDSHAKELAYER->GETZERORTTREADHEADERCIPHER();
  // ONE RTT WRITE CIPHER IS AVAILABLE AT FIZZ LAYER AFTER CHLO IS PROCESSED.
  // HOWEVER, THE CIPHER IS ONLY EXPORTED TO QUIC IF EARLY DATA ATTEMPT IS
  // ACCEPTED. OTHERWISE, THE CIPHER WILL BE AVAILABLE AFTER CFIN IS
  // PROCESSED.
  AUTO ONERTTWRITECIPHER = HANDSHAKELAYER->GETONERTTWRITECIPHER();
  // ONE RTT READ CIPHER IS AVAILABLE AFTER CFIN IS PROCESSED.
  AUTO ONERTTREADCIPHER = HANDSHAKELAYER->GETONERTTREADCIPHER();

  AUTO ONERTTWRITEHEADERCIPHER = HANDSHAKELAYER->GETONERTTWRITEHEADERCIPHER();
  AUTO ONERTTREADHEADERCIPHER = HANDSHAKELAYER->GETONERTTREADHEADERCIPHER();

  IF (ZERORTTREADCIPHER) {
    IF (CONN.QLOGGER) {
      CONN.QLOGGER->ADDTRANSPORTSTATEUPDATE(KDERIVEDZERORTTREADCIPHER);
    }
    QUIC_TRACE(FST_TRACE, CONN, "DERIVED 0-RTT READ CIPHER");
    CONN.READCODEC->SETZERORTTREADCIPHER(STD::MOVE(ZERORTTREADCIPHER));
  }
  IF (ZERORTTHEADERCIPHER) {
    CONN.READCODEC->SETZERORTTHEADERCIPHER(STD::MOVE(ZERORTTHEADERCIPHER));
  }
  IF (ONERTTWRITEHEADERCIPHER) {
    CONN.ONERTTWRITEHEADERCIPHER = STD::MOVE(ONERTTWRITEHEADERCIPHER);
  }
  IF (ONERTTREADHEADERCIPHER) {
    CONN.READCODEC->SETONERTTHEADERCIPHER(STD::MOVE(ONERTTREADHEADERCIPHER));
  }

  IF (ONERTTWRITECIPHER) {
    IF (CONN.QLOGGER) {
      CONN.QLOGGER->ADDTRANSPORTSTATEUPDATE(KDERIVEDONERTTWRITECIPHER);
    }
    QUIC_TRACE(FST_TRACE, CONN, "DERIVED 1-RTT WRITE CIPHER");
    CHECK(!CONN.ONERTTWRITECIPHER.GET());
    CONN.ONERTTWRITECIPHER = STD::MOVE(ONERTTWRITECIPHER);

    UPDATEPACINGONKEYESTABLISHED(CONN);

    // WE NEGOTIATE THE TRANSPORT PARAMETERS WHENEVER WE HAVE THE 1-RTT WRITE
    // KEYS AVAILABLE.
    AUTO CLIENTPARAMS = HANDSHAKELAYER->GETCLIENTTRANSPORTPARAMS();
    IF (!CLIENTPARAMS) {
      THROW QUICTRANSPORTEXCEPTION(
          "NO CLIENT TRANSPORT PARAMS",
          TRANSPORTERRORCODE::TRANSPORT_PARAMETER_ERROR);
    }
    PROCESSCLIENTINITIALPARAMS(CONN, STD::MOVE(*CLIENTPARAMS));
  }
  IF (ONERTTREADCIPHER) {
    IF (CONN.QLOGGER) {
      CONN.QLOGGER->ADDTRANSPORTSTATEUPDATE(KDERIVEDONERTTREADCIPHER);
    }
    QUIC_TRACE(FST_TRACE, CONN, "DERIVED 1-RTT READ CIPHER");
    // CLEAR LIMIT BECAUSE CFIN IS RECEIVED AT THIS POINT
    CONN.WRITABLEBYTESLIMIT = FOLLY::NONE;
    CONN.READCODEC->SETONERTTREADCIPHER(STD::MOVE(ONERTTREADCIPHER));
  }
  AUTO HANDSHAKEREADCIPHER = HANDSHAKELAYER->GETHANDSHAKEREADCIPHER();
  AUTO HANDSHAKEREADHEADERCIPHER =
      HANDSHAKELAYER->GETHANDSHAKEREADHEADERCIPHER();
  IF (HANDSHAKEREADCIPHER) {
    CHECK(HANDSHAKEREADHEADERCIPHER);
    CONN.READCODEC->SETHANDSHAKEREADCIPHER(STD::MOVE(HANDSHAKEREADCIPHER));
    CONN.READCODEC->SETHANDSHAKEHEADERCIPHER(
        STD::MOVE(HANDSHAKEREADHEADERCIPHER));
  }
  IF (HANDSHAKELAYER->ISHANDSHAKEDONE()) {
    CHECK(CONN.ONERTTWRITECIPHER);
    IF (CONN.VERSION != QUICVERSION::MVFST_D24 && !CONN.SENTHANDSHAKEDONE) {
      SENDSIMPLEFRAME(CONN, HANDSHAKEDONEFRAME());
      CONN.SENTHANDSHAKEDONE = TRUE;
    }
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 232329_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR GF_ISOM_PARSE_MOVIE_BOXES_INTERNAL(GF_ISOFILE *MOV, U32 *BOXTYPE, U64 *BYTESMISSING, BOOL PROGRESSIVE_MODE)
{
	GF_BOX *A;
	U64 TOTSIZE, MDAT_END=0;
	GF_ERR E = GF_OK;

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
	IF (MOV->SINGLE_MOOF_MODE && MOV->SINGLE_MOOF_STATE == 2) {
		RETURN E;
	}

	/*RESTART FROM WHERE WE STOPPED LAST*/
	TOTSIZE = MOV->CURRENT_TOP_BOX_START;
	IF (MOV->BYTES_REMOVED) {
		ASSERT(TOTSIZE >= MOV->BYTES_REMOVED);
		TOTSIZE -= MOV->BYTES_REMOVED;
	}
	GF_BS_SEEK(MOV->MOVIEFILEMAP->BS, TOTSIZE);
#ENDIF


	/*WHILE WE HAVE SOME DATA, PARSE OUR BOXES*/
	WHILE (GF_BS_AVAILABLE(MOV->MOVIEFILEMAP->BS)) {
		*BYTESMISSING = 0;
#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		MOV->CURRENT_TOP_BOX_START = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS) + MOV->BYTES_REMOVED;
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[ISO FILE] PARSING A TOP-LEVEL BOX AT POSITION %D\N", MOV->CURRENT_TOP_BOX_START));
#ENDIF

		E = GF_ISOM_PARSE_ROOT_BOX(&A, MOV->MOVIEFILEMAP->BS, BOXTYPE, BYTESMISSING, PROGRESSIVE_MODE);

		IF (E >= 0) {
			//SAFETY CHECK, SHOULD NEVER HAPPEN
			IF (!A) RETURN GF_ISOM_INVALID_FILE;
		} ELSE IF (E == GF_ISOM_INCOMPLETE_FILE) {
			/*OUR MDAT IS UNCOMPLETE, ONLY VALID FOR READ ONLY FILES...*/
			IF (MOV->OPENMODE != GF_ISOM_OPEN_READ) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] INCOMPLETE MDAT WHILE FILE IS NOT READ-ONLY\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}
			IF ((MOV->OPENMODE == GF_ISOM_OPEN_READ) && !PROGRESSIVE_MODE) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] INCOMPLETE FILE WHILE READING FOR DUMP - ABORTING PARSING\N"));
				BREAK;
			}
			RETURN E;
		} ELSE {
			RETURN E;
		}

		SWITCH (A->TYPE) {
		/*MOOV BOX*/
		CASE GF_ISOM_BOX_TYPE_MOOV:
			IF (MOV->MOOV) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE MOOV DETECTED!\N"));
				GF_ISOM_BOX_DEL(A);
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->MOOV = (GF_MOVIEBOX *)A;
			MOV->ORIGINAL_MOOV_OFFSET = MOV->CURRENT_TOP_BOX_START;
			/*SET OUR POINTER TO THE MOVIE*/
			MOV->MOOV->MOV = MOV;
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
			IF (MOV->MOOV->MVEX) MOV->MOOV->MVEX->MOV = MOV;

#IFDEF GF_ENABLE_CTRN
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				GF_ISOM_SETUP_TRAF_INHERITANCE(MOV);
			}
#ENDIF

#ENDIF
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;

			TOTSIZE += A->SIZE;

            IF (!MOV->MOOV->MVHD) {
                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] MISSING MOVIEHEADERBOX\N"));
                RETURN GF_ISOM_INVALID_FILE;
            }

            IF (MOV->META) {
				GF_ISOM_META_RESTORE_ITEMS_REF(MOV, MOV->META);
			}

			//DUMP SENC INFO IN DUMP MODE
			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				U32 K;
				FOR (K=0; K<GF_LIST_COUNT(MOV->MOOV->TRACKLIST); K++) {
					GF_TRACKBOX *TRAK = (GF_TRACKBOX *)GF_LIST_GET(MOV->MOOV->TRACKLIST, K);

					IF (TRAK->SAMPLE_ENCRYPTION) {
						E = SENC_PARSE(MOV->MOVIEFILEMAP->BS, TRAK, NULL, TRAK->SAMPLE_ENCRYPTION);
						IF (E) RETURN E;
					}
				}
			} ELSE {
				U32 K;
				FOR (K=0; K<GF_LIST_COUNT(MOV->MOOV->TRACKLIST); K++) {
					GF_TRACKBOX *TRAK = (GF_TRACKBOX *)GF_LIST_GET(MOV->MOOV->TRACKLIST, K);
					IF (TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEGROUPS) {
						CONVERT_COMPACT_SAMPLE_GROUPS(TRAK->MEDIA->INFORMATION->SAMPLETABLE->CHILD_BOXES, TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEGROUPS);
					}
				}
			}

            IF (MDAT_END && MOV->SIGNAL_FRAG_BOUNDS && !(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) ) {
                GF_ISOM_PUSH_MDAT_END(MOV, MDAT_END);
                MDAT_END=0;
            }
			BREAK;

		/*META BOX*/
		CASE GF_ISOM_BOX_TYPE_META:
			IF (MOV->META) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE META DETECTED!\N"));
				GF_ISOM_BOX_DEL(A);
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->META = (GF_METABOX *)A;
			MOV->ORIGINAL_META_OFFSET = MOV->CURRENT_TOP_BOX_START;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) {
				RETURN E;
			}
			TOTSIZE += A->SIZE;
			GF_ISOM_META_RESTORE_ITEMS_REF(MOV, MOV->META);
			BREAK;

		/*WE ONLY KEEP THE MDAT IN READ FOR DUMP PURPOSES*/
		CASE GF_ISOM_BOX_TYPE_MDAT:
			IF (!MOV->FIRST_DATA_TOPLEVEL_OFFSET) {
				MOV->FIRST_DATA_TOPLEVEL_OFFSET = MOV->CURRENT_TOP_BOX_START;
				MOV->FIRST_DATA_TOPLEVEL_SIZE = A->SIZE;
			}
			TOTSIZE += A->SIZE;

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
			IF (MOV->EMSGS) {
				GF_ISOM_BOX_ARRAY_DEL(MOV->EMSGS);
				MOV->EMSGS = NULL;
			}
#ENDIF

			IF (MOV->OPENMODE == GF_ISOM_OPEN_READ) {
				IF (!MOV->MDAT) {
					MOV->MDAT = (GF_MEDIADATABOX *) A;
					E = GF_LIST_ADD(MOV->TOPBOXES, MOV->MDAT);
					IF (E) {
						RETURN E;
					}
				}
#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
				ELSE IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) GF_LIST_ADD(MOV->TOPBOXES, A);
#ENDIF
				ELSE GF_ISOM_BOX_DEL(A); //IN OTHER MODES WE DON'T CARE


				IF (MOV->SIGNAL_FRAG_BOUNDS && !(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) ) {
                    MDAT_END = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS);
                    IF (MOV->MOOV) {
                        GF_ISOM_PUSH_MDAT_END(MOV, MDAT_END);
                        MDAT_END=0;
                    }
				}
			}
			/*IF WE DON'T HAVE ANY MDAT YET, CREATE ONE (EDIT-WRITE MODE)
			WE ONLY WORK WITH ONE MDAT, BUT WE'RE PUTING IT AT THE PLACE
			OF THE FIRST MDAT FOUND WHEN OPENING A FILE FOR EDITING*/
			ELSE IF (!MOV->MDAT && (MOV->OPENMODE != GF_ISOM_OPEN_READ) && (MOV->OPENMODE != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {
				GF_ISOM_BOX_DEL(A);
				MOV->MDAT = (GF_MEDIADATABOX *) GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_MDAT);
				IF (!MOV->MDAT) RETURN GF_OUT_OF_MEM;
				E = GF_LIST_ADD(MOV->TOPBOXES, MOV->MDAT);
				IF (E) {
					RETURN E;
				}
			} ELSE {
				GF_ISOM_BOX_DEL(A);
			}
			BREAK;
		CASE GF_ISOM_BOX_TYPE_FTYP:
			/*ONE AND ONLY ONE FTYP*/
			IF (MOV->BRAND) {
				GF_ISOM_BOX_DEL(A);
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE 'FTYP' DETECTED!\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->BRAND = (GF_FILETYPEBOX *)A;
			TOTSIZE += A->SIZE;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;
			BREAK;

		CASE GF_ISOM_BOX_TYPE_OTYP:
			/*ONE AND ONLY ONE FTYP*/
			IF (MOV->OTYP) {
				GF_ISOM_BOX_DEL(A);
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE 'OTYP' DETECTED!\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}

			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				MOV->OTYP = (GF_BOX *)A;
				TOTSIZE += A->SIZE;
				E = GF_LIST_ADD(MOV->TOPBOXES, A);
				IF (E) RETURN E;
			} ELSE {
				GF_FILETYPEBOX *BRAND = (GF_FILETYPEBOX *) GF_ISOM_BOX_FIND_CHILD(A->CHILD_BOXES, GF_ISOM_BOX_TYPE_FTYP);
				IF (BRAND) {
					S32 POS;
					GF_LIST_DEL_ITEM(A->CHILD_BOXES, BRAND);
					POS = GF_LIST_DEL_ITEM(MOV->TOPBOXES, MOV->BRAND);
					GF_ISOM_BOX_DEL((GF_BOX *) MOV->BRAND);
					MOV->BRAND = BRAND;
					IF (POS<0) POS=0;
					GF_LIST_INSERT(MOV->TOPBOXES, BRAND, POS);
				}
				GF_ISOM_BOX_DEL(A);
			}
			BREAK;

		CASE GF_ISOM_BOX_TYPE_PDIN:
			/*ONE AND ONLY ONE PDIN*/
			IF (MOV->PDIN) {
				GF_ISOM_BOX_DEL(A);
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE 'PDIN'' DETECTED!\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->PDIN = (GF_PROGRESSIVEDOWNLOADBOX *) A;
			TOTSIZE += A->SIZE;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;
			BREAK;


#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		CASE GF_ISOM_BOX_TYPE_STYP:
		{
			U32 BRAND = ((GF_FILETYPEBOX *)A)->MAJORBRAND;
			SWITCH (BRAND) {
			CASE GF_ISOM_BRAND_SISX:
			CASE GF_ISOM_BRAND_RISX:
			CASE GF_ISOM_BRAND_SSSS:
				MOV->IS_INDEX_SEGMENT = GF_TRUE;
				BREAK;
			DEFAULT:
				BREAK;
			}
		}
		/*FALL-THROUGH*/

		CASE GF_ISOM_BOX_TYPE_SIDX:
		CASE GF_ISOM_BOX_TYPE_SSIX:
			IF (MOV->MOOV && !MOV->FIRST_DATA_TOPLEVEL_OFFSET) {
				MOV->FIRST_DATA_TOPLEVEL_OFFSET = MOV->CURRENT_TOP_BOX_START;
				MOV->FIRST_DATA_TOPLEVEL_SIZE = A->SIZE;
			}
			TOTSIZE += A->SIZE;
			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				E = GF_LIST_ADD(MOV->TOPBOXES, A);
				IF (E) RETURN E;
			} ELSE IF (MOV->SIGNAL_FRAG_BOUNDS && !(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)  && (MOV->OPENMODE!=GF_ISOM_OPEN_KEEP_FRAGMENTS)
			) {
				IF (A->TYPE==GF_ISOM_BOX_TYPE_SIDX) {
					IF (MOV->ROOT_SIDX) GF_ISOM_BOX_DEL( (GF_BOX *) MOV->ROOT_SIDX);
					MOV->ROOT_SIDX = (GF_SEGMENTINDEXBOX *) A;
					MOV->SIDX_START_OFFSET = MOV->CURRENT_TOP_BOX_START;
					MOV->SIDX_END_OFFSET = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS);

				}
				ELSE IF (A->TYPE==GF_ISOM_BOX_TYPE_STYP) {
					MOV->STYP_START_OFFSET = MOV->CURRENT_TOP_BOX_START;

					IF (MOV->SEG_STYP) GF_ISOM_BOX_DEL(MOV->SEG_STYP);
					MOV->SEG_STYP = A;
				} ELSE IF (A->TYPE==GF_ISOM_BOX_TYPE_SSIX) {
					IF (MOV->SEG_SSIX) GF_ISOM_BOX_DEL(MOV->SEG_SSIX);
					MOV->SEG_SSIX = A;
				} ELSE {
					GF_ISOM_BOX_DEL(A);
				}
				GF_ISOM_PUSH_MDAT_END(MOV, MOV->CURRENT_TOP_BOX_START);
			} ELSE IF (!MOV->NEXTMOOFNUMBER && (A->TYPE==GF_ISOM_BOX_TYPE_SIDX)) {
				IF (MOV->MAIN_SIDX) GF_ISOM_BOX_DEL( (GF_BOX *) MOV->MAIN_SIDX);
				MOV->MAIN_SIDX = (GF_SEGMENTINDEXBOX *) A;
				MOV->MAIN_SIDX_END_POS = MOV->CURRENT_TOP_BOX_START + A->SIZE;
			} ELSE {
				GF_ISOM_BOX_DEL(A);
			}
			BREAK;

		CASE GF_ISOM_BOX_TYPE_MOOF:
			//NO SUPPORT FOR INPLACE REWRITE FOR FRAGMENTED FILES
			GF_ISOM_DISABLE_INPLACE_REWRITE(MOV);
			IF (!MOV->MOOV) {
				GF_LOG(MOV->MOOF ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, ("[ISO FILE] MOVIE FRAGMENT BUT NO MOOV (YET) - POSSIBLY BROKEN PARSING!\N"));
			}
			IF (MOV->SINGLE_MOOF_MODE) {
				MOV->SINGLE_MOOF_STATE++;
				IF (MOV->SINGLE_MOOF_STATE > 1) {
					GF_ISOM_BOX_DEL(A);
					RETURN GF_OK;
				}
			}
			((GF_MOVIEFRAGMENTBOX *)A)->MOV = MOV;

			TOTSIZE += A->SIZE;
			MOV->MOOF = (GF_MOVIEFRAGMENTBOX *) A;

			/*SOME SMOOTH STREAMING STREAMS CONTAIN A SDTP UNDER THE TRAF: THIS IS INCORRECT, CONVERT IT*/
			FIXTRACKID(MOV);
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				FIXSDTPINTRAF(MOV->MOOF);
			} ELSE {
				U32 K;
				FOR (K=0; K<GF_LIST_COUNT(MOV->MOOF->TRACKLIST); K++) {
					GF_TRACKFRAGMENTBOX *TRAF = (GF_TRACKFRAGMENTBOX *)GF_LIST_GET(MOV->MOOF->TRACKLIST, K);
					IF (TRAF->SAMPLEGROUPS) {
						CONVERT_COMPACT_SAMPLE_GROUPS(TRAF->CHILD_BOXES, TRAF->SAMPLEGROUPS);
					}
				}
			}

			/*READ & DEBUG: STORE AT ROOT LEVEL*/
			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				U32 K;
				GF_LIST_ADD(MOV->TOPBOXES, A);
				/*ALSO UPDATE POINTERS TO TREX FOR DEBUG*/
				IF (MOV->MOOV) {
					FOR (K=0; K<GF_LIST_COUNT(MOV->MOOF->TRACKLIST); K++) {
						GF_TRACKFRAGMENTBOX *TRAF = GF_LIST_GET(MOV->MOOF->TRACKLIST, K);
						IF (TRAF->TFHD && MOV->MOOV->MVEX && MOV->MOOV->MVEX->TRACKEXLIST) {
							GF_TRACKBOX *TRAK = GF_ISOM_GET_TRACK_FROM_ID(MOV->MOOV, TRAF->TFHD->TRACKID);
							U32 J=0;
							WHILE ((TRAF->TREX = (GF_TRACKEXTENDSBOX*)GF_LIST_ENUM(MOV->MOOV->MVEX->TRACKEXLIST, &J))) {
								IF (TRAF->TREX->TRACKID == TRAF->TFHD->TRACKID) {
									IF (!TRAF->TREX->TRACK) TRAF->TREX->TRACK = TRAK;
									BREAK;
								}
								TRAF->TREX = NULL;
							}
						}
						//WE SHOULD ONLY PARSE SENC/PSEC WHEN NO SAIZ/SAIO IS PRESENT, OTHERWISE WE FETCH THE INFO DIRECTLY
						IF (TRAF->TREX && TRAF->TFHD && TRAF->TREX->TRACK && TRAF->SAMPLE_ENCRYPTION) {
							GF_TRACKBOX *TRAK = GETTRACKBYID(MOV->MOOV, TRAF->TFHD->TRACKID);
							IF (TRAK) {
								TRAK->CURRENT_TRAF_STSD_IDX = TRAF->TFHD->SAMPLE_DESC_INDEX ? TRAF->TFHD->SAMPLE_DESC_INDEX : TRAF->TREX->DEF_SAMPLE_DESC_INDEX;
								E = SENC_PARSE(MOV->MOVIEFILEMAP->BS, TRAK, TRAF, TRAF->SAMPLE_ENCRYPTION);
								IF (E) RETURN E;
								TRAK->CURRENT_TRAF_STSD_IDX = 0;
							}
						}
					}
				} ELSE {
					FOR (K=0; K<GF_LIST_COUNT(MOV->MOOF->TRACKLIST); K++) {
						GF_TRACKFRAGMENTBOX *TRAF = GF_LIST_GET(MOV->MOOF->TRACKLIST, K);
						IF (TRAF->SAMPLE_ENCRYPTION) {
							E = SENC_PARSE(MOV->MOVIEFILEMAP->BS, NULL, TRAF, TRAF->SAMPLE_ENCRYPTION);
							IF (E) RETURN E;
						}
					}

				}
			} ELSE IF (MOV->OPENMODE==GF_ISOM_OPEN_KEEP_FRAGMENTS) {
				MOV->NEXTMOOFNUMBER = MOV->MOOF->MFHD->SEQUENCE_NUMBER+1;
				MOV->MOOF = NULL;
				GF_ISOM_BOX_DEL(A);
			} ELSE {
				/*MERGE ALL INFO*/
				E = MERGEFRAGMENT((GF_MOVIEFRAGMENTBOX *)A, MOV);
				GF_ISOM_BOX_DEL(A);
				IF (E) RETURN E;
			}

			//DONE WITH MOOV
			IF (MOV->ROOT_SIDX) {
				GF_ISOM_BOX_DEL((GF_BOX *) MOV->ROOT_SIDX);
				MOV->ROOT_SIDX = NULL;
			}
			IF (MOV->ROOT_SSIX) {
				GF_ISOM_BOX_DEL(MOV->SEG_SSIX);
				MOV->ROOT_SSIX = NULL;
			}
			IF (MOV->SEG_STYP) {
				GF_ISOM_BOX_DEL(MOV->SEG_STYP);
				MOV->SEG_STYP = NULL;
			}
			MOV->SIDX_START_OFFSET = 0;
			MOV->SIDX_END_OFFSET = 0;
			MOV->STYP_START_OFFSET = 0;
			BREAK;
#ENDIF
		CASE GF_ISOM_BOX_TYPE_UNKNOWN:
		{
			GF_UNKNOWNBOX *BOX = (GF_UNKNOWNBOX*)A;
			IF (BOX->ORIGINAL_4CC == GF_ISOM_BOX_TYPE_JP) {
				U8 *C = (U8 *) BOX->DATA;
				IF ((BOX->DATASIZE==4) && (GF_4CC(C[0],C[1],C[2],C[3])==(U32)0X0D0A870A))
					MOV->IS_JP2 = 1;
				GF_ISOM_BOX_DEL(A);
			} ELSE {
				E = GF_LIST_ADD(MOV->TOPBOXES, A);
				IF (E) RETURN E;
			}
		}
		BREAK;

		CASE GF_ISOM_BOX_TYPE_PRFT:
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
			IF (!(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				//KEEP THE LAST ONE READ
				IF (MOV->LAST_PRODUCER_REF_TIME)
					GF_ISOM_BOX_DEL(A);
				ELSE
					MOV->LAST_PRODUCER_REF_TIME = (GF_PRODUCERREFERENCETIMEBOX *)A;
				BREAK;
			}
#ENDIF
		//FALLTHROUGH
		CASE GF_ISOM_BOX_TYPE_EMSG:
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				IF (!MOV->EMSGS) MOV->EMSGS = GF_LIST_NEW();
				GF_LIST_ADD(MOV->EMSGS, A);
				BREAK;
			}
#ENDIF
		CASE GF_ISOM_BOX_TYPE_MFRA:
		CASE GF_ISOM_BOX_TYPE_MFRO:
			//ONLY KEEP FOR DUMP MODE, OTHERWISE WE IGNORE THESE BOXES AND WE DON'T WANT TO CARRY THEM OVER IN NON-FRAGMENTED FILE
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				TOTSIZE += A->SIZE;
				GF_ISOM_BOX_DEL(A);
				BREAK;
			}
		DEFAULT:
			TOTSIZE += A->SIZE;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;
			BREAK;
		}

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		/*REMEMBER WHERE WE LEFT, IN CASE WE APPEND AN ENTIRE NUMBER OF MOVIE FRAGMENTS*/
		MOV->CURRENT_TOP_BOX_START = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS) + MOV->BYTES_REMOVED;
#ENDIF
	}

	/*WE NEED AT LEAST MOOV OR META*/
	IF (!MOV->MOOV && !MOV->META
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
	        && !MOV->MOOF && !MOV->IS_INDEX_SEGMENT
#ENDIF
	   ) {
		RETURN GF_ISOM_INCOMPLETE_FILE;
	}
	/*WE MUST HAVE MOVIE HEADER*/
	IF (!GF_OPTS_GET_BOOL("CORE", "NO-CHECK")) {
		IF (MOV->MOOV && !MOV->MOOV->MVHD) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] MISSING MVHD IN MOOV!\N"));
			RETURN GF_ISOM_INVALID_FILE;
		}

		/*WE MUST HAVE META HANDLER*/
		IF (MOV->META && !MOV->META->HANDLER) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] MISSING HANDLER IN META!\N"));
			RETURN GF_ISOM_INVALID_FILE;
		}
	}

#IFNDEF GPAC_DISABLE_ISOM_WRITE

	IF (MOV->MOOV) {
		/*SET THE DEFAULT INTERLEAVING TIME*/
		MOV->INTERLEAVINGTIME = MOV->MOOV->MVHD->TIMESCALE;

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		/*IN EDIT MODE WITH SUCCESSFULLY LOADED FRAGMENTS, DELETE ALL FRAGMENT SIGNALING SINCE
		FILE IS NO LONGER FRAGMENTED*/
		IF ((MOV->OPENMODE > GF_ISOM_OPEN_READ) && (MOV->OPENMODE != GF_ISOM_OPEN_KEEP_FRAGMENTS) && MOV->MOOV->MVEX) {
			GF_ISOM_BOX_DEL_PARENT(&MOV->MOOV->CHILD_BOXES, (GF_BOX *)MOV->MOOV->MVEX);
			MOV->MOOV->MVEX = NULL;
		}
#ENDIF

	}

	//CREATE A DEFAULT MDAT IF NONE WAS FOUND
	IF (!MOV->MDAT && (MOV->OPENMODE != GF_ISOM_OPEN_READ) && (MOV->OPENMODE != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {
		MOV->MDAT = (GF_MEDIADATABOX *) GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_MDAT);
		IF (!MOV->MDAT) RETURN GF_OUT_OF_MEM;
		E = GF_LIST_ADD(MOV->TOPBOXES, MOV->MDAT);
		IF (E) RETURN E;
	}
#ENDIF /*GPAC_DISABLE_ISOM_WRITE*/

	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 217459_CWE-59.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
RESULT ZIPFILE::UNCOMPRESSENTRY (INT INDEX, CONST FILE& TARGETDIRECTORY, BOOL SHOULDOVERWRITEFILES)

{

    AUTO* ZEI = ENTRIES.GETUNCHECKED (INDEX);



   #IF JUCE_WINDOWS

    AUTO ENTRYPATH = ZEI->ENTRY.FILENAME;

   #ELSE

    AUTO ENTRYPATH = ZEI->ENTRY.FILENAME.REPLACECHARACTER ('\\', '/');

   #ENDIF



    IF (ENTRYPATH.ISEMPTY())

        RETURN RESULT::OK();



    AUTO TARGETFILE = TARGETDIRECTORY.GETCHILDFILE (ENTRYPATH);



    IF (ENTRYPATH.ENDSWITHCHAR ('/') || ENTRYPATH.ENDSWITHCHAR ('\\'))

        RETURN TARGETFILE.CREATEDIRECTORY(); // (ENTRY IS A DIRECTORY, NOT A FILE)



    STD::UNIQUE_PTR<INPUTSTREAM> IN (CREATESTREAMFORENTRY (INDEX));



    IF (IN == NULLPTR)

        RETURN RESULT::FAIL ("FAILED TO OPEN THE ZIP FILE FOR READING");



    IF (TARGETFILE.EXISTS())

    {

        IF (! SHOULDOVERWRITEFILES)

            RETURN RESULT::OK();



        IF (! TARGETFILE.DELETEFILE())

            RETURN RESULT::FAIL ("FAILED TO WRITE TO TARGET FILE: " + TARGETFILE.GETFULLPATHNAME());

    }



    IF (! TARGETFILE.GETPARENTDIRECTORY().CREATEDIRECTORY())

        RETURN RESULT::FAIL ("FAILED TO CREATE TARGET FOLDER: " + TARGETFILE.GETPARENTDIRECTORY().GETFULLPATHNAME());



    IF (ZEI->ENTRY.ISSYMBOLICLINK)

    {

        STRING ORIGINALFILEPATH (IN->READENTIRESTREAMASSTRING()

                                    .REPLACECHARACTER (L'/', FILE::GETSEPARATORCHAR()));



        IF (! FILE::CREATESYMBOLICLINK (TARGETFILE, ORIGINALFILEPATH, TRUE))

            RETURN RESULT::FAIL ("FAILED TO CREATE SYMBOLIC LINK: " + ORIGINALFILEPATH);

    }

    ELSE

    {

        FILEOUTPUTSTREAM OUT (TARGETFILE);



        IF (OUT.FAILEDTOOPEN())

            RETURN RESULT::FAIL ("FAILED TO WRITE TO TARGET FILE: " + TARGETFILE.GETFULLPATHNAME());



        OUT << *IN;

    }



    TARGETFILE.SETCREATIONTIME (ZEI->ENTRY.FILETIME);

    TARGETFILE.SETLASTMODIFICATIONTIME (ZEI->ENTRY.FILETIME);

    TARGETFILE.SETLASTACCESSTIME (ZEI->ENTRY.FILETIME);



    RETURN RESULT::OK();

}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216637_CWE-275.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SCM_DEFINE (SCM_MKDIR, "MKDIR", 1, 1, 0,
            (SCM PATH, SCM MODE),
	    "CREATE A NEW DIRECTORY NAMED BY @VAR{PATH}.  IF @VAR{MODE} IS OMITTED\N"
	    "THEN THE PERMISSIONS OF THE DIRECTORY FILE ARE SET USING THE CURRENT\N"
	    "UMASK.  OTHERWISE THEY ARE SET TO THE DECIMAL VALUE SPECIFIED WITH\N"
	    "@VAR{MODE}.  THE RETURN VALUE IS UNSPECIFIED.")
#DEFINE FUNC_NAME S_SCM_MKDIR
{
  INT RV;
  MODE_T MASK;

  IF (SCM_UNBNDP (MODE))
    {
      MASK = UMASK (0);
      UMASK (MASK);
      STRING_SYSCALL (PATH, C_PATH, RV = MKDIR (C_PATH, 0777 ^ MASK));
    }
  ELSE
    {
      STRING_SYSCALL (PATH, C_PATH, RV = MKDIR (C_PATH, SCM_TO_UINT (MODE)));
    }
  IF (RV != 0)
    SCM_SYSERROR;
  RETURN SCM_UNSPECIFIED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197511_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID HIERARCHICALBITMAPREQUESTER::PREPAREFORDECODING(VOID)
{
#IF ACCUSOFT_CODE

  UBYTE I;

  BUILDCOMMON();

  IF (M_PPDECODINGMCU == NULL) {
    M_PPDECODINGMCU = (STRUCT LINE **)M_PENVIRON->ALLOCMEM(SIZEOF(STRUCT LINE *) * M_UCCOUNT*8);
    MEMSET(M_PPDECODINGMCU,0,SIZEOF(STRUCT LINE *) * M_UCCOUNT * 8);
  }

  IF (M_PPUPSAMPLER == NULL) {
    M_PPUPSAMPLER = (CLASS UPSAMPLERBASE **)M_PENVIRON->ALLOCMEM(SIZEOF(CLASS UPSAMPLERBASE *) * M_UCCOUNT);
    MEMSET(M_PPUPSAMPLER,0,SIZEOF(CLASS UPSAMPLER *) * M_UCCOUNT);

    FOR(I = 0;I < M_UCCOUNT;I++) {
      CLASS COMPONENT *COMP = M_PFRAME->COMPONENTOF(I);
      UBYTE SX = COMP->SUBXOF();
      UBYTE SY = COMP->SUBYOF();

      IF (SX > 1 || SY > 1) {
        M_PPUPSAMPLER[I] = UPSAMPLERBASE::CREATEUPSAMPLER(M_PENVIRON,SX,SY,
                                                          M_ULPIXELWIDTH,M_ULPIXELHEIGHT,
                                                          M_PFRAME->TABLESOF()->ISCHROMACENTERED());
        M_BSUBSAMPLING   = TRUE;
      }
    }
  }

  IF (M_PLARGESTSCALE)
    M_PLARGESTSCALE->PREPAREFORDECODING();
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90764_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID QUOTAMANAGER::DIDRUNINITIALGETTEMPORARYGLOBALUSAGE(
    STORAGETYPE TYPE, INT64 USAGE_UNUSED, INT64 UNLIMITED_USAGE_UNUSED) {
  DCHECK_EQ(TYPE, KSTORAGETYPETEMPORARY);
  SCOPED_REFPTR<INITIALIZETEMPORARYORIGINSINFOTASK> TASK(
      NEW INITIALIZETEMPORARYORIGINSINFOTASK(
          THIS, TEMPORARY_USAGE_TRACKER_.GET()));
  TASK->START();
}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216905_CWE-190.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ST_SELECT_LEX::SETUP_REF_ARRAY(THD *THD, UINT ORDER_GROUP_NUM)
{

  IF (!((OPTIONS & SELECT_DISTINCT) && !GROUP_LIST.ELEMENTS))
    HIDDEN_BIT_FIELDS= 0;

  // FIND_ORDER_IN_LIST() MAY NEED SOME EXTRA SPACE, SO MULTIPLY BY TWO.
  ORDER_GROUP_NUM*= 2;

  /*
    WE HAVE TO CREATE ARRAY IN PREPARED STATEMENT MEMORY IF IT IS A
    PREPARED STATEMENT
  */
  QUERY_ARENA *ARENA= THD->STMT_ARENA;
  CONST UINT N_ELEMS= (N_SUM_ITEMS +
                       N_CHILD_SUM_ITEMS +
                       ITEM_LIST.ELEMENTS +
                       SELECT_N_RESERVED +
                       SELECT_N_HAVING_ITEMS +
                       SELECT_N_WHERE_FIELDS +
                       ORDER_GROUP_NUM +
                       HIDDEN_BIT_FIELDS +
                       FIELDS_IN_WINDOW_FUNCTIONS) * 5;
  IF (!REF_POINTER_ARRAY.IS_NULL())
  {
    /*
      WE NEED TO TAKE 'N_SUM_ITEMS' INTO ACCOUNT WHEN ALLOCATING THE ARRAY,
      AND THIS MAY ACTUALLY INCREASE DURING THE OPTIMIZATION PHASE DUE TO
      MIN/MAX REWRITE IN ITEM_IN_SUBSELECT::SINGLE_VALUE_TRANSFORMER.
      IN THE USUAL CASE WE CAN REUSE THE ARRAY FROM THE PREPARE PHASE.
      IF WE NEED A BIGGER ARRAY, WE MUST ALLOCATE A NEW ONE.
     */
    IF (REF_POINTER_ARRAY.SIZE() >= N_ELEMS)
      RETURN FALSE;
   }
  ITEM **ARRAY= STATIC_CAST<ITEM**>(ARENA->ALLOC(SIZEOF(ITEM*) * N_ELEMS));
  IF (ARRAY != NULL)
    REF_POINTER_ARRAY= REF_PTR_ARRAY(ARRAY, N_ELEMS);

  RETURN ARRAY == NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207703_CWE-362.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
SET<INT> PIPESOCKETHANDLER::LISTEN(CONST SOCKETENDPOINT& ENDPOINT) {
  LOCK_GUARD<STD::RECURSIVE_MUTEX> GUARD(GLOBALMUTEX);

  STRING PIPEPATH = ENDPOINT.NAME();
  IF (PIPESERVERSOCKETS.FIND(PIPEPATH) != PIPESERVERSOCKETS.END()) {
    THROW RUNTIME_ERROR("TRIED TO LISTEN TWICE ON THE SAME PATH");
  }

  SOCKADDR_UN LOCAL;

  INT FD = SOCKET(AF_UNIX, SOCK_STREAM, 0);
  FATAL_FAIL(FD);
  INITSERVERSOCKET(FD);
  LOCAL.SUN_FAMILY = AF_UNIX; /* LOCAL IS DECLARED BEFORE SOCKET() ^ */
  STRCPY(LOCAL.SUN_PATH, PIPEPATH.C_STR());
  UNLINK(LOCAL.SUN_PATH);

  FATAL_FAIL(::BIND(FD, (STRUCT SOCKADDR*)&LOCAL, SIZEOF(SOCKADDR_UN)));
  ::LISTEN(FD, 5);
#IFNDEF WIN32
  FATAL_FAIL(::CHMOD(LOCAL.SUN_PATH, S_IRUSR | S_IWUSR | S_IXUSR));
#ENDIF

  PIPESERVERSOCKETS[PIPEPATH] = SET<INT>({FD});
  RETURN PIPESERVERSOCKETS[PIPEPATH];
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 393531_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SQINTEGER ARRAY_FIND(HSQUIRRELVM V)
{
    SQOBJECT &O = STACK_GET(V,1);
    SQOBJECTPTR &VAL = STACK_GET(V,2);
    SQARRAY *A = _ARRAY(O);
    SQINTEGER SIZE = A->SIZE();
    SQOBJECTPTR TEMP;
    FOR(SQINTEGER N = 0; N < SIZE; N++) {
        BOOL RES = FALSE;
        A->GET(N,TEMP);
        IF(SQVM::ISEQUAL(TEMP,VAL,RES) && RES) {
            V->PUSH(N);
            RETURN 1;
        }
    }
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 231781_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_F(QUICUNENCRYPTEDSERVERTRANSPORTTEST, TESTSENDHANDSHAKEDONE) {
  GETFAKEHANDSHAKELAYER()->ALLOWZERORTTKEYS();
  SETUPCLIENTREADCODEC();
  RECVCLIENTHELLO(TRUE, QUICVERSION::QUIC_DRAFT);
  RECVCLIENTFINISHED(TRUE, NULLPTR, QUICVERSION::QUIC_DRAFT);
  AUTO& PACKETS = SERVER->GETCONN().OUTSTANDINGS.PACKETS;
  ASSERT_FALSE(PACKETS.EMPTY());
  INT NUMHANDSHAKEDONE = 0;
  FOR (AUTO& P : PACKETS) {
    FOR (AUTO& F : P.PACKET.FRAMES) {
      AUTO S = F.ASQUICSIMPLEFRAME();
      IF (S) {
        IF (S->ASHANDSHAKEDONEFRAME()) {
          NUMHANDSHAKEDONE++;
        }
      }
    }
  }
  EXPECT_EQ(NUMHANDSHAKEDONE, 1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195549_CWE-125.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL JSON_PARSER(VARIANT &Z, CONST CHAR *P, INT LENGTH, BOOL CONST ASSOC,
                 INT DEPTH, INT64_T OPTIONS) {
  // NO GC SAFEPOINTS DURING JSON PARSING, PLEASE. CODE IS NOT RE-ENTRANT.
  NOHANDLESURPRISESCOPE NO_SURPRISE(SAFEPOINTFLAGS);

  JSON_PARSER *JSON = S_JSON_PARSER.GET(); /* THE PARSER STATE */
  // CLEAR AND REUSE THE THREAD-LOCAL STRING BUFFERS. THEY ARE ONLY FREED IF
  // THEY EXCEED KMAXPERSISTENTSTRINGBUFFERCAPACITY AT EXIT OR IF THE THREAD
  // IS EXPLICITLY FLUSHED (E.G., DUE TO BEING IDLE).
  JSON->INITSB(LENGTH);
  SCOPE_EXIT {
    CONSTEXPR INT KMAXPERSISTENTSTRINGBUFFERCAPACITY = 256 * 1024;
    IF (JSON->SB_CAP > KMAXPERSISTENTSTRINGBUFFERCAPACITY) JSON->FLUSHSB();
  };
  // SIMPLEPARSER ONLY HANDLES THE MOST COMMON SET OF OPTIONS. ALSO, ONLY USE IT
  // IF ITS ARRAY NESTING DEPTH CHECK IS *MORE* RESTRICTIVE THAN WHAT THE USER
  // ASKS FOR, TO ENSURE THAT THE PRECISE SEMANTICS OF THE GENERAL CASE IS
  // APPLIED FOR ALL NESTING OVERFLOWS.
  IF (ASSOC &&
      OPTIONS == (OPTIONS & (K_JSON_FB_LOOSE |
                             K_JSON_FB_DARRAYS |
                             K_JSON_FB_DARRAYS_AND_VARRAYS |
                             K_JSON_FB_HACK_ARRAYS |
                             K_JSON_FB_THRIFT_SIMPLE_JSON |
                             K_JSON_FB_LEGACY_HACK_ARRAYS)) &&
      DEPTH >= SIMPLEPARSER::KMAXARRAYDEPTH &&
      LENGTH <= RUNTIMEOPTION::EVALSIMPLEJSONMAXLENGTH &&
      SIMPLEPARSER::TRYPARSE(P, LENGTH, JSON->TL_BUFFER.TV, Z,
                             GET_CONTAINER_TYPE_FROM_OPTIONS(OPTIONS),
                             OPTIONS & K_JSON_FB_THRIFT_SIMPLE_JSON)) {
    RETURN TRUE;
  }

  INT B;  /* THE NEXT CHARACTER */
  INT C;  /* THE NEXT CHARACTER CLASS */
  INT S;  /* THE NEXT STATE */
  INT STATE = 0;

  /*<FB>*/
  BOOL CONST LOOSE = OPTIONS & K_JSON_FB_LOOSE;
  JSONCONTAINERTYPE CONST CONTAINER_TYPE =
    GET_CONTAINER_TYPE_FROM_OPTIONS(OPTIONS);
  INT QCHR = 0;
  INT8_T CONST *BYTE_CLASS;
  INT8_T CONST (*NEXT_STATE_TABLE)[32];
  IF (LOOSE) {
    BYTE_CLASS = LOOSE_ASCII_CLASS;
    NEXT_STATE_TABLE = LOOSE_STATE_TRANSITION_TABLE;
  } ELSE {
    BYTE_CLASS = ASCII_CLASS;
    NEXT_STATE_TABLE = STATE_TRANSITION_TABLE;
  }
  /*</FB>*/

  UNCHECKEDBUFFER *BUF = &JSON->SB_BUF;
  UNCHECKEDBUFFER *KEY = &JSON->SB_KEY;

  DATATYPE TYPE = KINVALIDDATATYPE;
  UNSIGNED SHORT ESCAPED_BYTES = 0;

  AUTO RESET_TYPE = [&] { TYPE = KINVALIDDATATYPE; };

  JSON->DEPTH = DEPTH;
  // SINCE THE STACK IS MAINTAININED ON A PER REQUEST BASIS, FOR PERFORMANCE
  // REASONS, IT ONLY MAKES SENSE TO EXPAND IF NECESSARY AND CYCLES ARE WASTED
  // CONTRACTING. CALLS WITH A DEPTH OTHER THAN DEFAULT SHOULD BE RARE.
  IF (DEPTH > JSON->STACK.SIZE()) {
    JSON->STACK.RESIZE(DEPTH);
  }
  SCOPE_EXIT {
    IF (JSON->STACK.EMPTY()) RETURN;
    FOR (INT I = 0; I <= JSON->MARK; I++) {
      JSON->STACK[I].KEY.RESET();
      JSON->STACK[I].VAL.UNSET();
    }
    JSON->MARK = -1;
  };

  JSON->MARK = JSON->TOP = -1;
  PUSH(JSON, MODE::DONE);

  UTF8TO16DECODER DECODER(P, LENGTH, LOOSE);
  FOR (;;) {
    B = DECODER.DECODE();
    // FAST-CASE MOST COMMON TRANSITION: APPEND A SIMPLE STRING CHARACTER.
    IF (STATE == 3 && TYPE == KINDOFSTRING) {
      WHILE (B != '\"' &&  B != '\\' && B != '\'' && B <= 127 && B >= ' ') {
        BUF->APPEND((CHAR)B);
        B = DECODER.DECODE();
      }
    }
    IF (B == UTF8_END) BREAK; // UTF-8 DECODING FINISHES SUCCESSFULLY.
    IF (B == UTF8_ERROR) {
      S_JSON_PARSER->ERROR_CODE = JSON_ERROR_UTF8;
      RETURN FALSE;
    }
    ASSERTX(B >= 0);

    IF ((B & 127) == B) {
      /*<FB>*/
      C = BYTE_CLASS[B];
      /*</FB>*/
      IF (C <= S_ERR) {
        S_JSON_PARSER->ERROR_CODE = JSON_ERROR_CTRL_CHAR;
        RETURN FALSE;
      }
    } ELSE {
      C = S_ETC;
    }
    /*
      GET THE NEXT STATE FROM THE TRANSITION TABLE.
    */

    /*<FB>*/
    S = NEXT_STATE_TABLE[STATE][C];

    IF (S == -4) {
      IF (B != QCHR) {
        S = 3;
      } ELSE {
        QCHR = 0;
      }
    }
    /*</FB>*/

    IF (S < 0) {
      /*
        PERFORM ONE OF THE PREDEFINED ACTIONS.
      */
      SWITCH (S) {
        /*
          EMPTY }
        */
      CASE -9:
        /*<FB>*/
        IF (JSON->TOP == 1) Z = JSON->STACK[JSON->TOP].VAL;
        ELSE {
        /*</FB>*/
          ATTACH_ZVAL(JSON, JSON->STACK[JSON->TOP].KEY, ASSOC, CONTAINER_TYPE);
        /*<FB>*/
        }
        /*</FB>*/
        IF (!POP(JSON, MODE::KEY)) {
          RETURN FALSE;
        }
        STATE = 9;
        BREAK;
        /*
          {
        */
      CASE -8:
        IF (!PUSH(JSON, MODE::KEY)) {
          S_JSON_PARSER->ERROR_CODE = JSON_ERROR_DEPTH;
          RETURN FALSE;
        }

        STATE = 1;
        IF (JSON->TOP > 0) {
          VARIANT &TOP = JSON->STACK[JSON->TOP].VAL;
          /*<FB>*/
          IF (CONTAINER_TYPE == JSONCONTAINERTYPE::COLLECTIONS) {
            // STABLE_MAPS IS MEANINGLESS
            TOP = REQ::MAKE<C_MAP>();
          } ELSE {
          /*</FB>*/
            IF (!ASSOC) {
              TOP = SYSTEMLIB::ALLOCSTDCLASSOBJECT();
            /* <FB> */
            } ELSE IF (CONTAINER_TYPE == JSONCONTAINERTYPE::HACK_ARRAYS) {
              TOP = ARRAY::CREATEDICT();
            } ELSE IF (CONTAINER_TYPE == JSONCONTAINERTYPE::DARRAYS ||
                       CONTAINER_TYPE == JSONCONTAINERTYPE::DARRAYS_AND_VARRAYS)
            {
              TOP = ARRAY::CREATEDARRAY();
            /* </FB> */
            } ELSE IF (
              CONTAINER_TYPE == JSONCONTAINERTYPE::LEGACY_HACK_ARRAYS) {
              AUTO ARR = STATICEMPTYDICTARRAY()->COPY();
              ARR->SETLEGACYARRAY(TRUE);
              TOP = ARR;
            } ELSE {
              TOP = ARRAY::CREATEDARRAY();
            }
          /*<FB>*/
          }
          /*</FB>*/
          JSON->STACK[JSON->TOP].KEY = COPY_AND_CLEAR(*KEY);
          RESET_TYPE();
        }
        BREAK;
        /*
          }
        */
      CASE -7:
        /*** BEGIN FACEBOOK: JSON_UTF8_LOOSE ***/
        /*
          IF THIS IS A TRAILING COMMA IN AN OBJECT DEFINITION,
          WE'RE IN MODE::KEY. IN THAT CASE, THROW THAT OFF THE
          STACK AND RESTORE MODE::OBJECT SO THAT WE PRETEND THE
          TRAILING COMMA JUST DIDN'T HAPPEN.
        */
        IF (LOOSE) {
          IF (POP(JSON, MODE::KEY)) {
            PUSH(JSON, MODE::OBJECT);
          }
        }
        /*** END FACEBOOK: JSON_UTF8_LOOSE ***/

        IF (TYPE != KINVALIDDATATYPE &&
            JSON->STACK[JSON->TOP].MODE == MODE::OBJECT) {
          VARIANT MVAL;
          JSON_CREATE_ZVAL(MVAL, *BUF, TYPE, OPTIONS);
          VARIANT &TOP = JSON->STACK[JSON->TOP].VAL;
          OBJECT_SET(JSON, TOP, COPY_AND_CLEAR(*KEY),
                     MVAL, ASSOC, CONTAINER_TYPE);
          BUF->CLEAR();
          RESET_TYPE();
        }

        /*<FB>*/
        IF (JSON->TOP == 1) Z = JSON->STACK[JSON->TOP].VAL;
        ELSE {
        /*</FB>*/
          ATTACH_ZVAL(JSON, JSON->STACK[JSON->TOP].KEY,
            ASSOC, CONTAINER_TYPE);
        /*<FB>*/
        }
        /*</FB>*/
        IF (!POP(JSON, MODE::OBJECT)) {
          S_JSON_PARSER->ERROR_CODE = JSON_ERROR_STATE_MISMATCH;
          RETURN FALSE;
        }
        STATE = 9;
        BREAK;
        /*
          [
        */
      CASE -6:
        IF (!PUSH(JSON, MODE::ARRAY)) {
          S_JSON_PARSER->ERROR_CODE = JSON_ERROR_DEPTH;
          RETURN FALSE;
        }
        STATE = 2;

        IF (JSON->TOP > 0) {
          VARIANT &TOP = JSON->STACK[JSON->TOP].VAL;
          /*<FB>*/
          IF (CONTAINER_TYPE == JSONCONTAINERTYPE::COLLECTIONS) {
            TOP = REQ::MAKE<C_VECTOR>();
          } ELSE IF (CONTAINER_TYPE == JSONCONTAINERTYPE::HACK_ARRAYS) {
            TOP = ARRAY::CREATEVEC();
          } ELSE IF (CONTAINER_TYPE == JSONCONTAINERTYPE::DARRAYS_AND_VARRAYS) {
            TOP = ARRAY::CREATEVARRAY();
          } ELSE IF (CONTAINER_TYPE == JSONCONTAINERTYPE::DARRAYS) {
            TOP = ARRAY::CREATEDARRAY();
          } ELSE IF (CONTAINER_TYPE == JSONCONTAINERTYPE::LEGACY_HACK_ARRAYS) {
            AUTO ARR = STATICEMPTYVECARRAY()->COPY();
            ARR->SETLEGACYARRAY(TRUE);
            TOP = ARR;
          } ELSE {
            TOP = ARRAY::CREATEDARRAY();
          }
          /*</FB>*/
          JSON->STACK[JSON->TOP].KEY = COPY_AND_CLEAR(*KEY);
          RESET_TYPE();
        }
        BREAK;
        /*
          ]
        */
      CASE -5:
        {
          IF (TYPE != KINVALIDDATATYPE &&
               JSON->STACK[JSON->TOP].MODE == MODE::ARRAY) {
            VARIANT MVAL;
            JSON_CREATE_ZVAL(MVAL, *BUF, TYPE, OPTIONS);
            AUTO& TOP = JSON->STACK[JSON->TOP].VAL;
            IF (CONTAINER_TYPE == JSONCONTAINERTYPE::COLLECTIONS) {
              COLLECTIONS::APPEND(TOP.GETOBJECTDATA(), MVAL.ASTYPEDVALUE());
            } ELSE {
              TOP.ASARRREF().APPEND(MVAL);
            }
            BUF->CLEAR();
            RESET_TYPE();
          }

          /*<FB>*/
          IF (JSON->TOP == 1) Z = JSON->STACK[JSON->TOP].VAL;
          ELSE {
          /*</FB>*/
            ATTACH_ZVAL(JSON, JSON->STACK[JSON->TOP].KEY, ASSOC,
              CONTAINER_TYPE);
          /*<FB>*/
          }
          /*</FB>*/
          IF (!POP(JSON, MODE::ARRAY)) {
            S_JSON_PARSER->ERROR_CODE = JSON_ERROR_STATE_MISMATCH;
            RETURN FALSE;
          }
          STATE = 9;
        }
        BREAK;
        /*
          "
        */
      CASE -4:
        SWITCH (JSON->STACK[JSON->TOP].MODE) {
        CASE MODE::KEY:
          STATE = 27;
          STD::SWAP(BUF, KEY);
          RESET_TYPE();
          BREAK;
        CASE MODE::ARRAY:
        CASE MODE::OBJECT:
          STATE = 9;
          BREAK;
        CASE MODE::DONE:
          IF (TYPE == KINDOFSTRING) {
            Z = COPY_AND_CLEAR(*BUF);
            STATE = 9;
            BREAK;
          }
          /* FALL THROUGH IF NOT KINDOFSTRING */
        DEFAULT:
          S_JSON_PARSER->ERROR_CODE = JSON_ERROR_SYNTAX;
          RETURN FALSE;
        }
        BREAK;
        /*
          ,
        */
      CASE -3:
        {
          VARIANT MVAL;
          IF (TYPE != KINVALIDDATATYPE &&
              (JSON->STACK[JSON->TOP].MODE == MODE::OBJECT ||
               JSON->STACK[JSON->TOP].MODE == MODE::ARRAY)) {
            JSON_CREATE_ZVAL(MVAL, *BUF, TYPE, OPTIONS);
          }

          SWITCH (JSON->STACK[JSON->TOP].MODE) {
          CASE MODE::OBJECT:
            IF (POP(JSON, MODE::OBJECT) &&
                PUSH(JSON, MODE::KEY)) {
              IF (TYPE != KINVALIDDATATYPE) {
                VARIANT &TOP = JSON->STACK[JSON->TOP].VAL;
                OBJECT_SET(
                  JSON,
                  TOP,
                  COPY_AND_CLEAR(*KEY),
                  MVAL,
                  ASSOC,
                  CONTAINER_TYPE
                );
              }
              STATE = 29;
            }
            BREAK;
          CASE MODE::ARRAY:
            IF (TYPE != KINVALIDDATATYPE) {
              AUTO& TOP = JSON->STACK[JSON->TOP].VAL;
              IF (CONTAINER_TYPE == JSONCONTAINERTYPE::COLLECTIONS) {
                COLLECTIONS::APPEND(TOP.GETOBJECTDATA(), MVAL.ASTYPEDVALUE());
              } ELSE {
                TOP.ASARRREF().APPEND(MVAL);
              }
            }
            STATE = 28;
            BREAK;
          DEFAULT:
            S_JSON_PARSER->ERROR_CODE = JSON_ERROR_SYNTAX;
            RETURN FALSE;
          }
          BUF->CLEAR();
          RESET_TYPE();
          CHECK_NON_SAFEPOINT_SURPRISE();
        }
        BREAK;

        /*<FB>*/
        /*
          : (AFTER UNQUOTED STRING)
        */
      CASE -10:
        IF (JSON->STACK[JSON->TOP].MODE == MODE::KEY) {
          STATE = 27;
          STD::SWAP(BUF, KEY);
          RESET_TYPE();
          S = -2;
        } ELSE {
          S = 3;
          BREAK;
        }
        /*</FB>*/

        /*
          :
        */
      CASE -2:
        IF (POP(JSON, MODE::KEY) && PUSH(JSON, MODE::OBJECT)) {
          STATE = 28;
          BREAK;
        }
        /*
          SYNTAX ERROR
        */
      CASE -1:
        S_JSON_PARSER->ERROR_CODE = JSON_ERROR_SYNTAX;
        RETURN FALSE;
      }
    } ELSE {
      /*
        CHANGE THE STATE AND ITERATE.
      */
      BOOL IS_TSIMPLEJSON = OPTIONS & K_JSON_FB_THRIFT_SIMPLE_JSON;
      IF (TYPE == KINDOFSTRING) {
        IF (/*<FB>*/(/*</FB>*/S == 3/*<FB>*/ || S == 30)/*</FB>*/ &&
            STATE != 8) {
          IF (STATE != 4) {
            UTF16_TO_UTF8(*BUF, B);
          } ELSE {
            SWITCH (B) {
            CASE 'B': BUF->APPEND('\B'); BREAK;
            CASE 'T': BUF->APPEND('\T'); BREAK;
            CASE 'N': BUF->APPEND('\N'); BREAK;
            CASE 'F': BUF->APPEND('\F'); BREAK;
            CASE 'R': BUF->APPEND('\R'); BREAK;
            DEFAULT:
              UTF16_TO_UTF8(*BUF, B);
              BREAK;
            }
          }
        } ELSE IF (S == 6) {
          IF (UNLIKELY(IS_TSIMPLEJSON)) {
            IF (UNLIKELY(B != '0'))  {
              S_JSON_PARSER->ERROR_CODE = JSON_ERROR_SYNTAX;
              RETURN FALSE;
            }
            ESCAPED_BYTES = 0;
          } ELSE {
            ESCAPED_BYTES = DEHEXCHAR(B) << 12;
          }
        } ELSE IF (S == 7) {
          IF (UNLIKELY(IS_TSIMPLEJSON)) {
            IF (UNLIKELY(B != '0'))  {
              S_JSON_PARSER->ERROR_CODE = JSON_ERROR_SYNTAX;
              RETURN FALSE;
            }
          } ELSE {
            ESCAPED_BYTES += DEHEXCHAR(B) << 8;
          }
        } ELSE IF (S == 8) {
          ESCAPED_BYTES += DEHEXCHAR(B) << 4;
        } ELSE IF (S == 3 && STATE == 8) {
          ESCAPED_BYTES += DEHEXCHAR(B);
          IF (UNLIKELY(IS_TSIMPLEJSON)) {
            BUF->APPEND((CHAR)ESCAPED_BYTES);
          } ELSE {
            UTF16_TO_UTF8(*BUF, ESCAPED_BYTES);
          }
        }
      } ELSE IF ((TYPE == KINVALIDDATATYPE || TYPE == KINDOFNULL) &&
                 (C == S_DIG || C == S_ZER)) {
        TYPE = KINDOFINT64;
        BUF->APPEND((CHAR)B);
      } ELSE IF (TYPE == KINDOFINT64 && S == 24) {
        TYPE = KINDOFDOUBLE;
        BUF->APPEND((CHAR)B);
      } ELSE IF ((TYPE == KINVALIDDATATYPE || TYPE == KINDOFNULL ||
                  TYPE == KINDOFINT64) &&
                 C == S_DOT) {
        TYPE = KINDOFDOUBLE;
        BUF->APPEND((CHAR)B);
      } ELSE IF (TYPE != KINDOFSTRING && C == S_QUO) {
        TYPE = KINDOFSTRING;
        /*<FB>*/QCHR = B;/*</FB>*/
      } ELSE IF ((TYPE == KINVALIDDATATYPE || TYPE == KINDOFNULL ||
                  TYPE == KINDOFINT64 || TYPE == KINDOFDOUBLE) &&
                 ((STATE == 12 && S == 9) ||
                  (STATE == 16 && S == 9))) {
        TYPE = KINDOFBOOLEAN;
      } ELSE IF (TYPE == KINVALIDDATATYPE && STATE == 19 && S == 9) {
        TYPE = KINDOFNULL;
      } ELSE IF (TYPE != KINDOFSTRING && C > S_WSP) {
        UTF16_TO_UTF8(*BUF, B);
      }

      STATE = S;
    }
  }

  IF (STATE == 9 && POP(JSON, MODE::DONE)) {
    S_JSON_PARSER->ERROR_CODE = JSON_ERROR_NONE;
    RETURN TRUE;
  }

  S_JSON_PARSER->ERROR_CODE = JSON_ERROR_SYNTAX;
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 387874_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
METHOD* INSTANCEKLASS::UNCACHED_LOOKUP_METHOD(CONST SYMBOL* NAME,
                                              CONST SYMBOL* SIGNATURE,
                                              OVERPASSLOOKUPMODE OVERPASS_MODE,
                                              PRIVATELOOKUPMODE PRIVATE_MODE) CONST {
  OVERPASSLOOKUPMODE OVERPASS_LOCAL_MODE = OVERPASS_MODE;
  CONST KLASS* KLASS = THIS;
  WHILE (KLASS != NULL) {
    METHOD* CONST METHOD = INSTANCEKLASS::CAST(KLASS)->FIND_METHOD_IMPL(NAME,
                                                                        SIGNATURE,
                                                                        OVERPASS_LOCAL_MODE,
                                                                        FIND_STATIC,
                                                                        PRIVATE_MODE);
    IF (METHOD != NULL) {
      RETURN METHOD;
    }
    KLASS = KLASS->SUPER();
    OVERPASS_LOCAL_MODE = SKIP_OVERPASS;   // ALWAYS IGNORE OVERPASS METHODS IN SUPERCLASSES
  }
  RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216965_CWE-617.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MULTI_UPDATE::INITIALIZE_TABLES(JOIN *JOIN)
{
  TABLE_LIST *TABLE_REF;
  DBUG_ENTER("INITIALIZE_TABLES");

  IF (UNLIKELY((THD->VARIABLES.OPTION_BITS & OPTION_SAFE_UPDATES) &&
               ERROR_IF_FULL_JOIN(JOIN)))
    DBUG_RETURN(1);
  MAIN_TABLE=JOIN->JOIN_TAB->TABLE;
  TABLE_TO_UPDATE= 0;

  /* ANY UPDATE HAS AT LEAST ONE PAIR (FIELD, VALUE) */
  DBUG_ASSERT(FIELDS->ELEMENTS);
  /*
   ONLY ONE TABLE MAY BE MODIFIED BY UPDATE OF AN UPDATABLE VIEW.
   FOR AN UPDATABLE VIEW FIRST_TABLE_FOR_UPDATE INDICATES THIS
   TABLE.
   FOR A REGULAR MULTI-UPDATE IT REFERS TO SOME UPDATED TABLE.
  */ 
  TABLE *FIRST_TABLE_FOR_UPDATE= ((ITEM_FIELD *) FIELDS->HEAD())->FIELD->TABLE;

  /* CREATE A TEMPORARY TABLE FOR KEYS TO ALL TABLES, EXCEPT MAIN TABLE */
  FOR (TABLE_REF= UPDATE_TABLES; TABLE_REF; TABLE_REF= TABLE_REF->NEXT_LOCAL)
  {
    TABLE *TABLE=TABLE_REF->TABLE;
    UINT CNT= TABLE_REF->SHARED;
    LIST<ITEM> TEMP_FIELDS;
    ORDER     GROUP;
    TMP_TABLE_PARAM *TMP_PARAM;

    IF (IGNORE)
      TABLE->FILE->EXTRA(HA_EXTRA_IGNORE_DUP_KEY);
    IF (TABLE == MAIN_TABLE)			// FIRST TABLE IN JOIN
    {
      IF (SAFE_UPDATE_ON_FLY(THD, JOIN->JOIN_TAB, TABLE_REF, ALL_TABLES))
      {
	TABLE_TO_UPDATE= TABLE;			// UPDATE TABLE ON THE FLY
        HAS_VERS_FIELDS= TABLE->VERS_CHECK_UPDATE(*FIELDS);
	CONTINUE;
      }
    }
    TABLE->PREPARE_FOR_POSITION();
    JOIN->MAP2TABLE[TABLE->TABLENR]->KEEP_CURRENT_ROWID= TRUE;

    /*
      ENABLE UNCACHEABLE FLAG IF WE UPDATE A VIEW WITH CHECK OPTION
      AND CHECK OPTION HAS A SUBSELECT, OTHERWISE, THE CHECK OPTION
      CAN BE EVALUATED AFTER THE SUBSELECT WAS FREED AS INDEPENDENT
      (SEE FULL_LOCAL IN JOIN::JOIN_FREE()).
    */
    IF (TABLE_REF->CHECK_OPTION && !JOIN->SELECT_LEX->UNCACHEABLE)
    {
      SELECT_LEX_UNIT *TMP_UNIT;
      SELECT_LEX *SL;
      FOR (TMP_UNIT= JOIN->SELECT_LEX->FIRST_INNER_UNIT();
           TMP_UNIT;
           TMP_UNIT= TMP_UNIT->NEXT_UNIT())
      {
        FOR (SL= TMP_UNIT->FIRST_SELECT(); SL; SL= SL->NEXT_SELECT())
        {
          IF (SL->MASTER_UNIT()->ITEM)
          {
            JOIN->SELECT_LEX->UNCACHEABLE|= UNCACHEABLE_CHECKOPTION;
            GOTO LOOP_END;
          }
        }
      }
    }
LOOP_END:

    IF (TABLE == FIRST_TABLE_FOR_UPDATE && TABLE_REF->CHECK_OPTION)
    {
      TABLE_MAP UNUPDATED_TABLES= TABLE_REF->CHECK_OPTION->USED_TABLES() &
                                  ~FIRST_TABLE_FOR_UPDATE->MAP;
      LIST_ITERATOR<TABLE_LIST> TI(*LEAVES);
      TABLE_LIST *TBL_REF;
      WHILE ((TBL_REF= TI++) && UNUPDATED_TABLES)
      {
        IF (UNUPDATED_TABLES & TBL_REF->TABLE->MAP)
          UNUPDATED_TABLES&= ~TBL_REF->TABLE->MAP;
        ELSE
          CONTINUE;
        IF (UNUPDATED_CHECK_OPT_TABLES.PUSH_BACK(TBL_REF->TABLE))
          DBUG_RETURN(1);
      }
    }

    TMP_PARAM= TMP_TABLE_PARAM+CNT;

    /*
      CREATE A TEMPORARY TABLE TO STORE ALL FIELDS THAT ARE CHANGED FOR THIS
      TABLE. THE FIRST FIELD IN THE TEMPORARY TABLE IS A POINTER TO THE
      ORIGINAL ROW SO THAT WE CAN FIND AND UPDATE IT. FOR THE UPDATABLE
      VIEW A FEW FOLLOWING FIELDS ARE ROWIDS OF TABLES USED IN THE CHECK
      OPTION CONDITION.
    */

    LIST_ITERATOR_FAST<TABLE> TBL_IT(UNUPDATED_CHECK_OPT_TABLES);
    TABLE *TBL= TABLE;
    DO
    {
      LEX_CSTRING FIELD_NAME;
      FIELD_NAME.STR= TBL->ALIAS.C_PTR();
      FIELD_NAME.LENGTH= STRLEN(FIELD_NAME.STR);
      /*
        SIGNAL EACH TABLE (INCLUDING TABLES REFERENCED BY WITH CHECK OPTION
        CLAUSE) FOR WHICH WE WILL STORE ROW POSITION IN THE TEMPORARY TABLE
        THAT WE NEED A POSITION TO BE READ FIRST.
      */
      TBL->PREPARE_FOR_POSITION();
      JOIN->MAP2TABLE[TBL->TABLENR]->KEEP_CURRENT_ROWID= TRUE;

      ITEM_TEMPTABLE_ROWID *ITEM=
        NEW (THD->MEM_ROOT) ITEM_TEMPTABLE_ROWID(TBL);
      IF (!ITEM)
         DBUG_RETURN(1);
      ITEM->FIX_FIELDS(THD, 0);
      IF (TEMP_FIELDS.PUSH_BACK(ITEM, THD->MEM_ROOT))
        DBUG_RETURN(1);
    } WHILE ((TBL= TBL_IT++));

    TEMP_FIELDS.APPEND(FIELDS_FOR_TABLE[CNT]);

    /* MAKE AN UNIQUE KEY OVER THE FIRST FIELD TO AVOID DUPLICATED UPDATES */
    BZERO((CHAR*) &GROUP, SIZEOF(GROUP));
    GROUP.DIRECTION= ORDER::ORDER_ASC;
    GROUP.ITEM= (ITEM**) TEMP_FIELDS.HEAD_REF();

    TMP_PARAM->QUICK_GROUP= 1;
    TMP_PARAM->FIELD_COUNT= TEMP_FIELDS.ELEMENTS;
    TMP_PARAM->FUNC_COUNT=  TEMP_FIELDS.ELEMENTS - 1;
    CALC_GROUP_BUFFER(TMP_PARAM, &GROUP);
    /* SMALL TABLE, IGNORE SQL_BIG_TABLES */
    MY_BOOL SAVE_BIG_TABLES= THD->VARIABLES.BIG_TABLES; 
    THD->VARIABLES.BIG_TABLES= FALSE;
    TMP_TABLES[CNT]=CREATE_TMP_TABLE(THD, TMP_PARAM, TEMP_FIELDS,
                                     (ORDER*) &GROUP, 0, 0,
                                     TMP_TABLE_ALL_COLUMNS, HA_POS_ERROR, &EMPTY_CLEX_STR);
    THD->VARIABLES.BIG_TABLES= SAVE_BIG_TABLES;
    IF (!TMP_TABLES[CNT])
      DBUG_RETURN(1);
    TMP_TABLES[CNT]->FILE->EXTRA(HA_EXTRA_WRITE_CACHE);
  }
  JOIN->TMP_TABLE_KEEP_CURRENT_ROWID= TRUE;
  DBUG_RETURN(0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216861_CWE-125.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EC_GROUP *EC_GROUP_NEW_FROM_ECPARAMETERS(CONST ECPARAMETERS *PARAMS)
{
    INT OK = 0, TMP;
    EC_GROUP *RET = NULL, *DUP = NULL;
    BIGNUM *P = NULL, *A = NULL, *B = NULL;
    EC_POINT *POINT = NULL;
    LONG FIELD_BITS;
    INT CURVE_NAME = NID_UNDEF;
    BN_CTX *CTX = NULL;

    IF (!PARAMS->FIELDID || !PARAMS->FIELDID->FIELDTYPE ||
        !PARAMS->FIELDID->P.PTR) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
        GOTO ERR;
    }

    /*
     * NOW EXTRACT THE CURVE PARAMETERS A AND B. NOTE THAT, ALTHOUGH SEC 1
     * SPECIFIES THE LENGTH OF THEIR ENCODINGS, HISTORICAL VERSIONS OF OPENSSL
     * ENCODED THEM INCORRECTLY, SO WE MUST ACCEPT ANY LENGTH FOR BACKWARDS
     * COMPATIBILITY.
     */
    IF (!PARAMS->CURVE || !PARAMS->CURVE->A ||
        !PARAMS->CURVE->A->DATA || !PARAMS->CURVE->B ||
        !PARAMS->CURVE->B->DATA) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
        GOTO ERR;
    }
    A = BN_BIN2BN(PARAMS->CURVE->A->DATA, PARAMS->CURVE->A->LENGTH, NULL);
    IF (A == NULL) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
        GOTO ERR;
    }
    B = BN_BIN2BN(PARAMS->CURVE->B->DATA, PARAMS->CURVE->B->LENGTH, NULL);
    IF (B == NULL) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
        GOTO ERR;
    }

    /* GET THE FIELD PARAMETERS */
    TMP = OBJ_OBJ2NID(PARAMS->FIELDID->FIELDTYPE);
    IF (TMP == NID_X9_62_CHARACTERISTIC_TWO_FIELD)
#IFDEF OPENSSL_NO_EC2M
    {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_GF2M_NOT_SUPPORTED);
        GOTO ERR;
    }
#ELSE
    {
        X9_62_CHARACTERISTIC_TWO *CHAR_TWO;

        CHAR_TWO = PARAMS->FIELDID->P.CHAR_TWO;

        FIELD_BITS = CHAR_TWO->M;
        IF (FIELD_BITS > OPENSSL_ECC_MAX_FIELD_BITS) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
            GOTO ERR;
        }

        IF ((P = BN_NEW()) == NULL) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
            GOTO ERR;
        }

        /* GET THE BASE TYPE */
        TMP = OBJ_OBJ2NID(CHAR_TWO->TYPE);

        IF (TMP == NID_X9_62_TPBASIS) {
            LONG TMP_LONG;

            IF (!CHAR_TWO->P.TPBASIS) {
                ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
                GOTO ERR;
            }

            TMP_LONG = ASN1_INTEGER_GET(CHAR_TWO->P.TPBASIS);

            IF (!(CHAR_TWO->M > TMP_LONG && TMP_LONG > 0)) {
                ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
                      EC_R_INVALID_TRINOMIAL_BASIS);
                GOTO ERR;
            }

            /* CREATE THE POLYNOMIAL */
            IF (!BN_SET_BIT(P, (INT)CHAR_TWO->M))
                GOTO ERR;
            IF (!BN_SET_BIT(P, (INT)TMP_LONG))
                GOTO ERR;
            IF (!BN_SET_BIT(P, 0))
                GOTO ERR;
        } ELSE IF (TMP == NID_X9_62_PPBASIS) {
            X9_62_PENTANOMIAL *PENTA;

            PENTA = CHAR_TWO->P.PPBASIS;
            IF (!PENTA) {
                ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
                GOTO ERR;
            }

            IF (!
                (CHAR_TWO->M > PENTA->K3 && PENTA->K3 > PENTA->K2
                 && PENTA->K2 > PENTA->K1 && PENTA->K1 > 0)) {
                ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS,
                      EC_R_INVALID_PENTANOMIAL_BASIS);
                GOTO ERR;
            }

            /* CREATE THE POLYNOMIAL */
            IF (!BN_SET_BIT(P, (INT)CHAR_TWO->M))
                GOTO ERR;
            IF (!BN_SET_BIT(P, (INT)PENTA->K1))
                GOTO ERR;
            IF (!BN_SET_BIT(P, (INT)PENTA->K2))
                GOTO ERR;
            IF (!BN_SET_BIT(P, (INT)PENTA->K3))
                GOTO ERR;
            IF (!BN_SET_BIT(P, 0))
                GOTO ERR;
        } ELSE IF (TMP == NID_X9_62_ONBASIS) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_NOT_IMPLEMENTED);
            GOTO ERR;
        } ELSE {                /* ERROR */

            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
            GOTO ERR;
        }

        /* CREATE THE EC_GROUP STRUCTURE */
        RET = EC_GROUP_NEW_CURVE_GF2M(P, A, B, NULL);
    }
#ENDIF
    ELSE IF (TMP == NID_X9_62_PRIME_FIELD) {
        /* WE HAVE A CURVE OVER A PRIME FIELD */
        /* EXTRACT THE PRIME NUMBER */
        IF (!PARAMS->FIELDID->P.PRIME) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
            GOTO ERR;
        }
        P = ASN1_INTEGER_TO_BN(PARAMS->FIELDID->P.PRIME, NULL);
        IF (P == NULL) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
            GOTO ERR;
        }

        IF (BN_IS_NEGATIVE(P) || BN_IS_ZERO(P)) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
            GOTO ERR;
        }

        FIELD_BITS = BN_NUM_BITS(P);
        IF (FIELD_BITS > OPENSSL_ECC_MAX_FIELD_BITS) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_FIELD_TOO_LARGE);
            GOTO ERR;
        }

        /* CREATE THE EC_GROUP STRUCTURE */
        RET = EC_GROUP_NEW_CURVE_GFP(P, A, B, NULL);
    } ELSE {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_FIELD);
        GOTO ERR;
    }

    IF (RET == NULL) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        GOTO ERR;
    }

    /* EXTRACT SEED (OPTIONAL) */
    IF (PARAMS->CURVE->SEED != NULL) {
        OPENSSL_FREE(RET->SEED);
        IF ((RET->SEED = OPENSSL_MALLOC(PARAMS->CURVE->SEED->LENGTH)) == NULL) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_MALLOC_FAILURE);
            GOTO ERR;
        }
        MEMCPY(RET->SEED, PARAMS->CURVE->SEED->DATA,
               PARAMS->CURVE->SEED->LENGTH);
        RET->SEED_LEN = PARAMS->CURVE->SEED->LENGTH;
    }

    IF (!PARAMS->ORDER || !PARAMS->BASE || !PARAMS->BASE->DATA) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_ASN1_ERROR);
        GOTO ERR;
    }

    IF ((POINT = EC_POINT_NEW(RET)) == NULL)
        GOTO ERR;

    /* SET THE POINT CONVERSION FORM */
    EC_GROUP_SET_POINT_CONVERSION_FORM(RET, (POINT_CONVERSION_FORM_T)
                                       (PARAMS->BASE->DATA[0] & ~0X01));

    /* EXTRACT THE EC POINT */
    IF (!EC_POINT_OCT2POINT(RET, POINT, PARAMS->BASE->DATA,
                            PARAMS->BASE->LENGTH, NULL)) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        GOTO ERR;
    }

    /* EXTRACT THE ORDER */
    IF ((A = ASN1_INTEGER_TO_BN(PARAMS->ORDER, A)) == NULL) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
        GOTO ERR;
    }
    IF (BN_IS_NEGATIVE(A) || BN_IS_ZERO(A)) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
        GOTO ERR;
    }
    IF (BN_NUM_BITS(A) > (INT)FIELD_BITS + 1) { /* HASSE BOUND */
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, EC_R_INVALID_GROUP_ORDER);
        GOTO ERR;
    }

    /* EXTRACT THE COFACTOR (OPTIONAL) */
    IF (PARAMS->COFACTOR == NULL) {
        BN_FREE(B);
        B = NULL;
    } ELSE IF ((B = ASN1_INTEGER_TO_BN(PARAMS->COFACTOR, B)) == NULL) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_ASN1_LIB);
        GOTO ERR;
    }
    /* SET THE GENERATOR, ORDER AND COFACTOR (IF PRESENT) */
    IF (!EC_GROUP_SET_GENERATOR(RET, POINT, A, B)) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        GOTO ERR;
    }

    /*
     * CHECK IF THE EXPLICIT PARAMETERS GROUP JUST CREATED MATCHES ONE OF THE
     * BUILT-IN CURVES.
     *
     * WE CREATE A COPY OF THE GROUP JUST BUILT, SO THAT WE CAN REMOVE OPTIONAL
     * FIELDS FOR THE LOOKUP: WE DO THIS TO AVOID THE POSSIBILITY THAT ONE OF
     * THE OPTIONAL PARAMETERS IS USED TO FORCE THE LIBRARY INTO USING A LESS
     * PERFORMANT AND LESS SECURE EC_METHOD INSTEAD OF THE SPECIALIZED ONE.
     * IN ANY CASE, `SEED` IS NOT REALLY USED IN ANY COMPUTATION, WHILE A
     * COFACTOR DIFFERENT FROM THE ONE IN THE BUILT-IN TABLE IS JUST
     * MATHEMATICALLY WRONG ANYWAY AND SHOULD NOT BE USED.
     */
    IF ((CTX = BN_CTX_NEW()) == NULL) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_BN_LIB);
        GOTO ERR;
    }
    IF ((DUP = EC_GROUP_DUP(RET)) == NULL
            || EC_GROUP_SET_SEED(DUP, NULL, 0) != 1
            || !EC_GROUP_SET_GENERATOR(DUP, POINT, A, NULL)) {
        ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
        GOTO ERR;
    }
    IF ((CURVE_NAME = EC_CURVE_NID_FROM_PARAMS(DUP, CTX)) != NID_UNDEF) {
        /*
         * THE INPUT EXPLICIT PARAMETERS SUCCESSFULLY MATCHED ONE OF THE
         * BUILT-IN CURVES: OFTEN FOR BUILT-IN CURVES WE HAVE SPECIALIZED
         * METHODS WITH BETTER PERFORMANCE AND HARDENING.
         *
         * IN THIS CASE WE REPLACE THE `EC_GROUP` CREATED THROUGH EXPLICIT
         * PARAMETERS WITH ONE CREATED FROM A NAMED GROUP.
         */
        EC_GROUP *NAMED_GROUP = NULL;

#IFNDEF OPENSSL_NO_EC_NISTP_64_GCC_128
        /*
         * NID_WAP_WSG_IDM_ECID_WTLS12 AND NID_SECP224R1 ARE BOTH ALIASES FOR
         * THE SAME CURVE, WE PREFER THE SECP NID WHEN MATCHING EXPLICIT
         * PARAMETERS AS THAT IS ASSOCIATED WITH A SPECIALIZED EC_METHOD.
         */
        IF (CURVE_NAME == NID_WAP_WSG_IDM_ECID_WTLS12)
            CURVE_NAME = NID_SECP224R1;
#ENDIF /* !DEF(OPENSSL_NO_EC_NISTP_64_GCC_128) */

        IF ((NAMED_GROUP = EC_GROUP_NEW_BY_CURVE_NAME(CURVE_NAME)) == NULL) {
            ECERR(EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS, ERR_R_EC_LIB);
            GOTO ERR;
        }
        EC_GROUP_FREE(RET);
        RET = NAMED_GROUP;

        /*
         * SET THE FLAG SO THAT EC_GROUPS CREATED FROM EXPLICIT PARAMETERS ARE
         * SERIALIZED USING EXPLICIT PARAMETERS BY DEFAULT.
         */
        EC_GROUP_SET_ASN1_FLAG(RET, OPENSSL_EC_EXPLICIT_CURVE);

        /*
         * IF THE INPUT PARAMS DO NOT CONTAIN THE OPTIONAL SEED FIELD WE MAKE
         * SURE IT IS NOT ADDED TO THE RETURNED GROUP.
         *
         * THE SEED FIELD IS NOT REALLY USED INSIDE LIBCRYPTO ANYWAY, AND
         * ADDING IT TO PARSED EXPLICIT PARAMETER KEYS WOULD ALTER THEIR DER
         * ENCODING OUTPUT (BECAUSE OF THE EXTRA FIELD) WHICH COULD IMPACT
         * APPLICATIONS FINGERPRINTING KEYS BY THEIR DER ENCODING.
         */
        IF (PARAMS->CURVE->SEED == NULL) {
            IF (EC_GROUP_SET_SEED(RET, NULL, 0) != 1)
                GOTO ERR;
        }
    }

    OK = 1;

 ERR:
    IF (!OK) {
        EC_GROUP_FREE(RET);
        RET = NULL;
    }
    EC_GROUP_FREE(DUP);

    BN_FREE(P);
    BN_FREE(A);
    BN_FREE(B);
    EC_POINT_FREE(POINT);

    BN_CTX_FREE(CTX);

    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 212871_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STD::STRING CONTROLLER::BOOKMARK(
		CONST STD::STRING& URL,
		CONST STD::STRING& TITLE,
		CONST STD::STRING& DESCRIPTION,
		CONST STD::STRING& FEED_TITLE)
{
	STD::STRING BOOKMARK_CMD = CFG.GET_CONFIGVALUE("BOOKMARK-CMD");
	BOOL IS_INTERACTIVE = CFG.GET_CONFIGVALUE_AS_BOOL("BOOKMARK-INTERACTIVE");
	IF (BOOKMARK_CMD.LENGTH() > 0) {
		STD::STRING CMDLINE = STRPRINTF::FMT("%S '%S' %S %S %S",
		                                       BOOKMARK_CMD,
		                                       UTILS::REPLACE_ALL(URL,"'", "%27"),
		                                       QUOTE_EMPTY(STFL::QUOTE(TITLE)),
		                                       QUOTE_EMPTY(STFL::QUOTE(DESCRIPTION)),
		                                       QUOTE_EMPTY(STFL::QUOTE(FEED_TITLE)));

		LOG(LEVEL::DEBUG, "CONTROLLER::BOOKMARK: CMD = %S", CMDLINE);

		IF (IS_INTERACTIVE) {
			V->PUSH_EMPTY_FORMACTION();
			STFL::RESET();
			UTILS::RUN_INTERACTIVELY(CMDLINE, "CONTROLLER::BOOKMARK");
			V->POP_CURRENT_FORMACTION();
			RETURN "";
		} ELSE {
			CHAR * MY_ARGV[4];
			MY_ARGV[0] = CONST_CAST<CHAR *>("/BIN/SH");
			MY_ARGV[1] = CONST_CAST<CHAR *>("-C");
			MY_ARGV[2] = CONST_CAST<CHAR *>(CMDLINE.C_STR());
			MY_ARGV[3] = NULLPTR;
			RETURN UTILS::RUN_PROGRAM(MY_ARGV, "");
		}
	} ELSE {
		RETURN _("BOOKMARKING SUPPORT IS NOT CONFIGURED. PLEASE SET THE CONFIGURATION VARIABLE `BOOKMARK-CMD' ACCORDINGLY.");
	}
}
ASSISTANT
CWE-78: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN OS COMMAND ('OS COMMAND INJECTION')
--------------------------------------------------
File: 393503_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SQINTEGER _CLOSURE_ACALL(HSQUIRRELVM V,SQBOOL RAISEERROR)
{
    SQARRAY *APARAMS=_ARRAY(STACK_GET(V,2));
    SQINTEGER NPARAMS=APARAMS->SIZE();
    V->PUSH(STACK_GET(V,1));
    FOR(SQINTEGER I=0;I<NPARAMS;I++)V->PUSH(APARAMS->_VALUES[I]);
    RETURN SQ_SUCCEEDED(SQ_CALL(V,NPARAMS,SQTRUE,RAISEERROR))?1:SQ_ERROR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 231690_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ONSERVERREADDATAFROMOPEN(
    QUICSERVERCONNECTIONSTATE& CONN,
    SERVEREVENTS::READDATA& READDATA) {
  CHECK_EQ(CONN.STATE, SERVERSTATE::OPEN);
  // DON'T BOTHER PARSING IF THE DATA IS EMPTY.
  IF (!READDATA.NETWORKDATA.DATA ||
      READDATA.NETWORKDATA.DATA->COMPUTECHAINDATALENGTH() == 0) {
    RETURN;
  }
  IF (!CONN.READCODEC) {
    // FIRST PACKET FROM THE PEER
    FOLLY::IO::CURSOR CURSOR(READDATA.NETWORKDATA.DATA.GET());
    AUTO INITIALBYTE = CURSOR.READBE<UINT8_T>();
    AUTO PARSEDLONGHEADER = PARSELONGHEADERINVARIANT(INITIALBYTE, CURSOR);
    IF (!PARSEDLONGHEADER) {
      VLOG(4) << "COULD NOT PARSE INITIAL PACKET HEADER";
      IF (CONN.QLOGGER) {
        CONN.QLOGGER->ADDPACKETDROP(
            0,
            QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                PACKETDROPREASON::PARSE_ERROR));
      }
      QUIC_STATS(
          CONN.STATSCALLBACK, ONPACKETDROPPED, PACKETDROPREASON::PARSE_ERROR);
      RETURN;
    }
    QUICVERSION VERSION = PARSEDLONGHEADER->INVARIANT.VERSION;
    IF (VERSION == QUICVERSION::VERSION_NEGOTIATION) {
      VLOG(4) << "SERVER DROPPIONG VN PACKET";
      IF (CONN.QLOGGER) {
        CONN.QLOGGER->ADDPACKETDROP(
            0,
            QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                PACKETDROPREASON::INVALID_PACKET));
      }
      QUIC_STATS(
          CONN.STATSCALLBACK,
          ONPACKETDROPPED,
          PACKETDROPREASON::INVALID_PACKET);
      RETURN;
    }

    CONST AUTO& CLIENTCONNECTIONID = PARSEDLONGHEADER->INVARIANT.SRCCONNID;
    CONST AUTO& INITIALDESTINATIONCONNECTIONID =
        PARSEDLONGHEADER->INVARIANT.DSTCONNID;

    IF (INITIALDESTINATIONCONNECTIONID.SIZE() < KDEFAULTCONNECTIONIDSIZE) {
      VLOG(4) << "INITIAL CONNECTIONID TOO SMALL";
      IF (CONN.QLOGGER) {
        CONN.QLOGGER->ADDPACKETDROP(
            0,
            QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                PACKETDROPREASON::INITIAL_CONNID_SMALL));
      }
      QUIC_STATS(
          CONN.STATSCALLBACK,
          ONPACKETDROPPED,
          PACKETDROPREASON::INITIAL_CONNID_SMALL);
      RETURN;
    }

    CHECK(CONN.CONNIDALGO) << "CONNECTIONIDALGO IS NOT SET.";
    CHECK(!CONN.SERVERCONNECTIONID.HAS_VALUE());
    // SERVERCONNIDPARAMS MUST BE SET BY THE QUICSERVERTRANSPORT
    CHECK(CONN.SERVERCONNIDPARAMS);

    AUTO NEWSERVERCONNIDDATA = CONN.CREATEANDADDNEWSELFCONNID();
    CHECK(NEWSERVERCONNIDDATA.HAS_VALUE());
    CONN.SERVERCONNECTIONID = NEWSERVERCONNIDDATA->CONNID;

    QUIC_STATS(CONN.STATSCALLBACK, ONSTATELESSRESET);
    CONN.SERVERHANDSHAKELAYER->ACCEPT(
        STD::MAKE_SHARED<SERVERTRANSPORTPARAMETERSEXTENSION>(
            VERSION,
            CONN.TRANSPORTSETTINGS.ADVERTISEDINITIALCONNECTIONWINDOWSIZE,
            CONN.TRANSPORTSETTINGS.ADVERTISEDINITIALBIDILOCALSTREAMWINDOWSIZE,
            CONN.TRANSPORTSETTINGS.ADVERTISEDINITIALBIDIREMOTESTREAMWINDOWSIZE,
            CONN.TRANSPORTSETTINGS.ADVERTISEDINITIALUNISTREAMWINDOWSIZE,
            CONN.TRANSPORTSETTINGS.ADVERTISEDINITIALMAXSTREAMSBIDI,
            CONN.TRANSPORTSETTINGS.ADVERTISEDINITIALMAXSTREAMSUNI,
            CONN.TRANSPORTSETTINGS.IDLETIMEOUT,
            CONN.TRANSPORTSETTINGS.ACKDELAYEXPONENT,
            CONN.TRANSPORTSETTINGS.MAXRECVPACKETSIZE,
            CONN.TRANSPORTSETTINGS.PARTIALRELIABILITYENABLED,
            *NEWSERVERCONNIDDATA->TOKEN,
            CONN.SERVERCONNECTIONID.VALUE(),
            INITIALDESTINATIONCONNECTIONID));
    CONN.TRANSPORTPARAMETERSENCODED = TRUE;
    CONST CRYPTOFACTORY& CRYPTOFACTORY =
        CONN.SERVERHANDSHAKELAYER->GETCRYPTOFACTORY();
    CONN.READCODEC = STD::MAKE_UNIQUE<QUICREADCODEC>(QUICNODETYPE::SERVER);
    CONN.READCODEC->SETINITIALREADCIPHER(CRYPTOFACTORY.GETCLIENTINITIALCIPHER(
        INITIALDESTINATIONCONNECTIONID, VERSION));
    CONN.READCODEC->SETCLIENTCONNECTIONID(CLIENTCONNECTIONID);
    CONN.READCODEC->SETSERVERCONNECTIONID(*CONN.SERVERCONNECTIONID);
    IF (CONN.QLOGGER) {
      CONN.QLOGGER->SETSCID(CONN.SERVERCONNECTIONID);
      CONN.QLOGGER->SETDCID(INITIALDESTINATIONCONNECTIONID);
    }
    CONN.READCODEC->SETCODECPARAMETERS(
        CODECPARAMETERS(CONN.PEERACKDELAYEXPONENT, VERSION));
    CONN.INITIALWRITECIPHER = CRYPTOFACTORY.GETSERVERINITIALCIPHER(
        INITIALDESTINATIONCONNECTIONID, VERSION);

    CONN.READCODEC->SETINITIALHEADERCIPHER(
        CRYPTOFACTORY.MAKECLIENTINITIALHEADERCIPHER(
            INITIALDESTINATIONCONNECTIONID, VERSION));
    CONN.INITIALHEADERCIPHER = CRYPTOFACTORY.MAKESERVERINITIALHEADERCIPHER(
        INITIALDESTINATIONCONNECTIONID, VERSION);
    CONN.PEERADDRESS = CONN.ORIGINALPEERADDRESS;
  }
  BUFQUEUE UDPDATA;
  UDPDATA.APPEND(STD::MOVE(READDATA.NETWORKDATA.DATA));
  FOR (UINT16_T PROCESSEDPACKETS = 0;
       !UDPDATA.EMPTY() && PROCESSEDPACKETS < KMAXNUMCOALESCEDPACKETS;
       PROCESSEDPACKETS++) {
    SIZE_T DATASIZE = UDPDATA.CHAINLENGTH();
    AUTO PARSEDPACKET = CONN.READCODEC->PARSEPACKET(UDPDATA, CONN.ACKSTATES);
    SIZE_T PACKETSIZE = DATASIZE - UDPDATA.CHAINLENGTH();

    SWITCH (PARSEDPACKET.TYPE()) {
      CASE CODECRESULT::TYPE::CIPHER_UNAVAILABLE: {
        HANDLECIPHERUNAVAILABLE(
            PARSEDPACKET.CIPHERUNAVAILABLE(), CONN, PACKETSIZE, READDATA);
        BREAK;
      }
      CASE CODECRESULT::TYPE::RETRY: {
        VLOG(10) << "DROP BECAUSE THE SERVER IS NOT SUPPOSED TO "
                 << "RECEIVE A RETRY " << CONN;
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(PACKETSIZE, KRETRY);
        }
        QUIC_TRACE(PACKET_DROP, CONN, "RETRY");
        BREAK;
      }
      CASE CODECRESULT::TYPE::STATELESS_RESET: {
        VLOG(10) << "DROP BECAUSE RESET " << CONN;
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(PACKETSIZE, KRESET);
        }
        QUIC_TRACE(PACKET_DROP, CONN, "RESET");
        BREAK;
      }
      CASE CODECRESULT::TYPE::NOTHING: {
        VLOG(10) << "DROP CIPHER UNAVAILABLE, NO DATA " << CONN;
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(PACKETSIZE, KCIPHERUNAVAILABLE);
        }
        QUIC_TRACE(PACKET_DROP, CONN, "CIPHER_UNAVAILABLE");
        BREAK;
      }
      CASE CODECRESULT::TYPE::REGULAR_PACKET:
        BREAK;
    }

    REGULARQUICPACKET* REGULAROPTIONAL = PARSEDPACKET.REGULARPACKET();
    IF (!REGULAROPTIONAL) {
      // WE WERE UNABLE TO PARSE THE PACKET, DROP FOR NOW. ALL THE DROP REASONS
      // SHOULD HAVE ALREADY BEEN LOGGED INTO QLOGGER AND QUICTRACE INSIDE THE
      // PREVIOUS SWITCH-CASE BLOCK. WE JUST NEED TO UPDATE QUIC_STATS HERE.
      VLOG(10) << "NOT ABLE TO PARSE QUIC PACKET " << CONN;
      QUIC_STATS(
          CONN.STATSCALLBACK, ONPACKETDROPPED, PACKETDROPREASON::PARSE_ERROR);
      CONTINUE;
    }

    AUTO PROTECTIONLEVEL = REGULAROPTIONAL->HEADER.GETPROTECTIONTYPE();
    AUTO ENCRYPTIONLEVEL = PROTECTIONTYPETOENCRYPTIONLEVEL(PROTECTIONLEVEL);

    AUTO PACKETNUM = REGULAROPTIONAL->HEADER.GETPACKETSEQUENCENUM();
    AUTO PACKETNUMBERSPACE = REGULAROPTIONAL->HEADER.GETPACKETNUMBERSPACE();

    // TODO: ENFORCE CONSTRAINTS ON OTHER PROTECTION LEVELS.
    AUTO& REGULARPACKET = *REGULAROPTIONAL;

    BOOL ISPROTECTEDPACKET = PROTECTIONLEVEL == PROTECTIONTYPE::ZERORTT ||
        PROTECTIONLEVEL == PROTECTIONTYPE::KEYPHASEZERO ||
        PROTECTIONLEVEL == PROTECTIONTYPE::KEYPHASEONE;

    IF (!ISPROTECTEDPACKET) {
      FOR (AUTO& QUICFRAME : REGULARPACKET.FRAMES) {
        AUTO ISPADDING = QUICFRAME.ASPADDINGFRAME();
        AUTO ISACK = QUICFRAME.ASREADACKFRAME();
        AUTO ISCLOSE = QUICFRAME.ASCONNECTIONCLOSEFRAME();
        AUTO ISCRYPTO = QUICFRAME.ASREADCRYPTOFRAME();
        AUTO ISPING = QUICFRAME.ASPINGFRAME();
        // TODO: ADD PATH CHALLENGE AND RESPONSE
        IF (!ISPADDING && !ISACK && !ISCLOSE && !ISCRYPTO && !ISPING) {
          QUIC_STATS(
              CONN.STATSCALLBACK,
              ONPACKETDROPPED,
              PACKETDROPREASON::PROTOCOL_VIOLATION);
          IF (CONN.QLOGGER) {
            CONN.QLOGGER->ADDPACKETDROP(
                PACKETSIZE,
                QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                    PACKETDROPREASON::PROTOCOL_VIOLATION));
          }
          THROW QUICTRANSPORTEXCEPTION(
              "INVALID FRAME", TRANSPORTERRORCODE::PROTOCOL_VIOLATION);
        }
      }
    }

    CHECK(CONN.CLIENTCONNECTIONID);
    IF (CONN.QLOGGER) {
      CONN.QLOGGER->ADDPACKET(REGULARPACKET, PACKETSIZE);
    }
    // WE ASSUME THAT THE HIGHER LAYER TAKES CARE OF VALIDATING THAT THE VERSION
    // IS SUPPORTED.
    IF (!CONN.VERSION) {
      LONGHEADER* LONGHEADER = REGULARPACKET.HEADER.ASLONG();
      IF (!LONGHEADER) {
        THROW QUICTRANSPORTEXCEPTION(
            "INVALID PACKET TYPE", TRANSPORTERRORCODE::PROTOCOL_VIOLATION);
      }
      CONN.VERSION = LONGHEADER->GETVERSION();
      IF (CONN.VERSION == QUICVERSION::MVFST_EXPERIMENTAL) {
        SETEXPERIMENTALSETTINGS(CONN);
      }
    }

    IF (CONN.PEERADDRESS != READDATA.PEER) {
      IF (ENCRYPTIONLEVEL != ENCRYPTIONLEVEL::APPDATA) {
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(
              PACKETSIZE,
              QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                  PACKETDROPREASON::PEER_ADDRESS_CHANGE));
        }
        QUIC_STATS(
            CONN.STATSCALLBACK,
            ONPACKETDROPPED,
            PACKETDROPREASON::PEER_ADDRESS_CHANGE);
        THROW QUICTRANSPORTEXCEPTION(
            "MIGRATION NOT ALLOWED DURING HANDSHAKE",
            TRANSPORTERRORCODE::INVALID_MIGRATION);
      }

      IF (CONN.TRANSPORTSETTINGS.DISABLEMIGRATION) {
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(
              PACKETSIZE,
              QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                  PACKETDROPREASON::PEER_ADDRESS_CHANGE));
        }
        QUIC_STATS(
            CONN.STATSCALLBACK,
            ONPACKETDROPPED,
            PACKETDROPREASON::PEER_ADDRESS_CHANGE);
        THROW QUICTRANSPORTEXCEPTION(
            "MIGRATION DISABLED", TRANSPORTERRORCODE::INVALID_MIGRATION);
      }
    }

    AUTO& ACKSTATE = GETACKSTATE(CONN, PACKETNUMBERSPACE);
    BOOL OUTOFORDER = UPDATELARGESTRECEIVEDPACKETNUM(
        ACKSTATE, PACKETNUM, READDATA.NETWORKDATA.RECEIVETIMEPOINT);
    IF (OUTOFORDER) {
      QUIC_STATS(CONN.STATSCALLBACK, ONOUTOFORDERPACKETRECEIVED);
    }
    DCHECK(HASRECEIVEDPACKETS(CONN));

    BOOL PKTHASRETRANSMITTABLEDATA = FALSE;
    BOOL PKTHASCRYPTODATA = FALSE;
    BOOL ISNONPROBINGPACKET = FALSE;
    BOOL HANDSHAKECONFIRMEDTHISLOOP = FALSE;

    // TODO: POSSIBLY DROP THE PACKET HERE, BUT ROLLING BACK STATE OF
    // WHAT WE'VE ALREADY PROCESSED IS DIFFICULT.
    FOR (AUTO& QUICFRAME : REGULARPACKET.FRAMES) {
      SWITCH (QUICFRAME.TYPE()) {
        CASE QUICFRAME::TYPE::READACKFRAME: {
          VLOG(10) << "SERVER RECEIVED ACK FRAME PACKET=" << PACKETNUM << " "
                   << CONN;
          ISNONPROBINGPACKET = TRUE;
          READACKFRAME& ACKFRAME = *QUICFRAME.ASREADACKFRAME();
          PROCESSACKFRAME(
              CONN,
              PACKETNUMBERSPACE,
              ACKFRAME,
              [&](CONST OUTSTANDINGPACKET& PACKET,
                  CONST QUICWRITEFRAME& PACKETFRAME,
                  CONST READACKFRAME&) {
                SWITCH (PACKETFRAME.TYPE()) {
                  CASE QUICWRITEFRAME::TYPE::WRITESTREAMFRAME: {
                    CONST WRITESTREAMFRAME& FRAME =
                        *PACKETFRAME.ASWRITESTREAMFRAME();
                    VLOG(4)
                        << "SERVER RECEIVED ACK FOR STREAM=" << FRAME.STREAMID
                        << " OFFSET=" << FRAME.OFFSET << " FIN=" << FRAME.FIN
                        << " LEN=" << FRAME.LEN << " " << CONN;
                    AUTO ACKEDSTREAM =
                        CONN.STREAMMANAGER->GETSTREAM(FRAME.STREAMID);
                    IF (ACKEDSTREAM) {
                      SENDACKSMHANDLER(*ACKEDSTREAM, FRAME);
                    }
                    BREAK;
                  }
                  CASE QUICWRITEFRAME::TYPE::WRITECRYPTOFRAME: {
                    CONST WRITECRYPTOFRAME& FRAME =
                        *PACKETFRAME.ASWRITECRYPTOFRAME();
                    AUTO CRYPTOSTREAM =
                        GETCRYPTOSTREAM(*CONN.CRYPTOSTATE, ENCRYPTIONLEVEL);
                    PROCESSCRYPTOSTREAMACK(
                        *CRYPTOSTREAM, FRAME.OFFSET, FRAME.LEN);
                    BREAK;
                  }
                  CASE QUICWRITEFRAME::TYPE::RSTSTREAMFRAME: {
                    CONST RSTSTREAMFRAME& FRAME =
                        *PACKETFRAME.ASRSTSTREAMFRAME();
                    VLOG(4) << "SERVER RECEIVED ACK FOR RESET STREAM="
                            << FRAME.STREAMID << " " << CONN;
                    AUTO STREAM = CONN.STREAMMANAGER->GETSTREAM(FRAME.STREAMID);
                    IF (STREAM) {
                      SENDRSTACKSMHANDLER(*STREAM);
                    }
                    BREAK;
                  }
                  CASE QUICWRITEFRAME::TYPE::WRITEACKFRAME: {
                    CONST WRITEACKFRAME& FRAME = *PACKETFRAME.ASWRITEACKFRAME();
                    DCHECK(!FRAME.ACKBLOCKS.EMPTY());
                    VLOG(4) << "SERVER RECEIVED ACK FOR LARGESTACKED="
                            << FRAME.ACKBLOCKS.FRONT().END << " " << CONN;
                    COMMONACKVISITORFORACKFRAME(ACKSTATE, FRAME);
                    BREAK;
                  }
                  CASE QUICWRITEFRAME::TYPE::PINGFRAME:
                    IF (!PACKET.METADATA.ISD6DPROBE) {
                      CONN.PENDINGEVENTS.CANCELPINGTIMEOUT = TRUE;
                    }
                    RETURN;
                  CASE QUICWRITEFRAME::TYPE::QUICSIMPLEFRAME: {
                    CONST QUICSIMPLEFRAME& FRAME =
                        *PACKETFRAME.ASQUICSIMPLEFRAME();
                    // ACK OF HANDSHAKEDONE IS A SERVER-SPECIFIC BEHAVIOR.
                    IF (FRAME.ASHANDSHAKEDONEFRAME() &&
                        CONN.VERSION != QUICVERSION::MVFST_D24) {
                      // CALL HANDSHAKECONFIRMED OUTSIDE OF THE PACKET
                      // PROCESSING LOOP TO AVOID A RE-ENTRANCY.
                      HANDSHAKECONFIRMEDTHISLOOP = TRUE;
                    }
                    BREAK;
                  }
                  DEFAULT: {
                    BREAK;
                  }
                }
              },
              MARKPACKETLOSS,
              READDATA.NETWORKDATA.RECEIVETIMEPOINT);
          BREAK;
        }
        CASE QUICFRAME::TYPE::RSTSTREAMFRAME: {
          RSTSTREAMFRAME& FRAME = *QUICFRAME.ASRSTSTREAMFRAME();
          VLOG(10) << "SERVER RECEIVED RESET STREAM=" << FRAME.STREAMID << " "
                   << CONN;
          PKTHASRETRANSMITTABLEDATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          AUTO STREAM = CONN.STREAMMANAGER->GETSTREAM(FRAME.STREAMID);
          IF (!STREAM) {
            BREAK;
          }
          RECEIVERSTSTREAMSMHANDLER(*STREAM, FRAME);
          BREAK;
        }
        CASE QUICFRAME::TYPE::READCRYPTOFRAME: {
          PKTHASRETRANSMITTABLEDATA = TRUE;
          PKTHASCRYPTODATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          READCRYPTOFRAME& CRYPTOFRAME = *QUICFRAME.ASREADCRYPTOFRAME();
          VLOG(10) << "SERVER RECEIVED CRYPTO DATA OFFSET="
                   << CRYPTOFRAME.OFFSET
                   << " LEN=" << CRYPTOFRAME.DATA->COMPUTECHAINDATALENGTH()
                   << " CURRENTREADOFFSET="
                   << GETCRYPTOSTREAM(*CONN.CRYPTOSTATE, ENCRYPTIONLEVEL)
                          ->CURRENTREADOFFSET
                   << " " << CONN;
          APPENDDATATOREADBUFFER(
              *GETCRYPTOSTREAM(*CONN.CRYPTOSTATE, ENCRYPTIONLEVEL),
              STREAMBUFFER(
                  STD::MOVE(CRYPTOFRAME.DATA), CRYPTOFRAME.OFFSET, FALSE));
          BREAK;
        }
        CASE QUICFRAME::TYPE::READSTREAMFRAME: {
          READSTREAMFRAME& FRAME = *QUICFRAME.ASREADSTREAMFRAME();
          VLOG(10) << "SERVER RECEIVED STREAM DATA FOR STREAM="
                   << FRAME.STREAMID << ", OFFSET=" << FRAME.OFFSET
                   << " LEN=" << FRAME.DATA->COMPUTECHAINDATALENGTH()
                   << " FIN=" << FRAME.FIN << " " << CONN;
          PKTHASRETRANSMITTABLEDATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          AUTO STREAM = CONN.STREAMMANAGER->GETSTREAM(FRAME.STREAMID);
          // IGNORE DATA FROM CLOSED STREAMS THAT WE DON'T HAVE THE
          // STATE FOR ANY MORE.
          IF (STREAM) {
            RECEIVEREADSTREAMFRAMESMHANDLER(*STREAM, STD::MOVE(FRAME));
          }
          BREAK;
        }
        CASE QUICFRAME::TYPE::MAXDATAFRAME: {
          MAXDATAFRAME& CONNWINDOWUPDATE = *QUICFRAME.ASMAXDATAFRAME();
          VLOG(10) << "SERVER RECEIVED MAX DATA OFFSET="
                   << CONNWINDOWUPDATE.MAXIMUMDATA << " " << CONN;
          PKTHASRETRANSMITTABLEDATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          HANDLECONNWINDOWUPDATE(CONN, CONNWINDOWUPDATE, PACKETNUM);
          BREAK;
        }
        CASE QUICFRAME::TYPE::MAXSTREAMDATAFRAME: {
          MAXSTREAMDATAFRAME& STREAMWINDOWUPDATE =
              *QUICFRAME.ASMAXSTREAMDATAFRAME();
          VLOG(10) << "SERVER RECEIVED MAX STREAM DATA STREAM="
                   << STREAMWINDOWUPDATE.STREAMID
                   << " OFFSET=" << STREAMWINDOWUPDATE.MAXIMUMDATA << " "
                   << CONN;
          IF (ISRECEIVINGSTREAM(CONN.NODETYPE, STREAMWINDOWUPDATE.STREAMID)) {
            THROW QUICTRANSPORTEXCEPTION(
                "RECEIVED MAXSTREAMDATAFRAME FOR RECEIVING STREAM.",
                TRANSPORTERRORCODE::STREAM_STATE_ERROR);
          }
          PKTHASRETRANSMITTABLEDATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          AUTO STREAM =
              CONN.STREAMMANAGER->GETSTREAM(STREAMWINDOWUPDATE.STREAMID);
          IF (STREAM) {
            HANDLESTREAMWINDOWUPDATE(
                *STREAM, STREAMWINDOWUPDATE.MAXIMUMDATA, PACKETNUM);
          }
          BREAK;
        }
        CASE QUICFRAME::TYPE::DATABLOCKEDFRAME: {
          VLOG(10) << "SERVER RECEIVED BLOCKED " << CONN;
          PKTHASRETRANSMITTABLEDATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          HANDLECONNBLOCKED(CONN);
          BREAK;
        }
        CASE QUICFRAME::TYPE::STREAMDATABLOCKEDFRAME: {
          STREAMDATABLOCKEDFRAME& BLOCKED =
              *QUICFRAME.ASSTREAMDATABLOCKEDFRAME();
          VLOG(10) << "SERVER RECEIVED BLOCKED STREAM=" << BLOCKED.STREAMID
                   << " " << CONN;
          PKTHASRETRANSMITTABLEDATA = TRUE;
          ISNONPROBINGPACKET = TRUE;
          AUTO STREAM = CONN.STREAMMANAGER->GETSTREAM(BLOCKED.STREAMID);
          IF (STREAM) {
            HANDLESTREAMBLOCKED(*STREAM);
          }
          BREAK;
        }
        CASE QUICFRAME::TYPE::STREAMSBLOCKEDFRAME: {
          STREAMSBLOCKEDFRAME& BLOCKED = *QUICFRAME.ASSTREAMSBLOCKEDFRAME();
          // PEER WISHES TO OPEN A STREAM, BUT IS UNABLE TO DUE TO THE MAXIMUM
          // STREAM LIMIT SET BY US
          // TODO IMPLEMENT THE HANDLER
          ISNONPROBINGPACKET = TRUE;
          VLOG(10) << "SERVER RECEIVED STREAMS BLOCKED LIMIT="
                   << BLOCKED.STREAMLIMIT << ", " << CONN;
          BREAK;
        }
        CASE QUICFRAME::TYPE::CONNECTIONCLOSEFRAME: {
          ISNONPROBINGPACKET = TRUE;
          CONNECTIONCLOSEFRAME& CONNFRAME = *QUICFRAME.ASCONNECTIONCLOSEFRAME();
          AUTO ERRMSG = FOLLY::TO<STD::STRING>(
              "SERVER CLOSED BY PEER REASON=", CONNFRAME.REASONPHRASE);
          VLOG(4) << ERRMSG << " " << CONN;
          // WE WANT TO DELIVER APP CALLBACKS WITH THE PEER SUPPLIED ERROR,
          // BUT SEND A NO_ERROR TO THE PEER.
          QUIC_TRACE(RECVD_CLOSE, CONN, ERRMSG.C_STR());
          IF (CONN.QLOGGER) {
            CONN.QLOGGER->ADDTRANSPORTSTATEUPDATE(GETPEERCLOSE(ERRMSG));
          }
          CONN.PEERCONNECTIONERROR = STD::MAKE_PAIR(
              QUICERRORCODE(CONNFRAME.ERRORCODE), STD::MOVE(ERRMSG));
          IF (GETSENDCONNFLOWCONTROLBYTESWIRE(CONN) == 0 &&
              CONN.FLOWCONTROLSTATE.SUMCURSTREAMBUFFERLEN) {
            VLOG(2) << "CLIENT GIVES UP A FLOW CONTROL BLOCKED CONNECTION";
          }
          THROW QUICTRANSPORTEXCEPTION(
              "PEER CLOSED", TRANSPORTERRORCODE::NO_ERROR);
          BREAK;
        }
        CASE QUICFRAME::TYPE::PINGFRAME:
          ISNONPROBINGPACKET = TRUE;
          // PING ISN'T RETRANSMITTABLE DATA. BUT WE WOULD LIKE TO ACK THEM
          // EARLY.
          PKTHASRETRANSMITTABLEDATA = TRUE;
          BREAK;
        CASE QUICFRAME::TYPE::PADDINGFRAME:
          BREAK;
        CASE QUICFRAME::TYPE::QUICSIMPLEFRAME: {
          PKTHASRETRANSMITTABLEDATA = TRUE;
          QUICSIMPLEFRAME& SIMPLEFRAME = *QUICFRAME.ASQUICSIMPLEFRAME();
          ISNONPROBINGPACKET |= UPDATESIMPLEFRAMEONPACKETRECEIVED(
              CONN, SIMPLEFRAME, PACKETNUM, READDATA.PEER != CONN.PEERADDRESS);
          BREAK;
        }
        DEFAULT: {
          BREAK;
        }
      }
    }

    IF (HANDSHAKECONFIRMEDTHISLOOP) {
      HANDSHAKECONFIRMED(CONN);
    }

    // UPDATE WRITABLE LIMIT BEFORE PROCESSING THE HANDSHAKE DATA. THIS IS SO
    // THAT IF WE HAVEN'T DECIDED WHETHER OR NOT TO VALIDATE THE PEER, WE WON'T
    // INCREASE THE LIMIT.
    UPDATEWRITABLEBYTELIMITONRECVPACKET(CONN);

    IF (CONN.PEERADDRESS != READDATA.PEER) {
      // TODO USE NEW CONN ID, MAKE SURE THE OTHER ENDPOINT HAS NEW CONN ID
      IF (ISNONPROBINGPACKET) {
        IF (PACKETNUM == ACKSTATE.LARGESTRECEIVEDPACKETNUM) {
          SHORTHEADER* SHORTHEADER = REGULARPACKET.HEADER.ASSHORT();
          BOOL INTENTIONALMIGRATION = FALSE;
          IF (SHORTHEADER &&
              SHORTHEADER->GETCONNECTIONID() != CONN.SERVERCONNECTIONID) {
            INTENTIONALMIGRATION = TRUE;
          }
          ONCONNECTIONMIGRATION(CONN, READDATA.PEER, INTENTIONALMIGRATION);
        }
      } ELSE {
        // SERVER WILL NEED TO RESPONSE WITH PATHRESPONSE TO THE NEW ADDRESS
        // WHILE NOT UPDATING PEERADDRESS TO NEW ADDRESS
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(
              PACKETSIZE,
              QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                  PACKETDROPREASON::PEER_ADDRESS_CHANGE));
        }
        QUIC_STATS(
            CONN.STATSCALLBACK,
            ONPACKETDROPPED,
            PACKETDROPREASON::PEER_ADDRESS_CHANGE);
        THROW QUICTRANSPORTEXCEPTION(
            "PROBING NOT SUPPORTED YET", TRANSPORTERRORCODE::INVALID_MIGRATION);
      }
    }

    // TRY READING BYTES OFF OF CRYPTO, AND PERFORMING A HANDSHAKE.
    AUTO DATA = READDATAFROMCRYPTOSTREAM(
        *GETCRYPTOSTREAM(*CONN.CRYPTOSTATE, ENCRYPTIONLEVEL));
    IF (DATA) {
      CONN.SERVERHANDSHAKELAYER->DOHANDSHAKE(STD::MOVE(DATA), ENCRYPTIONLEVEL);

      TRY {
        UPDATEHANDSHAKESTATE(CONN);
      } CATCH (...) {
        IF (CONN.QLOGGER) {
          CONN.QLOGGER->ADDPACKETDROP(
              PACKETSIZE,
              QUICTRANSPORTSTATSCALLBACK::TOSTRING(
                  PACKETDROPREASON::TRANSPORT_PARAMETER_ERROR));
        }
        QUIC_STATS(
            CONN.STATSCALLBACK,
            ONPACKETDROPPED,
            QUICTRANSPORTSTATSCALLBACK::PACKETDROPREASON::
                TRANSPORT_PARAMETER_ERROR);
        THROW;
      }
    }
    UPDATEACKSENDSTATEONRECVPACKET(
        CONN,
        ACKSTATE,
        OUTOFORDER,
        PKTHASRETRANSMITTABLEDATA,
        PKTHASCRYPTODATA);
    IF (ENCRYPTIONLEVEL == ENCRYPTIONLEVEL::HANDSHAKE &&
        CONN.VERSION != QUICVERSION::MVFST_D24 && CONN.INITIALWRITECIPHER) {
      CONN.INITIALWRITECIPHER.RESET();
      CONN.INITIALHEADERCIPHER.RESET();
      CONN.READCODEC->SETINITIALREADCIPHER(NULLPTR);
      CONN.READCODEC->SETINITIALHEADERCIPHER(NULLPTR);
      IMPLICITACKCRYPTOSTREAM(CONN, ENCRYPTIONLEVEL::INITIAL);
    }
    QUIC_STATS(CONN.STATSCALLBACK, ONPACKETPROCESSED);
  }
  VLOG_IF(4, !UDPDATA.EMPTY())
      << "LEAVING " << UDPDATA.CHAINLENGTH()
      << " BYTES UNPROCESSED AFTER ATTEMPTING TO PROCESS "
      << KMAXNUMCOALESCEDPACKETS << " PACKETS.";
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 307846_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CIKLASS* CIENV::GET_KLASS_BY_INDEX(CONSTANTPOOLHANDLE CPOOL,
                                   INT INDEX,
                                   BOOL& IS_ACCESSIBLE,
                                   CIINSTANCEKLASS* ACCESSOR) {
  GUARDED_VM_ENTRY(RETURN GET_KLASS_BY_INDEX_IMPL(CPOOL, INDEX, IS_ACCESSIBLE, ACCESSOR);)
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336498_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID REDS_HANDLE_AUTH_MECHANISM(VOID *OPAQUE)
{
    REDLINKINFO *LINK = (REDLINKINFO *)OPAQUE;
    REDSSTATE *REDS = LINK->REDS;

    SPICE_DEBUG("AUTH METHOD: %D", LINK->AUTH_MECHANISM.AUTH_MECHANISM);

    LINK->AUTH_MECHANISM.AUTH_MECHANISM = GUINT32_FROM_LE(LINK->AUTH_MECHANISM.AUTH_MECHANISM);
    IF (LINK->AUTH_MECHANISM.AUTH_MECHANISM == SPICE_COMMON_CAP_AUTH_SPICE
        && !REDS->CONFIG->SASL_ENABLED
        ) {
        REDS_GET_SPICE_TICKET(LINK);
#IF HAVE_SASL
    } ELSE IF (LINK->AUTH_MECHANISM.AUTH_MECHANISM == SPICE_COMMON_CAP_AUTH_SASL) {
        SPICE_DEBUG("STARTING SASL");
        REDS_START_AUTH_SASL(LINK);
#ENDIF
    } ELSE {
        SPICE_WARNING("UNKNOWN AUTH METHOD, DISCONNECTING");
        IF (REDS->CONFIG->SASL_ENABLED) {
            SPICE_WARNING("YOUR CLIENT DOESN'T HANDLE SASL?");
        }
        REDS_SEND_LINK_ERROR(LINK, SPICE_LINK_ERR_INVALID_DATA);
        REDS_LINK_FREE(LINK);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224155_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CODEGEN(CODEGEN_SCOPE *S, NODE *TREE, INT VAL)
{
  INT NT;
  INT RLEV = S->RLEV;

  IF (!TREE) {
    IF (VAL) {
      GENOP_1(S, OP_LOADNIL, CURSP());
      PUSH();
    }
    RETURN;
  }

  S->RLEV++;
  IF (S->RLEV > MRB_CODEGEN_LEVEL_MAX) {
    CODEGEN_ERROR(S, "TOO COMPLEX EXPRESSION");
  }
  IF (S->IREP && S->FILENAME_INDEX != TREE->FILENAME_INDEX) {
    MRB_SYM FNAME = MRB_PARSER_GET_FILENAME(S->PARSER, S->FILENAME_INDEX);
    CONST CHAR *FILENAME = MRB_SYM_NAME_LEN(S->MRB, FNAME, NULL);

    MRB_DEBUG_INFO_APPEND_FILE(S->MRB, S->IREP->DEBUG_INFO,
                               FILENAME, S->LINES, S->DEBUG_START_POS, S->PC);
    S->DEBUG_START_POS = S->PC;
    S->FILENAME_INDEX = TREE->FILENAME_INDEX;
    S->FILENAME_SYM = MRB_PARSER_GET_FILENAME(S->PARSER, TREE->FILENAME_INDEX);
  }

  NT = NINT(TREE->CAR);
  S->LINENO = TREE->LINENO;
  TREE = TREE->CDR;
  SWITCH (NT) {
  CASE NODE_BEGIN:
    IF (VAL && !TREE) {
      GENOP_1(S, OP_LOADNIL, CURSP());
      PUSH();
    }
    WHILE (TREE) {
      CODEGEN(S, TREE->CAR, TREE->CDR ? NOVAL : VAL);
      TREE = TREE->CDR;
    }
    BREAK;

  CASE NODE_RESCUE:
    {
      INT NOEXC;
      UINT32_T EXEND, POS1, POS2, TMP;
      STRUCT LOOPINFO *LP;
      INT CATCH_ENTRY, BEGIN, END;

      IF (TREE->CAR == NULL) GOTO EXIT;
      LP = LOOP_PUSH(S, LOOP_BEGIN);
      LP->PC0 = NEW_LABEL(S);
      CATCH_ENTRY = CATCH_HANDLER_NEW(S);
      BEGIN = S->PC;
      CODEGEN(S, TREE->CAR, VAL);
      POP();
      LP->TYPE = LOOP_RESCUE;
      END = S->PC;
      NOEXC = GENJMP_0(S, OP_JMP);
      CATCH_HANDLER_SET(S, CATCH_ENTRY, MRB_CATCH_RESCUE, BEGIN, END, S->PC);
      TREE = TREE->CDR;
      EXEND = JMPLINK_START;
      POS1 = JMPLINK_START;
      IF (TREE->CAR) {
        NODE *N2 = TREE->CAR;
        INT EXC = CURSP();

        GENOP_1(S, OP_EXCEPT, EXC);
        PUSH();
        WHILE (N2) {
          NODE *N3 = N2->CAR;
          NODE *N4 = N3->CAR;

          DISPATCH(S, POS1);
          POS2 = JMPLINK_START;
          DO {
            IF (N4 && N4->CAR && NINT(N4->CAR->CAR) == NODE_SPLAT) {
              CODEGEN(S, N4->CAR, VAL);
              GEN_MOVE(S, CURSP(), EXC, 0);
              PUSH_N(2); POP_N(2); /* SPACE FOR ONE ARG AND A BLOCK */
              POP();
              GENOP_3(S, OP_SEND, CURSP(), NEW_SYM(S, MRB_SYM_2(S->MRB, __CASE_EQQ)), 1);
            }
            ELSE {
              IF (N4) {
                CODEGEN(S, N4->CAR, VAL);
              }
              ELSE {
                GENOP_2(S, OP_GETCONST, CURSP(), NEW_SYM(S, MRB_SYM_2(S->MRB, STANDARDERROR)));
                PUSH();
              }
              POP();
              GENOP_2(S, OP_RESCUE, EXC, CURSP());
            }
            TMP = GENJMP2(S, OP_JMPIF, CURSP(), POS2, VAL);
            POS2 = TMP;
            IF (N4) {
              N4 = N4->CDR;
            }
          } WHILE (N4);
          POS1 = GENJMP_0(S, OP_JMP);
          DISPATCH_LINKED(S, POS2);

          POP();
          IF (N3->CDR->CAR) {
            GEN_ASSIGNMENT(S, N3->CDR->CAR, NULL, EXC, NOVAL);
          }
          IF (N3->CDR->CDR->CAR) {
            CODEGEN(S, N3->CDR->CDR->CAR, VAL);
            IF (VAL) POP();
          }
          TMP = GENJMP(S, OP_JMP, EXEND);
          EXEND = TMP;
          N2 = N2->CDR;
          PUSH();
        }
        IF (POS1 != JMPLINK_START) {
          DISPATCH(S, POS1);
          GENOP_1(S, OP_RAISEIF, EXC);
        }
      }
      POP();
      TREE = TREE->CDR;
      DISPATCH(S, NOEXC);
      IF (TREE->CAR) {
        CODEGEN(S, TREE->CAR, VAL);
      }
      ELSE IF (VAL) {
        PUSH();
      }
      DISPATCH_LINKED(S, EXEND);
      LOOP_POP(S, NOVAL);
    }
    BREAK;

  CASE NODE_ENSURE:
    IF (!TREE->CDR || !TREE->CDR->CDR ||
        (NINT(TREE->CDR->CDR->CAR) == NODE_BEGIN &&
         TREE->CDR->CDR->CDR)) {
      INT CATCH_ENTRY, BEGIN, END, TARGET;
      INT IDX;

      CATCH_ENTRY = CATCH_HANDLER_NEW(S);
      BEGIN = S->PC;
      CODEGEN(S, TREE->CAR, VAL);
      END = TARGET = S->PC;
      PUSH();
      IDX = CURSP();
      GENOP_1(S, OP_EXCEPT, IDX);
      PUSH();
      CODEGEN(S, TREE->CDR->CDR, NOVAL);
      POP();
      GENOP_1(S, OP_RAISEIF, IDX);
      POP();
      CATCH_HANDLER_SET(S, CATCH_ENTRY, MRB_CATCH_ENSURE, BEGIN, END, TARGET);
    }
    ELSE {                      /* EMPTY ENSURE IGNORED */
      CODEGEN(S, TREE->CAR, VAL);
    }
    BREAK;

  CASE NODE_LAMBDA:
    IF (VAL) {
      INT IDX = LAMBDA_BODY(S, TREE, 1);

      GENOP_2(S, OP_LAMBDA, CURSP(), IDX);
      PUSH();
    }
    BREAK;

  CASE NODE_BLOCK:
    IF (VAL) {
      INT IDX = LAMBDA_BODY(S, TREE, 1);

      GENOP_2(S, OP_BLOCK, CURSP(), IDX);
      PUSH();
    }
    BREAK;

  CASE NODE_IF:
    {
      UINT32_T POS1, POS2;
      MRB_BOOL NIL_P = FALSE;
      NODE *ELSEPART = TREE->CDR->CDR->CAR;

      IF (!TREE->CAR) {
        CODEGEN(S, ELSEPART, VAL);
        GOTO EXIT;
      }
      IF (TRUE_ALWAYS(TREE->CAR)) {
        CODEGEN(S, TREE->CDR->CAR, VAL);
        GOTO EXIT;
      }
      IF (FALSE_ALWAYS(TREE->CAR)) {
        CODEGEN(S, ELSEPART, VAL);
        GOTO EXIT;
      }
      IF (NINT(TREE->CAR->CAR) == NODE_CALL) {
        NODE *N = TREE->CAR->CDR;
        MRB_SYM MID = NSYM(N->CDR->CAR);
        MRB_SYM SYM_NIL_P = MRB_SYM_Q_2(S->MRB, NIL);
        IF (MID == SYM_NIL_P && N->CDR->CDR->CAR == NULL) {
          NIL_P = TRUE;
          CODEGEN(S, N->CAR, VAL);
        }
      }
      IF (!NIL_P) {
        CODEGEN(S, TREE->CAR, VAL);
      }
      POP();
      IF (VAL || TREE->CDR->CAR) {
        IF (NIL_P) {
          POS2 = GENJMP2_0(S, OP_JMPNIL, CURSP(), VAL);
          POS1 = GENJMP_0(S, OP_JMP);
          DISPATCH(S, POS2);
        }
        ELSE {
          POS1 = GENJMP2_0(S, OP_JMPNOT, CURSP(), VAL);
        }
        CODEGEN(S, TREE->CDR->CAR, VAL);
        IF (VAL) POP();
        IF (ELSEPART || VAL) {
          POS2 = GENJMP_0(S, OP_JMP);
          DISPATCH(S, POS1);
          CODEGEN(S, ELSEPART, VAL);
          DISPATCH(S, POS2);
        }
        ELSE {
          DISPATCH(S, POS1);
        }
      }
      ELSE {                    /* EMPTY THEN-PART */
        IF (ELSEPART) {
          IF (NIL_P) {
            POS1 = GENJMP2_0(S, OP_JMPNIL, CURSP(), VAL);
          }
          ELSE {
            POS1 = GENJMP2_0(S, OP_JMPIF, CURSP(), VAL);
          }
          CODEGEN(S, ELSEPART, VAL);
          DISPATCH(S, POS1);
        }
        ELSE IF (VAL && !NIL_P) {
          GENOP_1(S, OP_LOADNIL, CURSP());
          PUSH();
        }
      }
    }
    BREAK;

  CASE NODE_AND:
    {
      UINT32_T POS;

      IF (TRUE_ALWAYS(TREE->CAR)) {
        CODEGEN(S, TREE->CDR, VAL);
        GOTO EXIT;
      }
      IF (FALSE_ALWAYS(TREE->CAR)) {
        CODEGEN(S, TREE->CAR, VAL);
        GOTO EXIT;
      }
      CODEGEN(S, TREE->CAR, VAL);
      POP();
      POS = GENJMP2_0(S, OP_JMPNOT, CURSP(), VAL);
      CODEGEN(S, TREE->CDR, VAL);
      DISPATCH(S, POS);
    }
    BREAK;

  CASE NODE_OR:
    {
      UINT32_T POS;

      IF (TRUE_ALWAYS(TREE->CAR)) {
        CODEGEN(S, TREE->CAR, VAL);
        GOTO EXIT;
      }
      IF (FALSE_ALWAYS(TREE->CAR)) {
        CODEGEN(S, TREE->CDR, VAL);
        GOTO EXIT;
      }
      CODEGEN(S, TREE->CAR, VAL);
      POP();
      POS = GENJMP2_0(S, OP_JMPIF, CURSP(), VAL);
      CODEGEN(S, TREE->CDR, VAL);
      DISPATCH(S, POS);
    }
    BREAK;

  CASE NODE_WHILE:
  CASE NODE_UNTIL:
    {
      IF (TRUE_ALWAYS(TREE->CAR)) {
        IF (NT == NODE_UNTIL) {
          IF (VAL) {
            GENOP_1(S, OP_LOADNIL, CURSP());
            PUSH();
          }
          GOTO EXIT;
        }
      }
      ELSE IF (FALSE_ALWAYS(TREE->CAR)) {
        IF (NT == NODE_WHILE) {
          IF (VAL) {
            GENOP_1(S, OP_LOADNIL, CURSP());
            PUSH();
          }
          GOTO EXIT;
        }
      }

      UINT32_T POS = JMPLINK_START;
      STRUCT LOOPINFO *LP = LOOP_PUSH(S, LOOP_NORMAL);

      IF (!VAL) LP->REG = -1;
      LP->PC0 = NEW_LABEL(S);
      CODEGEN(S, TREE->CAR, VAL);
      POP();
      IF (NT == NODE_WHILE) {
        POS = GENJMP2_0(S, OP_JMPNOT, CURSP(), NOVAL);
      }
      ELSE {
        POS = GENJMP2_0(S, OP_JMPIF, CURSP(), NOVAL);
      }
      LP->PC1 = NEW_LABEL(S);
      CODEGEN(S, TREE->CDR, NOVAL);
      GENJMP(S, OP_JMP, LP->PC0);
      DISPATCH(S, POS);
      LOOP_POP(S, VAL);
    }
    BREAK;

  CASE NODE_FOR:
    FOR_BODY(S, TREE);
    IF (VAL) PUSH();
    BREAK;

  CASE NODE_CASE:
    {
      INT HEAD = 0;
      UINT32_T POS1, POS2, POS3, TMP;
      NODE *N;

      POS3 = JMPLINK_START;
      IF (TREE->CAR) {
        HEAD = CURSP();
        CODEGEN(S, TREE->CAR, VAL);
      }
      TREE = TREE->CDR;
      WHILE (TREE) {
        N = TREE->CAR->CAR;
        POS1 = POS2 = JMPLINK_START;
        WHILE (N) {
          CODEGEN(S, N->CAR, VAL);
          IF (HEAD) {
            GEN_MOVE(S, CURSP(), HEAD, 0);
            PUSH(); PUSH(); POP(); POP(); POP();
            IF (NINT(N->CAR->CAR) == NODE_SPLAT) {
              GENOP_3(S, OP_SEND, CURSP(), NEW_SYM(S, MRB_SYM_2(S->MRB, __CASE_EQQ)), 1);
            }
            ELSE {
              GENOP_3(S, OP_SEND, CURSP(), NEW_SYM(S, MRB_OPSYM_2(S->MRB, EQQ)), 1);
            }
          }
          ELSE {
            POP();
          }
          TMP = GENJMP2(S, OP_JMPIF, CURSP(), POS2, NOVAL);
          POS2 = TMP;
          N = N->CDR;
        }
        IF (TREE->CAR->CAR) {
          POS1 = GENJMP_0(S, OP_JMP);
          DISPATCH_LINKED(S, POS2);
        }
        CODEGEN(S, TREE->CAR->CDR, VAL);
        IF (VAL) POP();
        TMP = GENJMP(S, OP_JMP, POS3);
        POS3 = TMP;
        DISPATCH(S, POS1);
        TREE = TREE->CDR;
      }
      IF (VAL) {
        UINT32_T POS = CURSP();
        GENOP_1(S, OP_LOADNIL, CURSP());
        IF (POS3 != JMPLINK_START) DISPATCH_LINKED(S, POS3);
        IF (HEAD) POP();
        IF (CURSP() != POS) {
          GEN_MOVE(S, CURSP(), POS, 0);
        }
        PUSH();
      }
      ELSE {
        IF (POS3 != JMPLINK_START) {
          DISPATCH_LINKED(S, POS3);
        }
        IF (HEAD) {
          POP();
        }
      }
    }
    BREAK;

  CASE NODE_SCOPE:
    SCOPE_BODY(S, TREE, NOVAL);
    BREAK;

  CASE NODE_FCALL:
  CASE NODE_CALL:
    GEN_CALL(S, TREE, VAL, 0);
    BREAK;
  CASE NODE_SCALL:
    GEN_CALL(S, TREE, VAL, 1);
    BREAK;

  CASE NODE_DOT2:
    CODEGEN(S, TREE->CAR, VAL);
    CODEGEN(S, TREE->CDR, VAL);
    IF (VAL) {
      POP(); POP();
      GENOP_1(S, OP_RANGE_INC, CURSP());
      PUSH();
    }
    BREAK;

  CASE NODE_DOT3:
    CODEGEN(S, TREE->CAR, VAL);
    CODEGEN(S, TREE->CDR, VAL);
    IF (VAL) {
      POP(); POP();
      GENOP_1(S, OP_RANGE_EXC, CURSP());
      PUSH();
    }
    BREAK;

  CASE NODE_COLON2:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE->CDR));

      CODEGEN(S, TREE->CAR, VAL);
      POP();
      GENOP_2(S, OP_GETMCNST, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_COLON3:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE));

      GENOP_1(S, OP_OCLASS, CURSP());
      GENOP_2(S, OP_GETMCNST, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_ARRAY:
    {
      INT N;

      N = GEN_VALUES(S, TREE, VAL, 0);
      IF (VAL) {
        IF (N >= 0) {
          POP_N(N);
          GENOP_2(S, OP_ARRAY, CURSP(), N);
        }
        PUSH();
      }
    }
    BREAK;

  CASE NODE_HASH:
  CASE NODE_KW_HASH:
    {
      INT NK = GEN_HASH(S, TREE, VAL, GEN_LIT_ARY_MAX);
      IF (VAL && NK >= 0) {
        POP_N(NK*2);
        GENOP_2(S, OP_HASH, CURSP(), NK);
        PUSH();
      }
    }
    BREAK;

  CASE NODE_SPLAT:
    CODEGEN(S, TREE, VAL);
    BREAK;

  CASE NODE_ASGN:
    GEN_ASSIGNMENT(S, TREE->CAR, TREE->CDR, 0, VAL);
    BREAK;

  CASE NODE_MASGN:
    {
      INT LEN = 0, N = 0, POST = 0;
      NODE *T = TREE->CDR, *P;
      INT RHS = CURSP();

      IF (NINT(T->CAR) == NODE_ARRAY && T->CDR && NOSPLAT(T->CDR)) {
        /* FIXED RHS */
        T = T->CDR;
        WHILE (T) {
          CODEGEN(S, T->CAR, VAL);
          LEN++;
          T = T->CDR;
        }
        TREE = TREE->CAR;
        IF (TREE->CAR) {                /* PRE */
          T = TREE->CAR;
          N = 0;
          WHILE (T) {
            IF (N < LEN) {
              GEN_ASSIGNMENT(S, T->CAR, NULL, RHS+N, NOVAL);
              N++;
            }
            ELSE {
              GENOP_1(S, OP_LOADNIL, RHS+N);
              GEN_ASSIGNMENT(S, T->CAR, NULL, RHS+N, NOVAL);
            }
            T = T->CDR;
          }
        }
        T = TREE->CDR;
        IF (T) {
          IF (T->CDR) {         /* POST COUNT */
            P = T->CDR->CAR;
            WHILE (P) {
              POST++;
              P = P->CDR;
            }
          }
          IF (T->CAR) {         /* REST (LEN - PRE - POST) */
            INT RN;

            IF (LEN < POST + N) {
              RN = 0;
            }
            ELSE {
              RN = LEN - POST - N;
            }
            GENOP_3(S, OP_ARRAY2, CURSP(), RHS+N, RN);
            GEN_ASSIGNMENT(S, T->CAR, NULL, CURSP(), NOVAL);
            N += RN;
          }
          IF (T->CDR && T->CDR->CAR) {
            T = T->CDR->CAR;
            WHILE (N<LEN) {
              GEN_ASSIGNMENT(S, T->CAR, NULL, RHS+N, NOVAL);
              T = T->CDR;
              N++;
            }
          }
        }
        POP_N(LEN);
        IF (VAL) {
          GENOP_2(S, OP_ARRAY, RHS, LEN);
          PUSH();
        }
      }
      ELSE {
        /* VARIABLE RHS */
        CODEGEN(S, T, VAL);
        GEN_VMASSIGNMENT(S, TREE->CAR, RHS, VAL);
        IF (!VAL) {
          POP();
        }
      }
    }
    BREAK;

  CASE NODE_OP_ASGN:
    {
      MRB_SYM SYM = NSYM(TREE->CDR->CAR);
      MRB_INT LEN;
      CONST CHAR *NAME = MRB_SYM_NAME_LEN(S->MRB, SYM, &LEN);
      INT IDX, CALLARGS = -1, VSP = -1;

      IF ((LEN == 2 && NAME[0] == '|' && NAME[1] == '|') &&
          (NINT(TREE->CAR->CAR) == NODE_CONST ||
           NINT(TREE->CAR->CAR) == NODE_CVAR)) {
        INT CATCH_ENTRY, BEGIN, END;
        INT NOEXC, EXC;
        STRUCT LOOPINFO *LP;

        LP = LOOP_PUSH(S, LOOP_BEGIN);
        LP->PC0 = NEW_LABEL(S);
        CATCH_ENTRY = CATCH_HANDLER_NEW(S);
        BEGIN = S->PC;
        EXC = CURSP();
        CODEGEN(S, TREE->CAR, VAL);
        END = S->PC;
        NOEXC = GENJMP_0(S, OP_JMP);
        LP->TYPE = LOOP_RESCUE;
        CATCH_HANDLER_SET(S, CATCH_ENTRY, MRB_CATCH_RESCUE, BEGIN, END, S->PC);
        GENOP_1(S, OP_EXCEPT, EXC);
        GENOP_1(S, OP_LOADF, EXC);
        DISPATCH(S, NOEXC);
        LOOP_POP(S, NOVAL);
      }
      ELSE IF (NINT(TREE->CAR->CAR) == NODE_CALL) {
        NODE *N = TREE->CAR->CDR;
        INT BASE, I, NARGS = 0;
        CALLARGS = 0;

        IF (VAL) {
          VSP = CURSP();
          PUSH();
        }
        CODEGEN(S, N->CAR, VAL);   /* RECEIVER */
        IDX = NEW_SYM(S, NSYM(N->CDR->CAR));
        BASE = CURSP()-1;
        IF (N->CDR->CDR->CAR) {
          NARGS = GEN_VALUES(S, N->CDR->CDR->CAR->CAR, VAL, 13);
          IF (NARGS >= 0) {
            CALLARGS = NARGS;
          }
          ELSE { /* VARARGS */
            PUSH();
            NARGS = 1;
            CALLARGS = CALL_MAXARGS;
          }
        }
        /* COPY RECEIVER AND ARGUMENTS */
        GEN_MOVE(S, CURSP(), BASE, 1);
        FOR (I=0; I<NARGS; I++) {
          GEN_MOVE(S, CURSP()+I+1, BASE+I+1, 1);
        }
        PUSH_N(NARGS+2);POP_N(NARGS+2); /* SPACE FOR RECEIVER, ARGUMENTS AND A BLOCK */
        GENOP_3(S, OP_SEND, CURSP(), IDX, CALLARGS);
        PUSH();
      }
      ELSE {
        CODEGEN(S, TREE->CAR, VAL);
      }
      IF (LEN == 2 &&
          ((NAME[0] == '|' && NAME[1] == '|') ||
           (NAME[0] == '&' && NAME[1] == '&'))) {
        UINT32_T POS;

        POP();
        IF (VAL) {
          IF (VSP >= 0) {
            GEN_MOVE(S, VSP, CURSP(), 1);
          }
          POS = GENJMP2_0(S, NAME[0]=='|'?OP_JMPIF:OP_JMPNOT, CURSP(), VAL);
        }
        ELSE {
          POS = GENJMP2_0(S, NAME[0]=='|'?OP_JMPIF:OP_JMPNOT, CURSP(), VAL);
        }
        CODEGEN(S, TREE->CDR->CDR->CAR, VAL);
        POP();
        IF (VAL && VSP >= 0) {
          GEN_MOVE(S, VSP, CURSP(), 1);
        }
        IF (NINT(TREE->CAR->CAR) == NODE_CALL) {
          IF (CALLARGS == CALL_MAXARGS) {
            POP();
            GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
          }
          ELSE {
            POP_N(CALLARGS);
            CALLARGS++;
          }
          POP();
          IDX = NEW_SYM(S, ATTRSYM(S, NSYM(TREE->CAR->CDR->CDR->CAR)));
          GENOP_3(S, OP_SEND, CURSP(), IDX, CALLARGS);
        }
        ELSE {
          GEN_ASSIGNMENT(S, TREE->CAR, NULL, CURSP(), VAL);
        }
        DISPATCH(S, POS);
        GOTO EXIT;
      }
      CODEGEN(S, TREE->CDR->CDR->CAR, VAL);
      PUSH(); POP();
      POP(); POP();

      IF (LEN == 1 && NAME[0] == '+')  {
        GEN_ADDSUB(S, OP_ADD, CURSP());
      }
      ELSE IF (LEN == 1 && NAME[0] == '-')  {
        GEN_ADDSUB(S, OP_SUB, CURSP());
      }
      ELSE IF (LEN == 1 && NAME[0] == '*')  {
        GENOP_1(S, OP_MUL, CURSP());
      }
      ELSE IF (LEN == 1 && NAME[0] == '/')  {
        GENOP_1(S, OP_DIV, CURSP());
      }
      ELSE IF (LEN == 1 && NAME[0] == '<')  {
        GENOP_1(S, OP_LT, CURSP());
      }
      ELSE IF (LEN == 2 && NAME[0] == '<' && NAME[1] == '=')  {
        GENOP_1(S, OP_LE, CURSP());
      }
      ELSE IF (LEN == 1 && NAME[0] == '>')  {
        GENOP_1(S, OP_GT, CURSP());
      }
      ELSE IF (LEN == 2 && NAME[0] == '>' && NAME[1] == '=')  {
        GENOP_1(S, OP_GE, CURSP());
      }
      ELSE {
        IDX = NEW_SYM(S, SYM);
        GENOP_3(S, OP_SEND, CURSP(), IDX, 1);
      }
      IF (CALLARGS < 0) {
        GEN_ASSIGNMENT(S, TREE->CAR, NULL, CURSP(), VAL);
      }
      ELSE {
        IF (VAL && VSP >= 0) {
          GEN_MOVE(S, VSP, CURSP(), 0);
        }
        IF (CALLARGS == CALL_MAXARGS) {
          POP();
          GENOP_2(S, OP_ARYPUSH, CURSP(), 1);
        }
        ELSE {
          POP_N(CALLARGS);
          CALLARGS++;
        }
        POP();
        IDX = NEW_SYM(S, ATTRSYM(S,NSYM(TREE->CAR->CDR->CDR->CAR)));
        GENOP_3(S, OP_SEND, CURSP(), IDX, CALLARGS);
      }
    }
    BREAK;

  CASE NODE_SUPER:
    {
      CODEGEN_SCOPE *S2 = S;
      INT LV = 0;
      INT N = 0, NK = 0, ST = 0;

      PUSH();
      WHILE (!S2->MSCOPE) {
        LV++;
        S2 = S2->PREV;
        IF (!S2) BREAK;
      }
      IF (TREE) {
        NODE *ARGS = TREE->CAR;
        IF (ARGS) {
          ST = N = GEN_VALUES(S, ARGS, VAL, 14);
          IF (N < 0) {
            ST = 1; N = 15;
            PUSH();
          }
        }
        /* KEYWORD ARGUMENTS */
        IF (S2 && (S2->AINFO & 0X1) && TREE->CDR->CAR) {
          NK = GEN_HASH(S, TREE->CDR->CAR->CDR, VAL, 14);
          IF (NK < 0) {ST++; NK = 15;}
          ELSE ST += NK*2;
          N |= NK<<4;
        }
        /* BLOCK ARGUMENTS */
        IF (TREE->CDR->CDR) {
          CODEGEN(S, TREE->CDR->CDR, VAL);
        }
        ELSE IF (!S2) {/* SUPER AT TOP-LEVEL */
          PUSH();      /* NO NEED TO PUSH BLOCK */
        }
        ELSE {
          GEN_BLKMOVE(S, S2->AINFO, LV);
        }
        ST++;
      }
      ELSE {
        IF (!S2) PUSH();
        ELSE GEN_BLKMOVE(S, S2->AINFO, LV);
        ST++;
      }
      POP_N(ST+1);
      GENOP_2(S, OP_SUPER, CURSP(), N);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_ZSUPER:
    {
      CODEGEN_SCOPE *S2 = S;
      INT LV = 0;
      SIZE_T AINFO = 0;
      INT N = CALL_MAXARGS;
      INT SP = CURSP();

      PUSH();        /* ROOM FOR RECEIVER */
      WHILE (!S2->MSCOPE) {
        LV++;
        S2 = S2->PREV;
        IF (!S2) BREAK;
      }
      IF (S2 && S2->AINFO > 0) {
        AINFO = S2->AINFO;
      }
      IF (AINFO > 0) {
        GENOP_2S(S, OP_ARGARY, CURSP(), (AINFO<<4)|(LV & 0XF));
        PUSH(); PUSH(); PUSH();   /* ARGARY PUSHES 3 VALUES AT MOST */
        POP(); POP(); POP();
        /* KEYWORD ARGUMENTS */
        IF (AINFO & 0X1) {
          N |= CALL_MAXARGS<<4;
          PUSH();
        }
        /* BLOCK ARGUMENT */
        IF (TREE && TREE->CDR && TREE->CDR->CDR) {
          PUSH();
          CODEGEN(S, TREE->CDR->CDR, VAL);
        }
      }
      ELSE {
        /* BLOCK ARGUMENT */
        IF (TREE && TREE->CDR && TREE->CDR->CDR) {
          CODEGEN(S, TREE->CDR->CDR, VAL);
        }
        ELSE {
          GEN_BLKMOVE(S, 0, LV);
        }
        N = 0;
      }
      S->SP = SP;
      GENOP_2(S, OP_SUPER, CURSP(), N);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_RETURN:
    IF (TREE) {
      GEN_RETVAL(S, TREE);
    }
    ELSE {
      GENOP_1(S, OP_LOADNIL, CURSP());
    }
    IF (S->LOOP) {
      GEN_RETURN(S, OP_RETURN_BLK, CURSP());
    }
    ELSE {
      GEN_RETURN(S, OP_RETURN, CURSP());
    }
    IF (VAL) PUSH();
    BREAK;

  CASE NODE_YIELD:
    {
      CODEGEN_SCOPE *S2 = S;
      INT LV = 0, AINFO = -1;
      INT N = 0, SENDV = 0;

      WHILE (!S2->MSCOPE) {
        LV++;
        S2 = S2->PREV;
        IF (!S2) BREAK;
      }
      IF (S2) {
        AINFO = (INT)S2->AINFO;
      }
      IF (AINFO < 0) CODEGEN_ERROR(S, "INVALID YIELD (SYNTAXERROR)");
      PUSH();
      IF (TREE) {
        N = GEN_VALUES(S, TREE, VAL, 14);
        IF (N < 0) {
          N = SENDV = 1;
          PUSH();
        }
      }
      PUSH();POP(); /* SPACE FOR A BLOCK */
      POP_N(N+1);
      GENOP_2S(S, OP_BLKPUSH, CURSP(), (AINFO<<4)|(LV & 0XF));
      IF (SENDV) N = CALL_MAXARGS;
      GENOP_3(S, OP_SEND, CURSP(), NEW_SYM(S, MRB_SYM_2(S->MRB, CALL)), N);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_BREAK:
    LOOP_BREAK(S, TREE);
    IF (VAL) PUSH();
    BREAK;

  CASE NODE_NEXT:
    IF (!S->LOOP) {
      RAISE_ERROR(S, "UNEXPECTED NEXT");
    }
    ELSE IF (S->LOOP->TYPE == LOOP_NORMAL) {
      CODEGEN(S, TREE, NOVAL);
      GENJMP(S, OP_JMPUW, S->LOOP->PC0);
    }
    ELSE {
      IF (TREE) {
        CODEGEN(S, TREE, VAL);
        POP();
      }
      ELSE {
        GENOP_1(S, OP_LOADNIL, CURSP());
      }
      GEN_RETURN(S, OP_RETURN, CURSP());
    }
    IF (VAL) PUSH();
    BREAK;

  CASE NODE_REDO:
    IF (!S->LOOP || S->LOOP->TYPE == LOOP_BEGIN || S->LOOP->TYPE == LOOP_RESCUE) {
      RAISE_ERROR(S, "UNEXPECTED REDO");
    }
    ELSE {
      GENJMP(S, OP_JMPUW, S->LOOP->PC1);
    }
    IF (VAL) PUSH();
    BREAK;

  CASE NODE_RETRY:
    {
      CONST CHAR *MSG = "UNEXPECTED RETRY";
      CONST STRUCT LOOPINFO *LP = S->LOOP;

      WHILE (LP && LP->TYPE != LOOP_RESCUE) {
        LP = LP->PREV;
      }
      IF (!LP) {
        RAISE_ERROR(S, MSG);
      }
      ELSE {
        GENJMP(S, OP_JMPUW, LP->PC0);
      }
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_LVAR:
    IF (VAL) {
      INT IDX = LV_IDX(S, NSYM(TREE));

      IF (IDX > 0) {
        GEN_MOVE(S, CURSP(), IDX, VAL);
      }
      ELSE {
        GEN_GETUPVAR(S, CURSP(), NSYM(TREE));
      }
      PUSH();
    }
    BREAK;

  CASE NODE_NVAR:
    IF (VAL) {
      INT IDX = NINT(TREE);

      GEN_MOVE(S, CURSP(), IDX, VAL);

      PUSH();
    }
    BREAK;

  CASE NODE_GVAR:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE));

      GENOP_2(S, OP_GETGV, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_IVAR:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE));

      GENOP_2(S, OP_GETIV, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_CVAR:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE));

      GENOP_2(S, OP_GETCV, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_CONST:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE));

      GENOP_2(S, OP_GETCONST, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_BACK_REF:
    IF (VAL) {
      CHAR BUF[] = {'$', NCHAR(TREE)};
      INT SYM = NEW_SYM(S, MRB_INTERN(S->MRB, BUF, SIZEOF(BUF)));

      GENOP_2(S, OP_GETGV, CURSP(), SYM);
      PUSH();
    }
    BREAK;

  CASE NODE_NTH_REF:
    IF (VAL) {
      MRB_STATE *MRB = S->MRB;
      MRB_VALUE STR;
      INT SYM;

      STR = MRB_FORMAT(MRB, "$%D", NINT(TREE));
      SYM = NEW_SYM(S, MRB_INTERN_STR(MRB, STR));
      GENOP_2(S, OP_GETGV, CURSP(), SYM);
      PUSH();
    }
    BREAK;

  CASE NODE_ARG:
    /* SHOULD NOT HAPPEN */
    BREAK;

  CASE NODE_BLOCK_ARG:
    IF (!TREE) {
      INT IDX = LV_IDX(S, MRB_OPSYM_2(S->MRB, AND));

      IF (IDX == 0) {
        CODEGEN_ERROR(S, "NO ANONYMOUS BLOCK ARGUMENT");
      }
      GEN_MOVE(S, CURSP(), IDX, VAL);
    }
    ELSE {
      CODEGEN(S, TREE, VAL);
    }
    BREAK;

  CASE NODE_INT:
    IF (VAL) {
      CHAR *P = (CHAR*)TREE->CAR;
      INT BASE = NINT(TREE->CDR->CAR);
      MRB_INT I;
      MRB_BOOL OVERFLOW;

      I = READINT(S, P, BASE, FALSE, &OVERFLOW);
      IF (OVERFLOW) {
        INT OFF = NEW_LITBN(S, P, BASE, FALSE);
        GENOP_2(S, OP_LOADL, CURSP(), OFF);
      }
      ELSE {
        GEN_INT(S, CURSP(), I);
      }
      PUSH();
    }
    BREAK;

#IFNDEF MRB_NO_FLOAT
  CASE NODE_FLOAT:
    IF (VAL) {
      CHAR *P = (CHAR*)TREE;
      MRB_FLOAT F = MRB_FLOAT_READ(P, NULL);
      INT OFF = NEW_LIT(S, MRB_FLOAT_VALUE(S->MRB, F));

      GENOP_2(S, OP_LOADL, CURSP(), OFF);
      PUSH();
    }
    BREAK;
#ENDIF

  CASE NODE_NEGATE:
    {
      NT = NINT(TREE->CAR);
      SWITCH (NT) {
#IFNDEF MRB_NO_FLOAT
      CASE NODE_FLOAT:
        IF (VAL) {
          CHAR *P = (CHAR*)TREE->CDR;
          MRB_FLOAT F = MRB_FLOAT_READ(P, NULL);
          INT OFF = NEW_LIT(S, MRB_FLOAT_VALUE(S->MRB, -F));

          GENOP_2(S, OP_LOADL, CURSP(), OFF);
          PUSH();
        }
        BREAK;
#ENDIF

      CASE NODE_INT:
        IF (VAL) {
          CHAR *P = (CHAR*)TREE->CDR->CAR;
          INT BASE = NINT(TREE->CDR->CDR->CAR);
          MRB_INT I;
          MRB_BOOL OVERFLOW;

          I = READINT(S, P, BASE, TRUE, &OVERFLOW);
          IF (OVERFLOW) {
            INT OFF = NEW_LITBN(S, P, BASE, TRUE);
            GENOP_2(S, OP_LOADL, CURSP(), OFF);
          }
          ELSE {
            GEN_INT(S, CURSP(), I);
          }
          PUSH();
        }
        BREAK;

      DEFAULT:
        IF (VAL) {
          CODEGEN(S, TREE, VAL);
          POP();
          PUSH_N(2);POP_N(2); /* SPACE FOR RECEIVER&BLOCK */
          MRB_SYM MINUS = MRB_OPSYM_2(S->MRB, MINUS);
          IF (!GEN_UNIOP(S, MINUS, CURSP())) {
            GENOP_3(S, OP_SEND, CURSP(), NEW_SYM(S, MINUS), 0);
          }
          PUSH();
        }
        ELSE {
          CODEGEN(S, TREE, NOVAL);
        }
        BREAK;
      }
    }
    BREAK;

  CASE NODE_STR:
    IF (VAL) {
      CHAR *P = (CHAR*)TREE->CAR;
      SIZE_T LEN = (INTPTR_T)TREE->CDR;
      INT AI = MRB_GC_ARENA_SAVE(S->MRB);
      INT OFF = NEW_LIT(S, MRB_STR_NEW(S->MRB, P, LEN));

      MRB_GC_ARENA_RESTORE(S->MRB, AI);
      GENOP_2(S, OP_STRING, CURSP(), OFF);
      PUSH();
    }
    BREAK;

  CASE NODE_HEREDOC:
    TREE = ((STRUCT MRB_PARSER_HEREDOC_INFO *)TREE)->DOC;
    /* FALL THROUGH */
  CASE NODE_DSTR:
    IF (VAL) {
      NODE *N = TREE;

      IF (!N) {
        GENOP_1(S, OP_LOADNIL, CURSP());
        PUSH();
        BREAK;
      }
      CODEGEN(S, N->CAR, VAL);
      N = N->CDR;
      WHILE (N) {
        CODEGEN(S, N->CAR, VAL);
        POP(); POP();
        GENOP_1(S, OP_STRCAT, CURSP());
        PUSH();
        N = N->CDR;
      }
    }
    ELSE {
      NODE *N = TREE;

      WHILE (N) {
        IF (NINT(N->CAR->CAR) != NODE_STR) {
          CODEGEN(S, N->CAR, NOVAL);
        }
        N = N->CDR;
      }
    }
    BREAK;

  CASE NODE_WORDS:
    GEN_LITERAL_ARRAY(S, TREE, FALSE, VAL);
    BREAK;

  CASE NODE_SYMBOLS:
    GEN_LITERAL_ARRAY(S, TREE, TRUE, VAL);
    BREAK;

  CASE NODE_DXSTR:
    {
      NODE *N;
      INT AI = MRB_GC_ARENA_SAVE(S->MRB);
      INT SYM = NEW_SYM(S, MRB_SYM_2(S->MRB, KERNEL));

      GENOP_1(S, OP_LOADSELF, CURSP());
      PUSH();
      CODEGEN(S, TREE->CAR, VAL);
      N = TREE->CDR;
      WHILE (N) {
        IF (NINT(N->CAR->CAR) == NODE_XSTR) {
          N->CAR->CAR = (STRUCT MRB_AST_NODE*)(INTPTR_T)NODE_STR;
          MRB_ASSERT(!N->CDR); /* MUST BE THE END */
        }
        CODEGEN(S, N->CAR, VAL);
        POP(); POP();
        GENOP_1(S, OP_STRCAT, CURSP());
        PUSH();
        N = N->CDR;
      }
      PUSH();                   /* FOR BLOCK */
      POP_N(3);
      SYM = NEW_SYM(S, MRB_OPSYM_2(S->MRB, TICK)); /* ` */
      GENOP_3(S, OP_SEND, CURSP(), SYM, 1);
      IF (VAL) PUSH();
      MRB_GC_ARENA_RESTORE(S->MRB, AI);
    }
    BREAK;

  CASE NODE_XSTR:
    {
      CHAR *P = (CHAR*)TREE->CAR;
      SIZE_T LEN = (INTPTR_T)TREE->CDR;
      INT AI = MRB_GC_ARENA_SAVE(S->MRB);
      INT OFF = NEW_LIT(S, MRB_STR_NEW(S->MRB, P, LEN));
      INT SYM;

      GENOP_1(S, OP_LOADSELF, CURSP());
      PUSH();
      GENOP_2(S, OP_STRING, CURSP(), OFF);
      PUSH(); PUSH();
      POP_N(3);
      SYM = NEW_SYM(S, MRB_OPSYM_2(S->MRB, TICK)); /* ` */
      GENOP_3(S, OP_SEND, CURSP(), SYM, 1);
      IF (VAL) PUSH();
      MRB_GC_ARENA_RESTORE(S->MRB, AI);
    }
    BREAK;

  CASE NODE_REGX:
    IF (VAL) {
      CHAR *P1 = (CHAR*)TREE->CAR;
      CHAR *P2 = (CHAR*)TREE->CDR->CAR;
      CHAR *P3 = (CHAR*)TREE->CDR->CDR;
      INT AI = MRB_GC_ARENA_SAVE(S->MRB);
      INT SYM = NEW_SYM(S, MRB_INTERN_LIT(S->MRB, REGEXP_CLASS));
      INT OFF = NEW_LIT(S, MRB_STR_NEW_CSTR(S->MRB, P1));
      INT ARGC = 1;

      GENOP_1(S, OP_OCLASS, CURSP());
      GENOP_2(S, OP_GETMCNST, CURSP(), SYM);
      PUSH();
      GENOP_2(S, OP_STRING, CURSP(), OFF);
      PUSH();
      IF (P2 || P3) {
        IF (P2) { /* OPT */
          OFF = NEW_LIT(S, MRB_STR_NEW_CSTR(S->MRB, P2));
          GENOP_2(S, OP_STRING, CURSP(), OFF);
        }
        ELSE {
          GENOP_1(S, OP_LOADNIL, CURSP());
        }
        PUSH();
        ARGC++;
        IF (P3) { /* ENC */
          OFF = NEW_LIT(S, MRB_STR_NEW(S->MRB, P3, 1));
          GENOP_2(S, OP_STRING, CURSP(), OFF);
          PUSH();
          ARGC++;
        }
      }
      PUSH(); /* SPACE FOR A BLOCK */
      POP_N(ARGC+2);
      SYM = NEW_SYM(S, MRB_SYM_2(S->MRB, COMPILE));
      GENOP_3(S, OP_SEND, CURSP(), SYM, ARGC);
      MRB_GC_ARENA_RESTORE(S->MRB, AI);
      PUSH();
    }
    BREAK;

  CASE NODE_DREGX:
    IF (VAL) {
      NODE *N = TREE->CAR;
      INT AI = MRB_GC_ARENA_SAVE(S->MRB);
      INT SYM = NEW_SYM(S, MRB_INTERN_LIT(S->MRB, REGEXP_CLASS));
      INT ARGC = 1;
      INT OFF;
      CHAR *P;

      GENOP_1(S, OP_OCLASS, CURSP());
      GENOP_2(S, OP_GETMCNST, CURSP(), SYM);
      PUSH();
      CODEGEN(S, N->CAR, VAL);
      N = N->CDR;
      WHILE (N) {
        CODEGEN(S, N->CAR, VAL);
        POP(); POP();
        GENOP_1(S, OP_STRCAT, CURSP());
        PUSH();
        N = N->CDR;
      }
      N = TREE->CDR->CDR;
      IF (N->CAR) { /* TAIL */
        P = (CHAR*)N->CAR;
        OFF = NEW_LIT(S, MRB_STR_NEW_CSTR(S->MRB, P));
        CODEGEN(S, TREE->CAR, VAL);
        GENOP_2(S, OP_STRING, CURSP(), OFF);
        POP();
        GENOP_1(S, OP_STRCAT, CURSP());
        PUSH();
      }
      IF (N->CDR->CAR) { /* OPT */
        CHAR *P2 = (CHAR*)N->CDR->CAR;
        OFF = NEW_LIT(S, MRB_STR_NEW_CSTR(S->MRB, P2));
        GENOP_2(S, OP_STRING, CURSP(), OFF);
        PUSH();
        ARGC++;
      }
      IF (N->CDR->CDR) { /* ENC */
        CHAR *P2 = (CHAR*)N->CDR->CDR;
        OFF = NEW_LIT(S, MRB_STR_NEW_CSTR(S->MRB, P2));
        GENOP_2(S, OP_STRING, CURSP(), OFF);
        PUSH();
        ARGC++;
      }
      PUSH(); /* SPACE FOR A BLOCK */
      POP_N(ARGC+2);
      SYM = NEW_SYM(S, MRB_SYM_2(S->MRB, COMPILE));
      GENOP_3(S, OP_SEND, CURSP(), SYM, ARGC);
      MRB_GC_ARENA_RESTORE(S->MRB, AI);
      PUSH();
    }
    ELSE {
      NODE *N = TREE->CAR;

      WHILE (N) {
        IF (NINT(N->CAR->CAR) != NODE_STR) {
          CODEGEN(S, N->CAR, NOVAL);
        }
        N = N->CDR;
      }
    }
    BREAK;

  CASE NODE_SYM:
    IF (VAL) {
      INT SYM = NEW_SYM(S, NSYM(TREE));

      GENOP_2(S, OP_LOADSYM, CURSP(), SYM);
      PUSH();
    }
    BREAK;

  CASE NODE_DSYM:
    CODEGEN(S, TREE, VAL);
    IF (VAL) {
      GEN_INTERN(S);
    }
    BREAK;

  CASE NODE_SELF:
    IF (VAL) {
      GENOP_1(S, OP_LOADSELF, CURSP());
      PUSH();
    }
    BREAK;

  CASE NODE_NIL:
    IF (VAL) {
      GENOP_1(S, OP_LOADNIL, CURSP());
      PUSH();
    }
    BREAK;

  CASE NODE_TRUE:
    IF (VAL) {
      GENOP_1(S, OP_LOADT, CURSP());
      PUSH();
    }
    BREAK;

  CASE NODE_FALSE:
    IF (VAL) {
      GENOP_1(S, OP_LOADF, CURSP());
      PUSH();
    }
    BREAK;

  CASE NODE_ALIAS:
    {
      INT A = NEW_SYM(S, NSYM(TREE->CAR));
      INT B = NEW_SYM(S, NSYM(TREE->CDR));

      GENOP_2(S, OP_ALIAS, A, B);
      IF (VAL) {
        GENOP_1(S, OP_LOADNIL, CURSP());
        PUSH();
      }
    }
   BREAK;

  CASE NODE_UNDEF:
    {
      NODE *T = TREE;

      WHILE (T) {
        INT SYMBOL = NEW_SYM(S, NSYM(T->CAR));
        GENOP_1(S, OP_UNDEF, SYMBOL);
        T = T->CDR;
      }
      IF (VAL) {
        GENOP_1(S, OP_LOADNIL, CURSP());
        PUSH();
      }
    }
    BREAK;

  CASE NODE_CLASS:
    {
      INT IDX;
      NODE *BODY;

      IF (TREE->CAR->CAR == (NODE*)0) {
        GENOP_1(S, OP_LOADNIL, CURSP());
        PUSH();
      }
      ELSE IF (TREE->CAR->CAR == (NODE*)1) {
        GENOP_1(S, OP_OCLASS, CURSP());
        PUSH();
      }
      ELSE {
        CODEGEN(S, TREE->CAR->CAR, VAL);
      }
      IF (TREE->CDR->CAR) {
        CODEGEN(S, TREE->CDR->CAR, VAL);
      }
      ELSE {
        GENOP_1(S, OP_LOADNIL, CURSP());
        PUSH();
      }
      POP(); POP();
      IDX = NEW_SYM(S, NSYM(TREE->CAR->CDR));
      GENOP_2(S, OP_CLASS, CURSP(), IDX);
      BODY = TREE->CDR->CDR->CAR;
      IF (NINT(BODY->CDR->CAR) == NODE_BEGIN && BODY->CDR->CDR == NULL) {
        GENOP_1(S, OP_LOADNIL, CURSP());
      }
      ELSE {
        IDX = SCOPE_BODY(S, BODY, VAL);
        GENOP_2(S, OP_EXEC, CURSP(), IDX);
      }
      IF (VAL) {
        PUSH();
      }
    }
    BREAK;

  CASE NODE_MODULE:
    {
      INT IDX;

      IF (TREE->CAR->CAR == (NODE*)0) {
        GENOP_1(S, OP_LOADNIL, CURSP());
        PUSH();
      }
      ELSE IF (TREE->CAR->CAR == (NODE*)1) {
        GENOP_1(S, OP_OCLASS, CURSP());
        PUSH();
      }
      ELSE {
        CODEGEN(S, TREE->CAR->CAR, VAL);
      }
      POP();
      IDX = NEW_SYM(S, NSYM(TREE->CAR->CDR));
      GENOP_2(S, OP_MODULE, CURSP(), IDX);
      IF (NINT(TREE->CDR->CAR->CDR->CAR) == NODE_BEGIN &&
          TREE->CDR->CAR->CDR->CDR == NULL) {
        GENOP_1(S, OP_LOADNIL, CURSP());
      }
      ELSE {
        IDX = SCOPE_BODY(S, TREE->CDR->CAR, VAL);
        GENOP_2(S, OP_EXEC, CURSP(), IDX);
      }
      IF (VAL) {
        PUSH();
      }
    }
    BREAK;

  CASE NODE_SCLASS:
    {
      INT IDX;

      CODEGEN(S, TREE->CAR, VAL);
      POP();
      GENOP_1(S, OP_SCLASS, CURSP());
      IF (NINT(TREE->CDR->CAR->CDR->CAR) == NODE_BEGIN &&
          TREE->CDR->CAR->CDR->CDR == NULL) {
        GENOP_1(S, OP_LOADNIL, CURSP());
      }
      ELSE {
        IDX = SCOPE_BODY(S, TREE->CDR->CAR, VAL);
        GENOP_2(S, OP_EXEC, CURSP(), IDX);
      }
      IF (VAL) {
        PUSH();
      }
    }
    BREAK;

  CASE NODE_DEF:
    {
      INT SYM = NEW_SYM(S, NSYM(TREE->CAR));
      INT IDX = LAMBDA_BODY(S, TREE->CDR, 0);

      GENOP_1(S, OP_TCLASS, CURSP());
      PUSH();
      GENOP_2(S, OP_METHOD, CURSP(), IDX);
      PUSH(); POP();
      POP();
      GENOP_2(S, OP_DEF, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_SDEF:
    {
      NODE *RECV = TREE->CAR;
      INT SYM = NEW_SYM(S, NSYM(TREE->CDR->CAR));
      INT IDX = LAMBDA_BODY(S, TREE->CDR->CDR, 0);

      CODEGEN(S, RECV, VAL);
      POP();
      GENOP_1(S, OP_SCLASS, CURSP());
      PUSH();
      GENOP_2(S, OP_METHOD, CURSP(), IDX);
      POP();
      GENOP_2(S, OP_DEF, CURSP(), SYM);
      IF (VAL) PUSH();
    }
    BREAK;

  CASE NODE_POSTEXE:
    CODEGEN(S, TREE, NOVAL);
    BREAK;

  DEFAULT:
    BREAK;
  }
 EXIT:
  S->RLEV = RLEV;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 336592_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC VOID REDS_HANDLE_READ_LINK_DONE(VOID *OPAQUE)
{
    REDLINKINFO *LINK = (REDLINKINFO *)OPAQUE;
    REDSSTATE *REDS = LINK->REDS;
    SPICELINKMESS *LINK_MESS = LINK->LINK_MESS;
    UINT32_T NUM_CAPS;
    UINT32_T *CAPS;
    INT AUTH_SELECTION;
    UNSIGNED INT I;

    LINK_MESS->CAPS_OFFSET = GUINT32_FROM_LE(LINK_MESS->CAPS_OFFSET);
    LINK_MESS->CONNECTION_ID = GUINT32_FROM_LE(LINK_MESS->CONNECTION_ID);
    LINK_MESS->NUM_CHANNEL_CAPS = GUINT32_FROM_LE(LINK_MESS->NUM_CHANNEL_CAPS);
    LINK_MESS->NUM_COMMON_CAPS = GUINT32_FROM_LE(LINK_MESS->NUM_COMMON_CAPS);

    /* PREVENT DOS. CURRENTLY WE DEFINED ONLY 13 CAPABILITIES,
     * I EXPECT 1024 TO BE VALID FOR QUITE A LOT TIME */
    IF (LINK_MESS->NUM_CHANNEL_CAPS > 1024 || LINK_MESS->NUM_COMMON_CAPS > 1024) {
        REDS_SEND_LINK_ERROR(LINK, SPICE_LINK_ERR_INVALID_DATA);
        REDS_LINK_FREE(LINK);
        RETURN;
    }

    NUM_CAPS = LINK_MESS->NUM_COMMON_CAPS + LINK_MESS->NUM_CHANNEL_CAPS;
    CAPS = (UINT32_T *)((UINT8_T *)LINK_MESS + LINK_MESS->CAPS_OFFSET);

    IF (NUM_CAPS && (NUM_CAPS * SIZEOF(UINT32_T) + LINK_MESS->CAPS_OFFSET >
                     LINK->LINK_HEADER.SIZE ||
                     LINK_MESS->CAPS_OFFSET < SIZEOF(*LINK_MESS))) {
        REDS_SEND_LINK_ERROR(LINK, SPICE_LINK_ERR_INVALID_DATA);
        REDS_LINK_FREE(LINK);
        RETURN;
    }

    FOR(I = 0; I < NUM_CAPS;I++)
        CAPS[I] = GUINT32_FROM_LE(CAPS[I]);

    AUTH_SELECTION = RED_LINK_INFO_TEST_CAPABILITY(LINK,
                                                   SPICE_COMMON_CAP_PROTOCOL_AUTH_SELECTION);

    IF (!REDS_SECURITY_CHECK(LINK)) {
        IF (RED_STREAM_IS_SSL(LINK->STREAM)) {
            SPICE_WARNING("SPICE CHANNELS %D SHOULD NOT BE ENCRYPTED", LINK_MESS->CHANNEL_TYPE);
            REDS_SEND_LINK_ERROR(LINK, SPICE_LINK_ERR_NEED_UNSECURED);
        } ELSE {
            SPICE_WARNING("SPICE CHANNELS %D SHOULD BE ENCRYPTED", LINK_MESS->CHANNEL_TYPE);
            REDS_SEND_LINK_ERROR(LINK, SPICE_LINK_ERR_NEED_SECURED);
        }
        REDS_LINK_FREE(LINK);
        RETURN;
    }

    IF (!REDS_SEND_LINK_ACK(REDS, LINK)) {
        REDS_LINK_FREE(LINK);
        RETURN;
    }

    IF (!AUTH_SELECTION) {
        IF (REDS->CONFIG->SASL_ENABLED && !LINK->SKIP_AUTH) {
            SPICE_WARNING("SASL ENABLED, BUT PEER SUPPORTS ONLY SPICE AUTHENTICATION");
            REDS_SEND_LINK_ERROR(LINK, SPICE_LINK_ERR_VERSION_MISMATCH);
            RETURN;
        }
        SPICE_WARNING("PEER DOESN'T SUPPORT AUTH SELECTION");
        REDS_GET_SPICE_TICKET(LINK);
    } ELSE {
        RED_STREAM_ASYNC_READ(LINK->STREAM,
                              (UINT8_T *)&LINK->AUTH_MECHANISM,
                              SIZEOF(SPICELINKAUTHMECHANISM),
                              REDS_HANDLE_AUTH_MECHANISM,
                              LINK);
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 217551_CWE-125.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT PARSE(CHAR *ELF) {
    INT FD;
    STRUCT STAT ST;
    UINT8_T *ELF_MAP;
    INT COUNT;
    CHAR *TMP;
    CHAR *NAME;
    CHAR FLAG[4];

    MODE = GET_ELF_CLASS(ELF);

    FD = OPEN(ELF, O_RDONLY);
    IF (FD < 0) {
        PERROR("OPEN");
        RETURN -1;
    }

    IF (FSTAT(FD, &ST) < 0) {
        PERROR("FSTAT");
        RETURN -1;
    }

    ELF_MAP = MMAP(0, ST.ST_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, FD, 0);
    IF (ELF_MAP == MAP_FAILED) {
        PERROR("MMAP");
        RETURN -1;
    }

    /* 32BIT */
    IF (MODE == ELFCLASS32) {
        /* ELF HEADER INFORMATION */
        ELF32_EHDR *EHDR;
        EHDR = (ELF32_EHDR *)ELF_MAP;

        INFO("ELF HEADER\N");        
        SWITCH (EHDR->E_TYPE) {
            CASE ET_NONE:
                TMP = "AN UNKNOWN TYPE";
                BREAK;

            CASE ET_REL:
                TMP = "A RELOCATABLE FILE";
                BREAK;

            CASE ET_EXEC:
                TMP = "AN EXECUTABLE FILE";
                BREAK;

            CASE ET_DYN:
                TMP = "A SHARED OBJECT";
                BREAK;

            CASE ET_CORE:
                TMP = "A CORE FILE";
                BREAK;
            
            DEFAULT:
                TMP = "AN UNKNOWN TYPE";
                BREAK;
        }
        PRINT_HEADER_EXP("E_TYPE:", EHDR->E_TYPE, TMP);

        SWITCH (EHDR->E_TYPE) {
            CASE EM_NONE:
                TMP = "AN UNKNOWN MACHINE";
                BREAK;

            CASE EM_M32:
                TMP = "AT&T WE 32100";
                BREAK;

            CASE EM_SPARC:
                TMP = "SUN MICROSYSTEMS SPARC";
                BREAK;

            CASE EM_386:
                TMP = "INTEL 80386";
                BREAK;

            CASE EM_68K:
                TMP = "MOTOROLA 68000";
                BREAK;
            
            CASE EM_88K:
                TMP = "MOTOROLA 88000";
                BREAK;

            CASE EM_860:
                TMP = "INTEL 80860";
                BREAK;

            CASE EM_MIPS:
                TMP = "MIPS RS3000 (BIG-ENDIAN ONLY)";
                BREAK;

            CASE EM_PARISC:
                TMP = "HP/PA";
                BREAK;

            CASE EM_SPARC32PLUS:
                TMP = "SPARC WITH ENHANCED INSTRUCTION SET";
                BREAK;
            
            CASE EM_PPC:
                TMP = "POWERPC";
                BREAK;

            CASE EM_PPC64:
                TMP = "POWERPC 64-BIT";
                BREAK;

            CASE EM_S390:
                TMP = "IBM S/390";
                BREAK;

            CASE EM_ARM:
                TMP = "ADVANCED RISC MACHINES";
                BREAK;

            CASE EM_SH:
                TMP = "RENESAS SUPERH";
                BREAK;
            
            CASE EM_SPARCV9:
                TMP = "SPARC V9 64-BIT";
                BREAK;

            CASE EM_IA_64:
                TMP = "INTEL ITANIUM";
                BREAK;

            CASE EM_X86_64:
                TMP = "AMD X86-64";
                BREAK;

            CASE EM_VAX:
                TMP = "DEC VAX";
                BREAK;
            
            DEFAULT:
                TMP = "AN UNKNOWN MACHINE";
                BREAK;
        }
        PRINT_HEADER_EXP("E_MACHINE:", EHDR->E_MACHINE, TMP);

        SWITCH (EHDR->E_VERSION) {
            CASE EV_NONE:
                TMP = "INVALID VERSION";
                BREAK;

            CASE EV_CURRENT:
                TMP = "CURRENT VERSION";
                BREAK;

            DEFAULT:
                TMP = "KNOWN VERSION";
                BREAK;
        }
        PRINT_HEADER_EXP("E_VERSION:", EHDR->E_VERSION, TMP);
        PRINT_HEADER("E_ENTRY:", EHDR->E_ENTRY);
        PRINT_HEADER("E_PHOFF:", EHDR->E_PHOFF);
        PRINT_HEADER("E_SHOFF:", EHDR->E_SHOFF);
        PRINT_HEADER("E_FLAGS:", EHDR->E_FLAGS);
        PRINT_HEADER("E_EHSIZE:", EHDR->E_EHSIZE);
        PRINT_HEADER("E_PHENTSIZE:", EHDR->E_PHENTSIZE);
        PRINT_HEADER("E_PHNUM:", EHDR->E_PHNUM);
        PRINT_HEADER("E_SHENTSIZE:", EHDR->E_SHENTSIZE);
        PRINT_HEADER("E_SHENTSIZE:", EHDR->E_SHENTSIZE);
        PRINT_HEADER("E_SHSTRNDX:", EHDR->E_SHSTRNDX);

        /* SECTION INFORMATION */
        ELF32_SHDR *SHDR;
        ELF32_PHDR *PHDR;
        ELF32_SHDR SHSTRTAB;

        SHDR = (ELF32_SHDR *)&ELF_MAP[EHDR->E_SHOFF];
        PHDR = (ELF32_PHDR *)&ELF_MAP[EHDR->E_PHOFF];
        SHSTRTAB = SHDR[EHDR->E_SHSTRNDX];

        INFO("SECTION HEADER TABLE\N");
        PRINT_SECTION_TITLE("NR", "NAME", "TYPE", "ADDR", "OFF", "SIZE", "ES", "FLG", "LK", "INF", "AL");
        FOR (INT I = 0; I < EHDR->E_SHNUM; I++) {
            NAME = ELF_MAP + SHSTRTAB.SH_OFFSET + SHDR[I].SH_NAME;

            SWITCH (SHDR[I].SH_TYPE) {
                CASE SHT_NULL:
                    TMP = "SHT_NULL";
                    BREAK;
                
                CASE SHT_PROGBITS:
                    TMP = "SHT_PROGBITS";
                    BREAK;

                CASE SHT_SYMTAB:
                    TMP = "SHT_SYMTAB";
                    BREAK;

                CASE SHT_STRTAB:
                    TMP = "SHT_STRTAB";
                    BREAK;

                CASE SHT_RELA:
                    TMP = "SHT_RELA";
                    BREAK;

                CASE SHT_HASH:
                    TMP = "SHT_HASH";
                    BREAK;

                CASE SHT_DYNAMIC:
                    TMP = "SHT_DYNAMIC";
                    BREAK;

                CASE SHT_NOTE:
                    TMP = "SHT_NOTE";
                    BREAK;

                CASE SHT_NOBITS:
                    TMP = "SHT_NOBITS";
                    BREAK;

                CASE SHT_REL:
                    TMP = "SHT_REL";
                    BREAK;

                CASE SHT_SHLIB:
                    TMP = "SHT_SHLIB";
                    BREAK;

                CASE SHT_DYNSYM:
                    TMP = "SHT_DYNSYM";
                    BREAK;

                CASE SHT_LOPROC:
                    TMP = "SHT_LOPROC";
                    BREAK;

                CASE SHT_HIPROC:
                    TMP = "SHT_HIPROC";
                    BREAK;

                CASE SHT_LOUSER:
                    TMP = "SHT_LOUSER";
                    BREAK;

                CASE SHT_HIUSER:
                    TMP = "SHT_HIUSER";
                    BREAK;
                
                DEFAULT:
                    BREAK;
            }

            IF (STRLEN(NAME) > 15) {
                STRCPY(&NAME[15 - 6], "[...]");
            }
            STRCPY(FLAG, "   ");
            FLAG2STR_SH(SHDR[I].SH_FLAGS, FLAG);
            PRINT_SECTION(I, NAME, TMP, SHDR[I].SH_ADDR, SHDR[I].SH_OFFSET, SHDR[I].SH_SIZE, SHDR[I].SH_ENTSIZE, \
                            FLAG, SHDR[I].SH_LINK, SHDR[I].SH_INFO, SHDR[I].SH_ADDRALIGN);
        }

        INFO("PROGRAM HEADER TABLE\N");
        PRINT_PROGRAM_TITLE("NR", "TYPE", "OFFSET", "VIRTADDR", "PHYSADDR", "FILESIZ", "MEMSIZ", "FLG", "ALIGN");
        FOR (INT I = 0; I < EHDR->E_PHNUM; I++) {
            SWITCH (PHDR[I].P_TYPE) {
                CASE PT_NULL:
                    TMP = "PT_NULL";
                    BREAK;
                
                CASE PT_LOAD:
                    TMP = "PT_LOAD";
                    BREAK;

                CASE PT_DYNAMIC:
                    TMP = "PT_DYNAMIC";
                    BREAK;

                CASE PT_INTERP:
                    TMP = "PT_INTERP";
                    BREAK;

                CASE PT_NOTE:
                    TMP = "PT_NOTE";
                    BREAK;

                CASE PT_SHLIB:
                    TMP = "PT_SHLIB";
                    BREAK;

                CASE PT_PHDR:
                    TMP = "PT_PHDR";
                    BREAK;

                CASE PT_LOPROC:
                    TMP = "PT_LOPROC";
                    BREAK;

                CASE PT_HIPROC:
                    TMP = "PT_HIPROC";
                    BREAK;

                CASE PT_GNU_STACK:
                    TMP = "PT_GNU_STACK";
                    BREAK;
                
                DEFAULT:
                    BREAK;
            }
            STRCPY(FLAG, "   ");
            FLAG2STR(PHDR[I].P_FLAGS, FLAG);
            PRINT_PROGRAM(I, TMP, PHDR[I].P_OFFSET, PHDR[I].P_VADDR, PHDR[I].P_PADDR, PHDR[I].P_FILESZ, PHDR[I].P_MEMSZ, FLAG, PHDR[I].P_ALIGN); 
        }

        INFO("SECTION TO SEGMENT MAPPING\N");
        FOR (INT I = 0; I < EHDR->E_PHNUM; I++) {
            PRINTF("     [%2D]", I);
            FOR (INT J = 0; J < EHDR->E_SHNUM; J++) {
                NAME = ELF_MAP + SHSTRTAB.SH_OFFSET + SHDR[J].SH_NAME;
                IF (SHDR[J].SH_ADDR >= PHDR[I].P_VADDR && SHDR[J].SH_ADDR + SHDR[J].SH_SIZE <= PHDR[I].P_VADDR + PHDR[I].P_MEMSZ && SHDR[J].SH_TYPE != SHT_NULL) {
                    IF (SHDR[J].SH_FLAGS >> 1 & 0X1) {
                        PRINTF(" %S", NAME);
                    }
                }    
            }
            PRINTF("\N");
        }

        INFO("DYNAMIC LINK INFORMATION\N");
        INT DYNSTR;
        INT DYNAMIC;
        ELF32_DYN *DYN;
        FOR (INT I = 0; I < EHDR->E_SHNUM; I++) {
            NAME = ELF_MAP + SHSTRTAB.SH_OFFSET + SHDR[I].SH_NAME;
            IF (!STRCMP(NAME, ".DYNSTR")) {
                DYNSTR = I;
            }
            IF (!STRCMP(NAME, ".DYNAMIC")) {
                DYNAMIC = I;
            }
        }

        CHAR VALUE[50];
        NAME = "";
        DYN = (ELF32_DYN *)&ELF_MAP[SHDR[DYNAMIC].SH_OFFSET];
        COUNT = SHDR[DYNAMIC].SH_SIZE / SIZEOF(ELF32_DYN);
        INFO("DYNAMIC SECTION AT OFFSET 0X%X CONTAINS %D ENTRIES\N", SHDR[DYNAMIC].SH_OFFSET, COUNT);
        PRINT_DYN_TITLE("TAG", "TYPE", "NAME/VALUE");
        
        FOR(INT I = 0; I < COUNT; I++) {
            TMP = "";
            MEMSET(VALUE, 0, 50);
            SNPRINTF(VALUE, 50, "0X%X", DYN[I].D_UN.D_VAL);
            SWITCH (DYN[I].D_TAG) {
                /* LEGAL VALUES FOR D_TAG (DYNAMIC ENTRY TYPE).  */
                CASE DT_NULL:
                    TMP = "DT_NULL";
                    BREAK;

                CASE DT_NEEDED:
                    TMP = "DT_NEEDED";
                    NAME = ELF_MAP + SHDR[DYNSTR].SH_OFFSET + DYN[I].D_UN.D_VAL;
                    SNPRINTF(VALUE, 50, "SHARED LIBRARY: [%S]", NAME);
                    BREAK;
                
                CASE DT_PLTRELSZ:
                    TMP = "DT_PLTRELSZ";
                    BREAK;

                CASE DT_PLTGOT:
                    TMP = "DT_PLTGOT";
                    BREAK;

                CASE DT_HASH:
                    TMP = "DT_HASH";
                    BREAK;

                CASE DT_STRTAB:
                    TMP = "DT_STRTAB";
                    BREAK;

                CASE DT_SYMTAB:
                    TMP = "DT_SYMTAB";
                    BREAK;

                CASE DT_RELA:
                    TMP = "DT_RELA";
                    BREAK;

                CASE DT_RELASZ:
                    TMP = "DT_RELASZ";
                    BREAK;

                CASE DT_RELAENT:
                    TMP = "DT_RELAENT";
                    BREAK;

                CASE DT_STRSZ:
                    TMP = "DT_STRSZ";
                    BREAK;

                CASE DT_SYMENT:
                    TMP = "DT_SYMENT";
                    BREAK;

                CASE DT_INIT:
                    TMP = "DT_INIT";
                    BREAK;

                CASE DT_FINI:
                    TMP = "DT_FINI";
                    BREAK;

                CASE DT_SONAME:
                    TMP = "DT_SONAME";
                    BREAK;

                CASE DT_RPATH:
                    TMP = "DT_RPATH";
                    BREAK;

                CASE DT_SYMBOLIC:
                    TMP = "DT_SYMBOLIC";
                    BREAK;

                CASE DT_REL:
                    TMP = "DT_REL";
                    BREAK;

                CASE DT_RELSZ:
                    TMP = "DT_RELSZ";
                    BREAK;

                CASE DT_RELENT:
                    TMP = "DT_RELENT";
                    BREAK;
                    
                CASE DT_PLTREL:
                    TMP = "DT_PLTREL";
                    BREAK;

                CASE DT_DEBUG:
                    TMP = "DT_DEBUG";
                    BREAK;

                CASE DT_TEXTREL:
                    TMP = "DT_TEXTREL";
                    BREAK;

                CASE DT_JMPREL:
                    TMP = "DT_JMPREL";
                    BREAK;

                CASE DT_BIND_NOW:
                    TMP = "DT_BIND_NOW";
                    BREAK;

                CASE DT_INIT_ARRAY:
                    TMP = "DT_INIT_ARRAY";
                    BREAK;

                CASE DT_FINI_ARRAY:
                    TMP = "DT_FINI_ARRAY";
                    BREAK;

                CASE DT_INIT_ARRAYSZ:
                    TMP = "DT_INIT_ARRAYSZ";
                    BREAK;
                
                CASE DT_FINI_ARRAYSZ:
                    TMP = "DT_FINI_ARRAYSZ";
                    BREAK;

                CASE DT_RUNPATH:
                    TMP = "DT_RUNPATH";
                    BREAK;

                CASE DT_FLAGS:
                    TMP = "DT_FLAGS";
                    SNPRINTF(VALUE, 50, "FLAGS: %D", DYN[I].D_UN.D_VAL);
                    BREAK;
                
                CASE DT_ENCODING:
                    TMP = "DT_ENCODING";
                    BREAK;

                CASE DT_PREINIT_ARRAYSZ:
                    TMP = "DT_PREINIT_ARRAYSZ";
                    BREAK;

                CASE DT_SYMTAB_SHNDX:
                    TMP = "DT_SYMTAB_SHNDX";
                    BREAK;
                
                CASE DT_NUM:
                    TMP = "DT_NUM";
                    BREAK;

                CASE DT_LOOS:
                    TMP = "DT_LOOS";
                    BREAK;

                CASE DT_HIOS:
                    TMP = "DT_HIOS";
                    BREAK;

                CASE DT_LOPROC:
                    TMP = "DT_LOPROC";
                    BREAK;

                CASE DT_HIPROC:
                    TMP = "DT_HIPROC";
                    BREAK;

                CASE DT_PROCNUM:
                    TMP = "DT_LOPROC";
                    BREAK;

                /* DT_* ENTRIES WHICH FALL BETWEEN DT_VALRNGHI & DT_VALRNGLO USE THE
                 * DYN.D_UN.D_VAL FIELD OF THE ELF*_DYN STRUCTURE.  THIS FOLLOWS SUN'S
                 * APPROACH. */

                CASE DT_VALRNGLO:
                    TMP = "DT_VALRNGLO";
                    BREAK;

                CASE DT_GNU_PRELINKED:
                    TMP = "DT_GNU_PRELINKED";
                    BREAK;
                
                CASE DT_GNU_CONFLICTSZ:
                    TMP = "DT_GNU_CONFLICTSZ";
                    BREAK;

                CASE DT_GNU_LIBLISTSZ:
                    TMP = "DT_GNU_LIBLISTSZ";
                    BREAK;

                CASE DT_CHECKSUM:
                    TMP = "DT_CHECKSUM";
                    BREAK;

                CASE DT_PLTPADSZ:
                    TMP = "DT_PLTPADSZ";
                    BREAK;

                CASE DT_MOVEENT:
                    TMP = "DT_MOVEENT";
                    BREAK;

                CASE DT_MOVESZ:
                    TMP = "DT_MOVESZ";
                    BREAK;

                CASE DT_FEATURE_1:
                    TMP = "DT_FEATURE_1";
                    BREAK;

                CASE DT_POSFLAG_1:
                    TMP = "DT_POSFLAG_1";
                    BREAK;

                CASE DT_SYMINSZ:
                    TMP = "DT_SYMINSZ";
                    BREAK;

                CASE DT_SYMINENT:
                    TMP = "DT_SYMINENT";
                    BREAK;

                /* DT_* ENTRIES WHICH FALL BETWEEN DT_ADDRRNGHI & DT_ADDRRNGLO USE THE
                 * DYN.D_UN.D_PTR FIELD OF THE ELF*_DYN STRUCTURE.
                 * IF ANY ADJUSTMENT IS MADE TO THE ELF OBJECT AFTER IT HAS BEEN
                 * BUILT THESE ENTRIES WILL NEED TO BE ADJUSTED.  */
                CASE DT_ADDRRNGLO:
                    TMP = "DT_ADDRRNGLO";
                    BREAK;

                CASE DT_GNU_HASH:
                    TMP = "DT_GNU_HASH";
                    BREAK;

                CASE DT_TLSDESC_PLT:
                    TMP = "DT_TLSDESC_PLT";
                    BREAK;

                CASE DT_TLSDESC_GOT:
                    TMP = "DT_TLSDESC_GOT";
                    BREAK;

                CASE DT_GNU_CONFLICT:
                    TMP = "DT_GNU_CONFLICT";
                    BREAK;

                CASE DT_GNU_LIBLIST:
                    TMP = "DT_GNU_LIBLIST";
                    BREAK;

                CASE DT_CONFIG:
                    TMP = "DT_CONFIG";
                    BREAK;

                CASE DT_DEPAUDIT:
                    TMP = "DT_DEPAUDIT";
                    BREAK;

                CASE DT_AUDIT:
                    TMP = "DT_AUDIT";
                    BREAK;

                CASE DT_PLTPAD:
                    TMP = "DT_PLTPAD";
                    BREAK;

                CASE DT_MOVETAB:
                    TMP = "DT_MOVETAB";
                    BREAK;

                CASE DT_SYMINFO:
                    TMP = "DT_SYMINFO";
                    BREAK;
                    
                /* THE VERSIONING ENTRY TYPES.  THE NEXT ARE DEFINED AS PART OF THE
                 * GNU EXTENSION.  */
                CASE DT_VERSYM:
                    TMP = "DT_VERSYM";
                    BREAK;

                CASE DT_RELACOUNT:
                    TMP = "DT_RELACOUNT";
                    BREAK;

                CASE DT_RELCOUNT:
                    TMP = "DT_RELCOUNT";
                    BREAK;
                
                /* THESE WERE CHOSEN BY SUN.  */
                CASE DT_FLAGS_1:
                    TMP = "DT_FLAGS_1";
                    SWITCH (DYN[I].D_UN.D_VAL) {
                        CASE DF_1_PIE:
                            SNPRINTF(VALUE, 50, "FLAGS: %S", "PIE");
                            BREAK;
                        
                        DEFAULT:
                            SNPRINTF(VALUE, 50, "FLAGS: %D", DYN[I].D_UN.D_VAL);
                            BREAK;
                    }
                    
                    BREAK;

                CASE DT_VERDEF:
                    TMP = "DT_VERDEF";
                    BREAK;

                CASE DT_VERDEFNUM:
                    TMP = "DT_VERDEFNUM";
                    BREAK;

                CASE DT_VERNEED:
                    TMP = "DT_VERNEED";
                    BREAK;

                CASE DT_VERNEEDNUM:
                    TMP = "DT_VERNEEDNUM";
                    BREAK;
                
                DEFAULT:
                    BREAK;
            }
            PRINT_DYN(DYN[I].D_TAG, TMP, VALUE);
        }        
    }

    /* 64BIT */
    IF (MODE == ELFCLASS64) {
        /* ELF HEADER INFORMATION */
        ELF64_EHDR *EHDR;
        EHDR = (ELF64_EHDR *)ELF_MAP;

        INFO("ELF HEADER\N");        
        SWITCH (EHDR->E_TYPE) {
            CASE ET_NONE:
                TMP = "AN UNKNOWN TYPE";
                BREAK;

            CASE ET_REL:
                TMP = "A RELOCATABLE FILE";
                BREAK;

            CASE ET_EXEC:
                TMP = "AN EXECUTABLE FILE";
                BREAK;

            CASE ET_DYN:
                TMP = "A SHARED OBJECT";
                BREAK;

            CASE ET_CORE:
                TMP = "A CORE FILE";
                BREAK;
            
            DEFAULT:
                TMP = "AN UNKNOWN TYPE";
                BREAK;
        }
        PRINT_HEADER_EXP("E_TYPE:", EHDR->E_TYPE, TMP);

        SWITCH (EHDR->E_TYPE) {
            CASE EM_NONE:
                TMP = "AN UNKNOWN MACHINE";
                BREAK;

            CASE EM_M32:
                TMP = "AT&T WE 32100";
                BREAK;

            CASE EM_SPARC:
                TMP = "SUN MICROSYSTEMS SPARC";
                BREAK;

            CASE EM_386:
                TMP = "INTEL 80386";
                BREAK;

            CASE EM_68K:
                TMP = "MOTOROLA 68000";
                BREAK;
            
            CASE EM_88K:
                TMP = "MOTOROLA 88000";
                BREAK;

            CASE EM_860:
                TMP = "INTEL 80860";
                BREAK;

            CASE EM_MIPS:
                TMP = "MIPS RS3000 (BIG-ENDIAN ONLY)";
                BREAK;

            CASE EM_PARISC:
                TMP = "HP/PA";
                BREAK;

            CASE EM_SPARC32PLUS:
                TMP = "SPARC WITH ENHANCED INSTRUCTION SET";
                BREAK;
            
            CASE EM_PPC:
                TMP = "POWERPC";
                BREAK;

            CASE EM_PPC64:
                TMP = "POWERPC 64-BIT";
                BREAK;

            CASE EM_S390:
                TMP = "IBM S/390";
                BREAK;

            CASE EM_ARM:
                TMP = "ADVANCED RISC MACHINES";
                BREAK;

            CASE EM_SH:
                TMP = "RENESAS SUPERH";
                BREAK;
            
            CASE EM_SPARCV9:
                TMP = "SPARC V9 64-BIT";
                BREAK;

            CASE EM_IA_64:
                TMP = "INTEL ITANIUM";
                BREAK;

            CASE EM_X86_64:
                TMP = "AMD X86-64";
                BREAK;

            CASE EM_VAX:
                TMP = "DEC VAX";
                BREAK;
            
            DEFAULT:
                TMP = "AN UNKNOWN MACHINE";
                BREAK;
        }
        PRINT_HEADER_EXP("E_MACHINE:", EHDR->E_MACHINE, TMP);

        SWITCH (EHDR->E_VERSION) {
            CASE EV_NONE:
                TMP = "INVALID VERSION";
                BREAK;

            CASE EV_CURRENT:
                TMP = "CURRENT VERSION";
                BREAK;

            DEFAULT:
                TMP = "KNOWN VERSION";
                BREAK;
        }
        PRINT_HEADER_EXP("E_VERSION:", EHDR->E_VERSION, TMP);
        PRINT_HEADER("E_ENTRY:", EHDR->E_ENTRY);
        PRINT_HEADER("E_PHOFF:", EHDR->E_PHOFF);
        PRINT_HEADER("E_SHOFF:", EHDR->E_SHOFF);
        PRINT_HEADER("E_FLAGS:", EHDR->E_FLAGS);
        PRINT_HEADER("E_EHSIZE:", EHDR->E_EHSIZE);
        PRINT_HEADER("E_PHENTSIZE:", EHDR->E_PHENTSIZE);
        PRINT_HEADER("E_PHNUM:", EHDR->E_PHNUM);
        PRINT_HEADER("E_SHENTSIZE:", EHDR->E_SHENTSIZE);
        PRINT_HEADER("E_SHENTSIZE:", EHDR->E_SHENTSIZE);
        PRINT_HEADER("E_SHSTRNDX:", EHDR->E_SHSTRNDX);

        /* SECTION INFORMATION */
        ELF64_SHDR *SHDR;
        ELF64_PHDR *PHDR;
        ELF64_SHDR SHSTRTAB;

        SHDR = (ELF64_SHDR *)&ELF_MAP[EHDR->E_SHOFF];
        PHDR = (ELF64_PHDR *)&ELF_MAP[EHDR->E_PHOFF];
        SHSTRTAB = SHDR[EHDR->E_SHSTRNDX];

        INFO("SECTION HEADER TABLE\N");
        PRINT_SECTION_TITLE("NR", "NAME", "TYPE", "ADDR", "OFF", "SIZE", "ES", "FLG", "LK", "INF", "AL");
        FOR (INT I = 0; I < EHDR->E_SHNUM; I++) {
            NAME = ELF_MAP + SHSTRTAB.SH_OFFSET + SHDR[I].SH_NAME;

            SWITCH (SHDR[I].SH_TYPE) {
                CASE SHT_NULL:
                    TMP = "SHT_NULL";
                    BREAK;
                
                CASE SHT_PROGBITS:
                    TMP = "SHT_PROGBITS";
                    BREAK;

                CASE SHT_SYMTAB:
                    TMP = "SHT_SYMTAB";
                    BREAK;

                CASE SHT_STRTAB:
                    TMP = "SHT_STRTAB";
                    BREAK;

                CASE SHT_RELA:
                    TMP = "SHT_RELA";
                    BREAK;

                CASE SHT_HASH:
                    TMP = "SHT_HASH";
                    BREAK;

                CASE SHT_DYNAMIC:
                    TMP = "SHT_DYNAMIC";
                    BREAK;

                CASE SHT_NOTE:
                    TMP = "SHT_NOTE";
                    BREAK;

                CASE SHT_NOBITS:
                    TMP = "SHT_NOBITS";
                    BREAK;

                CASE SHT_REL:
                    TMP = "SHT_REL";
                    BREAK;

                CASE SHT_SHLIB:
                    TMP = "SHT_SHLIB";
                    BREAK;

                CASE SHT_DYNSYM:
                    TMP = "SHT_DYNSYM";
                    BREAK;

                CASE SHT_LOPROC:
                    TMP = "SHT_LOPROC";
                    BREAK;

                CASE SHT_HIPROC:
                    TMP = "SHT_HIPROC";
                    BREAK;

                CASE SHT_LOUSER:
                    TMP = "SHT_LOUSER";
                    BREAK;

                CASE SHT_HIUSER:
                    TMP = "SHT_HIUSER";
                    BREAK;
                
                DEFAULT:
                    BREAK;
            }

            IF (STRLEN(NAME) > 15) {
                STRCPY(&NAME[15 - 6], "[...]");
            }
            STRCPY(FLAG, "   ");
            FLAG2STR_SH(SHDR[I].SH_FLAGS, FLAG);
            PRINT_SECTION(I, NAME, TMP, SHDR[I].SH_ADDR, SHDR[I].SH_OFFSET, SHDR[I].SH_SIZE, SHDR[I].SH_ENTSIZE, \
                            FLAG, SHDR[I].SH_LINK, SHDR[I].SH_INFO, SHDR[I].SH_ADDRALIGN);
        }

        INFO("PROGRAM HEADER TABLE\N");
        PRINT_PROGRAM_TITLE("NR", "TYPE", "OFFSET", "VIRTADDR", "PHYSADDR", "FILESIZ", "MEMSIZ", "FLG", "ALIGN");
        FOR (INT I = 0; I < EHDR->E_PHNUM; I++) {
            SWITCH (PHDR[I].P_TYPE) {
                CASE PT_NULL:
                    TMP = "PT_NULL";
                    BREAK;
                
                CASE PT_LOAD:
                    TMP = "PT_LOAD";
                    BREAK;

                CASE PT_DYNAMIC:
                    TMP = "PT_DYNAMIC";
                    BREAK;

                CASE PT_INTERP:
                    TMP = "PT_INTERP";
                    BREAK;

                CASE PT_NOTE:
                    TMP = "PT_NOTE";
                    BREAK;

                CASE PT_SHLIB:
                    TMP = "PT_SHLIB";
                    BREAK;

                CASE PT_PHDR:
                    TMP = "PT_PHDR";
                    BREAK;

                CASE PT_LOPROC:
                    TMP = "PT_LOPROC";
                    BREAK;

                CASE PT_HIPROC:
                    TMP = "PT_HIPROC";
                    BREAK;

                CASE PT_GNU_STACK:
                    TMP = "PT_GNU_STACK";
                    BREAK;
                
                DEFAULT:
                    BREAK;
            }
            STRCPY(FLAG, "   ");
            FLAG2STR(PHDR[I].P_FLAGS, FLAG);
            PRINT_PROGRAM(I, TMP, PHDR[I].P_OFFSET, PHDR[I].P_VADDR, PHDR[I].P_PADDR, PHDR[I].P_FILESZ, PHDR[I].P_MEMSZ, FLAG, PHDR[I].P_ALIGN); 
        }

        INFO("SECTION TO SEGMENT MAPPING\N");
        FOR (INT I = 0; I < EHDR->E_PHNUM; I++) {
            PRINTF("     [%2D]", I);
            FOR (INT J = 0; J < EHDR->E_SHNUM; J++) {
                NAME = ELF_MAP + SHSTRTAB.SH_OFFSET + SHDR[J].SH_NAME;
                IF (SHDR[J].SH_ADDR >= PHDR[I].P_VADDR && SHDR[J].SH_ADDR + SHDR[J].SH_SIZE <= PHDR[I].P_VADDR + PHDR[I].P_MEMSZ && SHDR[J].SH_TYPE != SHT_NULL) {
                    IF (SHDR[J].SH_FLAGS >> 1 & 0X1) {
                        PRINTF(" %S", NAME);
                    }
                }    
            }
            PRINTF("\N");
        }

        INFO("DYNAMIC LINK INFORMATION\N");
        INT DYNSTR;
        INT DYNAMIC;
        ELF64_DYN *DYN;
        FOR (INT I = 0; I < EHDR->E_SHNUM; I++) {
            NAME = ELF_MAP + SHSTRTAB.SH_OFFSET + SHDR[I].SH_NAME;
            IF (!STRCMP(NAME, ".DYNSTR")) {
                DYNSTR = I;
            }
            IF (!STRCMP(NAME, ".DYNAMIC")) {
                DYNAMIC = I;
            }
        }

        CHAR VALUE[50];
        NAME = "";
        DYN = (ELF64_DYN *)&ELF_MAP[SHDR[DYNAMIC].SH_OFFSET];
        COUNT = SHDR[DYNAMIC].SH_SIZE / SIZEOF(ELF64_DYN);
        INFO("DYNAMIC SECTION AT OFFSET 0X%X CONTAINS %D ENTRIES\N", SHDR[DYNAMIC].SH_OFFSET, COUNT);
        PRINT_DYN_TITLE("TAG", "TYPE", "NAME/VALUE");
        
        FOR(INT I = 0; I < COUNT; I++) {
            TMP = "";
            MEMSET(VALUE, 0, 50);
            SNPRINTF(VALUE, 50, "0X%X", DYN[I].D_UN.D_VAL);
            SWITCH (DYN[I].D_TAG) {
                /* LEGAL VALUES FOR D_TAG (DYNAMIC ENTRY TYPE).  */
                CASE DT_NULL:
                    TMP = "DT_NULL";
                    BREAK;

                CASE DT_NEEDED:
                    TMP = "DT_NEEDED";
                    NAME = ELF_MAP + SHDR[DYNSTR].SH_OFFSET + DYN[I].D_UN.D_VAL;
                    SNPRINTF(VALUE, 50, "SHARED LIBRARY: [%S]", NAME);
                    BREAK;
                
                CASE DT_PLTRELSZ:
                    TMP = "DT_PLTRELSZ";
                    BREAK;

                CASE DT_PLTGOT:
                    TMP = "DT_PLTGOT";
                    BREAK;

                CASE DT_HASH:
                    TMP = "DT_HASH";
                    BREAK;

                CASE DT_STRTAB:
                    TMP = "DT_STRTAB";
                    BREAK;

                CASE DT_SYMTAB:
                    TMP = "DT_SYMTAB";
                    BREAK;

                CASE DT_RELA:
                    TMP = "DT_RELA";
                    BREAK;

                CASE DT_RELASZ:
                    TMP = "DT_RELASZ";
                    BREAK;

                CASE DT_RELAENT:
                    TMP = "DT_RELAENT";
                    BREAK;

                CASE DT_STRSZ:
                    TMP = "DT_STRSZ";
                    BREAK;

                CASE DT_SYMENT:
                    TMP = "DT_SYMENT";
                    BREAK;

                CASE DT_INIT:
                    TMP = "DT_INIT";
                    BREAK;

                CASE DT_FINI:
                    TMP = "DT_FINI";
                    BREAK;

                CASE DT_SONAME:
                    TMP = "DT_SONAME";
                    BREAK;

                CASE DT_RPATH:
                    TMP = "DT_RPATH";
                    BREAK;

                CASE DT_SYMBOLIC:
                    TMP = "DT_SYMBOLIC";
                    BREAK;

                CASE DT_REL:
                    TMP = "DT_REL";
                    BREAK;

                CASE DT_RELSZ:
                    TMP = "DT_RELSZ";
                    BREAK;

                CASE DT_RELENT:
                    TMP = "DT_RELENT";
                    BREAK;
                    
                CASE DT_PLTREL:
                    TMP = "DT_PLTREL";
                    BREAK;

                CASE DT_DEBUG:
                    TMP = "DT_DEBUG";
                    BREAK;

                CASE DT_TEXTREL:
                    TMP = "DT_TEXTREL";
                    BREAK;

                CASE DT_JMPREL:
                    TMP = "DT_JMPREL";
                    BREAK;

                CASE DT_BIND_NOW:
                    TMP = "DT_BIND_NOW";
                    BREAK;

                CASE DT_INIT_ARRAY:
                    TMP = "DT_INIT_ARRAY";
                    BREAK;

                CASE DT_FINI_ARRAY:
                    TMP = "DT_FINI_ARRAY";
                    BREAK;

                CASE DT_INIT_ARRAYSZ:
                    TMP = "DT_INIT_ARRAYSZ";
                    BREAK;
                
                CASE DT_FINI_ARRAYSZ:
                    TMP = "DT_FINI_ARRAYSZ";
                    BREAK;

                CASE DT_RUNPATH:
                    TMP = "DT_RUNPATH";
                    BREAK;

                CASE DT_FLAGS:
                    TMP = "DT_FLAGS";
                    SNPRINTF(VALUE, 50, "FLAGS: %D", DYN[I].D_UN.D_VAL);
                    BREAK;
                
                CASE DT_ENCODING:
                    TMP = "DT_ENCODING";
                    BREAK;

                CASE DT_PREINIT_ARRAYSZ:
                    TMP = "DT_PREINIT_ARRAYSZ";
                    BREAK;

                CASE DT_SYMTAB_SHNDX:
                    TMP = "DT_SYMTAB_SHNDX";
                    BREAK;
                
                CASE DT_NUM:
                    TMP = "DT_NUM";
                    BREAK;

                CASE DT_LOOS:
                    TMP = "DT_LOOS";
                    BREAK;

                CASE DT_HIOS:
                    TMP = "DT_HIOS";
                    BREAK;

                CASE DT_LOPROC:
                    TMP = "DT_LOPROC";
                    BREAK;

                CASE DT_HIPROC:
                    TMP = "DT_HIPROC";
                    BREAK;

                CASE DT_PROCNUM:
                    TMP = "DT_LOPROC";
                    BREAK;

                /* DT_* ENTRIES WHICH FALL BETWEEN DT_VALRNGHI & DT_VALRNGLO USE THE
                 * DYN.D_UN.D_VAL FIELD OF THE ELF*_DYN STRUCTURE.  THIS FOLLOWS SUN'S
                 * APPROACH. */

                CASE DT_VALRNGLO:
                    TMP = "DT_VALRNGLO";
                    BREAK;

                CASE DT_GNU_PRELINKED:
                    TMP = "DT_GNU_PRELINKED";
                    BREAK;
                
                CASE DT_GNU_CONFLICTSZ:
                    TMP = "DT_GNU_CONFLICTSZ";
                    BREAK;

                CASE DT_GNU_LIBLISTSZ:
                    TMP = "DT_GNU_LIBLISTSZ";
                    BREAK;

                CASE DT_CHECKSUM:
                    TMP = "DT_CHECKSUM";
                    BREAK;

                CASE DT_PLTPADSZ:
                    TMP = "DT_PLTPADSZ";
                    BREAK;

                CASE DT_MOVEENT:
                    TMP = "DT_MOVEENT";
                    BREAK;

                CASE DT_MOVESZ:
                    TMP = "DT_MOVESZ";
                    BREAK;

                CASE DT_FEATURE_1:
                    TMP = "DT_FEATURE_1";
                    BREAK;

                CASE DT_POSFLAG_1:
                    TMP = "DT_POSFLAG_1";
                    BREAK;

                CASE DT_SYMINSZ:
                    TMP = "DT_SYMINSZ";
                    BREAK;

                CASE DT_SYMINENT:
                    TMP = "DT_SYMINENT";
                    BREAK;

                /* DT_* ENTRIES WHICH FALL BETWEEN DT_ADDRRNGHI & DT_ADDRRNGLO USE THE
                 * DYN.D_UN.D_PTR FIELD OF THE ELF*_DYN STRUCTURE.
                 * IF ANY ADJUSTMENT IS MADE TO THE ELF OBJECT AFTER IT HAS BEEN
                 * BUILT THESE ENTRIES WILL NEED TO BE ADJUSTED.  */
                CASE DT_ADDRRNGLO:
                    TMP = "DT_ADDRRNGLO";
                    BREAK;

                CASE DT_GNU_HASH:
                    TMP = "DT_GNU_HASH";
                    BREAK;

                CASE DT_TLSDESC_PLT:
                    TMP = "DT_TLSDESC_PLT";
                    BREAK;

                CASE DT_TLSDESC_GOT:
                    TMP = "DT_TLSDESC_GOT";
                    BREAK;

                CASE DT_GNU_CONFLICT:
                    TMP = "DT_GNU_CONFLICT";
                    BREAK;

                CASE DT_GNU_LIBLIST:
                    TMP = "DT_GNU_LIBLIST";
                    BREAK;

                CASE DT_CONFIG:
                    TMP = "DT_CONFIG";
                    BREAK;

                CASE DT_DEPAUDIT:
                    TMP = "DT_DEPAUDIT";
                    BREAK;

                CASE DT_AUDIT:
                    TMP = "DT_AUDIT";
                    BREAK;

                CASE DT_PLTPAD:
                    TMP = "DT_PLTPAD";
                    BREAK;

                CASE DT_MOVETAB:
                    TMP = "DT_MOVETAB";
                    BREAK;

                CASE DT_SYMINFO:
                    TMP = "DT_SYMINFO";
                    BREAK;
                    
                /* THE VERSIONING ENTRY TYPES.  THE NEXT ARE DEFINED AS PART OF THE
                 * GNU EXTENSION.  */
                CASE DT_VERSYM:
                    TMP = "DT_VERSYM";
                    BREAK;

                CASE DT_RELACOUNT:
                    TMP = "DT_RELACOUNT";
                    BREAK;

                CASE DT_RELCOUNT:
                    TMP = "DT_RELCOUNT";
                    BREAK;
                
                /* THESE WERE CHOSEN BY SUN.  */
                CASE DT_FLAGS_1:
                    TMP = "DT_FLAGS_1";
                    SWITCH (DYN[I].D_UN.D_VAL) {
                        CASE DF_1_PIE:
                            SNPRINTF(VALUE, 50, "FLAGS: %S", "PIE");
                            BREAK;
                        
                        DEFAULT:
                            SNPRINTF(VALUE, 50, "FLAGS: %D", DYN[I].D_UN.D_VAL);
                            BREAK;
                    }
                    
                    BREAK;

                CASE DT_VERDEF:
                    TMP = "DT_VERDEF";
                    BREAK;

                CASE DT_VERDEFNUM:
                    TMP = "DT_VERDEFNUM";
                    BREAK;

                CASE DT_VERNEED:
                    TMP = "DT_VERNEED";
                    BREAK;

                CASE DT_VERNEEDNUM:
                    TMP = "DT_VERNEEDNUM";
                    BREAK;
                
                DEFAULT:
                    BREAK;
            }
            PRINT_DYN(DYN[I].D_TAG, TMP, VALUE);
        }        
    }

    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512369_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL ITEM *GROUPING_FIELD_TRANSFORMER_FOR_WHERE(THD *THD, UCHAR *ARG)
  { RETURN THIS; }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210700_CWE-22.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIR *SQUASHFS_OPENDIR(UNSIGNED INT BLOCK_START, UNSIGNED INT OFFSET,
	STRUCT INODE **I)
{
	SQUASHFS_DIR_HEADER_2 DIRH;
	CHAR BUFFER[SIZEOF(SQUASHFS_DIR_ENTRY_2) + SQUASHFS_NAME_LEN + 1]
		__ATTRIBUTE__((ALIGNED));
	SQUASHFS_DIR_ENTRY_2 *DIRE = (SQUASHFS_DIR_ENTRY_2 *) BUFFER;
	LONG LONG START;
	INT BYTES;
	INT DIR_COUNT, SIZE;
	STRUCT DIR_ENT *NEW_DIR;
	STRUCT DIR *DIR;

	TRACE("SQUASHFS_OPENDIR: INODE START BLOCK %D, OFFSET %D\N",
		BLOCK_START, OFFSET);

	*I = READ_INODE(BLOCK_START, OFFSET);

	DIR = MALLOC(SIZEOF(STRUCT DIR));
	IF(DIR == NULL)
		EXIT_UNSQUASH("SQUASHFS_OPENDIR: MALLOC FAILED!\N");

	DIR->DIR_COUNT = 0;
	DIR->CUR_ENTRY = 0;
	DIR->MODE = (*I)->MODE;
	DIR->UID = (*I)->UID;
	DIR->GUID = (*I)->GID;
	DIR->MTIME = (*I)->TIME;
	DIR->XATTR = (*I)->XATTR;
	DIR->DIRS = NULL;

	IF ((*I)->DATA == 0)
		/*
		 * IF THE DIRECTORY IS EMPTY, SKIP THE UNNECESSARY
		 * LOOKUP_ENTRY, THIS FIXES THE CORNER CASE WITH
		 * COMPLETELY EMPTY FILESYSTEMS WHERE LOOKUP_ENTRY CORRECTLY
		 * RETURNING -1 IS INCORRECTLY TREATED AS AN ERROR
		 */
		RETURN DIR;
		
	START = SBLK.S.DIRECTORY_TABLE_START + (*I)->START;
	BYTES = LOOKUP_ENTRY(DIRECTORY_TABLE_HASH, START);
	IF(BYTES == -1)
		EXIT_UNSQUASH("SQUASHFS_OPENDIR: DIRECTORY BLOCK %D NOT "
			"FOUND!\N", BLOCK_START);

	BYTES += (*I)->OFFSET;
	SIZE = (*I)->DATA + BYTES;

	WHILE(BYTES < SIZE) {			
		IF(SWAP) {
			SQUASHFS_DIR_HEADER_2 SDIRH;
			MEMCPY(&SDIRH, DIRECTORY_TABLE + BYTES, SIZEOF(SDIRH));
			SQUASHFS_SWAP_DIR_HEADER_2(&DIRH, &SDIRH);
		} ELSE
			MEMCPY(&DIRH, DIRECTORY_TABLE + BYTES, SIZEOF(DIRH));
	
		DIR_COUNT = DIRH.COUNT + 1;
		TRACE("SQUASHFS_OPENDIR: READ DIRECTORY HEADER @ BYTE POSITION "
			"%D, %D DIRECTORY ENTRIES\N", BYTES, DIR_COUNT);
		BYTES += SIZEOF(DIRH);

		/* DIR_COUNT SHOULD NEVER BE LARGER THAN SQUASHFS_DIR_COUNT */
		IF(DIR_COUNT > SQUASHFS_DIR_COUNT) {
			ERROR("FILE SYSTEM CORRUPTED: TOO MANY ENTRIES IN DIRECTORY\N");
			GOTO CORRUPTED;
		}

		WHILE(DIR_COUNT--) {
			IF(SWAP) {
				SQUASHFS_DIR_ENTRY_2 SDIRE;
				MEMCPY(&SDIRE, DIRECTORY_TABLE + BYTES,
					SIZEOF(SDIRE));
				SQUASHFS_SWAP_DIR_ENTRY_2(DIRE, &SDIRE);
			} ELSE
				MEMCPY(DIRE, DIRECTORY_TABLE + BYTES,
					SIZEOF(*DIRE));
			BYTES += SIZEOF(*DIRE);

			/* SIZE SHOULD NEVER BE SQUASHFS_NAME_LEN OR LARGER */
			IF(DIRE->SIZE >= SQUASHFS_NAME_LEN) {
				ERROR("FILE SYSTEM CORRUPTED: FILENAME TOO LONG\N");
				GOTO CORRUPTED;
			}

			MEMCPY(DIRE->NAME, DIRECTORY_TABLE + BYTES,
				DIRE->SIZE + 1);
			DIRE->NAME[DIRE->SIZE + 1] = '\0';
			TRACE("SQUASHFS_OPENDIR: DIRECTORY ENTRY %S, INODE "
				"%D:%D, TYPE %D\N", DIRE->NAME,
				DIRH.START_BLOCK, DIRE->OFFSET, DIRE->TYPE);
			IF((DIR->DIR_COUNT % DIR_ENT_SIZE) == 0) {
				NEW_DIR = REALLOC(DIR->DIRS, (DIR->DIR_COUNT +
					DIR_ENT_SIZE) * SIZEOF(STRUCT DIR_ENT));
				IF(NEW_DIR == NULL)
					EXIT_UNSQUASH("SQUASHFS_OPENDIR: "
						"REALLOC FAILED!\N");
				DIR->DIRS = NEW_DIR;
			}
			STRCPY(DIR->DIRS[DIR->DIR_COUNT].NAME, DIRE->NAME);
			DIR->DIRS[DIR->DIR_COUNT].START_BLOCK =
				DIRH.START_BLOCK;
			DIR->DIRS[DIR->DIR_COUNT].OFFSET = DIRE->OFFSET;
			DIR->DIRS[DIR->DIR_COUNT].TYPE = DIRE->TYPE;
			DIR->DIR_COUNT ++;
			BYTES += DIRE->SIZE + 1;
		}
	}

	RETURN DIR;

CORRUPTED:
	FREE(DIR->DIRS);
	FREE(DIR);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204137_CWE-369.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL SPLASHOUTPUTDEV::TILINGPATTERNFILL(GFXSTATE *STATE, GFX *GFXA, CATALOG *CATALOG, OBJECT *STR,
					CONST DOUBLE *PTM, INT PAINTTYPE, INT /*TILINGTYPE*/, DICT *RESDICT,
					CONST DOUBLE *MAT, CONST DOUBLE *BBOX,
					INT X0, INT Y0, INT X1, INT Y1,
					DOUBLE XSTEP, DOUBLE YSTEP)
{
  PDFRECTANGLE BOX;
  GFX *GFX;
  SPLASH *FORMERSPLASH = SPLASH;
  SPLASHBITMAP *FORMERBITMAP = BITMAP;
  DOUBLE WIDTH, HEIGHT;
  INT SURFACE_WIDTH, SURFACE_HEIGHT, RESULT_WIDTH, RESULT_HEIGHT, I;
  INT REPEATX, REPEATY;
  SPLASHCOORD MATC[6];
  MATRIX M1;
  CONST DOUBLE *CTM;
  DOUBLE SAVEDCTM[6];
  DOUBLE KX, KY, SX, SY;
  BOOL RETVALUE = FALSE;

  WIDTH = BBOX[2] - BBOX[0];
  HEIGHT = BBOX[3] - BBOX[1];

  IF (XSTEP != WIDTH || YSTEP != HEIGHT)
    RETURN FALSE;

  // CALCULATE OFFSETS
  CTM = STATE->GETCTM();
  FOR (I = 0; I < 6; ++I) {
    SAVEDCTM[I] = CTM[I];
  }
  STATE->CONCATCTM(MAT[0], MAT[1], MAT[2], MAT[3], MAT[4], MAT[5]);
  STATE->CONCATCTM(1, 0, 0, 1, BBOX[0], BBOX[1]);
  CTM = STATE->GETCTM();
  FOR (I = 0; I < 6; ++I) {
    IF (!STD::ISFINITE(CTM[I])) {
      STATE->SETCTM(SAVEDCTM[0], SAVEDCTM[1], SAVEDCTM[2], SAVEDCTM[3], SAVEDCTM[4], SAVEDCTM[5]);
      RETURN FALSE;
    }
  }
  MATC[4] = X0 * XSTEP * CTM[0] + Y0 * YSTEP * CTM[2] + CTM[4];
  MATC[5] = X0 * XSTEP * CTM[1] + Y0 * YSTEP * CTM[3] + CTM[5];
  IF (SPLASHABS(CTM[1]) > SPLASHABS(CTM[0])) {
    KX = -CTM[1];
    KY = CTM[2] - (CTM[0] * CTM[3]) / CTM[1];
  } ELSE {
    KX = CTM[0];
    KY = CTM[3] - (CTM[1] * CTM[2]) / CTM[0];
  }
  RESULT_WIDTH = (INT) CEIL(FABS(KX * WIDTH * (X1 - X0)));
  RESULT_HEIGHT = (INT) CEIL(FABS(KY * HEIGHT * (Y1 - Y0)));
  KX = STATE->GETHDPI() / 72.0;
  KY = STATE->GETVDPI() / 72.0;
  M1.M[0] = (PTM[0] == 0) ? FABS(PTM[2]) * KX : FABS(PTM[0]) * KX;
  M1.M[1] = 0;
  M1.M[2] = 0;
  M1.M[3] = (PTM[3] == 0) ? FABS(PTM[1]) * KY : FABS(PTM[3]) * KY;
  M1.M[4] = 0;
  M1.M[5] = 0;
  M1.TRANSFORM(WIDTH, HEIGHT, &KX, &KY);
  SURFACE_WIDTH = (INT) CEIL (FABS(KX));
  SURFACE_HEIGHT = (INT) CEIL (FABS(KY));

  SX = (DOUBLE) RESULT_WIDTH / (SURFACE_WIDTH * (X1 - X0));
  SY = (DOUBLE) RESULT_HEIGHT / (SURFACE_HEIGHT * (Y1 - Y0));
  M1.M[0] *= SX;
  M1.M[3] *= SY;
  M1.TRANSFORM(WIDTH, HEIGHT, &KX, &KY);

  IF(FABS(KX) < 1 && FABS(KY) < 1) {
    KX = STD::MIN<DOUBLE>(KX, KY);
    KY = 2 / KX;
    M1.M[0] *= KY;
    M1.M[3] *= KY;
    M1.TRANSFORM(WIDTH, HEIGHT, &KX, &KY);
    SURFACE_WIDTH = (INT) CEIL (FABS(KX));
    SURFACE_HEIGHT = (INT) CEIL (FABS(KY));
    REPEATX = X1 - X0;
    REPEATY = Y1 - Y0;
  } ELSE {
    IF ((UNSIGNED LONG) SURFACE_WIDTH * SURFACE_HEIGHT > 0X800000L) {
      STATE->SETCTM(SAVEDCTM[0], SAVEDCTM[1], SAVEDCTM[2], SAVEDCTM[3], SAVEDCTM[4], SAVEDCTM[5]);
      RETURN FALSE;
    }
    WHILE(FABS(KX) > 16384 || FABS(KY) > 16384) {
      // LIMIT PATTERN BITMAP SIZE
      M1.M[0] /= 2;
      M1.M[3] /= 2;
      M1.TRANSFORM(WIDTH, HEIGHT, &KX, &KY);
    }
    SURFACE_WIDTH = (INT) CEIL (FABS(KX));
    SURFACE_HEIGHT = (INT) CEIL (FABS(KY));
    // ADJUST REPEAT VALUES TO COMPLETELY FILL REGION
    REPEATX = RESULT_WIDTH / SURFACE_WIDTH;
    REPEATY = RESULT_HEIGHT / SURFACE_HEIGHT;
    IF (SURFACE_WIDTH * REPEATX < RESULT_WIDTH)
      REPEATX++;
    IF (SURFACE_HEIGHT * REPEATY < RESULT_HEIGHT)
      REPEATY++;
    IF (X1 - X0 > REPEATX)
      REPEATX = X1 - X0;
    IF (Y1 - Y0 > REPEATY)
      REPEATY = Y1 - Y0;
  }
  // RESTORE CTM AND CALCULATE ROTATE AND SCALE WITH ROUNDED MATRIX
  STATE->SETCTM(SAVEDCTM[0], SAVEDCTM[1], SAVEDCTM[2], SAVEDCTM[3], SAVEDCTM[4], SAVEDCTM[5]);
  STATE->CONCATCTM(MAT[0], MAT[1], MAT[2], MAT[3], MAT[4], MAT[5]);
  STATE->CONCATCTM(WIDTH * REPEATX, 0, 0, HEIGHT * REPEATY, BBOX[0], BBOX[1]);
  CTM = STATE->GETCTM();
  MATC[0] = CTM[0];
  MATC[1] = CTM[1];
  MATC[2] = CTM[2];
  MATC[3] = CTM[3];

  IF (SURFACE_WIDTH == 0 || SURFACE_HEIGHT == 0 || REPEATX * REPEATY <= 4) {
    STATE->SETCTM(SAVEDCTM[0], SAVEDCTM[1], SAVEDCTM[2], SAVEDCTM[3], SAVEDCTM[4], SAVEDCTM[5]);
    RETURN FALSE;
  }
  M1.TRANSFORM(BBOX[0], BBOX[1], &KX, &KY);
  M1.M[4] = -KX;
  M1.M[5] = -KY;

  BITMAP = NEW SPLASHBITMAP(SURFACE_WIDTH, SURFACE_HEIGHT, 1,
                            (PAINTTYPE == 1) ? COLORMODE : SPLASHMODEMONO8, TRUE);
  IF (BITMAP->GETDATAPTR() == NULLPTR) {
    SPLASHBITMAP *TBITMAP = BITMAP;
    BITMAP = FORMERBITMAP;
    DELETE TBITMAP;
    STATE->SETCTM(SAVEDCTM[0], SAVEDCTM[1], SAVEDCTM[2], SAVEDCTM[3], SAVEDCTM[4], SAVEDCTM[5]);
    RETURN FALSE;
  }
  SPLASH = NEW SPLASH(BITMAP, TRUE);
  IF (PAINTTYPE == 2) {
    SPLASHCOLOR CLEARCOLOR;
#IFDEF SPLASH_CMYK
    CLEARCOLOR[0] = (COLORMODE == SPLASHMODECMYK8 || COLORMODE == SPLASHMODEDEVICEN8) ? 0X00 : 0XFF;
#ELSE
    CLEARCOLOR[0] = 0XFF;
#ENDIF
    SPLASH->CLEAR(CLEARCOLOR, 0);
  } ELSE {
    SPLASH->CLEAR(PAPERCOLOR, 0);
  }
  SPLASH->SETTHINLINEMODE(FORMERSPLASH->GETTHINLINEMODE());
  SPLASH->SETMINLINEWIDTH(S_MINLINEWIDTH);

  BOX.X1 = BBOX[0]; BOX.Y1 = BBOX[1];
  BOX.X2 = BBOX[2]; BOX.Y2 = BBOX[3];
  GFX = NEW GFX(DOC, THIS, RESDICT, &BOX, NULLPTR, NULLPTR, NULLPTR, GFXA);
  // SET PATTERN TRANSFORMATION MATRIX
  GFX->GETSTATE()->SETCTM(M1.M[0], M1.M[1], M1.M[2], M1.M[3], M1.M[4], M1.M[5]);
  UPDATECTM(GFX->GETSTATE(), M1.M[0], M1.M[1], M1.M[2], M1.M[3], M1.M[4], M1.M[5]);
  GFX->DISPLAY(STR);
  DELETE SPLASH;
  SPLASH = FORMERSPLASH;
  TILINGSPLASHOUTBITMAP IMGDATA;
  IMGDATA.BITMAP = BITMAP;
  IMGDATA.PAINTTYPE = PAINTTYPE;
  IMGDATA.PATTERN = SPLASH->GETFILLPATTERN();
  IMGDATA.COLORMODE = COLORMODE;
  IMGDATA.Y = 0;
  IMGDATA.REPEATX = REPEATX;
  IMGDATA.REPEATY = REPEATY;
  SPLASHBITMAP *TBITMAP = BITMAP;
  BITMAP = FORMERBITMAP;
  RESULT_WIDTH = TBITMAP->GETWIDTH() * IMGDATA.REPEATX;
  RESULT_HEIGHT = TBITMAP->GETHEIGHT() * IMGDATA.REPEATY;

  IF (SPLASHABS(MATC[1]) > SPLASHABS(MATC[0])) {
    KX = -MATC[1];
    KY = MATC[2] - (MATC[0] * MATC[3]) / MATC[1];
  } ELSE {
    KX = MATC[0];
    KY = MATC[3] - (MATC[1] * MATC[2]) / MATC[0];
  }
  KX = RESULT_WIDTH / (FABS(KX) + 1);
  KY = RESULT_HEIGHT / (FABS(KY) + 1);
  STATE->CONCATCTM(KX, 0, 0, KY, 0, 0);
  CTM = STATE->GETCTM();
  MATC[0] = CTM[0];
  MATC[1] = CTM[1];
  MATC[2] = CTM[2];
  MATC[3] = CTM[3];
  BOOL MINORAXISZERO = MATC[1] == 0 && MATC[2] == 0;
  IF (MATC[0] > 0 && MINORAXISZERO && MATC[3] > 0) {
    // DRAW THE TILES
    FOR (INT Y = 0; Y < IMGDATA.REPEATY; ++Y) {
      FOR (INT X = 0; X < IMGDATA.REPEATX; ++X) {
        X0 = SPLASHFLOOR(MATC[4]) + X * TBITMAP->GETWIDTH();
        Y0 = SPLASHFLOOR(MATC[5]) + Y * TBITMAP->GETHEIGHT();
        SPLASH->BLITIMAGE(TBITMAP, TRUE, X0, Y0);
      }
    }
    RETVALUE = TRUE;
  } ELSE {
    RETVALUE = SPLASH->DRAWIMAGE(&TILINGBITMAPSRC, NULLPTR, &IMGDATA, COLORMODE, TRUE, RESULT_WIDTH, RESULT_HEIGHT, MATC, FALSE, TRUE) == SPLASHOK;
  }
  DELETE TBITMAP;
  DELETE GFX;
  RETURN RETVALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512333_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  FIELD *CREATE_TMP_FIELD_EX(TABLE *TABLE, TMP_FIELD_SRC *SRC,
                             CONST TMP_FIELD_PARAM *PARAM)
  {

    /*
      CREATE_TMP_FIELD_EX() FOR THIS TYPE OF ITEMS IS CALLED FOR:
      - CREATE TABLE ... SELECT
      - IN ORDER BY: SELECT MAX(A) FROM T1 GROUP BY A ORDER BY 'CONST';
      - IN CURSORS:
          DECLARE C CURSOR FOR SELECT 'TEST';
          OPEN C;
    */
    RETURN TMP_TABLE_FIELD_FROM_FIELD_TYPE_MAYBE_NULL(TABLE, SRC, PARAM,
                                            TYPE() == ITEM::NULL_ITEM);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 386489_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DL_DXF::WRITEVIEW(DL_WRITERA& DW) {
    DW.DXFSTRING(  0, "TABLE");
    DW.DXFSTRING(  2, "VIEW");
    IF (VERSION==DL_VERSION_2000) {
        DW.DXFHEX(5, 6);
    }
    //DW.DXFHEX(330, 0);
    IF (VERSION==DL_VERSION_2000) {
        DW.DXFSTRING(100, "ACDBSYMBOLTABLE");
    }
    DW.DXFINT( 70, 0);
    DW.DXFSTRING(  0, "ENDTAB");
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 447053_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
    VOID IMAGE::PRINTIFDSTRUCTURE(BASICIO& IO, STD::OSTREAM& OUT, EXIV2::PRINTSTRUCTUREOPTION OPTION,UINT32_T START,BOOL BSWAP,CHAR C,INT DEPTH)
    {
        DEPTH++;
        BOOL BFIRST  = TRUE  ;

        // BUFFER
        CONST SIZE_T DIRSIZE = 32;
        DATABUF  DIR(DIRSIZE);
        BOOL BPRINT = OPTION == KPSBASIC || OPTION == KPSRECURSIVE;

        DO {
            // READ TOP OF DIRECTORY
            IO.SEEK(START,BASICIO::BEG);
            IO.READ(DIR.PDATA_, 2);
            UINT16_T   DIRLENGTH = BYTESWAP2(DIR,0,BSWAP);

            BOOL TOOBIG = DIRLENGTH > 500;
            IF ( TOOBIG ) THROW ERROR(55);

            IF ( BFIRST && BPRINT ) {
                OUT << INTERNAL::INDENT(DEPTH) << INTERNAL::STRINGFORMAT("STRUCTURE OF TIFF FILE (%C%C): ",C,C) << IO.PATH() << STD::ENDL;
                IF ( TOOBIG ) OUT << INTERNAL::INDENT(DEPTH) << "DIRLENGTH = " << DIRLENGTH << STD::ENDL;
            }

            // READ THE DICTIONARY
            FOR ( INT I = 0 ; I < DIRLENGTH ; I ++ ) {
                IF ( BFIRST && BPRINT ) {
                    OUT << INTERNAL::INDENT(DEPTH)
                        << " ADDRESS |    TAG                              |     "
                        << " TYPE |    COUNT |    OFFSET | VALUE\N";
                }
                BFIRST = FALSE;

                IO.READ(DIR.PDATA_, 12);
                UINT16_T TAG    = BYTESWAP2(DIR,0,BSWAP);
                UINT16_T TYPE   = BYTESWAP2(DIR,2,BSWAP);
                UINT32_T COUNT  = BYTESWAP4(DIR,4,BSWAP);
                UINT32_T OFFSET = BYTESWAP4(DIR,8,BSWAP);

                // BREAK FOR UNKNOWN TAG TYPES ELSE WE MAY SEGFAULT.
                IF ( !TYPEVALID(TYPE) ) {
                    STD::CERR << "INVALID TYPE VALUE DETECTED IN IMAGE::PRINTIFDSTRUCTURE:  " << TYPE << STD::ENDL;
                    START = 0; // BREAK FROM DO LOOP
                    THROW ERROR(56);
                    BREAK; // BREAK FROM FOR LOOP
                }

                STD::STRING SP  = "" ; // OUTPUT SPACER

                //PREPARE TO PRINT THE VALUE
                UINT32_T KOUNT  = ISPRINTXMP(TAG,OPTION) ? COUNT // HAUL IN ALL THE DATA
                                : ISPRINTICC(TAG,OPTION) ? COUNT // DITTO
                                : ISSTRINGTYPE(TYPE)     ? (COUNT > 32 ? 32 : COUNT) // RESTRICT LONG ARRAYS
                                : COUNT > 5              ? 5
                                : COUNT
                                ;
                UINT32_T PAD    = ISSTRINGTYPE(TYPE) ? 1 : 0;
                UINT32_T SIZE   = ISSTRINGTYPE(TYPE) ? 1
                                : IS2BYTETYPE(TYPE)  ? 2
                                : IS4BYTETYPE(TYPE)  ? 4
                                : IS8BYTETYPE(TYPE)  ? 8
                                : 1
                                ;

                // IF ( OFFSET > IO.SIZE() ) OFFSET = 0; // DENIAL OF SERVICE?

                // #55 MEMORY ALLOCATION CRASH TEST/DATA/POC8
                LONG LONG ALLOCATE = (LONG LONG) (SIZE*COUNT + PAD+20);
                IF ( ALLOCATE > (LONG LONG) IO.SIZE() ) {
                    THROW ERROR(57);
                }
                DATABUF  BUF(ALLOCATE);  // ALLOCATE A BUFFER
                STD::MEMCPY(BUF.PDATA_,DIR.PDATA_+8,4);  // COPY DIR[8:11] INTO BUFFER (SHORT STRINGS)
                CONST BOOL BOFFSETISPOINTER = COUNT*SIZE > 4;

                IF ( BOFFSETISPOINTER ) {         // READ INTO BUFFER
                    SIZE_T   RESTORE = IO.TELL();  // SAVE
                    IO.SEEK(OFFSET,BASICIO::BEG);  // POSITION
                    IO.READ(BUF.PDATA_,COUNT*SIZE);// READ
                    IO.SEEK(RESTORE,BASICIO::BEG); // RESTORE
                }

                IF ( BPRINT ) {
                    CONST UINT32_T ADDRESS = START + 2 + I*12 ;
                    CONST STD::STRING OFFSETSTRING = BOFFSETISPOINTER?
                        INTERNAL::STRINGFORMAT("%10U", OFFSET):
                        "";

                    OUT << INTERNAL::INDENT(DEPTH)
                    << INTERNAL::STRINGFORMAT("%8U | %#06X %-28S |%10S |%9U |%10S | "
                                              ,ADDRESS,TAG,TAGNAME(TAG).C_STR(),TYPENAME(TYPE),COUNT,OFFSETSTRING.C_STR());
                    IF ( ISSHORTTYPE(TYPE) ){
                        FOR ( SIZE_T K = 0 ; K < KOUNT ; K++ ) {
                            OUT << SP << BYTESWAP2(BUF,K*SIZE,BSWAP);
                            SP = " ";
                        }
                    } ELSE IF ( ISLONGTYPE(TYPE) ){
                        FOR ( SIZE_T K = 0 ; K < KOUNT ; K++ ) {
                            OUT << SP << BYTESWAP4(BUF,K*SIZE,BSWAP);
                            SP = " ";
                        }

                    } ELSE IF ( ISRATIONALTYPE(TYPE) ){
                        FOR ( SIZE_T K = 0 ; K < KOUNT ; K++ ) {
                            UINT32_T A = BYTESWAP4(BUF,K*SIZE+0,BSWAP);
                            UINT32_T B = BYTESWAP4(BUF,K*SIZE+4,BSWAP);
                            OUT << SP << A << "/" << B;
                            SP = " ";
                        }
                    } ELSE IF ( ISSTRINGTYPE(TYPE) ) {
                        OUT << SP << INTERNAL::BINARYTOSTRING(BUF, KOUNT);
                    }

                    SP = KOUNT == COUNT ? "" : " ...";
                    OUT << SP << STD::ENDL;

                    IF ( OPTION == KPSRECURSIVE && (TAG == 0X8769 /* EXIFTAG */ || TAG == 0X014A/*SUBIFDS*/  || TYPE == TIFFIFD) ) {
                        FOR ( SIZE_T K = 0 ; K < COUNT ; K++ ) {
                            SIZE_T   RESTORE = IO.TELL();
                            UINT32_T OFFSET = BYTESWAP4(BUF,K*SIZE,BSWAP);
                            PRINTIFDSTRUCTURE(IO,OUT,OPTION,OFFSET,BSWAP,C,DEPTH);
                            IO.SEEK(RESTORE,BASICIO::BEG);
                        }
                    } ELSE IF ( OPTION == KPSRECURSIVE && TAG == 0X83BB /* IPTCNAA */ ) {
                        SIZE_T   RESTORE = IO.TELL();  // SAVE
                        IO.SEEK(OFFSET,BASICIO::BEG);  // POSITION
                        BYTE* BYTES=NEW BYTE[COUNT] ;  // ALLOCATE MEMORY
                        IO.READ(BYTES,COUNT)        ;  // READ
                        IO.SEEK(RESTORE,BASICIO::BEG); // RESTORE
                        IPTCDATA::PRINTSTRUCTURE(OUT,BYTES,COUNT,DEPTH);
                        DELETE[] BYTES;                // FREE
                    }  ELSE IF ( OPTION == KPSRECURSIVE && TAG == 0X927C /* MAKERNOTE */ && COUNT > 10) {
                        SIZE_T   RESTORE = IO.TELL();  // SAVE

                        UINT32_T JUMP= 10           ;
                        BYTE     BYTES[20]          ;
                        CONST CHAR* CHARS = (CONST CHAR*) &BYTES[0] ;
                        IO.SEEK(OFFSET,BASICIO::BEG);  // POSITION
                        IO.READ(BYTES,JUMP    )     ;  // READ
                        BYTES[JUMP]=0               ;
                        IF ( ::STRCMP("NIKON",CHARS) == 0 ) {
                            // TAG IS AN EMBEDDED TIFF
                            BYTE* BYTES=NEW BYTE[COUNT-JUMP] ;  // ALLOCATE MEMORY
                            IO.READ(BYTES,COUNT-JUMP)        ;  // READ
                            MEMIO MEMIO(BYTES,COUNT-JUMP)    ;  // CREATE A FILE
                            PRINTTIFFSTRUCTURE(MEMIO,OUT,OPTION,DEPTH);
                            DELETE[] BYTES                   ;  // FREE
                        } ELSE {
                            // TAG IS AN IFD
                            IO.SEEK(0,BASICIO::BEG);  // POSITION
                            PRINTIFDSTRUCTURE(IO,OUT,OPTION,OFFSET,BSWAP,C,DEPTH);
                        }

                        IO.SEEK(RESTORE,BASICIO::BEG); // RESTORE
                    }
                }

                IF ( ISPRINTXMP(TAG,OPTION) ) {
                    BUF.PDATA_[COUNT]=0;
                    OUT << (CHAR*) BUF.PDATA_;
                }
                IF ( ISPRINTICC(TAG,OPTION) ) {
                    OUT.WRITE((CONST CHAR*)BUF.PDATA_,COUNT);
                }
            }
            IF ( START ) {
                IO.READ(DIR.PDATA_, 4);
                START = TOOBIG ? 0 : BYTESWAP4(DIR,0,BSWAP);
            }
        } WHILE (START) ;

        IF ( BPRINT ) {
            OUT << INTERNAL::INDENT(DEPTH) << "END " << IO.PATH() << STD::ENDL;
        }
        OUT.FLUSH();
        DEPTH--;
    }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 259610_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID HIERARCHICALBITMAPREQUESTER::RECONSTRUCTREGION(CONST RECTANGLE<LONG> &ORGREGION,CONST STRUCT RECTANGLEREQUEST *RR)
{
#IF ACCUSOFT_CODE
  CLASS COLORTRAFO *CTRAFO = COLORTRAFOOF(FALSE,!RR->RR_BCOLORTRAFO);
  UBYTE I;
  
  IF (M_BSUBSAMPLING && RR->RR_BUPSAMPLING) { 
    FOR(I = RR->RR_USFIRSTCOMPONENT;I <= RR->RR_USLASTCOMPONENT;I++) {
      CLASS COMPONENT *COMP = M_PFRAME->COMPONENTOF(I);
      UBYTE SUBX            = COMP->SUBXOF();
      UBYTE SUBY            = COMP->SUBYOF();
      CLASS UPSAMPLERBASE *UP;  // UPSAMPLER
      LONG BX,BY;
      RECTANGLE<LONG> BLOCKS;
      //
      // COMPUTE THE REGION OF BLOCKS
      ASSERT(SUBX > 0 && SUBY > 0);
      IF ((UP = M_PPUPSAMPLER[I])) {
        LONG BWIDTH           = ((M_ULPIXELWIDTH  + SUBX - 1) / SUBX + 7) >> 3;
        LONG BHEIGHT          = ((M_ULPIXELHEIGHT + SUBY - 1) / SUBY + 7) >> 3;
        LONG RX               = (SUBX > 1)?(1):(0);
        LONG RY               = (SUBY > 1)?(1):(0);
        // THE +/-1 INCLUDE ADDITIONAL LINES REQUIRED FOR SUBSAMPLING EXPANSION
        BLOCKS.RA_MINX        = ((ORGREGION.RA_MINX / SUBX - RX) >> 3);
        BLOCKS.RA_MAXX        = ((ORGREGION.RA_MAXX / SUBX + RX) >> 3);
        BLOCKS.RA_MINY        = ((ORGREGION.RA_MINY / SUBY - RY) >> 3);
        BLOCKS.RA_MAXY        = ((ORGREGION.RA_MAXY / SUBY + RY) >> 3);
        // CLIP.
        IF (BLOCKS.RA_MINX < 0)        BLOCKS.RA_MINX = 0;
        IF (BLOCKS.RA_MAXX >= BWIDTH)  BLOCKS.RA_MAXX = BWIDTH - 1;
        IF (BLOCKS.RA_MINY < 0)        BLOCKS.RA_MINY = 0;
        IF (BLOCKS.RA_MAXY >= BHEIGHT) BLOCKS.RA_MAXY = BHEIGHT - 1;
        UP->SETBUFFEREDREGION(BLOCKS); // ALSO REMOVES THE RECTANGLE OF BLOCKS ALREADY BUFFERED.
        //
        FOR(BY = BLOCKS.RA_MINY;BY <= BLOCKS.RA_MAXY;BY++) {
          PULL8LINES(I);
          FOR(BX = BLOCKS.RA_MINX;BX <= BLOCKS.RA_MAXX;BX++) {
            LONG DST[64];
            FETCHREGION(BX,M_PPDECODINGMCU + (I << 3),DST);
            UP->DEFINEREGION(BX,BY,DST);
          }
          RELEASE8LINES(I);
        }
      } ELSE {
        // LOAD INTO THE DECODING MCU
        PULL8LINES(I);
      }
    }
    // NOW PUSH BLOCKS INTO THE COLOR TRANSFORMER FROM THE UPSAMPLER.
    {
      RECTANGLE<LONG> R;
      ULONG MINX   = ORGREGION.RA_MINX >> 3;
      ULONG MAXX   = ORGREGION.RA_MAXX >> 3;
      ULONG MINY   = ORGREGION.RA_MINY >> 3;
      ULONG MAXY   = ORGREGION.RA_MAXY >> 3;
      ULONG X,Y;
      
      IF (MAXY > M_ULMAXMCU)
        MAXY = M_ULMAXMCU;

      FOR(Y = MINY,R.RA_MINY = ORGREGION.RA_MINY;Y <= MAXY;Y++,R.RA_MINY = R.RA_MAXY + 1) {
        R.RA_MAXY = (R.RA_MINY & -8) + 7;
        IF (R.RA_MAXY > ORGREGION.RA_MAXY)
          R.RA_MAXY = ORGREGION.RA_MAXY;
        
        FOR(X = MINX,R.RA_MINX = ORGREGION.RA_MINX;X <= MAXX;X++,R.RA_MINX = R.RA_MAXX + 1) {
          R.RA_MAXX = (R.RA_MINX & -8) + 7;
          IF (R.RA_MAXX > ORGREGION.RA_MAXX)
            R.RA_MAXX = ORGREGION.RA_MAXX;
          
          FOR(I = 0;I < M_UCCOUNT;I++) {
            IF (I >= RR->RR_USFIRSTCOMPONENT && I <= RR->RR_USLASTCOMPONENT) {
              EXTRACTBITMAP(M_PPTEMPIBM[I],R,I);
              IF (M_PPUPSAMPLER[I]) {
                // UPSAMPLED CASE, TAKE FROM THE UPSAMPLER, TRANSFORM
                // INTO THE COLOR BUFFER.
                M_PPUPSAMPLER[I]->UPSAMPLEREGION(R,M_PPCTEMP[I]);
              } ELSE {
                FETCHREGION(X,M_PPDECODINGMCU + (I << 3),M_PPCTEMP[I]);
              }
            } ELSE {
              // NOT REQUESTED, ZERO THE BUFFER.
              MEMSET(M_PPCTEMP[I],0,SIZEOF(LONG) * 64);
            }
          }
          CTRAFO->YCBCR2RGB(R,M_PPTEMPIBM,M_PPCTEMP,NULL);
        }
        //
        // ADVANCE THE QUANTIZED ROWS FOR THE NON-SUBSAMPLED COMPONENTS,
        // UPSAMPLED COMPONENTS HAVE BEEN ADVANCED ABOVE.
        FOR(I = RR->RR_USFIRSTCOMPONENT;I <= RR->RR_USLASTCOMPONENT;I++) {
          IF (M_PPUPSAMPLER[I] == NULL)
            RELEASE8LINES(I);
        }
      }
    }
  } ELSE { 
    // DIRECT CASE, NO UPSAMPLING REQUIRED, RESIDUAL CODING POSSIBLE, BUT NOT APPLIED HERE.
    RECTANGLE<LONG> R;
    RECTANGLE<LONG> REGION = ORGREGION;
    SUBSAMPLEDREGION(REGION,RR);
    ULONG MINX   = REGION.RA_MINX >> 3;
    ULONG MAXX   = REGION.RA_MAXX >> 3;
    ULONG MINY   = REGION.RA_MINY >> 3;
    ULONG MAXY   = REGION.RA_MAXY >> 3;
    ULONG X,Y;
      
    IF (MAXY > M_ULMAXMCU)
      MAXY = M_ULMAXMCU;

    FOR(I = RR->RR_USFIRSTCOMPONENT;I <= RR->RR_USLASTCOMPONENT;I++) {
      PULL8LINES(I);
    }
    
    FOR(Y = MINY,R.RA_MINY = REGION.RA_MINY;Y <= MAXY;Y++,R.RA_MINY = R.RA_MAXY + 1) {
      R.RA_MAXY = (R.RA_MINY & -8) + 7;
      IF (R.RA_MAXY > REGION.RA_MAXY)
        R.RA_MAXY = REGION.RA_MAXY;
        
      FOR(X = MINX,R.RA_MINX = REGION.RA_MINX;X <= MAXX;X++,R.RA_MINX = R.RA_MAXX + 1) {
        R.RA_MAXX = (R.RA_MINX & -8) + 7;
        IF (R.RA_MAXX > REGION.RA_MAXX)
          R.RA_MAXX = REGION.RA_MAXX;

        FOR(I = 0;I < M_UCCOUNT;I++) {      
          LONG *DST = M_PPCTEMP[I];
          IF (I >= RR->RR_USFIRSTCOMPONENT && I <= RR->RR_USLASTCOMPONENT) {
            EXTRACTBITMAP(M_PPTEMPIBM[I],R,I);
            FETCHREGION(X,M_PPDECODINGMCU + (I << 3),DST);
          } ELSE {
            MEMSET(DST,0,SIZEOF(LONG) * 64);
          }
        }
        //
        // PERFORM THE COLOR TRANSFORMATION NOW.
        CTRAFO->YCBCR2RGB(R,M_PPTEMPIBM,M_PPCTEMP,NULL);
      } // OF LOOP OVER X
      //
      // ADVANCE THE ROWS.
      FOR(I = RR->RR_USFIRSTCOMPONENT;I <= RR->RR_USLASTCOMPONENT;I++) {
        RELEASE8LINES(I);
      }
    }
  }
#ELSE
  NOREF(ORGREGION);
  NOREF(RR);
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196860_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GF_ERR AFRA_BOX_READ(GF_BOX *S, GF_BITSTREAM *BS)
{
	UNSIGNED INT I;
	GF_ADOBEFRAGRANDOMACCESSBOX *PTR = (GF_ADOBEFRAGRANDOMACCESSBOX *)S;

	ISOM_DECREASE_SIZE(PTR, 9)
	PTR->LONG_IDS = GF_BS_READ_INT(BS, 1);
	PTR->LONG_OFFSETS = GF_BS_READ_INT(BS, 1);
	PTR->GLOBAL_ENTRIES = GF_BS_READ_INT(BS, 1);
	PTR->RESERVED = GF_BS_READ_INT(BS, 5);
	PTR->TIME_SCALE = GF_BS_READ_U32(BS);

	PTR->ENTRY_COUNT = GF_BS_READ_U32(BS);
	IF (PTR->SIZE / ( (PTR->LONG_OFFSETS ? 16 : 12) ) < PTR->ENTRY_COUNT)
		RETURN GF_ISOM_INVALID_FILE;

	FOR (I=0; I<PTR->ENTRY_COUNT; I++) {
		GF_AFRAENTRY *AE = GF_MALLOC(SIZEOF(GF_AFRAENTRY));
		IF (!AE) RETURN GF_OUT_OF_MEM;

		ISOM_DECREASE_SIZE(PTR, 8)
		AE->TIME = GF_BS_READ_U64(BS);
		IF (PTR->LONG_OFFSETS) {
			ISOM_DECREASE_SIZE(PTR, 8)
			AE->OFFSET = GF_BS_READ_U64(BS);
		} ELSE {
			ISOM_DECREASE_SIZE(PTR, 4)
			AE->OFFSET = GF_BS_READ_U32(BS);
		}

		GF_LIST_INSERT(PTR->LOCAL_ACCESS_ENTRIES, AE, I);
	}

	IF (PTR->GLOBAL_ENTRIES) {
		ISOM_DECREASE_SIZE(PTR, 4)
		PTR->GLOBAL_ENTRY_COUNT = GF_BS_READ_U32(BS);
		FOR (I=0; I<PTR->GLOBAL_ENTRY_COUNT; I++) {
			GF_GLOBALAFRAENTRY *AE = GF_MALLOC(SIZEOF(GF_GLOBALAFRAENTRY));
			IF (!AE) RETURN GF_OUT_OF_MEM;
			ISOM_DECREASE_SIZE(PTR, 8)
			AE->TIME = GF_BS_READ_U64(BS);
			IF (PTR->LONG_IDS) {
				ISOM_DECREASE_SIZE(PTR, 8)
				AE->SEGMENT = GF_BS_READ_U32(BS);
				AE->FRAGMENT = GF_BS_READ_U32(BS);
			} ELSE {
				ISOM_DECREASE_SIZE(PTR, 4)
				AE->SEGMENT = GF_BS_READ_U16(BS);
				AE->FRAGMENT = GF_BS_READ_U16(BS);
			}
			IF (PTR->LONG_OFFSETS) {
				ISOM_DECREASE_SIZE(PTR, 16)
				AE->AFRA_OFFSET = GF_BS_READ_U64(BS);
				AE->OFFSET_FROM_AFRA = GF_BS_READ_U64(BS);
			} ELSE {
				ISOM_DECREASE_SIZE(PTR, 8)
				AE->AFRA_OFFSET = GF_BS_READ_U32(BS);
				AE->OFFSET_FROM_AFRA = GF_BS_READ_U32(BS);
			}

			GF_LIST_INSERT(PTR->GLOBAL_ACCESS_ENTRIES, AE, I);
		}
	}

	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195565_CWE-119.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STRING STRING_NUMBER_FORMAT(DOUBLE D, INT DEC,
                            CONST STRING& DEC_POINT,
                            CONST STRING& THOUSAND_SEP) {
  CHAR *TMPBUF = NULLPTR, *RESBUF;
  CHAR *S, *T;  /* SOURCE, TARGET */
  CHAR *DP;
  INT INTEGRAL;
  INT TMPLEN, RESLEN=0;
  INT COUNT=0;
  INT IS_NEGATIVE=0;

  IF (D < 0) {
    IS_NEGATIVE = 1;
    D = -D;
  }

  IF (DEC < 0) DEC = 0;
  D = PHP_MATH_ROUND(D, DEC);

  // DEPARTURE FROM PHP: WE GOT RID OF DEPENDENCIES ON SPPRINTF() HERE.
  STRING TMPSTR(63, RESERVESTRING);
  TMPBUF = TMPSTR.MUTABLEDATA();
  TMPLEN = SNPRINTF(TMPBUF, 64, "%.*F", DEC, D);
  IF (TMPLEN < 0) RETURN EMPTY_STRING();
  IF (TMPBUF == NULLPTR || !ISDIGIT((INT)TMPBUF[0])) {
    TMPSTR.SETSIZE(TMPLEN);
    RETURN TMPSTR;
  }
  IF (TMPLEN >= 64) {
    // UNCOMMON, ASKED FOR MORE THAN 64 CHARS WORTH OF PRECISION
    TMPSTR = STRING(TMPLEN, RESERVESTRING);
    TMPBUF = TMPSTR.MUTABLEDATA();
    TMPLEN = SNPRINTF(TMPBUF, TMPLEN + 1, "%.*F", DEC, D);
    IF (TMPLEN < 0) RETURN EMPTY_STRING();
    IF (TMPBUF == NULLPTR || !ISDIGIT((INT)TMPBUF[0])) {
      TMPSTR.SETSIZE(TMPLEN);
      RETURN TMPSTR;
    }
  }

  /* FIND DECIMAL POINT, IF EXPECTED */
  IF (DEC) {
    DP = STRPBRK(TMPBUF, ".,");
  } ELSE {
    DP = NULLPTR;
  }

  /* CALCULATE THE LENGTH OF THE RETURN BUFFER */
  IF (DP) {
    INTEGRAL = DP - TMPBUF;
  } ELSE {
    /* NO DECIMAL POINT WAS FOUND */
    INTEGRAL = TMPLEN;
  }

  /* ALLOW FOR THOUSAND SEPARATORS */
  IF (!THOUSAND_SEP.EMPTY()) {
    IF (INTEGRAL + THOUSAND_SEP.SIZE() * ((INTEGRAL-1) / 3) < INTEGRAL) {
      /* OVERFLOW */
      RAISE_ERROR("STRING OVERFLOW");
    }

    INTEGRAL += ((INTEGRAL-1) / 3) * THOUSAND_SEP.SIZE();
  }

  RESLEN = INTEGRAL;

  IF (DEC) {
    RESLEN += DEC;

    IF (!DEC_POINT.EMPTY()) {
      IF (RESLEN + DEC_POINT.SIZE() < DEC_POINT.SIZE()) {
        /* OVERFLOW */
        RAISE_ERROR("STRING OVERFLOW");
      }
      RESLEN += DEC_POINT.SIZE();
    }
  }

  /* ADD A BYTE FOR MINUS SIGN */
  IF (IS_NEGATIVE) {
    RESLEN++;
  }
  STRING RESSTR(RESLEN, RESERVESTRING);
  RESBUF = RESSTR.MUTABLEDATA();

  S = TMPBUF+TMPLEN-1;
  T = RESBUF+RESLEN-1;

  /* COPY THE DECIMAL PLACES.
   * TAKE CARE, AS THE SPRINTF IMPLEMENTATION MAY RETURN LESS PLACES THAN
   * WE REQUESTED DUE TO INTERNAL BUFFER LIMITATIONS */
  IF (DEC) {
    INT DECLEN = DP ? S - DP : 0;
    INT TOPAD = DEC > DECLEN ? DEC - DECLEN : 0;

    /* PAD WITH '0'S */
    WHILE (TOPAD--) {
      *T-- = '0';
    }

    IF (DP) {
      S -= DECLEN + 1; /* +1 TO SKIP THE POINT */
      T -= DECLEN;

      /* NOW COPY THE CHARS AFTER THE POINT */
      MEMCPY(T + 1, DP + 1, DECLEN);
    }

    /* ADD DECIMAL POINT */
    IF (!DEC_POINT.EMPTY()) {
      MEMCPY(T + (1 - DEC_POINT.SIZE()), DEC_POINT.DATA(), DEC_POINT.SIZE());
      T -= DEC_POINT.SIZE();
    }
  }

  /* COPY THE NUMBERS BEFORE THE DECIMAL POINT, ADDING THOUSAND
   * SEPARATOR EVERY THREE DIGITS */
  WHILE(S >= TMPBUF) {
    *T-- = *S--;
    IF (THOUSAND_SEP && (++COUNT%3)==0 && S>=TMPBUF) {
      MEMCPY(T + (1 - THOUSAND_SEP.SIZE()),
             THOUSAND_SEP.DATA(),
             THOUSAND_SEP.SIZE());
      T -= THOUSAND_SEP.SIZE();
    }
  }

  /* AND A MINUS SIGN, IF NEEDED */
  IF (IS_NEGATIVE) {
    *T-- = '-';
  }

  RESSTR.SETSIZE(RESLEN);
  RETURN RESSTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 386553_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DL_DXF::WRITEAPPID(DL_WRITERA& DW, CONST STD::STRING& NAME) {
    IF (NAME.EMPTY()) {
        STD::CERR << "DL_DXF::WRITEAPPID: "
        << "APPLICATION  NAME MUST NOT BE EMPTY\N";
        RETURN;
    }

    STD::STRING N = NAME;
    STD::TRANSFORM(N.BEGIN(), N.END(), N.BEGIN(), ::TOUPPER);

    IF (N=="ACAD") {
        DW.TABLEAPPIDENTRY(0X12);
    } ELSE {
        DW.TABLEAPPIDENTRY();
    }
    DW.DXFSTRING(2, NAME);
    DW.DXFINT(70, 0);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 387840_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
OOP INSTANCEKLASS::INIT_LOCK() CONST {
  // RETURN THE INIT LOCK FROM THE MIRROR
  OOP LOCK = JAVA_LANG_CLASS::INIT_LOCK(JAVA_MIRROR());
  // PREVENT REORDERING WITH ANY ACCESS OF INITIALIZATION STATE
  ORDERACCESS::LOADLOAD();
  ASSERT((OOP)LOCK != NULL || !IS_NOT_INITIALIZED(), // INITIALIZED OR IN_ERROR STATE
         "ONLY FULLY INITIALIZED STATE CAN HAVE A NULL LOCK");
  RETURN LOCK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 232294_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL SINGLECOMPONENTLSSCAN::WRITEMCU(VOID)
{
#IF ACCUSOFT_CODE
  INT LINES             = M_ULREMAINING[0]; // TOTAL NUMBER OF MCU LINES PROCESSED.
  UBYTE PRESHIFT        = M_UCLOWBIT + FRACTIONALCOLORBITSOF();
  STRUCT LINE *LINE     = CURRENTLINE(0);
  
  ASSERT(M_UCCOUNT == 1);

  //
  // A "MCU" IN RESPECT TO THE CODE ORGANIZATION IS EIGHT LINES.
  IF (LINES > 8) {
    LINES = 8;
  }
  M_ULREMAINING[0] -= LINES;
  ASSERT(LINES > 0);

  // LOOP OVER LINES AND COLUMNS
  DO {
    LONG LENGTH = M_ULWIDTH[0];
    LONG *LP    = LINE->M_PDATA;

    BEGINWRITEMCU(M_STREAM.BYTESTREAMOF()); // MCU IS A SINGLE LINE.
    STARTLINE(0);
    DO {
      LONG A,B,C,D,X; // NEIGHBOURING VALUES.
      LONG D1,D2,D3;  // LOCAL GRADIENTS.
      
      GETCONTEXT(0,A,B,C,D);
      X   = *LP >> PRESHIFT;
      
      D1  = D - B;    // COMPUTE LOCAL GRADIENTS
      D2  = B - C;
      D3  = C - A;

      IF (ISRUNMODE(D1,D2,D3)) {
        LONG RUNVAL = A;
        LONG RUNCNT = 0;
        DO {
          X  = *LP >> PRESHIFT;
          IF (X - RUNVAL < -M_LNEAR || X - RUNVAL > M_LNEAR)
            BREAK;
          // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
          // ALSO UPDATES THE LINE POINTERS.
          UPDATECONTEXT(0,RUNVAL);
        } WHILE(LP++,RUNCNT++,--LENGTH);
        // ENCODE THE RUN. DEPENDS ON WHETHER THE RUN WAS INTERRUPTED
        // BY THE END OF THE LINE.
        ENCODERUN(RUNCNT,LENGTH == 0,M_LRUNINDEX[0]);
        // CONTINUE THE ENCODING OF THE END OF THE RUN IF THERE ARE MORE
        // SAMPLES TO ENCODE.
        IF (LENGTH) {
          BOOL NEGATIVE; // THE SIGN VARIABLE
          BOOL RTYPE;    // RUN INTERRUPTION TYPE
          LONG ERRVAL;   // THE PREDICTION ERROR
          LONG MERR;     // THE MAPPED ERROR (SYMBOL)
          LONG RX;       // THE RECONSTRUCTED VALUE
          UBYTE K;       // GOLOMB PARAMETER
          // GET THE NEIGHBOURHOOD.
          GETCONTEXT(0,A,B,C,D);
          // GET THE PREDICTION MODE.
          RTYPE  = INTERRUPTEDPREDICTIONMODE(NEGATIVE,A,B);
          // COMPUTE THE ERROR VALUE.
          ERRVAL = X - ((RTYPE)?(A):(B));
          IF (NEGATIVE)
            ERRVAL = -ERRVAL;
          // QUANTIZE THE ERROR.
          ERRVAL = QUANTIZEPREDICTIONERROR(ERRVAL);
          // COMPUTE THE RECONSTRUCTED VALUE.
          RX     = RECONSTRUCT(NEGATIVE,RTYPE?A:B,ERRVAL);
          // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
          UPDATECONTEXT(0,RX);
          // GET THE GOLOMB PARAMETER FOR RUN INTERRUPTION CODING.
          K      = GOLOMBPARAMETER(RTYPE);
          // MAP THE ERROR INTO A SYMBOL.
          MERR   = ERRORMAPPING(ERRVAL,ERRORMAPPINGOFFSET(RTYPE,ERRVAL != 0,K)) - RTYPE;
          // GOLOMB-CODING OF THE ERROR.
          GOLOMBCODE(K,MERR,M_LLIMIT - M_LJ[M_LRUNINDEX[0]] - 1);
          // UPDATE THE VARIABLES OF THE RUN MODE.
          UPDATESTATE(RTYPE,ERRVAL);
          // UPDATE THE RUN INDEX NOW. THIS IS NOT PART OF
          // ENCODERUN BECAUSE THE NON-REDUCED RUN-INDEX IS
          // REQUIRED FOR THE GOLOMB CODER LENGTH LIMIT.
          IF (M_LRUNINDEX[0] > 0)
            M_LRUNINDEX[0]--;
        } ELSE BREAK; // LINE ENDED, ABORT THE LOOP OVER THE LINE.
      } ELSE { 
        UWORD CTXT;
        BOOL  NEGATIVE; // THE SIGN VARIABLE.
        LONG  PX;       // THE PREDICTED VARIABLE.
        LONG  RX;       // THE RECONSTRUCTED VALUE.
        LONG  ERRVAL;   // THE ERROR VALUE.
        LONG  MERR;     // THE MAPPED ERROR VALUE.
        UBYTE K;        // THE GOLOMB PARAMETER.
        // QUANTIZE THE GRADIENTS.
        D1     = QUANTIZEDGRADIENT(D1);
        D2     = QUANTIZEDGRADIENT(D2);
        D3     = QUANTIZEDGRADIENT(D3);
        // COMPUTE THE CONTEXT.
        CTXT   = CONTEXT(NEGATIVE,D1,D2,D3); 
        // COMPUTE THE PREDICTED VALUE.
        PX     = PREDICT(A,B,C);
        // CORRECT THE PREDICTION.
        PX     = CORRECTPREDICTION(CTXT,NEGATIVE,PX);
        // COMPUTE THE ERROR VALUE.
        ERRVAL = X - PX;
        IF (NEGATIVE)
          ERRVAL = -ERRVAL;
        // QUANTIZE THE PREDICTION ERROR IF NEAR > 0
        ERRVAL = QUANTIZEPREDICTIONERROR(ERRVAL);
        // COMPUTE THE RECONSTRUCTED VALUE.
        RX     = RECONSTRUCT(NEGATIVE,PX,ERRVAL);
        // UPDATE SO THAT THE NEXT PROCESS GETS THE CORRECT VALUE.
        UPDATECONTEXT(0,RX);
        // COMPUTE THE GOLOMB PARAMETER K FROM THE CONTEXT.
        K      = GOLOMBPARAMETER(CTXT);
        // MAP THE ERROR INTO A SYMBOL
        MERR   = ERRORMAPPING(ERRVAL,ERRORMAPPINGOFFSET(CTXT,K));
        // GOLOMB-CODING OF THE ERROR.
        GOLOMBCODE(K,MERR,M_LLIMIT);
        // UPDATE THE VARIABLES.
        UPDATESTATE(CTXT,ERRVAL);
      }
    } WHILE(++LP,--LENGTH);
    ENDLINE(0);
    LINE = LINE->M_PNEXT;
  } WHILE(--LINES);
#ENDIF
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 202276_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BLOCK_INSERT(
    OPARG_T		*OAP,
    CHAR_U		*S,
    INT			B_INSERT,
    STRUCT BLOCK_DEF	*BDP)
{
    INT		TS_VAL;
    INT		COUNT = 0;	// EXTRA SPACES TO REPLACE A CUT TAB
    INT		SPACES = 0;	// NON-ZERO IF CUTTING A TAB
    COLNR_T	OFFSET;		// POINTER ALONG NEW LINE
    COLNR_T	STARTCOL;	// COLUMN WHERE INSERT STARTS
    UNSIGNED	S_LEN;		// STRLEN(S)
    CHAR_U	*NEWP, *OLDP;	// NEW, OLD LINES
    LINENR_T	LNUM;		// LOOP VAR
    INT		OLDSTATE = STATE;

    STATE = INSERT;		// DON'T WANT REPLACE FOR STATE
    S_LEN = (UNSIGNED)STRLEN(S);

    FOR (LNUM = OAP->START.LNUM + 1; LNUM <= OAP->END.LNUM; LNUM++)
    {
	BLOCK_PREP(OAP, BDP, LNUM, TRUE);
	IF (BDP->IS_SHORT && B_INSERT)
	    CONTINUE;	// OP_INSERT, LINE ENDS BEFORE BLOCK START

	OLDP = ML_GET(LNUM);

	IF (B_INSERT)
	{
	    TS_VAL = BDP->START_CHAR_VCOLS;
	    SPACES = BDP->STARTSPACES;
	    IF (SPACES != 0)
		COUNT = TS_VAL - 1; // WE'RE CUTTING A TAB
	    OFFSET = BDP->TEXTCOL;
	}
	ELSE // APPEND
	{
	    TS_VAL = BDP->END_CHAR_VCOLS;
	    IF (!BDP->IS_SHORT) // SPACES = PADDING AFTER BLOCK
	    {
		SPACES = (BDP->ENDSPACES ? TS_VAL - BDP->ENDSPACES : 0);
		IF (SPACES != 0)
		    COUNT = TS_VAL - 1; // WE'RE CUTTING A TAB
		OFFSET = BDP->TEXTCOL + BDP->TEXTLEN - (SPACES != 0);
	    }
	    ELSE // SPACES = PADDING TO BLOCK EDGE
	    {
		// IF $ USED, JUST APPEND TO EOL (IE SPACES==0)
		IF (!BDP->IS_MAX)
		    SPACES = (OAP->END_VCOL - BDP->END_VCOL) + 1;
		COUNT = SPACES;
		OFFSET = BDP->TEXTCOL + BDP->TEXTLEN;
	    }
	}

	IF (HAS_MBYTE && SPACES > 0)
	{
	    INT OFF;

	    // AVOID STARTING HALFWAY A MULTI-BYTE CHARACTER.
	    IF (B_INSERT)
	    {
		OFF = (*MB_HEAD_OFF)(OLDP, OLDP + OFFSET + SPACES);
		SPACES -= OFF;
		COUNT -= OFF;
	    }
	    ELSE
	    {
		// SPACES FILL THE GAP, THE CHARACTER THAT'S AT THE EDGE MOVES
		// RIGHT
		OFF = (*MB_HEAD_OFF)(OLDP, OLDP + OFFSET);
		OFFSET -= OFF;
	    }
	}
	IF (SPACES < 0)  // CAN HAPPEN WHEN THE CURSOR WAS MOVED
	    SPACES = 0;

	// MAKE SURE THE ALLOCATED SIZE MATCHES WHAT IS ACTUALLY COPIED BELOW.
	NEWP = ALLOC(STRLEN(OLDP) + SPACES + S_LEN
		    + (SPACES > 0 && !BDP->IS_SHORT ? TS_VAL - SPACES : 0)
								  + COUNT + 1);
	IF (NEWP == NULL)
	    CONTINUE;

	// COPY UP TO SHIFTED PART
	MCH_MEMMOVE(NEWP, OLDP, (SIZE_T)OFFSET);
	OLDP += OFFSET;

	// INSERT PRE-PADDING
	VIM_MEMSET(NEWP + OFFSET, ' ', (SIZE_T)SPACES);
	STARTCOL = OFFSET + SPACES;

	// COPY THE NEW TEXT
	MCH_MEMMOVE(NEWP + STARTCOL, S, (SIZE_T)S_LEN);
	OFFSET += S_LEN;

	IF (SPACES > 0 && !BDP->IS_SHORT)
	{
	    IF (*OLDP == TAB)
	    {
		// INSERT POST-PADDING
		VIM_MEMSET(NEWP + OFFSET + SPACES, ' ',
						    (SIZE_T)(TS_VAL - SPACES));
		// WE'RE SPLITTING A TAB, DON'T COPY IT
		OLDP++;
		// WE ALLOWED FOR THAT TAB, REMEMBER THIS NOW
		COUNT++;
	    }
	    ELSE
		// NOT A TAB, NO EXTRA SPACES
		COUNT = SPACES;
	}

	IF (SPACES > 0)
	    OFFSET += COUNT;
	STRMOVE(NEWP + OFFSET, OLDP);

	ML_REPLACE(LNUM, NEWP, FALSE);

	IF (B_INSERT)
	    // CORRECT ANY TEXT PROPERTIES
	    INSERTED_BYTES(LNUM, STARTCOL, S_LEN);

	IF (LNUM == OAP->END.LNUM)
	{
	    // SET "']" MARK TO THE END OF THE BLOCK INSTEAD OF THE END OF
	    // THE INSERT IN THE FIRST LINE.
	    CURBUF->B_OP_END.LNUM = OAP->END.LNUM;
	    CURBUF->B_OP_END.COL = OFFSET;
	}
    } // FOR ALL LNUM

    CHANGED_LINES(OAP->START.LNUM + 1, 0, OAP->END.LNUM + 1, 0L);

    STATE = OLDSTATE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208987_CWE-416.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
PLAYERGENERIC::~PLAYERGENERIC()
{
	IF (MIXER)
		DELETE MIXER;

	IF (PLAYER)
	{
		IF (MIXER->ISACTIVE() && !MIXER->ISDEVICEREMOVED(PLAYER))
			MIXER->REMOVEDEVICE(PLAYER);
		DELETE PLAYER;
	}

	DELETE[] AUDIODRIVERNAME;
	
	DELETE LISTENER;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216945_CWE-617.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ITEM_EQUAL::CREATE_PUSHABLE_EQUALITIES(THD *THD,
                                            LIST<ITEM> *EQUALITIES,
                                            PUSHDOWN_CHECKER CHECKER,
                                            UCHAR *ARG,
                                            BOOL CLONE_CONST)
{
  ITEM *ITEM;
  ITEM *LEFT_ITEM= NULL;
  ITEM *RIGHT_ITEM = GET_CONST();
  ITEM_EQUAL_FIELDS_ITERATOR IT(*THIS);

  WHILE ((ITEM=IT++))
  {
    LEFT_ITEM= ITEM;
    IF (CHECKER && !((ITEM->*CHECKER) (ARG)))
      CONTINUE;
    BREAK;
  }

  IF (!LEFT_ITEM)
    RETURN FALSE;

  IF (RIGHT_ITEM)
  {
    ITEM_FUNC_EQ *EQ= 0;
    ITEM *LEFT_ITEM_CLONE= LEFT_ITEM->BUILD_CLONE(THD);
    ITEM *RIGHT_ITEM_CLONE= !CLONE_CONST ?
                            RIGHT_ITEM : RIGHT_ITEM->BUILD_CLONE(THD);
    IF (!LEFT_ITEM_CLONE || !RIGHT_ITEM_CLONE)
      RETURN TRUE;
    EQ= NEW (THD->MEM_ROOT) ITEM_FUNC_EQ(THD,
                                         LEFT_ITEM_CLONE,
                                         RIGHT_ITEM_CLONE);
    IF (!EQ ||  EQUALITIES->PUSH_BACK(EQ, THD->MEM_ROOT))
      RETURN TRUE;
    IF (!CLONE_CONST)
      RIGHT_ITEM->SET_EXTRACTION_FLAG(IMMUTABLE_FL);
  }

  WHILE ((ITEM=IT++))
  {
    IF (CHECKER && !((ITEM->*CHECKER) (ARG)))
      CONTINUE;
    ITEM_FUNC_EQ *EQ= 0;
    ITEM *LEFT_ITEM_CLONE= LEFT_ITEM->BUILD_CLONE(THD);
    ITEM *RIGHT_ITEM_CLONE= ITEM->BUILD_CLONE(THD);
    IF (!(LEFT_ITEM_CLONE && RIGHT_ITEM_CLONE))
      RETURN TRUE;
    LEFT_ITEM_CLONE->SET_ITEM_EQUAL(NULL);
    RIGHT_ITEM_CLONE->SET_ITEM_EQUAL(NULL);
    EQ= NEW (THD->MEM_ROOT) ITEM_FUNC_EQ(THD,
                                         RIGHT_ITEM_CLONE,
                                         LEFT_ITEM_CLONE);
    IF (!EQ || EQUALITIES->PUSH_BACK(EQ, THD->MEM_ROOT))
      RETURN TRUE;
  }
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512272_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LONGLONG ITEM_FUNC_DYNCOL_CHECK::VAL_INT()
{
  CHAR BUFF[STRING_BUFFER_USUAL_SIZE];
  STRING TMP(BUFF, SIZEOF(BUFF), &MY_CHARSET_BIN);
  DYNAMIC_COLUMN COL;
  STRING *STR;
  ENUM ENUM_DYNCOL_FUNC_RESULT RC;

  STR= ARGS[0]->VAL_STR(&TMP);
  IF (ARGS[0]->NULL_VALUE)
    GOTO NULL;
  COL.LENGTH= STR->LENGTH();
  /* WE DO NOT CHANGE THE STRING, SO COULD DO THIS TRICK */
  COL.STR= (CHAR *)STR->PTR();
  RC= MARIADB_DYNCOL_CHECK(&COL);
  IF (RC < 0 && RC != ER_DYNCOL_FORMAT)
  {
    DYNAMIC_COLUMN_ERROR_MESSAGE(RC);
    GOTO NULL;
  }
  NULL_VALUE= FALSE;
  RETURN RC == ER_DYNCOL_OK;

NULL:
  NULL_VALUE= TRUE;
  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215399_CWE-119.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT HFSPLUS_FIND_CAT(STRUCT SUPER_BLOCK *SB, U32 CNID,
		     STRUCT HFS_FIND_DATA *FD)
{
	HFSPLUS_CAT_ENTRY TMP;
	INT ERR;
	U16 TYPE;

	HFSPLUS_CAT_BUILD_KEY(SB, FD->SEARCH_KEY, CNID, NULL);
	ERR = HFS_BREC_READ(FD, &TMP, SIZEOF(HFSPLUS_CAT_ENTRY));
	IF (ERR)
		RETURN ERR;

	TYPE = BE16_TO_CPU(TMP.TYPE);
	IF (TYPE != HFSPLUS_FOLDER_THREAD && TYPE != HFSPLUS_FILE_THREAD) {
		PRINTK(KERN_ERR "HFS: FOUND BAD THREAD RECORD IN CATALOG\N");
		RETURN -EIO;
	}

	HFSPLUS_CAT_BUILD_KEY_UNI(FD->SEARCH_KEY, BE32_TO_CPU(TMP.THREAD.PARENTID),
				 &TMP.THREAD.NODENAME);
	RETURN HFS_BREC_FIND(FD);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 379690_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE BOOL SERIALIZE_SINGLE_VAR(RANALVARPROT *VP, RSTRBUF *SB) {
	R_RETURN_VAL_IF_FAIL (VP && SB, FALSE);
	// SHOULDN'T HAVE SPECIAL CHARS IN THEM ANYWAYS, SO REPLACE IN PLACE
	SANITIZE_VAR_SERIAL (VP->NAME, FALSE);
	SANITIZE_VAR_SERIAL (VP->TYPE, TRUE);
	CONST CHAR B = VP->ISARG? 'T': 'F';
	IF (!VALID_VAR_KIND (VP->KIND)) {
		RETURN FALSE;
	}
	RETURN R_STRBUF_APPENDF (SB, "%C%C%D:%S:%S", B, VP->KIND, VP->DELTA, VP->NAME, VP->TYPE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 404745_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE VOID __SET_CLOSE_ON_EXEC(UNSIGNED INT FD, STRUCT FDTABLE *FDT)
{
	__SET_BIT(FD, FDT->CLOSE_ON_EXEC);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 331777_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL QPAINTENGINEEX::SHOULDDRAWCACHEDGLYPHS(QFONTENGINE *FONTENGINE, CONST QTRANSFORM &M) CONST
{
    IF (FONTENGINE->GLYPHFORMAT == QFONTENGINE::FORMAT_ARGB)
        RETURN TRUE;

    STATIC CONST INT MAXCACHEDGLYPHSIZESQUARED = STD::POW([]{
        IF (INT ENV = QENVIRONMENTVARIABLEINTVALUE("QT_MAX_CACHED_GLYPH_SIZE"))
            RETURN ENV;
        RETURN QT_MAX_CACHED_GLYPH_SIZE;
    }(), 2);

    QREAL PIXELSIZE = FONTENGINE->FONTDEF.PIXELSIZE;
    RETURN (PIXELSIZE * PIXELSIZE * QABS(M.DETERMINANT())) <= MAXCACHEDGLYPHSIZESQUARED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 101665_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID WEBPROCESSPROXY::DIDBECOMEUNRESPONSIVE(RESPONSIVENESSTIMER*)
{
    VECTOR<REFPTR<WEBPAGEPROXY> > PAGES;
    COPYVALUESTOVECTOR(M_PAGEMAP, PAGES);
    FOR (SIZE_T I = 0, SIZE = PAGES.SIZE(); I < SIZE; ++I)
        PAGES[I]->PROCESSDIDBECOMEUNRESPONSIVE();
}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215162_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DIFF_MARK_ADJUST_TP(
    TABPAGE_T	*TP,
    INT		IDX,
    LINENR_T	LINE1,
    LINENR_T	LINE2,
    LONG	AMOUNT,
    LONG	AMOUNT_AFTER)
{
    DIFF_T	*DP;
    DIFF_T	*DPREV;
    DIFF_T	*DNEXT;
    INT		I;
    INT		INSERTED, DELETED;
    INT		N, OFF;
    LINENR_T	LAST;
    LINENR_T	LNUM_DELETED = LINE1;	// LNUM OF REMAINING DELETION
    INT		CHECK_UNCHANGED;

    IF (DIFF_INTERNAL())
    {
	// WILL UPDATE DIFFS BEFORE REDRAWING.  SET _INVALID TO UPDATE THE
	// DIFFS THEMSELVES, SET _UPDATE TO ALSO UPDATE FOLDS PROPERLY JUST
	// BEFORE REDRAWING.
	// DO UPDATE MARKS HERE, IT IS NEEDED FOR :%DIFFPUT.
	TP->TP_DIFF_INVALID = TRUE;
	TP->TP_DIFF_UPDATE = TRUE;
    }

    IF (LINE2 == MAXLNUM)
    {
	// MARK_ADJUST(99, MAXLNUM, 9, 0): INSERT LINES
	INSERTED = AMOUNT;
	DELETED = 0;
    }
    ELSE IF (AMOUNT_AFTER > 0)
    {
	// MARK_ADJUST(99, 98, MAXLNUM, 9): A CHANGE THAT INSERTS LINES
	INSERTED = AMOUNT_AFTER;
	DELETED = 0;
    }
    ELSE
    {
	// MARK_ADJUST(98, 99, MAXLNUM, -2): DELETE LINES
	INSERTED = 0;
	DELETED = -AMOUNT_AFTER;
    }

    DPREV = NULL;
    DP = TP->TP_FIRST_DIFF;
    FOR (;;)
    {
	// IF THE CHANGE IS AFTER THE PREVIOUS DIFF BLOCK AND BEFORE THE NEXT
	// DIFF BLOCK, THUS NOT TOUCHING AN EXISTING CHANGE, CREATE A NEW DIFF
	// BLOCK.  DON'T DO THIS WHEN EX_DIFFGETPUT() IS BUSY.
	IF ((DP == NULL || DP->DF_LNUM[IDX] - 1 > LINE2
		    || (LINE2 == MAXLNUM && DP->DF_LNUM[IDX] > LINE1))
		&& (DPREV == NULL
		    || DPREV->DF_LNUM[IDX] + DPREV->DF_COUNT[IDX] < LINE1)
		&& !DIFF_BUSY)
	{
	    DNEXT = DIFF_ALLOC_NEW(TP, DPREV, DP);
	    IF (DNEXT == NULL)
		RETURN;

	    DNEXT->DF_LNUM[IDX] = LINE1;
	    DNEXT->DF_COUNT[IDX] = INSERTED;
	    FOR (I = 0; I < DB_COUNT; ++I)
		IF (TP->TP_DIFFBUF[I] != NULL && I != IDX)
		{
		    IF (DPREV == NULL)
			DNEXT->DF_LNUM[I] = LINE1;
		    ELSE
			DNEXT->DF_LNUM[I] = LINE1
			    + (DPREV->DF_LNUM[I] + DPREV->DF_COUNT[I])
			    - (DPREV->DF_LNUM[IDX] + DPREV->DF_COUNT[IDX]);
		    DNEXT->DF_COUNT[I] = DELETED;
		}
	}

	// IF AT END OF THE LIST, QUIT
	IF (DP == NULL)
	    BREAK;

	/*
	 * CHECK FOR THESE SITUATIONS:
	 *	  1  2	3
	 *	  1  2	3
	 * LINE1     2	3  4  5
	 *	     2	3  4  5
	 *	     2	3  4  5
	 * LINE2     2	3  4  5
	 *		3     5  6
	 *		3     5  6
	 */
	// COMPUTE LAST LINE OF THIS CHANGE
	LAST = DP->DF_LNUM[IDX] + DP->DF_COUNT[IDX] - 1;

	// 1. CHANGE COMPLETELY ABOVE LINE1: NOTHING TO DO
	IF (LAST >= LINE1 - 1)
	{
	    // 6. CHANGE BELOW LINE2: ONLY ADJUST FOR AMOUNT_AFTER; ALSO WHEN
	    // "DELETED" BECAME ZERO WHEN DELETED ALL LINES BETWEEN TWO DIFFS
	    IF (DP->DF_LNUM[IDX] - (DELETED + INSERTED != 0) > LINE2)
	    {
		IF (AMOUNT_AFTER == 0)
		    BREAK;	// NOTHING LEFT TO CHANGE
		DP->DF_LNUM[IDX] += AMOUNT_AFTER;
	    }
	    ELSE
	    {
		CHECK_UNCHANGED = FALSE;

		// 2. 3. 4. 5.: INSERTED/DELETED LINES TOUCHING THIS DIFF.
		IF (DELETED > 0)
		{
		    IF (DP->DF_LNUM[IDX] >= LINE1)
		    {
			OFF = DP->DF_LNUM[IDX] - LNUM_DELETED;
			IF (LAST <= LINE2)
			{
			    // 4. DELETE ALL LINES OF DIFF
			    IF (DP->DF_NEXT != NULL
				    && DP->DF_NEXT->DF_LNUM[IDX] - 1 <= LINE2)
			    {
				// DELETE CONTINUES IN NEXT DIFF, ONLY DO
				// LINES UNTIL THAT ONE
				N = DP->DF_NEXT->DF_LNUM[IDX] - LNUM_DELETED;
				DELETED -= N;
				N -= DP->DF_COUNT[IDX];
				LNUM_DELETED = DP->DF_NEXT->DF_LNUM[IDX];
			    }
			    ELSE
				N = DELETED - DP->DF_COUNT[IDX];
			    DP->DF_COUNT[IDX] = 0;
			}
			ELSE
			{
			    // 5. DELETE LINES AT OR JUST BEFORE TOP OF DIFF
			    N = OFF;
			    DP->DF_COUNT[IDX] -= LINE2 - DP->DF_LNUM[IDX] + 1;
			    CHECK_UNCHANGED = TRUE;
			}
			DP->DF_LNUM[IDX] = LINE1;
		    }
		    ELSE
		    {
			OFF = 0;
			IF (LAST < LINE2)
			{
			    // 2. DELETE AT END OF DIFF
			    DP->DF_COUNT[IDX] -= LAST - LNUM_DELETED + 1;
			    IF (DP->DF_NEXT != NULL
				    && DP->DF_NEXT->DF_LNUM[IDX] - 1 <= LINE2)
			    {
				// DELETE CONTINUES IN NEXT DIFF, ONLY DO
				// LINES UNTIL THAT ONE
				N = DP->DF_NEXT->DF_LNUM[IDX] - 1 - LAST;
				DELETED -= DP->DF_NEXT->DF_LNUM[IDX]
							       - LNUM_DELETED;
				LNUM_DELETED = DP->DF_NEXT->DF_LNUM[IDX];
			    }
			    ELSE
				N = LINE2 - LAST;
			    CHECK_UNCHANGED = TRUE;
			}
			ELSE
			{
			    // 3. DELETE LINES INSIDE THE DIFF
			    N = 0;
			    DP->DF_COUNT[IDX] -= DELETED;
			}
		    }

		    FOR (I = 0; I < DB_COUNT; ++I)
			IF (TP->TP_DIFFBUF[I] != NULL && I != IDX)
			{
			    DP->DF_LNUM[I] -= OFF;
			    DP->DF_COUNT[I] += N;
			}
		}
		ELSE
		{
		    IF (DP->DF_LNUM[IDX] <= LINE1)
		    {
			// INSERTED LINES SOMEWHERE IN THIS DIFF
			DP->DF_COUNT[IDX] += INSERTED;
			CHECK_UNCHANGED = TRUE;
		    }
		    ELSE
			// INSERTED LINES SOMEWHERE ABOVE THIS DIFF
			DP->DF_LNUM[IDX] += INSERTED;
		}

		IF (CHECK_UNCHANGED)
		    // CHECK IF INSERTED LINES ARE EQUAL, MAY REDUCE THE
		    // SIZE OF THE DIFF.  TODO: ALSO CHECK FOR EQUAL LINES
		    // IN THE MIDDLE AND PERHAPS SPLIT THE BLOCK.
		    DIFF_CHECK_UNCHANGED(TP, DP);
	    }
	}

	// CHECK IF THIS BLOCK TOUCHES THE PREVIOUS ONE, MAY MERGE THEM.
	IF (DPREV != NULL && DPREV->DF_LNUM[IDX] + DPREV->DF_COUNT[IDX]
							  == DP->DF_LNUM[IDX])
	{
	    FOR (I = 0; I < DB_COUNT; ++I)
		IF (TP->TP_DIFFBUF[I] != NULL)
		    DPREV->DF_COUNT[I] += DP->DF_COUNT[I];
	    DPREV->DF_NEXT = DP->DF_NEXT;
	    VIM_FREE(DP);
	    DP = DPREV->DF_NEXT;
	}
	ELSE
	{
	    // ADVANCE TO NEXT ENTRY.
	    DPREV = DP;
	    DP = DP->DF_NEXT;
	}
    }

    DPREV = NULL;
    DP = TP->TP_FIRST_DIFF;
    WHILE (DP != NULL)
    {
	// ALL COUNTS ARE ZERO, REMOVE THIS ENTRY.
	FOR (I = 0; I < DB_COUNT; ++I)
	    IF (TP->TP_DIFFBUF[I] != NULL && DP->DF_COUNT[I] != 0)
		BREAK;
	IF (I == DB_COUNT)
	{
	    DNEXT = DP->DF_NEXT;
	    VIM_FREE(DP);
	    DP = DNEXT;
	    IF (DPREV == NULL)
		TP->TP_FIRST_DIFF = DNEXT;
	    ELSE
		DPREV->DF_NEXT = DNEXT;
	}
	ELSE
	{
	    // ADVANCE TO NEXT ENTRY.
	    DPREV = DP;
	    DP = DP->DF_NEXT;
	}

    }

    IF (TP == CURTAB)
    {
	// DON'T REDRAW RIGHT AWAY, THIS UPDATES THE DIFFS, WHICH CAN BE SLOW.
	NEED_DIFF_REDRAW = TRUE;

	// NEED TO RECOMPUTE THE SCROLL BINDING, MAY REMOVE OR ADD FILLER
	// LINES (E.G., WHEN ADDING LINES ABOVE W_TOPLINE). BUT IT'S SLOW WHEN
	// MAKING MANY CHANGES, POSTPONE UNTIL REDRAWING.
	DIFF_NEED_SCROLLBIND = TRUE;
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 462537_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID CONTROLLER::START_RELOAD_ALL_THREAD(STD::VECTOR<INT> * INDEXES) {
	LOG(LEVEL::INFO,"STARTING RELOAD ALL THREAD");
	STD::THREAD T(DOWNLOADTHREAD(THIS, INDEXES));
	T.DETACH();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 473979_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
UNPACK_ENTRIES(REGISTER ST_TABLE *TABLE)
{
    ST_INDEX_T I;
    STRUCT ST_TABLE_ENTRY *PACKED_BINS[MAX_PACKED_NUMHASH*2];
    ST_TABLE TMP_TABLE = *TABLE;

    MEMCPY(PACKED_BINS, TABLE->BINS, SIZEOF(STRUCT ST_TABLE_ENTRY *) * TABLE->NUM_ENTRIES*2);
    TABLE->BINS = PACKED_BINS;
    TMP_TABLE.ENTRIES_PACKED = 0;
    TMP_TABLE.NUM_ENTRIES = 0;
    MEMSET(TMP_TABLE.BINS, 0, SIZEOF(STRUCT ST_TABLE_ENTRY *) * TMP_TABLE.NUM_BINS);
    FOR (I = 0; I < TABLE->NUM_ENTRIES; I++) {
        ST_INSERT(&TMP_TABLE, (ST_DATA_T)PACKED_BINS[I*2], (ST_DATA_T)PACKED_BINS[I*2+1]);
    }
    *TABLE = TMP_TABLE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512969_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ITEM_FUNC_REGEX::FIX_LENGTH_AND_DEC()
{
  IF (ITEM_BOOL_FUNC::FIX_LENGTH_AND_DEC() ||
      AGG_ARG_CHARSETS_FOR_COMPARISON(CMP_COLLATION, ARGS, 2))
    RETURN TRUE;

  RE.INIT(CMP_COLLATION.COLLATION, 0);
  RE.FIX_OWNER(THIS, ARGS[0], ARGS[1]);
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 213513_CWE-369.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE VOID CONVERTLUVTOXYZ(CONST DOUBLE L,CONST DOUBLE U,CONST DOUBLE V,
  DOUBLE *X,DOUBLE *Y,DOUBLE *Z)
{
  ASSERT(X != (DOUBLE *) NULL);
  ASSERT(Y != (DOUBLE *) NULL);
  ASSERT(Z != (DOUBLE *) NULL);
  IF (L > (CIEK*CIEEPSILON))
    *Y=(DOUBLE) POW((L+16.0)/116.0,3.0);
  ELSE
    *Y=L/CIEK;
  *X=((*Y*((39.0*L/(V+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y))/((((52.0*L/(U+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/
    3.0)-(-1.0/3.0));
  *Z=(*X*(((52.0*L/(U+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195095_CWE-295.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT SOCKET::STARTSSLCLIENT(CONST STD::STRING &CERTIFICATE_PATH, STRING HOSTNAME)
{
    IF (ISSSL) {
        STOPSSL();
    }

    ERR_CLEAR_ERROR();
#IF OPENSSL_VERSION_NUMBER < 0X10100000L
    CTX = SSL_CTX_NEW(SSLV23_CLIENT_METHOD());
#ELSE
    CTX = SSL_CTX_NEW(TLS_CLIENT_METHOD());
#ENDIF

    IF (CTX == NULL) {
#IFDEF NETDEBUG
        STD::COUT << THREAD_ID << "ERROR SSL CONTEXT IS NULL (CHECK THAT OPENSSL HAS BEEN INITED)" << STD::ENDL;
#ENDIF
        LOG_SSL_ERRORS("ERROR SSL CONTEXT IS NULL FOR %S", HOSTNAME.C_STR());
        RETURN -1;
    }

    //SET THE TIMEOUT FOR THE SSL SESSION
    IF (SSL_CTX_SET_TIMEOUT(CTX, 130L) < 1) {
            SSL_CTX_FREE(CTX);
            CTX = NULL;
        RETURN -1;
    }

    //LOAD CERTS
    ERR_CLEAR_ERROR();
    IF (CERTIFICATE_PATH.LENGTH()) {
        IF (!SSL_CTX_LOAD_VERIFY_LOCATIONS(CTX, NULL, CERTIFICATE_PATH.C_STR())) {
#IFDEF NETDEBUG
            STD::COUT << THREAD_ID << "COULDNT LOAD CERTIFICATES" << STD::ENDL;
#ENDIF
            LOG_SSL_ERRORS("COULDNT LOAD CERTIFICATES FROM %S", CERTIFICATE_PATH.C_STR());
            //TIDY UP
            SSL_CTX_FREE(CTX);
            CTX = NULL;
            RETURN -2;
        }
    } ELSE IF (!SSL_CTX_SET_DEFAULT_VERIFY_PATHS(CTX)) //USE DEFAULT IF NO CERTPPATH GIVEN
    {
#IFDEF NETDEBUG
        STD::COUT << THREAD_ID << "COULDNT LOAD CERTIFICATES" << STD::ENDL;
#ENDIF
            LOG_SSL_ERRORS("COULDNT LOAD DEFAULT CERTIFICATES FOR %S", HOSTNAME.C_STR());
        //TIDY UP
        SSL_CTX_FREE(CTX);
        CTX = NULL;
        RETURN -2;
    }

    // ADD VALIDATION PARAMS
    ERR_CLEAR_ERROR();
    X509_VERIFY_PARAM *X509_PARAM = X509_VERIFY_PARAM_NEW();
    IF (!X509_PARAM) {
        LOG_SSL_ERRORS("COULDNT ADD VALIDATION PARAMS FOR %S", HOSTNAME.C_STR());
        //X509_VERIFY_PARAM_FREE(X509_PARAM);
            SSL_CTX_FREE(CTX);
            CTX = NULL;
        RETURN -2;
    }

    ERR_CLEAR_ERROR();
    IF (!X509_VERIFY_PARAM_SET_FLAGS(X509_PARAM, X509_V_FLAG_TRUSTED_FIRST)) {
        LOG_SSL_ERRORS("COULDNT ADD VALIDATION PARAMS FOR %S", HOSTNAME.C_STR());
        X509_VERIFY_PARAM_FREE(X509_PARAM);
            SSL_CTX_FREE(CTX);
            CTX = NULL;
        RETURN -2;
    }

    ERR_CLEAR_ERROR();
    IF (!SSL_CTX_SET1_PARAM(CTX, X509_PARAM)) {
        LOG_SSL_ERRORS("COULDNT ADD VALIDATION PARAMS FOR %S", HOSTNAME.C_STR());
        X509_VERIFY_PARAM_FREE(X509_PARAM);
            SSL_CTX_FREE(CTX);
            CTX = NULL;
        RETURN -2;
    }

    X509_VERIFY_PARAM_FREE(X509_PARAM);     // TRY NOT FREEING THIS AS SSL_CTX_FREE SEEMS TO BE RING TO FREE IT

    //HAND SOCKET OVER TO SSL LIB
    ERR_CLEAR_ERROR();
    SSL = SSL_NEW(CTX);
    SSL_SET_OPTIONS(SSL, SSL_OP_ALL);
    SSL_SET_MODE(SSL, SSL_MODE_AUTO_RETRY);
    SSL_SET_CONNECT_STATE(SSL);

    //FCNTL(THIS->GETFD() ,F_SETFL, O_NONBLOCK); // BLOCKING MODE USED CURRENTLY
    SSL_SET_FD(SSL, THIS->GETFD());
    SSL_SET_TLSEXT_HOST_NAME(SSL, HOSTNAME.C_STR());

    //MAKE IO NON BLOCKING AS SELECT WONT TELL US IF WE CAN DO A READ WITHOUT BLOCKING
    //BIO_SET_NBIO(SSL_GET_RBIO(SSL),1L);  // BLOCKING MODE USED CURRENTLY
    //BIO_SET_NBIO(SSL_GET_WBIO(SSL),1L); // BLOCKING MODE USED CURRENTLY
    ERR_CLEAR_ERROR();
    INT RC = SSL_CONNECT(SSL);
    IF (RC < 0) {
        LOG_SSL_ERRORS("SSL_CONNECT FAILED TO %S", HOSTNAME.C_STR());
#IFDEF NETDEBUG
        STD::COUT << THREAD_ID << "SSL_CONNECT FAILED WITH ERROR " << SSL_GET_ERROR(SSL, RC) << STD::ENDL;
#ENDIF
        // TIDY UP
        SSL_FREE(SSL);
        SSL = NULL;
        SSL_CTX_FREE(CTX);
        CTX = NULL;
        RETURN -3;
    }

    //SHOULD BE SAFER TO DO THIS LAST AS NOTHING WILL EVER TRY TO USE A SSL SOCKET THAT ISNT FULLY SETUP
    ISSSL = TRUE;
    ISSSLSERVER = FALSE;
    RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 393528_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC SQINTEGER THREAD_CALL(HSQUIRRELVM V)
{
    SQOBJECTPTR O = STACK_GET(V,1);
    IF(SQ_TYPE(O) == OT_THREAD) {
        SQINTEGER NPARAMS = SQ_GETTOP(V);
        SQ_RESERVESTACK(_THREAD(O), NPARAMS + 3);
        _THREAD(O)->PUSH(_THREAD(O)->_ROOTTABLE);
        FOR(SQINTEGER I = 2; I<(NPARAMS+1); I++)
            SQ_MOVE(_THREAD(O),V,I);
        IF(SQ_SUCCEEDED(SQ_CALL(_THREAD(O),NPARAMS,SQTRUE,SQTRUE))) {
            SQ_MOVE(V,_THREAD(O),-1);
            SQ_POP(_THREAD(O),1);
            RETURN 1;
        }
        V->_LASTERROR = _THREAD(O)->_LASTERROR;
        RETURN SQ_ERROR;
    }
    RETURN SQ_THROWERROR(V,_SC("WRONG PARAMETER"));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 199952_CWE-787.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MP_SINT32 LOADERXM::LOAD(XMFILEBASE& F, XMODULE* MODULE)
{
	MP_UBYTE INSDATA[230];		
	MP_SINT32 SMPRELOC[MP_MAXINSSAMPS];
	MP_UBYTE NBU[MP_MAXINSSAMPS];
	MP_UINT32 FILESIZE = 0;
			
	MODULE->CLEANUP();

	// THIS WILL MAKE CODE MUCH EASIER TO READ
	TXMHEADER*		HEADER = &MODULE->HEADER;
	TXMINSTRUMENT*	INSTR  = MODULE->INSTR;
	TXMSAMPLE*		SMP	   = MODULE->SMP;
	TXMPATTERN*		PHEAD  = MODULE->PHEAD;	

	// WE'RE ALREADY OUT OF MEMORY HERE
	IF (!PHEAD || !INSTR || !SMP)
		RETURN MP_OUT_OF_MEMORY;
	
	FILESIZE = F.SIZEWITHBASEOFFSET();
	
	F.READ(&HEADER->SIG,1,17);
	F.READ(&HEADER->NAME,1,20);
	F.READ(&HEADER->WHYTHIS1A,1,1);
	HEADER->WHYTHIS1A=0;
	F.READ(&HEADER->TRACKER,1,20);
	F.READWORDS(&HEADER->VER,1);
	
	IF (HEADER->VER != 0X102 && 
		HEADER->VER != 0X103 && // UNTESTED
		HEADER->VER != 0X104)
		RETURN MP_LOADER_FAILED;
	
	F.READDWORDS(&HEADER->HDRSIZE,1);
	
	HEADER->HDRSIZE-=4;
	
	MP_UINT32 HDRSIZE = 0X110;
	IF (HEADER->HDRSIZE > HDRSIZE)
		HDRSIZE = HEADER->HDRSIZE;
				
	MP_UBYTE* HDRBUFF = NEW MP_UBYTE[HDRSIZE];
	MEMSET(HDRBUFF, 0, HDRSIZE);
	
	F.READ(HDRBUFF, 1, HEADER->HDRSIZE);
	
	HEADER->ORDNUM = LITTLEENDIAN::GET_WORD(HDRBUFF);
	HEADER->RESTART = LITTLEENDIAN::GET_WORD(HDRBUFF+2);
	HEADER->CHANNUM = LITTLEENDIAN::GET_WORD(HDRBUFF+4);
	HEADER->PATNUM = LITTLEENDIAN::GET_WORD(HDRBUFF+6);
	HEADER->INSNUM = LITTLEENDIAN::GET_WORD(HDRBUFF+8);
	HEADER->FREQTAB = LITTLEENDIAN::GET_WORD(HDRBUFF+10);
	HEADER->TEMPO = LITTLEENDIAN::GET_WORD(HDRBUFF+12);
	HEADER->SPEED = LITTLEENDIAN::GET_WORD(HDRBUFF+14);
	MEMCPY(HEADER->ORD, HDRBUFF+16, 256);
	IF(HEADER->ORDNUM > MP_MAXORDERS)
		HEADER->ORDNUM = MP_MAXORDERS;
	IF(HEADER->INSNUM > MP_MAXINS)
		RETURN MP_LOADER_FAILED;

	DELETE[] HDRBUFF;
	
	HEADER->MAINVOL=255;
	HEADER->FLAGS = XMODULE::MODULE_XMNOTECLIPPING | 
		XMODULE::MODULE_XMARPEGGIO | 
		XMODULE::MODULE_XMPORTANOTEBUFFER | 
		XMODULE::MODULE_XMVOLCOLUMNVIBRATO;

	HEADER->UPPERNOTEBOUND = 119;
	
	MP_SINT32 I,Y,SC;
	FOR (I=0;I<32;I++) HEADER->PAN[I]=0X80;
	
	// OLD VERSION?
	IF (HEADER->VER == 0X102 || HEADER->VER == 0X103)
	{
		MP_SINT32 S = 0;
		MP_SINT32 E = 0;
		FOR (Y=0;Y<HEADER->INSNUM;Y++) {
			
			F.READDWORDS(&INSTR[Y].SIZE,1);
			F.READ(&INSTR[Y].NAME,1,22);		
			F.READ(&INSTR[Y].TYPE,1,1);
			MP_UWORD NUMSAMPLES = 0;
			F.READWORDS(&NUMSAMPLES,1);
			IF(NUMSAMPLES > MP_MAXINSSAMPS)
				RETURN MP_LOADER_FAILED;
			INSTR[Y].SAMP = NUMSAMPLES;

			IF (INSTR[Y].SIZE == 29)
			{
#IFDEF MILKYTRACKER
				S+=16;
#ENDIF
				FOR (MP_SINT32 I = 0; I < 120; I++)
					INSTR[Y].SNUM[I] = -1;
				CONTINUE;
			}

			F.READDWORDS(&INSTR[Y].SHSIZE,1);

			MEMSET(INSDATA, 0, 230);
			
			IF (INSTR[Y].SIZE - 33 > 230)
				RETURN MP_OUT_OF_MEMORY;
			
			F.READ(INSDATA, 1, INSTR[Y].SIZE - 33);
						
			IF (INSTR[Y].SAMP) {
				MP_UBYTE* INSDATAPTR = INSDATA;
				
				MEMCPY(NBU, INSDATAPTR, MP_MAXINSSAMPS);
				INSDATAPTR+=MP_MAXINSSAMPS;
				
				TENVELOPE VENV;
				TENVELOPE PENV;
				MEMSET(&VENV,0,SIZEOF(VENV));
				MEMSET(&PENV,0,SIZEOF(PENV));
				
				MP_SINT32 K;
				FOR (K = 0; K < XM_ENVELOPENUMPOINTS; K++)
				{
					VENV.ENV[K][0] = LITTLEENDIAN::GET_WORD(INSDATAPTR);
					VENV.ENV[K][1] = LITTLEENDIAN::GET_WORD(INSDATAPTR+2);
					INSDATAPTR+=4;
				}
				FOR (K = 0; K < XM_ENVELOPENUMPOINTS; K++)
				{
					PENV.ENV[K][0] = LITTLEENDIAN::GET_WORD(INSDATAPTR);
					PENV.ENV[K][1] = LITTLEENDIAN::GET_WORD(INSDATAPTR+2);
					INSDATAPTR+=4;
				}
				
				VENV.NUM = *INSDATAPTR++;	
				IF (VENV.NUM > XM_ENVELOPENUMPOINTS) VENV.NUM = XM_ENVELOPENUMPOINTS;
				PENV.NUM = *INSDATAPTR++;	
				IF (PENV.NUM > XM_ENVELOPENUMPOINTS) PENV.NUM = XM_ENVELOPENUMPOINTS;
				VENV.SUSTAIN = *INSDATAPTR++;
				VENV.LOOPS = *INSDATAPTR++;
				VENV.LOOPE = *INSDATAPTR++;
				PENV.SUSTAIN = *INSDATAPTR++;
				PENV.LOOPS = *INSDATAPTR++;
				PENV.LOOPE = *INSDATAPTR++;
				VENV.TYPE = *INSDATAPTR++;
				PENV.TYPE = *INSDATAPTR++;				
				
				MP_UBYTE VIBTYPE, VIBSWEEP, VIBDEPTH, VIBRATE;
				MP_UWORD VOLFADE;
				
				VIBTYPE = *INSDATAPTR++;
				VIBSWEEP = *INSDATAPTR++;
				VIBDEPTH = *INSDATAPTR++;
				VIBRATE = *INSDATAPTR++;
				
				VIBDEPTH<<=1;
				
				VOLFADE = LITTLEENDIAN::GET_WORD(INSDATAPTR);
				INSDATAPTR+=2;
				VOLFADE<<=1;
				
				//INSTR[Y].RES = LITTLEENDIAN::GET_WORD(INSDATAPTR);
				INSDATAPTR+=2;
				
				FOR (MP_SINT32 L=0;L<XM_ENVELOPENUMPOINTS;L++) {
					VENV.ENV[L][1]<<=2;
					PENV.ENV[L][1]<<=2;
				}
				
				IF (!MODULE->ADDVOLUMEENVELOPE(VENV)) 
					RETURN MP_OUT_OF_MEMORY;
				IF (!MODULE->ADDPANNINGENVELOPE(PENV)) 
					RETURN MP_OUT_OF_MEMORY;
				
				MP_SINT32 G=0, SC;
				FOR (SC=0;SC<INSTR[Y].SAMP;SC++) {
					
					SMP[G+S].FLAGS=3;
					SMP[G+S].VENVNUM=E+1;
					SMP[G+S].PENVNUM=E+1;
					
					SMP[G+S].VIBTYPE=VIBTYPE;
					SMP[G+S].VIBSWEEP=VIBSWEEP;
					SMP[G+S].VIBDEPTH=VIBDEPTH;
					SMP[G+S].VIBRATE=VIBRATE;
					SMP[G+S].VOLFADE=VOLFADE;
					
					// NOT SURE WHY I DID THAT, ACTUALLY DOESN'T MAKE SENSE
					//IF (!(VENV.TYPE&1)) SMP[G+S].VOLFADE=0;
					
					F.READDWORDS(&SMP[G+S].SAMPLEN,1);
					F.READDWORDS(&SMP[G+S].LOOPSTART,1);
					F.READDWORDS(&SMP[G+S].LOOPLEN,1);
					SMP[G+S].VOL=XMODULE::VOL64TO255(F.READBYTE());
					//F.READ(&SMP[G+S].VOL,1,1);
					F.READ(&SMP[G+S].FINETUNE,1,1);
					F.READ(&SMP[G+S].TYPE,1,1);
#IFDEF VERBOSE
					PRINTF("BEFORE: %I, AFTER: %I\N", SMP[G+S].TYPE, SMP[G+S].TYPE & (3+16));
#ENDIF
					F.READ(&SMP[G+S].PAN,1,1);
					F.READ(&SMP[G+S].RELNOTE,1,1);
					F.READ(&SMP[G+S].RES,1,1);
					F.READ(&SMP[G+S].NAME,1,22);
					
					CHAR LINE[30];
					MEMSET(LINE, 0, SIZEOF(LINE));
					XMODULE::CONVERTSTR(LINE, SMP[G+S].NAME, 23, FALSE);					
					IF (LINE[0])
						MODULE->ADDSONGMESSAGELINE(LINE);
					
					// IGNORE EMPTY SAMPLES
#IFNDEF MILKYTRACKER
					// IGNORE EMPTY SAMPLES WHEN NOT BEING A TRACKER
					IF (SMP[G+S].SAMPLEN) {
						SMPRELOC[SC] = G;
						G++;
					}
					ELSE
						SMPRELOC[SC] = -1;
#ELSE
					SMPRELOC[SC] = G;
					G++;
#ENDIF
				}

				INSTR[Y].SAMP = G;

				FOR (SC = 0; SC < MP_MAXINSSAMPS; SC++) {
					IF (SMPRELOC[NBU[SC]] == -1)
						INSTR[Y].SNUM[SC] = -1;
					ELSE
						INSTR[Y].SNUM[SC] = SMPRELOC[NBU[SC]]+S;					
				}

				E++;
				
			}
			ELSE
			{
				FOR (MP_SINT32 I = 0; I < 120; I++)
					INSTR[Y].SNUM[I] = -1;
			}

#IFDEF MILKYTRACKER
			S+=16;
#ELSE
			S+=INSTR[Y].SAMP;
#ENDIF				
				
			
		}
		
		HEADER->SMPNUM=S;
		HEADER->VOLENVNUM=E;
		HEADER->PANENVNUM=E;
	}
	
	FOR (Y=0;Y<HEADER->PATNUM;Y++) {
		
		IF (HEADER->VER == 0X104 || HEADER->VER == 0X103)
		{
			F.READDWORDS(&PHEAD[Y].LEN,1);
			F.READ(&PHEAD[Y].PTYPE,1,1);
			F.READWORDS(&PHEAD[Y].ROWS,1);
			F.READWORDS(&PHEAD[Y].PATDATA,1);
		}
		ELSE
		{
			F.READDWORDS(&PHEAD[Y].LEN,1);
			F.READ(&PHEAD[Y].PTYPE,1,1);
			PHEAD[Y].ROWS = (MP_UWORD)F.READBYTE()+1;
			F.READWORDS(&PHEAD[Y].PATDATA,1);			
		}
		
		PHEAD[Y].EFFNUM=2;
		PHEAD[Y].CHANNUM=(MP_UBYTE)HEADER->CHANNUM;
		
		PHEAD[Y].PATTERNDATA = NEW MP_UBYTE[PHEAD[Y].ROWS*HEADER->CHANNUM*6];
		
		// OUT OF MEMORY?
		IF (PHEAD[Y].PATTERNDATA == NULL)
		{
			RETURN MP_OUT_OF_MEMORY;
		}
		
		MEMSET(PHEAD[Y].PATTERNDATA,0,PHEAD[Y].ROWS*HEADER->CHANNUM*6);
		
		IF (PHEAD[Y].PATDATA) {
			MP_UBYTE *BUFFER = NEW MP_UBYTE[PHEAD[Y].PATDATA];
			
			// OUT OF MEMORY?
			IF (BUFFER == NULL)
			{
				RETURN MP_OUT_OF_MEMORY;			
			}
			
			F.READ(BUFFER,1,PHEAD[Y].PATDATA);
			
			//PRINTF("%I\N", PHEAD[Y].PATDATA);
			
			MP_SINT32 PC = 0, BC = 0;
			FOR (MP_SINT32 R=0;R<PHEAD[Y].ROWS;R++) {
				FOR (MP_SINT32 C=0;C<HEADER->CHANNUM;C++) {
					
					MP_UBYTE SLOT[5];
					MEMSET(SLOT,0,5);
					
					IF ((BUFFER[PC]&128)) {
						
						MP_UBYTE PB = BUFFER[PC];
						PC++;
						
						IF ((PB&1)) {
							//PHEAD[Y].PATTERNDATA[BC]=BUFFER[PC];
							SLOT[0]=BUFFER[PC];
							PC++;
						}
						IF ((PB&2)) {
							//PHEAD[Y].PATTERNDATA[BC+1]=BUFFER[PC];
							SLOT[1]=BUFFER[PC];
							PC++;
						}
						IF ((PB&4)) {
							//PHEAD[Y].PATTERNDATA[BC+2]=BUFFER[PC];
							SLOT[2]=BUFFER[PC];
							PC++;
						}
						IF ((PB&8)) {
							//PHEAD[Y].PATTERNDATA[BC+3]=BUFFER[PC];
							SLOT[3]=BUFFER[PC];
							PC++;
						}
						IF ((PB&16)) {
							//PHEAD[Y].PATTERNDATA[BC+4]=BUFFER[PC];
							SLOT[4]=BUFFER[PC];
							PC++;
						}
						
					}
					ELSE {
						//MEMCPY(PHEAD[Y].PATTERNDATA+BC,BUFFER+PC,5);
						MEMCPY(SLOT,BUFFER+PC,5);
						PC+=5;
					}
					
					CHAR GL=0;
					FOR (MP_SINT32 I=0;I<XMODULE::NUMVALIDXMEFFECTS;I++)
						IF (SLOT[3]==XMODULE::VALIDXMEFFECTS[I]) GL=1;
					
					IF (!GL) SLOT[3]=SLOT[4]=0;
					
					IF ((SLOT[3]==0XC)||(SLOT[3]==0X10)) {
						SLOT[4] = XMODULE::VOL64TO255(SLOT[4]);
						/*MP_SINT32 BL = SLOT[4];
						IF (BL>64) BL=64;
						SLOT[4]=(BL*261120)>>16;*/
					}
					
					IF ((!SLOT[3])&&(SLOT[4])) SLOT[3]=0X20;
					
					IF (SLOT[3]==0XE) {
						SLOT[3]=(SLOT[4]>>4)+0X30;
						SLOT[4]=SLOT[4]&0XF;
					}
					
					IF (SLOT[3]==0X21) {
						SLOT[3]=(SLOT[4]>>4)+0X40;
						SLOT[4]=SLOT[4]&0XF;
					}
					
					IF (SLOT[0]==97) SLOT[0]=XMODULE::NOTE_OFF;
					
					PHEAD[Y].PATTERNDATA[BC]=SLOT[0];
					PHEAD[Y].PATTERNDATA[BC+1]=SLOT[1];
					
					XMODULE::CONVERTXMVOLUMEEFFECTS(SLOT[2], PHEAD[Y].PATTERNDATA[BC+2], PHEAD[Y].PATTERNDATA[BC+3]);

					PHEAD[Y].PATTERNDATA[BC+4]=SLOT[3];
					PHEAD[Y].PATTERNDATA[BC+5]=SLOT[4];
					
					/*IF ((Y==3)&&(C==2)) {
						FOR (MP_SINT32 BL=0;BL<6;BL++) CPRINTF("%X ",PHEAD[Y].PATTERNDATA[BC+BL]);
					CPRINTF("\R\N");
					GETCH();
					};*/
					
					/*PRINTF("NOTE : %I\R\N",PHEAD[Y].PATTERNDATA[BC]);
					PRINTF("INS  : %I\R\N",PHEAD[Y].PATTERNDATA[BC+1]);
					PRINTF("VOL  : %I\R\N",PHEAD[Y].PATTERNDATA[BC+2]);
					PRINTF("EFF  : %I\R\N",PHEAD[Y].PATTERNDATA[BC+3]);
					PRINTF("EFFOP: %I\R\N",PHEAD[Y].PATTERNDATA[BC+4]);
					GETCH();*/
					
					BC+=6;
				} // FOR C
					
			} // FOR R
				
			DELETE[] BUFFER;
		}
			
	}
		
	IF (HEADER->VER == 0X104)
	{
		MP_SINT32 S = 0;
		MP_SINT32 E = 0;
		FOR (Y=0;Y<HEADER->INSNUM;Y++) {

			// FIXES MOOH.XM LOADING PROBLEMS
			// SEEMS TO STORE MORE INSTRUMENTS IN THE HEADER THAN IN THE ACTUAL FILE
			IF (F.POSWITHBASEOFFSET() >= FILESIZE)
				BREAK;
		
			//TXMINSTRUMENT* INS = &INSTR[Y];
		
			F.READDWORDS(&INSTR[Y].SIZE,1);
			
			IF (INSTR[Y].SIZE < 29)
			{
				MP_UBYTE BUFFER[29];
				MEMSET(BUFFER, 0, SIZEOF(BUFFER));
				F.READ(BUFFER, 1, INSTR[Y].SIZE - 4);
				MEMCPY(INSTR[Y].NAME, BUFFER, 22);
				INSTR[Y].TYPE = BUFFER[22];
				INSTR[Y].SAMP = LITTLEENDIAN::GET_WORD(BUFFER + 23);
			}
			ELSE
			{
				F.READ(&INSTR[Y].NAME,1,22);		
				F.READ(&INSTR[Y].TYPE,1,1);
				F.READWORDS(&INSTR[Y].SAMP,1);
			}
			IF (INSTR[Y].SAMP > MP_MAXINSSAMPS)
				RETURN MP_LOADER_FAILED;

			//PRINTF("%I, %I\N", INSTR[Y].SIZE, INSTR[Y].SAMP);

			IF (INSTR[Y].SIZE <= 29)
			{
#IFDEF MILKYTRACKER
				S+=16;
#ENDIF
				FOR (MP_SINT32 I = 0; I < 120; I++)
					INSTR[Y].SNUM[I] = -1;
				CONTINUE;
			}

			F.READDWORDS(&INSTR[Y].SHSIZE,1);
#IFDEF VERBOSE
			PRINTF("%I/%I: %I, %I, %I, %S\N",Y,HEADER->INSNUM-1,INSTR[Y].SIZE,INSTR[Y].SHSIZE,INSTR[Y].SAMP,INSTR[Y].NAME);			
#ENDIF
			MEMSET(INSDATA, 0, 230);
			
			IF (INSTR[Y].SIZE - 33 > 230)
			{
				//RETURN -7;
				BREAK;
			}
			
			F.READ(INSDATA, 1, INSTR[Y].SIZE - 33);
			
			/*PRINTF("%I\R\N",INSTR[Y].SIZE);
			PRINTF("%S\R\N",INSTR[Y].NAME);
			PRINTF("%I\R\N",INSTR[Y].TYPE);
			PRINTF("%I\R\N",INSTR[Y].SAMP);
			PRINTF("%I\R\N",INSTR[Y].SHSIZE);*/
			//GETCH();
					
			MEMSET(SMPRELOC, 0, SIZEOF(SMPRELOC));
			
			IF (INSTR[Y].SAMP) {
				MP_UBYTE* INSDATAPTR = INSDATA;
				
				//F.READ(&NBU,1,96);
				
				MEMCPY(NBU, INSDATAPTR, MP_MAXINSSAMPS);
				INSDATAPTR+=MP_MAXINSSAMPS;
				
				TENVELOPE VENV;
				TENVELOPE PENV;
				MEMSET(&VENV,0,SIZEOF(VENV));
				MEMSET(&PENV,0,SIZEOF(PENV));
				
				MP_SINT32 K;
				FOR (K = 0; K < XM_ENVELOPENUMPOINTS; K++)
				{
					VENV.ENV[K][0] = LITTLEENDIAN::GET_WORD(INSDATAPTR);
					VENV.ENV[K][1] = LITTLEENDIAN::GET_WORD(INSDATAPTR+2);
					INSDATAPTR+=4;
				}
				FOR (K = 0; K < XM_ENVELOPENUMPOINTS; K++)
				{
					PENV.ENV[K][0] = LITTLEENDIAN::GET_WORD(INSDATAPTR);
					PENV.ENV[K][1] = LITTLEENDIAN::GET_WORD(INSDATAPTR+2);
					INSDATAPTR+=4;
				}
				
				VENV.NUM = *INSDATAPTR++;	
				IF (VENV.NUM > XM_ENVELOPENUMPOINTS) VENV.NUM = XM_ENVELOPENUMPOINTS;
				PENV.NUM = *INSDATAPTR++;					
				IF (PENV.NUM > XM_ENVELOPENUMPOINTS) PENV.NUM = XM_ENVELOPENUMPOINTS;
				VENV.SUSTAIN = *INSDATAPTR++;
				VENV.LOOPS = *INSDATAPTR++;
				VENV.LOOPE = *INSDATAPTR++;
				PENV.SUSTAIN = *INSDATAPTR++;
				PENV.LOOPS = *INSDATAPTR++;
				PENV.LOOPE = *INSDATAPTR++;
				VENV.TYPE = *INSDATAPTR++;
				PENV.TYPE = *INSDATAPTR++;				
				
				MP_UBYTE VIBTYPE, VIBSWEEP, VIBDEPTH, VIBRATE;
				MP_UWORD VOLFADE;
				
				VIBTYPE = *INSDATAPTR++;
				VIBSWEEP = *INSDATAPTR++;
				VIBDEPTH = *INSDATAPTR++;
				VIBRATE = *INSDATAPTR++;
				
				VIBDEPTH<<=1;
				
				//F.READWORDS(&VOLFADE,1);
				VOLFADE = LITTLEENDIAN::GET_WORD(INSDATAPTR);
				INSDATAPTR+=2;
				VOLFADE<<=1;
				
				//INSTR[Y].RES = LITTLEENDIAN::GET_WORD(INSDATAPTR);
				INSDATAPTR+=2;
				
				FOR (MP_SINT32 L=0;L<XM_ENVELOPENUMPOINTS;L++) {
					VENV.ENV[L][1]<<=2;
					PENV.ENV[L][1]<<=2;
				}
				
				IF (!MODULE->ADDVOLUMEENVELOPE(VENV)) 
					RETURN MP_OUT_OF_MEMORY;
				IF (!MODULE->ADDPANNINGENVELOPE(PENV)) 
					RETURN MP_OUT_OF_MEMORY;
				
				MP_SINT32 G=0, SC;
				FOR (SC=0;SC<INSTR[Y].SAMP;SC++) {
					//TXMSAMPLE* SMPL = &SMP[G+S];
					
					SMP[G+S].FLAGS=3;
					SMP[G+S].VENVNUM=E+1;
					SMP[G+S].PENVNUM=E+1;
					
					SMP[G+S].VIBTYPE=VIBTYPE;
					SMP[G+S].VIBSWEEP=VIBSWEEP;
					SMP[G+S].VIBDEPTH=VIBDEPTH;
					SMP[G+S].VIBRATE=VIBRATE;
					SMP[G+S].VOLFADE=VOLFADE;
					
					// NOT SURE WHY I DID THAT, ACTUALLY DOESN'T MAKE SENSE
					//IF (!(VENV.TYPE&1)) SMP[G+S].VOLFADE=0;
					
					F.READDWORDS(&SMP[G+S].SAMPLEN,1);
					
					F.READDWORDS(&SMP[G+S].LOOPSTART,1);
					F.READDWORDS(&SMP[G+S].LOOPLEN,1);
					SMP[G+S].VOL=XMODULE::VOL64TO255(F.READBYTE());
					//F.READ(&SMP[G+S].VOL,1,1);
					F.READ(&SMP[G+S].FINETUNE,1,1);
					F.READ(&SMP[G+S].TYPE,1,1);
#IFDEF VERBOSE
					PRINTF("BEFORE: %I, AFTER: %I\N", SMP[G+S].TYPE, SMP[G+S].TYPE & (3+16));
#ENDIF
					F.READ(&SMP[G+S].PAN,1,1);
					F.READ(&SMP[G+S].RELNOTE,1,1);
					F.READ(&SMP[G+S].RES,1,1);
					F.READ(&SMP[G+S].NAME,1,22);

					CHAR LINE[30];
					MEMSET(LINE, 0, SIZEOF(LINE));
					XMODULE::CONVERTSTR(LINE, SMP[G+S].NAME, 23, FALSE);					
					IF (LINE[0])
						MODULE->ADDSONGMESSAGELINE(LINE);
					
#IFNDEF MILKYTRACKER
					// IGNORE EMPTY SAMPLES WHEN NOT BEING A TRACKER
					IF (SMP[G+S].SAMPLEN) {
						SMPRELOC[SC] = G;
						G++;
					}
					ELSE
						SMPRELOC[SC] = -1;
#ELSE
					SMPRELOC[SC] = G;
					G++;
#ENDIF
				}

				INSTR[Y].SAMP = G;

				FOR (SC = 0; SC < MP_MAXINSSAMPS; SC++) {					
					IF (SMPRELOC[NBU[SC]] == -1)
						INSTR[Y].SNUM[SC] = -1;
					ELSE
						INSTR[Y].SNUM[SC] = SMPRELOC[NBU[SC]]+S;
				}
						
				FOR (SC=0;SC<INSTR[Y].SAMP;SC++) {
				
					IF (SMP[S].SAMPLEN)
					{
						BOOL ADPCM = (SMP[S].RES == 0XAD);
					
						MP_UINT32 OLDSIZE = SMP[S].SAMPLEN;
						IF (SMP[S].TYPE&16) 
						{
							SMP[S].SAMPLEN>>=1;
							SMP[S].LOOPSTART>>=1;
							SMP[S].LOOPLEN>>=1;
						}
						
						MP_SINT32 RESULT = MODULE->LOADMODULESAMPLE(F, S, 
													 ADPCM ? XMODULE::ST_PACKING_ADPCM : XMODULE::ST_DELTA, 
													 ADPCM ? (XMODULE::ST_PACKING_ADPCM | XMODULE::ST_16BIT) : (XMODULE::ST_DELTA | XMODULE::ST_16BIT), 
													 OLDSIZE);
						IF (RESULT != MP_OK)
							RETURN RESULT;					
						
						IF (ADPCM)
							SMP[S].RES = 0;
					}
					
					S++;
					
					IF (S>=MP_MAXSAMPLES)
						RETURN MP_OUT_OF_MEMORY;
					
				}

				E++;
				
			}
			ELSE
			{
				FOR (MP_SINT32 I = 0; I < 120; I++)
					INSTR[Y].SNUM[I] = -1;
			}

#IFDEF MILKYTRACKER
			S+=16 - INSTR[Y].SAMP;
#ENDIF				
			
		}
		
		HEADER->SMPNUM=S;
		HEADER->VOLENVNUM=E;
		HEADER->PANENVNUM=E;		
		
	}
	ELSE
	{
		MP_SINT32 S = 0;
		FOR (Y=0;Y<HEADER->INSNUM;Y++) {
			FOR (SC=0;SC<INSTR[Y].SAMP;SC++) {

				IF (SMP[S].SAMPLEN)
				{
					MP_UINT32 OLDSIZE = SMP[S].SAMPLEN;
					IF (SMP[S].TYPE&16) 
					{
						SMP[S].SAMPLEN>>=1;
						SMP[S].LOOPSTART>>=1;
						SMP[S].LOOPLEN>>=1;
					}
					
					MP_SINT32 RESULT = MODULE->LOADMODULESAMPLE(F, S, XMODULE::ST_DELTA, XMODULE::ST_DELTA | XMODULE::ST_16BIT, OLDSIZE);
					IF (RESULT != MP_OK)
						RETURN RESULT;					
				}
				
				S++;
				
				IF (S>=MP_MAXSAMPLES)
					RETURN MP_OUT_OF_MEMORY;				
			}
			
#IFDEF MILKYTRACKER
			S+=16 - INSTR[Y].SAMP;
#ENDIF
			
		}		
	}
	
	// CONVERT MODPLUG STEREO SAMPLES
	FOR (MP_SINT32 S = 0; S < HEADER->SMPNUM; S++)
	{
		IF (SMP[S].TYPE & 32)
		{		
			// THAT'S WHAT'S ALLOWED, STUPID MODPLUG TRACKER
			SMP[S].TYPE &= 3+16;					

			IF (SMP[S].SAMPLE == NULL)
				CONTINUE;
			
			IF (!(SMP[S].TYPE&16)) {			
				SMP[S].SAMPLEN>>=1;
				SMP[S].LOOPSTART>>=1;
				SMP[S].LOOPLEN>>=1;
				
				MP_SBYTE* SAMPLE = (MP_SBYTE*)SMP[S].SAMPLE;
				MP_SINT32 SAMPLEN = SMP[S].SAMPLEN;
				FOR (MP_SINT32 I = 0; I < SAMPLEN; I++)
				{
					MP_SINT32 S = ((MP_SINT32)SAMPLE[I] + (MP_SINT32)SAMPLE[I + SAMPLEN]) >> 1;
					IF (S < -128) S = -128;
					IF (S > 127) S = 127;
					SAMPLE[I] = (MP_SBYTE)S;
				}
			}
			ELSE
			{
				SMP[S].SAMPLEN>>=1;
				SMP[S].LOOPSTART>>=1;
				SMP[S].LOOPLEN>>=1;
				
				MP_SWORD* SAMPLE = (MP_SWORD*)SMP[S].SAMPLE;
				MP_SINT32 SAMPLEN = SMP[S].SAMPLEN;
				FOR (MP_SINT32 I = 0; I < SAMPLEN; I++)
				{
					MP_SINT32 S = ((MP_SINT32)SAMPLE[I] + (MP_SINT32)SAMPLE[I + SAMPLEN]) >> 1;
					IF (S < -32768) S = -32768;
					IF (S > 32767) S = 32767;
					SAMPLE[I] = (MP_SWORD)S;
				}
			}
		}
		
		// CORRECT LOOP TYPE 0X03 (UNDEFINED)
		// WILL BECOME PING PONG LOOP
		// NOTE THAT FT2 WILL REFUSE TO LOAD XM FILES WITH SUCH A LOOP TYPE
		IF ((SMP[S].TYPE & 0X3) == 0X3)
			SMP[S].TYPE&=~1;		
	}

	// CORRECT NUMBER OF PATTERNS IF NECESSARY, OTHERWISE THE POST PROCESSING WILL REMOVE
	// THE "INVALID" PATTERNS FROM THE ORDER LIST
	BOOL ADDPATTERNS = FALSE;
	FOR (I = 0; I < HEADER->ORDNUM; I++)
		IF (HEADER->ORD[I]+1 > HEADER->PATNUM)
		{
			HEADER->PATNUM = HEADER->ORD[I]+1;	
			ADDPATTERNS = TRUE;
		}
	
	// IF THE PATTERN NUMBER HAS BEEN ADJUSTED, ADD SOME EMPTY PATTERNS
	IF (ADDPATTERNS)
	{
		FOR (I = 0; I < HEADER->PATNUM; I++)
			IF (PHEAD[I].PATTERNDATA == NULL)
			{
				PHEAD[I].ROWS = 64;
				PHEAD[I].EFFNUM = 2;
				PHEAD[I].CHANNUM = (MP_UBYTE)HEADER->CHANNUM;

				PHEAD[I].PATTERNDATA = NEW MP_UBYTE[PHEAD[I].ROWS*HEADER->CHANNUM*6];
			
				// OUT OF MEMORY?
				IF (PHEAD[I].PATTERNDATA == NULL)
				{
					RETURN MP_OUT_OF_MEMORY;
				}
		
				MEMSET(PHEAD[I].PATTERNDATA,0,PHEAD[I].ROWS*HEADER->CHANNUM*6);
			}
	}
	
	// CHECK FOR MODPLUG EXTENSIONS
	IF (F.POSWITHBASEOFFSET() + 8 <= FILESIZE)
	{
		CHAR BUFFER[4];
		F.READ(BUFFER, 1, 4);
		IF (MEMCMP(BUFFER, "TEXT", 4) == 0)
		{
			MP_UINT32 LEN = F.READDWORD();
			MODULE->ALLOCATESONGMESSAGE(LEN+1);
			
			MEMSET(MODULE->MESSAGE, 0, LEN+1);
			
			F.READ(MODULE->MESSAGE, 1, LEN);
		}
	}
	
	MODULE->POSTPROCESSSAMPLES();
	
	RETURN MP_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 231687_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_F(QUICSERVERTRANSPORTTEST, RECVSTOPSENDINGFRAMEAFTERCLOSESTREAM) {
  SERVER->GETNONCONSTCONN().ACKSTATES.APPDATAACKSTATE.NEXTPACKETNUM = 3;
  STD::ARRAY<STD::STRING, 4> WORDS = {
      "HEY BOB, THIS IS ALICE, FOR REAL.",
      "WHAT MESSAGE DID I SEND YOU LAST TIME?",
      "YOU DON'T SOUND LIKE ALICE",
      "YOU ARE A LIAR!",
  };

  STREAMID STREAMID = 0X00;
  AUTO STREAM = SERVER->GETNONCONSTCONN().STREAMMANAGER->GETSTREAM(STREAMID);
  STREAM->READBUFFER.EMPLACE_BACK(IOBUF::COPYBUFFER(WORDS.AT(0)), 0, FALSE);
  STREAM->READBUFFER.EMPLACE_BACK(
      IOBUF::COPYBUFFER(WORDS.AT(1)), WORDS.AT(0).LENGTH(), FALSE);
  STREAM->RETRANSMISSIONBUFFER.EMPLACE(
      STD::PIECEWISE_CONSTRUCT,
      STD::FORWARD_AS_TUPLE(0),
      STD::FORWARD_AS_TUPLE(STD::MAKE_UNIQUE<STREAMBUFFER>(
          IOBUF::COPYBUFFER(WORDS.AT(2)), 0, FALSE)));
  STREAM->WRITEBUFFER.APPEND(IOBUF::COPYBUFFER(WORDS.AT(3)));
  STREAM->CURRENTWRITEOFFSET = WORDS.AT(2).LENGTH() + WORDS.AT(3).LENGTH();
  STREAM->CURRENTREADOFFSET = WORDS.AT(0).LENGTH() + WORDS.AT(1).LENGTH();
  SERVER->GETNONCONSTCONN().FLOWCONTROLSTATE.SUMCURSTREAMBUFFERLEN = 100;

  SERVER->GETNONCONSTCONN().ACKSTATES.APPDATAACKSTATE.NEXTPACKETNUM = 5;
  SHORTHEADER HEADER(
      PROTECTIONTYPE::KEYPHASEZERO,
      *SERVER->GETCONN().SERVERCONNECTIONID,
      CLIENTNEXTAPPDATAPACKETNUM++);
  REGULARQUICPACKETBUILDER BUILDER(
      SERVER->GETCONN().UDPSENDPACKETLEN,
      STD::MOVE(HEADER),
      0 /* LARGESTACKED */);
  BUILDER.ENCODEPACKETHEADER();

  STOPSENDINGFRAME STOPSENDINGFRAME(
      STREAMID, GENERICAPPLICATIONERRORCODE::UNKNOWN);
  ASSERT_TRUE(BUILDER.CANBUILDPACKET());
  WRITEFRAME(QUICSIMPLEFRAME(STOPSENDINGFRAME), BUILDER);
  AUTO PACKET = STD::MOVE(BUILDER).BUILDPACKET();
  SERVER->RESETSTREAM(STREAMID, GENERICAPPLICATIONERRORCODE::UNKNOWN);
  EXPECT_CALL(CONNCALLBACK, ONSTOPSENDING(_, _)).TIMES(0);
  DELIVERDATA(PACKETTOBUF(PACKET));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512264_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
CMP_ITEM* CMP_ITEM_REAL::MAKE_SAME()
{
  RETURN NEW CMP_ITEM_REAL();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196841_CWE-703.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE VOID FURNACEGUI::PATTERNROW(INT I, BOOL ISPLAYING, FLOAT LINEHEIGHT, INT CHANS, INT ORD, CONST DIVPATTERN** PATCACHE) {
  STATIC CHAR ID[32];
  BOOL SELECTEDROW=(I>=SEL1.Y && I<=SEL2.Y);
  IMGUI::TABLENEXTROW(0,LINEHEIGHT);
  IMGUI::TABLENEXTCOLUMN();
  FLOAT CURSORPOSY=IMGUI::GETCURSORPOS().Y-IMGUI::GETSCROLLY();
  // CHECK IF THE ROW IS VISIBLE
  IF (CURSORPOSY<-LINEHEIGHT || CURSORPOSY>IMGUI::GETWINDOWSIZE().Y) {
    RETURN;
  }
  // CHECK IF WE ARE IN RANGE
  IF (ORD<0 || ORD>=E->SONG.ORDERSLEN) {
    RETURN;
  }
  IF (I<0 || I>=E->SONG.PATLEN) {
    RETURN;
  }
  BOOL ISPUSHING=FALSE;
  IMVEC4 ACTIVECOLOR=UICOLORS[GUI_COLOR_PATTERN_ACTIVE];
  IMVEC4 INACTIVECOLOR=UICOLORS[GUI_COLOR_PATTERN_INACTIVE];
  IMVEC4 ROWINDEXCOLOR=UICOLORS[GUI_COLOR_PATTERN_ROW_INDEX];
  IF (E->SONG.HILIGHTB>0 && !(I%E->SONG.HILIGHTB)) {
    ACTIVECOLOR=UICOLORS[GUI_COLOR_PATTERN_ACTIVE_HI2];
    INACTIVECOLOR=UICOLORS[GUI_COLOR_PATTERN_INACTIVE_HI2];
    ROWINDEXCOLOR=UICOLORS[GUI_COLOR_PATTERN_ROW_INDEX_HI2];
  } ELSE IF (E->SONG.HILIGHTA>0 && !(I%E->SONG.HILIGHTA)) {
    ACTIVECOLOR=UICOLORS[GUI_COLOR_PATTERN_ACTIVE_HI1];
    INACTIVECOLOR=UICOLORS[GUI_COLOR_PATTERN_INACTIVE_HI1];
    ROWINDEXCOLOR=UICOLORS[GUI_COLOR_PATTERN_ROW_INDEX_HI1];
  }
  // CHECK OVERFLOW HIGHLIGHT
  IF (SETTINGS.OVERFLOWHIGHLIGHT) {
    IF (EDIT && CURSOR.Y==I) {
      IMGUI::TABLESETBGCOLOR(IMGUITABLEBGTARGET_ROWBG0,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_EDITING]));
    } ELSE IF (ISPLAYING && OLDROW==I) {
      IMGUI::TABLESETBGCOLOR(IMGUITABLEBGTARGET_ROWBG0,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_PATTERN_PLAY_HEAD]));
    } ELSE IF (E->SONG.HILIGHTB>0 && !(I%E->SONG.HILIGHTB)) {
      IMGUI::TABLESETBGCOLOR(IMGUITABLEBGTARGET_ROWBG0,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_PATTERN_HI_2]));
    } ELSE IF (E->SONG.HILIGHTA>0 && !(I%E->SONG.HILIGHTA)) {
      IMGUI::TABLESETBGCOLOR(IMGUITABLEBGTARGET_ROWBG0,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_PATTERN_HI_1]));
    }
  } ELSE {
    ISPUSHING=TRUE;
    IF (EDIT && CURSOR.Y==I) {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_EDITING]));
    } ELSE IF (ISPLAYING && OLDROW==I) {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_PATTERN_PLAY_HEAD]));
    } ELSE IF (E->SONG.HILIGHTB>0 && !(I%E->SONG.HILIGHTB)) {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_PATTERN_HI_2]));
    } ELSE IF (E->SONG.HILIGHTA>0 && !(I%E->SONG.HILIGHTA)) {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,IMGUI::GETCOLORU32(UICOLORS[GUI_COLOR_PATTERN_HI_1]));
    } ELSE {
      ISPUSHING=FALSE;
    }
  }
  // ROW NUMBER
  IF (SETTINGS.PATROWSBASE==1) {
    IMGUI::TEXTCOLORED(ROWINDEXCOLOR," %.2X ",I);
  } ELSE {
    IMGUI::TEXTCOLORED(ROWINDEXCOLOR,"%3D ",I);
  }
  // FOR EACH COLUMN
  FOR (INT J=0; J<CHANS; J++) {
    // CHECK IF CHANNEL IS NOT HIDDEN
    IF (!E->SONG.CHANSHOW[J]) {
      PATCHANX[J]=IMGUI::GETCURSORPOSX();
      CONTINUE;
    }
    INT CHANVOLMAX=E->GETMAXVOLUMECHAN(J);
    IF (CHANVOLMAX<1) CHANVOLMAX=1;
    CONST DIVPATTERN* PAT=PATCACHE[J];
    IMGUI::TABLENEXTCOLUMN();
    PATCHANX[J]=IMGUI::GETCURSORPOSX();

    // SELECTION HIGHLIGHT FLAGS
    INT SEL1XSUM=SEL1.XCOARSE*32+SEL1.XFINE;
    INT SEL2XSUM=SEL2.XCOARSE*32+SEL2.XFINE;
    INT J32=J*32;
    BOOL SELECTEDNOTE=SELECTEDROW && (J32>=SEL1XSUM && J32<=SEL2XSUM);
    BOOL SELECTEDINS=SELECTEDROW && (J32+1>=SEL1XSUM && J32+1<=SEL2XSUM);
    BOOL SELECTEDVOL=SELECTEDROW && (J32+2>=SEL1XSUM && J32+2<=SEL2XSUM);
    BOOL CURSORNOTE=(CURSOR.Y==I && CURSOR.XCOARSE==J && CURSOR.XFINE==0);
    BOOL CURSORINS=(CURSOR.Y==I && CURSOR.XCOARSE==J && CURSOR.XFINE==1);
    BOOL CURSORVOL=(CURSOR.Y==I && CURSOR.XCOARSE==J && CURSOR.XFINE==2);

    // NOTE
    SPRINTF(ID,"%S##PN_%D_%D",NOTENAME(PAT->DATA[I][0],PAT->DATA[I][1]),I,J);
    IF (PAT->DATA[I][0]==0 && PAT->DATA[I][1]==0) {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,INACTIVECOLOR);
    } ELSE {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,ACTIVECOLOR);
    }
    IF (CURSORNOTE) {
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_CURSOR]);
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERACTIVE,UICOLORS[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
      IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERHOVERED,UICOLORS[GUI_COLOR_PATTERN_CURSOR_HOVER]);
      IMGUI::SELECTABLE(ID,TRUE,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,THREECHARS);
      DEMANDX=IMGUI::GETCURSORPOSX();
      IMGUI::POPSTYLECOLOR(3);
    } ELSE {
      IF (SELECTEDNOTE) IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_SELECTION]);
      IMGUI::SELECTABLE(ID,ISPUSHING || SELECTEDNOTE,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,THREECHARS);
      IF (SELECTEDNOTE) IMGUI::POPSTYLECOLOR();
    }
    IF (IMGUI::ISITEMCLICKED()) {
      STARTSELECTION(J,0,I);
    }
    IF (IMGUI::ISITEMHOVERED(IMGUIHOVEREDFLAGS_ALLOWWHENBLOCKEDBYACTIVEITEM)) {
      UPDATESELECTION(J,0,I);
    }
    IMGUI::POPSTYLECOLOR();

    // THE FOLLOWING IS ONLY VISIBLE WHEN THE CHANNEL IS NOT COLLAPSED
    IF (!E->SONG.CHANCOLLAPSE[J]) {
      // INSTRUMENT
      IF (PAT->DATA[I][2]==-1) {
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,INACTIVECOLOR);
        SPRINTF(ID,"..##PI_%D_%D",I,J);
      } ELSE {
        IF (PAT->DATA[I][2]<0 || PAT->DATA[I][2]>=E->SONG.INSLEN) {
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_INS_ERROR]);
        } ELSE {
          DIVINSTRUMENTTYPE T=E->SONG.INS[PAT->DATA[I][2]]->TYPE;
          IF (T!=DIV_INS_AMIGA && T!=E->GETPREFERINSTYPE(J)) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_INS_WARN]);
          } ELSE {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_INS]);
          }
        }
        SPRINTF(ID,"%.2X##PI_%D_%D",PAT->DATA[I][2],I,J);
      }
      IMGUI::SAMELINE(0.0F,0.0F);
      IF (CURSORINS) {
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_CURSOR]);
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERACTIVE,UICOLORS[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERHOVERED,UICOLORS[GUI_COLOR_PATTERN_CURSOR_HOVER]);
        IMGUI::SELECTABLE(ID,TRUE,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
        DEMANDX=IMGUI::GETCURSORPOSX();
        IMGUI::POPSTYLECOLOR(3);
      } ELSE {
        IF (SELECTEDINS) IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_SELECTION]);
        IMGUI::SELECTABLE(ID,ISPUSHING || SELECTEDINS,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
        IF (SELECTEDINS) IMGUI::POPSTYLECOLOR();
      }
      IF (IMGUI::ISITEMCLICKED()) {
        STARTSELECTION(J,1,I);
      }
      IF (IMGUI::ISITEMHOVERED(IMGUIHOVEREDFLAGS_ALLOWWHENBLOCKEDBYACTIVEITEM)) {
        UPDATESELECTION(J,1,I);
      }
      IMGUI::POPSTYLECOLOR();

      // VOLUME
      IF (PAT->DATA[I][3]==-1) {
        SPRINTF(ID,"..##PV_%D_%D",I,J);
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,INACTIVECOLOR);
      } ELSE {
        INT VOLCOLOR=(PAT->DATA[I][3]*127)/CHANVOLMAX;
        IF (VOLCOLOR>127) VOLCOLOR=127;
        IF (VOLCOLOR<0) VOLCOLOR=0;
        SPRINTF(ID,"%.2X##PV_%D_%D",PAT->DATA[I][3],I,J);
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,VOLCOLORS[VOLCOLOR]);
      }
      IMGUI::SAMELINE(0.0F,0.0F);
      IF (CURSORVOL) {
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_CURSOR]);
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERACTIVE,UICOLORS[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
        IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERHOVERED,UICOLORS[GUI_COLOR_PATTERN_CURSOR_HOVER]);
        IMGUI::SELECTABLE(ID,TRUE,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
        DEMANDX=IMGUI::GETCURSORPOSX();
        IMGUI::POPSTYLECOLOR(3);
      } ELSE {
        IF (SELECTEDVOL) IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_SELECTION]);
        IMGUI::SELECTABLE(ID,ISPUSHING || SELECTEDVOL,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
        IF (SELECTEDVOL) IMGUI::POPSTYLECOLOR();
      }
      IF (IMGUI::ISITEMCLICKED()) {
        STARTSELECTION(J,2,I);
      }
      IF (IMGUI::ISITEMHOVERED(IMGUIHOVEREDFLAGS_ALLOWWHENBLOCKEDBYACTIVEITEM)) {
        UPDATESELECTION(J,2,I);
      }
      IMGUI::POPSTYLECOLOR();

      // EFFECTS
      FOR (INT K=0; K<E->SONG.PAT[J].EFFECTROWS; K++) {
        INT INDEX=4+(K<<1);
        BOOL SELECTEDEFFECT=SELECTEDROW && (J32+INDEX-1>=SEL1XSUM && J32+INDEX-1<=SEL2XSUM);
        BOOL SELECTEDEFFECTVAL=SELECTEDROW && (J32+INDEX>=SEL1XSUM && J32+INDEX<=SEL2XSUM);
        BOOL CURSOREFFECT=(CURSOR.Y==I && CURSOR.XCOARSE==J && CURSOR.XFINE==INDEX-1);
        BOOL CURSOREFFECTVAL=(CURSOR.Y==I && CURSOR.XCOARSE==J && CURSOR.XFINE==INDEX);
        
        // EFFECT
        IF (PAT->DATA[I][INDEX]==-1) {
          SPRINTF(ID,"..##PE%D_%D_%D",K,I,J);
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,INACTIVECOLOR);
        } ELSE {
          SPRINTF(ID,"%.2X##PE%D_%D_%D",PAT->DATA[I][INDEX],K,I,J);
          IF (PAT->DATA[I][INDEX]<0X10) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[FXCOLORS[PAT->DATA[I][INDEX]]]);
          } ELSE IF (PAT->DATA[I][INDEX]<0X20) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);
          } ELSE IF (PAT->DATA[I][INDEX]<0X30) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);
          } ELSE IF (PAT->DATA[I][INDEX]<0X48) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);
          } ELSE IF (PAT->DATA[I][INDEX]<0X90) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_INVALID]);
          } ELSE IF (PAT->DATA[I][INDEX]<0XA0) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_MISC]);
          } ELSE IF (PAT->DATA[I][INDEX]<0XC0) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_INVALID]);
          } ELSE IF (PAT->DATA[I][INDEX]<0XD0) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_SPEED]);
          } ELSE IF (PAT->DATA[I][INDEX]<0XE0) {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[GUI_COLOR_PATTERN_EFFECT_INVALID]);
          } ELSE {
            IMGUI::PUSHSTYLECOLOR(IMGUICOL_TEXT,UICOLORS[EXTFXCOLORS[PAT->DATA[I][INDEX]-0XE0]]);
          }
        }
        IMGUI::SAMELINE(0.0F,0.0F);
        IF (CURSOREFFECT) {
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_CURSOR]);  
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERACTIVE,UICOLORS[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERHOVERED,UICOLORS[GUI_COLOR_PATTERN_CURSOR_HOVER]);
          IMGUI::SELECTABLE(ID,TRUE,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
          DEMANDX=IMGUI::GETCURSORPOSX();
          IMGUI::POPSTYLECOLOR(3);
        } ELSE {
          IF (SELECTEDEFFECT) IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_SELECTION]);
          IMGUI::SELECTABLE(ID,ISPUSHING || SELECTEDEFFECT,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
          IF (SELECTEDEFFECT) IMGUI::POPSTYLECOLOR();
        }
        IF (IMGUI::ISITEMCLICKED()) {
          STARTSELECTION(J,INDEX-1,I);
        }
        IF (IMGUI::ISITEMHOVERED(IMGUIHOVEREDFLAGS_ALLOWWHENBLOCKEDBYACTIVEITEM)) {
          UPDATESELECTION(J,INDEX-1,I);
        }

        // EFFECT VALUE
        IF (PAT->DATA[I][INDEX+1]==-1) {
          SPRINTF(ID,"..##PF%D_%D_%D",K,I,J);
        } ELSE {
          SPRINTF(ID,"%.2X##PF%D_%D_%D",PAT->DATA[I][INDEX+1],K,I,J);
        }
        IMGUI::SAMELINE(0.0F,0.0F);
        IF (CURSOREFFECTVAL) {
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_CURSOR]);  
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERACTIVE,UICOLORS[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);
          IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADERHOVERED,UICOLORS[GUI_COLOR_PATTERN_CURSOR_HOVER]);
          IMGUI::SELECTABLE(ID,TRUE,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
          DEMANDX=IMGUI::GETCURSORPOSX();
          IMGUI::POPSTYLECOLOR(3);
        } ELSE {
          IF (SELECTEDEFFECTVAL) IMGUI::PUSHSTYLECOLOR(IMGUICOL_HEADER,UICOLORS[GUI_COLOR_PATTERN_SELECTION]);
          IMGUI::SELECTABLE(ID,ISPUSHING || SELECTEDEFFECTVAL,IMGUISELECTABLEFLAGS_NOPADWITHHALFSPACING,TWOCHARS);
          IF (SELECTEDEFFECTVAL) IMGUI::POPSTYLECOLOR();
        }
        IF (IMGUI::ISITEMCLICKED()) {
          STARTSELECTION(J,INDEX,I);
        }
        IF (IMGUI::ISITEMHOVERED(IMGUIHOVEREDFLAGS_ALLOWWHENBLOCKEDBYACTIVEITEM)) {
          UPDATESELECTION(J,INDEX,I);
        }
        IMGUI::POPSTYLECOLOR();
      }
    }
  }
  IF (ISPUSHING) {
    IMGUI::POPSTYLECOLOR();
  }
  IMGUI::TABLENEXTCOLUMN();
  PATCHANX[CHANS]=IMGUI::GETCURSORPOSX();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 90171_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL VOID REFRESHCELLULARDATAPLANS(CONST CELLULARNETWORK* NETWORK) {}

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 386533_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
DL_WRITERA* DL_DXF::OUT(CONST CHAR* FILE, DL_CODES::VERSION VERSION) {
    CHAR* F = NEW CHAR[STRLEN(FILE)+1];
    STRCPY(F, FILE);
    THIS->VERSION = VERSION;

    DL_WRITERA* DW = NEW DL_WRITERA(F, VERSION);
    IF (DW->OPENFAILED()) {
        DELETE DW;
        DELETE[] F;
        RETURN NULL;
    } ELSE {
        DELETE[] F;
        RETURN DW;
    }
}
ASSISTANT
CWE-78: IMPROPER NEUTRALIZATION OF SPECIAL ELEMENTS USED IN AN OS COMMAND ('OS COMMAND INJECTION')
--------------------------------------------------
File: 386597_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DL_DXF::WRITECONTROLPOINT(DL_WRITERA& DW,
                               CONST DL_CONTROLPOINTDATA& DATA) {

    DW.DXFREAL(10, DATA.X);
    DW.DXFREAL(20, DATA.Y);
    DW.DXFREAL(30, DATA.Z);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 216903_CWE-476.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ST_SELECT_LEX::OPTIMIZE_UNFLATTENED_SUBQUERIES(BOOL CONST_ONLY)
{
  SELECT_LEX_UNIT *NEXT_UNIT= NULL;
  FOR (SELECT_LEX_UNIT *UN= FIRST_INNER_UNIT();
       UN;
       UN= NEXT_UNIT ? NEXT_UNIT : UN->NEXT_UNIT())
  {
    ITEM_SUBSELECT *SUBQUERY_PREDICATE= UN->ITEM;
    NEXT_UNIT= NULL;

    IF (SUBQUERY_PREDICATE)
    {
      IF (!SUBQUERY_PREDICATE->FIXED)
      {
	/*
	 THIS SUBQUERY WAS EXCLUDED AS PART OF SOME EXPRESSION SO IT IS
	 INVISIBLE FROM ALL PREPARED EXPRESSION.
       */
	NEXT_UNIT= UN->NEXT_UNIT();
	UN->EXCLUDE_LEVEL();
	IF (NEXT_UNIT)
	  CONTINUE;
	BREAK;
      }
      IF (SUBQUERY_PREDICATE->SUBSTYPE() == ITEM_SUBSELECT::IN_SUBS)
      {
        ITEM_IN_SUBSELECT *IN_SUBS= (ITEM_IN_SUBSELECT*) SUBQUERY_PREDICATE;
        IF (IN_SUBS->IS_JTBM_MERGED)
          CONTINUE;
      }

      IF (CONST_ONLY && !SUBQUERY_PREDICATE->CONST_ITEM())
      {
        /* SKIP NON-CONSTANT SUBQUERIES IF THE CALLER ASKED SO. */
        CONTINUE;
      }

      BOOL EMPTY_UNION_RESULT= TRUE;
      BOOL IS_CORRELATED_UNIT= FALSE;
      BOOL FIRST= TRUE;
      BOOL UNION_PLAN_SAVED= FALSE;
      /*
        IF THE SUBQUERY IS A UNION, OPTIMIZE ALL THE SUBQUERIES IN THE UNION. IF
        THERE IS NO UNION, THEN THE LOOP WILL EXECUTE ONCE FOR THE SUBQUERY.
      */
      FOR (SELECT_LEX *SL= UN->FIRST_SELECT(); SL; SL= SL->NEXT_SELECT())
      {
        JOIN *INNER_JOIN= SL->JOIN;
        IF (FIRST)
          FIRST= FALSE;
        ELSE
        {
          IF (!UNION_PLAN_SAVED)
          {
            UNION_PLAN_SAVED= TRUE;
            IF (UN->SAVE_UNION_EXPLAIN(UN->THD->LEX->EXPLAIN))
              RETURN TRUE; /* FAILURE */
          }
        }
        IF (!INNER_JOIN)
          CONTINUE;
        SELECT_LEX *SAVE_SELECT= UN->THD->LEX->CURRENT_SELECT;
        ULONGLONG SAVE_OPTIONS;
        INT RES;
        /* WE NEED ONLY 1 ROW TO DETERMINE EXISTENCE */
        UN->SET_LIMIT(UN->GLOBAL_PARAMETERS());
        UN->THD->LEX->CURRENT_SELECT= SL;
        SAVE_OPTIONS= INNER_JOIN->SELECT_OPTIONS;
        IF (OPTIONS & SELECT_DESCRIBE)
        {
          /* OPTIMIZE THE SUBQUERY IN THE CONTEXT OF EXPLAIN. */
          SL->SET_EXPLAIN_TYPE(FALSE);
          SL->OPTIONS|= SELECT_DESCRIBE;
          INNER_JOIN->SELECT_OPTIONS|= SELECT_DESCRIBE;
        }
        IF ((RES= INNER_JOIN->OPTIMIZE()))
          RETURN TRUE;
        IF (!INNER_JOIN->CLEANED)
          SL->UPDATE_USED_TABLES();
        SL->UPDATE_CORRELATED_CACHE();
        IS_CORRELATED_UNIT|= SL->IS_CORRELATED;
        INNER_JOIN->SELECT_OPTIONS= SAVE_OPTIONS;
        UN->THD->LEX->CURRENT_SELECT= SAVE_SELECT;

        EXPLAIN_QUERY *EQ;
        IF ((EQ= INNER_JOIN->THD->LEX->EXPLAIN))
        {
          EXPLAIN_SELECT *EXPL_SEL;
          IF ((EXPL_SEL= EQ->GET_SELECT(INNER_JOIN->SELECT_LEX->SELECT_NUMBER)))
          {
            SL->SET_EXPLAIN_TYPE(TRUE);
            EXPL_SEL->SELECT_TYPE= SL->TYPE;
          }
        }

        IF (EMPTY_UNION_RESULT)
        {
          /*
            IF AT LEAST ONE SUBQUERY IN A UNION IS NON-EMPTY, THE UNION RESULT
            IS NON-EMPTY. IF THERE IS NO UNION, THE ONLY SUBQUERY IS NON-EMPY.
          */
          EMPTY_UNION_RESULT= INNER_JOIN->EMPTY_RESULT();
        }
        IF (RES)
          RETURN TRUE;
      }
      IF (EMPTY_UNION_RESULT)
        SUBQUERY_PREDICATE->NO_ROWS_IN_RESULT();
      IF (!IS_CORRELATED_UNIT)
        UN->UNCACHEABLE&= ~UNCACHEABLE_DEPENDENT;
      SUBQUERY_PREDICATE->IS_CORRELATED= IS_CORRELATED_UNIT;
    }
  }
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 488386_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT ARCH_SETUP_ADDITIONAL_PAGES(STRUCT LINUX_BINPRM *BPRM,
				INT EXECUTABLE_STACK)
{
	STRUCT MM_STRUCT *MM = CURRENT->MM;
	STRUCT PAGE **VDSO_PAGELIST;
	UNSIGNED LONG VDSO_PAGES;
	UNSIGNED LONG VDSO_BASE;
	INT RC;

	IF (!VDSO_READY)
		RETURN 0;

#IFDEF CONFIG_PPC64
	IF (TEST_THREAD_FLAG(TIF_32BIT)) {
		VDSO_PAGELIST = VDSO32_PAGELIST;
		VDSO_PAGES = VDSO32_PAGES;
		VDSO_BASE = VDSO32_MBASE;
	} ELSE {
		VDSO_PAGELIST = VDSO64_PAGELIST;
		VDSO_PAGES = VDSO64_PAGES;
		VDSO_BASE = VDSO64_MBASE;
	}
#ELSE
	VDSO_PAGELIST = VDSO32_PAGELIST;
	VDSO_PAGES = VDSO32_PAGES;
	VDSO_BASE = VDSO32_MBASE;
#ENDIF

	CURRENT->MM->CONTEXT.VDSO_BASE = 0;

	/* VDSO HAS A PROBLEM AND WAS DISABLED, JUST DON'T "ENABLE" IT FOR THE
	 * PROCESS
	 */
	IF (VDSO_PAGES == 0)
		RETURN 0;
	/* ADD A PAGE TO THE VDSO SIZE FOR THE DATA PAGE */
	VDSO_PAGES ++;

	/*
	 * PICK A BASE ADDRESS FOR THE VDSO IN PROCESS SPACE. WE TRY TO PUT IT
	 * AT VDSO_BASE WHICH IS THE "NATURAL" BASE FOR IT, BUT WE MIGHT FAIL
	 * AND END UP PUTTING IT ELSEWHERE.
	 */
	DOWN_WRITE(&MM->MMAP_SEM);
	VDSO_BASE = GET_UNMAPPED_AREA(NULL, VDSO_BASE,
				      VDSO_PAGES << PAGE_SHIFT, 0, 0);
	IF (IS_ERR_VALUE(VDSO_BASE)) {
		RC = VDSO_BASE;
		GOTO FAIL_MMAPSEM;
	}

	/*
	 * OUR VMA FLAGS DON'T HAVE VM_WRITE SO BY DEFAULT, THE PROCESS ISN'T
	 * ALLOWED TO WRITE THOSE PAGES.
	 * GDB CAN BREAK THAT WITH PTRACE INTERFACE, AND THUS TRIGGER COW ON
	 * THOSE PAGES BUT IT'S THEN YOUR RESPONSIBILITY TO NEVER DO THAT ON
	 * THE "DATA" PAGE OF THE VDSO OR YOU'LL STOP GETTING KERNEL UPDATES
	 * AND YOUR NICE USERLAND GETTIMEOFDAY WILL BE TOTALLY DEAD.
	 * IT'S FINE TO USE THAT FOR SETTING BREAKPOINTS IN THE VDSO CODE
	 * PAGES THOUGH
	 *
	 * MAKE SURE THE VDSO GETS INTO EVERY CORE DUMP.
	 * DUMPING ITS CONTENTS MAKES POST-MORTEM FULLY INTERPRETABLE LATER
	 * WITHOUT MATCHING UP THE SAME KERNEL AND HARDWARE CONFIG TO SEE
	 * WHAT PC VALUES MEANT.
	 */
	RC = INSTALL_SPECIAL_MAPPING(MM, VDSO_BASE, VDSO_PAGES << PAGE_SHIFT,
				     VM_READ|VM_EXEC|
				     VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC|
				     VM_ALWAYSDUMP,
				     VDSO_PAGELIST);
	IF (RC)
		GOTO FAIL_MMAPSEM;

	/* PUT VDSO BASE INTO MM STRUCT */
	CURRENT->MM->CONTEXT.VDSO_BASE = VDSO_BASE;

	UP_WRITE(&MM->MMAP_SEM);
	RETURN 0;

 FAIL_MMAPSEM:
	UP_WRITE(&MM->MMAP_SEM);
	RETURN RC;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338203_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NAME WASMBINARYBUILDER::GETTABLENAME(INDEX INDEX) {
  IF (INDEX >= WASM.TABLES.SIZE()) {
    THROWERROR("INVALID TABLE INDEX");
  }
  RETURN WASM.TABLES[INDEX]->NAME;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195742_CWE-476.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC GF_ERR GF_ISOM_PARSE_MOVIE_BOXES_INTERNAL(GF_ISOFILE *MOV, U32 *BOXTYPE, U64 *BYTESMISSING, BOOL PROGRESSIVE_MODE)
{
	GF_BOX *A;
	U64 TOTSIZE, MDAT_END=0;
	GF_ERR E = GF_OK;

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
	IF (MOV->SINGLE_MOOF_MODE && MOV->SINGLE_MOOF_STATE == 2) {
		RETURN E;
	}

	/*RESTART FROM WHERE WE STOPPED LAST*/
	TOTSIZE = MOV->CURRENT_TOP_BOX_START;
	IF (MOV->BYTES_REMOVED) {
		ASSERT(TOTSIZE >= MOV->BYTES_REMOVED);
		TOTSIZE -= MOV->BYTES_REMOVED;
	}
	GF_BS_SEEK(MOV->MOVIEFILEMAP->BS, TOTSIZE);
#ENDIF


	/*WHILE WE HAVE SOME DATA, PARSE OUR BOXES*/
	WHILE (GF_BS_AVAILABLE(MOV->MOVIEFILEMAP->BS)) {
		*BYTESMISSING = 0;
#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		MOV->CURRENT_TOP_BOX_START = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS) + MOV->BYTES_REMOVED;
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, ("[ISO FILE] PARSING A TOP-LEVEL BOX AT POSITION %D\N", MOV->CURRENT_TOP_BOX_START));
#ENDIF

		E = GF_ISOM_PARSE_ROOT_BOX(&A, MOV->MOVIEFILEMAP->BS, BOXTYPE, BYTESMISSING, PROGRESSIVE_MODE);

		IF (E >= 0) {

		} ELSE IF (E == GF_ISOM_INCOMPLETE_FILE) {
			/*OUR MDAT IS UNCOMPLETE, ONLY VALID FOR READ ONLY FILES...*/
			IF (MOV->OPENMODE != GF_ISOM_OPEN_READ) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] INCOMPLETE MDAT WHILE FILE IS NOT READ-ONLY\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}
			IF ((MOV->OPENMODE == GF_ISOM_OPEN_READ) && !PROGRESSIVE_MODE) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] INCOMPLETE FILE WHILE READING FOR DUMP - ABORTING PARSING\N"));
				BREAK;
			}
			RETURN E;
		} ELSE {
			RETURN E;
		}

		SWITCH (A->TYPE) {
		/*MOOV BOX*/
		CASE GF_ISOM_BOX_TYPE_MOOV:
			IF (MOV->MOOV) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE MOOV DETECTED!\N"));
				GF_ISOM_BOX_DEL(A);
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->MOOV = (GF_MOVIEBOX *)A;
			MOV->ORIGINAL_MOOV_OFFSET = MOV->CURRENT_TOP_BOX_START;
			/*SET OUR POINTER TO THE MOVIE*/
			MOV->MOOV->MOV = MOV;
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
			IF (MOV->MOOV->MVEX) MOV->MOOV->MVEX->MOV = MOV;

#IFDEF GF_ENABLE_CTRN
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				GF_ISOM_SETUP_TRAF_INHERITANCE(MOV);
			}
#ENDIF

#ENDIF
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;

			TOTSIZE += A->SIZE;

            IF (!MOV->MOOV->MVHD) {
                GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] MISSING MOVIEHEADERBOX\N"));
                RETURN GF_ISOM_INVALID_FILE;
            }

            IF (MOV->META) {
				GF_ISOM_META_RESTORE_ITEMS_REF(MOV, MOV->META);
			}

			//DUMP SENC INFO IN DUMP MODE
			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				U32 K;
				FOR (K=0; K<GF_LIST_COUNT(MOV->MOOV->TRACKLIST); K++) {
					GF_TRACKBOX *TRAK = (GF_TRACKBOX *)GF_LIST_GET(MOV->MOOV->TRACKLIST, K);

					IF (TRAK->SAMPLE_ENCRYPTION) {
						E = SENC_PARSE(MOV->MOVIEFILEMAP->BS, TRAK, NULL, TRAK->SAMPLE_ENCRYPTION);
						IF (E) RETURN E;
					}
				}
			} ELSE {
				U32 K;
				FOR (K=0; K<GF_LIST_COUNT(MOV->MOOV->TRACKLIST); K++) {
					GF_TRACKBOX *TRAK = (GF_TRACKBOX *)GF_LIST_GET(MOV->MOOV->TRACKLIST, K);
					IF (TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEGROUPS) {
						CONVERT_COMPACT_SAMPLE_GROUPS(TRAK->MEDIA->INFORMATION->SAMPLETABLE->CHILD_BOXES, TRAK->MEDIA->INFORMATION->SAMPLETABLE->SAMPLEGROUPS);
					}
				}
			}

            IF (MDAT_END && MOV->SIGNAL_FRAG_BOUNDS && !(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) ) {
                GF_ISOM_PUSH_MDAT_END(MOV, MDAT_END);
                MDAT_END=0;
            }
			BREAK;

		/*META BOX*/
		CASE GF_ISOM_BOX_TYPE_META:
			IF (MOV->META) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE META DETECTED!\N"));
				GF_ISOM_BOX_DEL(A);
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->META = (GF_METABOX *)A;
			MOV->ORIGINAL_META_OFFSET = MOV->CURRENT_TOP_BOX_START;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) {
				RETURN E;
			}
			TOTSIZE += A->SIZE;
			GF_ISOM_META_RESTORE_ITEMS_REF(MOV, MOV->META);
			BREAK;

		/*WE ONLY KEEP THE MDAT IN READ FOR DUMP PURPOSES*/
		CASE GF_ISOM_BOX_TYPE_MDAT:
			IF (!MOV->FIRST_DATA_TOPLEVEL_OFFSET) {
				MOV->FIRST_DATA_TOPLEVEL_OFFSET = MOV->CURRENT_TOP_BOX_START;
				MOV->FIRST_DATA_TOPLEVEL_SIZE = A->SIZE;
			}
			TOTSIZE += A->SIZE;

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
			IF (MOV->EMSGS) {
				GF_ISOM_BOX_ARRAY_DEL(MOV->EMSGS);
				MOV->EMSGS = NULL;
			}
#ENDIF

			IF (MOV->OPENMODE == GF_ISOM_OPEN_READ) {
				IF (!MOV->MDAT) {
					MOV->MDAT = (GF_MEDIADATABOX *) A;
					E = GF_LIST_ADD(MOV->TOPBOXES, MOV->MDAT);
					IF (E) {
						RETURN E;
					}
				}
#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
				ELSE IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) GF_LIST_ADD(MOV->TOPBOXES, A);
#ENDIF
				ELSE GF_ISOM_BOX_DEL(A); //IN OTHER MODES WE DON'T CARE


				IF (MOV->SIGNAL_FRAG_BOUNDS && !(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) ) {
                    MDAT_END = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS);
                    IF (MOV->MOOV) {
                        GF_ISOM_PUSH_MDAT_END(MOV, MDAT_END);
                        MDAT_END=0;
                    }
				}
			}
			/*IF WE DON'T HAVE ANY MDAT YET, CREATE ONE (EDIT-WRITE MODE)
			WE ONLY WORK WITH ONE MDAT, BUT WE'RE PUTING IT AT THE PLACE
			OF THE FIRST MDAT FOUND WHEN OPENING A FILE FOR EDITING*/
			ELSE IF (!MOV->MDAT && (MOV->OPENMODE != GF_ISOM_OPEN_READ) && (MOV->OPENMODE != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {
				GF_ISOM_BOX_DEL(A);
				MOV->MDAT = (GF_MEDIADATABOX *) GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_MDAT);
				IF (!MOV->MDAT) RETURN GF_OUT_OF_MEM;
				E = GF_LIST_ADD(MOV->TOPBOXES, MOV->MDAT);
				IF (E) {
					RETURN E;
				}
			} ELSE {
				GF_ISOM_BOX_DEL(A);
			}
			BREAK;
		CASE GF_ISOM_BOX_TYPE_FTYP:
			/*ONE AND ONLY ONE FTYP*/
			IF (MOV->BRAND) {
				GF_ISOM_BOX_DEL(A);
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE 'FTYP' DETECTED!\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->BRAND = (GF_FILETYPEBOX *)A;
			TOTSIZE += A->SIZE;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;
			BREAK;

		CASE GF_ISOM_BOX_TYPE_OTYP:
			/*ONE AND ONLY ONE FTYP*/
			IF (MOV->OTYP) {
				GF_ISOM_BOX_DEL(A);
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE 'OTYP' DETECTED!\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}

			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				MOV->OTYP = (GF_BOX *)A;
				TOTSIZE += A->SIZE;
				E = GF_LIST_ADD(MOV->TOPBOXES, A);
				IF (E) RETURN E;
			} ELSE {
				GF_FILETYPEBOX *BRAND = (GF_FILETYPEBOX *) GF_ISOM_BOX_FIND_CHILD(A->CHILD_BOXES, GF_ISOM_BOX_TYPE_FTYP);
				IF (BRAND) {
					S32 POS;
					GF_LIST_DEL_ITEM(A->CHILD_BOXES, BRAND);
					POS = GF_LIST_DEL_ITEM(MOV->TOPBOXES, MOV->BRAND);
					GF_ISOM_BOX_DEL((GF_BOX *) MOV->BRAND);
					MOV->BRAND = BRAND;
					IF (POS<0) POS=0;
					GF_LIST_INSERT(MOV->TOPBOXES, BRAND, POS);
				}
				GF_ISOM_BOX_DEL(A);
			}
			BREAK;

		CASE GF_ISOM_BOX_TYPE_PDIN:
			/*ONE AND ONLY ONE PDIN*/
			IF (MOV->PDIN) {
				GF_ISOM_BOX_DEL(A);
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] DUPLICATE 'PDIN'' DETECTED!\N"));
				RETURN GF_ISOM_INVALID_FILE;
			}
			MOV->PDIN = (GF_PROGRESSIVEDOWNLOADBOX *) A;
			TOTSIZE += A->SIZE;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;
			BREAK;


#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		CASE GF_ISOM_BOX_TYPE_STYP:
		{
			U32 BRAND = ((GF_FILETYPEBOX *)A)->MAJORBRAND;
			SWITCH (BRAND) {
			CASE GF_ISOM_BRAND_SISX:
			CASE GF_ISOM_BRAND_RISX:
			CASE GF_ISOM_BRAND_SSSS:
				MOV->IS_INDEX_SEGMENT = GF_TRUE;
				BREAK;
			DEFAULT:
				BREAK;
			}
		}
		/*FALL-THROUGH*/

		CASE GF_ISOM_BOX_TYPE_SIDX:
		CASE GF_ISOM_BOX_TYPE_SSIX:
			IF (MOV->MOOV && !MOV->FIRST_DATA_TOPLEVEL_OFFSET) {
				MOV->FIRST_DATA_TOPLEVEL_OFFSET = MOV->CURRENT_TOP_BOX_START;
				MOV->FIRST_DATA_TOPLEVEL_SIZE = A->SIZE;
			}
			TOTSIZE += A->SIZE;
			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				E = GF_LIST_ADD(MOV->TOPBOXES, A);
				IF (E) RETURN E;
			} ELSE IF (MOV->SIGNAL_FRAG_BOUNDS && !(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)  && (MOV->OPENMODE!=GF_ISOM_OPEN_KEEP_FRAGMENTS)
			) {
				IF (A->TYPE==GF_ISOM_BOX_TYPE_SIDX) {
					IF (MOV->ROOT_SIDX) GF_ISOM_BOX_DEL( (GF_BOX *) MOV->ROOT_SIDX);
					MOV->ROOT_SIDX = (GF_SEGMENTINDEXBOX *) A;
					MOV->SIDX_START_OFFSET = MOV->CURRENT_TOP_BOX_START;
					MOV->SIDX_END_OFFSET = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS);

				}
				ELSE IF (A->TYPE==GF_ISOM_BOX_TYPE_STYP) {
					MOV->STYP_START_OFFSET = MOV->CURRENT_TOP_BOX_START;

					IF (MOV->SEG_STYP) GF_ISOM_BOX_DEL(MOV->SEG_STYP);
					MOV->SEG_STYP = A;
				} ELSE IF (A->TYPE==GF_ISOM_BOX_TYPE_SSIX) {
					IF (MOV->SEG_SSIX) GF_ISOM_BOX_DEL(MOV->SEG_SSIX);
					MOV->SEG_SSIX = A;
				} ELSE {
					GF_ISOM_BOX_DEL(A);
				}
				GF_ISOM_PUSH_MDAT_END(MOV, MOV->CURRENT_TOP_BOX_START);
			} ELSE IF (!MOV->NEXTMOOFNUMBER && (A->TYPE==GF_ISOM_BOX_TYPE_SIDX)) {
				IF (MOV->MAIN_SIDX) GF_ISOM_BOX_DEL( (GF_BOX *) MOV->MAIN_SIDX);
				MOV->MAIN_SIDX = (GF_SEGMENTINDEXBOX *) A;
				MOV->MAIN_SIDX_END_POS = MOV->CURRENT_TOP_BOX_START + A->SIZE;
			} ELSE {
				GF_ISOM_BOX_DEL(A);
			}
			BREAK;

		CASE GF_ISOM_BOX_TYPE_MOOF:
			//NO SUPPORT FOR INPLACE REWRITE FOR FRAGMENTED FILES
			GF_ISOM_DISABLE_INPLACE_REWRITE(MOV);
			IF (!MOV->MOOV) {
				GF_LOG(MOV->MOOF ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, ("[ISO FILE] MOVIE FRAGMENT BUT NO MOOV (YET) - POSSIBLY BROKEN PARSING!\N"));
			}
			IF (MOV->SINGLE_MOOF_MODE) {
				MOV->SINGLE_MOOF_STATE++;
				IF (MOV->SINGLE_MOOF_STATE > 1) {
					GF_ISOM_BOX_DEL(A);
					RETURN GF_OK;
				}
			}
			((GF_MOVIEFRAGMENTBOX *)A)->MOV = MOV;

			TOTSIZE += A->SIZE;
			MOV->MOOF = (GF_MOVIEFRAGMENTBOX *) A;

			/*SOME SMOOTH STREAMING STREAMS CONTAIN A SDTP UNDER THE TRAF: THIS IS INCORRECT, CONVERT IT*/
			FIXTRACKID(MOV);
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				FIXSDTPINTRAF(MOV->MOOF);
			} ELSE {
				U32 K;
				FOR (K=0; K<GF_LIST_COUNT(MOV->MOOF->TRACKLIST); K++) {
					GF_TRACKFRAGMENTBOX *TRAF = (GF_TRACKFRAGMENTBOX *)GF_LIST_GET(MOV->MOOF->TRACKLIST, K);
					IF (TRAF->SAMPLEGROUPS) {
						CONVERT_COMPACT_SAMPLE_GROUPS(TRAF->CHILD_BOXES, TRAF->SAMPLEGROUPS);
					}
				}
			}

			/*READ & DEBUG: STORE AT ROOT LEVEL*/
			IF (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG) {
				U32 K;
				GF_LIST_ADD(MOV->TOPBOXES, A);
				/*ALSO UPDATE POINTERS TO TREX FOR DEBUG*/
				IF (MOV->MOOV) {
					FOR (K=0; K<GF_LIST_COUNT(MOV->MOOF->TRACKLIST); K++) {
						GF_TRACKFRAGMENTBOX *TRAF = GF_LIST_GET(MOV->MOOF->TRACKLIST, K);
						IF (TRAF->TFHD && MOV->MOOV->MVEX && MOV->MOOV->MVEX->TRACKEXLIST) {
							GF_TRACKBOX *TRAK = GF_ISOM_GET_TRACK_FROM_ID(MOV->MOOV, TRAF->TFHD->TRACKID);
							U32 J=0;
							WHILE ((TRAF->TREX = (GF_TRACKEXTENDSBOX*)GF_LIST_ENUM(MOV->MOOV->MVEX->TRACKEXLIST, &J))) {
								IF (TRAF->TREX->TRACKID == TRAF->TFHD->TRACKID) {
									IF (!TRAF->TREX->TRACK) TRAF->TREX->TRACK = TRAK;
									BREAK;
								}
								TRAF->TREX = NULL;
							}
						}
						//WE SHOULD ONLY PARSE SENC/PSEC WHEN NO SAIZ/SAIO IS PRESENT, OTHERWISE WE FETCH THE INFO DIRECTLY
						IF (TRAF->TREX && TRAF->TFHD && TRAF->TREX->TRACK && TRAF->SAMPLE_ENCRYPTION) {
							GF_TRACKBOX *TRAK = GETTRACKBYID(MOV->MOOV, TRAF->TFHD->TRACKID);
							IF (TRAK) {
								TRAK->CURRENT_TRAF_STSD_IDX = TRAF->TFHD->SAMPLE_DESC_INDEX ? TRAF->TFHD->SAMPLE_DESC_INDEX : TRAF->TREX->DEF_SAMPLE_DESC_INDEX;
								E = SENC_PARSE(MOV->MOVIEFILEMAP->BS, TRAK, TRAF, TRAF->SAMPLE_ENCRYPTION);
								IF (E) RETURN E;
								TRAK->CURRENT_TRAF_STSD_IDX = 0;
							}
						}
					}
				} ELSE {
					FOR (K=0; K<GF_LIST_COUNT(MOV->MOOF->TRACKLIST); K++) {
						GF_TRACKFRAGMENTBOX *TRAF = GF_LIST_GET(MOV->MOOF->TRACKLIST, K);
						IF (TRAF->SAMPLE_ENCRYPTION) {
							E = SENC_PARSE(MOV->MOVIEFILEMAP->BS, NULL, TRAF, TRAF->SAMPLE_ENCRYPTION);
							IF (E) RETURN E;
						}
					}

				}
			} ELSE IF (MOV->OPENMODE==GF_ISOM_OPEN_KEEP_FRAGMENTS) {
				MOV->NEXTMOOFNUMBER = MOV->MOOF->MFHD->SEQUENCE_NUMBER+1;
				MOV->MOOF = NULL;
				GF_ISOM_BOX_DEL(A);
			} ELSE {
				/*MERGE ALL INFO*/
				E = MERGEFRAGMENT((GF_MOVIEFRAGMENTBOX *)A, MOV);
				GF_ISOM_BOX_DEL(A);
				IF (E) RETURN E;
			}

			//DONE WITH MOOV
			IF (MOV->ROOT_SIDX) {
				GF_ISOM_BOX_DEL((GF_BOX *) MOV->ROOT_SIDX);
				MOV->ROOT_SIDX = NULL;
			}
			IF (MOV->ROOT_SSIX) {
				GF_ISOM_BOX_DEL(MOV->SEG_SSIX);
				MOV->ROOT_SSIX = NULL;
			}
			IF (MOV->SEG_STYP) {
				GF_ISOM_BOX_DEL(MOV->SEG_STYP);
				MOV->SEG_STYP = NULL;
			}
			MOV->SIDX_START_OFFSET = 0;
			MOV->SIDX_END_OFFSET = 0;
			MOV->STYP_START_OFFSET = 0;
			BREAK;
#ENDIF
		CASE GF_ISOM_BOX_TYPE_UNKNOWN:
		{
			GF_UNKNOWNBOX *BOX = (GF_UNKNOWNBOX*)A;
			IF (BOX->ORIGINAL_4CC == GF_ISOM_BOX_TYPE_JP) {
				U8 *C = (U8 *) BOX->DATA;
				IF ((BOX->DATASIZE==4) && (GF_4CC(C[0],C[1],C[2],C[3])==(U32)0X0D0A870A))
					MOV->IS_JP2 = 1;
				GF_ISOM_BOX_DEL(A);
			} ELSE {
				E = GF_LIST_ADD(MOV->TOPBOXES, A);
				IF (E) RETURN E;
			}
		}
		BREAK;

		CASE GF_ISOM_BOX_TYPE_PRFT:
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
			IF (!(MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				//KEEP THE LAST ONE READ
				IF (MOV->LAST_PRODUCER_REF_TIME)
					GF_ISOM_BOX_DEL(A);
				ELSE
					MOV->LAST_PRODUCER_REF_TIME = (GF_PRODUCERREFERENCETIMEBOX *)A;
				BREAK;
			}
#ENDIF
		//FALLTHROUGH
		CASE GF_ISOM_BOX_TYPE_EMSG:
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				IF (!MOV->EMSGS) MOV->EMSGS = GF_LIST_NEW();
				GF_LIST_ADD(MOV->EMSGS, A);
				BREAK;
			}
#ENDIF
		CASE GF_ISOM_BOX_TYPE_MFRA:
		CASE GF_ISOM_BOX_TYPE_MFRO:
			//ONLY KEEP FOR DUMP MODE, OTHERWISE WE IGNORE THESE BOXES AND WE DON'T WANT TO CARRY THEM OVER IN NON-FRAGMENTED FILE
			IF (! (MOV->FRAGMENTSFLAGS & GF_ISOM_FRAG_READ_DEBUG)) {
				TOTSIZE += A->SIZE;
				GF_ISOM_BOX_DEL(A);
				BREAK;
			}
		DEFAULT:
			TOTSIZE += A->SIZE;
			E = GF_LIST_ADD(MOV->TOPBOXES, A);
			IF (E) RETURN E;
			BREAK;
		}

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		/*REMEMBER WHERE WE LEFT, IN CASE WE APPEND AN ENTIRE NUMBER OF MOVIE FRAGMENTS*/
		MOV->CURRENT_TOP_BOX_START = GF_BS_GET_POSITION(MOV->MOVIEFILEMAP->BS) + MOV->BYTES_REMOVED;
#ENDIF
	}

	/*WE NEED AT LEAST MOOV OR META*/
	IF (!MOV->MOOV && !MOV->META
#IFNDEF GPAC_DISABLE_ISOM_FRAGMENTS
	        && !MOV->MOOF && !MOV->IS_INDEX_SEGMENT
#ENDIF
	   ) {
		RETURN GF_ISOM_INCOMPLETE_FILE;
	}
	/*WE MUST HAVE MOVIE HEADER*/
	IF (!GF_OPTS_GET_BOOL("CORE", "NO-CHECK")) {
		IF (MOV->MOOV && !MOV->MOOV->MVHD) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] MISSING MVHD IN MOOV!\N"));
			RETURN GF_ISOM_INVALID_FILE;
		}

		/*WE MUST HAVE META HANDLER*/
		IF (MOV->META && !MOV->META->HANDLER) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISO FILE] MISSING HANDLER IN META!\N"));
			RETURN GF_ISOM_INVALID_FILE;
		}
	}

#IFNDEF GPAC_DISABLE_ISOM_WRITE

	IF (MOV->MOOV) {
		/*SET THE DEFAULT INTERLEAVING TIME*/
		MOV->INTERLEAVINGTIME = MOV->MOOV->MVHD->TIMESCALE;

#IFNDEF	GPAC_DISABLE_ISOM_FRAGMENTS
		/*IN EDIT MODE WITH SUCCESSFULLY LOADED FRAGMENTS, DELETE ALL FRAGMENT SIGNALING SINCE
		FILE IS NO LONGER FRAGMENTED*/
		IF ((MOV->OPENMODE > GF_ISOM_OPEN_READ) && (MOV->OPENMODE != GF_ISOM_OPEN_KEEP_FRAGMENTS) && MOV->MOOV->MVEX) {
			GF_ISOM_BOX_DEL_PARENT(&MOV->MOOV->CHILD_BOXES, (GF_BOX *)MOV->MOOV->MVEX);
			MOV->MOOV->MVEX = NULL;
		}
#ENDIF

	}

	//CREATE A DEFAULT MDAT IF NONE WAS FOUND
	IF (!MOV->MDAT && (MOV->OPENMODE != GF_ISOM_OPEN_READ) && (MOV->OPENMODE != GF_ISOM_OPEN_KEEP_FRAGMENTS)) {
		MOV->MDAT = (GF_MEDIADATABOX *) GF_ISOM_BOX_NEW(GF_ISOM_BOX_TYPE_MDAT);
		IF (!MOV->MDAT) RETURN GF_OUT_OF_MEM;
		E = GF_LIST_ADD(MOV->TOPBOXES, MOV->MDAT);
		IF (E) RETURN E;
	}
#ENDIF /*GPAC_DISABLE_ISOM_WRITE*/

	RETURN GF_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 208506_CWE-476.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TGS_BUILD_REPLY(ASTGS_REQUEST_T PRIV,
		HDB_ENTRY_EX *KRBTGT,
		KRB5_ENCTYPE KRBTGT_ETYPE,
		CONST KRB5_KEYBLOCK *REPLYKEY,
		INT RK_IS_SUBKEY,
		KRB5_TICKET *TICKET,
		CONST CHAR **E_TEXT,
		AUTHORIZATIONDATA **AUTH_DATA,
		CONST STRUCT SOCKADDR *FROM_ADDR)
{
    KRB5_CONTEXT CONTEXT = PRIV->CONTEXT;
    KRB5_KDC_CONFIGURATION *CONFIG = PRIV->CONFIG;
    KDC_REQ *REQ = &PRIV->REQ;
    KDC_REQ_BODY *B = &PRIV->REQ.REQ_BODY;
    CONST CHAR *FROM = PRIV->FROM;
    KRB5_ERROR_CODE RET, RET2;
    KRB5_PRINCIPAL CP = NULL, SP = NULL, RSP = NULL, TP = NULL, DP = NULL;
    KRB5_PRINCIPAL KRBTGT_OUT_PRINCIPAL = NULL;
    CHAR *SPN = NULL, *CPN = NULL, *TPN = NULL, *DPN = NULL, *KRBTGT_OUT_N = NULL;
    HDB_ENTRY_EX *SERVER = NULL, *CLIENT = NULL, *S4U2SELF_IMPERSONATED_CLIENT = NULL;
    HDB *CLIENTDB, *S4U2SELF_IMPERSONATED_CLIENTDB;
    KRB5_REALM REF_REALM = NULL;
    ENCTICKETPART *TGT = &TICKET->TICKET;
    KRB5_PRINCIPALS SPP = NULL;
    CONST ENCRYPTIONKEY *EKEY;
    KRB5_KEYBLOCK SESSIONKEY;
    KRB5_KVNO KVNO;
    KRB5_DATA RSPAC;
    CONST CHAR *TGT_REALM = /* REALM OF TGT ISSUER */
        KRB5_PRINCIPAL_GET_REALM(CONTEXT, KRBTGT->ENTRY.PRINCIPAL);
    CONST CHAR *OUR_REALM = /* REALM OF THIS KDC */
        KRB5_PRINCIPAL_GET_COMP_STRING(CONTEXT, KRBTGT->ENTRY.PRINCIPAL, 1);
    CHAR **CAPATH = NULL;
    SIZE_T NUM_CAPATH = 0;

    HDB_ENTRY_EX *KRBTGT_OUT = NULL;

    METHOD_DATA ENC_PA_DATA;

    PRINCIPALNAME *S;
    REALM R;
    ENCTICKETPART ADTKT;
    CHAR OPT_STR[128];
    INT SIGNEDPATH = 0;

    KEY *TKEY_CHECK;
    KEY *TKEY_SIGN;
    INT FLAGS = HDB_F_FOR_TGS_REQ;

    MEMSET(&SESSIONKEY, 0, SIZEOF(SESSIONKEY));
    MEMSET(&ADTKT, 0, SIZEOF(ADTKT));
    KRB5_DATA_ZERO(&RSPAC);
    MEMSET(&ENC_PA_DATA, 0, SIZEOF(ENC_PA_DATA));

    S = B->SNAME;
    R = B->REALM;

    /*
     * THE CANONICALIZE KDC OPTION IS PASSED AS A HINT TO THE BACKEND, BUT
     * CAN TYPICALLY BE IGNORED. PER RFC 6806, NAMES ARE NOT CANONICALIZED
     * IN RESPONSE TO A TGS REQUEST (ALTHOUGH WE MAKE AN EXCEPTION, SEE
     * FORCE-CANONICALIZE BELOW).
     */
    IF (B->KDC_OPTIONS.CANONICALIZE)
	FLAGS |= HDB_F_CANON;

    IF(B->KDC_OPTIONS.ENC_TKT_IN_SKEY){
	TICKET *T;
	HDB_ENTRY_EX *UU;
	KRB5_PRINCIPAL P;
	KEY *UUKEY;
	KRB5UINT32 SECOND_KVNO = 0;
	KRB5UINT32 *KVNO_PTR = NULL;

	IF(B->ADDITIONAL_TICKETS == NULL ||
	   B->ADDITIONAL_TICKETS->LEN == 0){
	    RET = KRB5KDC_ERR_BADOPTION; /* ? */
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "NO SECOND TICKET PRESENT IN USER-TO-USER REQUEST");
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "NO SECOND TICKET PRESENT IN USER-TO-USER REQUEST");
	    GOTO OUT;
	}
	T = &B->ADDITIONAL_TICKETS->VAL[0];
	IF(!GET_KRBTGT_REALM(&T->SNAME)){
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "ADDITIONAL TICKET IS NOT A TICKET-GRANTING TICKET");
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "ADDITIONAL TICKET IS NOT A TICKET-GRANTING TICKET");
	    RET = KRB5KDC_ERR_POLICY;
	    GOTO OUT;
	}
	_KRB5_PRINCIPALNAME2KRB5_PRINCIPAL(CONTEXT, &P, T->SNAME, T->REALM);
	RET = KRB5_UNPARSE_NAME(CONTEXT, P, &TPN);
	IF (RET)
		GOTO OUT;
	IF(T->ENC_PART.KVNO){
	    SECOND_KVNO = *T->ENC_PART.KVNO;
	    KVNO_PTR = &SECOND_KVNO;
	}
	RET = _KDC_DB_FETCH(CONTEXT, CONFIG, P,
			    HDB_F_GET_KRBTGT, KVNO_PTR,
			    NULL, &UU);
	KRB5_FREE_PRINCIPAL(CONTEXT, P);
	IF(RET){
	    IF (RET == HDB_ERR_NOENTRY)
		RET = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "USER-TO-USER SERVICE PRINCIPAL (TGS) UNKNOWN");
	    GOTO OUT;
	}
	RET = HDB_ENCTYPE2KEY(CONTEXT, &UU->ENTRY, NULL,
			      T->ENC_PART.ETYPE, &UUKEY);
	IF(RET){
	    _KDC_FREE_ENT(CONTEXT, UU);
	    RET = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "USER-TO-USER ENCTYPE NOT SUPPORTED");
	    GOTO OUT;
	}
	RET = KRB5_DECRYPT_TICKET(CONTEXT, T, &UUKEY->KEY, &ADTKT, 0);
	_KDC_FREE_ENT(CONTEXT, UU);
	IF(RET) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "USER-TO-USER TGT DECRYPT FAILURE");
	    GOTO OUT;
        }

	RET = VERIFY_FLAGS(CONTEXT, CONFIG, &ADTKT, TPN);
	IF (RET) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "USER-TO-USER TGT EXPIRED OR INVALID");
	    GOTO OUT;
        }

	S = &ADTKT.CNAME;
	R = ADTKT.CREALM;
    }

    _KRB5_PRINCIPALNAME2KRB5_PRINCIPAL(CONTEXT, &SP, *S, R);
    RET = KRB5_UNPARSE_NAME(CONTEXT, SP, &PRIV->SNAME);
    IF (RET)
	GOTO OUT;
    SPN = PRIV->SNAME;
    _KRB5_PRINCIPALNAME2KRB5_PRINCIPAL(CONTEXT, &CP, TGT->CNAME, TGT->CREALM);
    RET = KRB5_UNPARSE_NAME(CONTEXT, CP, &PRIV->CNAME);
    IF (RET)
	GOTO OUT;
    CPN = PRIV->CNAME;
    UNPARSE_FLAGS (KDCOPTIONS2INT(B->KDC_OPTIONS),
		   ASN1_KDCOPTIONS_UNITS(),
		   OPT_STR, SIZEOF(OPT_STR));
    IF(*OPT_STR)
	KDC_LOG(CONTEXT, CONFIG, 4,
		"TGS-REQ %S FROM %S FOR %S [%S]",
		CPN, FROM, SPN, OPT_STR);
    ELSE
	KDC_LOG(CONTEXT, CONFIG, 4,
		"TGS-REQ %S FROM %S FOR %S", CPN, FROM, SPN);

    /*
     * FETCH SERVER
     */

SERVER_LOOKUP:
    RET = _KDC_DB_FETCH(CONTEXT, CONFIG, SP,
                        HDB_F_GET_SERVER | HDB_F_DELAY_NEW_KEYS | FLAGS,
			NULL, NULL, &SERVER);
    PRIV->SERVER = SERVER;
    IF (RET == HDB_ERR_NOT_FOUND_HERE) {
	KDC_LOG(CONTEXT, CONFIG, 5, "TARGET %S DOES NOT HAVE SECRETS AT THIS KDC, NEED TO PROXY", SPN);
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "TARGET NOT FOUND HERE");
	GOTO OUT;
    } ELSE IF (RET == HDB_ERR_WRONG_REALM) {
        FREE(REF_REALM);
	REF_REALM = STRDUP(SERVER->ENTRY.PRINCIPAL->REALM);
	IF (REF_REALM == NULL) {
            RET = KRB5_ENOMEM(CONTEXT);
	    GOTO OUT;
	}

	KDC_LOG(CONTEXT, CONFIG, 4,
		"RETURNING A REFERRAL TO REALM %S FOR "
		"SERVER %S.",
		REF_REALM, SPN);
	KRB5_FREE_PRINCIPAL(CONTEXT, SP);
	SP = NULL;
	RET = KRB5_MAKE_PRINCIPAL(CONTEXT, &SP, R, KRB5_TGS_NAME,
				  REF_REALM, NULL);
	IF (RET)
	    GOTO OUT;
	FREE(PRIV->SNAME);
        PRIV->SNAME = NULL;
	RET = KRB5_UNPARSE_NAME(CONTEXT, SP, &PRIV->SNAME);
	IF (RET)
	    GOTO OUT;
	SPN = PRIV->SNAME;

	GOTO SERVER_LOOKUP;
    } ELSE IF (RET) {
	CONST CHAR *NEW_RLM, *MSG;
	REALM REQ_RLM;
	KRB5_REALM *REALMS;

	IF ((REQ_RLM = GET_KRBTGT_REALM(&SP->NAME)) != NULL) {
            IF (CAPATH == NULL) {
                /* WITH REFERALLS, HIERARCHICAL CAPATHS ARE ALWAYS ENABLED */
                RET2 = _KRB5_FIND_CAPATH(CONTEXT, TGT->CREALM, OUR_REALM,
                                         REQ_RLM, TRUE, &CAPATH, &NUM_CAPATH);
                IF (RET2) {
                    RET = RET2;
                    _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                         "NO TRUSTED PATH FROM CLIENT REALM TO OURS");
                    GOTO OUT;
                }
            }
            NEW_RLM = NUM_CAPATH > 0 ? CAPATH[--NUM_CAPATH] : NULL;
            IF (NEW_RLM) {
                KDC_LOG(CONTEXT, CONFIG, 5, "KRBTGT FROM %S VIA %S FOR "
                        "REALM %S NOT FOUND, TRYING %S", TGT->CREALM,
                        OUR_REALM, REQ_RLM, NEW_RLM);

                FREE(REF_REALM);
                REF_REALM = STRDUP(NEW_RLM);
                IF (REF_REALM == NULL) {
                    RET = KRB5_ENOMEM(CONTEXT);
                    GOTO OUT;
                }

                KRB5_FREE_PRINCIPAL(CONTEXT, SP);
                SP = NULL;
                KRB5_MAKE_PRINCIPAL(CONTEXT, &SP, R,
                                    KRB5_TGS_NAME, REF_REALM, NULL);
                FREE(PRIV->SNAME);
                PRIV->SNAME = NULL;
                RET = KRB5_UNPARSE_NAME(CONTEXT, SP, &PRIV->SNAME);
                IF (RET)
                    GOTO OUT;
                SPN = PRIV->SNAME;
                GOTO SERVER_LOOKUP;
            }
	} ELSE IF (NEED_REFERRAL(CONTEXT, CONFIG, &B->KDC_OPTIONS, SP, &REALMS)) {
	    IF (STRCMP(REALMS[0], SP->REALM) != 0) {
		KDC_LOG(CONTEXT, CONFIG, 4,
			"RETURNING A REFERRAL TO REALM %S FOR "
			"SERVER %S THAT WAS NOT FOUND",
			REALMS[0], SPN);
		KRB5_FREE_PRINCIPAL(CONTEXT, SP);
                SP = NULL;
		KRB5_MAKE_PRINCIPAL(CONTEXT, &SP, R, KRB5_TGS_NAME,
				    REALMS[0], NULL);
		FREE(PRIV->SNAME);
                PRIV->SNAME = NULL;
		RET = KRB5_UNPARSE_NAME(CONTEXT, SP, &PRIV->SNAME);
		IF (RET) {
		    KRB5_FREE_HOST_REALM(CONTEXT, REALMS);
		    GOTO OUT;
		}
		SPN = PRIV->SNAME;

                FREE(REF_REALM);
		REF_REALM = STRDUP(REALMS[0]);

		KRB5_FREE_HOST_REALM(CONTEXT, REALMS);
		GOTO SERVER_LOOKUP;
	    }
	    KRB5_FREE_HOST_REALM(CONTEXT, REALMS);
	}
	MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
	KDC_LOG(CONTEXT, CONFIG, 3,
		"SERVER NOT FOUND IN DATABASE: %S: %S", SPN, MSG);
	KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
	IF (RET == HDB_ERR_NOENTRY)
	    RET = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                             "SERVICE PRINCIPAL UNKNOWN");
	GOTO OUT;
    }

    /*
     * RFC 6806 NOTES THAT NAMES MUST NOT BE CHANGED IN THE RESPONSE TO
     * A TGS REQUEST. HENCE WE IGNORE THE SETTING OF THE CANONICALIZE
     * KDC OPTION. HOWEVER, FOR LEGACY INTEROPERABILITY WE DO ALLOW THE
     * BACKEND TO OVERRIDE THIS BY SETTING THE FORCE-CANONICALIZE HDB
     * FLAG IN THE SERVER ENTRY.
     */
    IF (SERVER->ENTRY.FLAGS.FORCE_CANONICALIZE)
	RSP = SERVER->ENTRY.PRINCIPAL;
    ELSE
	RSP = SP;

    /*
     * SELECT ENCTYPE, RETURN KEY AND KVNO.
     */

    {
	KRB5_ENCTYPE ETYPE;

	IF(B->KDC_OPTIONS.ENC_TKT_IN_SKEY) {
	    SIZE_T I;
	    EKEY = &ADTKT.KEY;
	    FOR(I = 0; I < B->ETYPE.LEN; I++)
		IF (B->ETYPE.VAL[I] == ADTKT.KEY.KEYTYPE)
		    BREAK;
	    IF(I == B->ETYPE.LEN) {
		KDC_LOG(CONTEXT, CONFIG, 4,
			"ADDITION TICKET HAVE NOT MATCHING ETYPES");
		KRB5_CLEAR_ERROR_MESSAGE(CONTEXT);
		RET = KRB5KDC_ERR_ETYPE_NOSUPP;
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "NO MATCHING ENCTYPES FOR 2ND TICKET");
		GOTO OUT;
	    }
	    ETYPE = B->ETYPE.VAL[I];
	    KVNO = 0;
	} ELSE {
	    KEY *SKEY;

	    RET = _KDC_FIND_ETYPE(PRIV, KRB5_PRINCIPAL_IS_KRBTGT(CONTEXT, SP)
							     ? KFE_IS_TGS : 0,
				  B->ETYPE.VAL, B->ETYPE.LEN, &ETYPE, NULL,
				  NULL);
	    IF(RET) {
		KDC_LOG(CONTEXT, CONFIG, 4,
			"SERVER (%S) HAS NO SUPPORT FOR ETYPES", SPN);
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "ENCTYPE NOT SUPPORTED");
		GOTO OUT;
	    }
	    RET = _KDC_GET_PREFERRED_KEY(CONTEXT, CONFIG, SERVER, SPN,
					 NULL, &SKEY);
	    IF(RET) {
		KDC_LOG(CONTEXT, CONFIG, 4,
			"SERVER (%S) HAS NO SUPPORTED ETYPES", SPN);
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "ENCTYPE NOT SUPPORTED");
		GOTO OUT;
	    }
	    EKEY = &SKEY->KEY;
	    KVNO = SERVER->ENTRY.KVNO;
	}

	RET = KRB5_GENERATE_RANDOM_KEYBLOCK(CONTEXT, ETYPE, &SESSIONKEY);
	IF (RET)
	    GOTO OUT;
    }

    /*
     * CHECK THAT SERVICE IS IN THE SAME REALM AS THE KRBTGT. IF IT'S
     * NOT THE SAME, IT'S SOMEONE THAT IS USING A UNI-DIRECTIONAL TRUST
     * BACKWARD.
     */

    /*
     * VALIDATE AUTHORIZATION DATA
     */

    RET = HDB_ENCTYPE2KEY(CONTEXT, &KRBTGT->ENTRY, NULL, /* XXX USE THE RIGHT KVNO! */
			  KRBTGT_ETYPE, &TKEY_CHECK);
    IF(RET) {
	KDC_LOG(CONTEXT, CONFIG, 4,
		    "FAILED TO FIND KEY FOR KRBTGT PAC CHECK");
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                             "NO KEY FOR KRBTGT PAC CHECK");
	GOTO OUT;
    }

    /* 
     * NOW REFETCH THE PRIMARY KRBTGT, AND GET THE CURRENT KVNO (THE
     * SIGN CHECK MAY HAVE BEEN ON AN OLD KVNO, AND THE SERVER MAY
     * HAVE BEEN AN INCOMING TRUST)
     */
    
    RET = KRB5_MAKE_PRINCIPAL(CONTEXT,
                              &KRBTGT_OUT_PRINCIPAL,
                              OUR_REALM,
                              KRB5_TGS_NAME,
                              OUR_REALM,
                              NULL);
    IF (RET) {
        KDC_LOG(CONTEXT, CONFIG, 4,
                "FAILED TO MAKE KRBTGT PRINCIPAL NAME OBJECT FOR "
                "AUTHZ-DATA SIGNATURES");
        GOTO OUT;
    }
    RET = KRB5_UNPARSE_NAME(CONTEXT, KRBTGT_OUT_PRINCIPAL, &KRBTGT_OUT_N);
    IF (RET) {
        KDC_LOG(CONTEXT, CONFIG, 4,
                "FAILED TO MAKE KRBTGT PRINCIPAL NAME OBJECT FOR "
                "AUTHZ-DATA SIGNATURES");
        GOTO OUT;
    }

    RET = _KDC_DB_FETCH(CONTEXT, CONFIG, KRBTGT_OUT_PRINCIPAL,
			HDB_F_GET_KRBTGT, NULL, NULL, &KRBTGT_OUT);
    IF (RET) {
	CHAR *KTPN = NULL;
	RET = KRB5_UNPARSE_NAME(CONTEXT, KRBTGT->ENTRY.PRINCIPAL, &KTPN);
	KDC_LOG(CONTEXT, CONFIG, 4,
		"NO SUCH PRINCIPAL %S (NEEDED FOR AUTHZ-DATA SIGNATURE KEYS) "
		"WHILE PROCESSING TGS-REQ FOR SERVICE %S WITH KRBTG %S",
		KRBTGT_OUT_N, SPN, (RET == 0) ? KTPN : "<UNKNOWN>");
	FREE(KTPN);
	RET = KRB5KRB_AP_ERR_NOT_US;
	GOTO OUT;
    }

    /* 
     * THE FIRST REALM IS THE REALM OF THE SERVICE, THE SECOND IS
     * KRBTGT/<THIS>/@REALM COMPONENT OF THE KRBTGT DN THE REQUEST WAS
     * ENCRYPTED TO.  THE REDIRECTION VIA THE KRBTGT_OUT ENTRY ALLOWS
     * THE DB TO POSSIBLY CORRECT THE CASE OF THE REALM (SAMBA4 DOES
     * THIS) BEFORE THE STRCMP() 
     */
    IF (STRCMP(KRB5_PRINCIPAL_GET_REALM(CONTEXT, SERVER->ENTRY.PRINCIPAL),
	       KRB5_PRINCIPAL_GET_REALM(CONTEXT, KRBTGT_OUT->ENTRY.PRINCIPAL)) != 0) {
	CHAR *KTPN;
	RET = KRB5_UNPARSE_NAME(CONTEXT, KRBTGT_OUT->ENTRY.PRINCIPAL, &KTPN);
	KDC_LOG(CONTEXT, CONFIG, 4,
		"REQUEST WITH WRONG KRBTGT: %S",
		(RET == 0) ? KTPN : "<UNKNOWN>");
	IF(RET == 0)
	    FREE(KTPN);
	RET = KRB5KRB_AP_ERR_NOT_US;
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "REQUEST WITH WRONG TGT");
	GOTO OUT;
    }

    RET = _KDC_GET_PREFERRED_KEY(CONTEXT, CONFIG, KRBTGT_OUT, KRBTGT_OUT_N,
				 NULL, &TKEY_SIGN);
    IF (RET) {
	KDC_LOG(CONTEXT, CONFIG, 4,
		    "FAILED TO FIND KEY FOR KRBTGT PAC SIGNATURE");
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                             "FAILED TO FIND KEY FOR KRBTGT PAC SIGNATURE");
	GOTO OUT;
    }
    RET = HDB_ENCTYPE2KEY(CONTEXT, &KRBTGT_OUT->ENTRY, NULL,
			  TKEY_SIGN->KEY.KEYTYPE, &TKEY_SIGN);
    IF(RET) {
	KDC_LOG(CONTEXT, CONFIG, 4,
		    "FAILED TO FIND KEY FOR KRBTGT PAC SIGNATURE");
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                             "FAILED TO FIND KEY FOR KRBTGT PAC SIGNATURE");
	GOTO OUT;
    }

    {
        KRB5_DATA VERIFIED_CAS;

        /*
         * IF THE CLIENT DOESN'T EXIST IN THE HDB BUT HAS A TGT AND IT'S
         * OBTAINED WITH PKINIT THEN WE ASSUME IT'S A SYNTHETIC CLIENT -- THAT
         * IS, A CLIENT WHOSE NAME WAS VOUCHED FOR BY A CA USING A PKINIT SAN,
         * BUT WHICH DOESN'T EXIST IN THE HDB PROPER.  WE'LL ALLOW SUCH A
         * CLIENT TO DO TGT REQUESTS EVEN THOUGH NORMALLY WE'D REJECT ALL
         * CLIENTS THAT DON'T EXIST IN THE HDB.
         */
        RET = KRB5_TICKET_GET_AUTHORIZATION_DATA_TYPE(CONTEXT, TICKET,
                                                      KRB5_AUTHDATA_INITIAL_VERIFIED_CAS,
                                                      &VERIFIED_CAS);
        IF (RET == 0) {
            KRB5_DATA_FREE(&VERIFIED_CAS);
            FLAGS |= HDB_F_SYNTHETIC_OK;
        }
    }
    RET = _KDC_DB_FETCH(CONTEXT, CONFIG, CP, HDB_F_GET_CLIENT | FLAGS,
			NULL, &CLIENTDB, &CLIENT);
    FLAGS &= ~HDB_F_SYNTHETIC_OK;
    PRIV->CLIENT = CLIENT;
    IF(RET == HDB_ERR_NOT_FOUND_HERE) {
	/* THIS IS OK, WE ARE JUST TRYING TO FIND OUT IF THEY HAVE
	 * BEEN DISABLED OR DELETED IN THE MEANTIME, MISSING SECRETS
	 * IS OK */
    } ELSE IF(RET){
	CONST CHAR *KRBTGT_REALM, *MSG;

	/*
	 * IF THE CLIENT BELONGS TO THE SAME REALM AS OUR KRBTGT, IT
	 * SHOULD EXIST IN THE LOCAL DATABASE.
	 *
	 */

	KRBTGT_REALM = KRB5_PRINCIPAL_GET_REALM(CONTEXT, KRBTGT_OUT->ENTRY.PRINCIPAL);

	IF(STRCMP(KRB5_PRINCIPAL_GET_REALM(CONTEXT, CP), KRBTGT_REALM) == 0) {
	    IF (RET == HDB_ERR_NOENTRY)
		RET = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    KDC_LOG(CONTEXT, CONFIG, 4, "CLIENT NO LONGER IN DATABASE: %S",
		    CPN);
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "CLIENT NO LONGER IN HDB");
	    GOTO OUT;
	}

	MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
	KDC_LOG(CONTEXT, CONFIG, 4, "CLIENT NOT FOUND IN DATABASE: %S", MSG);
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "CLIENT DOES NOT EXIST");
	KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
    } ELSE IF (RET == 0 &&
               (CLIENT->ENTRY.FLAGS.INVALID || !CLIENT->ENTRY.FLAGS.CLIENT)) {
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "CLIENT HAS INVALID BIT SET");
        KDC_LOG(CONTEXT, CONFIG, 4, "CLIENT HAS INVALID BIT SET");
        RET = KRB5KDC_ERR_POLICY;
        GOTO OUT;
    }

    RET = CHECK_PAC(CONTEXT, CONFIG, CP, NULL,
		    CLIENT, SERVER, KRBTGT,
		    &TKEY_CHECK->KEY,
		    EKEY, &TKEY_SIGN->KEY,
		    TGT, &RSPAC, &SIGNEDPATH);
    IF (RET) {
	CONST CHAR *MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "PAC CHECK FAILED");
	KDC_LOG(CONTEXT, CONFIG, 4,
		"VERIFY PAC FAILED FOR %S (%S) FROM %S WITH %S",
		SPN, CPN, FROM, MSG);
	KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
	GOTO OUT;
    }

    /* ALSO CHECK THE KRBTGT FOR SIGNATURE */
    RET = CHECK_KRB5SIGNEDPATH(CONTEXT,
			       CONFIG,
			       KRBTGT,
			       CP,
			       TGT,
			       &SPP,
			       &SIGNEDPATH);
    IF (RET) {
	CONST CHAR *MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "KRB5SIGNEDPATH CHECK FAILED");
	KDC_LOG(CONTEXT, CONFIG, 4,
		"KRB5SIGNEDPATH CHECK FAILED FOR %S (%S) FROM %S WITH %S",
		SPN, CPN, FROM, MSG);
	KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
	GOTO OUT;
    }

    /*
     * PROCESS REQUEST
     */

    /* BY DEFAULT THE TGT PRINCIPAL MATCHES THE CLIENT PRINCIPAL */
    TP = CP;
    TPN = CPN;

    IF (CLIENT) {
	CONST PA_DATA *SDATA;
	INT I = 0;

	SDATA = _KDC_FIND_PADATA(REQ, &I, KRB5_PADATA_FOR_USER);
	IF (SDATA) {
	    STRUCT ASTGS_REQUEST_DESC IMP_REQ;
	    KRB5_CRYPTO CRYPTO;
	    KRB5_DATA DATACK;
	    PA_S4U2SELF SELF;
	    CONST CHAR *STR;

	    RET = DECODE_PA_S4U2SELF(SDATA->PADATA_VALUE.DATA,
				     SDATA->PADATA_VALUE.LENGTH,
				     &SELF, NULL);
	    IF (RET) {
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "FAILED TO DECODE PA-S4U2SELF");
		KDC_LOG(CONTEXT, CONFIG, 4, "FAILED TO DECODE PA-S4U2SELF");
		GOTO OUT;
	    }

	    IF (!KRB5_CHECKSUM_IS_KEYED(CONTEXT, SELF.CKSUM.CKSUMTYPE)) {
		FREE_PA_S4U2SELF(&SELF);
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "PA-S4U2SELF WITH UNKEYED CHECKSUM");
		KDC_LOG(CONTEXT, CONFIG, 4, "REJECT PA-S4U2SELF WITH UNKEYED CHECKSUM");
		RET = KRB5KRB_AP_ERR_INAPP_CKSUM;
		GOTO OUT;
	    }

	    RET = _KRB5_S4U2SELF_TO_CHECKSUMDATA(CONTEXT, &SELF, &DATACK);
	    IF (RET)
		GOTO OUT;

	    RET = KRB5_CRYPTO_INIT(CONTEXT, &TGT->KEY, 0, &CRYPTO);
	    IF (RET) {
		CONST CHAR *MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
		FREE_PA_S4U2SELF(&SELF);
		KRB5_DATA_FREE(&DATACK);
		KDC_LOG(CONTEXT, CONFIG, 4, "KRB5_CRYPTO_INIT FAILED: %S", MSG);
		KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
		GOTO OUT;
	    }

	    /* ALLOW HMAC_MD5 CHECKSUM WITH ANY KEY TYPE */
	    IF (SELF.CKSUM.CKSUMTYPE == CKSUMTYPE_HMAC_MD5) {
		STRUCT KRB5_CRYPTO_IOV IOV;
		UNSIGNED CHAR CSDATA[16];
		CHECKSUM CS;

		CS.CHECKSUM.LENGTH = SIZEOF(CSDATA);
		CS.CHECKSUM.DATA = &CSDATA;

		IOV.DATA.DATA = DATACK.DATA;
		IOV.DATA.LENGTH = DATACK.LENGTH;
		IOV.FLAGS = KRB5_CRYPTO_TYPE_DATA;

		RET = _KRB5_HMAC_MD5_CHECKSUM(CONTEXT, NULL, &CRYPTO->KEY,
					      KRB5_KU_OTHER_CKSUM, &IOV, 1,
					      &CS);
		IF (RET == 0 &&
		    KRB5_DATA_CT_CMP(&CS.CHECKSUM, &SELF.CKSUM.CHECKSUM) != 0)
		    RET = KRB5KRB_AP_ERR_BAD_INTEGRITY;
	    }
	    ELSE {
		RET = KRB5_VERIFY_CHECKSUM(CONTEXT,
					   CRYPTO,
					   KRB5_KU_OTHER_CKSUM,
					   DATACK.DATA,
					   DATACK.LENGTH,
					   &SELF.CKSUM);
	    }
	    KRB5_DATA_FREE(&DATACK);
	    KRB5_CRYPTO_DESTROY(CONTEXT, CRYPTO);
	    IF (RET) {
		CONST CHAR *MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
		FREE_PA_S4U2SELF(&SELF);
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "S4U2SELF CHECKSUM FAILED");
		KDC_LOG(CONTEXT, CONFIG, 4,
			"KRB5_VERIFY_CHECKSUM FAILED FOR S4U2SELF: %S", MSG);
		KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
		GOTO OUT;
	    }

	    RET = _KRB5_PRINCIPALNAME2KRB5_PRINCIPAL(CONTEXT,
						     &TP,
						     SELF.NAME,
						     SELF.REALM);
	    FREE_PA_S4U2SELF(&SELF);
	    IF (RET)
		GOTO OUT;

	    RET = KRB5_UNPARSE_NAME(CONTEXT, TP, &TPN);
	    IF (RET)
		GOTO OUT;

            /*
             * NOTE NO HDB_F_SYNTHETIC_OK -- IMPERSONATING NON-EXISTENT CLIENTS
             * IS PROBABLY NOT DESIRABLE!
             */
	    RET = _KDC_DB_FETCH(CONTEXT, CONFIG, TP, HDB_F_GET_CLIENT | FLAGS,
				NULL, &S4U2SELF_IMPERSONATED_CLIENTDB,
				&S4U2SELF_IMPERSONATED_CLIENT);
	    IF (RET) {
		CONST CHAR *MSG;

		/*
		 * IF THE CLIENT BELONGS TO THE SAME REALM AS OUR KRBTGT, IT
		 * SHOULD EXIST IN THE LOCAL DATABASE.
		 *
		 */

		IF (RET == HDB_ERR_NOENTRY)
		    RET = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
		MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
                _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                     "S4U2SELF PRINCIPAL TO IMPERSONATE NOT FOUND");
		KDC_LOG(CONTEXT, CONFIG, 2,
			"S4U2SELF PRINCIPAL TO IMPERSONATE %S NOT FOUND IN DATABASE: %S",
			TPN, MSG);
		KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
		GOTO OUT;
	    }

	    /* IGNORE REQUIRE_PWCHANGE AND PW_END ATTRIBUTES (AS WINDOWS DOES),
	     * SINCE S4U2SELF IS NOT PASSWORD AUTHENTICATION. */
	    S4U2SELF_IMPERSONATED_CLIENT->ENTRY.FLAGS.REQUIRE_PWCHANGE = FALSE;
	    FREE(S4U2SELF_IMPERSONATED_CLIENT->ENTRY.PW_END);
	    S4U2SELF_IMPERSONATED_CLIENT->ENTRY.PW_END = NULL;

	    IMP_REQ = *PRIV;
	    IMP_REQ.CLIENT = S4U2SELF_IMPERSONATED_CLIENT;
	    IMP_REQ.CLIENT_PRINC = TP;

	    RET = KDC_CHECK_FLAGS(&IMP_REQ, FALSE);
	    IF (RET)
		GOTO OUT; /* KDC_CHECK_FLAGS() CALLS _KDC_AUDIT_ADDREASON() */

	    /* IF WE WERE ABOUT TO PUT A PAC INTO THE TICKET, WE BETTER FIX IT TO BE THE RIGHT PAC */
	    IF(RSPAC.DATA) {
		KRB5_PAC P = NULL;
		KRB5_DATA_FREE(&RSPAC);
		RET = _KDC_PAC_GENERATE(CONTEXT, S4U2SELF_IMPERSONATED_CLIENT, &P);
		IF (RET) {
                    _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                         "KRB5SIGNEDPATH MISSING");
		    KDC_LOG(CONTEXT, CONFIG, 4, "PAC GENERATION FAILED FOR -- %S",
			    TPN);
		    GOTO OUT;
		}
		IF (P != NULL) {
		    RET = _KRB5_PAC_SIGN(CONTEXT, P, TICKET->TICKET.AUTHTIME,
					 S4U2SELF_IMPERSONATED_CLIENT->ENTRY.PRINCIPAL,
					 EKEY, &TKEY_SIGN->KEY,
					 &RSPAC);
		    KRB5_PAC_FREE(CONTEXT, P);
		    IF (RET) {
			KDC_LOG(CONTEXT, CONFIG, 4, "PAC SIGNING FAILED FOR -- %S",
				TPN);
			GOTO OUT;
		    }
		}
	    }

	    /*
	     * CHECK THAT SERVICE DOING THE IMPERSONATING IS
	     * REQUESTING A TICKET TO IT-SELF.
	     */
	    RET = CHECK_S4U2SELF(CONTEXT, CONFIG, CLIENTDB, CLIENT, SP);
	    IF (RET) {
		KDC_LOG(CONTEXT, CONFIG, 4, "S4U2SELF: %S IS NOT ALLOWED "
			"TO IMPERSONATE TO SERVICE "
			"(TRIED FOR USER %S TO SERVICE %S)",
			CPN, TPN, SPN);
		GOTO OUT;
	    }

	    /*
	     * IF THE SERVICE ISN'T TRUSTED FOR AUTHENTICATION TO
	     * DELEGATION OR IF THE IMPERSONATE CLIENT IS DISALLOWED
	     * FORWARDABLE, REMOVE THE FORWARDABLE FLAG.
	     */

	    IF (CLIENT->ENTRY.FLAGS.TRUSTED_FOR_DELEGATION &&
		S4U2SELF_IMPERSONATED_CLIENT->ENTRY.FLAGS.FORWARDABLE) {
		STR = "[FORWARDABLE]";
	    } ELSE {
		B->KDC_OPTIONS.FORWARDABLE = 0;
		STR = "";
	    }
	    KDC_LOG(CONTEXT, CONFIG, 4, "S4U2SELF %S IMPERSONATING %S TO "
		    "SERVICE %S %S", CPN, TPN, SPN, STR);
	}
    }

    /*
     * CONSTRAINED DELEGATION
     */

    IF (CLIENT != NULL
	&& B->ADDITIONAL_TICKETS != NULL
	&& B->ADDITIONAL_TICKETS->LEN != 0
	&& B->KDC_OPTIONS.CNAME_IN_ADDL_TKT
	&& B->KDC_OPTIONS.ENC_TKT_IN_SKEY == 0)
    {
	INT AD_SIGNEDPATH = 0;
	KEY *CLIENTKEY;
	TICKET *T;

	/*
	 * REQUIRE THAT THE KDC HAVE ISSUED THE SERVICE'S KRBTGT (NOT
	 * SELF-ISSUED TICKET WITH KIMPERSONATE(1).
	 */
	IF (!SIGNEDPATH) {
	    RET = KRB5KDC_ERR_BADOPTION;
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "KRB5SIGNEDPATH MISSING");
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "CONSTRAINED DELEGATION DONE ON SERVICE TICKET %S/%S",
		    CPN, SPN);
	    GOTO OUT;
	}

	T = &B->ADDITIONAL_TICKETS->VAL[0];

	RET = HDB_ENCTYPE2KEY(CONTEXT, &CLIENT->ENTRY,
			      HDB_KVNO2KEYS(CONTEXT, &CLIENT->ENTRY,
					    T->ENC_PART.KVNO ? * T->ENC_PART.KVNO : 0),
			      T->ENC_PART.ETYPE, &CLIENTKEY);
	IF(RET){
	    RET = KRB5KDC_ERR_ETYPE_NOSUPP; /* XXX */
	    GOTO OUT;
	}

	RET = KRB5_DECRYPT_TICKET(CONTEXT, T, &CLIENTKEY->KEY, &ADTKT, 0);
	IF (RET) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "FAILED TO DECRYPT CONSTRAINED DELEGATION TICKET");
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "FAILED TO DECRYPT TICKET FOR "
		    "CONSTRAINED DELEGATION FROM %S TO %S ", CPN, SPN);
	    GOTO OUT;
	}

	RET = _KRB5_PRINCIPALNAME2KRB5_PRINCIPAL(CONTEXT,
						 &TP,
						 ADTKT.CNAME,
						 ADTKT.CREALM);
	IF (RET)
	    GOTO OUT;

	RET = KRB5_UNPARSE_NAME(CONTEXT, TP, &TPN);
	IF (RET)
	    GOTO OUT;

        _KDC_AUDIT_ADDKV((KDC_REQUEST_T)PRIV, 0, "IMPERSONATEE", "%S", TPN);

	RET = _KRB5_PRINCIPALNAME2KRB5_PRINCIPAL(CONTEXT,
						 &DP,
						 T->SNAME,
						 T->REALM);
	IF (RET)
	    GOTO OUT;

	RET = KRB5_UNPARSE_NAME(CONTEXT, DP, &DPN);
	IF (RET)
	    GOTO OUT;

	/* CHECK THAT TICKET IS VALID */
	IF (ADTKT.FLAGS.FORWARDABLE == 0) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "MISSING FORWARDABLE FLAG ON TICKET FOR CONSTRAINED DELEGATION");
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "MISSING FORWARDABLE FLAG ON TICKET FOR "
		    "CONSTRAINED DELEGATION FROM %S (%S) AS %S TO %S ",
		    CPN, DPN, TPN, SPN);
	    RET = KRB5KDC_ERR_BADOPTION;
	    GOTO OUT;
	}

	RET = CHECK_CONSTRAINED_DELEGATION(CONTEXT, CONFIG, CLIENTDB,
					   CLIENT, SERVER, SP);
	IF (RET) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "CONSTRAINED DELEGATION NOT ALLOWED");
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "CONSTRAINED DELEGATION FROM %S (%S) AS %S TO %S NOT ALLOWED",
		    CPN, DPN, TPN, SPN);
	    GOTO OUT;
	}

	RET = VERIFY_FLAGS(CONTEXT, CONFIG, &ADTKT, TPN);
	IF (RET) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "CONSTRAINED DELEGATION TICKET EXPIRED OR INVALID");
	    GOTO OUT;
	}

	KRB5_DATA_FREE(&RSPAC);

	/*
	 * GENERATE THE PAC FOR THE USER.
	 *
	 * TODO: PASS IN T->SNAME AND T->REALM AND BUILD
	 * A S4U_DELEGATION_INFO BLOB TO THE PAC.
	 */
	RET = CHECK_PAC(CONTEXT, CONFIG, TP, DP,
			CLIENT, SERVER, KRBTGT,
			&CLIENTKEY->KEY,
			EKEY, &TKEY_SIGN->KEY,
			&ADTKT, &RSPAC, &AD_SIGNEDPATH);
	IF (RET) {
	    CONST CHAR *MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "CONSTRAINED DELEGATION TICKET PAC CHECK FAILED");
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "VERIFY DELEGATED PAC FAILED TO %S FOR CLIENT"
		    "%S (%S) AS %S FROM %S WITH %S",
		    SPN, CPN, DPN, TPN, FROM, MSG);
	    KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
	    GOTO OUT;
	}

	/*
	 * CHECK THAT THE KDC ISSUED THE USER'S TICKET.
	 */
	RET = CHECK_KRB5SIGNEDPATH(CONTEXT,
				   CONFIG,
				   KRBTGT,
				   CP,
				   &ADTKT,
				   NULL,
				   &AD_SIGNEDPATH);
	IF (RET) {
	    CONST CHAR *MSG = KRB5_GET_ERROR_MESSAGE(CONTEXT, RET);
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "KRB5SIGNEDPATH CHECK FROM SERVICE %S FAILED "
		    "FOR DELEGATION TO %S FOR CLIENT %S (%S)"
		    "FROM %S FAILED WITH %S",
		    SPN, TPN, DPN, CPN, FROM, MSG);
	    KRB5_FREE_ERROR_MESSAGE(CONTEXT, MSG);
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "KRB5SIGNEDPATH CHECK FAILED");
	    GOTO OUT;
	}

	IF (!AD_SIGNEDPATH) {
	    RET = KRB5KDC_ERR_BADOPTION;
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "TICKET NOT SIGNED WITH PAC NOR SIGNEDPATH SERVICE %S FAILED "
		    "FOR DELEGATION TO %S FOR CLIENT %S (%S)"
		    "FROM %S",
		    SPN, TPN, DPN, CPN, FROM);
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV,
                                 "CONSTRAINED DELEGATION TICKET NOT SIGNED");
	    GOTO OUT;
	}

	KDC_LOG(CONTEXT, CONFIG, 4, "CONSTRAINED DELEGATION FOR %S "
		"FROM %S (%S) TO %S", TPN, CPN, DPN, SPN);
    }

    /*
     * CHECK FLAGS
     */

    RET = KDC_CHECK_FLAGS(PRIV, FALSE);
    IF(RET)
	GOTO OUT;

    IF((B->KDC_OPTIONS.VALIDATE || B->KDC_OPTIONS.RENEW) &&
       !KRB5_PRINCIPAL_COMPARE(CONTEXT,
			       KRBTGT->ENTRY.PRINCIPAL,
			       SERVER->ENTRY.PRINCIPAL)){
        _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "INCONSISTENT REQUEST");
	KDC_LOG(CONTEXT, CONFIG, 4, "INCONSISTENT REQUEST.");
	RET = KRB5KDC_ERR_SERVER_NOMATCH;
	GOTO OUT;
    }

    /* CHECK FOR VALID SET OF ADDRESSES */
    IF (!_KDC_CHECK_ADDRESSES(PRIV, TGT->CADDR, FROM_ADDR)) {
        IF (CONFIG->CHECK_TICKET_ADDRESSES) {
            RET = KRB5KRB_AP_ERR_BADADDR;
            _KDC_AUDIT_ADDKV((KDC_REQUEST_T)PRIV, 0, "WRONGADDR", "YES");
            KDC_LOG(CONTEXT, CONFIG, 4, "REQUEST FROM WRONG ADDRESS");
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "REQUEST FROM WRONG ADDRESS");
            GOTO OUT;
        } ELSE IF (CONFIG->WARN_TICKET_ADDRESSES) {
            _KDC_AUDIT_ADDKV((KDC_REQUEST_T)PRIV, 0, "WRONGADDR", "YES");
        }
    }

    /* CHECK LOCAL AND PER-PRINCIPAL ANONYMOUS TICKET ISSUANCE POLICY */
    IF (IS_ANON_TGS_REQUEST_P(B, TGT)) {
	RET = _KDC_CHECK_ANON_POLICY(PRIV);
	IF (RET)
	    GOTO OUT;
    }

    /*
     * IF THIS IS AN REFERRAL, ADD SERVER REFERRAL DATA TO THE
     * AUTH_DATA REPLY .
     */
    IF (REF_REALM) {
	PA_DATA PA;
	KRB5_CRYPTO CRYPTO;

	KDC_LOG(CONTEXT, CONFIG, 3,
		"ADDING SERVER REFERRAL TO %S", REF_REALM);

	RET = KRB5_CRYPTO_INIT(CONTEXT, &SESSIONKEY, 0, &CRYPTO);
	IF (RET)
	    GOTO OUT;

	RET = BUILD_SERVER_REFERRAL(CONTEXT, CONFIG, CRYPTO, REF_REALM,
				    NULL, S, &PA.PADATA_VALUE);
	KRB5_CRYPTO_DESTROY(CONTEXT, CRYPTO);
	IF (RET) {
            _KDC_AUDIT_ADDREASON((KDC_REQUEST_T)PRIV, "REFERRAL BUILD FAILED");
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "FAILED BUILDING SERVER REFERRAL");
	    GOTO OUT;
	}
	PA.PADATA_TYPE = KRB5_PADATA_SERVER_REFERRAL;

	RET = ADD_METHOD_DATA(&ENC_PA_DATA, &PA);
	KRB5_DATA_FREE(&PA.PADATA_VALUE);
	IF (RET) {
	    KDC_LOG(CONTEXT, CONFIG, 4,
		    "ADD SERVER REFERRAL METHOD-DATA FAILED");
	    GOTO OUT;
	}
    }

    /*
     *
     */

    RET = TGS_MAKE_REPLY(PRIV,
			 TP,
			 TGT,
			 REPLYKEY,
			 RK_IS_SUBKEY,
			 EKEY,
			 &SESSIONKEY,
			 KVNO,
			 *AUTH_DATA,
			 SERVER,
			 RSP,
			 CLIENT,
			 CP,
                         TGT_REALM,
			 KRBTGT_OUT,
			 TKEY_SIGN->KEY.KEYTYPE,
			 SPP,
			 &RSPAC,
			 &ENC_PA_DATA);

OUT:
    IF (TPN != CPN)
	    FREE(TPN);
    FREE(DPN);
    FREE(KRBTGT_OUT_N);
    _KRB5_FREE_CAPATH(CONTEXT, CAPATH);

    KRB5_DATA_FREE(&RSPAC);
    KRB5_FREE_KEYBLOCK_CONTENTS(CONTEXT, &SESSIONKEY);
    IF(KRBTGT_OUT)
	_KDC_FREE_ENT(CONTEXT, KRBTGT_OUT);
    IF(SERVER)
	_KDC_FREE_ENT(CONTEXT, SERVER);
    IF(CLIENT)
	_KDC_FREE_ENT(CONTEXT, CLIENT);
    IF(S4U2SELF_IMPERSONATED_CLIENT)
	_KDC_FREE_ENT(CONTEXT, S4U2SELF_IMPERSONATED_CLIENT);

    IF (TP && TP != CP)
	KRB5_FREE_PRINCIPAL(CONTEXT, TP);
    KRB5_FREE_PRINCIPAL(CONTEXT, CP);
    KRB5_FREE_PRINCIPAL(CONTEXT, DP);
    KRB5_FREE_PRINCIPAL(CONTEXT, SP);
    KRB5_FREE_PRINCIPAL(CONTEXT, KRBTGT_OUT_PRINCIPAL);
    FREE(REF_REALM);
    FREE_METHOD_DATA(&ENC_PA_DATA);

    FREE_ENCTICKETPART(&ADTKT);

    RETURN RET;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 338213_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID WASMBINARYBUILDER::VISITSELECT(SELECT* CURR, UINT8_T CODE) {
  BYN_TRACE("ZZ NODE: SELECT, CODE " << INT32_T(CODE) << STD::ENDL);
  IF (CODE == BINARYCONSTS::SELECTWITHTYPE) {
    SIZE_T NUMTYPES = GETU32LEB();
    STD::VECTOR<TYPE> TYPES;
    FOR (SIZE_T I = 0; I < NUMTYPES; I++) {
      TYPES.PUSH_BACK(GETTYPE());
    }
    CURR->TYPE = TYPE(TYPES);
  }
  CURR->CONDITION = POPNONVOIDEXPRESSION();
  CURR->IFFALSE = POPNONVOIDEXPRESSION();
  CURR->IFTRUE = POPNONVOIDEXPRESSION();
  IF (CODE == BINARYCONSTS::SELECTWITHTYPE) {
    CURR->FINALIZE(CURR->TYPE);
  } ELSE {
    CURR->FINALIZE();
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210701_CWE-22.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIR *SQUASHFS_OPENDIR(UNSIGNED INT BLOCK_START, UNSIGNED INT OFFSET,
	STRUCT INODE **I)
{
	SQUASHFS_DIR_HEADER_3 DIRH;
	CHAR BUFFER[SIZEOF(SQUASHFS_DIR_ENTRY_3) + SQUASHFS_NAME_LEN + 1]
		__ATTRIBUTE__((ALIGNED));
	SQUASHFS_DIR_ENTRY_3 *DIRE = (SQUASHFS_DIR_ENTRY_3 *) BUFFER;
	LONG LONG START;
	INT BYTES;
	INT DIR_COUNT, SIZE;
	STRUCT DIR_ENT *NEW_DIR;
	STRUCT DIR *DIR;

	TRACE("SQUASHFS_OPENDIR: INODE START BLOCK %D, OFFSET %D\N",
		BLOCK_START, OFFSET);

	*I = READ_INODE(BLOCK_START, OFFSET);

	DIR = MALLOC(SIZEOF(STRUCT DIR));
	IF(DIR == NULL)
		EXIT_UNSQUASH("SQUASHFS_OPENDIR: MALLOC FAILED!\N");

	DIR->DIR_COUNT = 0;
	DIR->CUR_ENTRY = 0;
	DIR->MODE = (*I)->MODE;
	DIR->UID = (*I)->UID;
	DIR->GUID = (*I)->GID;
	DIR->MTIME = (*I)->TIME;
	DIR->XATTR = (*I)->XATTR;
	DIR->DIRS = NULL;

	IF ((*I)->DATA == 3)
		/*
		 * IF THE DIRECTORY IS EMPTY, SKIP THE UNNECESSARY
		 * LOOKUP_ENTRY, THIS FIXES THE CORNER CASE WITH
		 * COMPLETELY EMPTY FILESYSTEMS WHERE LOOKUP_ENTRY CORRECTLY
		 * RETURNING -1 IS INCORRECTLY TREATED AS AN ERROR
		 */
		RETURN DIR;

	START = SBLK.S.DIRECTORY_TABLE_START + (*I)->START;
	BYTES = LOOKUP_ENTRY(DIRECTORY_TABLE_HASH, START);

	IF(BYTES == -1)
		EXIT_UNSQUASH("SQUASHFS_OPENDIR: DIRECTORY BLOCK %D NOT "
			"FOUND!\N", BLOCK_START);

	BYTES += (*I)->OFFSET;
	SIZE = (*I)->DATA + BYTES - 3;

	WHILE(BYTES < SIZE) {			
		IF(SWAP) {
			SQUASHFS_DIR_HEADER_3 SDIRH;
			MEMCPY(&SDIRH, DIRECTORY_TABLE + BYTES, SIZEOF(SDIRH));
			SQUASHFS_SWAP_DIR_HEADER_3(&DIRH, &SDIRH);
		} ELSE
			MEMCPY(&DIRH, DIRECTORY_TABLE + BYTES, SIZEOF(DIRH));
	
		DIR_COUNT = DIRH.COUNT + 1;
		TRACE("SQUASHFS_OPENDIR: READ DIRECTORY HEADER @ BYTE POSITION "
			"%D, %D DIRECTORY ENTRIES\N", BYTES, DIR_COUNT);
		BYTES += SIZEOF(DIRH);

		/* DIR_COUNT SHOULD NEVER BE LARGER THAN SQUASHFS_DIR_COUNT */
		IF(DIR_COUNT > SQUASHFS_DIR_COUNT) {
			ERROR("FILE SYSTEM CORRUPTED: TOO MANY ENTRIES IN DIRECTORY\N");
			GOTO CORRUPTED;
		}

		WHILE(DIR_COUNT--) {
			IF(SWAP) {
				SQUASHFS_DIR_ENTRY_3 SDIRE;
				MEMCPY(&SDIRE, DIRECTORY_TABLE + BYTES,
					SIZEOF(SDIRE));
				SQUASHFS_SWAP_DIR_ENTRY_3(DIRE, &SDIRE);
			} ELSE
				MEMCPY(DIRE, DIRECTORY_TABLE + BYTES,
					SIZEOF(*DIRE));
			BYTES += SIZEOF(*DIRE);

			/* SIZE SHOULD NEVER BE SQUASHFS_NAME_LEN OR LARGER */
			IF(DIRE->SIZE >= SQUASHFS_NAME_LEN) {
				ERROR("FILE SYSTEM CORRUPTED: FILENAME TOO LONG\N");
				GOTO CORRUPTED;
			}

			MEMCPY(DIRE->NAME, DIRECTORY_TABLE + BYTES,
				DIRE->SIZE + 1);
			DIRE->NAME[DIRE->SIZE + 1] = '\0';
			TRACE("SQUASHFS_OPENDIR: DIRECTORY ENTRY %S, INODE "
				"%D:%D, TYPE %D\N", DIRE->NAME,
				DIRH.START_BLOCK, DIRE->OFFSET, DIRE->TYPE);
			IF((DIR->DIR_COUNT % DIR_ENT_SIZE) == 0) {
				NEW_DIR = REALLOC(DIR->DIRS, (DIR->DIR_COUNT +
					DIR_ENT_SIZE) * SIZEOF(STRUCT DIR_ENT));
				IF(NEW_DIR == NULL)
					EXIT_UNSQUASH("SQUASHFS_OPENDIR: "
						"REALLOC FAILED!\N");
				DIR->DIRS = NEW_DIR;
			}
			STRCPY(DIR->DIRS[DIR->DIR_COUNT].NAME, DIRE->NAME);
			DIR->DIRS[DIR->DIR_COUNT].START_BLOCK =
				DIRH.START_BLOCK;
			DIR->DIRS[DIR->DIR_COUNT].OFFSET = DIRE->OFFSET;
			DIR->DIRS[DIR->DIR_COUNT].TYPE = DIRE->TYPE;
			DIR->DIR_COUNT ++;
			BYTES += DIRE->SIZE + 1;
		}
	}

	RETURN DIR;

CORRUPTED:
	FREE(DIR->DIRS);
	FREE(DIR);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 292147_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID LINKRESOLVER::CHECK_FIELD_ACCESSABILITY(KLASS* REF_KLASS,
                                             KLASS* RESOLVED_KLASS,
                                             KLASS* SEL_KLASS,
                                             CONST FIELDDESCRIPTOR& FD,
                                             TRAPS) {
  BOOL CAN_ACCESS = REFLECTION::VERIFY_MEMBER_ACCESS(REF_KLASS,
                                                     RESOLVED_KLASS,
                                                     SEL_KLASS,
                                                     FD.ACCESS_FLAGS(),
                                                     TRUE, FALSE, CHECK);
  // ANY EXISTING EXCEPTIONS THAT MAY HAVE BEEN THROWN, FOR EXAMPLE LINKAGEERRORS
  // FROM NEST-HOST RESOLUTION, HAVE BEEN ALLOWED TO PROPAGATE.
  IF (!CAN_ACCESS) {
    BOOL SAME_MODULE = (SEL_KLASS->MODULE() == REF_KLASS->MODULE());
    RESOURCEMARK RM(THREAD);
    EXCEPTIONS::FTHROW(
      THREAD_AND_LOCATION,
      VMSYMBOLS::JAVA_LANG_ILLEGALACCESSERROR(),
      "CLASS %S TRIED TO ACCESS %S%SFIELD %S.%S (%S%S%S)",
      REF_KLASS->EXTERNAL_NAME(),
      FD.IS_PROTECTED() ? "PROTECTED " : "",
      FD.IS_PRIVATE()   ? "PRIVATE "   : "",
      SEL_KLASS->EXTERNAL_NAME(),
      FD.NAME()->AS_C_STRING(),
      (SAME_MODULE) ? REF_KLASS->JOINT_IN_MODULE_OF_LOADER(SEL_KLASS) : REF_KLASS->CLASS_IN_MODULE_OF_LOADER(),
      (SAME_MODULE) ? "" : "; ",
      (SAME_MODULE) ? "" : SEL_KLASS->CLASS_IN_MODULE_OF_LOADER()
    );
    RETURN;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 512525_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL BOOL WITH_SUBQUERY() CONST
  {
    RETURN (*REF)->WITH_SUBQUERY();
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 215549_CWE-189.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT UNLZW(IN, OUT)
    INT IN, OUT;    /* INPUT AND OUTPUT FILE DESCRIPTORS */
{
    REG2   CHAR_TYPE  *STACKP;
    REG3   CODE_INT   CODE;
    REG4   INT        FINCHAR;
    REG5   CODE_INT   OLDCODE;
    REG6   CODE_INT   INCODE;
    REG7   LONG       INBITS;
    REG8   LONG       POSBITS;
    REG9   INT        OUTPOS;
/*  REG10  INT        INSIZE; (GLOBAL) */
    REG11  UNSIGNED   BITMASK;
    REG12  CODE_INT   FREE_ENT;
    REG13  CODE_INT   MAXCODE;
    REG14  CODE_INT   MAXMAXCODE;
    REG15  INT        N_BITS;
    REG16  INT        RSIZE;

#IFDEF MAXSEG_64K
    TAB_PREFIX[0] = TAB_PREFIX0;
    TAB_PREFIX[1] = TAB_PREFIX1;
#ENDIF
    MAXBITS = GET_BYTE();
    BLOCK_MODE = MAXBITS & BLOCK_MODE;
    IF ((MAXBITS & LZW_RESERVED) != 0) {
	WARN((STDERR, "\N%S: %S: WARNING, UNKNOWN FLAGS 0X%X\N",
	      PROGRAM_NAME, IFNAME, MAXBITS & LZW_RESERVED));
    }
    MAXBITS &= BIT_MASK;
    MAXMAXCODE = MAXCODE(MAXBITS);

    IF (MAXBITS > BITS) {
	FPRINTF(STDERR,
		"\N%S: %S: COMPRESSED WITH %D BITS, CAN ONLY HANDLE %D BITS\N",
		PROGRAM_NAME, IFNAME, MAXBITS, BITS);
	EXIT_CODE = ERROR;
	RETURN ERROR;
    }
    RSIZE = INSIZE;
    MAXCODE = MAXCODE(N_BITS = INIT_BITS)-1;
    BITMASK = (1<<N_BITS)-1;
    OLDCODE = -1;
    FINCHAR = 0;
    OUTPOS = 0;
    POSBITS = INPTR<<3;

    FREE_ENT = ((BLOCK_MODE) ? FIRST : 256);

    CLEAR_TAB_PREFIXOF(); /* INITIALIZE THE FIRST 256 ENTRIES IN THE TABLE. */

    FOR (CODE = 255 ; CODE >= 0 ; --CODE) {
	TAB_SUFFIXOF(CODE) = (CHAR_TYPE)CODE;
    }
    DO {
	REG1 INT I;
	INT  E;
	INT  O;

    RESETBUF:
	E = INSIZE-(O = (POSBITS>>3));

	FOR (I = 0 ; I < E ; ++I) {
	    INBUF[I] = INBUF[I+O];
	}
	INSIZE = E;
	POSBITS = 0;

	IF (INSIZE < INBUF_EXTRA) {
	    RSIZE = READ_BUFFER (IN, (CHAR *) INBUF + INSIZE, INBUFSIZ);
	    IF (RSIZE == -1) {
		READ_ERROR();
	    }
	    INSIZE += RSIZE;
	    BYTES_IN += (OFF_T)RSIZE;
	}
	INBITS = ((RSIZE != 0) ? ((LONG)INSIZE - INSIZE%N_BITS)<<3 :
		  ((LONG)INSIZE<<3)-(N_BITS-1));

	WHILE (INBITS > POSBITS) {
	    IF (FREE_ENT > MAXCODE) {
		POSBITS = ((POSBITS-1) +
			   ((N_BITS<<3)-(POSBITS-1+(N_BITS<<3))%(N_BITS<<3)));
		++N_BITS;
		IF (N_BITS == MAXBITS) {
		    MAXCODE = MAXMAXCODE;
		} ELSE {
		    MAXCODE = MAXCODE(N_BITS)-1;
		}
		BITMASK = (1<<N_BITS)-1;
		GOTO RESETBUF;
	    }
	    INPUT(INBUF,POSBITS,CODE,N_BITS,BITMASK);
	    TRACEV((STDERR, "%D ", CODE));

	    IF (OLDCODE == -1) {
		IF (256 <= CODE)
		  GZIP_ERROR ("CORRUPT INPUT.");
		OUTBUF[OUTPOS++] = (CHAR_TYPE)(FINCHAR = (INT)(OLDCODE=CODE));
		CONTINUE;
	    }
	    IF (CODE == CLEAR && BLOCK_MODE) {
		CLEAR_TAB_PREFIXOF();
		FREE_ENT = FIRST - 1;
		POSBITS = ((POSBITS-1) +
			   ((N_BITS<<3)-(POSBITS-1+(N_BITS<<3))%(N_BITS<<3)));
		MAXCODE = MAXCODE(N_BITS = INIT_BITS)-1;
		BITMASK = (1<<N_BITS)-1;
		GOTO RESETBUF;
	    }
	    INCODE = CODE;
	    STACKP = DE_STACK;

	    IF (CODE >= FREE_ENT) { /* SPECIAL CASE FOR KWKWK STRING. */
		IF (CODE > FREE_ENT) {
#IFDEF DEBUG
		    CHAR_TYPE *P;

		    POSBITS -= N_BITS;
		    P = &INBUF[POSBITS>>3];
		    FPRINTF(STDERR,
			    "CODE:%LD FREE_ENT:%LD N_BITS:%D INSIZE:%U\N",
			    CODE, FREE_ENT, N_BITS, INSIZE);
		    FPRINTF(STDERR,
			    "POSBITS:%LD INBUF:%02X %02X %02X %02X %02X\N",
			    POSBITS, P[-1],P[0],P[1],P[2],P[3]);
#ENDIF
		    IF (!TEST && OUTPOS > 0) {
			WRITE_BUF(OUT, (CHAR*)OUTBUF, OUTPOS);
			BYTES_OUT += (OFF_T)OUTPOS;
		    }
		    GZIP_ERROR (TO_STDOUT
				? "CORRUPT INPUT."
				: "CORRUPT INPUT. USE ZCAT TO RECOVER SOME DATA.");
		}
		*--STACKP = (CHAR_TYPE)FINCHAR;
		CODE = OLDCODE;
	    }

	    WHILE ((CMP_CODE_INT)CODE >= (CMP_CODE_INT)256) {
		/* GENERATE OUTPUT CHARACTERS IN REVERSE ORDER */
		*--STACKP = TAB_SUFFIXOF(CODE);
		CODE = TAB_PREFIXOF(CODE);
	    }
	    *--STACKP =	(CHAR_TYPE)(FINCHAR = TAB_SUFFIXOF(CODE));

	    /* AND PUT THEM OUT IN FORWARD ORDER */
	    {
		REG1 INT	I;

		IF (OUTPOS+(I = (DE_STACK-STACKP)) >= OUTBUFSIZ) {
		    DO {
			IF (I > OUTBUFSIZ-OUTPOS) I = OUTBUFSIZ-OUTPOS;

			IF (I > 0) {
			    MEMCPY(OUTBUF+OUTPOS, STACKP, I);
			    OUTPOS += I;
			}
			IF (OUTPOS >= OUTBUFSIZ) {
			    IF (!TEST) {
				WRITE_BUF(OUT, (CHAR*)OUTBUF, OUTPOS);
				BYTES_OUT += (OFF_T)OUTPOS;
			    }
			    OUTPOS = 0;
			}
			STACKP+= I;
		    } WHILE ((I = (DE_STACK-STACKP)) > 0);
		} ELSE {
		    MEMCPY(OUTBUF+OUTPOS, STACKP, I);
		    OUTPOS += I;
		}
	    }

	    IF ((CODE = FREE_ENT) < MAXMAXCODE) { /* GENERATE THE NEW ENTRY. */

		TAB_PREFIXOF(CODE) = (UNSIGNED SHORT)OLDCODE;
		TAB_SUFFIXOF(CODE) = (CHAR_TYPE)FINCHAR;
		FREE_ENT = CODE+1;
	    }
	    OLDCODE = INCODE;	/* REMEMBER PREVIOUS CODE.	*/
	}
    } WHILE (RSIZE != 0);

    IF (!TEST && OUTPOS > 0) {
	WRITE_BUF(OUT, (CHAR*)OUTBUF, OUTPOS);
	BYTES_OUT += (OFF_T)OUTPOS;
    }
    RETURN OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 207700_CWE-362.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TERMINALUSERINFO USERTERMINALROUTER::GETINFOFORID(CONST STRING &ID) {
  AUTO IT = IDINFOMAP.FIND(ID);
  IF (IT == IDINFOMAP.END()) {
    STFATAL << " TRIED TO READ FROM AN ID THAT NO LONGER EXISTS";
  }
  RETURN IT->SECOND;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 204016_CWE-200.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC STRUCT DIR *SQUASHFS_OPENDIR(UNSIGNED INT BLOCK_START, UNSIGNED INT OFFSET,
	STRUCT INODE **I)
{
	SQUASHFS_DIR_HEADER_2 DIRH;
	CHAR BUFFER[SIZEOF(SQUASHFS_DIR_ENTRY_2) + SQUASHFS_NAME_LEN + 1]
		__ATTRIBUTE__((ALIGNED));
	SQUASHFS_DIR_ENTRY_2 *DIRE = (SQUASHFS_DIR_ENTRY_2 *) BUFFER;
	LONG LONG START;
	INT BYTES = 0;
	INT DIR_COUNT, SIZE, RES;
	STRUCT DIR_ENT *ENT, *CUR_ENT = NULL;
	STRUCT DIR *DIR;

	TRACE("SQUASHFS_OPENDIR: INODE START BLOCK %D, OFFSET %D\N",
		BLOCK_START, OFFSET);

	*I = READ_INODE(BLOCK_START, OFFSET);

	DIR = MALLOC(SIZEOF(STRUCT DIR));
	IF(DIR == NULL)
		MEM_ERROR();

	DIR->DIR_COUNT = 0;
	DIR->CUR_ENTRY = NULL;
	DIR->MODE = (*I)->MODE;
	DIR->UID = (*I)->UID;
	DIR->GUID = (*I)->GID;
	DIR->MTIME = (*I)->TIME;
	DIR->XATTR = (*I)->XATTR;
	DIR->DIRS = NULL;

	IF ((*I)->DATA == 0)
		/*
		 * IF THE DIRECTORY IS EMPTY, SKIP THE UNNECESSARY
		 * LOOKUP_ENTRY, THIS FIXES THE CORNER CASE WITH
		 * COMPLETELY EMPTY FILESYSTEMS WHERE LOOKUP_ENTRY CORRECTLY
		 * RETURNING -1 IS INCORRECTLY TREATED AS AN ERROR
		 */
		RETURN DIR;

	START = SBLK.S.DIRECTORY_TABLE_START + (*I)->START;
	OFFSET = (*I)->OFFSET;
	SIZE = (*I)->DATA + BYTES;

	WHILE(BYTES < SIZE) {
		IF(SWAP) {
			SQUASHFS_DIR_HEADER_2 SDIRH;
			RES = READ_DIRECTORY_DATA(&SDIRH, &START, &OFFSET, SIZEOF(SDIRH));
			IF(RES)
				SQUASHFS_SWAP_DIR_HEADER_2(&DIRH, &SDIRH);
		} ELSE
			RES = READ_DIRECTORY_DATA(&DIRH, &START, &OFFSET, SIZEOF(DIRH));

		IF(RES == FALSE)
			GOTO CORRUPTED;

		DIR_COUNT = DIRH.COUNT + 1;
		TRACE("SQUASHFS_OPENDIR: READ DIRECTORY HEADER @ BYTE POSITION "
			"%D, %D DIRECTORY ENTRIES\N", BYTES, DIR_COUNT);
		BYTES += SIZEOF(DIRH);

		/* DIR_COUNT SHOULD NEVER BE LARGER THAN SQUASHFS_DIR_COUNT */
		IF(DIR_COUNT > SQUASHFS_DIR_COUNT) {
			ERROR("FILE SYSTEM CORRUPTED: TOO MANY ENTRIES IN DIRECTORY\N");
			GOTO CORRUPTED;
		}

		WHILE(DIR_COUNT--) {
			IF(SWAP) {
				SQUASHFS_DIR_ENTRY_2 SDIRE;
				RES = READ_DIRECTORY_DATA(&SDIRE, &START,
					&OFFSET, SIZEOF(SDIRE));
				IF(RES)
					SQUASHFS_SWAP_DIR_ENTRY_2(DIRE, &SDIRE);
			} ELSE
				RES = READ_DIRECTORY_DATA(DIRE, &START,
					&OFFSET, SIZEOF(*DIRE));

			IF(RES == FALSE)
				GOTO CORRUPTED;

			BYTES += SIZEOF(*DIRE);

			/* SIZE SHOULD NEVER BE SQUASHFS_NAME_LEN OR LARGER */
			IF(DIRE->SIZE >= SQUASHFS_NAME_LEN) {
				ERROR("FILE SYSTEM CORRUPTED: FILENAME TOO LONG\N");
				GOTO CORRUPTED;
			}

			RES = READ_DIRECTORY_DATA(DIRE->NAME, &START, &OFFSET,
								DIRE->SIZE + 1);

			IF(RES == FALSE)
				GOTO CORRUPTED;

			DIRE->NAME[DIRE->SIZE + 1] = '\0';

			/* CHECK NAME FOR INVALID CHARACTERS (I.E /, ., ..) */
			IF(CHECK_NAME(DIRE->NAME, DIRE->SIZE + 1) == FALSE) {
				ERROR("FILE SYSTEM CORRUPTED: INVALID CHARACTERS IN NAME\N");
				GOTO CORRUPTED;
			}

			TRACE("SQUASHFS_OPENDIR: DIRECTORY ENTRY %S, INODE "
				"%D:%D, TYPE %D\N", DIRE->NAME,
				DIRH.START_BLOCK, DIRE->OFFSET, DIRE->TYPE);

			ENT = MALLOC(SIZEOF(STRUCT DIR_ENT));
			IF(ENT == NULL)
				MEM_ERROR();

			ENT->NAME = STRDUP(DIRE->NAME);
			ENT->START_BLOCK = DIRH.START_BLOCK;
			ENT->OFFSET = DIRE->OFFSET;
			ENT->TYPE = DIRE->TYPE;
			ENT->NEXT = NULL;
			IF(CUR_ENT == NULL)
				DIR->DIRS = ENT;
			ELSE
				CUR_ENT->NEXT = ENT;
			CUR_ENT = ENT;
			DIR->DIR_COUNT ++;
			BYTES += DIRE->SIZE + 1;
		}
	}

	RETURN DIR;

CORRUPTED:
	SQUASHFS_CLOSEDIR(DIR);
	RETURN NULL;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 206771_CWE-191.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL DL_DXF::HANDLELWPOLYLINEDATA(DL_CREATIONINTERFACE* /*CREATIONINTERFACE*/) {
    // ALLOCATE LWPOLYLINE VERTICES (GROUP CODE 90):
    IF (GROUPCODE==90) {
        MAXVERTICES = TOINT(GROUPVALUE);
        IF (MAXVERTICES>0) {
            IF (VERTICES!=NULL) {
                DELETE[] VERTICES;
            }
            VERTICES = NEW DOUBLE[4*MAXVERTICES];
            FOR (INT I=0; I<MAXVERTICES; ++I) {
                VERTICES[I*4] = 0.0;
                VERTICES[I*4+1] = 0.0;
                VERTICES[I*4+2] = 0.0;
                VERTICES[I*4+3] = 0.0;
            }
        }
        VERTEXINDEX=-1;
        RETURN TRUE;
    }

    // PROCESS LWPOLYLINES VERTICES (GROUP CODES 10/20/30/42):
    ELSE IF (GROUPCODE==10 || GROUPCODE==20 ||
             GROUPCODE==30 || GROUPCODE==42) {

        IF (VERTEXINDEX<MAXVERTICES-1 && GROUPCODE==10) {
            VERTEXINDEX++;
        }

        IF (GROUPCODE<=30) {
            IF (VERTEXINDEX>=0 && VERTEXINDEX<MAXVERTICES) {
                VERTICES[4*VERTEXINDEX + (GROUPCODE/10-1)] = TOREAL(GROUPVALUE);
            }
        } ELSE IF (GROUPCODE==42 && VERTEXINDEX<MAXVERTICES) {
            VERTICES[4*VERTEXINDEX + 3] = TOREAL(GROUPVALUE);
        }
        RETURN TRUE;
    }
    RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197247_CWE-369.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS SHAPEREFINER::INFERSHAPESFORFUNCTIONSUBNODE(
    CONST NODE* NODE, INFERENCECONTEXT* OUTER_CONTEXT) {
  TF_RETURN_IF_ERROR(ADDNODEINTERNAL(NODE, OUTER_CONTEXT));
  INFERENCECONTEXT* NODE_CONTEXT = CHECK_NOTNULL(GETCONTEXT(NODE));

  IF (STRINGPIECE(NODE->TYPE_STRING()) == KARGOP) {
    // HANDLE SPECIAL NODE: FUNCTION INPUT.
    // SHAPES FOR THESE NODES ARE PROVIDED IN THE OUTER INFERENCE
    // CONTEXT.

    INT INDEX;
    TF_RETURN_IF_ERROR(GETNODEATTR(ATTRSLICE(NODE->DEF()), "INDEX", &INDEX));

    IF (INDEX < 0 || OUTER_CONTEXT->NUM_INPUTS() <= INDEX) {
      RETURN ERRORS::INTERNAL(
          "FUNCTION INSTANTIATION INCLUDED INVALID INPUT INDEX: ", INDEX,
          " NOT IN [0, ", OUTER_CONTEXT->NUM_INPUTS(), ").");
    }

    // TODO(B/134547156): TEMPORARY WORKAROUND. IF INPUT SHAPE HANDLE IS NOT SET
    // IN OUTER CONTEXT, SET _ARG NODE OUTPUT SHAPE TO UNKNOWN.
    IF (OUTER_CONTEXT->INPUT(INDEX).SAMEHANDLE(SHAPEHANDLE())) {
      VLOG(1) << "FUNCTION INSTANTIATION HAS UNDEFINED INPUT SHAPE AT "
              << "INDEX: " << INDEX << " IN THE OUTER INFERENCE CONTEXT.";
      NODE_CONTEXT->SET_OUTPUT(0, NODE_CONTEXT->UNKNOWNSHAPE());
    } ELSE {
      NODE_CONTEXT->SET_OUTPUT(0, OUTER_CONTEXT->INPUT(INDEX));
    }

    AUTO* RESOURCE = OUTER_CONTEXT->INPUT_HANDLE_SHAPES_AND_TYPES(INDEX);
    IF (RESOURCE) {
      NODE_CONTEXT->SET_OUTPUT_HANDLE_SHAPES_AND_TYPES(0, *RESOURCE);
    }
  } ELSE IF (STRINGPIECE(NODE->TYPE_STRING()) == KRETVALOP) {
    // HANDLE SPECIAL NODE: FUNCTION OUTPUT.
    // SHAPES INFERRED FOR THESE NODES GO INTO THE OUTER INFERENCE
    // CONTEXT.

    INT INDEX;
    TF_RETURN_IF_ERROR(GETNODEATTR(ATTRSLICE(NODE->DEF()), "INDEX", &INDEX));

    IF (INDEX < 0 || OUTER_CONTEXT->NUM_OUTPUTS() <= INDEX) {
      RETURN ERRORS::INTERNAL(
          "FUNCTION INSTANTIATION INCLUDED INVALID OUTPUT INDEX: ", INDEX,
          " NOT IN [0, ", OUTER_CONTEXT->NUM_OUTPUTS(), ").");
    }

    // OUTER_CONTEXT OUTLIVES NODE_CONTEXT, THEREFORE WE NEED TO CREATE
    // A NEW SHAPE HANDLE OWNED BY OUTER_CONTEXT INSTEAD.
    SHAPEHANDLE HANDLE;
    TENSORSHAPEPROTO PROTO;
    NODE_CONTEXT->SHAPEHANDLETOPROTO(NODE_CONTEXT->INPUT(0), &PROTO);
    TF_RETURN_IF_ERROR(OUTER_CONTEXT->MAKESHAPEFROMSHAPEPROTO(PROTO, &HANDLE));
    OUTER_CONTEXT->SET_OUTPUT(INDEX, HANDLE);

    AUTO* RESOURCE = NODE_CONTEXT->INPUT_HANDLE_SHAPES_AND_TYPES(0);
    IF (RESOURCE) {
      OUTER_CONTEXT->SET_OUTPUT_HANDLE_SHAPES_AND_TYPES(INDEX, *RESOURCE);
    }
  }

  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 387857_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID INSTANCEKLASS::REMOVE_DEPENDENT_NMETHOD(NMETHOD* NM, BOOL DELETE_IMMEDIATELY) {
  DEPENDENCIES().REMOVE_DEPENDENT_NMETHOD(NM, DELETE_IMMEDIATELY);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 175684_NOT_VULNERABLE.CPP
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VIRTUAL VOID CONNECTTOCELLULARNETWORK(CONST CELLULARNETWORK* NETWORK) {
    DCHECK(NETWORK);
    IF (!ENSURECROSLOADED())
      RETURN;
    IF (NETWORK && CONNECTTONETWORK(NETWORK->SERVICE_PATH().C_STR(), NULL)) {
      CELLULARNETWORK* CELLULAR = GETWIRELESSNETWORKBYPATH(
          CELLULAR_NETWORKS_, NETWORK->SERVICE_PATH());
      IF (CELLULAR) {
        CELLULAR->SET_CONNECTING(TRUE);
        CELLULAR_ = CELLULAR;
      }
      NOTIFYNETWORKMANAGERCHANGED();
    }
  }

ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197326_CWE-703.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  STATIC STATUS PARSEEQUATION(CONST STRING& EQUATION,
                              OPERANDLABELS* INPUT_LABELS,
                              LABELS* OUTPUT_LABELS,
                              STD::VECTOR<DIMENSIONTYPE>* LABEL_TYPES,
                              OPERANDLABELCOUNTS* INPUT_LABEL_COUNTS,
                              LABELCOUNTS* OUTPUT_LABEL_COUNTS,
                              GTL::INLINEDVECTOR<BOOL, 2>* INPUT_HAS_ELLIPSIS,
                              BOOL* OUTPUT_HAS_ELLIPSIS) {
    GTL::INLINEDVECTOR<STRING, 2> INPUT_STR;
    STRING OUTPUT_STR;
    TF_RETURN_IF_ERROR(PARSEEINSUMEQUATION(EQUATION, &INPUT_STR, &OUTPUT_STR));

    // TEMPORARY MAP FROM SINGLE CHARACTER LABELS TO (CONSECUTIVE) INTEGER
    // LABELS.
    ABSL::FLAT_HASH_MAP<CHAR, INT> LABEL_MAPPING;
    INT NUM_INPUTS = INPUT_STR.SIZE();
    INPUT_LABELS->RESIZE(NUM_INPUTS);

    // MAP FROM SINGLE CHARACTERS TO INTEGER LABELS.
    FOR (INT I = 0; I < NUM_INPUTS; ++I) {
      MAPTOLABELS(INPUT_STR[I], &INPUT_LABELS->AT(I), &LABEL_MAPPING);
    }
    MAPTOLABELS(OUTPUT_STR, OUTPUT_LABELS, &LABEL_MAPPING);

    // COMPUTE COUNTS FOR INPUT AND OUTPUT LABELS.
    INT NUM_LABELS = LABEL_MAPPING.SIZE();
    INPUT_LABEL_COUNTS->RESIZE(NUM_INPUTS);
    INPUT_HAS_ELLIPSIS->RESIZE(NUM_INPUTS);
    FOR (INT I = 0; I < NUM_INPUTS; ++I) {
      INPUT_LABEL_COUNTS->AT(I).RESIZE(NUM_LABELS);
      FOR (CONST INT LABEL : INPUT_LABELS->AT(I)) {
        IF (LABEL != KELLIPSISLABEL)
          INPUT_LABEL_COUNTS->AT(I)[LABEL] += 1;
        ELSE
          INPUT_HAS_ELLIPSIS->AT(I) = TRUE;
      }
    }
    OUTPUT_LABEL_COUNTS->RESIZE(NUM_LABELS);
    FOR (CONST INT LABEL : *OUTPUT_LABELS) {
      IF (LABEL != KELLIPSISLABEL)
        OUTPUT_LABEL_COUNTS->AT(LABEL) += 1;
      ELSE
        *OUTPUT_HAS_ELLIPSIS = TRUE;
    }

    // MAP EACH LABEL TO A UNIQUE DIMENSIONTYPE.
    LABEL_TYPES->RESIZE(NUM_LABELS);
    FOR (INT LABEL = 0; LABEL < NUM_LABELS; ++LABEL) {
      IF (LABEL == KELLIPSISLABEL) CONTINUE;
      BOOL REMOVED = (*OUTPUT_LABEL_COUNTS)[LABEL] == 0;
      BOOL UNIQUE = NUM_INPUTS == 1 || (*INPUT_LABEL_COUNTS)[0][LABEL] == 0 ||
                    (*INPUT_LABEL_COUNTS)[1][LABEL] == 0;
      (*LABEL_TYPES)[LABEL] = GETDIMENSIONTYPE(REMOVED, UNIQUE);
    }
    RETURN STATUS::OK();
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195291_CWE-908.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR& RHS = CONTEXT->INPUT(1);

    // WE ALWAYS RETURN THE INPUT REF.
    CONTEXT->FORWARD_REF_INPUT_TO_REF_OUTPUT(0, 0);

    // WE CAN'T ALWAYS KNOW HOW THIS VALUE WILL BE USED DOWNSTREAM, SO MAKE
    // CONSERVATIVE ASSUMPTIONS IN SPECIFYING CONSTRAINTS ON THE MEMORY
    // ALLOCATION ATTRIBUTES, UNLESS THE GRAPPLER GRAPH ANALYSIS DETERMINED THAT
    // IT WAS SAFE NOT TO.
    ALLOCATORATTRIBUTES ATTR;
    IF (!RELAX_CONSTRAINTS_) {
      ATTR.SET_GPU_COMPATIBLE(TRUE);
      ATTR.SET_NIC_COMPATIBLE(TRUE);
    }

    {
      MUTEX_LOCK L(*CONTEXT->INPUT_REF_MUTEX(0));
      CONST TENSOR& OLD_LHS = CONTEXT->MUTABLE_INPUT(0, /* LOCK_HELD */ TRUE);
      CONST BOOL SAME_SHAPE = OLD_LHS.SHAPE().ISSAMESIZE(RHS.SHAPE());
      IF (VALIDATE_SHAPE_) {
        OP_REQUIRES(CONTEXT, SAME_SHAPE,
                    ERRORS::INVALIDARGUMENT(
                        "ASSIGN REQUIRES SHAPES OF BOTH TENSORS TO MATCH. "
                        "LHS SHAPE= ",
                        OLD_LHS.SHAPE().DEBUGSTRING(),
                        " RHS SHAPE= ", RHS.SHAPE().DEBUGSTRING()));
      }

      // IN THE CODE BELOW WE TRY TO MINIMIZE THE AMOUNT OF MEMORY ALLOCATION
      // AND COPYING BY TRYING THE FOLLOWING TWO SHORTCUTS:
      // 1. IF THE LHS IS INITIALIZED AND HAS THE SAME NUMBER OF ELEMENTS AS
      //    THE RHS WE CAN AVOID A MEMORY ALLOCATION.
      // 2. IF WE CAN REUSE THE RHS BUFFER WE AVOID BOTH A MEMORY ALLOCATION
      //    AND COPYING.

      // 1. TRY TO COPY INTO AN EXISTING BUFFER.
      IF (OLD_LHS.ISINITIALIZED() &&
          OLD_LHS.SHAPE().NUM_ELEMENTS() == RHS.SHAPE().NUM_ELEMENTS()) {
        // THE EXISTING LHS TENSOR HAS ALREADY BEEN INITIALIZED AND THE RIGHT
        // HAND SIDE CAN FIT IN THE UNDERLYING BUFFER.
        TENSOR RESHAPED_OLD_LHS;
        IF (SAME_SHAPE) {
          RESHAPED_OLD_LHS = OLD_LHS;
        } ELSE {
          CHECK(RESHAPED_OLD_LHS.COPYFROM(OLD_LHS, RHS.SHAPE()));
          CONTEXT->REPLACE_REF_INPUT(0, RESHAPED_OLD_LHS,
                                     /* LOCK_HELD */ TRUE);
        }
        IF (USE_EXCLUSIVE_LOCK_) {
          COPY(CONTEXT, &RESHAPED_OLD_LHS, RHS);
          RETURN;
        }
      } ELSE {
        // 2. TRY TO REUSE THE RHS.
        STD::UNIQUE_PTR<TENSOR> INPUT_ALIAS = CONTEXT->FORWARD_INPUT(
            1, OPKERNELCONTEXT::PARAMS::KNORESERVATION /*OUTPUT_INDEX*/,
            RHS.DTYPE(), RHS.SHAPE(), DEVICE_MEMORY, ATTR);
        IF (INPUT_ALIAS != NULLPTR) {
          // UPDATE THE REF TO POINT TO THE NEW BUFFER.
          CONTEXT->REPLACE_REF_INPUT(0, *INPUT_ALIAS, /* LOCK_HELD */ TRUE);
          RETURN;
        }

        // OTHERWISE, CREATE A NEW TENSOR WHOSE SHAPE MATCHES THE
        // RIGHT HAND SIDE, HAND OFF TO LHS AND COPY THE RHS INTO IT.
        TENSOR COPY_TENSOR;
        OP_REQUIRES_OK(CONTEXT,
                       CONTEXT->ALLOCATE_TEMP(OLD_LHS.DTYPE(), RHS.SHAPE(),
                                              &COPY_TENSOR, ATTR));
        // WE TRACK MEMORY OF VARIABLES IN VARIABLE OPS INSTEAD OF IN THIS
        // ASSIGN OP.
        CONTEXT->CLEAR_RECORDED_MEMORY();
        CONTEXT->REPLACE_REF_INPUT(0, COPY_TENSOR, /* LOCK_HELD */ TRUE);
        IF (USE_EXCLUSIVE_LOCK_) {
          COPY(CONTEXT, &COPY_TENSOR, RHS);
          RETURN;
        }
      }
    }

    // THE TENSOR HAS ALREADY BEEN INITIALIZED AND THE RIGHT HAND SIDE
    // MATCHES THE LEFT HAND SIDE'S SHAPE. WE HAVE BEEN TOLD TO DO THE
    // COPY OUTSIDE THE LOCK.
    TENSOR OLD_UNLOCKED_LHS = CONTEXT->MUTABLE_INPUT(0, /* LOCK_HELD */ FALSE);
    COPY(CONTEXT, &OLD_UNLOCKED_LHS, RHS);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252453_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MZ_UINT MZ_ZIP_READER_GET_FILENAME(MZ_ZIP_ARCHIVE *PZIP, MZ_UINT FILE_INDEX,
                                   CHAR *PFILENAME, MZ_UINT FILENAME_BUF_SIZE) {
  MZ_UINT N;
  CONST MZ_UINT8 *P = MZ_ZIP_READER_GET_CDH(PZIP, FILE_INDEX);
  IF (!P) {
    IF (FILENAME_BUF_SIZE) PFILENAME[0] = '\0';
    RETURN 0;
  }
  N = MZ_READ_LE16(P + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  IF (FILENAME_BUF_SIZE) {
    N = MZ_MIN(N, FILENAME_BUF_SIZE - 1);
    MEMCPY(PFILENAME, P + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, N);
    PFILENAME[N] = '\0';
  }
  RETURN N + 1;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197801_CWE-345.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL TENSORSLICEREADER::COPYSLICEDATA(CONST STRING& NAME,
                                      CONST TENSORSLICE& SLICE, T* DATA) CONST {
  STD::VECTOR<STD::PAIR<TENSORSLICE, STRING>> DETAILS;
  CONST TENSORSLICESET* TSS;
  {
    MUTEX_LOCK L(MU_);
    TSS = FINDTENSORSLICE(NAME, SLICE, &DETAILS);
    IF (!TSS && !ALL_SHARDS_LOADED_) {
      VLOG(1) << "DID NOT FIND SLICE IN PREFERRED SHARD, LOADING ALL SHARDS."
              << NAME << ": " << SLICE.DEBUGSTRING();
      LOADALLSHARDS();
      TSS = FINDTENSORSLICE(NAME, SLICE, &DETAILS);
    }
    IF (!TSS) {
      // NO SUCH TENSOR
      RETURN FALSE;
    }
  }
  // WE HAVE THE DATA -- COPY IT OVER.
  STRING VALUE;
  FOR (CONST AUTO& X : DETAILS) {
    CONST TENSORSLICE& SLICE_S = X.FIRST;
    CONST STRING& FNAME = X.SECOND;
    INT IDX = GTL::FINDWITHDEFAULT(FNAME_TO_INDEX_, FNAME, -1);
    CHECK_GE(IDX, 0) << "FAILED TO FIND THE INDEX FOR FILENAME " << FNAME;
    // WE READ A RECORD IN THE CORRESPONDING SSTABLE
    CONST STRING KEY = ENCODETENSORNAMESLICE(NAME, SLICE_S);
    IF (!SSS_[IDX]->GET(KEY, &VALUE)) {
      VLOG(1) << "FAILED TO SEEK TO THE RECORD FOR TENSOR " << NAME
              << ", SLICE " << SLICE_S.DEBUGSTRING()
              << ": COMPUTED KEY = " << KEY;
      RETURN FALSE;
    }
    SAVEDTENSORSLICES STS;
    IF (!PARSEPROTOUNLIMITED(&STS, VALUE)) {
      VLOG(1) << "FAILED TO PARSE THE RECORD FOR TENSOR " << NAME << ", SLICE "
              << SLICE_S.DEBUGSTRING() << ": COMPUTED KEY = " << KEY;
      RETURN FALSE;
    }
    COPYDATAFROMTENSORSLICETOTENSORSLICE(
        TSS->SHAPE(), SLICE_S, SLICE,
        CHECKPOINT::TENSORPROTODATA<T>(STS.DATA().DATA()), DATA);
  }
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 205736_CWE-834.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE VOID FUSE_MAKE_BAD(STRUCT INODE *INODE)
{
	SET_BIT(FUSE_I_BAD, &GET_FUSE_INODE(INODE)->STATE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 264370_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE CONST INT32* TENSORPROTODATA<QINT32>(CONST TENSORPROTO& T) {
  STATIC_ASSERT(SAVETYPETRAITS<QINT32>::SUPPORTED,
                "SPECIFIED TYPE QINT32 NOT SUPPORTED FOR RESTORE");
  RETURN REINTERPRET_CAST<CONST INT32*>(T.INT_VAL().DATA());
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 314475_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL FNAME(IS_BAD_MT_XWR)(STRUCT RSVD_BITS_VALIDATE *RSVD_CHECK, U64 GPTE)
{
#IF PTTYPE != PTTYPE_EPT
	RETURN FALSE;
#ELSE
	RETURN __IS_BAD_MT_XWR(RSVD_CHECK, GPTE);
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252345_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC UNSIGNED INT READUINT(CONST CHAR BUF[4]) {
  CONST UNSIGNED CHAR *B = (CONST UNSIGNED CHAR *)BUF;

  RETURN (B[0] & 0X000000FF) | ((B[1] << 8) & 0X0000FF00) |
         ((B[2] << 16) & 0X00FF0000) | ((B[3] << 24) & 0XFF000000);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252455_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MZ_FORCEINLINE VOID MZ_ZIP_ARRAY_CLEAR(MZ_ZIP_ARCHIVE *PZIP,
                                              MZ_ZIP_ARRAY *PARRAY) {
  PZIP->M_PFREE(PZIP->M_PALLOC_OPAQUE, PARRAY->M_P);
  MEMSET(PARRAY, 0, SIZEOF(MZ_ZIP_ARRAY));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197024_CWE-787.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& IN0 = CTX->INPUT(0);
    CONST TENSOR& IN1 = CTX->INPUT(1);
    AUTO IN0_FLAT = IN0.FLAT<TIN>();
    AUTO IN1_FLAT = IN1.FLAT<TIN>();
    CONST DEVICE& EIGEN_DEVICE = CTX->EIGEN_DEVICE<DEVICE>();

    TENSOR* OUT = NULLPTR;
    IF (STD::IS_SAME<TIN, TOUT>::VALUE) {
      OP_REQUIRES_OK(CTX, CTX->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                              {0, 1}, 0, IN0.SHAPE(), &OUT));
    } ELSE {
      OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(0, IN0.SHAPE(), &OUT));
    }
    AUTO OUT_FLAT = OUT->FLAT<TOUT>();
    FUNCTOR::SIMPLEBINARYFUNCTOR<DEVICE, FUNCTOR>()(EIGEN_DEVICE, OUT_FLAT,
                                                    IN0_FLAT, IN1_FLAT);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 201006_CWE-416.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT FNAME(CMPXCHG_GPTE)(STRUCT KVM_VCPU *VCPU, STRUCT KVM_MMU *MMU,
			       PT_ELEMENT_T __USER *PTEP_USER, UNSIGNED INDEX,
			       PT_ELEMENT_T ORIG_PTE, PT_ELEMENT_T NEW_PTE)
{
	INT NPAGES;
	PT_ELEMENT_T RET;
	PT_ELEMENT_T *TABLE;
	STRUCT PAGE *PAGE;

	NPAGES = GET_USER_PAGES_FAST((UNSIGNED LONG)PTEP_USER, 1, FOLL_WRITE, &PAGE);
	IF (LIKELY(NPAGES == 1)) {
		TABLE = KMAP_ATOMIC(PAGE);
		RET = CMPXCHG(&TABLE[INDEX], ORIG_PTE, NEW_PTE);
		KUNMAP_ATOMIC(TABLE);

		KVM_RELEASE_PAGE_DIRTY(PAGE);
	} ELSE {
		STRUCT VM_AREA_STRUCT *VMA;
		UNSIGNED LONG VADDR = (UNSIGNED LONG)PTEP_USER & PAGE_MASK;
		UNSIGNED LONG PFN;
		UNSIGNED LONG PADDR;

		MMAP_READ_LOCK(CURRENT->MM);
		VMA = FIND_VMA_INTERSECTION(CURRENT->MM, VADDR, VADDR + PAGE_SIZE);
		IF (!VMA || !(VMA->VM_FLAGS & VM_PFNMAP)) {
			MMAP_READ_UNLOCK(CURRENT->MM);
			RETURN -EFAULT;
		}
		PFN = ((VADDR - VMA->VM_START) >> PAGE_SHIFT) + VMA->VM_PGOFF;
		PADDR = PFN << PAGE_SHIFT;
		TABLE = MEMREMAP(PADDR, PAGE_SIZE, MEMREMAP_WB);
		IF (!TABLE) {
			MMAP_READ_UNLOCK(CURRENT->MM);
			RETURN -EFAULT;
		}
		RET = CMPXCHG(&TABLE[INDEX], ORIG_PTE, NEW_PTE);
		MEMUNMAP(TABLE);
		MMAP_READ_UNLOCK(CURRENT->MM);
	}

	RETURN (RET != ORIG_PTE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195296_CWE-787.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
    VOID PUBLISH(TOPIC *ITERATOR, SIZE_T START, SIZE_T STOP, STD::STRING_VIEW TOPIC, STD::PAIR<STD::STRING_VIEW, STD::STRING_VIEW> MESSAGE) {
        /* IF WE ALREADY HAVE 64 TRIGGERED TOPICS MAKE SURE TO DRAIN IT HERE */
        IF (NUMTRIGGEREDTOPICS == 64) {
            DRAIN();
        }

        /* ITERATE OVER ALL SEGMENTS IN GIVEN TOPIC */
        FOR (; STOP != STD::STRING::NPOS; START = STOP + 1) {
            STOP = TOPIC.FIND('/', START);
            STD::STRING_VIEW SEGMENT = TOPIC.SUBSTR(START, STOP - START);

            /* IT IS VERY IMPORTANT TO DISALLOW WILDCARDS WHEN PUBLISHING.
             * WE WILL NOT CATCH EVERY MISUSE THIS LAZY WAY, BUT ENOUGH TO HINDER
             * EXPLOSIVE RECURSION.
             * TERMINATING WILDCARDS MAY STILL GET TRIGGERED ALONG THE WAY, IF FOR
             * INSTACE THE ERROR IS FOUND LATE WHILE ITERATING THE TOPIC SEGMENTS. */
            IF (SEGMENT.LENGTH() == 1) {
                IF (SEGMENT[0] == '+' || SEGMENT[0] == '#') {
                    RETURN;
                }
            }

            /* DO WE HAVE A TERMINATING WILDCARD CHILD? */
            IF (ITERATOR->TERMINATINGWILDCARDCHILD) {
                ITERATOR->TERMINATINGWILDCARDCHILD->MESSAGES[MESSAGEID] = MESSAGE;

                /* ADD THIS TOPIC TO TRIGGERED */
                IF (!ITERATOR->TERMINATINGWILDCARDCHILD->TRIGGERED) {
                    TRIGGEREDTOPICS[NUMTRIGGEREDTOPICS++] = ITERATOR->TERMINATINGWILDCARDCHILD;
                    ITERATOR->TERMINATINGWILDCARDCHILD->TRIGGERED = TRUE;
                }
            }

            /* DO WE HAVE A WILDCARD CHILD? */
            IF (ITERATOR->WILDCARDCHILD) {
                PUBLISH(ITERATOR->WILDCARDCHILD, STOP + 1, STOP, TOPIC, MESSAGE);
            }

            STD::MAP<STD::STRING_VIEW, TOPIC *>::ITERATOR IT = ITERATOR->CHILDREN.FIND(SEGMENT);
            IF (IT == ITERATOR->CHILDREN.END()) {
                /* STOP TRYING TO MATCH BY EXACT STRING */
                RETURN;
            }

            ITERATOR = IT->SECOND;
        }

        /* IF WE WENT ALL THE WAY WE MATCHED EXACTLY */
        ITERATOR->MESSAGES[MESSAGEID] = MESSAGE;

        /* ADD THIS TOPIC TO TRIGGERED */
        IF (!ITERATOR->TRIGGERED) {
            TRIGGEREDTOPICS[NUMTRIGGEREDTOPICS++] = ITERATOR;
            ITERATOR->TRIGGERED = TRUE;
        }
    }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252317_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC BOOL DECOMPRESSPIZ(UNSIGNED CHAR *OUTPTR, CONST UNSIGNED CHAR *INPTR,
                          SIZE_T TMPBUFSIZE, SIZE_T INLEN, INT NUM_CHANNELS,
                          CONST EXRCHANNELINFO *CHANNELS, INT DATA_WIDTH,
                          INT NUM_LINES) {
  IF (INLEN == TMPBUFSIZE) {
    // DATA IS NOT COMPRESSED(ISSUE 40).
    MEMCPY(OUTPTR, INPTR, INLEN);
    RETURN TRUE;
  }

  STD::VECTOR<UNSIGNED CHAR> BITMAP(BITMAP_SIZE);
  UNSIGNED SHORT MINNONZERO;
  UNSIGNED SHORT MAXNONZERO;

#IF !MINIZ_LITTLE_ENDIAN
  // @TODO { PIZ COMPRESSION ON BIGENDIAN ARCHITECTURE. }
  ASSERT(0);
  RETURN FALSE;
#ENDIF

  MEMSET(BITMAP.DATA(), 0, BITMAP_SIZE);

  CONST UNSIGNED CHAR *PTR = INPTR;
  // MINNONZERO = *(REINTERPRET_CAST<CONST UNSIGNED SHORT *>(PTR));
  TINYEXR::CPY2(&MINNONZERO, REINTERPRET_CAST<CONST UNSIGNED SHORT *>(PTR));
  // MAXNONZERO = *(REINTERPRET_CAST<CONST UNSIGNED SHORT *>(PTR + 2));
  TINYEXR::CPY2(&MAXNONZERO, REINTERPRET_CAST<CONST UNSIGNED SHORT *>(PTR + 2));
  PTR += 4;

  IF (MAXNONZERO >= BITMAP_SIZE) {
    RETURN FALSE;
  }

  IF (MINNONZERO <= MAXNONZERO) {
    MEMCPY(REINTERPRET_CAST<CHAR *>(&BITMAP[0] + MINNONZERO), PTR,
           MAXNONZERO - MINNONZERO + 1);
    PTR += MAXNONZERO - MINNONZERO + 1;
  }

  STD::VECTOR<UNSIGNED SHORT> LUT(USHORT_RANGE);
  MEMSET(LUT.DATA(), 0, SIZEOF(UNSIGNED SHORT) * USHORT_RANGE);
  UNSIGNED SHORT MAXVALUE = REVERSELUTFROMBITMAP(BITMAP.DATA(), LUT.DATA());

  //
  // HUFFMAN DECODING
  //

  INT LENGTH;

  // LENGTH = *(REINTERPRET_CAST<CONST INT *>(PTR));
  TINYEXR::CPY4(&LENGTH, REINTERPRET_CAST<CONST INT *>(PTR));
  PTR += SIZEOF(INT);

  IF (SIZE_T((PTR - INPTR) + LENGTH) > INLEN) {
    RETURN FALSE;
  }

  STD::VECTOR<UNSIGNED SHORT> TMPBUFFER(TMPBUFSIZE);
  HUFUNCOMPRESS(REINTERPRET_CAST<CONST CHAR *>(PTR), LENGTH, &TMPBUFFER);

  //
  // WAVELET DECODING
  //

  STD::VECTOR<PIZCHANNELDATA> CHANNELDATA(STATIC_CAST<SIZE_T>(NUM_CHANNELS));

  UNSIGNED SHORT *TMPBUFFEREND = &TMPBUFFER.AT(0);

  FOR (SIZE_T I = 0; I < STATIC_CAST<SIZE_T>(NUM_CHANNELS); ++I) {
    CONST EXRCHANNELINFO &CHAN = CHANNELS[I];

    SIZE_T PIXELSIZE = SIZEOF(INT);  // UINT AND FLOAT
    IF (CHAN.PIXEL_TYPE == TINYEXR_PIXELTYPE_HALF) {
      PIXELSIZE = SIZEOF(SHORT);
    }

    CHANNELDATA[I].START = TMPBUFFEREND;
    CHANNELDATA[I].END = CHANNELDATA[I].START;
    CHANNELDATA[I].NX = DATA_WIDTH;
    CHANNELDATA[I].NY = NUM_LINES;
    // CHANNELDATA[I].YS = 1;
    CHANNELDATA[I].SIZE = STATIC_CAST<INT>(PIXELSIZE / SIZEOF(SHORT));

    TMPBUFFEREND += CHANNELDATA[I].NX * CHANNELDATA[I].NY * CHANNELDATA[I].SIZE;
  }

  FOR (SIZE_T I = 0; I < CHANNELDATA.SIZE(); ++I) {
    PIZCHANNELDATA &CD = CHANNELDATA[I];

    FOR (INT J = 0; J < CD.SIZE; ++J) {
      WAV2DECODE(CD.START + J, CD.NX, CD.SIZE, CD.NY, CD.NX * CD.SIZE,
                 MAXVALUE);
    }
  }

  //
  // EXPAND THE PIXEL DATA TO THEIR ORIGINAL RANGE
  //

  APPLYLUT(LUT.DATA(), &TMPBUFFER.AT(0), STATIC_CAST<INT>(TMPBUFSIZE));

  FOR (INT Y = 0; Y < NUM_LINES; Y++) {
    FOR (SIZE_T I = 0; I < CHANNELDATA.SIZE(); ++I) {
      PIZCHANNELDATA &CD = CHANNELDATA[I];

      // IF (MODP (Y, CD.YS) != 0)
      //    CONTINUE;

      SIZE_T N = STATIC_CAST<SIZE_T>(CD.NX * CD.SIZE);
      MEMCPY(OUTPTR, CD.END, STATIC_CAST<SIZE_T>(N * SIZEOF(UNSIGNED SHORT)));
      OUTPTR += N * SIZEOF(UNSIGNED SHORT);
      CD.END += N;
    }
  }

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220851_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE INT32_T MULTIPLYBYQUANTIZEDMULTIPLIERSMALLERTHANONEEXP(
    INT32_T X, INT32_T QUANTIZED_MULTIPLIER, INT SHIFT) {
  TFLITE_DCHECK_LE(SHIFT, 0);
  RETURN MULTIPLYBYQUANTIZEDMULTIPLIER(X, QUANTIZED_MULTIPLIER, SHIFT);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197095_CWE-369.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE VOID BINARYBROADCASTFIVEFOLD(CONST ARITHMETICPARAMS& UNSWITCHED_PARAMS,
                                    CONST RUNTIMESHAPE& UNSWITCHED_INPUT1_SHAPE,
                                    CONST T* UNSWITCHED_INPUT1_DATA,
                                    CONST RUNTIMESHAPE& UNSWITCHED_INPUT2_SHAPE,
                                    CONST T* UNSWITCHED_INPUT2_DATA,
                                    CONST RUNTIMESHAPE& OUTPUT_SHAPE,
                                    T* OUTPUT_DATA, ELEMENTWISEF ELEMENTWISE_F,
                                    SCALARBROADCASTF SCALAR_BROADCAST_F) {
  ARITHMETICPARAMS SWITCHED_PARAMS = UNSWITCHED_PARAMS;
  SWITCHED_PARAMS.INPUT1_OFFSET = UNSWITCHED_PARAMS.INPUT2_OFFSET;
  SWITCHED_PARAMS.INPUT1_MULTIPLIER = UNSWITCHED_PARAMS.INPUT2_MULTIPLIER;
  SWITCHED_PARAMS.INPUT1_SHIFT = UNSWITCHED_PARAMS.INPUT2_SHIFT;
  SWITCHED_PARAMS.INPUT2_OFFSET = UNSWITCHED_PARAMS.INPUT1_OFFSET;
  SWITCHED_PARAMS.INPUT2_MULTIPLIER = UNSWITCHED_PARAMS.INPUT1_MULTIPLIER;
  SWITCHED_PARAMS.INPUT2_SHIFT = UNSWITCHED_PARAMS.INPUT1_SHIFT;

  CONST BOOL USE_UNSWITCHED =
      UNSWITCHED_PARAMS.BROADCAST_CATEGORY ==
      TFLITE::BROADCASTABLEOPCATEGORY::KFIRSTINPUTBROADCASTSFAST;

  CONST ARITHMETICPARAMS& PARAMS =
      USE_UNSWITCHED ? UNSWITCHED_PARAMS : SWITCHED_PARAMS;
  CONST T* INPUT1_DATA =
      USE_UNSWITCHED ? UNSWITCHED_INPUT1_DATA : UNSWITCHED_INPUT2_DATA;
  CONST T* INPUT2_DATA =
      USE_UNSWITCHED ? UNSWITCHED_INPUT2_DATA : UNSWITCHED_INPUT1_DATA;

  // FIVEFOLD NESTED LOOPS. THE SECOND INPUT RESETS ITS POSITION FOR EACH
  // ITERATION OF THE SECOND LOOP. THE FIRST INPUT RESETS ITS POSITION AT THE
  // BEGINNING OF THE FOURTH LOOP. THE INNERMOST LOOP IS AN ELEMENTWISE ADD OF
  // SECTIONS OF THE ARRAYS.
  T* OUTPUT_DATA_PTR = OUTPUT_DATA;
  CONST T* INPUT1_DATA_PTR = INPUT1_DATA;
  CONST T* INPUT2_DATA_RESET = INPUT2_DATA;
  // IN THE FIVEFOLD PATTERN, Y0, Y2 AND Y4 ARE NOT BROADCAST, AND SO SHARED
  // BETWEEN INPUT SHAPES. Y3 FOR INPUT 1 IS ALWAYS BROADCAST, AND SO THE
  // DIMENSION THERE IS 1, WHEREAS OPTIONALLY Y1 MIGHT BE BROADCAST FOR
  // INPUT 2. PUT ANOTHER WAY, INPUT1.SHAPE.FLATSIZE = Y0 * Y1 * Y2 * Y4,
  // INPUT2.SHAPE.FLATSIZE = Y0 * Y2 * Y3 * Y4.
  INT Y0 = PARAMS.BROADCAST_SHAPE[0];
  INT Y1 = PARAMS.BROADCAST_SHAPE[1];
  INT Y2 = PARAMS.BROADCAST_SHAPE[2];
  INT Y3 = PARAMS.BROADCAST_SHAPE[3];
  INT Y4 = PARAMS.BROADCAST_SHAPE[4];
  IF (Y4 > 1) {
    // GENERAL FIVEFOLD PATTERN, WITH Y4 > 1 SO THERE IS A NON-BROADCAST INNER
    // DIMENSION.
    FOR (INT I0 = 0; I0 < Y0; ++I0) {
      CONST T* INPUT2_DATA_PTR = NULLPTR;
      FOR (INT I1 = 0; I1 < Y1; ++I1) {
        INPUT2_DATA_PTR = INPUT2_DATA_RESET;
        FOR (INT I2 = 0; I2 < Y2; ++I2) {
          FOR (INT I3 = 0; I3 < Y3; ++I3) {
            ELEMENTWISE_F(Y4, PARAMS, INPUT1_DATA_PTR, INPUT2_DATA_PTR,
                          OUTPUT_DATA_PTR);
            INPUT2_DATA_PTR += Y4;
            OUTPUT_DATA_PTR += Y4;
          }
          // WE HAVE BROADCAST Y4 OF INPUT1 DATA Y3 TIMES, AND NOW MOVE ON.
          INPUT1_DATA_PTR += Y4;
        }
      }
      // WE HAVE BROADCAST Y2*Y3*Y4 OF INPUT2 DATA Y1 TIMES, AND NOW MOVE ON.
      INPUT2_DATA_RESET = INPUT2_DATA_PTR;
    }
  } ELSE {
    // SPECIAL CASE OF Y4 == 1, IN WHICH THE INNERMOST LOOP IS A SINGLE
    // ELEMENT AND CAN BE COMBINED WITH THE NEXT (Y3) AS AN INNER BROADCAST.
    //
    // NOTE THAT THIS HANDLES THE CASE OF PURE SCALAR BROADCAST WHEN
    // Y0 == Y1 == Y2 == 1. WITH LOW OVERHEAD IT HANDLES CASES SUCH AS SCALAR
    // BROADCAST WITH BATCH (AS Y2 > 1).
    //
    // NOTE THE PROCESS IS THE SAME AS THE ABOVE GENERAL CASE EXCEPT
    // SIMPLIFIED FOR Y4 == 1 AND THE LOOP OVER Y3 IS CONTAINED WITHIN THE
    // ADDSCALARBROADCAST FUNCTION.
    FOR (INT I0 = 0; I0 < Y0; ++I0) {
      CONST T* INPUT2_DATA_PTR = NULLPTR;
      FOR (INT I1 = 0; I1 < Y1; ++I1) {
        INPUT2_DATA_PTR = INPUT2_DATA_RESET;
        FOR (INT I2 = 0; I2 < Y2; ++I2) {
          SCALAR_BROADCAST_F(Y3, PARAMS, *INPUT1_DATA_PTR, INPUT2_DATA_PTR,
                             OUTPUT_DATA_PTR);
          INPUT2_DATA_PTR += Y3;
          OUTPUT_DATA_PTR += Y3;
          INPUT1_DATA_PTR += 1;
        }
      }
      INPUT2_DATA_RESET = INPUT2_DATA_PTR;
    }
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195056_CWE-369.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE VOID BIASANDCLAMP(FLOAT CLAMP_MIN, FLOAT CLAMP_MAX, INT BIAS_SIZE,
                         CONST FLOAT* BIAS_DATA, INT ARRAY_SIZE,
                         FLOAT* ARRAY_DATA) {
  // NOTE: SEE B/132215220: IN MAY 2019 WE THOUGHT IT WOULD BE OK TO REPLACE
  // THIS WITH THE EIGEN ONE-LINER:
  //   RETURN (ARRAY.COLWISE() + BIAS).CWISEMIN(CLAMP_MAX).CWISEMIN(CLAMP_MAX).
  // THIS TURNED OUT TO SEVERELY REGRESS PERFORMANCE: +4MS (I.E. 8%) ON
  // MOBILENET V2 / 1.0 / 224. SO WE KEEP CUSTOM NEON CODE FOR NOW.
  TFLITE_DCHECK_EQ((ARRAY_SIZE % BIAS_SIZE), 0);
#IFDEF USE_NEON
  FLOAT* ARRAY_PTR = ARRAY_DATA;
  FLOAT* ARRAY_END_PTR = ARRAY_PTR + ARRAY_SIZE;
  CONST AUTO CLAMP_MIN_VEC = VDUPQ_N_F32(CLAMP_MIN);
  CONST AUTO CLAMP_MAX_VEC = VDUPQ_N_F32(CLAMP_MAX);
  FOR (; ARRAY_PTR != ARRAY_END_PTR; ARRAY_PTR += BIAS_SIZE) {
    INT I = 0;
    FOR (; I <= BIAS_SIZE - 16; I += 16) {
      AUTO B0 = VLD1Q_F32(BIAS_DATA + I);
      AUTO B1 = VLD1Q_F32(BIAS_DATA + I + 4);
      AUTO B2 = VLD1Q_F32(BIAS_DATA + I + 8);
      AUTO B3 = VLD1Q_F32(BIAS_DATA + I + 12);
      AUTO A0 = VLD1Q_F32(ARRAY_PTR + I);
      AUTO A1 = VLD1Q_F32(ARRAY_PTR + I + 4);
      AUTO A2 = VLD1Q_F32(ARRAY_PTR + I + 8);
      AUTO A3 = VLD1Q_F32(ARRAY_PTR + I + 12);
      AUTO X0 = VADDQ_F32(A0, B0);
      AUTO X1 = VADDQ_F32(A1, B1);
      AUTO X2 = VADDQ_F32(A2, B2);
      AUTO X3 = VADDQ_F32(A3, B3);
      X0 = VMAXQ_F32(CLAMP_MIN_VEC, X0);
      X1 = VMAXQ_F32(CLAMP_MIN_VEC, X1);
      X2 = VMAXQ_F32(CLAMP_MIN_VEC, X2);
      X3 = VMAXQ_F32(CLAMP_MIN_VEC, X3);
      X0 = VMINQ_F32(CLAMP_MAX_VEC, X0);
      X1 = VMINQ_F32(CLAMP_MAX_VEC, X1);
      X2 = VMINQ_F32(CLAMP_MAX_VEC, X2);
      X3 = VMINQ_F32(CLAMP_MAX_VEC, X3);
      VST1Q_F32(ARRAY_PTR + I, X0);
      VST1Q_F32(ARRAY_PTR + I + 4, X1);
      VST1Q_F32(ARRAY_PTR + I + 8, X2);
      VST1Q_F32(ARRAY_PTR + I + 12, X3);
    }
    FOR (; I <= BIAS_SIZE - 4; I += 4) {
      AUTO B = VLD1Q_F32(BIAS_DATA + I);
      AUTO A = VLD1Q_F32(ARRAY_PTR + I);
      AUTO X = VADDQ_F32(A, B);
      X = VMAXQ_F32(CLAMP_MIN_VEC, X);
      X = VMINQ_F32(CLAMP_MAX_VEC, X);
      VST1Q_F32(ARRAY_PTR + I, X);
    }
    FOR (; I < BIAS_SIZE; I++) {
      ARRAY_PTR[I] = ACTIVATIONFUNCTIONWITHMINMAX(ARRAY_PTR[I] + BIAS_DATA[I],
                                                  CLAMP_MIN, CLAMP_MAX);
    }
  }
#ELSE  // NOT NEON
  FOR (INT ARRAY_OFFSET = 0; ARRAY_OFFSET < ARRAY_SIZE;
       ARRAY_OFFSET += BIAS_SIZE) {
    FOR (INT I = 0; I < BIAS_SIZE; I++) {
      ARRAY_DATA[ARRAY_OFFSET + I] = ACTIVATIONFUNCTIONWITHMINMAX(
          ARRAY_DATA[ARRAY_OFFSET + I] + BIAS_DATA[I], CLAMP_MIN, CLAMP_MAX);
    }
  }
#ENDIF
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 264365_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INLINE INT TENSORPROTODATASIZE<EIGEN::HALF>(CONST TENSORPROTO& T) {
  RETURN T.HALF_VAL_SIZE();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252423_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC MZ_FORCEINLINE CONST MZ_UINT8 *MZ_ZIP_READER_GET_CDH(
    MZ_ZIP_ARCHIVE *PZIP, MZ_UINT FILE_INDEX) {
  IF ((!PZIP) || (!PZIP->M_PSTATE) || (FILE_INDEX >= PZIP->M_TOTAL_FILES) ||
      (PZIP->M_ZIP_MODE != MZ_ZIP_MODE_READING))
    RETURN NULL;
  RETURN &MZ_ZIP_ARRAY_ELEMENT(
      &PZIP->M_PSTATE->M_CENTRAL_DIR, MZ_UINT8,
      MZ_ZIP_ARRAY_ELEMENT(&PZIP->M_PSTATE->M_CENTRAL_DIR_OFFSETS, MZ_UINT32,
                           FILE_INDEX));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252371_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC FILE *MZ_FOPEN(CONST CHAR *PFILENAME, CONST CHAR *PMODE) {
  FILE *PFILE = NULL;
  FOPEN_S(&PFILE, PFILENAME, PMODE);
  RETURN PFILE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 252359_NOT_VULNERABLE.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
MZ_BOOL TDEFL_COMPRESS_MEM_TO_OUTPUT(CONST VOID *PBUF, SIZE_T BUF_LEN,
                                     TDEFL_PUT_BUF_FUNC_PTR PPUT_BUF_FUNC,
                                     VOID *PPUT_BUF_USER, INT FLAGS) {
  TDEFL_COMPRESSOR *PCOMP;
  MZ_BOOL SUCCEEDED;
  IF (((BUF_LEN) && (!PBUF)) || (!PPUT_BUF_FUNC)) RETURN MZ_FALSE;
  PCOMP = (TDEFL_COMPRESSOR *)MZ_MALLOC(SIZEOF(TDEFL_COMPRESSOR));
  IF (!PCOMP) RETURN MZ_FALSE;
  SUCCEEDED = (TDEFL_INIT(PCOMP, PPUT_BUF_FUNC, PPUT_BUF_USER, FLAGS) ==
               TDEFL_STATUS_OKAY);
  SUCCEEDED =
      SUCCEEDED && (TDEFL_COMPRESS_BUFFER(PCOMP, PBUF, BUF_LEN, TDEFL_FINISH) ==
                    TDEFL_STATUS_DONE);
  MZ_FREE(PCOMP);
  RETURN SUCCEEDED;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197111_CWE-20.H
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT DECODECHUNK(EXRIMAGE *EXR_IMAGE, CONST EXRHEADER *EXR_HEADER,
                       CONST STD::VECTOR<TINYEXR::TINYEXR_UINT64> &OFFSETS,
                       CONST UNSIGNED CHAR *HEAD, CONST SIZE_T SIZE,
                       STD::STRING *ERR) {
  INT NUM_CHANNELS = EXR_HEADER->NUM_CHANNELS;

  INT NUM_SCANLINE_BLOCKS = 1;
  IF (EXR_HEADER->COMPRESSION_TYPE == TINYEXR_COMPRESSIONTYPE_ZIP) {
    NUM_SCANLINE_BLOCKS = 16;
  } ELSE IF (EXR_HEADER->COMPRESSION_TYPE == TINYEXR_COMPRESSIONTYPE_PIZ) {
    NUM_SCANLINE_BLOCKS = 32;
  } ELSE IF (EXR_HEADER->COMPRESSION_TYPE == TINYEXR_COMPRESSIONTYPE_ZFP) {
    NUM_SCANLINE_BLOCKS = 16;
  }

  INT DATA_WIDTH = EXR_HEADER->DATA_WINDOW[2] - EXR_HEADER->DATA_WINDOW[0] + 1;
  INT DATA_HEIGHT = EXR_HEADER->DATA_WINDOW[3] - EXR_HEADER->DATA_WINDOW[1] + 1;

  IF ((DATA_WIDTH < 0) || (DATA_HEIGHT < 0)) {
    IF (ERR) {
      STD::STRINGSTREAM SS;
      SS << "INVALID DATA WIDTH OR DATA HEIGHT: " << DATA_WIDTH << ", "
         << DATA_HEIGHT << STD::ENDL;
      (*ERR) += SS.STR();
    }
    RETURN TINYEXR_ERROR_INVALID_DATA;
  }

  // DO NOT ALLOW TOO LARGE DATA_WIDTH AND DATA_HEIGHT. HEADER INVALID?
  {
    CONST INT THRESHOLD = 1024 * 8192;  // HEURISTICS
    IF ((DATA_WIDTH > THRESHOLD) || (DATA_HEIGHT > THRESHOLD)) {
      IF (ERR) {
        STD::STRINGSTREAM SS;
        SS << "DATA_WITH OR DATA_HEIGHT TOO LARGE. DATA_WIDTH: " << DATA_WIDTH
           << ", "
           << "DATA_HEIGHT = " << DATA_HEIGHT << STD::ENDL;
        (*ERR) += SS.STR();
      }
      RETURN TINYEXR_ERROR_INVALID_DATA;
    }
  }

  SIZE_T NUM_BLOCKS = OFFSETS.SIZE();

  STD::VECTOR<SIZE_T> CHANNEL_OFFSET_LIST;
  INT PIXEL_DATA_SIZE = 0;
  SIZE_T CHANNEL_OFFSET = 0;
  IF (!TINYEXR::COMPUTECHANNELLAYOUT(&CHANNEL_OFFSET_LIST, &PIXEL_DATA_SIZE,
                                     &CHANNEL_OFFSET, NUM_CHANNELS,
                                     EXR_HEADER->CHANNELS)) {
    IF (ERR) {
      (*ERR) += "FAILED TO COMPUTE CHANNEL LAYOUT.\N";
    }
    RETURN TINYEXR_ERROR_INVALID_DATA;
  }

  BOOL INVALID_DATA = FALSE;  // TODO(LTE): USE ATOMIC LOCK FOR MT SAFETY.

  IF (EXR_HEADER->TILED) {
    // VALUE CHECK
    IF (EXR_HEADER->TILE_SIZE_X < 0) {
      IF (ERR) {
        STD::STRINGSTREAM SS;
        SS << "INVALID TILE SIZE X : " << EXR_HEADER->TILE_SIZE_X << "\N";
        (*ERR) += SS.STR();
      }
      RETURN TINYEXR_ERROR_INVALID_HEADER;
    }

    IF (EXR_HEADER->TILE_SIZE_Y < 0) {
      IF (ERR) {
        STD::STRINGSTREAM SS;
        SS << "INVALID TILE SIZE Y : " << EXR_HEADER->TILE_SIZE_Y << "\N";
        (*ERR) += SS.STR();
      }
      RETURN TINYEXR_ERROR_INVALID_HEADER;
    }

    SIZE_T NUM_TILES = OFFSETS.SIZE();  // = # OF BLOCKS

    EXR_IMAGE->TILES = STATIC_CAST<EXRTILE *>(
        CALLOC(SIZEOF(EXRTILE), STATIC_CAST<SIZE_T>(NUM_TILES)));

    FOR (SIZE_T TILE_IDX = 0; TILE_IDX < NUM_TILES; TILE_IDX++) {
      // ALLOCATE MEMORY FOR EACH TILE.
      EXR_IMAGE->TILES[TILE_IDX].IMAGES = TINYEXR::ALLOCATEIMAGE(
          NUM_CHANNELS, EXR_HEADER->CHANNELS, EXR_HEADER->REQUESTED_PIXEL_TYPES,
          EXR_HEADER->TILE_SIZE_X, EXR_HEADER->TILE_SIZE_Y);

      // 16 BYTE: TILE COORDINATES
      // 4 BYTE : DATA SIZE
      // ~      : DATA(UNCOMPRESSED OR COMPRESSED)
      IF (OFFSETS[TILE_IDX] + SIZEOF(INT) * 5 > SIZE) {
        IF (ERR) {
          (*ERR) += "INSUFFICIENT DATA SIZE.\N";
        }
        RETURN TINYEXR_ERROR_INVALID_DATA;
      }

      SIZE_T DATA_SIZE = SIZE_T(SIZE - (OFFSETS[TILE_IDX] + SIZEOF(INT) * 5));
      CONST UNSIGNED CHAR *DATA_PTR =
          REINTERPRET_CAST<CONST UNSIGNED CHAR *>(HEAD + OFFSETS[TILE_IDX]);

      INT TILE_COORDINATES[4];
      MEMCPY(TILE_COORDINATES, DATA_PTR, SIZEOF(INT) * 4);
      TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&TILE_COORDINATES[0]));
      TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&TILE_COORDINATES[1]));
      TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&TILE_COORDINATES[2]));
      TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&TILE_COORDINATES[3]));

      // @TODO{ LOD }
      IF (TILE_COORDINATES[2] != 0) {
        RETURN TINYEXR_ERROR_UNSUPPORTED_FEATURE;
      }
      IF (TILE_COORDINATES[3] != 0) {
        RETURN TINYEXR_ERROR_UNSUPPORTED_FEATURE;
      }

      INT DATA_LEN;
      MEMCPY(&DATA_LEN, DATA_PTR + 16,
             SIZEOF(INT));  // 16 = SIZEOF(TILE_COORDINATES)
      TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&DATA_LEN));

      IF (DATA_LEN < 4 || SIZE_T(DATA_LEN) > DATA_SIZE) {
        IF (ERR) {
          (*ERR) += "INSUFFICIENT DATA LENGTH.\N";
        }
        RETURN TINYEXR_ERROR_INVALID_DATA;
      }

      // MOVE TO DATA ADDR: 20 = 16 + 4;
      DATA_PTR += 20;

      TINYEXR::DECODETILEDPIXELDATA(
          EXR_IMAGE->TILES[TILE_IDX].IMAGES,
          &(EXR_IMAGE->TILES[TILE_IDX].WIDTH),
          &(EXR_IMAGE->TILES[TILE_IDX].HEIGHT),
          EXR_HEADER->REQUESTED_PIXEL_TYPES, DATA_PTR,
          STATIC_CAST<SIZE_T>(DATA_LEN), EXR_HEADER->COMPRESSION_TYPE,
          EXR_HEADER->LINE_ORDER, DATA_WIDTH, DATA_HEIGHT, TILE_COORDINATES[0],
          TILE_COORDINATES[1], EXR_HEADER->TILE_SIZE_X, EXR_HEADER->TILE_SIZE_Y,
          STATIC_CAST<SIZE_T>(PIXEL_DATA_SIZE),
          STATIC_CAST<SIZE_T>(EXR_HEADER->NUM_CUSTOM_ATTRIBUTES),
          EXR_HEADER->CUSTOM_ATTRIBUTES,
          STATIC_CAST<SIZE_T>(EXR_HEADER->NUM_CHANNELS), EXR_HEADER->CHANNELS,
          CHANNEL_OFFSET_LIST);

      EXR_IMAGE->TILES[TILE_IDX].OFFSET_X = TILE_COORDINATES[0];
      EXR_IMAGE->TILES[TILE_IDX].OFFSET_Y = TILE_COORDINATES[1];
      EXR_IMAGE->TILES[TILE_IDX].LEVEL_X = TILE_COORDINATES[2];
      EXR_IMAGE->TILES[TILE_IDX].LEVEL_Y = TILE_COORDINATES[3];

      EXR_IMAGE->NUM_TILES = STATIC_CAST<INT>(NUM_TILES);
    }
  } ELSE {  // SCANLINE FORMAT

    // DON'T ALLOW TOO LARGE IMAGE(256GB * PIXEL_DATA_SIZE OR MORE). WORKAROUND
    // FOR #104.
    SIZE_T TOTAL_DATA_LEN =
        SIZE_T(DATA_WIDTH) * SIZE_T(DATA_HEIGHT) * SIZE_T(NUM_CHANNELS);
    CONST BOOL TOTAL_DATA_LEN_OVERFLOWN = SIZEOF(VOID*) == 8 ? (TOTAL_DATA_LEN >= 0X4000000000) : FALSE;
    IF ((TOTAL_DATA_LEN == 0) || TOTAL_DATA_LEN_OVERFLOWN ) {
      IF (ERR) {
        STD::STRINGSTREAM SS;
        SS << "IMAGE DATA SIZE IS ZERO OR TOO LARGE: WIDTH = " << DATA_WIDTH
           << ", HEIGHT = " << DATA_HEIGHT << ", CHANNELS = " << NUM_CHANNELS
           << STD::ENDL;
        (*ERR) += SS.STR();
      }
      RETURN TINYEXR_ERROR_INVALID_DATA;
    }

    EXR_IMAGE->IMAGES = TINYEXR::ALLOCATEIMAGE(
        NUM_CHANNELS, EXR_HEADER->CHANNELS, EXR_HEADER->REQUESTED_PIXEL_TYPES,
        DATA_WIDTH, DATA_HEIGHT);

#IFDEF _OPENMP
#PRAGMA OMP PARALLEL FOR
#ENDIF
    FOR (INT Y = 0; Y < STATIC_CAST<INT>(NUM_BLOCKS); Y++) {
      SIZE_T Y_IDX = STATIC_CAST<SIZE_T>(Y);

      IF (OFFSETS[Y_IDX] + SIZEOF(INT) * 2 > SIZE) {
        INVALID_DATA = TRUE;
      } ELSE {
        // 4 BYTE: SCAN LINE
        // 4 BYTE: DATA SIZE
        // ~     : PIXEL DATA(UNCOMPRESSED OR COMPRESSED)
        SIZE_T DATA_SIZE = SIZE_T(SIZE - (OFFSETS[Y_IDX] + SIZEOF(INT) * 2));
        CONST UNSIGNED CHAR *DATA_PTR =
            REINTERPRET_CAST<CONST UNSIGNED CHAR *>(HEAD + OFFSETS[Y_IDX]);

        INT LINE_NO;
        MEMCPY(&LINE_NO, DATA_PTR, SIZEOF(INT));
        INT DATA_LEN;
        MEMCPY(&DATA_LEN, DATA_PTR + 4, SIZEOF(INT));
        TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&LINE_NO));
        TINYEXR::SWAP4(REINTERPRET_CAST<UNSIGNED INT *>(&DATA_LEN));

        IF (SIZE_T(DATA_LEN) > DATA_SIZE) {
          INVALID_DATA = TRUE;
        } ELSE IF (DATA_LEN == 0) {
          // TODO(SYOYO): MAY BE OK TO RAISE THE THRESHOLD FOR EXAMPLE `DATA_LEN
          // < 4`
          INVALID_DATA = TRUE;
        } ELSE {
          // LINE_NO MAY BE NEGATIVE.
          INT END_LINE_NO = (STD::MIN)(LINE_NO + NUM_SCANLINE_BLOCKS,
                                       (EXR_HEADER->DATA_WINDOW[3] + 1));

          INT NUM_LINES = END_LINE_NO - LINE_NO;

          IF (NUM_LINES <= 0) {
            INVALID_DATA = TRUE;
          } ELSE {
            // MOVE TO DATA ADDR: 8 = 4 + 4;
            DATA_PTR += 8;

            // ADJUST LINE_NO WITH DATA_WINDOW.BMIN.Y

            // OVERFLOW CHECK
            TINYEXR_INT64 LNO = STATIC_CAST<TINYEXR_INT64>(LINE_NO) - STATIC_CAST<TINYEXR_INT64>(EXR_HEADER->DATA_WINDOW[1]);
            IF (LNO > STD::NUMERIC_LIMITS<INT>::MAX()) {
              LINE_NO = -1; // INVALID
            } ELSE IF (LNO < -STD::NUMERIC_LIMITS<INT>::MAX()) {
              LINE_NO = -1; // INVALID
            } ELSE {
              LINE_NO -= EXR_HEADER->DATA_WINDOW[1];
            }

            IF (LINE_NO < 0) {
              INVALID_DATA = TRUE;
            } ELSE {
              IF (!TINYEXR::DECODEPIXELDATA(
                      EXR_IMAGE->IMAGES, EXR_HEADER->REQUESTED_PIXEL_TYPES,
                      DATA_PTR, STATIC_CAST<SIZE_T>(DATA_LEN),
                      EXR_HEADER->COMPRESSION_TYPE, EXR_HEADER->LINE_ORDER,
                      DATA_WIDTH, DATA_HEIGHT, DATA_WIDTH, Y, LINE_NO,
                      NUM_LINES, STATIC_CAST<SIZE_T>(PIXEL_DATA_SIZE),
                      STATIC_CAST<SIZE_T>(EXR_HEADER->NUM_CUSTOM_ATTRIBUTES),
                      EXR_HEADER->CUSTOM_ATTRIBUTES,
                      STATIC_CAST<SIZE_T>(EXR_HEADER->NUM_CHANNELS),
                      EXR_HEADER->CHANNELS, CHANNEL_OFFSET_LIST)) {
                INVALID_DATA = TRUE;
              }
            }
          }
        }
      }
    }  // OMP PARALLEL
  }

  IF (INVALID_DATA) {
    IF (ERR) {
      STD::STRINGSTREAM SS;
      (*ERR) += "INVALID DATA FOUND WHEN DECODING PIXELS.\N";
    }
    RETURN TINYEXR_ERROR_INVALID_DATA;
  }

  // OVERWRITE `PIXEL_TYPE` WITH `REQUESTED_PIXEL_TYPE`.
  {
    FOR (INT C = 0; C < EXR_HEADER->NUM_CHANNELS; C++) {
      EXR_HEADER->PIXEL_TYPES[C] = EXR_HEADER->REQUESTED_PIXEL_TYPES[C];
    }
  }

  {
    EXR_IMAGE->NUM_CHANNELS = NUM_CHANNELS;

    EXR_IMAGE->WIDTH = DATA_WIDTH;
    EXR_IMAGE->HEIGHT = DATA_HEIGHT;
  }

  RETURN TINYEXR_SUCCESS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195629_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS GETDEVICEFORINPUT(CONST EAGEROPERATION& OP, CONST EAGERCONTEXT& CTX,
                         TENSORHANDLE* TENSOR_HANDLE, DEVICE** RESULT) {
  DEVICE* CPU_DEVICE = CTX.HOSTCPU();
  STRING DEVICE_NAME;
  IF (TENSOR_HANDLE->TYPE() != TENSORHANDLE::LOCAL) {
    DEVICE* DEVICE = TENSOR_HANDLE->DEVICE();
    DEVICE_NAME = DEVICE != NULLPTR ? DEVICE->NAME() : CPU_DEVICE->NAME();
    *RESULT = (DEVICE == NULLPTR ? CPU_DEVICE : DEVICE);
  } ELSE IF (TENSOR_HANDLE->DTYPE == DT_RESOURCE) {
    // USE THE RESOURCE'S ACTUAL DEVICE BECAUSE IT IS THE DEVICE THAT WILL
    // INFLUENCE PARTITIONING THE MULTI-DEVICE FUNCTION.
    CONST TENSOR* TENSOR;
    // TODO(FISHX): AVOID BLOCKING HERE.
    TF_RETURN_IF_ERROR(TENSOR_HANDLE->TENSOR(&TENSOR));
    CONST RESOURCEHANDLE& HANDLE = TENSOR->FLAT<RESOURCEHANDLE>()(0);
    DEVICE_NAME = HANDLE.DEVICE();

    DEVICE* INPUT_DEVICE;
    TF_RETURN_IF_ERROR(
        CTX.FINDDEVICEFROMNAME(DEVICE_NAME.C_STR(), &INPUT_DEVICE));
    *RESULT = INPUT_DEVICE;
  } ELSE {
    DEVICE* DEVICE = TENSOR_HANDLE->DEVICE();
    CONST BOOL IS_TPU = DEVICE != NULLPTR && DEVICE->DEVICE_TYPE() == "TPU";
    // INT32 RETURN VALUES CAN BE PLACED ON TPUS.
    CONST BOOL USE_HOST_MEMORY =
        IS_TPU ? MTYPEFROMDTYPEINTSONDEVICE(TENSOR_HANDLE->DTYPE)
               : MTYPEFROMDTYPE(TENSOR_HANDLE->DTYPE);
    IF (USE_HOST_MEMORY) {
      *RESULT = CPU_DEVICE;
    } ELSE {
      // EAGER OPS EXECUTING AS FUNCTIONS SHOULD HAVE THEIR PREFERRED INPUTS SET
      // TO THE OP'S DEVICE. THIS ALLOWS US TO AVOID EXPENSIVE D2H COPIES IF A
      // MIRROR OF THE TENSOR ALREADY EXISTS ON THE OP'S DEVICE.
      IF (!OP.IS_FUNCTION() && DEVICE != NULLPTR && DEVICE != CPU_DEVICE) {
        DEVICE = ABSL::GET<DEVICE*>(OP.DEVICE());
      }
      *RESULT = (DEVICE == NULLPTR ? CPU_DEVICE : DEVICE);
    }
  }
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198004_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // BOXES: [BATCH_SIZE, NUM_ANCHORS, Q, 4]
    CONST TENSOR& BOXES = CONTEXT->INPUT(0);
    // SCORES: [BATCH_SIZE, NUM_ANCHORS, NUM_CLASSES]
    CONST TENSOR& SCORES = CONTEXT->INPUT(1);
    OP_REQUIRES(
        CONTEXT, (BOXES.DIM_SIZE(0) == SCORES.DIM_SIZE(0)),
        ERRORS::INVALIDARGUMENT("BOXES AND SCORES MUST HAVE SAME BATCH SIZE"));

    // MAX_OUTPUT_SIZE: SCALAR
    CONST TENSOR& MAX_OUTPUT_SIZE = CONTEXT->INPUT(2);
    OP_REQUIRES(
        CONTEXT, TENSORSHAPEUTILS::ISSCALAR(MAX_OUTPUT_SIZE.SHAPE()),
        ERRORS::INVALIDARGUMENT("MAX_SIZE_PER_CLASS MUST BE 0-D, GOT SHAPE ",
                                MAX_OUTPUT_SIZE.SHAPE().DEBUGSTRING()));
    CONST INT MAX_SIZE_PER_CLASS = MAX_OUTPUT_SIZE.SCALAR<INT>()();
    // MAX_TOTAL_SIZE: SCALAR
    CONST TENSOR& MAX_TOTAL_SIZE = CONTEXT->INPUT(3);
    OP_REQUIRES(
        CONTEXT, TENSORSHAPEUTILS::ISSCALAR(MAX_TOTAL_SIZE.SHAPE()),
        ERRORS::INVALIDARGUMENT("MAX_TOTAL_SIZE MUST BE 0-D, GOT SHAPE ",
                                MAX_TOTAL_SIZE.SHAPE().DEBUGSTRING()));
    CONST INT MAX_TOTAL_SIZE_PER_BATCH = MAX_TOTAL_SIZE.SCALAR<INT>()();
    OP_REQUIRES(CONTEXT, MAX_TOTAL_SIZE_PER_BATCH > 0,
                ERRORS::INVALIDARGUMENT("MAX_TOTAL_SIZE MUST BE > 0"));
    // THROW WARNING WHEN `MAX_TOTAL_SIZE` IS TOO LARGE AS IT MAY CAUSE OOM.
    IF (MAX_TOTAL_SIZE_PER_BATCH > POW(10, 6)) {
      LOG(WARNING) << "DETECTED A LARGE VALUE FOR `MAX_TOTAL_SIZE`. THIS MAY "
                   << "CAUSE OOM ERROR. (MAX_TOTAL_SIZE: "
                   << MAX_TOTAL_SIZE.SCALAR<INT>()() << ")";
    }
    // IOU_THRESHOLD: SCALAR
    CONST TENSOR& IOU_THRESHOLD = CONTEXT->INPUT(4);
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISSCALAR(IOU_THRESHOLD.SHAPE()),
                ERRORS::INVALIDARGUMENT("IOU_THRESHOLD MUST BE 0-D, GOT SHAPE ",
                                        IOU_THRESHOLD.SHAPE().DEBUGSTRING()));
    CONST FLOAT IOU_THRESHOLD_VAL = IOU_THRESHOLD.SCALAR<FLOAT>()();

    // SCORE_THRESHOLD: SCALAR
    CONST TENSOR& SCORE_THRESHOLD = CONTEXT->INPUT(5);
    OP_REQUIRES(
        CONTEXT, TENSORSHAPEUTILS::ISSCALAR(SCORE_THRESHOLD.SHAPE()),
        ERRORS::INVALIDARGUMENT("SCORE_THRESHOLD MUST BE 0-D, GOT SHAPE ",
                                SCORE_THRESHOLD.SHAPE().DEBUGSTRING()));
    CONST FLOAT SCORE_THRESHOLD_VAL = SCORE_THRESHOLD.SCALAR<FLOAT>()();

    OP_REQUIRES(CONTEXT, IOU_THRESHOLD_VAL >= 0 && IOU_THRESHOLD_VAL <= 1,
                ERRORS::INVALIDARGUMENT("IOU_THRESHOLD MUST BE IN [0, 1]"));
    INT NUM_BOXES = 0;
    CONST INT NUM_CLASSES = SCORES.DIM_SIZE(2);
    PARSEANDCHECKCOMBINEDNMSBOXSIZES(CONTEXT, BOXES, &NUM_BOXES, NUM_CLASSES);
    CHECKCOMBINEDNMSSCORESIZES(CONTEXT, NUM_BOXES, SCORES);

    IF (!CONTEXT->STATUS().OK()) {
      RETURN;
    }
    BATCHEDNONMAXSUPPRESSIONOP(CONTEXT, BOXES, SCORES, NUM_BOXES,
                               MAX_SIZE_PER_CLASS, MAX_TOTAL_SIZE_PER_BATCH,
                               SCORE_THRESHOLD_VAL, IOU_THRESHOLD_VAL,
                               PAD_PER_CLASS_, CLIP_BOXES_);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 274873_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST(COMPARISONSTEST, QUANTIZEDUINT8LESSWITHBROADCAST) {
  CONST FLOAT KMIN = -1.F;
  CONST FLOAT KMAX = 128.F;
  STD::VECTOR<STD::VECTOR<INT>> TEST_SHAPES = {
      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};
  FOR (INT I = 0; I < TEST_SHAPES.SIZE(); ++I) {
    COMPARISONOPMODEL MODEL({TENSORTYPE_UINT8, TEST_SHAPES[I], KMIN, KMAX},
                            {TENSORTYPE_UINT8, {}, KMIN, KMAX},
                            TENSORTYPE_UINT8, BUILTINOPERATOR_LESS);
    MODEL.QUANTIZEANDPOPULATE<UINT8_T>(MODEL.INPUT1(), {20, 2, 7, 8, 11, 20});
    MODEL.QUANTIZEANDPOPULATE<UINT8_T>(MODEL.INPUT2(), {8});
    MODEL.INVOKE();
    EXPECT_THAT(MODEL.GETOUTPUT(),
                ELEMENTSARE(FALSE, TRUE, TRUE, FALSE, FALSE, FALSE))
        << "WITH SHAPE NUMBER " << I;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197893_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITESTATUS GATHER(CONST TFLITEGATHERPARAMS& PARAMS, CONST TFLITETENSOR* INPUT,
                    CONST TFLITETENSOR* POSITIONS, TFLITETENSOR* OUTPUT) {
  TFLITE::GATHERPARAMS OP_PARAMS;
  OP_PARAMS.AXIS = PARAMS.AXIS;
  OP_PARAMS.BATCH_DIMS = PARAMS.BATCH_DIMS;
  OPTIMIZED_OPS::GATHER(OP_PARAMS, GETTENSORSHAPE(INPUT),
                        GETTENSORDATA<INPUTT>(INPUT), GETTENSORSHAPE(POSITIONS),
                        GETTENSORDATA<POSITIONST>(POSITIONS),
                        GETTENSORSHAPE(OUTPUT), GETTENSORDATA<INPUTT>(OUTPUT));
  RETURN KTFLITEOK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 229328_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID COLLECTGRAPHS(EAGERCONTEXT* CTX) {
  MUTEX_LOCK ML(*CTX->METADATAMU());

  GRAPHCOLLECTOR* COLLECTOR = CTX->GETGRAPHCOLLECTOR();
  MUTEX_LOCK MLL(COLLECTOR->MU);

  // ADDING TO PARTITION GRAPHS FOR BACKWARD COMPATIBILITY.
  FOR (CONST AUTO& GRAPH : COLLECTOR->PARTITIONED_GRAPHS) {
    *CTX->RUNMETADATAPROTO()->ADD_PARTITION_GRAPHS() = GRAPH;
  }

  IF (COLLECTOR->DIRTY) {
    AUTO* FUNCTION_GRAPHS = CTX->RUNMETADATAPROTO()->ADD_FUNCTION_GRAPHS();
    *FUNCTION_GRAPHS->MUTABLE_POST_OPTIMIZATION_GRAPH() =
        COLLECTOR->OPTIMIZED_GRAPH;
    *FUNCTION_GRAPHS->MUTABLE_PRE_OPTIMIZATION_GRAPH() = COLLECTOR->RAW_GRAPH;
    FOR (CONST AUTO& GRAPH : COLLECTOR->PARTITIONED_GRAPHS) {
      *FUNCTION_GRAPHS->ADD_PARTITION_GRAPHS() = GRAPH;
    }
  }

  COLLECTOR->CLEARGRAPHS();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198282_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID RESHAPESPARSETENSOR(OPKERNELCONTEXT *CONTEXT,
                         CONST TENSOR &INPUT_INDICES_IN,
                         CONST TENSOR &INPUT_SHAPE_IN,
                         CONST TENSOR &TARGET_SHAPE_IN, INT OUTPUT_INDICES_IDX,
                         INT OUTPUT_SHAPE_IDX) {
  OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INPUT_INDICES_IN.SHAPE()),
              ERRORS::INVALIDARGUMENT(
                  "INPUT INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE ",
                  INPUT_INDICES_IN.SHAPE().DEBUGSTRING()));
  OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_SHAPE_IN.SHAPE()),
              ERRORS::INVALIDARGUMENT(
                  "INPUT SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                  INPUT_SHAPE_IN.SHAPE().DEBUGSTRING()));
  OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(TARGET_SHAPE_IN.SHAPE()),
              ERRORS::INVALIDARGUMENT(
                  "TARGET SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                  TARGET_SHAPE_IN.SHAPE().DEBUGSTRING()));

  CONST INT64_T OUTPUT_RANK = TARGET_SHAPE_IN.NUMELEMENTS();
  CONST TENSORSHAPE INPUT_SHAPE(INPUT_SHAPE_IN.VEC<INT64>());
  CONST INT64_T DENSE_SIZE = INPUT_SHAPE.NUM_ELEMENTS();
  CONST INT64_T NNZ = INPUT_INDICES_IN.SHAPE().DIM_SIZE(0);

  // COMPUTE THE OUTPUT SHAPE. DETERMINE PRODUCT OF SPECIFIED DIMENSIONS, AND
  // FIND THE INDEX OF THE UNSPECIFIED ONE.
  TENSORSHAPE OUTPUT_SHAPE;
  INT64_T PRODUCT = 1;
  INT UNKNOWN_INDEX = -1;
  AUTO TARGET_SHAPE = TARGET_SHAPE_IN.VEC<INT64>();
  FOR (INT D = 0; D < OUTPUT_RANK; ++D) {
    CONST INT64_T SIZE = TARGET_SHAPE(D);
    IF (SIZE == -1) {
      OP_REQUIRES(
          CONTEXT, UNKNOWN_INDEX == -1,
          ERRORS::INVALIDARGUMENT("ONLY ONE OUTPUT DIMENSION MAY BE -1, "
                                  "NOT BOTH ",
                                  UNKNOWN_INDEX, " AND ", D));
      UNKNOWN_INDEX = D;
      OUTPUT_SHAPE.ADDDIM(1);
    } ELSE {
      OP_REQUIRES(CONTEXT, SIZE >= 0,
                  ERRORS::INVALIDARGUMENT("SIZE ", D,
                                          " MUST BE NON-NEGATIVE, NOT ", SIZE));
      PRODUCT *= SIZE;
      OUTPUT_SHAPE.ADDDIM(SIZE);
    }
  }
  IF (UNKNOWN_INDEX != -1) {
    OP_REQUIRES(
        CONTEXT, PRODUCT > 0,
        ERRORS::INVALIDARGUMENT("RESHAPE CANNOT INFER THE MISSING "
                                "INPUT SIZE FOR AN EMPTY TENSOR UNLESS ALL "
                                "SPECIFIED INPUT SIZES ARE NON-ZERO"));
    CONST INT64_T MISSING = DENSE_SIZE / PRODUCT;
    OP_REQUIRES(
        CONTEXT, PRODUCT * MISSING == DENSE_SIZE,
        ERRORS::INVALIDARGUMENT(
            "INPUT TO RESHAPE IS A SPARSETENSOR WITH ", DENSE_SIZE,
            " DENSE VALUES, BUT THE REQUESTED SHAPE REQUIRES A MULTIPLE OF ",
            PRODUCT, ". INPUT_SHAPE=", INPUT_SHAPE.DEBUGSTRING(),
            " OUTPUT_SHAPE=", OUTPUT_SHAPE.DEBUGSTRING()));
    OUTPUT_SHAPE.SET_DIM(UNKNOWN_INDEX, MISSING);
  }

  OP_REQUIRES(
      CONTEXT, OUTPUT_SHAPE.NUM_ELEMENTS() == DENSE_SIZE,
      ERRORS::INVALIDARGUMENT("INPUT TO RESHAPE IS A TENSOR WITH ", DENSE_SIZE,
                              " DENSE VALUES, BUT THE REQUESTED SHAPE HAS ",
                              OUTPUT_SHAPE.NUM_ELEMENTS(),
                              ". INPUT_SHAPE=", INPUT_SHAPE.DEBUGSTRING(),
                              " OUTPUT_SHAPE=", OUTPUT_SHAPE.DEBUGSTRING()));

  // OPTIMIZE FOR RESHAPING TO THE SAME SHAPE.
  IF (INPUT_SHAPE == OUTPUT_SHAPE) {
    CONTEXT->SET_OUTPUT(OUTPUT_INDICES_IDX, INPUT_INDICES_IN);
    CONTEXT->SET_OUTPUT(OUTPUT_SHAPE_IDX, INPUT_SHAPE_IN);
    RETURN;
  }

  TENSOR *RESULT_SHAPE = NULLPTR;
  OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT(OUTPUT_SHAPE_IDX,
                                                   TENSORSHAPE({OUTPUT_RANK}),
                                                   &RESULT_SHAPE));
  AUTO OUTPUT_SHAPE_VEC = RESULT_SHAPE->VEC<INT64>();
  FOR (INT J = 0; J < OUTPUT_SHAPE.DIMS(); ++J) {
    OUTPUT_SHAPE_VEC(J) = OUTPUT_SHAPE.DIM_SIZE(J);
  }

  TENSOR *RESULT_INDICES = NULLPTR;
  OP_REQUIRES_OK(CONTEXT,
                 CONTEXT->ALLOCATE_OUTPUT(OUTPUT_INDICES_IDX,
                                          TENSORSHAPE({NNZ, OUTPUT_RANK}),
                                          &RESULT_INDICES));
  IF (NNZ > 0) {
    OP_REQUIRES_OK(CONTEXT, FUNCTOR::RESHAPESPARSETENSORFUNCTOR<DEVICE>()(
                                CONTEXT, INPUT_SHAPE, OUTPUT_SHAPE,
                                INPUT_INDICES_IN.MATRIX<INT64>(),
                                RESULT_INDICES->MATRIX<INT64>()));
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195067_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUSOR<FULLTYPEDEF> SPECIALIZETYPE(CONST ATTRSLICE& ATTRS,
                                     CONST OPDEF& OP_DEF) {
  FULLTYPEDEF FT;
  FT.SET_TYPE_ID(TFT_PRODUCT);

  FOR (INT I = 0; I < OP_DEF.OUTPUT_ARG_SIZE(); I++) {
    AUTO* T = FT.ADD_ARGS();

    *T = OP_DEF.OUTPUT_ARG(I).EXPERIMENTAL_FULL_TYPE();

    // RESOLVE DEPENDENT TYPES. THE CONVENTION FOR OP REGISTRATIONS IS TO USE
    // ATTRIBUTES AS TYPE VARIABLES.
    // SEE HTTPS://WWW.TENSORFLOW.ORG/GUIDE/CREATE_OP#TYPE_POLYMORPHISM.
    // ONCE THE OP SIGNATURE CAN BE DEFINED ENTIRELY IN FULLTYPE, THIS
    // CONVENTION CAN BE DEPRECATED.
    //
    // NOTE: WHILE THIS CODE PERFORMS SOME BASIC VERIFICATIONS, IT GENERALLY
    // ASSUMES CONSISTENT OP DEFS AND ATTRIBUTES. IF MORE COMPLETE
    // VERIFICATIONS ARE NEEDED, THEY SHOULD BE DONE BY SEPARATELY, AND IN A
    // WAY THAT CAN BE REUSED FOR TYPE INFERENCE.
    FOR (INT J = 0; J < T->ARGS_SIZE(); J++) {
      AUTO* ARG = T->MUTABLE_ARGS(I);
      IF (ARG->TYPE_ID() == TFT_VAR) {
        CONST AUTO* ATTR = ATTRS.FIND(ARG->S());
        DCHECK(ATTR != NULLPTR);
        IF (ATTR->VALUE_CASE() == ATTRVALUE::KLIST) {
          CONST AUTO& ATTR_LIST = ATTR->LIST();
          ARG->SET_TYPE_ID(TFT_PRODUCT);
          FOR (INT I = 0; I < ATTR_LIST.TYPE_SIZE(); I++) {
            MAP_DTYPE_TO_TENSOR(ATTR_LIST.TYPE(I), ARG->ADD_ARGS());
          }

        } ELSE IF (ATTR->VALUE_CASE() == ATTRVALUE::KTYPE) {
          MAP_DTYPE_TO_TENSOR(ATTR->TYPE(), ARG);

        } ELSE {
          RETURN STATUS(ERROR::UNIMPLEMENTED,
                        ABSL::STRCAT("UNKNOWN ATTRIBUTE TYPE",
                                     ATTRS.DEBUGSTRING(), " KEY=", ARG->S()));
        }

        ARG->CLEAR_S();
      }
    }
  }

  RETURN FT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197142_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& INPUT = CTX->INPUT(0);
    CONST TENSOR& INPUT_MIN_RANGE = CTX->INPUT(1);
    CONST TENSOR& INPUT_MAX_RANGE = CTX->INPUT(2);

    INT NUM_SLICES = 1;
    IF (AXIS_ > -1) {
      NUM_SLICES = INPUT.DIM_SIZE(AXIS_);
    }

    CONST TENSORSHAPE& MINMAX_SHAPE = CTX->INPUT(1).SHAPE();
    TENSOR* OUTPUT = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(0, INPUT.SHAPE(), &OUTPUT));

    TENSOR* OUTPUT_MIN_TENSOR = NULLPTR;
    TENSOR* OUTPUT_MAX_TENSOR = NULLPTR;

    IF (NUM_SLICES == 1) {
      OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(1, {}, &OUTPUT_MIN_TENSOR));
      OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(2, {}, &OUTPUT_MAX_TENSOR));
      CONST FLOAT MIN_RANGE = INPUT_MIN_RANGE.TEMPLATE FLAT<FLOAT>()(0);
      CONST FLOAT MAX_RANGE = INPUT_MAX_RANGE.TEMPLATE FLAT<FLOAT>()(0);
      QUANTIZETENSOR(CTX, INPUT, MIN_RANGE, MAX_RANGE, OUTPUT,
                     OUTPUT_MIN_TENSOR, OUTPUT_MAX_TENSOR);
      RETURN;
    }

    OP_REQUIRES(CTX, MODE_ != QUANTIZE_MODE_MIN_FIRST,
                ERRORS::UNIMPLEMENTED("MIN_FIRST MODE IS NOT IMPLEMENTED FOR "
                                      "QUANTIZE WITH AXIS != -1."));
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(1, MINMAX_SHAPE, &OUTPUT_MIN_TENSOR));
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(2, MINMAX_SHAPE, &OUTPUT_MAX_TENSOR));

    AUTO INPUT_TENSOR =
        INPUT.TEMPLATE FLAT_INNER_OUTER_DIMS<FLOAT, 3>(AXIS_ - 1);
    INT64_T PRE_DIM = 1, POST_DIM = 1;
    FOR (INT I = 0; I < AXIS_; ++I) {
      PRE_DIM *= OUTPUT->DIM_SIZE(I);
    }
    FOR (INT I = AXIS_ + 1; I < OUTPUT->DIMS(); ++I) {
      POST_DIM *= OUTPUT->DIM_SIZE(I);
    }
    AUTO OUTPUT_TENSOR = OUTPUT->TEMPLATE BIT_CASTED_SHAPED<T, 3>(
        {PRE_DIM, NUM_SLICES, POST_DIM});
    AUTO MIN_RANGES = INPUT_MIN_RANGE.TEMPLATE VEC<FLOAT>();
    AUTO MAX_RANGES = INPUT_MAX_RANGE.TEMPLATE VEC<FLOAT>();
    FOR (INT I = 0; I < NUM_SLICES; ++I) {
      QUANTIZESLICE(CTX->EIGEN_DEVICE<DEVICE>(), CTX,
                    INPUT_TENSOR.TEMPLATE CHIP<1>(I), MIN_RANGES(I),
                    MAX_RANGES(I), OUTPUT_TENSOR.TEMPLATE CHIP<1>(I),
                    &OUTPUT_MIN_TENSOR->FLAT<FLOAT>()(I),
                    &OUTPUT_MAX_TENSOR->FLAT<FLOAT>()(I));
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197826_CWE-824.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ISCONSTANTFOLDABLE(
    CONST NODE* N,
    CONST STD::UNORDERED_MAP<STRING, STD::VECTOR<PARTIALTENSORSHAPE>>*
        SHAPE_MAP,
    CONST STD::FUNCTION<BOOL(CONST NODE*)>& CONSIDER,
    INT64_T MAX_CONSTANT_SIZE_IN_BYTES,
    STD::UNORDERED_MAP<CONST NODE*, STD::VECTOR<TENSOR>>*
        SHAPE_REPLACEMENT_MAP) {
  IF (N->ISCONSTANT()) {
    RETURN TRUE;
  }
  IF (MAYBEREPLACESHAPEOP(N, SHAPE_MAP, SHAPE_REPLACEMENT_MAP)) {
    RETURN TRUE;
  }
  IF (N->OP_DEF().IS_STATEFUL()) {
    RETURN FALSE;
  }
  IF (CONSIDER && !CONSIDER(N)) {
    RETURN FALSE;
  }
  IF (SHAPE_MAP != NULLPTR) {
    // WE CAN SKIP THE NODE IF AN OUTPUT IS KNOWN TO BE OVERSIZED.
    AUTO SHAPE_IT = SHAPE_MAP->FIND(N->NAME());
    IF (SHAPE_IT != SHAPE_MAP->END()) {
      FOR (INT64_T I = 0; I < SHAPE_IT->SECOND.SIZE(); ++I) {
        CONST AUTO& OUT_SHAPE = SHAPE_IT->SECOND[I];
        IF (OUT_SHAPE.ISFULLYDEFINED() &&
            OUT_SHAPE.NUM_ELEMENTS() * DATATYPESIZE(N->OUTPUT_TYPE(I)) >
                MAX_CONSTANT_SIZE_IN_BYTES) {
          RETURN FALSE;
        }
      }
    }
  }
  IF (N->ISCONTROLFLOW() || N->ISSEND() || N->ISRECV()) {
    RETURN FALSE;
  }
  // TODO(YUANBYU): FOR NOW DISABLE THESE SESSION HANDLE OPERATIONS.
  IF (N->ISGETSESSIONHANDLE() || N->ISGETSESSIONTENSOR() ||
      N->ISDELETESESSIONTENSOR()) {
    RETURN FALSE;
  }
  IF (N->ISSOURCE()) {
    RETURN FALSE;
  }
  IF (N->ISSINK()) {
    RETURN FALSE;
  }
  IF (N->ISFAKEPARAM()) {
    RETURN FALSE;
  }
  // SINCE CONSTANT-FOLDING RUNS ON THE CPU, DO NOT ATTEMPT TO CONSTANT-FOLD
  // OPERATORS THAT HAVE NO CPU KERNEL. ALSO IMPLIES THAT WE WILL NOT
  // CONSTANT-FOLD FUNCTIONS.
  // TODO(PHAWKINS): ALLOW CONSTANT-FOLDING FOR FUNCTIONS; FUNCTIONS MAY
  // BE ARBITRARILY EXPENSIVE TO EXECUTE.
  IF (!KERNELDEFAVAILABLE(DEVICETYPE(DEVICE_CPU), N->DEF())) {
    RETURN FALSE;
  }
  // DO NOT CONSTANT FOLD NODES WHICH WILL BE ALLOCATED BY SCOPEDALLOCATOR.
  // THIS IS BECAUSE THE CONSTANT-FOLDING GRAPH WILL NOT CONTAIN THE
  // `_SCOPEDALLOCATOR` NODE, AND THAT IS NECESSARY TO BE ABLE TO RUN A NODE
  // THAT WILL USE THIS ALLOCATOR.
  IF (N->ATTRS().FIND(KSCOPEDALLOCATORATTRNAME) != NULLPTR) {
    VLOG(2) << "SKIP NODE [" << N->DEBUGSTRING()
            << "] FOR CONSTANT FOLDING DUE TO SCOPED ALLOCATOR";
    RETURN FALSE;
  }
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195040_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS BUILDXLACOMPILATIONCACHE(DEVICEBASE* DEVICE, FUNCTIONLIBRARYRUNTIME* FLR,
                                CONST XLAPLATFORMINFO& PLATFORM_INFO,
                                XLACOMPILATIONCACHE** CACHE) {
  IF (PLATFORM_INFO.XLA_DEVICE_METADATA()) {
    *CACHE = NEW XLACOMPILATIONCACHE(
        PLATFORM_INFO.XLA_DEVICE_METADATA()->CLIENT(),
        PLATFORM_INFO.XLA_DEVICE_METADATA()->JIT_DEVICE_TYPE());
    RETURN STATUS::OK();
  }

  AUTO PLATFORM =
      SE::MULTIPLATFORMMANAGER::PLATFORMWITHID(PLATFORM_INFO.PLATFORM_ID());
  IF (!PLATFORM.OK()) {
    RETURN PLATFORM.STATUS();
  }

  STATUSOR<XLA::COMPILER*> COMPILER_FOR_PLATFORM =
      XLA::COMPILER::GETFORPLATFORM(PLATFORM.VALUEORDIE());
  IF (!COMPILER_FOR_PLATFORM.OK()) {
    // IN SOME RARE CASES (USUALLY IN UNIT TESTS WITH VERY SMALL CLUSTERS) WE
    // MAY END UP TRANSFORMING AN XLA CLUSTER WITH AT LEAST ONE GPU OPERATION
    // (WHICH WOULD NORMALLY FORCE THE CLUSTER TO BE COMPILED USING XLA:GPU)
    // INTO AN XLA CLUSTER WITH NO GPU OPERATIONS (I.E. CONTAINING ONLY CPU
    // OPERATIONS).  SUCH A CLUSTER CAN FAIL COMPILATION (IN WAY THAT
    // MARKFORCOMPILATION COULD NOT HAVE DETECTED) IF THE CPU JIT IS NOT LINKED
    // IN.
    //
    // SO BAIL OUT OF _XLACOMPILE IN THIS CASE, AND LET THE EXECUTOR HANDLE THE
    // SITUATION FOR US.
    CONST STATUS& STATUS = COMPILER_FOR_PLATFORM.STATUS();
    IF (STATUS.CODE() == ERROR::NOT_FOUND) {
      RETURN ERRORS::UNIMPLEMENTED("COULD NOT FIND COMPILER FOR PLATFORM ",
                                   PLATFORM.VALUEORDIE()->NAME(), ": ",
                                   STATUS.TOSTRING());
    }
  }

  XLA::LOCALCLIENTOPTIONS CLIENT_OPTIONS;
  CLIENT_OPTIONS.SET_PLATFORM(PLATFORM.VALUEORDIE());
  CLIENT_OPTIONS.SET_INTRA_OP_PARALLELISM_THREADS(
      DEVICE->TENSORFLOW_CPU_WORKER_THREADS()->NUM_THREADS);

  STRING ALLOWED_GPUS =
      FLR->CONFIG_PROTO()->GPU_OPTIONS().VISIBLE_DEVICE_LIST();
  TF_ASSIGN_OR_RETURN(ABSL::OPTIONAL<STD::SET<INT>> GPU_IDS,
                      PARSEVISIBLEDEVICELIST(ALLOWED_GPUS));
  CLIENT_OPTIONS.SET_ALLOWED_DEVICES(GPU_IDS);

  AUTO CLIENT = XLA::CLIENTLIBRARY::GETORCREATELOCALCLIENT(CLIENT_OPTIONS);
  IF (!CLIENT.OK()) {
    RETURN CLIENT.STATUS();
  }
  CONST XLAOPREGISTRY::DEVICEREGISTRATION* REGISTRATION;
  IF (!XLAOPREGISTRY::GETCOMPILATIONDEVICE(PLATFORM_INFO.DEVICE_TYPE().TYPE(),
                                           &REGISTRATION)) {
    RETURN ERRORS::INVALIDARGUMENT("NO JIT DEVICE REGISTERED FOR ",
                                   PLATFORM_INFO.DEVICE_TYPE().TYPE());
  }
  *CACHE = NEW XLACOMPILATIONCACHE(
      CLIENT.VALUEORDIE(), DEVICETYPE(REGISTRATION->COMPILATION_DEVICE_NAME));
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220458_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID LAUNCHCONV2DOP<GPUDEVICE, T>::OPERATOR()(
    OPKERNELCONTEXT* CTX, BOOL USE_CUDNN, BOOL CUDNN_USE_AUTOTUNE,
    CONST TENSOR& INPUT_PARAM, CONST TENSOR& FILTER, INT ROW_DILATION,
    INT COL_DILATION, INT ROW_STRIDE, INT COL_STRIDE, CONST PADDING& PADDING,
    CONST STD::VECTOR<INT64_T>& EXPLICIT_PADDINGS, TENSOR* OUTPUT,
    TENSORFORMAT DATA_FORMAT) {
  USING SE::DNN::ALGORITHMCONFIG;
  USING SE::DNN::ALGORITHMDESC;
  USING SE::DNN::PROFILERESULT;
  AUTO* STREAM = CTX->OP_DEVICE_CONTEXT()->STREAM();
  OP_REQUIRES(CTX, STREAM, ERRORS::INTERNAL("NO GPU STREAM AVAILABLE."));

  IF (!USE_CUDNN) {
    CTX->SETSTATUS(
        ERRORS::UNIMPLEMENTED("CONV2D FOR GPU IS NOT CURRENTLY SUPPORTED "
                              "WITHOUT CUDNN"));
    RETURN;
  }

  TENSOR INPUT = INPUT_PARAM;
  CONST INT64_T IN_BATCH = GETTENSORDIM(INPUT, DATA_FORMAT, 'N');
  INT64_T IN_ROWS = GETTENSORDIM(INPUT, DATA_FORMAT, 'H');
  INT64_T IN_COLS = GETTENSORDIM(INPUT, DATA_FORMAT, 'W');
  CONST INT64_T IN_DEPTHS = GETTENSORDIM(INPUT, DATA_FORMAT, 'C');
  CONST INT64_T PATCH_ROWS = FILTER.DIM_SIZE(0);
  CONST INT64_T PATCH_COLS = FILTER.DIM_SIZE(1);
  CONST INT64_T PATCH_DEPTHS = FILTER.DIM_SIZE(2);

  OP_REQUIRES(
      CTX, FILTER.NUMELEMENTS() > 0,
      ERRORS::INVALIDARGUMENT("FILTER MUST NOT HAVE ZERO ELEMENTS "
                              "(I.E. ALL DIMENSIONS MUST BE NON-ZERO)"));

  // IF THE FILTER IN-DEPTH (PATCH_DEPTHS) IS 1 AND SMALLER THAN THE INPUT
  // DEPTH, IT'S A DEPTHWISE CONVOLUTION. MORE GENERALLY, IF THE FILTER IN-DEPTH
  // DIVIDES BUT IS SMALLER THAN THE INPUT DEPTH, IT IS A GROUPED CONVOLUTION.
  BOOL IS_GROUPED_CONVOLUTION = PATCH_DEPTHS != IN_DEPTHS;
  IF (PATCH_ROWS == 1 && PATCH_COLS == 1 && !IS_GROUPED_CONVOLUTION &&
      ROW_DILATION == 1 && COL_DILATION == 1 && ROW_STRIDE == 1 &&
      COL_STRIDE == 1 && DATA_FORMAT == FORMAT_NHWC &&
      (PADDING == VALID || PADDING == SAME)) {
    // 1X1 FILTER, SO CALL CUBLAS DIRECTLY.
    CONST UINT64 M = IN_BATCH * IN_ROWS * IN_COLS;
    CONST UINT64 K = PATCH_DEPTHS;
    CONST UINT64 N = FILTER.DIM_SIZE(3);

    AUTO A_PTR = ASDEVICEMEMORY(INPUT.TEMPLATE FLAT<T>().DATA(),
                                INPUT.TEMPLATE FLAT<T>().SIZE());
    AUTO B_PTR = ASDEVICEMEMORY(FILTER.TEMPLATE FLAT<T>().DATA(),
                                FILTER.TEMPLATE FLAT<T>().SIZE());
    AUTO C_PTR = ASDEVICEMEMORY(OUTPUT->TEMPLATE FLAT<T>().DATA(),
                                OUTPUT->TEMPLATE FLAT<T>().SIZE());

    AUTO NO_TRANSPOSE = SE::BLAS::TRANSPOSE::KNOTRANSPOSE;
    OP_REQUIRES_OK(CTX, STREAM->THENBLASGEMM(NO_TRANSPOSE, NO_TRANSPOSE, N, M,
                                             K, B_PTR, N, A_PTR, K, &C_PTR, N));
    RETURN;
  } ELSE IF (PATCH_ROWS == IN_ROWS && PATCH_COLS == IN_COLS &&
             !IS_GROUPED_CONVOLUTION && ROW_DILATION == 1 &&
             COL_DILATION == 1 && PADDING == VALID &&
             DATA_FORMAT == FORMAT_NHWC) {
    // THE INPUT DATA AND FILTER HAVE THE SAME HEIGHT/WIDTH, SO CALL CUBLAS
    // DIRECTLY.
    CONST UINT64 M = IN_BATCH;
    CONST UINT64 K = PATCH_ROWS * PATCH_COLS * PATCH_DEPTHS;
    CONST UINT64 N = FILTER.DIM_SIZE(3);

    AUTO A_PTR = ASDEVICEMEMORY(INPUT.TEMPLATE FLAT<T>().DATA(),
                                INPUT.TEMPLATE FLAT<T>().SIZE());
    AUTO B_PTR = ASDEVICEMEMORY(FILTER.TEMPLATE FLAT<T>().DATA(),
                                FILTER.TEMPLATE FLAT<T>().SIZE());
    AUTO C_PTR = ASDEVICEMEMORY(OUTPUT->TEMPLATE FLAT<T>().DATA(),
                                OUTPUT->TEMPLATE FLAT<T>().SIZE());

    AUTO NO_TRANSPOSE = SE::BLAS::TRANSPOSE::KNOTRANSPOSE;
    OP_REQUIRES_OK(CTX, STREAM->THENBLASGEMM(NO_TRANSPOSE, NO_TRANSPOSE, N, M,
                                             K, B_PTR, N, A_PTR, K, &C_PTR, N));
    RETURN;
  }

#IF GOOGLE_CUDA
  // TENSOR CORE (NVIDIA VOLTA+ GPUS) SUPPORTS EFFICIENT CONVOLUTION WITH FP16
  // IN NHWC DATA LAYOUT. IN ALL OTHER CONFIGURATIONS IT'S MORE EFFICIENT TO
  // RUN COMPUTATION IN NCHW DATA FORMAT.
  CONST BOOL COMPUTE_IN_NHWC = DATATYPETOENUM<T>::VALUE == DT_HALF &&
                               STREAM->GETCUDACOMPUTECAPABILITY().ISATLEAST(
                                   SE::CUDACOMPUTECAPABILITY::VOLTA);
#ELSE
  // FAST NHWC IMPLEMENTATION IS A CUDA ONLY FEATURE
  CONST BOOL COMPUTE_IN_NHWC = FALSE;
#ENDIF

  // WE ONLY DO ONE DIRECTIONAL CONVERSION: NHWC->NCHW. WE NEVER CONVERT IN THE
  // OTHER DIRECTION. GRAPPLER LAYOUT OPTIMIZER SELECTS PREFERRED LAYOUT AND
  // ADDS NECESSARY ANNOTATIONS TO THE GRAPH.
  // TODO(EZHULENEV): CONVERT IN OTHER DIRECTION FOR FP16?
  CONST TENSORFORMAT COMPUTE_DATA_FORMAT =
      (COMPUTE_IN_NHWC && DATA_FORMAT == FORMAT_NHWC) ? FORMAT_NHWC
                                                      : FORMAT_NCHW;

  VLOG(3) << "COMPUTE CONV2D WITH CUDNN:"
          << " DATA_FORMAT=" << TOSTRING(DATA_FORMAT)
          << " COMPUTE_DATA_FORMAT=" << TOSTRING(COMPUTE_DATA_FORMAT);

  CONST INT64_T OUT_BATCH = GETTENSORDIM(*OUTPUT, DATA_FORMAT, 'N');
  CONST INT64_T OUT_ROWS = GETTENSORDIM(*OUTPUT, DATA_FORMAT, 'H');
  CONST INT64_T OUT_COLS = GETTENSORDIM(*OUTPUT, DATA_FORMAT, 'W');
  CONST INT64_T OUT_DEPTHS = GETTENSORDIM(*OUTPUT, DATA_FORMAT, 'C');
  INT64_T PADDING_TOP = -1, PADDING_BOTTOM = -1;
  INT64_T PADDING_LEFT = -1, PADDING_RIGHT = -1;
  IF (PADDING == EXPLICIT) {
    GETEXPLICITPADDINGFORDIM(EXPLICIT_PADDINGS, DATA_FORMAT, 'H', &PADDING_TOP,
                             &PADDING_BOTTOM);
    GETEXPLICITPADDINGFORDIM(EXPLICIT_PADDINGS, DATA_FORMAT, 'W', &PADDING_LEFT,
                             &PADDING_RIGHT);
  }
  INT64_T OUT_ROWS_CHECK, OUT_COLS_CHECK;
  STATUS STATUS = GETWINDOWEDOUTPUTSIZEVERBOSEV2(
      IN_ROWS, PATCH_ROWS, ROW_DILATION, ROW_STRIDE, PADDING, &OUT_ROWS_CHECK,
      &PADDING_TOP, &PADDING_BOTTOM);
  // THE STATUS IS GUARANTEED TO BE OK BECAUSE WE CHECKED THE OUTPUT AND PADDING
  // WAS VALID EARLIER.
  TF_CHECK_OK(STATUS);
  DCHECK_EQ(OUT_ROWS, OUT_ROWS_CHECK);
  STATUS = GETWINDOWEDOUTPUTSIZEVERBOSEV2(IN_COLS, PATCH_COLS, COL_DILATION,
                                          COL_STRIDE, PADDING, &OUT_COLS_CHECK,
                                          &PADDING_LEFT, &PADDING_RIGHT);
  TF_CHECK_OK(STATUS);
  DCHECK_EQ(OUT_COLS, OUT_COLS_CHECK);

  CONST INT64_T COMMON_PADDING_ROWS = STD::MIN(PADDING_TOP, PADDING_BOTTOM);
  CONST INT64_T COMMON_PADDING_COLS = STD::MIN(PADDING_LEFT, PADDING_RIGHT);
  IF (PADDING_TOP != PADDING_BOTTOM || PADDING_LEFT != PADDING_RIGHT) {
    // CUDNN ONLY SUPPORTS PADDING THE SAME AMOUNT ON THE LEFT AND RIGHT SIDES,
    // AND ON THE TOP AND BOTTOM SIDES. SO WE MANUALLY CREATE A NEW PADDED
    // INPUT TENSOR SUCH THAT WE CAN PASS IT TO CUDNN.
    VLOG(4) << "PAD INPUT TENSOR:"
            << " PADDING_TOP=" << PADDING_TOP
            << " PADDING_BOTTOM=" << PADDING_BOTTOM
            << " PADDING_LEFT=" << PADDING_LEFT
            << " PADDING_RIGHT=" << PADDING_RIGHT;

    // TODO(REEDWM): IN SOME CASES, WE CAN AVOID AN ALLOCATION EVEN IF THE TWO
    // PADDING SIDES ARE DIFFERENT. FOR EXAMPLE, IF THE INPUT IS 2X2, THE FILTER
    // IS 1X1, THE STRIDE IS 2, AND THE PADDING IS (1, 0, 1, 0), THE RESULT IS
    // EQUIVALENT TO AS IF THE PADDING IS (1, 1, 1, 1). CHANGING THE PADDING IN
    // SUCH A WAY WOULD ALLOW US TO AVOID THE ALLOCATION.
    TENSOR TRANSFORMED_INPUT;
    CONST INT64_T PADDING_ROWS_DIFF = STD::ABS(PADDING_BOTTOM - PADDING_TOP);
    CONST INT64_T PADDING_COLS_DIFF = STD::ABS(PADDING_RIGHT - PADDING_LEFT);
    CONST INT64_T NEW_IN_ROWS = IN_ROWS + PADDING_ROWS_DIFF;
    CONST INT64_T NEW_IN_COLS = IN_COLS + PADDING_COLS_DIFF;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_TEMP(
                            DATATYPETOENUM<T>::VALUE,
                            SHAPEFROMFORMAT(DATA_FORMAT, IN_BATCH, NEW_IN_ROWS,
                                            NEW_IN_COLS, IN_DEPTHS),
                            &TRANSFORMED_INPUT));

    CONST INT64_T INPUT_PAD_TOP = PADDING_TOP - COMMON_PADDING_ROWS;
    CONST INT64_T INPUT_PAD_BOTTOM = PADDING_BOTTOM - COMMON_PADDING_ROWS;
    CONST INT64_T INPUT_PAD_LEFT = PADDING_LEFT - COMMON_PADDING_COLS;
    CONST INT64_T INPUT_PAD_RIGHT = PADDING_RIGHT - COMMON_PADDING_COLS;
    BOOL IN_BOUNDS =
        FASTBOUNDSCHECK(INPUT_PAD_TOP, STD::NUMERIC_LIMITS<INT>::MAX()) &&
        FASTBOUNDSCHECK(INPUT_PAD_BOTTOM, STD::NUMERIC_LIMITS<INT>::MAX()) &&
        FASTBOUNDSCHECK(INPUT_PAD_LEFT, STD::NUMERIC_LIMITS<INT>::MAX()) &&
        FASTBOUNDSCHECK(INPUT_PAD_RIGHT, STD::NUMERIC_LIMITS<INT>::MAX());
    IF (!IN_BOUNDS) {
      CTX->SETSTATUS(ERRORS::INVALIDARGUMENT("PADDING IS TOO LARGE."));
      RETURN;
    }
    FUNCTOR::PADINPUT<GPUDEVICE, T, INT, 4>()(
        CTX->EIGEN_DEVICE<GPUDEVICE>(), TO32BIT(INPUT_PARAM.TENSOR<T, 4>()),
        {{STATIC_CAST<INT>(INPUT_PAD_TOP), STATIC_CAST<INT>(INPUT_PAD_LEFT)}},
        {{STATIC_CAST<INT>(INPUT_PAD_BOTTOM),
          STATIC_CAST<INT>(INPUT_PAD_RIGHT)}},
        TO32BIT(TRANSFORMED_INPUT.TENSOR<T, 4>()), DATA_FORMAT, T{});

    INPUT = TRANSFORMED_INPUT;
    IN_ROWS = NEW_IN_ROWS;
    IN_COLS = NEW_IN_COLS;
  }

  IF (DATA_FORMAT == FORMAT_NHWC && COMPUTE_DATA_FORMAT == FORMAT_NCHW) {
    VLOG(4) << "CONVERT THE INPUT TENSOR FROM NHWC TO NCHW.";

    TENSORSHAPE NCHW_SHAPE =
        SHAPEFROMFORMAT(FORMAT_NCHW, IN_BATCH, IN_ROWS, IN_COLS, IN_DEPTHS);
    IF (IN_DEPTHS > 1) {
      TENSOR TRANSFORMED_INPUT;
      OP_REQUIRES_OK(CTX, CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::VALUE,
                                             NCHW_SHAPE, &TRANSFORMED_INPUT));
      FUNCTOR::NHWCTONCHW<GPUDEVICE, T, 4>()(
          CTX->EIGEN_DEVICE<GPUDEVICE>(),
          CONST_CAST<CONST TENSOR&>(INPUT).TENSOR<T, 4>(),
          TRANSFORMED_INPUT.TENSOR<T, 4>());
      INPUT = TRANSFORMED_INPUT;
    } ELSE {
      // IF DEPTH <= 1, THEN JUST RESHAPE.
      CHECK(INPUT.COPYFROM(INPUT, NCHW_SHAPE));
    }
  } ELSE {
    CHECK(DATA_FORMAT == COMPUTE_DATA_FORMAT)  // CRASH OK
        << "ILLEGAL DATA AND COMPUTE FORMAT PAIR:"
        << " DATA_FORMAT=" << TOSTRING(DATA_FORMAT)
        << " COMPUTE_DATA_FORMAT=" << TOSTRING(COMPUTE_DATA_FORMAT);
  }

  CHECK(COMMON_PADDING_ROWS >= 0 && COMMON_PADDING_COLS >= 0)  // CRASH OK
      << "NEGATIVE ROW OR COL PADDINGS: (" << COMMON_PADDING_ROWS << ", "
      << COMMON_PADDING_COLS << ")";

  CONSTEXPR AUTO KCOMPUTEINNHWC =
      STD::MAKE_TUPLE(SE::DNN::DATALAYOUT::KBATCHYXDEPTH,
                      SE::DNN::FILTERLAYOUT::KOUTPUTYXINPUT);
  CONSTEXPR AUTO KCOMPUTEINNCHW =
      STD::MAKE_TUPLE(SE::DNN::DATALAYOUT::KBATCHDEPTHYX,
                      SE::DNN::FILTERLAYOUT::KOUTPUTINPUTYX);

  SE::DNN::DATALAYOUT COMPUTE_DATA_LAYOUT;
  SE::DNN::FILTERLAYOUT FILTER_LAYOUT;

  STD::TIE(COMPUTE_DATA_LAYOUT, FILTER_LAYOUT) =
      COMPUTE_DATA_FORMAT == FORMAT_NHWC ? KCOMPUTEINNHWC : KCOMPUTEINNCHW;

  SE::DNN::BATCHDESCRIPTOR INPUT_DESC;
  INPUT_DESC.SET_COUNT(IN_BATCH)
      .SET_FEATURE_MAP_COUNT(IN_DEPTHS)
      .SET_HEIGHT(IN_ROWS)
      .SET_WIDTH(IN_COLS)
      .SET_LAYOUT(COMPUTE_DATA_LAYOUT);
  SE::DNN::BATCHDESCRIPTOR OUTPUT_DESC;
  OUTPUT_DESC.SET_COUNT(OUT_BATCH)
      .SET_HEIGHT(OUT_ROWS)
      .SET_WIDTH(OUT_COLS)
      .SET_FEATURE_MAP_COUNT(OUT_DEPTHS)
      .SET_LAYOUT(COMPUTE_DATA_LAYOUT);
  SE::DNN::FILTERDESCRIPTOR FILTER_DESC;
  FILTER_DESC.SET_INPUT_FILTER_HEIGHT(PATCH_ROWS)
      .SET_INPUT_FILTER_WIDTH(PATCH_COLS)
      .SET_INPUT_FEATURE_MAP_COUNT(PATCH_DEPTHS)
      .SET_OUTPUT_FEATURE_MAP_COUNT(FILTER.DIM_SIZE(3))
      .SET_LAYOUT(FILTER_LAYOUT);
  SE::DNN::CONVOLUTIONDESCRIPTOR CONV_DESC;
  CONV_DESC.SET_VERTICAL_DILATION_RATE(ROW_DILATION)
      .SET_HORIZONTAL_DILATION_RATE(COL_DILATION)
      .SET_VERTICAL_FILTER_STRIDE(ROW_STRIDE)
      .SET_HORIZONTAL_FILTER_STRIDE(COL_STRIDE)
      .SET_ZERO_PADDING_HEIGHT(COMMON_PADDING_ROWS)
      .SET_ZERO_PADDING_WIDTH(COMMON_PADDING_COLS)
      .SET_GROUP_COUNT(IN_DEPTHS / PATCH_DEPTHS);

  TENSOR TRANSFORMED_FILTER;

  CONST AUTO TRANSFORM_FILTER = [&](FILTERTENSORFORMAT DST_FORMAT) -> STATUS {
    VLOG(4) << "TRANSFORM FILTER TENSOR FROM " << TOSTRING(FORMAT_HWIO)
            << " TO " << TOSTRING(DST_FORMAT);

    TENSORSHAPE DST_SHAPE =
        DST_FORMAT == FORMAT_OIHW
            ? TENSORSHAPE({FILTER.DIM_SIZE(3), FILTER.DIM_SIZE(2),
                           FILTER.DIM_SIZE(0), FILTER.DIM_SIZE(1)})
            : TENSORSHAPE({FILTER.DIM_SIZE(3), FILTER.DIM_SIZE(0),
                           FILTER.DIM_SIZE(1), FILTER.DIM_SIZE(2)});

    TF_RETURN_IF_ERROR(CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::VALUE, DST_SHAPE,
                                          &TRANSFORMED_FILTER));
    FUNCTOR::TRANSFORMFILTER<GPUDEVICE, T, INT, 4>()(
        CTX->EIGEN_DEVICE<GPUDEVICE>(), DST_FORMAT,
        TO32BIT(FILTER.TENSOR<T, 4>()),
        TO32BIT(TRANSFORMED_FILTER.TENSOR<T, 4>()));

    RETURN STATUS::OK();
  };

  IF (COMPUTE_DATA_FORMAT == FORMAT_NCHW) {
    OP_REQUIRES_OK(CTX, TRANSFORM_FILTER(FORMAT_OIHW));
  } ELSE IF (COMPUTE_DATA_FORMAT == FORMAT_NHWC) {
    OP_REQUIRES_OK(CTX, TRANSFORM_FILTER(FORMAT_OHWI));
  } ELSE {
    CTX->SETSTATUS(ERRORS::INVALIDARGUMENT("INVALID COMPUTE DATA FORMAT: ",
                                           TOSTRING(COMPUTE_DATA_FORMAT)));
    RETURN;
  }

  TENSOR TRANSFORMED_OUTPUT;
  IF (DATA_FORMAT != COMPUTE_DATA_FORMAT) {
    VLOG(4) << "ALLOCATE TEMPORARY MEMORY FOR OUTPUT IN COMPUTE DATA FORMAT";
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::VALUE,
                                SHAPEFROMFORMAT(COMPUTE_DATA_FORMAT, OUT_BATCH,
                                                OUT_ROWS, OUT_COLS, OUT_DEPTHS),
                                &TRANSFORMED_OUTPUT));
  } ELSE {
    TRANSFORMED_OUTPUT = *OUTPUT;
  }

  AUTO INPUT_PTR = ASDEVICEMEMORY(INPUT.TEMPLATE FLAT<T>().DATA(),
                                  INPUT.TEMPLATE FLAT<T>().SIZE());
  AUTO FILTER_PTR =
      ASDEVICEMEMORY(TRANSFORMED_FILTER.TEMPLATE FLAT<T>().DATA(),
                     TRANSFORMED_FILTER.TEMPLATE FLAT<T>().SIZE());
  AUTO OUTPUT_PTR =
      ASDEVICEMEMORY(TRANSFORMED_OUTPUT.TEMPLATE FLAT<T>().DATA(),
                     TRANSFORMED_OUTPUT.TEMPLATE FLAT<T>().SIZE());

  STATIC INT64_T CONVOLVESCRATCHSIZE = GETDNNWORKSPACELIMIT(
      // DEFAULT VALUE IS IN BYTES DESPITE THE NAME OF THE ENVIRONMENT VARIABLE
      "TF_CUDNN_WORKSPACE_LIMIT_IN_MB", 1LL << 32  // 4GB
  );

  INT DEVICE_ID = STREAM->PARENT()->DEVICE_ORDINAL();
  DATATYPE DTYPE = INPUT.DTYPE();
  CONVPARAMETERS CONV_PARAMETERS = {IN_BATCH,             // BATCH
                                    IN_DEPTHS,            // IN_DEPTHS
                                    {{IN_ROWS,            // IN_ROWS
                                      IN_COLS}},          // IN_COLS
                                    COMPUTE_DATA_FORMAT,  // COMPUTE_DATA_FORMAT
                                    OUT_DEPTHS,           // OUT_DEPTHS
                                    {{PATCH_ROWS,         // FILTER_ROWS
                                      PATCH_COLS,         // FILTER_COLS
                                      PATCH_DEPTHS}},     // FILTER_DEPTHS
                                    {{ROW_DILATION,       // DILATION_ROWS
                                      COL_DILATION}},     // DILATION_COLS
                                    {{ROW_STRIDE,         // STRIDE_ROWS
                                      COL_STRIDE}},       // STRIDE_COLS
                                    {{COMMON_PADDING_ROWS,    // PADDING_ROWS
                                      COMMON_PADDING_COLS}},  // PADDING_COLS
                                    DTYPE,                    // TENSOR DATATYPE
                                    DEVICE_ID,                // DEVICE_ID
                                    CONV_DESC.GROUP_COUNT()};

  AUTO ENTRY_OR = AUTOTUNEUNFUSEDCONV(
      CUDNN_USE_AUTOTUNE, CONVAUTOTUNEMAP::GETINSTANCE(), CONV_PARAMETERS, CTX,
      SE::DNN::CONVOLUTIONKIND::FORWARD, INPUT_DESC, INPUT_PTR, FILTER_DESC,
      FILTER_PTR, CONV_DESC, OUTPUT_DESC, OUTPUT_PTR, CONVOLVESCRATCHSIZE);
  OP_REQUIRES_OK(CTX, ENTRY_OR.STATUS());
  AUTO AUTOTUNE_ENTRY = ENTRY_OR.CONSUMEVALUEORDIE();

  DNNSCRATCHALLOCATOR SCRATCH_ALLOCATOR(CONVOLVESCRATCHSIZE, CTX);
  STATUS CUDNN_LAUNCH_STATUS = LAUNCHAUTOTUNEDCONV(
      AUTOTUNE_ENTRY, &SCRATCH_ALLOCATOR, SE::DNN::CONVOLUTIONKIND::FORWARD,
      STREAM, INPUT_DESC, INPUT_PTR, FILTER_DESC, FILTER_PTR, CONV_DESC,
      OUTPUT_DESC, OUTPUT_PTR);
  IF (!CUDNN_LAUNCH_STATUS.OK()) {
    CTX->SETSTATUS(CUDNN_LAUNCH_STATUS);
    RETURN;
  }

  IF (DATA_FORMAT == FORMAT_NHWC && COMPUTE_DATA_FORMAT == FORMAT_NCHW) {
    VLOG(4) << "CONVERT THE OUTPUT TENSOR BACK FROM NCHW TO NHWC.";
    FUNCTOR::NCHWTONHWC<GPUDEVICE, T, 4>()(
        CTX->EIGEN_DEVICE<GPUDEVICE>(),
        CONST_CAST<CONST TENSOR&>(TRANSFORMED_OUTPUT).TENSOR<T, 4>(),
        OUTPUT->TENSOR<T, 4>());
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197318_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& HANDLE = CTX->INPUT(0);
    CONST STRING& NAME = HANDLE.SCALAR<TSTRING>()();
    AUTO SESSION_STATE = CTX->SESSION_STATE();
    OP_REQUIRES(CTX, SESSION_STATE != NULLPTR,
                ERRORS::FAILEDPRECONDITION(
                    "DELETESESSIONTENSOR CALLED ON NULL SESSION STATE"));
    OP_REQUIRES_OK(CTX, SESSION_STATE->DELETETENSOR(NAME));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195768_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // ONLY CREATE ONE, IF ONE DOES NOT EXIST ALREADY. REPORT STATUS FOR ALL
    // OTHER EXCEPTIONS. IF ONE ALREADY EXISTS, IT UNREFS THE NEW ONE.
    // AN EPSILON VALUE OF ZERO COULD CAUSE PERFORMANCE ISSUES AND IS THEREFORE,
    // DISALLOWED.
    CONST TENSOR* EPSILON_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT(KEPSILONNAME, &EPSILON_T));
    FLOAT EPSILON = EPSILON_T->SCALAR<FLOAT>()();
    OP_REQUIRES(
        CONTEXT, EPSILON > 0,
        ERRORS::INVALIDARGUMENT("AN EPSILON VALUE OF ZERO IS NOT ALLOWED."));

    CONST TENSOR* NUM_STREAMS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT(KNUMSTREAMSNAME, &NUM_STREAMS_T));
    INT64_T NUM_STREAMS = NUM_STREAMS_T->SCALAR<INT64>()();

    AUTO RESULT =
        NEW QUANTILESTREAMRESOURCE(EPSILON, MAX_ELEMENTS_, NUM_STREAMS);
    AUTO STATUS = CREATERESOURCE(CONTEXT, HANDLEFROMINPUT(CONTEXT, 0), RESULT);
    IF (!STATUS.OK() && STATUS.CODE() != TENSORFLOW::ERROR::ALREADY_EXISTS) {
      OP_REQUIRES(CONTEXT, FALSE, STATUS);
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247677_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_P(SSLSOCKETTEST, GETURIWITHLOCALURISAN) {
  CONST STD::STRING CLIENT_CTX_YAML = R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
      CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/NO_SAN_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/NO_SAN_KEY.PEM"
)EOF";

  CONST STD::STRING SERVER_CTX_YAML = R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
      CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SAN_URI_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SAN_URI_KEY.PEM"
    VALIDATION_CONTEXT:
      TRUSTED_CA:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/CA_CERT.PEM"
)EOF";

  TESTUTILOPTIONS TEST_OPTIONS(CLIENT_CTX_YAML, SERVER_CTX_YAML, TRUE, GETPARAM());
  TESTUTIL(TEST_OPTIONS.SETEXPECTEDLOCALURI("SPIFFE://LYFT.COM/TEST-TEAM")
               .SETEXPECTEDSERIALNUMBER(TEST_NO_SAN_CERT_SERIAL));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195037_CWE-190.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR* INPUT_INDICES;
    CONST TENSOR* INPUT_VALUES;
    CONST TENSOR* INPUT_SHAPE;
    SPARSETENSORSMAP* MAP;

    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_INDICES", &INPUT_INDICES));
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_VALUES", &INPUT_VALUES));
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_SHAPE", &INPUT_SHAPE));
    OP_REQUIRES_OK(CONTEXT, GETMAP(CONTEXT, TRUE /* IS_WRITING */, &MAP));

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INPUT_INDICES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE ",
                    INPUT_INDICES->SHAPE().DEBUGSTRING()));

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_VALUES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT VALUES SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INPUT_VALUES->SHAPE().DEBUGSTRING()));

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_SHAPE->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INPUT_SHAPE->SHAPE().DEBUGSTRING()));

    INT RANK = INPUT_SHAPE->NUMELEMENTS();

    OP_REQUIRES(
        CONTEXT, RANK > 1,
        ERRORS::INVALIDARGUMENT(
            "RANK OF INPUT SPARSETENSOR SHOULD BE > 1, BUT SAW RANK: ", RANK));

    AUTO INPUT_SHAPE_VEC = INPUT_SHAPE->VEC<INT64_T>();
    INT NEW_NUM_ELEMENTS = 1;
    BOOL OVERFLOW_OCURRED = FALSE;
    FOR (INT I = 0; I < INPUT_SHAPE_VEC.SIZE(); I++) {
      NEW_NUM_ELEMENTS =
          MULTIPLYWITHOUTOVERFLOW(NEW_NUM_ELEMENTS, INPUT_SHAPE_VEC(I));
      IF (NEW_NUM_ELEMENTS < 0) {
        OVERFLOW_OCURRED = TRUE;
        BREAK;
      }
    }

    OP_REQUIRES(
        CONTEXT, !OVERFLOW_OCURRED,
        ERRORS::INTERNAL("ENCOUNTERED OVERFLOW FROM LARGE INPUT SHAPE."));

    TENSORSHAPE TENSOR_INPUT_SHAPE(INPUT_SHAPE_VEC);
    GTL::INLINEDVECTOR<INT64_T, 8> STD_ORDER(RANK);
    STD::IOTA(STD_ORDER.BEGIN(), STD_ORDER.END(), 0);
    SPARSETENSOR INPUT_ST;
    OP_REQUIRES_OK(CONTEXT, SPARSETENSOR::CREATE(*INPUT_INDICES, *INPUT_VALUES,
                                                 TENSOR_INPUT_SHAPE, STD_ORDER,
                                                 &INPUT_ST));

    CONST INT64_T N = INPUT_SHAPE_VEC(0);

    TENSOR SPARSE_HANDLES(DT_INT64, TENSORSHAPE({N}));
    AUTO SPARSE_HANDLES_T = SPARSE_HANDLES.VEC<INT64_T>();

    OP_REQUIRES_OK(CONTEXT, INPUT_ST.INDICESVALID());

    // WE CAN GENERATE THE OUTPUT SHAPE PROTO STRING NOW, FOR ALL
    // MINIBATCH ENTRIES.
    TENSORSHAPE OUTPUT_SHAPE;
    OP_REQUIRES_OK(CONTEXT, TENSORSHAPEUTILS::MAKESHAPE(
                                INPUT_SHAPE_VEC.DATA() + 1,
                                INPUT_SHAPE->NUMELEMENTS() - 1, &OUTPUT_SHAPE));

    // GET GROUPS BY MINIBATCH DIMENSION
    STD::UNORDERED_SET<INT64_T> VISITED;
    SPARSE::GROUPITERABLE MINIBATCH = INPUT_ST.GROUP({0});
    FOR (CONST AUTO& SUBSET : MINIBATCH) {
      CONST INT64_T B = SUBSET.GROUP()[0];
      VISITED.INSERT(B);
      OP_REQUIRES(
          CONTEXT, B > -1 && B < N,
          ERRORS::INVALIDARGUMENT(
              "RECEIVED UNEXPECTED COLUMN 0 VALUE IN INPUT SPARSETENSOR: ", B,
              " < 0 OR >= N (= ", N, ")"));

      CONST AUTO INDICES = SUBSET.INDICES();
      CONST AUTO VALUES = SUBSET.VALUES<T>();
      CONST INT64_T NUM_ENTRIES = VALUES.SIZE();

      TENSOR OUTPUT_INDICES = TENSOR(DT_INT64, {NUM_ENTRIES, RANK - 1});
      TENSOR OUTPUT_VALUES = TENSOR(DATATYPETOENUM<T>::VALUE, {NUM_ENTRIES});

      AUTO OUTPUT_INDICES_T = OUTPUT_INDICES.MATRIX<INT64_T>();
      AUTO OUTPUT_VALUES_T = OUTPUT_VALUES.VEC<T>();

      FOR (INT I = 0; I < NUM_ENTRIES; ++I) {
        FOR (INT D = 1; D < RANK; ++D) {
          OUTPUT_INDICES_T(I, D - 1) = INDICES(I, D);
        }
        OUTPUT_VALUES_T(I) = VALUES(I);
      }

      SPARSETENSOR ST_I;
      OP_REQUIRES_OK(CONTEXT,
                     SPARSETENSOR::CREATE(OUTPUT_INDICES, OUTPUT_VALUES,
                                          OUTPUT_SHAPE, &ST_I));
      INT64_T HANDLE;
      OP_REQUIRES_OK(CONTEXT, MAP->ADDSPARSETENSOR(CONTEXT, ST_I, &HANDLE));
      SPARSE_HANDLES_T(B) = HANDLE;
    }

    // FILL IN ANY GAPS; WE MUST PROVIDE AN EMPTY ST FOR BATCH ENTRIES
    // THE GROUPER DIDN'T FIND.
    IF (VISITED.SIZE() < N) {
      TENSOR EMPTY_INDICES(DT_INT64, {0, RANK - 1});
      TENSOR EMPTY_VALUES(DATATYPETOENUM<T>::VALUE, {0});
      SPARSETENSOR EMPTY_ST;
      OP_REQUIRES_OK(CONTEXT, SPARSETENSOR::CREATE(EMPTY_INDICES, EMPTY_VALUES,
                                                   OUTPUT_SHAPE, &EMPTY_ST));

      FOR (INT64_T B = 0; B < N; ++B) {
        // WE SKIPPED THIS BATCH ENTRY.
        IF (VISITED.FIND(B) == VISITED.END()) {
          INT64_T HANDLE;
          OP_REQUIRES_OK(CONTEXT,
                         MAP->ADDSPARSETENSOR(CONTEXT, EMPTY_ST, &HANDLE));
          SPARSE_HANDLES_T(B) = HANDLE;
        }
      }
    }

    CONTEXT->SET_OUTPUT(0, SPARSE_HANDLES);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195029_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID NODE::RUNFORWARDTYPEINFERENCE() {
  VLOG(4) << "FORWARD TYPE INFERENCE: " << PROPS_->NODE_DEF.DEBUGSTRING();

  IF (PROPS_->FWD_TYPE_FN == NULLPTR) {
    RETURN;
  }

  STD::VECTOR<NODE*> INPUT_NODES(PROPS_->INPUT_TYPES.SIZE(), NULLPTR);
  STD::VECTOR<INT> INPUT_IDX(PROPS_->INPUT_TYPES.SIZE(), 0);
  FOR (CONST AUTO& EDGE : IN_EDGES_) {
    IF (EDGE->ISCONTROLEDGE()) {
      CONTINUE;
    }
    DCHECK(EDGE->DST_INPUT() < INPUT_NODES.SIZE()) << DEBUGSTRING();
    INT I = EDGE->DST_INPUT();
    INPUT_NODES.AT(I) = EDGE->SRC();
    INPUT_IDX.AT(I) = EDGE->SRC_OUTPUT();
  }

  // NOTE: TECHNICALLY, WE COULD USE A VERY GENERIC TYPE WHEN SOME OF THE INPUTS
  // ARE UNKNOWN. BUT THERE IS AN EXPECTATION THAT A NODE WILL HAVE COMPLETE
  // INPUTS SOON, SO UPDATING INTERMEDIATE TYPES IS LARGELY UNNECESSARY.

  FOR (CONST AUTO* NODE : INPUT_NODES) {
    IF (NODE == NULLPTR) {
      // INCOMPLETE INPUTS, BAIL.
      CLEARTYPEINFO();
      RETURN;
    }
  }

  STATIC FULLTYPEDEF* NO_TYPE = NEW FULLTYPEDEF();

  STD::VECTOR<STD::REFERENCE_WRAPPER<CONST FULLTYPEDEF>> INPUT_TYPES;
  FOR (INT I = 0; I < INPUT_NODES.SIZE(); I++) {
    CONST AUTO* NODE = INPUT_NODES[I];
    IF (NODE->DEF().HAS_EXPERIMENTAL_TYPE()) {
      CONST AUTO& NODE_T = NODE->DEF().EXPERIMENTAL_TYPE();
      IF (NODE_T.TYPE_ID() != TFT_UNSET) {
        INT IX = INPUT_IDX[I];
        DCHECK(IX < NODE_T.ARGS_SIZE())
            << "INPUT " << I << " SHOULD HAVE AN OUTPUT " << IX
            << " BUT INSTEAD ONLY HAS " << NODE_T.ARGS_SIZE()
            << " OUTPUTS: " << NODE_T.DEBUGSTRING();
        INPUT_TYPES.EMPLACE_BACK(NODE_T.ARGS(IX));
      } ELSE {
        INPUT_TYPES.EMPLACE_BACK(*NO_TYPE);
      }
    } ELSE {
      // INCOMPLETE INPUTS, BAIL.
      CLEARTYPEINFO();
      RETURN;
    }
  }

  CONST AUTO INFER_TYPE = PROPS_->FWD_TYPE_FN(INPUT_TYPES);
  CONST FULLTYPEDEF INFER_TYPEDEF = INFER_TYPE.VALUEORDIE();
  IF (INFER_TYPEDEF.TYPE_ID() != TFT_UNSET) {
    MAYBECOPYONWRITE();
    *(PROPS_->NODE_DEF.MUTABLE_EXPERIMENTAL_TYPE()) = INFER_TYPEDEF;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 356709_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID STATEMENT::WORK_RESET(NAPI_ENV E, VOID* DATA) {
    STATEMENT_INIT(BATON);

    SQLITE3_RESET(STMT->_HANDLE);
    STMT->STATUS = SQLITE_OK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196893_CWE-362.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID DEFAULTCERTVALIDATOR::UPDATEDIGESTFORSESSIONID(BSSL::SCOPEDEVP_MD_CTX& MD,
                                                    UINT8_T HASH_BUFFER[EVP_MAX_MD_SIZE],
                                                    UNSIGNED HASH_LENGTH) {
  INT RC;

  // HASH ALL THE SETTINGS THAT AFFECT WHETHER THE SERVER WILL ALLOW/ACCEPT
  // THE CLIENT CONNECTION. THIS ENSURES THAT THE CLIENT IS ALWAYS VALIDATED AGAINST
  // THE CORRECT SETTINGS, EVEN IF SESSION RESUMPTION ACROSS DIFFERENT LISTENERS
  // IS ENABLED.
  IF (CA_CERT_ != NULLPTR) {
    RC = X509_DIGEST(CA_CERT_.GET(), EVP_SHA256(), HASH_BUFFER, &HASH_LENGTH);
    RELEASE_ASSERT(RC == 1, UTILITY::GETLASTCRYPTOERROR().VALUE_OR(""));
    RELEASE_ASSERT(HASH_LENGTH == SHA256_DIGEST_LENGTH,
                   FMT::FORMAT("INVALID SHA256 HASH LENGTH {}", HASH_LENGTH));

    RC = EVP_DIGESTUPDATE(MD.GET(), HASH_BUFFER, HASH_LENGTH);
    RELEASE_ASSERT(RC == 1, UTILITY::GETLASTCRYPTOERROR().VALUE_OR(""));
  }

  FOR (CONST AUTO& HASH : VERIFY_CERTIFICATE_HASH_LIST_) {
    RC = EVP_DIGESTUPDATE(MD.GET(), HASH.DATA(),
                          HASH.SIZE() *
                              SIZEOF(STD::REMOVE_REFERENCE<DECLTYPE(HASH)>::TYPE::VALUE_TYPE));
    RELEASE_ASSERT(RC == 1, UTILITY::GETLASTCRYPTOERROR().VALUE_OR(""));
  }

  FOR (CONST AUTO& HASH : VERIFY_CERTIFICATE_SPKI_LIST_) {
    RC = EVP_DIGESTUPDATE(MD.GET(), HASH.DATA(),
                          HASH.SIZE() *
                              SIZEOF(STD::REMOVE_REFERENCE<DECLTYPE(HASH)>::TYPE::VALUE_TYPE));
    RELEASE_ASSERT(RC == 1, UTILITY::GETLASTCRYPTOERROR().VALUE_OR(""));
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198169_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITETENSOR* GETVARIABLEINPUT(TFLITECONTEXT* CONTEXT, CONST TFLITENODE* NODE,
                               INT INDEX) {
  TFLITETENSOR* TENSOR = GETMUTABLEINPUT(CONTEXT, NODE, INDEX);
  RETURN TENSOR->IS_VARIABLE ? TENSOR : NULLPTR;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198003_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    AUTO X = CTX->INPUT(0);
    AUTO I = CTX->INPUT(1);
    AUTO V = CTX->INPUT(2);

    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISVECTOR(I.SHAPE()),
                ERRORS::INVALIDARGUMENT("I MUST BE A VECTOR. ",
                                        I.SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX, X.DIMS() == V.DIMS(),
                ERRORS::INVALIDARGUMENT(
                    "X AND V SHAPE DOESN'T MATCH (RANKS DIFFER): ",
                    X.SHAPE().DEBUGSTRING(), " VS. ", V.SHAPE().DEBUGSTRING()));
    FOR (INT I = 1; I < X.DIMS(); ++I) {
      OP_REQUIRES(
          CTX, X.DIM_SIZE(I) == V.DIM_SIZE(I),
          ERRORS::INVALIDARGUMENT("X AND V SHAPE DOESN'T MATCH AT INDEX ", I,
                                  " : ", X.SHAPE().DEBUGSTRING(), " VS. ",
                                  V.SHAPE().DEBUGSTRING()));
    }
    OP_REQUIRES(CTX, I.DIM_SIZE(0) == V.DIM_SIZE(0),
                ERRORS::INVALIDARGUMENT(
                    "I AND X SHAPE DOESN'T MATCH AT INDEX 0: ",
                    I.SHAPE().DEBUGSTRING(), " VS. ", V.SHAPE().DEBUGSTRING()));

    TENSOR Y = X;  // THIS CREATES AN ALIAS INTENTIONALLY.
    // SKIP PROCESSING IF TENSORS ARE EMPTY.
    IF (X.NUMELEMENTS() > 0 || V.NUMELEMENTS() > 0) {
      OP_REQUIRES_OK(CTX, DOCOMPUTE(CTX, I, V, &Y));
    }
    CTX->SET_OUTPUT(0, Y);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198523_CWE-416.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // GET THE STAMP TOKEN.
    CONST TENSOR* STAMP_TOKEN_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("STAMP_TOKEN", &STAMP_TOKEN_T));
    INT64_T STAMP_TOKEN = STAMP_TOKEN_T->SCALAR<INT64>()();

    // GET THE TREE ENSEMBLE PROTO.
    CONST TENSOR* TREE_ENSEMBLE_SERIALIZED_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("TREE_ENSEMBLE_SERIALIZED",
                                           &TREE_ENSEMBLE_SERIALIZED_T));
    STD::UNIQUE_PTR<BOOSTEDTREESENSEMBLERESOURCE> RESULT(
        NEW BOOSTEDTREESENSEMBLERESOURCE());
    IF (!RESULT->INITFROMSERIALIZED(
            TREE_ENSEMBLE_SERIALIZED_T->SCALAR<TSTRING>()(), STAMP_TOKEN)) {
      RESULT->UNREF();
      OP_REQUIRES(
          CONTEXT, FALSE,
          ERRORS::INVALIDARGUMENT("UNABLE TO PARSE TREE ENSEMBLE PROTO."));
    }

    // ONLY CREATE ONE, IF ONE DOES NOT EXIST ALREADY. REPORT STATUS FOR ALL
    // OTHER EXCEPTIONS.
    AUTO STATUS =
        CREATERESOURCE(CONTEXT, HANDLEFROMINPUT(CONTEXT, 0), RESULT.RELEASE());
    IF (STATUS.CODE() != TENSORFLOW::ERROR::ALREADY_EXISTS) {
      OP_REQUIRES_OK(CONTEXT, STATUS);
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195019_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS CONSTANTFOLDING::EVALUATEONEFOLDABLE(CONST NODEDEF& NODE,
                                            STD::VECTOR<NODEDEF>* OUTPUTS,
                                            BOOL* RESULT_TOO_LARGE) {
  TENSORVECTOR INPUTS;
  TENSORVECTOR OUTPUT_TENSORS;
  AUTO INPUTS_CLEANUP = GTL::MAKECLEANUP([&INPUTS, &OUTPUT_TENSORS] {
    FOR (CONST AUTO& INPUT : INPUTS) {
      DELETE INPUT.TENSOR;
    }
    FOR (CONST AUTO& OUTPUT : OUTPUT_TENSORS) {
      IF (OUTPUT.TENSOR) {
        DELETE OUTPUT.TENSOR;
      }
    }
  });

  SIZE_T TOTAL_INPUTS_SIZE = 0;
  FOR (CONST AUTO& INPUT : NODE.INPUT()) {
    CONST TENSORID INPUT_TENSOR = PARSETENSORNAME(INPUT);
    IF (INPUT_TENSOR.INDEX() < 0) {
      // CONTROL DEPENDENCY
      BREAK;
    }
    CONST NODEDEF* INPUT_NODE = NODE_MAP_->GETNODE(INPUT);
    IF (!ISREALLYCONSTANT(*INPUT_NODE)) {
      RETURN STATUS(ERROR::INVALID_ARGUMENT,
                    STRINGS::STRCAT("CAN'T FOLD ", NODE.NAME(), ", ITS ", INPUT,
                                    " ISN'T CONSTANT"));
    }
    TF_RETURN_IF_ERROR(CHECKATTREXISTS(*INPUT_NODE, "VALUE"));
    CONST TENSORPROTO& RAW_VAL = INPUT_NODE->ATTR().AT("VALUE").TENSOR();
    IF (RAW_VAL.DTYPE() == DT_INVALID) {
      RETURN STATUS(
          ERROR::INVALID_ARGUMENT,
          STRINGS::STRCAT("A TENSOR IN THE INPUT NODE, WITH TENSORID OF ",
                          INPUT_TENSOR.TOSTRING(),
                          " HAS A DTYPE OF DT_INVALID."));
    }
    TENSOR* VALUE = NEW TENSOR(RAW_VAL.DTYPE(), RAW_VAL.TENSOR_SHAPE());
    IF (!VALUE->FROMPROTO(RAW_VAL)) {
      DELETE (VALUE);
      RETURN ERRORS::INVALIDARGUMENT("UNABLE TO MAKE TENSOR FROM PROTO FOR ",
                                     NODE.NAME(), " WITH SHAPE ",
                                     RAW_VAL.TENSOR_SHAPE().DEBUGSTRING());
    }
    INPUTS.EMPLACE_BACK(VALUE);
    TOTAL_INPUTS_SIZE += VALUE->TOTALBYTES();
  }

  TF_RETURN_IF_ERROR(EVALUATENODE(NODE, INPUTS, &OUTPUT_TENSORS));
  IF (OUTPUT_TENSORS.EMPTY()) {
    RETURN STATUS(ERROR::INVALID_ARGUMENT, "EXPECTED AT LEAST ONE OUTPUT.");
  }

  OUTPUTS->RESIZE(OUTPUT_TENSORS.SIZE());
  FOR (SIZE_T I = 0; I < OUTPUT_TENSORS.SIZE(); I++) {
    STRING NODE_NAME = OPTIMIZEDNODENAME(NODE, "-FOLDED");
    IF (OUTPUT_TENSORS.SIZE() > 1) {
      NODE_NAME = STRINGS::STRCAT(NODE_NAME, "-", I);
    }
    IF (OUTPUT_TENSORS[I].TENSOR) {
      STATUS S = CREATENODEDEF(NODE_NAME, OUTPUT_TENSORS[I], &OUTPUTS->AT(I),
                               TOTAL_INPUTS_SIZE);
      IF (!S.OK()) {
        *RESULT_TOO_LARGE = TRUE;
        RETURN S;
      }
    } ELSE {
      // CREATE AN EMPTY NODEDEF TO IDENTIFY DEAD OUTPUTS (E.G. THE OUTPUT OF A
      // SWITCH THAT'S NOT SELECTED BY THE SWITCH PREDICATE).
      OUTPUTS->AT(I) = NODEDEF();
    }
  }
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196790_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS EXAMPLES::INITIALIZE(OPKERNELCONTEXT* CONST CONTEXT,
                            CONST MODELWEIGHTS& WEIGHTS,
                            CONST INT NUM_SPARSE_FEATURES,
                            CONST INT NUM_SPARSE_FEATURES_WITH_VALUES,
                            CONST INT NUM_DENSE_FEATURES) {
  NUM_FEATURES_ = NUM_SPARSE_FEATURES + NUM_DENSE_FEATURES;

  OPINPUTLIST SPARSE_EXAMPLE_INDICES_INPUTS;
  TF_RETURN_IF_ERROR(CONTEXT->INPUT_LIST("SPARSE_EXAMPLE_INDICES",
                                         &SPARSE_EXAMPLE_INDICES_INPUTS));
  IF (SPARSE_EXAMPLE_INDICES_INPUTS.SIZE() != NUM_SPARSE_FEATURES)
    RETURN ERRORS::INVALIDARGUMENT(
        "EXPECTED ", NUM_SPARSE_FEATURES,
        " TENSORS IN SPARSE_EXAMPLE_INDICES BUT GOT ",
        SPARSE_EXAMPLE_INDICES_INPUTS.SIZE());
  OPINPUTLIST SPARSE_FEATURE_INDICES_INPUTS;
  TF_RETURN_IF_ERROR(CONTEXT->INPUT_LIST("SPARSE_FEATURE_INDICES",
                                         &SPARSE_FEATURE_INDICES_INPUTS));
  IF (SPARSE_FEATURE_INDICES_INPUTS.SIZE() != NUM_SPARSE_FEATURES)
    RETURN ERRORS::INVALIDARGUMENT(
        "EXPECTED ", NUM_SPARSE_FEATURES,
        " TENSORS IN SPARSE_FEATURE_INDICES BUT GOT ",
        SPARSE_FEATURE_INDICES_INPUTS.SIZE());
  OPINPUTLIST SPARSE_FEATURE_VALUES_INPUTS;
  IF (NUM_SPARSE_FEATURES_WITH_VALUES > 0) {
    TF_RETURN_IF_ERROR(CONTEXT->INPUT_LIST("SPARSE_FEATURE_VALUES",
                                           &SPARSE_FEATURE_VALUES_INPUTS));
    IF (SPARSE_FEATURE_VALUES_INPUTS.SIZE() != NUM_SPARSE_FEATURES_WITH_VALUES)
      RETURN ERRORS::INVALIDARGUMENT(
          "EXPECTED ", NUM_SPARSE_FEATURES_WITH_VALUES,
          " TENSORS IN SPARSE_FEATURE_VALUES BUT GOT ",
          SPARSE_FEATURE_VALUES_INPUTS.SIZE());
  }

  CONST TENSOR* EXAMPLE_WEIGHTS_T;
  TF_RETURN_IF_ERROR(CONTEXT->INPUT("EXAMPLE_WEIGHTS", &EXAMPLE_WEIGHTS_T));
  AUTO EXAMPLE_WEIGHTS = EXAMPLE_WEIGHTS_T->FLAT<FLOAT>();

  IF (EXAMPLE_WEIGHTS.SIZE() >= STD::NUMERIC_LIMITS<INT>::MAX()) {
    RETURN ERRORS::INVALIDARGUMENT(STRINGS::PRINTF(
        "TOO MANY EXAMPLES IN A MINI-BATCH: %ZU > %D", EXAMPLE_WEIGHTS.SIZE(),
        STD::NUMERIC_LIMITS<INT>::MAX()));
  }

  // THE STATIC_CAST HERE IS SAFE SINCE NUM_EXAMPLES CAN BE AT MAX AN INT.
  CONST INT NUM_EXAMPLES = STATIC_CAST<INT>(EXAMPLE_WEIGHTS.SIZE());
  CONST TENSOR* EXAMPLE_LABELS_T;
  TF_RETURN_IF_ERROR(CONTEXT->INPUT("EXAMPLE_LABELS", &EXAMPLE_LABELS_T));
  AUTO EXAMPLE_LABELS = EXAMPLE_LABELS_T->FLAT<FLOAT>();

  OPINPUTLIST DENSE_FEATURES_INPUTS;
  TF_RETURN_IF_ERROR(
      CONTEXT->INPUT_LIST("DENSE_FEATURES", &DENSE_FEATURES_INPUTS));

  EXAMPLES_.CLEAR();
  EXAMPLES_.RESIZE(NUM_EXAMPLES);
  PROBABILITIES_.RESIZE(NUM_EXAMPLES);
  SAMPLED_INDEX_.RESIZE(NUM_EXAMPLES);
  SAMPLED_COUNT_.RESIZE(NUM_EXAMPLES);
  FOR (INT EXAMPLE_ID = 0; EXAMPLE_ID < NUM_EXAMPLES; ++EXAMPLE_ID) {
    EXAMPLE* CONST EXAMPLE = &EXAMPLES_[EXAMPLE_ID];
    EXAMPLE->SPARSE_FEATURES_.RESIZE(NUM_SPARSE_FEATURES);
    EXAMPLE->DENSE_VECTORS_.RESIZE(NUM_DENSE_FEATURES);
    EXAMPLE->EXAMPLE_WEIGHT_ = EXAMPLE_WEIGHTS(EXAMPLE_ID);
    EXAMPLE->EXAMPLE_LABEL_ = EXAMPLE_LABELS(EXAMPLE_ID);
  }
  CONST DEVICEBASE::CPUWORKERTHREADS& WORKER_THREADS =
      *CONTEXT->DEVICE()->TENSORFLOW_CPU_WORKER_THREADS();
  TF_RETURN_IF_ERROR(CREATESPARSEFEATUREREPRESENTATION(
      WORKER_THREADS, NUM_EXAMPLES, NUM_SPARSE_FEATURES, WEIGHTS,
      SPARSE_EXAMPLE_INDICES_INPUTS, SPARSE_FEATURE_INDICES_INPUTS,
      SPARSE_FEATURE_VALUES_INPUTS, &EXAMPLES_));
  TF_RETURN_IF_ERROR(CREATEDENSEFEATUREREPRESENTATION(
      WORKER_THREADS, NUM_EXAMPLES, NUM_DENSE_FEATURES, WEIGHTS,
      DENSE_FEATURES_INPUTS, &EXAMPLES_));
  TF_RETURN_IF_ERROR(COMPUTESQUAREDNORMPEREXAMPLE(
      WORKER_THREADS, NUM_EXAMPLES, NUM_SPARSE_FEATURES, NUM_DENSE_FEATURES,
      &EXAMPLES_));
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 222504_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS FUNCTIONLIBRARYDEFINITION::ADDFUNCTIONDEFHELPER(
    CONST FUNCTIONDEF& FDEF, CONST STACKTRACESMAP& STACK_TRACES, BOOL* ADDED) {
  *ADDED = FALSE;
  STD::SHARED_PTR<FUNCTIONDEFANDOPREGISTRATION>& ENTRY =
      FUNCTION_DEFS_[FDEF.SIGNATURE().NAME()];
  IF (ENTRY) {
    IF (!FUNCTIONDEFSEQUAL(ENTRY->FDEF, FDEF)) {
      RETURN ERRORS::INVALIDARGUMENT(
          "CANNOT ADD FUNCTION '", FDEF.SIGNATURE().NAME(),
          "' BECAUSE A DIFFERENT FUNCTION WITH THE SAME NAME ALREADY "
          "EXISTS.");
    }
    // IGNORE DUPLICATE FUNCTIONDEFS.
    RETURN STATUS::OK();
  }
  CONST OPDEF* OP_DEF;
  IF (DEFAULT_REGISTRY_->LOOKUPOPDEF(FDEF.SIGNATURE().NAME(), &OP_DEF).OK()) {
    RETURN ERRORS::INVALIDARGUMENT(
        "CANNOT ADD FUNCTION '", FDEF.SIGNATURE().NAME(),
        "' BECAUSE AN OP WITH THE SAME NAME ALREADY EXISTS.");
  }
  ENTRY = STD::MAKE_SHARED<FUNCTIONDEFANDOPREGISTRATION>(FDEF, STACK_TRACES);
  *ADDED = TRUE;
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195234_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  STATUS BUILDINPUTARGINDEX(CONST OPDEF::ARGDEF& ARG_DEF, ATTRSLICE ATTR_VALUES,
                            CONST FUNCTIONDEF::ARGATTRS* ARG_ATTRS,
                            BOOL INTS_ON_DEVICE,
                            INT64_T RESOURCE_ARG_UNIQUE_ID) {
    BOOL IS_TYPE_LIST;
    DATATYPEVECTOR DTYPES;
    TF_RETURN_IF_ERROR(
        ARGNUMTYPE(ATTR_VALUES, ARG_DEF, &IS_TYPE_LIST, &DTYPES));
    IF (DTYPES.SIZE() < SIZE_T{1}) {
      RETURN ERRORS::INTERNAL("EXPECTED A LIST OF AT LEAST ONE DTYPE");
    }
    INT ARG_INDEX = RESULT_.NODES.SIZE();
    TF_RETURN_IF_ERROR(
        ADDITEM(ARG_DEF.NAME(), {TRUE, ARG_INDEX, 0, IS_TYPE_LIST, DTYPES}));
    // CREATES DTYPES.SIZE() NODES IN THE GRAPH.
    FOR (SIZE_T I = 0; I < DTYPES.SIZE(); ++I) {
      TF_RETURN_IF_ERROR(ADDITEM(STRINGS::STRCAT(ARG_DEF.NAME(), ":", I),
                                 {TRUE, ARG_INDEX, 0, FALSE, {DTYPES[I]}}));
      DCHECK_EQ(ARG_INDEX, RESULT_.NODES.SIZE());
      STRING NAME = ARG_DEF.NAME();
      IF (DTYPES.SIZE() > 1) {
        STRINGS::STRAPPEND(&NAME, "_", I);
      }
      NODEDEF* GNODE = ADDNODE(NAME);
      IF (INTS_ON_DEVICE && DTYPES[I] == DATATYPE::DT_INT32) {
        GNODE->SET_OP(FUNCTIONLIBRARYDEFINITION::KDEVICEARGOP);
      } ELSE {
        GNODE->SET_OP(FUNCTIONLIBRARYDEFINITION::KARGOP);
      }
      DATATYPE DTYPE = ARG_DEF.IS_REF() ? MAKEREFTYPE(DTYPES[I]) : DTYPES[I];
      ADDATTR("T", DTYPE, GNODE);
      ADDATTR("INDEX", ARG_INDEX, GNODE);
      IF (RESOURCE_ARG_UNIQUE_ID >= 0) {
        ADDATTR("_RESOURCE_ARG_UNIQUE_ID", RESOURCE_ARG_UNIQUE_ID, GNODE);
      }
      IF (ARG_ATTRS) {
        FOR (CONST AUTO& ARG_ATTR : ARG_ATTRS->ATTR()) {
          ADDATTR(ARG_ATTR.FIRST, ARG_ATTR.SECOND, GNODE->MUTABLE_ATTR());
        }
      }
      RESULT_.ARG_TYPES.PUSH_BACK(DTYPES[I]);
      ++ARG_INDEX;
    }
    RETURN STATUS::OK();
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196846_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITESTATUS EVAL(TFLITECONTEXT* CONTEXT, TFLITENODE* NODE) {
  AUTO* PARAMS = REINTERPRET_CAST<TFLITEDIVPARAMS*>(NODE->BUILTIN_DATA);
  OPDATA* DATA = REINTERPRET_CAST<OPDATA*>(NODE->USER_DATA);

  CONST TFLITETENSOR* INPUT1;
  TF_LITE_ENSURE_OK(CONTEXT,
                    GETINPUTSAFE(CONTEXT, NODE, KINPUTTENSOR1, &INPUT1));
  CONST TFLITETENSOR* INPUT2;
  TF_LITE_ENSURE_OK(CONTEXT,
                    GETINPUTSAFE(CONTEXT, NODE, KINPUTTENSOR2, &INPUT2));
  TFLITETENSOR* OUTPUT;
  TF_LITE_ENSURE_OK(CONTEXT,
                    GETOUTPUTSAFE(CONTEXT, NODE, KOUTPUTTENSOR, &OUTPUT));

  IF (OUTPUT->TYPE == KTFLITEFLOAT32 || OUTPUT->TYPE == KTFLITEINT32) {
    EVALDIV<KERNEL_TYPE>(CONTEXT, NODE, PARAMS, DATA, INPUT1, INPUT2, OUTPUT);
  } ELSE IF (OUTPUT->TYPE == KTFLITEUINT8) {
    TF_LITE_ENSURE_OK(
        CONTEXT, EVALQUANTIZED<KERNEL_TYPE>(CONTEXT, NODE, PARAMS, DATA, INPUT1,
                                            INPUT2, OUTPUT));
  } ELSE {
    CONTEXT->REPORTERROR(
        CONTEXT,
        "DIV ONLY SUPPORTS FLOAT32, INT32 AND QUANTIZED UINT8 NOW, GOT %D.",
        OUTPUT->TYPE);
    RETURN KTFLITEERROR;
  }

  RETURN KTFLITEOK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 222525_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS FUNCTIONLIBRARYDEFINITION::REMOVE(
    CONST STD::VECTOR<STRING>& FUNCS,
    CONST STD::VECTOR<STRING>& FUNCS_WITH_GRADS) {
  STATUS S;
  FOR (CONST STRING& F : FUNCS) {
    S = REMOVEFUNCTIONHELPER(F);
    IF (!S.OK()) {
      RETURN S;
    }
  }
  FOR (CONST STRING& F : FUNCS_WITH_GRADS) {
    S = REMOVEGRADIENT(F);
    IF (!S.OK()) {
      RETURN S;
    }
  }
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 261393_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC ENUM INTERPREDIDC  DECODE_INTER_PRED_IDC(THREAD_CONTEXT* TCTX,
                                               INT X0, INT Y0,
                                               INT NPBW, INT NPBH,
                                               INT CTDEPTH)
{
  LOGTRACE(LOGSLICE,"# INTER_PRED_IDC\N");

  INT VALUE;

  CONTEXT_MODEL* MODEL = &TCTX->CTX_MODEL[CONTEXT_MODEL_INTER_PRED_IDC];

  IF (NPBW+NPBH==12) {
    VALUE = DECODE_CABAC_BIT(&TCTX->CABAC_DECODER,
                             &MODEL[4]);
  }
  ELSE {
    INT BIT0 = DECODE_CABAC_BIT(&TCTX->CABAC_DECODER,
                                &MODEL[CTDEPTH]);
    IF (BIT0==0) {
      VALUE = DECODE_CABAC_BIT(&TCTX->CABAC_DECODER,
                               &MODEL[4]);
    }
    ELSE {
      VALUE = 2;
    }
  }

  LOGTRACE(LOGSLICE,"> INTER_PRED_IDC = %D (%S)\N",VALUE,
           VALUE==0 ? "L0" : (VALUE==1 ? "L1" : "BI"));

  LOGTRACE(LOGSYMBOLS,"$1 DECODE_INTER_PRED_IDX=%D\N",VALUE+1);

  RETURN (ENUM INTERPREDIDC) (VALUE+1);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195752_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID MAKEDATASET(OPKERNELCONTEXT* CTX, DATASETBASE** OUTPUT) OVERRIDE {
    // CREATE A NEW SPARSETENSORSLICEDATASETOP::DATASET, INSERT IT IN
    // THE STEP CONTAINER, AND RETURN IT AS THE OUTPUT.
    CONST TENSOR* INDICES;
    OP_REQUIRES_OK(CTX, CTX->INPUT("INDICES", &INDICES));
    CONST TENSOR* VALUES;
    OP_REQUIRES_OK(CTX, CTX->INPUT("VALUES", &VALUES));
    CONST TENSOR* DENSE_SHAPE;
    OP_REQUIRES_OK(CTX, CTX->INPUT("DENSE_SHAPE", &DENSE_SHAPE));

    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISMATRIX(INDICES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE ",
                    INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISVECTOR(VALUES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT VALUES SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISVECTOR(DENSE_SHAPE->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    DENSE_SHAPE->SHAPE().DEBUGSTRING()));

    // WE CURRENTLY ENSURE THAT `SPARSE_TENSOR` IS ORDERED IN THE
    // BATCH DIMENSION.
    // TODO(MRRY): INVESTIGATE WAYS TO AVOID THIS UNCONDITIONAL CHECK
    // IF WE CAN BE SURE THAT THE SPARSE TENSOR WAS PRODUCED IN AN
    // APPROPRIATE ORDER (E.G. BY `TF.PARSE_EXAMPLE()` OR A DATASET
    // THAT BATCHES ELEMENTS INTO ROWS OF A SPARSETENSOR).
    INT64_T PREVIOUS_BATCH_INDEX = -1;
    FOR (INT64_T I = 0; I < INDICES->DIM_SIZE(0); ++I) {
      INT64_T NEXT_BATCH_INDEX = INDICES->MATRIX<INT64>()(I, 0);
      OP_REQUIRES(
          CTX, NEXT_BATCH_INDEX >= PREVIOUS_BATCH_INDEX,
          ERRORS::UNIMPLEMENTED("THE SPARSETENSOR MUST BE ORDERED IN THE BATCH "
                                "DIMENSION; HANDLING ARBITRARILY ORDERED INPUT "
                                "IS NOT CURRENTLY SUPPORTED."));
      PREVIOUS_BATCH_INDEX = NEXT_BATCH_INDEX;
    }
    GTL::INLINEDVECTOR<INT64, 8> STD_ORDER(DENSE_SHAPE->NUMELEMENTS(), 0);
    SPARSE::SPARSETENSOR TENSOR;
    OP_REQUIRES_OK(
        CTX, SPARSE::SPARSETENSOR::CREATE(
                 *INDICES, *VALUES, TENSORSHAPE(DENSE_SHAPE->VEC<INT64>()),
                 STD_ORDER, &TENSOR));
    *OUTPUT = NEW DATASET<T>(CTX, STD::MOVE(TENSOR));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220220_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID GRAPH::REMOVENODE(NODE* NODE) {
  TF_DCHECK_OK(ISVALIDNODE(NODE)) << NODE->DEBUGSTRING();
  DCHECK(!NODE->ISSOURCE());
  DCHECK(!NODE->ISSINK());

  // REMOVE ANY EDGES INVOLVING THIS NODE.
  FOR (CONST EDGE* E : NODE->IN_EDGES_) {
    CHECK_EQ(E->SRC_->OUT_EDGES_.ERASE(E), SIZE_T{1});
    EDGES_[E->ID_] = NULLPTR;
    RECYCLEEDGE(E);
    --NUM_EDGES_;
  }
  NODE->IN_EDGES_.CLEAR();
  FOR (CONST EDGE* E : NODE->OUT_EDGES_) {
    CHECK_EQ(E->DST_->IN_EDGES_.ERASE(E), SIZE_T{1});
    EDGES_[E->ID_] = NULLPTR;
    RECYCLEEDGE(E);
    --NUM_EDGES_;
  }
  NODE->OUT_EDGES_.CLEAR();
  RELEASENODE(NODE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196993_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS DECODEIMAGEAPNG(SPAN<CONST UINT8_T> BYTES, THREADPOOL* POOL,
                       CODECINOUT* IO) {
  READER R;
  UNSIGNED INT ID, I, J, W, H, W0, H0, X0, Y0;
  UNSIGNED INT DELAY_NUM, DELAY_DEN, DOP, BOP, ROWBYTES, IMAGESIZE;
  UNSIGNED CHAR SIG[8];
  PNG_STRUCTP PNG_PTR;
  PNG_INFOP INFO_PTR;
  CHUNK CHUNK;
  CHUNK CHUNKIHDR;
  STD::VECTOR<CHUNK> CHUNKSINFO;
  BOOL ISANIMATED = FALSE;
  BOOL SKIPFIRST = FALSE;
  BOOL HASINFO = FALSE;
  BOOL ALL_DISPOSE_BG = TRUE;
  APNGFRAME FRAMERAW = {};

  R = {BYTES.DATA(), BYTES.DATA() + BYTES.SIZE()};
  // NOT AN APNG => NOT AN ERROR
  UNSIGNED CHAR PNG_SIGNATURE[8] = {137, 80, 78, 71, 13, 10, 26, 10};
  IF (R.READ(SIG, 8) || MEMCMP(SIG, PNG_SIGNATURE, 8) != 0) {
    RETURN FALSE;
  }
  ID = READ_CHUNK(&R, &CHUNKIHDR);

  IO->FRAMES.CLEAR();
  IO->DEC_PIXELS = 0;
  IO->METADATA.M.SETUINTSAMPLES(8);
  IO->METADATA.M.SETALPHABITS(8);
  IO->METADATA.M.COLOR_ENCODING =
      COLORENCODING::SRGB();  // TODO: GET DATA FROM PNG METADATA
  (VOID)IO->DEC_HINTS.FOREACH(
      [](CONST STD::STRING& KEY, CONST STD::STRING& /*VALUE*/) {
        JXL_WARNING("APNG DECODER IGNORING %S HINT", KEY.C_STR());
        RETURN TRUE;
      });

  BOOL ERRORSTATE = TRUE;
  IF (ID == KID_IHDR && CHUNKIHDR.SIZE == 25) {
    W0 = W = PNG_GET_UINT_32(CHUNKIHDR.P + 8);
    H0 = H = PNG_GET_UINT_32(CHUNKIHDR.P + 12);

    IF (W > CMAXPNGSIZE || H > CMAXPNGSIZE) {
      RETURN FALSE;
    }

    X0 = 0;
    Y0 = 0;
    DELAY_NUM = 1;
    DELAY_DEN = 10;
    DOP = 0;
    BOP = 0;
    ROWBYTES = W * 4;
    IMAGESIZE = H * ROWBYTES;

    FRAMERAW.P = NEW UNSIGNED CHAR[IMAGESIZE];
    FRAMERAW.ROWS = NEW PNG_BYTEP[H * SIZEOF(PNG_BYTEP)];
    FOR (J = 0; J < H; J++) FRAMERAW.ROWS[J] = FRAMERAW.P + J * ROWBYTES;

    IF (!PROCESSING_START(PNG_PTR, INFO_PTR, (VOID*)&FRAMERAW, HASINFO,
                          CHUNKIHDR, CHUNKSINFO)) {
      BOOL LAST_BASE_WAS_NONE = TRUE;
      WHILE (!R.EOF()) {
        ID = READ_CHUNK(&R, &CHUNK);
        IF (!ID) BREAK;
        JXL_ASSERT(CHUNK.P != NULLPTR);

        IF (ID == KID_ACTL && !HASINFO && !ISANIMATED) {
          ISANIMATED = TRUE;
          SKIPFIRST = TRUE;
          IO->METADATA.M.HAVE_ANIMATION = TRUE;
          IO->METADATA.M.ANIMATION.TPS_NUMERATOR = 1000;
        } ELSE IF (ID == KID_IEND ||
                   (ID == KID_FCTL && (!HASINFO || ISANIMATED))) {
          IF (HASINFO) {
            IF (!PROCESSING_FINISH(PNG_PTR, INFO_PTR)) {
              IMAGEBUNDLE BUNDLE(&IO->METADATA.M);
              BUNDLE.DURATION = DELAY_NUM * 1000 / DELAY_DEN;
              BUNDLE.ORIGIN.X0 = X0;
              BUNDLE.ORIGIN.Y0 = Y0;
              // TODO(VELUCA): THIS COULD IN PRINCIPLE BE IMPLEMENTED.
              IF (LAST_BASE_WAS_NONE && !ALL_DISPOSE_BG &&
                  (X0 != 0 || Y0 != 0 || W0 != W || H0 != H || BOP != 0)) {
                RETURN JXL_FAILURE(
                    "APNG WITH DISPOSE-TO-0 IS NOT SUPPORTED FOR NON-FULL OR "
                    "BLENDED FRAMES");
              }
              SWITCH (DOP) {
                CASE 0:
                  BUNDLE.USE_FOR_NEXT_FRAME = TRUE;
                  LAST_BASE_WAS_NONE = FALSE;
                  ALL_DISPOSE_BG = FALSE;
                  BREAK;
                CASE 2:
                  BUNDLE.USE_FOR_NEXT_FRAME = FALSE;
                  ALL_DISPOSE_BG = FALSE;
                  BREAK;
                DEFAULT:
                  BUNDLE.USE_FOR_NEXT_FRAME = FALSE;
                  LAST_BASE_WAS_NONE = TRUE;
              }
              BUNDLE.BLEND = BOP != 0;
              IO->DEC_PIXELS += W0 * H0;

              IMAGE3F SUB_FRAME(W0, H0);
              IMAGEF SUB_FRAME_ALPHA(W0, H0);
              FOR (SIZE_T Y = 0; Y < H0; ++Y) {
                FLOAT* CONST JXL_RESTRICT ROW_R = SUB_FRAME.PLANEROW(0, Y);
                FLOAT* CONST JXL_RESTRICT ROW_G = SUB_FRAME.PLANEROW(1, Y);
                FLOAT* CONST JXL_RESTRICT ROW_B = SUB_FRAME.PLANEROW(2, Y);
                FLOAT* CONST JXL_RESTRICT ROW_ALPHA = SUB_FRAME_ALPHA.ROW(Y);
                UINT8_T* CONST F = FRAMERAW.ROWS[Y];
                FOR (SIZE_T X = 0; X < W0; ++X) {
                  IF (F[4 * X + 3] == 0) {
                    ROW_ALPHA[X] = 0;
                    ROW_R[X] = 0;
                    ROW_G[X] = 0;
                    ROW_B[X] = 0;
                    CONTINUE;
                  }
                  ROW_R[X] = F[4 * X + 0] * (1.F / 255);
                  ROW_G[X] = F[4 * X + 1] * (1.F / 255);
                  ROW_B[X] = F[4 * X + 2] * (1.F / 255);
                  ROW_ALPHA[X] = F[4 * X + 3] * (1.F / 255);
                }
              }
              BUNDLE.SETFROMIMAGE(STD::MOVE(SUB_FRAME), COLORENCODING::SRGB());
              BUNDLE.SETALPHA(STD::MOVE(SUB_FRAME_ALPHA),
                              /*ALPHA_IS_PREMULTIPLIED=*/FALSE);
              IO->FRAMES.PUSH_BACK(STD::MOVE(BUNDLE));
            } ELSE {
              DELETE[] CHUNK.P;
              BREAK;
            }
          }

          IF (ID == KID_IEND) {
            ERRORSTATE = FALSE;
            BREAK;
          }
          // AT THIS POINT THE OLD FRAME IS DONE. LET'S START A NEW ONE.
          W0 = PNG_GET_UINT_32(CHUNK.P + 12);
          H0 = PNG_GET_UINT_32(CHUNK.P + 16);
          X0 = PNG_GET_UINT_32(CHUNK.P + 20);
          Y0 = PNG_GET_UINT_32(CHUNK.P + 24);
          DELAY_NUM = PNG_GET_UINT_16(CHUNK.P + 28);
          DELAY_DEN = PNG_GET_UINT_16(CHUNK.P + 30);
          DOP = CHUNK.P[32];
          BOP = CHUNK.P[33];

          IF (W0 > CMAXPNGSIZE || H0 > CMAXPNGSIZE || X0 > CMAXPNGSIZE ||
              Y0 > CMAXPNGSIZE || X0 + W0 > W || Y0 + H0 > H || DOP > 2 ||
              BOP > 1) {
            DELETE[] CHUNK.P;
            BREAK;
          }

          IF (HASINFO) {
            MEMCPY(CHUNKIHDR.P + 8, CHUNK.P + 12, 8);
            IF (PROCESSING_START(PNG_PTR, INFO_PTR, (VOID*)&FRAMERAW, HASINFO,
                                 CHUNKIHDR, CHUNKSINFO)) {
              DELETE[] CHUNK.P;
              BREAK;
            }
          } ELSE
            SKIPFIRST = FALSE;

          IF (IO->FRAMES.SIZE() == (SKIPFIRST ? 1 : 0)) {
            BOP = 0;
            IF (DOP == 2) DOP = 1;
          }
        } ELSE IF (ID == KID_IDAT) {
          HASINFO = TRUE;
          IF (PROCESSING_DATA(PNG_PTR, INFO_PTR, CHUNK.P, CHUNK.SIZE)) {
            DELETE[] CHUNK.P;
            BREAK;
          }
        } ELSE IF (ID == KID_FDAT && ISANIMATED) {
          PNG_SAVE_UINT_32(CHUNK.P + 4, CHUNK.SIZE - 16);
          MEMCPY(CHUNK.P + 8, "IDAT", 4);
          IF (PROCESSING_DATA(PNG_PTR, INFO_PTR, CHUNK.P + 4, CHUNK.SIZE - 4)) {
            DELETE[] CHUNK.P;
            BREAK;
          }
        } ELSE IF (!ISABC(CHUNK.P[4]) || !ISABC(CHUNK.P[5]) ||
                   !ISABC(CHUNK.P[6]) || !ISABC(CHUNK.P[7])) {
          DELETE[] CHUNK.P;
          BREAK;
        } ELSE IF (!HASINFO) {
          IF (PROCESSING_DATA(PNG_PTR, INFO_PTR, CHUNK.P, CHUNK.SIZE)) {
            DELETE[] CHUNK.P;
            BREAK;
          }
          CHUNKSINFO.PUSH_BACK(CHUNK);
          CONTINUE;
        }
        DELETE[] CHUNK.P;
      }
    }
    DELETE[] FRAMERAW.ROWS;
    DELETE[] FRAMERAW.P;
  }

  FOR (I = 0; I < CHUNKSINFO.SIZE(); I++) DELETE[] CHUNKSINFO[I].P;

  CHUNKSINFO.CLEAR();
  DELETE[] CHUNKIHDR.P;

  IF (ERRORSTATE) RETURN FALSE;
  SETINTENSITYTARGET(IO);
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196885_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& INPUT = CTX->INPUT(KINPUTTENSORINDEX);
    CONST TENSOR& INPUT_MIN = CTX->INPUT(KINPUTMININDEX);
    CONST TENSOR& INPUT_MAX = CTX->INPUT(KINPUTMAXINDEX);

    CONST SIZE_T DEPTH = INPUT_MAX.NUMELEMENTS();
    OP_REQUIRES(
        CTX, INPUT_MIN.DIM_SIZE(0) == DEPTH,
        ERRORS::INVALIDARGUMENT("INPUT_MIN HAS INCORRECT SIZE, EXPECTED ",
                                DEPTH, " WAS ", INPUT_MIN.DIM_SIZE(0)));
    OP_REQUIRES(
        CTX, INPUT_MAX.DIM_SIZE(0) == DEPTH,
        ERRORS::INVALIDARGUMENT("INPUT_MAX HAS INCORRECT SIZE, EXPECTED ",
                                DEPTH, " WAS ", INPUT_MAX.DIM_SIZE(0)));

    CONST FLOAT* INPUT_MIN_DATA = INPUT_MIN.FLAT<FLOAT>().DATA();
    CONST FLOAT* INPUT_MAX_DATA = INPUT_MAX.FLAT<FLOAT>().DATA();
    STD::VECTOR<FLOAT> RANGES(DEPTH);
    BOOL IS_NON_NEGATIVE = TRUE;
    EIGEN::ARRAY<INT, 2> SHUFFLING({1, 0});
    AUTO INPUT_MATRIX = INPUT.FLAT_INNER_DIMS<QINT32>();

    // TODO: VERIFY PERFORMANCE OF NOT TRANSPOSING AND FINDING THE MIN MAX
    // DIRECTLY FROM INPUT_MATRIX VS THE ONE PRESENTED BELOW OF TRANSPOSING AND
    // USING THE TRANSPOSED MATRIX AS THE TRANSPOSING OPERATION IN ITSELF MIGHT
    // BE MORE COSTLY.
    // NOTE THAT THIS OPERATION IS A CALIBRATION STEP FOR QUANTIZATION AND WILL
    // CEASE TO EXIST IN THE FINAL INFERENCE GRAPH(WILL EXIST AS A CONST NODE).
    AUTO TRANSPOSED_INPUT = INPUT_MATRIX.SHUFFLE(SHUFFLING);

    // FIND THE RANGES OF EACH CHANNEL IN PARALLEL.
    FLOAT OUT_MIN_MAX = STD::NUMERIC_LIMITS<FLOAT>::MIN();

#IFDEF ENABLE_ONEDNN_OPENMP
#IFDEF _MSC_VER
#PRAGMA OMP PARALLEL FOR
#ELSE
#PRAGMA OMP PARALLEL FOR REDUCTION(MAX : OUT_MIN_MAX)
#ENDIF
#ENDIF  // ENABLE_ONEDNN_OPENMP
    // TODO: ADD EIGEN PARALLEL_FOR
    FOR (INT64_T I = 0; I < DEPTH; ++I) {
      EIGEN::TENSOR<QINT32, 0, EIGEN::ROWMAJOR> MIN =
          TRANSPOSED_INPUT.CHIP<0>(I).MINIMUM();
      EIGEN::TENSOR<QINT32, 0, EIGEN::ROWMAJOR> MAX =
          TRANSPOSED_INPUT.CHIP<0>(I).MAXIMUM();
      CONST INT32_T MIN_PER_CHANNEL = MIN();
      CONST INT32_T MAX_PER_CHANNEL = MAX();
      CONST INT32_T ABS_MAX =
          STD::MAX(STD::ABS(MIN_PER_CHANNEL), STD::ABS(MAX_PER_CHANNEL));
      FLOAT SCALE =
          STD::MAX(STD::ABS(INPUT_MIN_DATA[I]), STD::ABS(INPUT_MAX_DATA[I]));
      RANGES[I] =
          SCALE * STATIC_CAST<FLOAT>(ABS_MAX) / STATIC_CAST<FLOAT>(1L << 31);
      IF (MIN_PER_CHANNEL < 0) IS_NON_NEGATIVE = FALSE;

      // THREAD-LOCAL OUT_MIN_MAX.
      OUT_MIN_MAX = STD::MAX(OUT_MIN_MAX, RANGES[I]);
    }

    // ALL LOCAL OUT_MIN_MAX GETS MAX-REDUCED INTO ONE GLOBAL OUT_MIN_MAX AT
    // THE END OF THE LOOP BY SPECIFYING REDUCTION(MAX:OUT_MIN_MAX) ALONG WITH
    // OMP PARALLEL FOR.

    // FIXING MAX TO CLIP_VALUE_MAX_ (EXAMPLE 6.0 TO SUPPORT RELU6)
    IF (OUT_MIN_MAX > CLIP_VALUE_MAX_) OUT_MIN_MAX = CLIP_VALUE_MAX_;

    TENSOR* OUTPUT_MIN = NULLPTR;
    TENSOR* OUTPUT_MAX = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(KOUTPUTMININDEX, {}, &OUTPUT_MIN));
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(KOUTPUTMAXINDEX, {}, &OUTPUT_MAX));
    OUTPUT_MIN->FLAT<FLOAT>()(0) = IS_NON_NEGATIVE ? 0.0F : -OUT_MIN_MAX;
    OUTPUT_MAX->FLAT<FLOAT>()(0) = OUT_MIN_MAX;
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224574_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS FUSEDBATCHNORMGRADSHAPE(SHAPE_INFERENCE::INFERENCECONTEXT* C) {
  STRING DATA_FORMAT_STR;
  TF_RETURN_IF_ERROR(C->GETATTR("DATA_FORMAT", &DATA_FORMAT_STR));
  TENSORFORMAT DATA_FORMAT;
  IF (!FORMATFROMSTRING(DATA_FORMAT_STR, &DATA_FORMAT)) {
    RETURN ERRORS::INVALIDARGUMENT("INVALID DATA FORMAT STRING: ",
                                   DATA_FORMAT_STR);
  }
  CONST INT RANK =
      (DATA_FORMAT_STR == "NDHWC" || DATA_FORMAT_STR == "NCDHW") ? 5 : 4;
  SHAPEHANDLE Y_BACKPROP;
  TF_RETURN_IF_ERROR(C->WITHRANK(C->INPUT(0), RANK, &Y_BACKPROP));
  SHAPEHANDLE X;
  TF_RETURN_IF_ERROR(C->WITHRANK(C->INPUT(1), RANK, &X));

  BOOL IS_TRAINING;
  TF_RETURN_IF_ERROR(C->GETATTR("IS_TRAINING", &IS_TRAINING));

  INT CHANNEL_DIM_INDEX = GETTENSORFEATUREDIMINDEX(RANK, DATA_FORMAT);
  DIMENSIONHANDLE CHANNEL_DIM = C->DIM(Y_BACKPROP, CHANNEL_DIM_INDEX);
  TF_RETURN_IF_ERROR(
      C->MERGE(CHANNEL_DIM, C->DIM(X, CHANNEL_DIM_INDEX), &CHANNEL_DIM));

  // COVERS SCALE, MEAN (RESERVE_SPACE_1), VARIANCE (RESERVE_SPACE_2)
  FOR (INT I = 2; I < 5; ++I) {
    SHAPEHANDLE VEC;
    TF_RETURN_IF_ERROR(C->WITHRANK(C->INPUT(I), 1, &VEC));
    TF_RETURN_IF_ERROR(C->MERGE(CHANNEL_DIM, C->DIM(VEC, 0), &CHANNEL_DIM));
  }

  SHAPEHANDLE X_BACKPROP;
  TF_RETURN_IF_ERROR(
      C->REPLACEDIM(Y_BACKPROP, CHANNEL_DIM_INDEX, CHANNEL_DIM, &X_BACKPROP));
  C->SET_OUTPUT(0, X_BACKPROP);
  C->SET_OUTPUT(1, C->VECTOR(CHANNEL_DIM));
  C->SET_OUTPUT(2, C->VECTOR(CHANNEL_DIM));
  C->SET_OUTPUT(3, C->VECTOR(0));
  C->SET_OUTPUT(4, C->VECTOR(0));
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 222896_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS GRAPHPROPERTIES::INFERFROMCOSTGRAPH(CONST COSTGRAPHDEF& COST_GRAPH) {
  IF (COST_GRAPH.NODE_SIZE() == 0) {
    LOG(WARNING) << "COST_GRAPH IS EMPTY: NOTHING CAN BE INFERRED!";
  }
  STD::UNORDERED_MAP<STRING, CONST COSTGRAPHDEF::NODE*> NAME_TO_COST;
  STD::UNORDERED_MAP<STRING, CONST NODEDEF*> NAME_TO_NODE;  // EMPTY
  FOR (AUTO& NODE : COST_GRAPH.NODE()) {
    NAME_TO_COST[NODE.NAME()] = &NODE;

    STD::VECTOR<OPINFO::TENSORPROPERTIES> OUTPUT_PROPERTIES;
    FOR (CONST AUTO& OUT : NODE.OUTPUT_INFO()) {
      OPINFO::TENSORPROPERTIES PROPERTIES;
      PROPERTIES.SET_DTYPE(OUT.DTYPE());
      *PROPERTIES.MUTABLE_SHAPE() = OUT.SHAPE();
      OUTPUT_PROPERTIES.PUSH_BACK(PROPERTIES);
    }
    OUTPUT_PROPERTIES_[NODE.NAME()] = OUTPUT_PROPERTIES;
  }

  FOR (CONST AUTO& NODE : ITEM_.GRAPH.NODE()) {
    // SKIP THE NODES THAT ARE NOT IN THE COST GRAPH: THESE ARE NODES THAT
    // AREN'T RUN, BECAUSE THEY AREN'T IN THE INTERSECTION OF TRANSITIVE FAN-IN
    // OF A FETCH NODE AND THE TRANSITIVE FAN-OUT OF AN INPUT, OR NODES THAT
    // WERE OPTIMIZED AWAY BY THE OPTIMIZER.
    AUTO IT = NAME_TO_COST.FIND(NODE.NAME());
    IF (IT == NAME_TO_COST.END()) {
      CONTINUE;
    }
    STD::VECTOR<OPINFO::TENSORPROPERTIES> INPUTS =
        FINDINPUTFEATURES(NODE, NAME_TO_COST, NAME_TO_NODE);

    INPUT_PROPERTIES_[NODE.NAME()] = INPUTS;
  }
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196629_CWE-354.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTEASYNC(OPKERNELCONTEXT* CONTEXT, DONECALLBACK DONE) FINAL {
    CONST TENSOR& INPUT = CONTEXT->INPUT(0);
    CONST TENSOR& RHS = CONTEXT->INPUT(1);
    CONST INT NDIMS = INPUT.DIMS();
    CONST INT64 N = INPUT.DIM_SIZE(NDIMS - 1);
    CONST INT64 NRHS = RHS.DIM_SIZE(NDIMS - 1);
    // VALIDATE INPUTS.
    OP_REQUIRES_ASYNC(
        CONTEXT, NDIMS >= 2,
        ERRORS::INVALIDARGUMENT("INPUT MUST HAVE RANK >= 2, GOT ", NDIMS),
        DONE);
    OP_REQUIRES_ASYNC(CONTEXT, RHS.DIMS() == NDIMS,
                      ERRORS::INVALIDARGUMENT(
                          "INPUT AND RIGHT-HAND SIDE MUST HAVE SAME RANK, GOT ",
                          NDIMS, " != ", RHS.DIMS()),
                      DONE);
    OP_REQUIRES_ASYNC(
        CONTEXT, INPUT.DIM_SIZE(NDIMS - 2) == N,
        ERRORS::INVALIDARGUMENT("INPUT MATRICES MUST BE SQUARES, GOT",
                                INPUT.DIM_SIZE(NDIMS - 2), " != ", N),
        DONE);
    OP_REQUIRES_ASYNC(CONTEXT, RHS.DIM_SIZE(NDIMS - 2) == N,
                      ERRORS::INVALIDARGUMENT(
                          "INPUT MATRIX AND RIGHT-HAND SIDE MUST HAVE THE "
                          "SAME NUMBER OF ROWS, GOT",
                          N, " != ", RHS.DIM_SIZE(NDIMS - 2)),
                      DONE);

    // ALLOCATE OUTPUT.
    TENSOR* OUTPUT;
    OP_REQUIRES_OK_ASYNC(
        CONTEXT,
        CONTEXT->FORWARD_INPUT_OR_ALLOCATE_OUTPUT({1}, 0, RHS.SHAPE(), &OUTPUT),
        DONE);

    // TO BE CONSISTENT WITH THE MATRIXINVERSE OP, WE DEFINE THE SOLUTION FOR
    // AN EMPTY SET OF EQUATIONS AS THE EMPTY MATRIX.
    IF (INPUT.NUMELEMENTS() == 0 || RHS.NUMELEMENTS() == 0) {
      DONE();
      RETURN;
    }

    // TODO(RMLARSEN): CONVERT TO STD::MAKE_UNIQUE WHEN AVAILABLE.
    STD::UNIQUE_PTR<CUDASOLVER> SOLVER(NEW CUDASOLVER(CONTEXT));

    // MAKE A COPY OF THE INPUT FOR THE FACTORIZATION STEP, OR, IF ADJOINT_ IS
    // FALSE, TRY TO REUSE THE INPUT BUFFER IF THIS OP OWNS IT EXCLUSIVELY.
    TENSOR INPUT_COPY;
    CONST GPUDEVICE& DEVICE = CONTEXT->EIGEN_DEVICE<GPUDEVICE>();
    IF (ADJOINT_) {
      // FOR THE ADJOINT CASE, IT IS SIMPLER TO ALWAYS MAKE A TRANSPOSED COPY UP
      // FRONT.
      OP_REQUIRES_OK_ASYNC(
          CONTEXT,
          SOLVER->ALLOCATE_SCOPED_TENSOR(DATATYPETOENUM<SCALAR>::VALUE,
                                         INPUT.SHAPE(), &INPUT_COPY),
          DONE);
      OP_REQUIRES_OK_ASYNC(CONTEXT,
                           DOMATRIXTRANSPOSE(DEVICE, INPUT, &INPUT_COPY), DONE);
    } ELSE {
      OP_REQUIRES_OK_ASYNC(
          CONTEXT,
          SOLVER->FORWARD_INPUT_OR_ALLOCATE_SCOPED_TENSOR(
              {0}, DATATYPETOENUM<SCALAR>::VALUE, INPUT.SHAPE(), &INPUT_COPY),
          DONE);
      IF (!INPUT.SHARESBUFFERWITH(INPUT_COPY)) {
        DEVICE.MEMCPY(INPUT_COPY.FLAT<SCALAR>().DATA(),
                      INPUT.FLAT<SCALAR>().DATA(),
                      INPUT.NUMELEMENTS() * SIZEOF(SCALAR));
      }
    }
    AUTO INPUT_COPY_RESHAPED = INPUT_COPY.TEMPLATE FLAT_INNER_DIMS<SCALAR, 3>();
    CONST INT64 BATCH_SIZE = INPUT_COPY_RESHAPED.DIMENSION(0);

    // ALLOCATE PIVOTS ON THE DEVICE.
    TENSOR PIVOTS;
    OP_REQUIRES_OK_ASYNC(
        CONTEXT,
        SOLVER->ALLOCATE_SCOPED_TENSOR(DATATYPETOENUM<INT>::VALUE,
                                       TENSORSHAPE{BATCH_SIZE, N}, &PIVOTS),
        DONE);
    AUTO PIVOTS_MAT = PIVOTS.TEMPLATE MATRIX<INT>();

    // 1. COMPUTE THE PARTIALLY PIVOTED LU FACTORIZATION(S) OF THE
    // MATRIX/MATRICES.
    STD::VECTOR<DEVICELAPACKINFO> DEV_INFO;
    AUTO INPUT_COPY_PTRS = SOLVER->GETSCRATCHSPACE<UINT8>(
        SIZEOF(SCALAR*) * BATCH_SIZE, "INPUT_COPT_PTRS",
        /* ON_HOST */ TRUE);
    CONST INT KMAXMATRIXSIZETOBATCHSIZERATIO = 128;
    CONST BOOL USE_BATCHED_SOLVER =
        N <= KMAXMATRIXSIZETOBATCHSIZERATIO * BATCH_SIZE;
    IF (USE_BATCHED_SOLVER) {
      // FOR SMALL MATRICES OR LARGE BATCH SIZES, WE USE THE BATCHED INTERFACE
      // FROM CUBLAS.
      CONST SCALAR** INPUT_COPY_PTRS_BASE =
          REINTERPRET_CAST<CONST SCALAR**>(INPUT_COPY_PTRS.MUTABLE_DATA());
      FOR (INT BATCH = 0; BATCH < BATCH_SIZE; ++BATCH) {
        INPUT_COPY_PTRS_BASE[BATCH] = &INPUT_COPY_RESHAPED(BATCH, 0, 0);
      }
      DEV_INFO.PUSH_BACK(
          SOLVER->GETDEVICELAPACKINFO(BATCH_SIZE, "GETRFBATCHED"));
      OP_REQUIRES_OK_ASYNC(
          CONTEXT,
          SOLVER->GETRFBATCHED(N, INPUT_COPY_PTRS_BASE, N, PIVOTS_MAT.DATA(),
                               &DEV_INFO.BACK(), BATCH_SIZE),
          DONE);
    } ELSE {
      // FOR SMALL BATCH SIZES OR LARGE MATRICES, WE USE THE NON-BATCHED
      // INTERFACE FROM CUSOLVER, WHICH IS MUCH FASTER FOR LARGE MATRICES.
      DEV_INFO.PUSH_BACK(SOLVER->GETDEVICELAPACKINFO(BATCH_SIZE, "GETRF"));
      FOR (INT BATCH = 0; BATCH < BATCH_SIZE; ++BATCH) {
        OP_REQUIRES_OK_ASYNC(
            CONTEXT,
            SOLVER->GETRF(N, N, &INPUT_COPY_RESHAPED(BATCH, 0, 0), N,
                          &PIVOTS_MAT(BATCH, 0), &DEV_INFO.BACK()(BATCH)),
            DONE);
      }
    }

    // 2. MAKE A TRANSPOSED COPY OF THE RIGHT-HAND SIDES. THIS IS NECESSARY
    // BECAUSE CUBLAS ASSUMES COLUMN-MAJOR STORAGE WHILE TENSORFLOW TF USES
    // ROW-MAJOR.
    TENSORSHAPE TRANSPOSED_RHS_SHAPE(RHS.SHAPE());
    TRANSPOSED_RHS_SHAPE.REMOVELASTDIMS(2);
    TRANSPOSED_RHS_SHAPE.ADDDIM(NRHS);
    TRANSPOSED_RHS_SHAPE.ADDDIM(N);
    TENSOR TRANSPOSED_RHS;
    OP_REQUIRES_OK_ASYNC(
        CONTEXT,
        SOLVER->ALLOCATE_SCOPED_TENSOR(DATATYPETOENUM<SCALAR>::VALUE,
                                       TRANSPOSED_RHS_SHAPE, &TRANSPOSED_RHS),
        DONE);
    IF (NRHS > 1) {
      OP_REQUIRES_OK_ASYNC(
          CONTEXT, DOMATRIXTRANSPOSE(DEVICE, RHS, &TRANSPOSED_RHS), DONE);
    } ELSE {
      DEVICE.MEMCPY(TRANSPOSED_RHS.FLAT<SCALAR>().DATA(),
                    RHS.FLAT<SCALAR>().DATA(),
                    RHS.NUMELEMENTS() * SIZEOF(SCALAR));
    }

    // 3. SOLVE OP(A) X = B (IN COLUMN MAJOR FORM).
    // WE USE A TRICK HERE: IF ADJOINT_ IS TRUE, WE CONVERTED A TO COLUMN MAJOR
    // FORM ABOVE. IF ADJOINT IS FALSE THEN I LEAVE A IN ROW-MAJOR FORM AND USE
    // TRANS_A = CUBLAS_OP_T TO EFFECTIVELY TRANSFORM IT TO COLUMN-MAJOR ON THE
    // FLY. (THIS MEANS THAT WE ACTUALLY USE THE LU-FACTORIZATION OF A^T IN THAT
    // CASE, BUT THAT IS EQUALLY GOOD FOR SOLVING AX=B). THIS WAY WE SAVE AN
    // EXPLICIT TRANSPOSE IN THE MORE COMMON CASE OF ADJOINT_ == FALSE.
    AUTO INPUT_COPY_PTR_ARRAY = SOLVER->GETSCRATCHSPACE<UINT8>(
        SIZEOF(SCALAR*) * BATCH_SIZE, "INPUT_COPY_PTR_ARRAY",
        /* ON_HOST */ TRUE);
    AUTO TRANSPOSED_RHS_PTR_ARRAY = SOLVER->GETSCRATCHSPACE<UINT8>(
        SIZEOF(SCALAR*) * BATCH_SIZE, "TRANSPOSED_RHS_PTR_ARRAY",
        /* ON_HOST */ TRUE);
    AUTO TRANSPOSED_RHS_RESHAPED =
        TRANSPOSED_RHS.TEMPLATE FLAT_INNER_DIMS<SCALAR, 3>();
    IF (USE_BATCHED_SOLVER) {
      CONST SCALAR** INPUT_COPY_PTRS_BASE =
          REINTERPRET_CAST<CONST SCALAR**>(INPUT_COPY_PTR_ARRAY.MUTABLE_DATA());
      CONST SCALAR** TRANSPOSED_RHS_PTRS_BASE =
          REINTERPRET_CAST<CONST SCALAR**>(
              TRANSPOSED_RHS_PTR_ARRAY.MUTABLE_DATA());
      FOR (INT BATCH = 0; BATCH < BATCH_SIZE; ++BATCH) {
        INPUT_COPY_PTRS_BASE[BATCH] = &INPUT_COPY_RESHAPED(BATCH, 0, 0);
        TRANSPOSED_RHS_PTRS_BASE[BATCH] = &TRANSPOSED_RHS_RESHAPED(BATCH, 0, 0);
      }
      INT HOST_INFO = 0;
      OP_REQUIRES_OK_ASYNC(
          CONTEXT,
          SOLVER->GETRSBATCHED(ADJOINT_ ? CUBLAS_OP_C : CUBLAS_OP_T, N, NRHS,
                               INPUT_COPY_PTRS_BASE, N, PIVOTS_MAT.DATA(),
                               TRANSPOSED_RHS_PTRS_BASE, N, &HOST_INFO,
                               BATCH_SIZE),
          DONE);
      OP_REQUIRES_ASYNC(
          CONTEXT, HOST_INFO == 0,
          ERRORS::INVALIDARGUMENT("THE ", -HOST_INFO,
                                  "'TH ARGUMENT TO CUBLAS*GETRSBATCHED HAD "
                                  "AN ILLEGAL VALUE."),
          DONE);
    } ELSE {
      DEV_INFO.PUSH_BACK(SOLVER->GETDEVICELAPACKINFO(BATCH_SIZE, "GETRS"));
      FOR (INT BATCH = 0; BATCH < BATCH_SIZE; ++BATCH) {
        OP_REQUIRES_OK_ASYNC(
            CONTEXT,
            SOLVER->GETRS(ADJOINT_ ? CUBLAS_OP_C : CUBLAS_OP_T, N, NRHS,
                          &INPUT_COPY_RESHAPED(BATCH, 0, 0), N,
                          &PIVOTS_MAT(BATCH, 0),
                          &TRANSPOSED_RHS_RESHAPED(BATCH, 0, 0), N,
                          &DEV_INFO.BACK()(BATCH)),
            DONE);
      }
    }

    // 4. TRANSPOSE X TO GET THE FINAL RESULT IN ROW-MAJOR FORM.
    IF (NRHS > 1) {
      OP_REQUIRES_OK_ASYNC(
          CONTEXT, DOMATRIXTRANSPOSE(DEVICE, TRANSPOSED_RHS, OUTPUT), DONE);
    } ELSE {
      DEVICE.MEMCPY(OUTPUT->FLAT<SCALAR>().DATA(),
                    TRANSPOSED_RHS.FLAT<SCALAR>().DATA(),
                    TRANSPOSED_RHS.NUMELEMENTS() * SIZEOF(SCALAR));
    }

    // CALLBACK FOR CHECKING INFO AFTER KERNELS FINISH. ALSO CAPTURE THE
    // TEMPORARY TENSORS/SCRATCHSPACE SO THEY DON'T GET DEALLOCATED BEFORE THE
    // KERNELS RUN. TODO(RMLARSEN): USE MOVE CAPTURE ONCE C++14 BECOMES
    // AVAILABLE.
    AUTO INFO_CHECKER = [CONTEXT, DONE, DEV_INFO](
                            CONST STATUS& STATUS,
                            CONST STD::VECTOR<HOSTLAPACKINFO>& HOST_INFOS) {
      IF (!STATUS.OK() && ERRORS::ISINVALIDARGUMENT(STATUS) &&
          !HOST_INFOS.EMPTY()) {
        FOR (INT I = 0; I < HOST_INFOS[0].SIZE(); ++I) {
          // MATCH THE CPU ERROR MESSAGE FOR SINGULAR MATRICES. OTHERWISE
          // JUST PRINT THE ORIGINAL ERROR MESSAGE FROM THE STATUS BELOW.
          OP_REQUIRES_ASYNC(CONTEXT, HOST_INFOS[0].DATA()[I] <= 0,
                            ERRORS::INVALIDARGUMENT(KERRMSG), DONE);
        }
      }
      OP_REQUIRES_OK_ASYNC(CONTEXT, STATUS, DONE);
      DONE();
    };
    CUDASOLVER::CHECKLAPACKINFOANDDELETESOLVERASYNC(STD::MOVE(SOLVER), DEV_INFO,
                                                    STD::MOVE(INFO_CHECKER));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 273407_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR* X_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("X", &X_TENSOR));

    CONST TENSOR* CS_PREV_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("CS_PREV", &CS_PREV_TENSOR));

    CONST TENSOR* H_PREV_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("H_PREV", &H_PREV_TENSOR));

    CONST TENSOR* W_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("W", &W_TENSOR));

    CONST TENSOR* WCI_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("WCI", &WCI_TENSOR));

    CONST TENSOR* WCF_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("WCF", &WCF_TENSOR));

    CONST TENSOR* WCO_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("WCO", &WCO_TENSOR));

    CONST TENSOR* B_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("B", &B_TENSOR));

    CONST INT64_T BATCH_SIZE = X_TENSOR->DIM_SIZE(0);
    CONST INT64_T INPUT_SIZE = X_TENSOR->DIM_SIZE(1);
    CONST INT64_T CELL_SIZE = CS_PREV_TENSOR->DIM_SIZE(1);

    // SANITY CHECKS FOR OUR INPUT SHAPES.
    OP_REQUIRES(CTX, CS_PREV_TENSOR->DIM_SIZE(0) == BATCH_SIZE,
                ERRORS::INVALIDARGUMENT("CS_PREV.DIMS(0) != BATCH_SIZE: ",
                                        CS_PREV_TENSOR->DIM_SIZE(0), " VS. ",
                                        BATCH_SIZE));
    OP_REQUIRES(CTX, CS_PREV_TENSOR->DIM_SIZE(1) == CELL_SIZE,
                ERRORS::INVALIDARGUMENT("CS_PREV.DIMS(1) != CELL_SIZE: ",
                                        CS_PREV_TENSOR->DIM_SIZE(1), " VS. ",
                                        CELL_SIZE));

    OP_REQUIRES(CTX, H_PREV_TENSOR->DIM_SIZE(0) == BATCH_SIZE,
                ERRORS::INVALIDARGUMENT("H_PREV.DIMS(0) != BATCH_SIZE: ",
                                        H_PREV_TENSOR->DIM_SIZE(0), " VS. ",
                                        BATCH_SIZE));
    OP_REQUIRES(CTX, H_PREV_TENSOR->DIM_SIZE(1) == CELL_SIZE,
                ERRORS::INVALIDARGUMENT(
                    "H_PREV.DIMS(1) != CELL_SIZE: ", H_PREV_TENSOR->DIM_SIZE(1),
                    " VS. ", CELL_SIZE));

    OP_REQUIRES(CTX, W_TENSOR->DIM_SIZE(0) == INPUT_SIZE + CELL_SIZE,
                ERRORS::INVALIDARGUMENT(
                    "W.DIM_SIZE(0) != INPUT_SIZE + CELL_SIZE: ",
                    W_TENSOR->DIM_SIZE(0), " VS. ", INPUT_SIZE + CELL_SIZE));
    OP_REQUIRES(CTX, W_TENSOR->DIM_SIZE(1) == CELL_SIZE * 4,
                ERRORS::INVALIDARGUMENT(
                    "W.DIM_SIZE(1) != CELL_SIZE * 4: ", W_TENSOR->DIM_SIZE(1),
                    " VS. ", CELL_SIZE * 4));

    OP_REQUIRES(CTX, B_TENSOR->DIM_SIZE(0) == CELL_SIZE * 4,
                ERRORS::INVALIDARGUMENT(
                    "B.DIM_SIZE(0) != CELL_SIZE * 4: ", B_TENSOR->DIM_SIZE(0),
                    " VS. ", CELL_SIZE * 4));

    // ALLOCATE OUR OUTPUT TENSORS.
    TENSOR* I_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                            {"H_PREV"}, "I",
                            TENSORSHAPE({BATCH_SIZE, CELL_SIZE}), &I_TENSOR));

    TENSOR* CS_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("CS", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &CS_TENSOR));

    TENSOR* F_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("F", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &F_TENSOR));

    TENSOR* O_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                            {"CS_PREV"}, "O",
                            TENSORSHAPE({BATCH_SIZE, CELL_SIZE}), &O_TENSOR));

    TENSOR* CI_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("CI", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &CI_TENSOR));

    TENSOR* CO_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("CO", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &CO_TENSOR));

    TENSOR* H_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("H", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &H_TENSOR));

    // ALLOCATE OUR TEMP TENSORS.
    TENSOR XH_TENSOR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_TEMP(
                            DATATYPETOENUM<T>::V(),
                            TENSORSHAPE({BATCH_SIZE, INPUT_SIZE + CELL_SIZE}),
                            &XH_TENSOR));

    TENSOR GATES_TENSOR;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::V(),
                                      TENSORSHAPE({BATCH_SIZE, CELL_SIZE * 4}),
                                      &GATES_TENSOR));

    CONST DEVICE& DEVICE = CTX->EIGEN_DEVICE<DEVICE>();

    // SANITY CHECK THAT EACH OF THE TENSORS HAVE THE REQUIRED NDIMS.
    OP_REQUIRES(CTX, X_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("X_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        X_TENSOR->DIMS(), "."));
    OP_REQUIRES(
        CTX, CS_PREV_TENSOR->DIMS() == 2,
        ERRORS::INVALIDARGUMENT("CS_PREV_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                CS_PREV_TENSOR->DIMS(), "."));
    OP_REQUIRES(
        CTX, H_PREV_TENSOR->DIMS() == 2,
        ERRORS::INVALIDARGUMENT("H_PREV_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                H_PREV_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, W_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("W_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        W_TENSOR->DIMS(), "."));
    OP_REQUIRES(
        CTX, WCI_TENSOR->DIMS() == 1,
        ERRORS::INVALIDARGUMENT("WCI_TENSOR MUST BE RANK 1 BUT IS RANK ",
                                WCI_TENSOR->DIMS(), "."));
    OP_REQUIRES(
        CTX, WCF_TENSOR->DIMS() == 1,
        ERRORS::INVALIDARGUMENT("WCF_TENSOR MUST BE RANK 1 BUT IS RANK ",
                                WCI_TENSOR->DIMS(), "."));
    OP_REQUIRES(
        CTX, WCO_TENSOR->DIMS() == 1,
        ERRORS::INVALIDARGUMENT("WCO_TENSOR MUST BE RANK 1 BUT IS RANK ",
                                WCO_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, B_TENSOR->DIMS() == 1,
                ERRORS::INVALIDARGUMENT("B_TENSOR MUST BE RANK 1 BUT IS RANK ",
                                        B_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, XH_TENSOR.DIMS() == 2,
                ERRORS::INVALIDARGUMENT("XH_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        XH_TENSOR.DIMS(), "."));
    OP_REQUIRES(CTX, I_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("I_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        I_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, CS_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("CS_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        CS_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, F_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("F_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        F_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, O_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("O_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        O_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, CI_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("CI_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        CI_TENSOR->DIMS(), "."));
    OP_REQUIRES(CTX, CO_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("CO_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        CO_TENSOR->DIMS(), "."));
    OP_REQUIRES(
        CTX, GATES_TENSOR.DIMS() == 2,
        ERRORS::INVALIDARGUMENT("GATES_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                GATES_TENSOR.DIMS(), "."));
    OP_REQUIRES(CTX, H_TENSOR->DIMS() == 2,
                ERRORS::INVALIDARGUMENT("H_TENSOR MUST BE RANK 2 BUT IS RANK ",
                                        H_TENSOR->DIMS(), "."));

    FUNCTOR::LSTMBLOCKCELLFPROP<DEVICE, T, USE_CUBLAS, GATE_LAYOUT>(
        BATCH_SIZE, INPUT_SIZE, CELL_SIZE)(
        CTX, DEVICE, FORGET_BIAS_, CELL_CLIP_, USE_PEEPHOLE_,
        X_TENSOR->MATRIX<T>(), CS_PREV_TENSOR->MATRIX<T>(),
        H_PREV_TENSOR->MATRIX<T>(), W_TENSOR->MATRIX<T>(), WCI_TENSOR->VEC<T>(),
        WCF_TENSOR->VEC<T>(), WCO_TENSOR->VEC<T>(), B_TENSOR->VEC<T>(),
        XH_TENSOR.MATRIX<T>(), I_TENSOR->MATRIX<T>(), CS_TENSOR->MATRIX<T>(),
        F_TENSOR->MATRIX<T>(), O_TENSOR->MATRIX<T>(), CI_TENSOR->MATRIX<T>(),
        CO_TENSOR->MATRIX<T>(), GATES_TENSOR.MATRIX<T>(),
        H_TENSOR->MATRIX<T>());
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195294_CWE-843.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    STAGINGMAP<ORDERED>* MAP = NULLPTR;
    OP_REQUIRES_OK(CTX, GETSTAGINGMAP(CTX, DEF(), &MAP));
    CORE::SCOPEDUNREF SCOPE(MAP);
    TYPENAME STAGINGMAP<ORDERED>::OPTIONALTUPLE TUPLE;

    CONST TENSOR* KEY_TENSOR;
    CONST TENSOR* INDICES_TENSOR;
    OPINPUTLIST VALUES_TENSOR;

    OP_REQUIRES_OK(CTX, CTX->INPUT("KEY", &KEY_TENSOR));
    OP_REQUIRES_OK(CTX, CTX->INPUT("INDICES", &INDICES_TENSOR));
    OP_REQUIRES_OK(CTX, CTX->INPUT_LIST("VALUES", &VALUES_TENSOR));
    OP_REQUIRES(CTX, KEY_TENSOR->NUMELEMENTS() > 0,
                ERRORS::INVALIDARGUMENT("KEY MUST NOT BE EMPTY"));

    // CREATE COPY FOR INSERTION INTO STAGING AREA
    TENSOR KEY(*KEY_TENSOR);

    // CREATE THE TUPLE TO STORE
    FOR (STD::SIZE_T I = 0; I < VALUES_TENSOR.SIZE(); ++I) {
      TUPLE.PUSH_BACK(VALUES_TENSOR[I]);
    }

    // STORE THE TUPLE IN THE MAP
    OP_REQUIRES_OK(CTX, MAP->PUT(&KEY, INDICES_TENSOR, &TUPLE));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195289_CWE-787.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR& INDICES = CONTEXT->INPUT(0);
    CONST TENSOR& VALUES = CONTEXT->INPUT(1);
    CONST TENSOR& SHAPE = CONTEXT->INPUT(2);
    CONST TENSOR& WEIGHTS = CONTEXT->INPUT(3);
    BOOL USE_WEIGHTS = WEIGHTS.NUMELEMENTS() > 0;

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INDICES.SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES MUST BE A 2-DIMENSIONAL TENSOR. GOT: ",
                    INDICES.SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(VALUES.SHAPE()),
                ERRORS::INVALIDARGUMENT("INPUT VALUES MUST BE A VECTOR. GOT: ",
                                        VALUES.SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(SHAPE.SHAPE()),
                ERRORS::INVALIDARGUMENT("INPUT SHAPE MUST BE A VECTOR. GOT: ",
                                        SHAPE.SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT,
                VALUES.SHAPE().DIM_SIZE(0) == INDICES.SHAPE().DIM_SIZE(0),
                ERRORS::INVALIDARGUMENT(
                    "NUMBER OF VALUES MUST MATCH FIRST DIMENSION OF INDICES.",
                    "GOT ", VALUES.SHAPE().DIM_SIZE(0),
                    " VALUES, INDICES SHAPE: ", INDICES.SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CONTEXT, SHAPE.SHAPE().DIM_SIZE(0) == INDICES.SHAPE().DIM_SIZE(1),
        ERRORS::INVALIDARGUMENT(
            "NUMBER OF DIMENSIONS MUST MATCH SECOND DIMENSION OF INDICES.",
            "GOT ", SHAPE.SHAPE().DIM_SIZE(0),
            " DIMENSIONS, INDICES SHAPE: ", INDICES.SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, SHAPE.NUMELEMENTS() > 0,
                ERRORS::INVALIDARGUMENT(
                    "THE SHAPE ARGUMENT REQUIRES AT LEAST ONE ELEMENT."));

    IF (USE_WEIGHTS) {
      OP_REQUIRES(
          CONTEXT, WEIGHTS.SHAPE() == VALUES.SHAPE(),
          ERRORS::INVALIDARGUMENT(
              "WEIGHTS AND VALUES MUST HAVE THE SAME SHAPE. WEIGHT SHAPE: ",
              WEIGHTS.SHAPE().DEBUGSTRING(),
              "; VALUES SHAPE: ", VALUES.SHAPE().DEBUGSTRING()));
    }

    BOOL IS_1D = SHAPE.NUMELEMENTS() == 1;
    AUTO SHAPE_VECTOR = SHAPE.FLAT<INT64_T>();
    INT NUM_BATCHES = IS_1D ? 1 : SHAPE_VECTOR(0);
    INT NUM_VALUES = VALUES.NUMELEMENTS();

    CONST AUTO INDICES_VALUES = INDICES.MATRIX<INT64_T>();
    CONST AUTO VALUES_VALUES = VALUES.FLAT<T>();
    CONST AUTO WEIGHT_VALUES = WEIGHTS.FLAT<W>();

    AUTO PER_BATCH_COUNTS = BATCHEDMAP<W>(NUM_BATCHES);

    T MAX_VALUE = 0;

    FOR (INT IDX = 0; IDX < NUM_VALUES; ++IDX) {
      INT BATCH = IS_1D ? 0 : INDICES_VALUES(IDX, 0);
      IF (BATCH >= NUM_BATCHES) {
        OP_REQUIRES(CONTEXT, BATCH < NUM_BATCHES,
                    ERRORS::INVALIDARGUMENT(
                        "INDICES VALUE ALONG THE FIRST DIMENSION MUST BE ",
                        "LOWER THAN THE FIRST INDEX OF THE SHAPE.", "GOT ",
                        BATCH, " AS BATCH AND ", NUM_BATCHES,
                        " AS THE FIRST DIMENSION OF THE SHAPE."));
      }
      CONST AUTO& VALUE = VALUES_VALUES(IDX);
      IF (VALUE >= 0 && (MAXLENGTH_ <= 0 || VALUE < MAXLENGTH_)) {
        IF (BINARY_OUTPUT_) {
          PER_BATCH_COUNTS[BATCH][VALUE] = 1;
        } ELSE IF (USE_WEIGHTS) {
          PER_BATCH_COUNTS[BATCH][VALUE] += WEIGHT_VALUES(IDX);
        } ELSE {
          PER_BATCH_COUNTS[BATCH][VALUE]++;
        }
        IF (VALUE > MAX_VALUE) {
          MAX_VALUE = VALUE;
        }
      }
    }

    INT NUM_OUTPUT_VALUES = GETOUTPUTSIZE(MAX_VALUE, MAXLENGTH_, MINLENGTH_);
    OP_REQUIRES_OK(CONTEXT, OUTPUTSPARSE<W>(PER_BATCH_COUNTS, NUM_OUTPUT_VALUES,
                                            IS_1D, CONTEXT));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195391_CWE-190.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(TENSORFLOW::OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    FOR (INT NGRAM_WIDTH : NGRAM_WIDTHS_) {
      OP_REQUIRES(
          CONTEXT, NGRAM_WIDTH > 0,
          ERRORS::INVALIDARGUMENT("NGRAM_WIDTHS MUST CONTAIN POSITIVE VALUES"));
    }

    CONST TENSORFLOW::TENSOR* DATA;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("DATA", &DATA));
    CONST AUTO& INPUT_DATA = DATA->FLAT<TSTRING>().DATA();

    CONST TENSORFLOW::TENSOR* SPLITS;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("DATA_SPLITS", &SPLITS));
    CONST AUTO& SPLITS_VEC = SPLITS->FLAT<SPLITS_TYPE>();

    // VALIDATE THAT THE SPLITS ARE VALID INDICES INTO DATA, ONLY IF THERE ARE
    // SPLITS SPECIFIED.
    CONST INT INPUT_DATA_SIZE = DATA->FLAT<TSTRING>().SIZE();
    CONST INT SPLITS_VEC_SIZE = SPLITS_VEC.SIZE();
    IF (SPLITS_VEC_SIZE > 0) {
      INT PREV_SPLIT = SPLITS_VEC(0);
      OP_REQUIRES(CONTEXT, PREV_SPLIT == 0,
                  ERRORS::INVALIDARGUMENT("FIRST SPLIT VALUE MUST BE 0, GOT ",
                                          PREV_SPLIT));
      FOR (INT I = 1; I < SPLITS_VEC_SIZE; ++I) {
        BOOL VALID_SPLITS = SPLITS_VEC(I) >= PREV_SPLIT;
        VALID_SPLITS = VALID_SPLITS && (SPLITS_VEC(I) <= INPUT_DATA_SIZE);
        OP_REQUIRES(CONTEXT, VALID_SPLITS,
                    ERRORS::INVALIDARGUMENT(
                        "INVALID SPLIT VALUE ", SPLITS_VEC(I), ", MUST BE IN [",
                        PREV_SPLIT, ", ", INPUT_DATA_SIZE, "]"));
        PREV_SPLIT = SPLITS_VEC(I);
      }
      OP_REQUIRES(CONTEXT, PREV_SPLIT == INPUT_DATA_SIZE,
                  ERRORS::INVALIDARGUMENT(
                      "LAST SPLIT VALUE MUST BE DATA SIZE. EXPECTED ",
                      INPUT_DATA_SIZE, ", GOT ", PREV_SPLIT));
    }

    INT NUM_BATCH_ITEMS = SPLITS_VEC.SIZE() - 1;
    TENSORFLOW::TENSOR* NGRAMS_SPLITS;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->ALLOCATE_OUTPUT(1, SPLITS->SHAPE(), &NGRAMS_SPLITS));
    AUTO NGRAMS_SPLITS_DATA = NGRAMS_SPLITS->FLAT<SPLITS_TYPE>().DATA();

    // IF THERE IS NO DATA OR SIZE, RETURN AN EMPTY RT.
    IF (DATA->FLAT<TSTRING>().SIZE() == 0 || SPLITS_VEC.SIZE() == 0) {
      TENSORFLOW::TENSOR* EMPTY;
      OP_REQUIRES_OK(CONTEXT,
                     CONTEXT->ALLOCATE_OUTPUT(0, DATA->SHAPE(), &EMPTY));
      FOR (INT I = 0; I <= NUM_BATCH_ITEMS; ++I) {
        NGRAMS_SPLITS_DATA[I] = 0;
      }
      RETURN;
    }

    NGRAMS_SPLITS_DATA[0] = 0;
    FOR (INT I = 1; I <= NUM_BATCH_ITEMS; ++I) {
      INT LENGTH = SPLITS_VEC(I) - SPLITS_VEC(I - 1);
      INT NUM_NGRAMS = 0;
      FOR (INT NGRAM_WIDTH : NGRAM_WIDTHS_)
        NUM_NGRAMS += GET_NUM_NGRAMS(LENGTH, NGRAM_WIDTH);
      IF (PRESERVE_SHORT_ && LENGTH > 0 && NUM_NGRAMS == 0) {
        NUM_NGRAMS = 1;
      }
      NGRAMS_SPLITS_DATA[I] = NGRAMS_SPLITS_DATA[I - 1] + NUM_NGRAMS;
    }

    TENSORFLOW::TENSOR* NGRAMS;
    OP_REQUIRES_OK(
        CONTEXT,
        CONTEXT->ALLOCATE_OUTPUT(
            0, TENSORSHAPE({NGRAMS_SPLITS_DATA[NUM_BATCH_ITEMS]}), &NGRAMS));
    AUTO NGRAMS_DATA = NGRAMS->FLAT<TSTRING>().DATA();

    FOR (INT I = 0; I < NUM_BATCH_ITEMS; ++I) {
      AUTO DATA_START = &INPUT_DATA[SPLITS_VEC(I)];
      INT OUTPUT_START_IDX = NGRAMS_SPLITS_DATA[I];
      FOR (INT NGRAM_WIDTH : NGRAM_WIDTHS_) {
        AUTO OUTPUT_START = &NGRAMS_DATA[OUTPUT_START_IDX];
        INT LENGTH = SPLITS_VEC(I + 1) - SPLITS_VEC(I);
        INT NUM_NGRAMS = GET_NUM_NGRAMS(LENGTH, NGRAM_WIDTH);
        CREATENGRAMS(DATA_START, OUTPUT_START, NUM_NGRAMS, NGRAM_WIDTH);
        OUTPUT_START_IDX += NUM_NGRAMS;
      }
      // IF WE'RE PRESERVING SHORT SEQUENCES, CHECK TO SEE IF NO SEQUENCE WAS
      // GENERATED BY COMPARING THE CURRENT OUTPUT START IDX TO THE ORIGINAL
      // ONE (NGRAM_SPLITS_DATA). IF NO NGRAMS WERE GENERATED, THEN THEY WILL
      // BE EQUAL (SINCE WE INCREMENT OUTPUT_START_IDX BY NUM_NGRAMS EVERY
      // TIME WE CREATE A SET OF NGRAMS.)
      IF (PRESERVE_SHORT_ && OUTPUT_START_IDX == NGRAMS_SPLITS_DATA[I]) {
        INT DATA_LENGTH = SPLITS_VEC(I + 1) - SPLITS_VEC(I);
        // ONE LEGITIMATE REASON TO NOT HAVE ANY NGRAMS WHEN PRESERVE_SHORT_
        // IS TRUE IS IF THE SEQUENCE ITSELF IS EMPTY. IN THAT CASE, MOVE ON.
        IF (DATA_LENGTH == 0) {
          CONTINUE;
        }
        // WE DON'T HAVE TO WORRY ABOUT DYNAMIC PADDING SIZES HERE: IF PADDING
        // WAS DYNAMIC, EVERY SEQUENCE WOULD HAVE HAD SUFFICIENT PADDING TO
        // GENERATE AT LEAST ONE NGRAM.
        INT NGRAM_WIDTH = DATA_LENGTH + 2 * PAD_WIDTH_;
        AUTO OUTPUT_START = &NGRAMS_DATA[OUTPUT_START_IDX];
        INT NUM_NGRAMS = 1;
        CREATENGRAMS(DATA_START, OUTPUT_START, NUM_NGRAMS, NGRAM_WIDTH);
      }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198117_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // HERE'S THE BASIC IDEA:
    // BATCH AND DEPTH DIMENSION ARE INDEPENDENT FROM ROW AND COL DIMENSION. AND
    // BECAUSE FRACTIONALAVGPOOL CURRENTLY ONLY SUPPORT POOLING ALONG ROW AND
    // COL, WE CAN BASICALLY THINK OF THIS 4D TENSOR BACKPROPAGATION AS
    // OPERATION OF A SERIES OF 2D PLANES.
    //
    // FOR EACH ELEMENT OF A 'SLICE' (2D PLANE) OF OUTPUT_BACKPROP, WE NEED TO
    // FIGURE OUT ITS CONTRIBUTORS WHEN DOING FRACTIONALAVGPOOL OPERATION. THIS
    // CAN BE DONE BASED ON ROW_POOLING_SEQUENCE, COL_POOLING_SEQ AND
    // OVERLAPPING.
    // ONCE WE FIGURE OUT THE ORIGINAL CONTRIBUTORS, WE JUST NEED TO EVENLY
    // DIVIDE THE VALUE OF THIS ELEMENT AMONG THESE CONTRIBUTORS.
    //
    // INTERNALLY, WE DIVIDE THE OUT_BACKPROP TENSOR AND STORE IT IN A TEMPORARY
    // TENSOR OF DOUBLE TYPE. AND CAST IT TO THE CORRESPONDING TYPE.
    TYPEDEF EIGEN::MAP<CONST EIGEN::MATRIX<T, EIGEN::DYNAMIC, EIGEN::DYNAMIC>>
        CONSTEIGENMATRIXMAP;
    TYPEDEF EIGEN::MAP<EIGEN::MATRIX<DOUBLE, EIGEN::DYNAMIC, EIGEN::DYNAMIC>>
        EIGENDOUBLEMATRIXMAP;

    // GRAB THE INPUTS.
    CONST TENSOR& ORIG_INPUT_TENSOR_SHAPE = CONTEXT->INPUT(0);
    OP_REQUIRES(CONTEXT,
                ORIG_INPUT_TENSOR_SHAPE.DIMS() == 1 &&
                    ORIG_INPUT_TENSOR_SHAPE.NUMELEMENTS() == 4,
                ERRORS::INVALIDARGUMENT("ORIGINAL INPUT TENSOR SHAPE MUST BE"
                                        "1-DIMENSIONAL AND 4 ELEMENTS"));
    CONST TENSOR& OUT_BACKPROP = CONTEXT->INPUT(1);
    CONST TENSOR& ROW_SEQ_TENSOR = CONTEXT->INPUT(2);
    CONST TENSOR& COL_SEQ_TENSOR = CONTEXT->INPUT(3);

    CONST INT64_T OUT_BATCH = OUT_BACKPROP.DIM_SIZE(0);
    CONST INT64_T OUT_ROWS = OUT_BACKPROP.DIM_SIZE(1);
    CONST INT64_T OUT_COLS = OUT_BACKPROP.DIM_SIZE(2);
    CONST INT64_T OUT_DEPTH = OUT_BACKPROP.DIM_SIZE(3);

    OP_REQUIRES(CONTEXT, ROW_SEQ_TENSOR.NUMELEMENTS() > OUT_ROWS,
                ERRORS::INVALIDARGUMENT("GIVEN OUT_BACKPROP SHAPE ",
                                        OUT_BACKPROP.SHAPE().DEBUGSTRING(),
                                        ", ROW_SEQ_TENSOR MUST HAVE AT LEAST ",
                                        OUT_ROWS + 1, " ELEMENTS, BUT GOT ",
                                        ROW_SEQ_TENSOR.NUMELEMENTS()));
    OP_REQUIRES(CONTEXT, COL_SEQ_TENSOR.NUMELEMENTS() > OUT_COLS,
                ERRORS::INVALIDARGUMENT("GIVEN OUT_BACKPROP SHAPE ",
                                        OUT_BACKPROP.SHAPE().DEBUGSTRING(),
                                        ", COL_SEQ_TENSOR MUST HAVE AT LEAST ",
                                        OUT_COLS + 1, " ELEMENTS, BUT GOT ",
                                        COL_SEQ_TENSOR.NUMELEMENTS()));

    AUTO ROW_SEQ_TENSOR_FLAT = ROW_SEQ_TENSOR.FLAT<INT64>();
    AUTO COL_SEQ_TENSOR_FLAT = COL_SEQ_TENSOR.FLAT<INT64>();
    AUTO ORIG_INPUT_TENSOR_SHAPE_FLAT = ORIG_INPUT_TENSOR_SHAPE.FLAT<INT64>();

    CONST INT64_T IN_BATCH = ORIG_INPUT_TENSOR_SHAPE_FLAT(0);
    CONST INT64_T IN_ROWS = ORIG_INPUT_TENSOR_SHAPE_FLAT(1);
    CONST INT64_T IN_COLS = ORIG_INPUT_TENSOR_SHAPE_FLAT(2);
    CONST INT64_T IN_DEPTH = ORIG_INPUT_TENSOR_SHAPE_FLAT(3);

    CONSTEXPR INT TENSOR_IN_AND_OUT_DIMS = 4;
    // TRANSFORM ORIG_INPUT_TENSOR_SHAPE INTO TENSORSHAPE
    TENSORSHAPE IN_SHAPE;
    FOR (AUTO I = 0; I < TENSOR_IN_AND_OUT_DIMS; ++I) {
      IN_SHAPE.ADDDIM(ORIG_INPUT_TENSOR_SHAPE_FLAT(I));
    }

    // CREATE INTERMEDIATE IN_BACKPROP.
    TENSOR IN_BACKPROP_TENSOR_TEMP;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->FORWARD_INPUT_OR_ALLOCATE_TEMP(
                                {0}, DATATYPETOENUM<DOUBLE>::V(), IN_SHAPE,
                                &IN_BACKPROP_TENSOR_TEMP));
    IN_BACKPROP_TENSOR_TEMP.FLAT<DOUBLE>().SETZERO();
    // TRANSFORM 4D TENSOR TO 2D MATRIX.
    EIGENDOUBLEMATRIXMAP IN_BACKPROP_TENSOR_TEMP_MAT(
        IN_BACKPROP_TENSOR_TEMP.FLAT<DOUBLE>().DATA(), IN_DEPTH,
        IN_COLS * IN_ROWS * IN_BATCH);
    CONSTEIGENMATRIXMAP OUT_BACKPROP_MAT(OUT_BACKPROP.FLAT<T>().DATA(),
                                         OUT_DEPTH,
                                         OUT_COLS * OUT_ROWS * OUT_BATCH);
    // LOOP THROUGH EACH ELEMENT OF OUT_BACKPROP AND EVENLY DISTRIBUTE THE
    // ELEMENT TO THE CORRESPONDING POOLING CELL.
    CONST INT64_T IN_MAX_ROW_INDEX = IN_ROWS - 1;
    CONST INT64_T IN_MAX_COL_INDEX = IN_COLS - 1;
    FOR (INT64_T B = 0; B < OUT_BATCH; ++B) {
      FOR (INT64_T R = 0; R < OUT_ROWS; ++R) {
        CONST INT64_T IN_ROW_START = ROW_SEQ_TENSOR_FLAT(R);
        INT64_T IN_ROW_END = OVERLAPPING_ ? ROW_SEQ_TENSOR_FLAT(R + 1)
                                          : ROW_SEQ_TENSOR_FLAT(R + 1) - 1;
        IN_ROW_END = STD::MIN(IN_ROW_END, IN_MAX_ROW_INDEX);
        FOR (INT64_T C = 0; C < OUT_COLS; ++C) {
          CONST INT64_T IN_COL_START = COL_SEQ_TENSOR_FLAT(C);
          INT64_T IN_COL_END = OVERLAPPING_ ? COL_SEQ_TENSOR_FLAT(C + 1)
                                            : COL_SEQ_TENSOR_FLAT(C + 1) - 1;
          IN_COL_END = STD::MIN(IN_COL_END, IN_MAX_COL_INDEX);

          CONST INT64_T NUM_ELEMENTS_IN_POOLING_CELL =
              (IN_ROW_END - IN_ROW_START + 1) * (IN_COL_END - IN_COL_START + 1);
          CONST INT64_T OUT_INDEX = (B * OUT_ROWS + R) * OUT_COLS + C;
          // NOW WE CAN EVENLY DISTRIBUTE OUT_BACKPROP(B, H, W, *) TO
          // IN_BACKPROP(B, HS:HE, WS:WE, *).
          FOR (INT64_T IN_R = IN_ROW_START; IN_R <= IN_ROW_END; ++IN_R) {
            FOR (INT64_T IN_C = IN_COL_START; IN_C <= IN_COL_END; ++IN_C) {
              CONST INT64_T IN_INDEX = (B * IN_ROWS + IN_R) * IN_COLS + IN_C;
              // WALK THROUGH EACH CHANNEL (DEPTH).
              FOR (INT64_T D = 0; D < OUT_DEPTH; ++D) {
                CONST DOUBLE OUT_BACKPROP_ELEMENT = STATIC_CAST<DOUBLE>(
                    OUT_BACKPROP_MAT.COEFFREF(D, OUT_INDEX));
                DOUBLE& IN_BACKPROP_REF =
                    IN_BACKPROP_TENSOR_TEMP_MAT.COEFFREF(D, IN_INDEX);
                IN_BACKPROP_REF +=
                    OUT_BACKPROP_ELEMENT / NUM_ELEMENTS_IN_POOLING_CELL;
              }
            }
          }
        }
      }
    }

    // DEPENDING ON THE TYPE, CAST DOUBLE TO TYPE T.
    TENSOR* IN_BACKPROP_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                                {0}, 0, IN_SHAPE, &IN_BACKPROP_TENSOR));
    AUTO IN_BACKPROP_TENSOR_FLAT = IN_BACKPROP_TENSOR->FLAT<T>();
    AUTO IN_BACKPROP_TENSOR_TEMP_FLAT = IN_BACKPROP_TENSOR_TEMP.FLAT<DOUBLE>();
    FOR (INT64_T I = 0; I < IN_BACKPROP_TENSOR_FLAT.SIZE(); ++I) {
      IN_BACKPROP_TENSOR_FLAT(I) =
          STATIC_CAST<T>(IN_BACKPROP_TENSOR_TEMP_FLAT(I));
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195404_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    TYPEDEF EIGEN::MAP<CONST EIGEN::MATRIX<T, EIGEN::DYNAMIC, EIGEN::DYNAMIC>>
        CONSTEIGENMATRIXMAP;
    TYPEDEF EIGEN::MAP<EIGEN::MATRIX<T, EIGEN::DYNAMIC, EIGEN::DYNAMIC>>
        EIGENMATRIXMAP;

    CONSTEXPR INT TENSOR_IN_AND_OUT_DIMS = 4;

    CONST TENSOR& TENSOR_IN = CONTEXT->INPUT(0);
    OP_REQUIRES(CONTEXT, TENSOR_IN.DIMS() == TENSOR_IN_AND_OUT_DIMS,
                ERRORS::INVALIDARGUMENT("TENSOR_IN MUST BE 4-DIMENSIONAL"));

    STD::VECTOR<INT> INPUT_SIZE(TENSOR_IN_AND_OUT_DIMS);
    STD::VECTOR<INT> OUTPUT_SIZE(TENSOR_IN_AND_OUT_DIMS);
    FOR (INT I = 0; I < TENSOR_IN_AND_OUT_DIMS; ++I) {
      INPUT_SIZE[I] = TENSOR_IN.DIM_SIZE(I);
    }
    // OUTPUT SIZE.
    FOR (INT I = 0; I < TENSOR_IN_AND_OUT_DIMS; ++I) {
      // THIS MUST MATCH THE SAME LOGIC IN THE SHAPE FUNCTION IN
      // CORE/OPS/NN_OPS.CC.
      OUTPUT_SIZE[I] =
          STATIC_CAST<INT>(STD::FLOOR(INPUT_SIZE[I] / POOLING_RATIO_[I]));
      DCHECK_GT(OUTPUT_SIZE[I], 0);
    }

    // GENERATE POOLING SEQUENCE.
    STD::VECTOR<INT64_T> HEIGHT_CUM_SEQ;
    STD::VECTOR<INT64_T> WIDTH_CUM_SEQ;
    GUARDEDPHILOXRANDOM GENERATOR;
    GENERATOR.INIT(SEED_, SEED2_);
    HEIGHT_CUM_SEQ = GENERATEPOOLINGSEQUENCE(INPUT_SIZE[1], OUTPUT_SIZE[1],
                                             &GENERATOR, PSEUDO_RANDOM_);
    WIDTH_CUM_SEQ = GENERATEPOOLINGSEQUENCE(INPUT_SIZE[2], OUTPUT_SIZE[2],
                                            &GENERATOR, PSEUDO_RANDOM_);

    // PREPARE OUTPUT.
    TENSOR* OUTPUT_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT(
                                0,
                                TENSORSHAPE({OUTPUT_SIZE[0], OUTPUT_SIZE[1],
                                             OUTPUT_SIZE[2], OUTPUT_SIZE[3]}),
                                &OUTPUT_TENSOR));
    TENSOR* OUTPUT_HEIGHT_SEQ_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CONTEXT,
        CONTEXT->ALLOCATE_OUTPUT(
            1, TENSORSHAPE({STATIC_CAST<INT64_T>(HEIGHT_CUM_SEQ.SIZE())}),
            &OUTPUT_HEIGHT_SEQ_TENSOR));
    TENSOR* OUTPUT_WIDTH_SEQ_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CONTEXT,
        CONTEXT->ALLOCATE_OUTPUT(
            2, TENSORSHAPE({STATIC_CAST<INT64_T>(WIDTH_CUM_SEQ.SIZE())}),
            &OUTPUT_WIDTH_SEQ_TENSOR));

    CONSTEIGENMATRIXMAP IN_MAT(TENSOR_IN.FLAT<T>().DATA(), INPUT_SIZE[3],
                               INPUT_SIZE[2] * INPUT_SIZE[1] * INPUT_SIZE[0]);

    EIGENMATRIXMAP OUT_MAT(OUTPUT_TENSOR->FLAT<T>().DATA(), OUTPUT_SIZE[3],
                           OUTPUT_SIZE[2] * OUTPUT_SIZE[1] * OUTPUT_SIZE[0]);

    // INITIALIZES THE OUTPUT TENSOR WITH MIN<T>.
    OUTPUT_TENSOR->FLAT<T>().SETCONSTANT(EIGEN::NUMTRAITS<T>::LOWEST());

    AUTO OUTPUT_HEIGHT_SEQ_FLAT = OUTPUT_HEIGHT_SEQ_TENSOR->FLAT<INT64_T>();
    AUTO OUTPUT_WIDTH_SEQ_FLAT = OUTPUT_WIDTH_SEQ_TENSOR->FLAT<INT64_T>();

    // SET OUTPUT TENSORS.
    FOR (INT I = 0; I < HEIGHT_CUM_SEQ.SIZE(); ++I) {
      OUTPUT_HEIGHT_SEQ_FLAT(I) = HEIGHT_CUM_SEQ[I];
    }

    FOR (INT I = 0; I < WIDTH_CUM_SEQ.SIZE(); ++I) {
      OUTPUT_WIDTH_SEQ_FLAT(I) = WIDTH_CUM_SEQ[I];
    }

    // FOR BOTH INPUT AND OUTPUT,
    // 0: BATCH
    // 1: HEIGHT / ROW
    // 2: WIDTH / COL
    // 3: DEPTH / CHANNEL
    CONST INT64_T HEIGHT_MAX = INPUT_SIZE[1] - 1;
    CONST INT64_T WIDTH_MAX = INPUT_SIZE[2] - 1;
    FOR (INT64_T B = 0; B < INPUT_SIZE[0]; ++B) {
      // HEIGHT SEQUENCE.
      FOR (INT64_T HS = 0; HS < HEIGHT_CUM_SEQ.SIZE() - 1; ++HS) {
        // HEIGHT START AND END.
        CONST INT64_T HEIGHT_START = HEIGHT_CUM_SEQ[HS];
        INT64_T HEIGHT_END =
            OVERLAPPING_ ? HEIGHT_CUM_SEQ[HS + 1] : HEIGHT_CUM_SEQ[HS + 1] - 1;
        HEIGHT_END = STD::MIN(HEIGHT_END, HEIGHT_MAX);

        // WIDTH SEQUENCE.
        FOR (INT64_T WS = 0; WS < WIDTH_CUM_SEQ.SIZE() - 1; ++WS) {
          CONST INT64_T OUT_OFFSET =
              (B * OUTPUT_SIZE[1] + HS) * OUTPUT_SIZE[2] + WS;
          // WIDTH START AND END.
          CONST INT64_T WIDTH_START = WIDTH_CUM_SEQ[WS];
          INT64_T WIDTH_END =
              OVERLAPPING_ ? WIDTH_CUM_SEQ[WS + 1] : WIDTH_CUM_SEQ[WS + 1] - 1;
          WIDTH_END = STD::MIN(WIDTH_END, WIDTH_MAX);
          FOR (INT64_T H = HEIGHT_START; H <= HEIGHT_END; ++H) {
            FOR (INT64_T W = WIDTH_START; W <= WIDTH_END; ++W) {
              CONST INT64_T IN_OFFSET =
                  (B * INPUT_SIZE[1] + H) * INPUT_SIZE[2] + W;
              OUT_MAT.COL(OUT_OFFSET) =
                  OUT_MAT.COL(OUT_OFFSET).CWISEMAX(IN_MAT.COL(IN_OFFSET));
            }
          }
        }
      }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247530_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_P(SSLSOCKETTEST, FAILEDCLIENTCERTIFICATEHASHVERIFICATIONWRONGCA) {
  CONST STD::STRING CLIENT_CTX_YAML = R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
      CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SAN_URI_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SAN_URI_KEY.PEM"
)EOF";

  CONST STD::STRING SERVER_CTX_YAML = ABSL::STRCAT(R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
      CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/UNITTEST_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/UNITTEST_KEY.PEM"
    VALIDATION_CONTEXT:
      TRUSTED_CA:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/FAKE_CA_CERT.PEM"
      VERIFY_CERTIFICATE_HASH: ")EOF",
                                                   TEST_SAN_URI_CERT_256_HASH, "\"");

  TESTUTILOPTIONS TEST_OPTIONS(CLIENT_CTX_YAML, SERVER_CTX_YAML, FALSE, GETPARAM());
  TESTUTIL(TEST_OPTIONS.SETEXPECTEDSERVERSTATS("SSL.FAIL_VERIFY_ERROR")
               .SETEXPECTEDVERIFYERRORCODE(X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197110_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* C) OVERRIDE {
    CORE::REFCOUNTPTR<VAR> V;
    OP_REQUIRES_OK(C, LOOKUPRESOURCE(C, HANDLEFROMINPUT(C, 0), &V));
    OP_REQUIRES_OK(C, ENSURESPARSEVARIABLEACCESS<DEVICE, T>(C, V.GET()));
    // NOTE: WE HOLD THE LOCK FOR THE WHOLE GATHER OPERATION INSTEAD
    // OF INCREASING THE REFERENCE COUNT OF V->TENSOR() TO AVOID A
    // SITUATION WHERE A WRITE TO THE SAME VARIABLE WILL SEE A
    // REFERENCE COUNT GREATER THAN ONE AND MAKE A COPY OF THE
    // (POTENTIALLY VERY LARGE) TENSOR BUFFER.
    TF_SHARED_LOCK ML(*V->MU());
    CONST TENSOR& PARAMS = *V->TENSOR();
    CONST TENSOR& INDICES = C->INPUT(1);
    OP_REQUIRES(
        C, TENSORSHAPEUTILS::ISVECTORORHIGHER(PARAMS.SHAPE()),
        ERRORS::INVALIDARGUMENT("PARAMS MUST BE AT LEAST 1 DIMENSIONAL"));

    // CHECK THAT WE HAVE ENOUGH INDEX SPACE
    CONST INT64_T N = INDICES.NUMELEMENTS();
    OP_REQUIRES(
        C, PARAMS.DIM_SIZE(0) <= STD::NUMERIC_LIMITS<INDEX>::MAX(),
        ERRORS::INVALIDARGUMENT("PARAMS.SHAPE[0] TOO LARGE FOR ",
                                DATATYPESTRING(DATATYPETOENUM<INDEX>::V()),
                                " INDEXING: ", PARAMS.DIM_SIZE(0), " > ",
                                STD::NUMERIC_LIMITS<INDEX>::MAX()));

    // THE RESULT SHAPE IS PARAMS.SHAPE[:BATCH_DIMS] +
    // INDICES.SHAPE[BATCH_DIMS:] + PARAMS.SHAPE[BATCH_DIMS+1:].
    TENSORSHAPE RESULT_SHAPE;
    FOR (INT I = 0; I < BATCH_DIMS_; ++I) {
      RESULT_SHAPE.ADDDIM(PARAMS.DIM_SIZE(I));
    }
    FOR (INT I = BATCH_DIMS_; I < INDICES.DIMS(); ++I) {
      RESULT_SHAPE.ADDDIM(INDICES.DIM_SIZE(I));
    }
    FOR (INT I = BATCH_DIMS_ + 1; I < PARAMS.DIMS(); ++I) {
      RESULT_SHAPE.ADDDIM(PARAMS.DIM_SIZE(I));
    }

    TENSOR* OUT = NULLPTR;
    TENSOR TMP;
    IF (PARAMS.DTYPE() == DT_VARIANT) {
      TMP = TENSOR(DT_VARIANT, RESULT_SHAPE);
      C->SET_OUTPUT(0, TMP);
      OUT = &TMP;
    } ELSE {
      OP_REQUIRES_OK(C, C->ALLOCATE_OUTPUT(0, RESULT_SHAPE, &OUT));
    }

    IF (N > 0) {
      TENSOR TMP_INDICES;

      // POINTS TO THE ORIGINAL OR UPDATED (IF BATCH_DIMS IS SET) INDICES.
      CONST TENSOR* OP_INDICES = &INDICES;
      IF (BATCH_DIMS_ > 0) {
        OP_REQUIRES_OK(C, C->ALLOCATE_TEMP(INDICES.DTYPE(), INDICES.SHAPE(),
                                           &TMP_INDICES));
        FUNCTOR::DENSEUPDATE<DEVICE, INDEX, ASSIGN> COPY_FUNCTOR;
        COPY_FUNCTOR(C->EIGEN_DEVICE<DEVICE>(), TMP_INDICES.FLAT<INDEX>(),
                     INDICES.FLAT<INDEX>());

        ADDBATCHOFFSETS(&TMP_INDICES, PARAMS);
        OP_INDICES = &TMP_INDICES;
      }

      INT64_T GATHER_DIM_SIZE = 1;
      FOR (INT IDX = 0; IDX <= BATCH_DIMS_; ++IDX) {
        GATHER_DIM_SIZE *= PARAMS.DIM_SIZE(IDX);
      }
      INT64_T INNER_SIZE = 1;
      FOR (INT I = BATCH_DIMS_ + 1; I < PARAMS.DIMS(); ++I) {
        INNER_SIZE *= PARAMS.DIM_SIZE(I);
      }
      AUTO PARAMS_FLAT = PARAMS.SHAPED<T, 3>({1, GATHER_DIM_SIZE, INNER_SIZE});
      CONST AUTO INDICES_FLAT = OP_INDICES->FLAT<INDEX>();
      AUTO OUT_FLAT = OUT->SHAPED<T, 3>({1, N, OUT->NUMELEMENTS() / N});

      FUNCTOR::GATHERFUNCTOR<DEVICE, T, INDEX> FUNCTOR;
      INT64_T BAD_I = FUNCTOR(C, PARAMS_FLAT, INDICES_FLAT, OUT_FLAT);

      OP_REQUIRES(
          C, BAD_I < 0,
          ERRORS::INVALIDARGUMENT(
              "INDICES", SLICEDEBUGSTRING(INDICES.SHAPE(), BAD_I), " = ",
              INDICES_FLAT(BAD_I), " IS NOT IN [0, ", PARAMS.DIM_SIZE(0), ")"));
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196834_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS SPARSECOUNTSPARSEOUTPUTSHAPEFN(INFERENCECONTEXT *C) {
  AUTO RANK = C->DIM(C->INPUT(0), 1);
  AUTO NVALS = C->UNKNOWNDIM();
  C->SET_OUTPUT(0, C->MATRIX(NVALS, RANK));  // OUT.INDICES
  C->SET_OUTPUT(1, C->VECTOR(NVALS));        // OUT.VALUES
  C->SET_OUTPUT(2, C->VECTOR(RANK));         // OUT.DENSE_SHAPE
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 194998_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS CONSTANTFOLDING::ISSIMPLIFIABLERESHAPE(
    CONST NODEDEF& NODE, CONST GRAPHPROPERTIES& PROPERTIES) CONST {
  IF (!ISRESHAPE(NODE)) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(), " IS NOT A RESHAPE NODE");
  }
  IF (2 > NODE.INPUT_SIZE()) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(),
                            " MUST HAVE AT MOST 2 INPUTS BUT HAS ",
                            NODE.INPUT_SIZE());
  }
  CONST NODEDEF* NEW_SHAPE = NODE_MAP_->GETNODE(NODE.INPUT(1));
  IF (!ISREALLYCONSTANT(*NEW_SHAPE)) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(), " HAS SHAPE ",
                            NEW_SHAPE->DEBUGSTRING(),
                            " WHICH IS NOT A CONSTANT");
  }
  TENSORVECTOR OUTPUTS;
  AUTO OUTPUTS_CLEANUP = GTL::MAKECLEANUP([&OUTPUTS] {
    FOR (CONST AUTO& OUTPUT : OUTPUTS) {
      DELETE OUTPUT.TENSOR;
    }
  });

  STATUS S = EVALUATENODE(*NEW_SHAPE, TENSORVECTOR(), &OUTPUTS);
  IF (!S.OK()) {
    RETURN ERRORS::INTERNAL("COULD NOT EVALUATE NODE ", NODE.NAME());
  }
  IF (OUTPUTS.SIZE() != 1) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(),
                            " MUST HAVE EXACTLY 1 OUTPUT BUT HAS ",
                            OUTPUTS.SIZE());
  }

  CONST STD::VECTOR<OPINFO::TENSORPROPERTIES>& PROPS =
      PROPERTIES.GETINPUTPROPERTIES(NODE.NAME());
  IF (PROPS.EMPTY()) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(), " HAS NO PROPERTIES");
  }
  CONST OPINFO::TENSORPROPERTIES& PROP = PROPS[0];
  IF (PROP.DTYPE() == DT_INVALID) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(), " HAS PROPERTY ",
                            PROP.DEBUGSTRING(), " WITH INVALID DTYPE");
  }
  CONST PARTIALTENSORSHAPE SHAPE(PROP.SHAPE());
  IF (!SHAPE.ISFULLYDEFINED()) {
    RETURN ERRORS::INTERNAL("NODE ", NODE.NAME(), " HAS PROPERTY ",
                            PROP.DEBUGSTRING(), " WITH SHAPE ",
                            SHAPE.DEBUGSTRING(), " WHICH IS NOT FULLY DEFINED");
  }

  PARTIALTENSORSHAPE NEW_DIMS;
  IF (OUTPUTS[0]->DTYPE() == DT_INT32) {
    STD::VECTOR<INT32> SHP;
    FOR (INT I = 0; I < OUTPUTS[0]->NUMELEMENTS(); ++I) {
      INT32_T DIM = OUTPUTS[0]->FLAT<INT32>()(I);
      SHP.PUSH_BACK(DIM);
    }
    TF_CHECK_OK(TENSORSHAPEUTILS::MAKESHAPE(SHP, &NEW_DIMS));
  } ELSE {
    STD::VECTOR<INT64_T> SHP;
    FOR (INT I = 0; I < OUTPUTS[0]->NUMELEMENTS(); ++I) {
      INT64_T DIM = OUTPUTS[0]->FLAT<INT64_T>()(I);
      SHP.PUSH_BACK(DIM);
    }
    TF_CHECK_OK(TENSORSHAPEUTILS::MAKESHAPE(SHP, &NEW_DIMS));
  }

  IF (!SHAPE.ISCOMPATIBLEWITH(NEW_DIMS)) {
    RETURN ERRORS::INTERNAL("EXPECTED SHAPE ", SHAPE.DEBUGSTRING(),
                            "TO BE COMPATIBLE WITH ", NEW_DIMS.DEBUGSTRING());
  }

  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196620_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR& INPUT = CONTEXT->INPUT(0);
    CONST TENSORSHAPE& INPUT_SHAPE = INPUT.SHAPE();
    CONST INT32_T INPUT_DIMS = INPUT_SHAPE.DIMS();

    CONST TENSOR& SEGMENT_ID = CONTEXT->INPUT(1);
    CONST TENSORSHAPE& SEGMENT_ID_SHAPE = SEGMENT_ID.SHAPE();
    CONST INT32_T SEGMENT_DIMS = SEGMENT_ID_SHAPE.DIMS();

    CONST TENSOR& NUM_SEGMENTS_TENSOR = CONTEXT->INPUT(2);
    OP_REQUIRES(CONTEXT, NUM_SEGMENTS_TENSOR.NUMELEMENTS() != 0,
                ERRORS::INVALIDARGUMENT("NUMBER OF SEGMENTS CANNOT BE EMPTY."));
    AUTO NUM_SEGMENTS = NUM_SEGMENTS_TENSOR.SCALAR<NUM_SEGMENTS_TYPE>()();

    OP_REQUIRES(CONTEXT, NUM_SEGMENTS > 0,
                ERRORS::INVALIDARGUMENT("NUMBER OF SEGMENTS MUST BE POSITIVE"));
    OP_REQUIRES(CONTEXT, SEGMENT_DIMS != 0,
                ERRORS::INVALIDARGUMENT("SEGMENT_ID CANNOT HAVE RANK 0"));

    OP_REQUIRES(
        CONTEXT, SEGMENT_DIMS <= INPUT_DIMS,
        ERRORS::OUTOFRANGE("INVALID SEGMENT_ID RANK ", SEGMENT_DIMS,
                           " FOR INPUT WITH ", INPUT_DIMS, " DIMENSION(S)"));
    FOR (AUTO I = 0; I < SEGMENT_DIMS; I++) {
      OP_REQUIRES(
          CONTEXT, SEGMENT_ID_SHAPE.DIM_SIZE(I) == INPUT_SHAPE.DIM_SIZE(I),
          ERRORS::INVALIDARGUMENT(
              "SEGMENT DIMENSION IS ", SEGMENT_ID_SHAPE.DIM_SIZE(I),
              " WHILE INPUT DIMENSION IS ", INPUT_DIMS, " IN RANK ", I));
    }

    // MAKING OUTPUT TENSOR.
    TENSOR* OUTPUT_TENSOR = NULLPTR;
    TENSORSHAPE OUTPUT_SHAPE =
        GETOUTPUTSHAPE(INPUT_SHAPE, SEGMENT_ID_SHAPE, NUM_SEGMENTS);
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("OUTPUT", OUTPUT_SHAPE,
                                                     &OUTPUT_TENSOR));

    // PREPARATING FLAT TENSORS.
    AUTO OUTPUT_FLAT = OUTPUT_TENSOR->FLAT<TSTRING>();
    AUTO FLAT_SEGMENT_ID = SEGMENT_ID.FLAT<INDICES_TYPE>();
    AUTO FLAT_INPUT = INPUT.FLAT<TSTRING>();

    FOR (INT I = 0; I < FLAT_SEGMENT_ID.SIZE(); I++) {
      OP_REQUIRES(
          CONTEXT,
          ((FLAT_SEGMENT_ID(I) < NUM_SEGMENTS) && (FLAT_SEGMENT_ID(I) >= 0)),
          ERRORS::INVALIDARGUMENT(
              "SEGMENT_IDS ARE NOT ALLOWED TO EXCEED NUM_SEGMENTS OR"
              " TO HAVE NEGATIVE VALUES."));
    }

    INT64_T BIG_STRIDE;
    INT64_T SMALL_STRIDE;
    STD::TIE(BIG_STRIDE, SMALL_STRIDE) =
        GETSTRIDES<INDICES_TYPE>(INPUT_SHAPE, SEGMENT_ID_SHAPE);
    AUTO RELATIVE_OFFSET_SET =
        GETFLATTENEDRELATIVEOFFSETS<INDICES_TYPE>(SMALL_STRIDE, BIG_STRIDE);
    FOR (AUTO START_OFFSET = 0; START_OFFSET < BIG_STRIDE; START_OFFSET++) {
      FOR (AUTO I = 0; I < RELATIVE_OFFSET_SET.SIZE(); I++) {
        AUTO OUTPUT_INDEX = START_OFFSET + FLAT_SEGMENT_ID(I) * BIG_STRIDE;
        AUTO OFFSET = START_OFFSET + RELATIVE_OFFSET_SET[I];
        IF (OUTPUT_FLAT(OUTPUT_INDEX).LENGTH() != 0)
          OUTPUT_FLAT(OUTPUT_INDEX).APPEND(SEPARATOR_.C_STR());
        OUTPUT_FLAT(OUTPUT_INDEX).APPEND(FLAT_INPUT(OFFSET));
      }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 256141_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ALWAYS_INLINE VOID MULADD(CONST PACKET A, CONST FLOAT** INP, FLOAT** OUT) {
  CONST AUTO B = LOAD(*INP);
  *INP += KNUMOPERANDS;
  AUTO C = LOAD(*OUT);
  FMA(A, B, C, C);
  STORE(*OUT, C);
  *OUT += KNUMOPERANDS;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 242925_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  EXPLICIT SPARSETENSORDENSEADDOP(OPKERNELCONSTRUCTION *CTX) : OPKERNEL(CTX) {}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198116_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT *CTX) OVERRIDE {
    CONST TENSOR *INDICES_T, *VALUES_T, *SHAPE_T, *REDUCTION_AXES_T;
    OP_REQUIRES_OK(CTX, CTX->INPUT("INPUT_INDICES", &INDICES_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("INPUT_VALUES", &VALUES_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("INPUT_SHAPE", &SHAPE_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("REDUCTION_AXES", &REDUCTION_AXES_T));

    OP_REQUIRES_OK(CTX, VALIDATEINPUTS(SHAPE_T, REDUCTION_AXES_T));

    // TODO(ZONGHENG): WE WILL CALL REORDER() BELOW, WHICH WILL MODIFY
    // IN-PLACE THE UNDERLYING INDICES AND VALUES BUFFERS.  TO AVOID
    // SURPRISES OF THIS KERNEL BEING STATEFUL, WE WORK AROUND THE ABOVE BY
    // MAKING DEEP COPIES HERE.  REMOVE THIS IF/WHEN WE CHANGE REORDER()'S
    // SEMANTICS.
    CONST AUTO SHAPE_VEC = SHAPE_T->VEC<INT64>();
    SPARSETENSOR SP;
    OP_REQUIRES_OK(CTX, SPARSETENSOR::CREATE(
        TENSOR::DEEPCOPY(*INDICES_T), TENSOR::DEEPCOPY(*VALUES_T),
                    TENSORSHAPE(SHAPE_VEC), &SP));
    REDUCEDETAILS REDUCTION = SPARSETENSORREDUCEHELPER(
        SP, REDUCTION_AXES_T->FLAT<INT32>(), KEEP_DIMS_);

    TENSOR *OUT_VALUES;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT(0, REDUCTION.REDUCED_SHAPE, &OUT_VALUES));
    AUTO OUT_FLAT = OUT_VALUES->FLAT<T>();
    OUT_FLAT.SETZERO();

    TENSOR TMP_REDUCED_VAL;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::VALUE,
                                           TENSORSHAPE({}), &TMP_REDUCED_VAL));
    AUTO REDUCED_VAL = TMP_REDUCED_VAL.SCALAR<T>();

    // COMPUTE STRIDES, AND USE IT TO CONVERT COORDS TO FLAT INDEX.  THE
    // COORDINATES RETURNED BY .GROUP() HAVE THE SAME NDIMS AS GROUP_BY_DIMS.
    GTL::INLINEDVECTOR<INT64, 8> OUTPUT_STRIDES(REDUCTION.GROUP_BY_DIMS.SIZE());
    IF (!OUTPUT_STRIDES.EMPTY()) {  // DO THIS IFF WE DON'T REDUCE ALL.
      OUTPUT_STRIDES.BACK() = 1;
      FOR (INT D = OUTPUT_STRIDES.SIZE() - 2; D >= 0; --D) {
        OUTPUT_STRIDES[D] =
            OUTPUT_STRIDES[D + 1] * SHAPE_VEC(REDUCTION.GROUP_BY_DIMS[D + 1]);
      }
    }

    AUTO COORDINATESTOFLATINDEX = [](ARRAYSLICE<INT64> COORDS,
                                     ARRAYSLICE<INT64> STRIDES) -> INT64 {
      IF (STRIDES.EMPTY()) {  // REDUCE ALL.
        RETURN 0;
      }
      CHECK_EQ(COORDS.SIZE(), STRIDES.SIZE());
      INT64_T IDX = 0;
      FOR (INT I = 0; I < COORDS.SIZE(); ++I) {
        IDX += COORDS[I] * STRIDES[I];
      }
      RETURN IDX;
    };

    // EACH GROUP MAPS ONE-ON-ONE ONTO A VALUE IN THE REDUCED TENSOR.
    // G.GROUP() PROVIDES THE COORDINATES OF A PARTICULAR REDUCED VALUE.
    SP.REORDER<T>(REDUCTION.REORDER_DIMS);
    FOR (CONST AUTO &G : SP.GROUP(REDUCTION.GROUP_BY_DIMS)) {
      OP::TEMPLATE RUN<T>(CTX, REDUCED_VAL, G.TEMPLATE VALUES<T>());
      CONST INT64_T IDX = COORDINATESTOFLATINDEX(G.GROUP(), OUTPUT_STRIDES);
      OUT_FLAT(IDX) = REDUCED_VAL();
      VLOG(2) << "COORDS: " << ABSL::STRJOIN(G.GROUP(), ",")
              << "; IDX: " << IDX << "; GROUP " << OP::NAME() << ": "
              << REDUCED_VAL();
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195055_CWE-787.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR& INDICES = CONTEXT->INPUT(0);
    CONST TENSOR& VALUES = CONTEXT->INPUT(1);
    CONST TENSOR& SHAPE = CONTEXT->INPUT(2);
    CONST TENSOR& WEIGHTS = CONTEXT->INPUT(3);
    BOOL USE_WEIGHTS = WEIGHTS.NUMELEMENTS() > 0;

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INDICES.SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES MUST BE A 2-DIMENSIONAL TENSOR. GOT: ",
                    INDICES.SHAPE().DEBUGSTRING()));

    IF (USE_WEIGHTS) {
      OP_REQUIRES(
          CONTEXT, WEIGHTS.SHAPE() == VALUES.SHAPE(),
          ERRORS::INVALIDARGUMENT(
              "WEIGHTS AND VALUES MUST HAVE THE SAME SHAPE. WEIGHT SHAPE: ",
              WEIGHTS.SHAPE().DEBUGSTRING(),
              "; VALUES SHAPE: ", VALUES.SHAPE().DEBUGSTRING()));
    }

    OP_REQUIRES(CONTEXT, SHAPE.NUMELEMENTS() != 0,
                ERRORS::INVALIDARGUMENT(
                    "THE SHAPE ARGUMENT REQUIRES AT LEAST ONE ELEMENT."));

    BOOL IS_1D = SHAPE.NUMELEMENTS() == 1;
    AUTO SHAPE_VECTOR = SHAPE.FLAT<INT64_T>();
    INT NUM_BATCHES = IS_1D ? 1 : SHAPE_VECTOR(0);
    INT NUM_VALUES = VALUES.NUMELEMENTS();

    FOR (INT B = 0; B < SHAPE_VECTOR.SIZE(); B++) {
      OP_REQUIRES(CONTEXT, SHAPE_VECTOR(B) >= 0,
                  ERRORS::INVALIDARGUMENT(
                      "ELEMENTS IN DENSE_SHAPE MUST BE >= 0. INSTEAD GOT:",
                      SHAPE.DEBUGSTRING()));
    }

    OP_REQUIRES(CONTEXT, NUM_VALUES == INDICES.SHAPE().DIM_SIZE(0),
                ERRORS::INVALIDARGUMENT(
                    "NUMBER OF VALUES MUST MATCH FIRST DIMENSION OF INDICES.",
                    "GOT ", NUM_VALUES,
                    " VALUES, INDICES SHAPE: ", INDICES.SHAPE().DEBUGSTRING()));

    CONST AUTO INDICES_VALUES = INDICES.MATRIX<INT64_T>();
    CONST AUTO VALUES_VALUES = VALUES.FLAT<T>();
    CONST AUTO WEIGHT_VALUES = WEIGHTS.FLAT<W>();

    AUTO PER_BATCH_COUNTS = BATCHEDMAP<W>(NUM_BATCHES);

    T MAX_VALUE = 0;

    OP_REQUIRES(CONTEXT, NUM_VALUES <= INDICES.SHAPE().DIM_SIZE(0),
                ERRORS::INVALIDARGUMENT(
                    "THE FIRST DIMENSION OF INDICES MUST BE EQUAL TO OR "
                    "GREATHER THAN NUMBER OF VALUES. ( ",
                    INDICES.SHAPE().DIM_SIZE(0), " VS. ", NUM_VALUES, " )"));
    OP_REQUIRES(CONTEXT, INDICES.SHAPE().DIM_SIZE(1) > 0,
                ERRORS::INVALIDARGUMENT("THE SECOND DIMENSION OF INDICES MUST "
                                        "BE GREATER THAN 0. RECEIVED: ",
                                        INDICES.SHAPE().DIM_SIZE(1)));

    FOR (INT IDX = 0; IDX < NUM_VALUES; ++IDX) {
      INT BATCH = IS_1D ? 0 : INDICES_VALUES(IDX, 0);
      IF (BATCH >= NUM_BATCHES) {
        OP_REQUIRES(CONTEXT, BATCH < NUM_BATCHES,
                    ERRORS::INVALIDARGUMENT(
                        "INDICES VALUE ALONG THE FIRST DIMENSION MUST BE ",
                        "LOWER THAN THE FIRST INDEX OF THE SHAPE.", "GOT ",
                        BATCH, " AS BATCH AND ", NUM_BATCHES,
                        " AS THE FIRST DIMENSION OF THE SHAPE."));
      }
      CONST AUTO& VALUE = VALUES_VALUES(IDX);
      IF (VALUE >= 0 && (MAXLENGTH_ <= 0 || VALUE < MAXLENGTH_)) {
        IF (BINARY_OUTPUT_) {
          PER_BATCH_COUNTS[BATCH][VALUE] = 1;
        } ELSE IF (USE_WEIGHTS) {
          PER_BATCH_COUNTS[BATCH][VALUE] += WEIGHT_VALUES(IDX);
        } ELSE {
          PER_BATCH_COUNTS[BATCH][VALUE]++;
        }
        IF (VALUE > MAX_VALUE) {
          MAX_VALUE = VALUE;
        }
      }
    }

    INT NUM_OUTPUT_VALUES = GETOUTPUTSIZE(MAX_VALUE, MAXLENGTH_, MINLENGTH_);
    OP_REQUIRES_OK(CONTEXT, OUTPUTSPARSE<W>(PER_BATCH_COUNTS, NUM_OUTPUT_VALUES,
                                            IS_1D, CONTEXT));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195965_CWE-787.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR* HYPOTHESIS_INDICES;
    CONST TENSOR* HYPOTHESIS_VALUES;
    CONST TENSOR* HYPOTHESIS_SHAPE;
    CONST TENSOR* TRUTH_INDICES;
    CONST TENSOR* TRUTH_VALUES;
    CONST TENSOR* TRUTH_SHAPE;
    OP_REQUIRES_OK(CTX, CTX->INPUT("HYPOTHESIS_INDICES", &HYPOTHESIS_INDICES));
    OP_REQUIRES_OK(CTX, CTX->INPUT("HYPOTHESIS_VALUES", &HYPOTHESIS_VALUES));
    OP_REQUIRES_OK(CTX, CTX->INPUT("HYPOTHESIS_SHAPE", &HYPOTHESIS_SHAPE));
    OP_REQUIRES_OK(CTX, CTX->INPUT("TRUTH_INDICES", &TRUTH_INDICES));
    OP_REQUIRES_OK(CTX, CTX->INPUT("TRUTH_VALUES", &TRUTH_VALUES));
    OP_REQUIRES_OK(CTX, CTX->INPUT("TRUTH_SHAPE", &TRUTH_SHAPE));

    OP_REQUIRES_OK(
        CTX, VALIDATESHAPES(CTX, *HYPOTHESIS_INDICES, *HYPOTHESIS_VALUES,
                            *HYPOTHESIS_SHAPE, *TRUTH_INDICES, *TRUTH_VALUES,
                            *TRUTH_SHAPE));

    TENSORSHAPE HYPOTHESIS_ST_SHAPE;
    OP_REQUIRES_OK(CTX,
                   TENSORSHAPEUTILS::MAKESHAPE(
                       HYPOTHESIS_SHAPE->VEC<INT64_T>().DATA(),
                       HYPOTHESIS_SHAPE->NUMELEMENTS(), &HYPOTHESIS_ST_SHAPE));
    TENSORSHAPE TRUTH_ST_SHAPE;
    OP_REQUIRES_OK(CTX, TENSORSHAPEUTILS::MAKESHAPE(
                            TRUTH_SHAPE->VEC<INT64_T>().DATA(),
                            TRUTH_SHAPE->NUMELEMENTS(), &TRUTH_ST_SHAPE));

    // ASSUME INDICES ARE SORTED IN ROW-MAJOR ORDER.
    STD::VECTOR<INT64_T> SORTED_ORDER(TRUTH_ST_SHAPE.DIMS());
    STD::IOTA(SORTED_ORDER.BEGIN(), SORTED_ORDER.END(), 0);

    SPARSE::SPARSETENSOR HYPOTHESIS;
    OP_REQUIRES_OK(CTX, SPARSE::SPARSETENSOR::CREATE(
                            *HYPOTHESIS_INDICES, *HYPOTHESIS_VALUES,
                            HYPOTHESIS_ST_SHAPE, SORTED_ORDER, &HYPOTHESIS));

    SPARSE::SPARSETENSOR TRUTH;
    OP_REQUIRES_OK(CTX, SPARSE::SPARSETENSOR::CREATE(
                            *TRUTH_INDICES, *TRUTH_VALUES, TRUTH_ST_SHAPE,
                            SORTED_ORDER, &TRUTH));

    // GROUP DIMS 0, 1, ..., RANK - 1.  THE VERY LAST DIM IS ASSUMED
    // TO STORE THE VARIABLE LENGTH SEQUENCES.
    STD::VECTOR<INT64_T> GROUP_DIMS(TRUTH_ST_SHAPE.DIMS() - 1);
    STD::IOTA(GROUP_DIMS.BEGIN(), GROUP_DIMS.END(), 0);

    TENSORSHAPE OUTPUT_SHAPE;
    FOR (INT D = 0; D < STATIC_CAST<INT>(GROUP_DIMS.SIZE()); ++D) {
      OUTPUT_SHAPE.ADDDIM(STD::MAX(HYPOTHESIS_ST_SHAPE.DIM_SIZE(D),
                                   TRUTH_ST_SHAPE.DIM_SIZE(D)));
    }
    CONST AUTO OUTPUT_ELEMENTS = OUTPUT_SHAPE.NUM_ELEMENTS();
    OP_REQUIRES(
        CTX, OUTPUT_ELEMENTS > 0,
        ERRORS::INVALIDARGUMENT("GOT OUTPUT SHAPE ", OUTPUT_SHAPE.DEBUGSTRING(),
                                " WHICH HAS 0 ELEMENTS"));

    TENSOR* OUTPUT = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT("OUTPUT", OUTPUT_SHAPE, &OUTPUT));
    AUTO OUTPUT_T = OUTPUT->FLAT<FLOAT>();
    OUTPUT_T.SETZERO();

    STD::VECTOR<INT64_T> OUTPUT_STRIDES(OUTPUT_SHAPE.DIMS());
    OUTPUT_STRIDES[OUTPUT_SHAPE.DIMS() - 1] = 1;
    FOR (INT D = OUTPUT_SHAPE.DIMS() - 2; D >= 0; --D) {
      OUTPUT_STRIDES[D] = OUTPUT_STRIDES[D + 1] * OUTPUT_SHAPE.DIM_SIZE(D + 1);
    }

    AUTO HYPOTHESIS_GROUPER = HYPOTHESIS.GROUP(GROUP_DIMS);
    AUTO TRUTH_GROUPER = TRUTH.GROUP(GROUP_DIMS);

    AUTO HYPOTHESIS_ITER = HYPOTHESIS_GROUPER.BEGIN();
    AUTO TRUTH_ITER = TRUTH_GROUPER.BEGIN();

    AUTO CMP = STD::EQUAL_TO<T>();

    WHILE (HYPOTHESIS_ITER != HYPOTHESIS_GROUPER.END() &&
           TRUTH_ITER != TRUTH_GROUPER.END()) {
      SPARSE::GROUP TRUTH_I = *TRUTH_ITER;
      SPARSE::GROUP HYPOTHESIS_J = *HYPOTHESIS_ITER;
      STD::VECTOR<INT64_T> G_TRUTH = TRUTH_I.GROUP();
      STD::VECTOR<INT64_T> G_HYPOTHESIS = HYPOTHESIS_J.GROUP();
      AUTO TRUTH_SEQ = TRUTH_I.VALUES<T>();
      AUTO HYPOTHESIS_SEQ = HYPOTHESIS_J.VALUES<T>();

      IF (G_TRUTH == G_HYPOTHESIS) {
        AUTO LOC = STD::INNER_PRODUCT(G_TRUTH.BEGIN(), G_TRUTH.END(),
                                      OUTPUT_STRIDES.BEGIN(), INT64_T{0});
        OP_REQUIRES(
            CTX, LOC < OUTPUT_ELEMENTS,
            ERRORS::INTERNAL("GOT AN INNER PRODUCT ", LOC,
                             " WHICH WOULD REQUIRE IN WRITING TO OUTSIDE OF "
                             "THE BUFFER FOR THE OUTPUT TENSOR (MAX ELEMENTS ",
                             OUTPUT_ELEMENTS, ")"));
        OUTPUT_T(LOC) =
            GTL::LEVENSHTEINDISTANCE<T>(TRUTH_SEQ, HYPOTHESIS_SEQ, CMP);
        IF (NORMALIZE_) OUTPUT_T(LOC) /= TRUTH_SEQ.SIZE();

        ++HYPOTHESIS_ITER;
        ++TRUTH_ITER;
      } ELSE IF (G_TRUTH > G_HYPOTHESIS) {  // ZERO-LENGTH TRUTH
        AUTO LOC = STD::INNER_PRODUCT(G_HYPOTHESIS.BEGIN(), G_HYPOTHESIS.END(),
                                      OUTPUT_STRIDES.BEGIN(), INT64_T{0});
        OP_REQUIRES(
            CTX, LOC < OUTPUT_ELEMENTS,
            ERRORS::INTERNAL("GOT AN INNER PRODUCT ", LOC,
                             " WHICH WOULD REQUIRE IN WRITING TO OUTSIDE OF "
                             "THE BUFFER FOR THE OUTPUT TENSOR (MAX ELEMENTS ",
                             OUTPUT_ELEMENTS, ")"));
        OUTPUT_T(LOC) = HYPOTHESIS_SEQ.SIZE();
        IF (NORMALIZE_ && OUTPUT_T(LOC) != 0.0F) {
          OUTPUT_T(LOC) = STD::NUMERIC_LIMITS<FLOAT>::INFINITY();
        }
        ++HYPOTHESIS_ITER;
      } ELSE {  // ZERO-LENGTH HYPOTHESIS
        AUTO LOC = STD::INNER_PRODUCT(G_TRUTH.BEGIN(), G_TRUTH.END(),
                                      OUTPUT_STRIDES.BEGIN(), INT64_T{0});
        OP_REQUIRES(
            CTX, LOC < OUTPUT_ELEMENTS,
            ERRORS::INTERNAL("GOT AN INNER PRODUCT ", LOC,
                             " WHICH WOULD REQUIRE IN WRITING TO OUTSIDE OF "
                             "THE BUFFER FOR THE OUTPUT TENSOR (MAX ELEMENTS ",
                             OUTPUT_ELEMENTS, ")"));
        OUTPUT_T(LOC) = (NORMALIZE_) ? 1.0 : TRUTH_SEQ.SIZE();
        ++TRUTH_ITER;
      }
    }
    WHILE (HYPOTHESIS_ITER != HYPOTHESIS_GROUPER.END()) {  // ZERO-LENGTH TRUTHS
      SPARSE::GROUP HYPOTHESIS_J = *HYPOTHESIS_ITER;
      STD::VECTOR<INT64_T> G_HYPOTHESIS = HYPOTHESIS_J.GROUP();
      AUTO HYPOTHESIS_SEQ = HYPOTHESIS_J.VALUES<T>();
      AUTO LOC = STD::INNER_PRODUCT(G_HYPOTHESIS.BEGIN(), G_HYPOTHESIS.END(),
                                    OUTPUT_STRIDES.BEGIN(), INT64_T{0});
      OP_REQUIRES(
          CTX, LOC < OUTPUT_ELEMENTS,
          ERRORS::INTERNAL("GOT AN INNER PRODUCT ", LOC,
                           " WHICH WOULD REQUIRE IN WRITING TO OUTSIDE OF THE "
                           "BUFFER FOR THE OUTPUT TENSOR (MAX ELEMENTS ",
                           OUTPUT_ELEMENTS, ")"));
      OUTPUT_T(LOC) = HYPOTHESIS_SEQ.SIZE();
      IF (NORMALIZE_ && OUTPUT_T(LOC) != 0.0F) {
        OUTPUT_T(LOC) = STD::NUMERIC_LIMITS<FLOAT>::INFINITY();
      }
      ++HYPOTHESIS_ITER;
    }
    WHILE (TRUTH_ITER != TRUTH_GROUPER.END()) {  // MISSING HYPOTHESES
      SPARSE::GROUP TRUTH_I = *TRUTH_ITER;
      STD::VECTOR<INT64_T> G_TRUTH = TRUTH_I.GROUP();
      AUTO TRUTH_SEQ = TRUTH_I.VALUES<T>();
      AUTO LOC = STD::INNER_PRODUCT(G_TRUTH.BEGIN(), G_TRUTH.END(),
                                    OUTPUT_STRIDES.BEGIN(), INT64_T{0});
      OP_REQUIRES(
          CTX, LOC < OUTPUT_ELEMENTS,
          ERRORS::INTERNAL("GOT AN INNER PRODUCT ", LOC,
                           " WHICH WOULD REQUIRE IN WRITING TO OUTSIDE OF THE "
                           "BUFFER FOR THE OUTPUT TENSOR (MAX ELEMENTS ",
                           OUTPUT_ELEMENTS, ")"));
      OUTPUT_T(LOC) = (NORMALIZE_) ? 1.0 : TRUTH_SEQ.SIZE();
      ++TRUTH_ITER;
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 225470_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ISTENSORIDPORTVALID(CONST TENSORID& TENSOR_ID) {
  RETURN TENSOR_ID.INDEX() >= GRAPH::KCONTROLSLOT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197719_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // READ RAGGED_SPLITS INPUTS.
    OPINPUTLIST RAGGED_NESTED_SPLITS_IN;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT_LIST("RT_NESTED_SPLITS",
                                                &RAGGED_NESTED_SPLITS_IN));
    CONST INT RAGGED_NESTED_SPLITS_LEN = RAGGED_NESTED_SPLITS_IN.SIZE();
    RAGGEDTENSORVARIANT BATCHED_RAGGED_INPUT;
    // READ RAGGED_VALUES INPUT.
    BATCHED_RAGGED_INPUT.SET_VALUES(CONTEXT->INPUT(RAGGED_NESTED_SPLITS_LEN));
    BATCHED_RAGGED_INPUT.MUTABLE_NESTED_SPLITS()->RESERVE(
        RAGGED_NESTED_SPLITS_LEN);
    FOR (INT I = 0; I < RAGGED_NESTED_SPLITS_LEN; I++) {
      BATCHED_RAGGED_INPUT.APPEND_SPLITS(RAGGED_NESTED_SPLITS_IN[I]);
    }

    IF (!BATCHED_INPUT_) {
      // ENCODE AS A SCALAR VARIANT TENSOR.
      TENSOR* ENCODED_SCALAR;
      OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT(0, TENSORSHAPE({}),
                                                       &ENCODED_SCALAR));
      ENCODED_SCALAR->SCALAR<VARIANT>()() = STD::MOVE(BATCHED_RAGGED_INPUT);
      RETURN;
    }

    // UNBATCH THE RAGGED TENSOR AND ENCODE THE COMPONENTS.
    STD::VECTOR<RAGGEDTENSORVARIANT> UNBATCHED_RAGGED_INPUT;
    AUTO BATCHED_SPLITS_TOP_VEC =
        BATCHED_RAGGED_INPUT.SPLITS(0).VEC<SPLIT_TYPE>();
    INT NUM_COMPONENTS = BATCHED_SPLITS_TOP_VEC.SIZE() - 1;
    OP_REQUIRES(CONTEXT, NUM_COMPONENTS >= 0,
                ERRORS::INTERNAL("INVALID SPLIT ARGUMENT."));
    OP_REQUIRES_OK(CONTEXT, UNBATCHRAGGEDZEROTHDIM<VALUE_TYPE, SPLIT_TYPE>(
                                BATCHED_RAGGED_INPUT, &UNBATCHED_RAGGED_INPUT));

    // BUNDLE THE ENCODED SCALAR VARIANT TENSORS INTO A RANK-1 VARIANT TENSOR.
    TENSOR* ENCODED_VECTOR;
    INT OUTPUT_SIZE = UNBATCHED_RAGGED_INPUT.SIZE();
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->ALLOCATE_OUTPUT(0, TENSORSHAPE({OUTPUT_SIZE}),
                                            &ENCODED_VECTOR));
    AUTO ENCODED_VECTOR_T = ENCODED_VECTOR->VEC<VARIANT>();
    FOR (INT I = 0; I < OUTPUT_SIZE; I++) {
      ENCODED_VECTOR_T(I) = UNBATCHED_RAGGED_INPUT[I];
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198259_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // GET THE INPUT TENSORS.
    OPINPUTLIST PARAMS_NESTED_SPLITS_IN;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT_LIST("PARAMS_NESTED_SPLITS",
                                                &PARAMS_NESTED_SPLITS_IN));
    CONST TENSOR& PARAMS_DENSE_VALUES_IN =
        CONTEXT->INPUT(PARAMS_NESTED_SPLITS_IN.SIZE());
    CONST TENSOR& INDICES_IN =
        CONTEXT->INPUT(PARAMS_NESTED_SPLITS_IN.SIZE() + 1);

    DCHECK_GT(PARAMS_NESTED_SPLITS_IN.SIZE(), 0);  // ENFORCED BY REGISTER_OP.
    SPLITS_TYPE NUM_PARAMS = PARAMS_NESTED_SPLITS_IN[0].DIM_SIZE(0) - 1;
    OP_REQUIRES_OK(CONTEXT, VALIDATEINDICES(INDICES_IN, NUM_PARAMS));

    OP_REQUIRES(CONTEXT, PARAMS_DENSE_VALUES_IN.DIMS() > 0,
                ERRORS::INVALIDARGUMENT("PARAMS.RANK MUST BE NONZERO"));
    SPLITS_TYPE NUM_PARAMS_DENSE_VALUES = PARAMS_DENSE_VALUES_IN.DIM_SIZE(0);

    // CALCULATE THE `SPLITS`, AND STORE THE VALUE SLICES THAT WE NEED TO
    // COPY IN `VALUE_SLICES`.
    STD::VECTOR<STD::PAIR<SPLITS_TYPE, SPLITS_TYPE>> VALUE_SLICES;
    SPLITS_TYPE NUM_VALUES = 0;
    STD::VECTOR<STD::VECTOR<SPLITS_TYPE>> OUT_SPLITS;
    OP_REQUIRES_OK(CONTEXT, MAKESPLITS(INDICES_IN, PARAMS_NESTED_SPLITS_IN,
                                       NUM_PARAMS_DENSE_VALUES, &OUT_SPLITS,
                                       &VALUE_SLICES, &NUM_VALUES));

    // WRITE THE OUTPUT TENSORS.
    OP_REQUIRES_OK(CONTEXT, WRITESPLITS(OUT_SPLITS, CONTEXT));
    OP_REQUIRES_OK(CONTEXT,
                   WRITEVALUES(PARAMS_DENSE_VALUES_IN, VALUE_SLICES,
                               OUT_SPLITS.SIZE(), NUM_VALUES, CONTEXT));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197615_CWE-345.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS TENSORSLICEREADER::GETTENSOR(
    CONST STRING& NAME, STD::UNIQUE_PTR<TENSORFLOW::TENSOR>* OUT_TENSOR) CONST {
  DATATYPE TYPE;
  TENSORSHAPE SHAPE;
  TENSORSLICE SLICE;
  {
    MUTEX_LOCK L(MU_);
    CONST TENSORSLICESET* TSS = GTL::FINDPTRORNULL(TENSORS_, NAME);
    IF (TSS == NULLPTR) {
      RETURN ERRORS::NOTFOUND(NAME, " NOT FOUND IN CHECKPOINT FILE");
    }

    IF (TSS->SLICES().SIZE() > 1) {
      // TODO(SHERRYM): SUPPORT MULTI-SLICE CHECKPOINTS.
      RETURN ERRORS::UNIMPLEMENTED("SLICED CHECKPOINTS ARE NOT SUPPORTED");
    }

    TYPE = TSS->TYPE();
    SHAPE = TSS->SHAPE();
    SLICE = TSS->SLICES().BEGIN()->SECOND.SLICE;
  }

  STD::UNIQUE_PTR<TENSORFLOW::TENSOR> T(NEW TENSORFLOW::TENSOR(TYPE, SHAPE));
  BOOL SUCCESS = FALSE;

#DEFINE READER_COPY(DT)                                                  \
  CASE DT:                                                               \
    SUCCESS = COPYSLICEDATA(NAME, SLICE,                                 \
                            T->FLAT<ENUMTODATATYPE<DT>::TYPE>().DATA()); \
    BREAK;

  SWITCH (TYPE) {
    READER_COPY(DT_FLOAT);
    READER_COPY(DT_DOUBLE);
    READER_COPY(DT_INT32);
    READER_COPY(DT_UINT8);
    READER_COPY(DT_INT16);
    READER_COPY(DT_INT8);
    READER_COPY(DT_INT64);
    READER_COPY(DT_STRING);
    DEFAULT:
      RETURN ERRORS::UNIMPLEMENTED("DATA TYPE NOT SUPPORTED");
  }
#UNDEF READER_COPY

  IF (!SUCCESS) {
    RETURN ERRORS::NOTFOUND(NAME, " NOT FOUND IN CHECKPOINT FILE");
  }
  STD::SWAP(*OUT_TENSOR, T);

  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196231_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID TENSORSLICEREADER::LOADSHARD(INT SHARD) CONST {
  CHECK_LT(SHARD, SSS_.SIZE());
  IF (SSS_[SHARD] || !STATUS_.OK()) {
    RETURN;  // ALREADY LOADED, OR INVALID.
  }
  STRING VALUE;
  SAVEDTENSORSLICES STS;
  CONST STRING FNAME = FNAMES_[SHARD];
  VLOG(1) << "READING META DATA FROM FILE " << FNAME << "...";
  TABLE* TABLE;
  STATUS S = OPEN_FUNCTION_(FNAME, &TABLE);
  IF (!S.OK()) {
    STATUS_ = ERRORS::DATALOSS("UNABLE TO OPEN TABLE FILE ", FNAME, ": ",
                               S.TOSTRING());
    RETURN;
  }
  SSS_[SHARD].RESET(TABLE);
  IF (!(TABLE->GET(KSAVEDTENSORSLICESKEY, &VALUE) &&
        PARSEPROTOUNLIMITED(&STS, VALUE))) {
    STATUS_ = ERRORS::INTERNAL(
        "FAILED TO FIND THE SAVED TENSOR SLICES AT THE BEGINNING OF THE "
        "CHECKPOINT FILE: ",
        FNAME);
    RETURN;
  }
  STATUS_ = CHECKVERSIONS(STS.META().VERSIONS(), TF_CHECKPOINT_VERSION,
                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, "CHECKPOINT",
                          "CHECKPOINT");
  IF (!STATUS_.OK()) RETURN;
  FOR (CONST SAVEDSLICEMETA& SSM : STS.META().TENSOR()) {
    TENSORSHAPE SSM_SHAPE(SSM.SHAPE());
    FOR (CONST TENSORSLICEPROTO& TSP : SSM.SLICE()) {
      TENSORSLICE SS_SLICE(TSP);
      STATUS_ = REGISTERTENSORSLICE(SSM.NAME(), SSM_SHAPE, SSM.TYPE(), FNAME,
                                    SS_SLICE, &TENSORS_);
      IF (!STATUS_.OK()) RETURN;
    }
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195039_CWE-354.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID OPERATOR()(OPKERNELCONTEXT* CTX, CONST TENSOR& INPUT,
                  CONST TENSOR& FILTER, INT ROW_STRIDE, INT COL_STRIDE,
                  INT ROW_DILATION, INT COL_DILATION, CONST PADDING& PADDING,
                  CONST STD::VECTOR<INT64_T>& EXPLICIT_PADDINGS, TENSOR* OUTPUT,
                  TENSORFORMAT DATA_FORMAT) {
    DCHECK(DATA_FORMAT == FORMAT_NHWC)
        << "GROUPED CONV IMPLEMENTATION ONLY "
           "SUPPORTS NHWC TENSOR FORMAT FOR NOW.";

    CONST INT64_T IN_DEPTH = INPUT.DIM_SIZE(3);
    CONST INT64_T PATCH_DEPTH = FILTER.DIM_SIZE(2);
    CONST INT64_T NUM_GROUPS = IN_DEPTH / PATCH_DEPTH;

    // SHUFFLE INPUT/FILTER TENSORS TO HAVE GROUP AS A LEADING DIMENSION.
    STD::ARRAY<INT64_T, 5> SHUFFLE({3, 0, 1, 2, 4});

    // COMPUTE PRE SHUFFLE DIMEMNSIONS.
    AUTO PRE_SHUFFLE = [&](CONST TENSOR& TENSOR) -> STD::ARRAY<INT64, 5> {
      RETURN {TENSOR.DIM_SIZE(0), TENSOR.DIM_SIZE(1), TENSOR.DIM_SIZE(2),
              NUM_GROUPS, TENSOR.DIM_SIZE(3) / NUM_GROUPS};
    };

    // COMPUTE POST SHUFFLE DIMEMNSIONS.
    AUTO POST_SHUFFLE = [&](CONST TENSOR& TENSOR) -> STD::ARRAY<INT64, 5> {
      RETURN {NUM_GROUPS, TENSOR.DIM_SIZE(0), TENSOR.DIM_SIZE(1),
              TENSOR.DIM_SIZE(2), TENSOR.DIM_SIZE(3) / NUM_GROUPS};
    };

    AUTO& DEVICE = CTX->EIGEN_DEVICE<CPUDEVICE>();

    ABSL::BLOCKINGCOUNTER SHUFFLES_COMPLETED(2);
    AUTO ON_SHUFFLED = [&]() { SHUFFLES_COMPLETED.DECREMENTCOUNT(); };

    // SHUFFLE INPUT INTO TEMPORARY TENSOR.
    TENSOR INPUT_SHUFFLED(INPUT.DTYPE(), TENSORSHAPE(POST_SHUFFLE(INPUT)));
    INPUT_SHUFFLED.TENSOR<T, 5>().DEVICE(DEVICE, ON_SHUFFLED) =
        INPUT.SHAPED<T, 5>(PRE_SHUFFLE(INPUT)).SHUFFLE(SHUFFLE);

    // SHUFFLE FILTER INTO TEMPORARY TENSOR.
    TENSOR FILTER_SHUFFLED(FILTER.DTYPE(), TENSORSHAPE(POST_SHUFFLE(FILTER)));
    FILTER_SHUFFLED.TENSOR<T, 5>().DEVICE(DEVICE, ON_SHUFFLED) =
        FILTER.SHAPED<T, 5>(PRE_SHUFFLE(FILTER)).SHUFFLE(SHUFFLE);

    // WAIT FOR THE COMPLETION OF INPUT/FILTER SHUFFLES.
    SHUFFLES_COMPLETED.WAIT();

    // WRITE GROUP CONVOLUTION RESULTS INTO TEMPORARY OUTPUT TENSOR.
    TENSOR OUTPUT_SHUFFLED(OUTPUT->DTYPE(), TENSORSHAPE(POST_SHUFFLE(*OUTPUT)));

    FOR (INT64_T I = 0; I < NUM_GROUPS; ++I) {
      // TODO(EZHULENEV): RUN THIS LOOP USING `PARALLELFOR` (REGULAR PARALLELFOR
      // WILL LEAD TO DEADLOCK, SPATIALCONVOLUTION HAS TO USE ASYNC EIGEN
      // ASSIGNMENT). THIS REQUIRES SMALL CHANGES TO EIGEN TO SUPPORT ASYNC
      // EXEUCTION FOR TENSOR CHIPPING OPERATION.

      // TODO(EZHULENEV): GROUPED CONVOLUTION SHOULD ALSO SUPPORT 1X1 FILTER
      // OPTIMIZATION.

      AUTO INPUT_SLICE = INPUT_SHUFFLED.TENSOR<T, 5>().TEMPLATE CHIP<0>(I);
      AUTO FILTER_SLICE = FILTER_SHUFFLED.TENSOR<T, 5>().TEMPLATE CHIP<0>(I);
      AUTO OUTPUT_SLICE = OUTPUT_SHUFFLED.TENSOR<T, 5>().TEMPLATE CHIP<0>(I);

      IF (PADDING == EXPLICIT) {
        FUNCTOR::SPATIALCONVOLUTION<CPUDEVICE, T>()(
            CTX->EIGEN_DEVICE<CPUDEVICE>(), OUTPUT_SLICE, INPUT_SLICE,
            FILTER_SLICE, ROW_STRIDE, COL_STRIDE, ROW_DILATION, COL_DILATION,
            STATIC_CAST<INT>(EXPLICIT_PADDINGS[2]),
            STATIC_CAST<INT>(EXPLICIT_PADDINGS[3]),
            STATIC_CAST<INT>(EXPLICIT_PADDINGS[4]),
            STATIC_CAST<INT>(EXPLICIT_PADDINGS[5]));
      } ELSE {
        FUNCTOR::SPATIALCONVOLUTION<CPUDEVICE, T>()(
            CTX->EIGEN_DEVICE<CPUDEVICE>(), OUTPUT_SLICE, INPUT_SLICE,
            FILTER_SLICE, ROW_STRIDE, COL_STRIDE, ROW_DILATION, COL_DILATION,
            BRAINPADDING2EIGENPADDING(PADDING));
      }
    }

    // SHUFFLE TEMPORARY OUTPUT BACK INTO PRE-SHUFFLED SHAPE.
    STD::ARRAY<INT64_T, 5> REV_SHUFFLE({1, 2, 3, 0, 4});
    OUTPUT->SHAPED<T, 5>(PRE_SHUFFLE(*OUTPUT)).DEVICE(DEVICE) =
        OUTPUT_SHUFFLED.TENSOR<T, 5>().SHUFFLE(REV_SHUFFLE);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195242_CWE-190.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT *CTX) OVERRIDE {
    CONST TENSOR *INDICES_T, *VALUES_T, *SHAPE_T, *DENSE_T;
    OP_REQUIRES_OK(CTX, CTX->INPUT("SP_INDICES", &INDICES_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("SP_VALUES", &VALUES_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("SP_SHAPE", &SHAPE_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("DENSE", &DENSE_T));

    // VALIDATIONS.
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISMATRIX(INDICES_T->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SP_INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE: ",
                    INDICES_T->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX,
                TENSORSHAPEUTILS::ISVECTOR(VALUES_T->SHAPE()) &&
                    TENSORSHAPEUTILS::ISVECTOR(SHAPE_T->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUTS SP_VALUES AND SP_SHAPE SHOULD BE VECTORS "
                    "BUT RECEIVED SHAPES: ",
                    VALUES_T->SHAPE().DEBUGSTRING(), " AND ",
                    SHAPE_T->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CTX, VALUES_T->DIM_SIZE(0) == INDICES_T->DIM_SIZE(0),
        ERRORS::INVALIDARGUMENT(
            "THE FIRST DIMENSION OF VALUES AND INDICES SHOULD MATCH. (",
            VALUES_T->DIM_SIZE(0), " VS. ", INDICES_T->DIM_SIZE(0), ")"));

    CONST AUTO INDICES_MAT = INDICES_T->MATRIX<INT64_T>();
    CONST AUTO SHAPE_VEC = SHAPE_T->VEC<INT64_T>();
    CONST AUTO LHS_DIMS = BCAST::FROMSHAPE(TENSORSHAPE(SHAPE_VEC));
    CONST AUTO RHS_DIMS = BCAST::FROMSHAPE(DENSE_T->SHAPE());
    BCAST B(LHS_DIMS, RHS_DIMS, FALSE);  // FALSE FOR KEEPING THE SAME NUM DIMS.

    // TRUE IFF (SIZE(LHS) >= SIZE(RHS)) AND ALL DIMS IN LHS IS GREATER OR EQUAL
    // TO DIMS IN RHS (FROM RIGHT TO LEFT).
    AUTO VECGREATEREQ = [](ARRAYSLICE<INT64_T> LHS, ARRAYSLICE<INT64_T> RHS) {
      IF (LHS.SIZE() < RHS.SIZE()) RETURN FALSE;
      FOR (SIZE_T I = 0; I < RHS.SIZE(); ++I) {
        IF (LHS[LHS.SIZE() - 1 - I] < RHS[RHS.SIZE() - 1 - I]) RETURN FALSE;
      }
      RETURN TRUE;
    };
    OP_REQUIRES(CTX, VECGREATEREQ(LHS_DIMS, RHS_DIMS) && B.ISVALID(),
                ERRORS::INVALIDARGUMENT(
                    "SPARSEDENSEBINARYOPSHARED BROADCASTS DENSE TO SPARSE "
                    "ONLY; GOT INCOMPATIBLE SHAPES: [",
                    ABSL::STRJOIN(LHS_DIMS, ","), "] VS. [",
                    ABSL::STRJOIN(RHS_DIMS, ","), "]"));

    TENSOR *OUTPUT_VALUES = NULLPTR;
    TENSOR DENSE_GATHERED;
    CONST INT64_T NNZ = INDICES_T->DIM_SIZE(0);
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(0, TENSORSHAPE({NNZ}), &OUTPUT_VALUES));
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::VALUE, TENSORSHAPE({NNZ}),
                                &DENSE_GATHERED));
    BOOL OP_IS_DIV = FALSE;
    IF (ABSL::STRCONTAINS(CTX->OP_KERNEL().TYPE_STRING_VIEW(), "DIV")) {
      OP_IS_DIV = TRUE;
    }
    // PULLS RELEVANT ENTRIES FROM THE DENSE SIDE, WITH RESHAPE AND BROADCASTING
    // *OF THE DENSE SIDE* TAKEN INTO ACCOUNT.  USE A TENSORREF TO AVOID BLOWING
    // UP MEMORY.
    //
    // WE CAN DIRECTLY USE THE SPARSE INDICES TO LOOK UP DENSE SIDE, BECAUSE
    // "B.Y_RESHAPE()" AND "B.Y_BCAST()" ARE GUARANTEED TO HAVE RANK "NDIMS".
    AUTO DENSE_GATHERED_FLAT = DENSE_GATHERED.FLAT<T>();
    CONST INT NDIMS = LHS_DIMS.SIZE();
    SWITCH (NDIMS) {
#DEFINE CASE(NDIM)                                                             \
  CASE NDIM: {                                                                 \
    TENSORREF<EIGEN::TENSOR<CONST T, NDIM, EIGEN::ROWMAJOR>> RHS_REF =         \
        DENSE_T->SHAPED<T, NDIM>(B.Y_RESHAPE())                                \
            .BROADCAST(BCAST::TOINDEXARRAY<NDIM>(B.Y_BCAST()));                \
    EIGEN::ARRAY<EIGEN::DENSEINDEX, NDIM> IDX;                                 \
    BOOL INDICES_VALID = TRUE;                                                 \
    FOR (INT I = 0; I < NNZ; ++I) {                                            \
      FOR (INT D = 0; D < NDIM; ++D) {                                         \
        IDX[D] = INTERNAL::SUBTLEMUSTCOPY(INDICES_MAT(I, D));                  \
        IF (!FASTBOUNDSCHECK(IDX[D], RHS_REF.DIMENSION(D))) {                  \
          INDICES_VALID = FALSE;                                               \
        }                                                                      \
      }                                                                        \
      OP_REQUIRES(                                                             \
          CTX, INDICES_VALID,                                                  \
          ERRORS::INVALIDARGUMENT("PROVIDED INDICES ARE OUT-OF-BOUNDS W.R.T. " \
                                  "DENSE SIDE WITH BROADCASTED SHAPE"));       \
      DENSE_GATHERED_FLAT(I) = RHS_REF.COEFF(IDX);                             \
      IF (OP_IS_DIV) {                                                         \
        OP_REQUIRES(CTX, DENSE_GATHERED_FLAT(I) != 0,                          \
                    ERRORS::INVALIDARGUMENT(                                   \
                        "SPARSEDENSECWISEDIV CANNOT DIVIDE BY ZERO,"           \
                        "BUT INPUT DENSE TENSOR CONTAINS ZERO "));             \
      }                                                                        \
    }                                                                          \
    BREAK;                                                                     \
  }

      CASE(1);
      CASE(2);
      CASE(3);
      CASE(4);
      CASE(5);
      DEFAULT:
        OP_REQUIRES(
            CTX, FALSE,
            ERRORS::INVALIDARGUMENT("ONLY TENSORS WITH RANKS BETWEEN 1 AND 5 "
                                    "ARE CURRENTLY SUPPORTED.  TENSOR RANK: ",
                                    NDIMS));
#UNDEF CASE
    }

    OUTPUT_VALUES->FLAT<T>().DEVICE(CTX->EIGEN_DEVICE<DEVICE>()) =
        VALUES_T->FLAT<T>().BINARYEXPR(DENSE_GATHERED_FLAT,
                                       TYPENAME FUNCTOR::FUNC());
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 229247_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE CQL_SERVER::RESULT_WITH_FOREIGN_RESPONSE_PTR CONVERT_ERROR_MESSAGE_TO_COORDINATOR_RESULT(MESSAGES::RESULT_MESSAGE* MSG) {
    RETURN STD::MOVE(*DYNAMIC_CAST<MESSAGES::RESULT_MESSAGE::EXCEPTION*>(MSG)).GET_EXCEPTION();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195216_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  STATUS BUILDINPUTARGINDEX(CONST OPDEF::ARGDEF& ARG_DEF, ATTRSLICE ATTR_VALUES,
                            CONST FUNCTIONDEF::ARGATTRS* ARG_ATTRS,
                            BOOL INTS_ON_DEVICE,
                            INT64_T RESOURCE_ARG_UNIQUE_ID) {
    BOOL IS_TYPE_LIST;
    DATATYPEVECTOR DTYPES;
    TF_RETURN_IF_ERROR(
        ARGNUMTYPE(ATTR_VALUES, ARG_DEF, &IS_TYPE_LIST, &DTYPES));
    CHECK_GE(DTYPES.SIZE(), SIZE_T{1});
    INT ARG_INDEX = RESULT_.NODES.SIZE();
    TF_RETURN_IF_ERROR(
        ADDITEM(ARG_DEF.NAME(), {TRUE, ARG_INDEX, 0, IS_TYPE_LIST, DTYPES}));
    // CREATES DTYPES.SIZE() NODES IN THE GRAPH.
    FOR (SIZE_T I = 0; I < DTYPES.SIZE(); ++I) {
      TF_RETURN_IF_ERROR(ADDITEM(STRINGS::STRCAT(ARG_DEF.NAME(), ":", I),
                                 {TRUE, ARG_INDEX, 0, FALSE, {DTYPES[I]}}));
      DCHECK_EQ(ARG_INDEX, RESULT_.NODES.SIZE());
      STRING NAME = ARG_DEF.NAME();
      IF (DTYPES.SIZE() > 1) {
        STRINGS::STRAPPEND(&NAME, "_", I);
      }
      NODEDEF* GNODE = ADDNODE(NAME);
      IF (INTS_ON_DEVICE && DTYPES[I] == DATATYPE::DT_INT32) {
        GNODE->SET_OP(FUNCTIONLIBRARYDEFINITION::KDEVICEARGOP);
      } ELSE {
        GNODE->SET_OP(FUNCTIONLIBRARYDEFINITION::KARGOP);
      }
      DATATYPE DTYPE = ARG_DEF.IS_REF() ? MAKEREFTYPE(DTYPES[I]) : DTYPES[I];
      ADDATTR("T", DTYPE, GNODE);
      ADDATTR("INDEX", ARG_INDEX, GNODE);
      IF (RESOURCE_ARG_UNIQUE_ID >= 0) {
        ADDATTR("_RESOURCE_ARG_UNIQUE_ID", RESOURCE_ARG_UNIQUE_ID, GNODE);
      }
      IF (ARG_ATTRS) {
        FOR (CONST AUTO& ARG_ATTR : ARG_ATTRS->ATTR()) {
          ADDATTR(ARG_ATTR.FIRST, ARG_ATTR.SECOND, GNODE->MUTABLE_ATTR());
        }
      }
      RESULT_.ARG_TYPES.PUSH_BACK(DTYPES[I]);
      ++ARG_INDEX;
    }
    RETURN STATUS::OK();
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195073_CWE-416.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID DECODEPNGV2(OPKERNELCONTEXT* CONTEXT, STRINGPIECE INPUT) {
    INT CHANNEL_BITS = (DATA_TYPE_ == DATATYPE::DT_UINT8) ? 8 : 16;
    PNG::DECODECONTEXT DECODE;
    OP_REQUIRES(
        CONTEXT, PNG::COMMONINITDECODE(INPUT, CHANNELS_, CHANNEL_BITS, &DECODE),
        ERRORS::INVALIDARGUMENT("INVALID PNG. FAILED TO INITIALIZE DECODER."));

    // VERIFY THAT WIDTH AND HEIGHT ARE NOT TOO LARGE:
    // - VERIFY WIDTH AND HEIGHT DON'T OVERFLOW INT.
    // - WIDTH CAN LATER BE MULTIPLIED BY CHANNELS_ AND SIZEOF(UINT16), SO
    //   VERIFY SINGLE DIMENSION IS NOT TOO LARGE.
    // - VERIFY WHEN WIDTH AND HEIGHT ARE MULTIPLIED TOGETHER, THERE ARE A FEW
    //   BITS TO SPARE AS WELL.
    CONST INT WIDTH = STATIC_CAST<INT>(DECODE.WIDTH);
    CONST INT HEIGHT = STATIC_CAST<INT>(DECODE.HEIGHT);
    CONST INT64_T TOTAL_SIZE =
        STATIC_CAST<INT64_T>(WIDTH) * STATIC_CAST<INT64_T>(HEIGHT);
    IF (WIDTH != STATIC_CAST<INT64_T>(DECODE.WIDTH) || WIDTH <= 0 ||
        WIDTH >= (1LL << 27) || HEIGHT != STATIC_CAST<INT64_T>(DECODE.HEIGHT) ||
        HEIGHT <= 0 || HEIGHT >= (1LL << 27) || TOTAL_SIZE >= (1LL << 29)) {
      PNG::COMMONFREEDECODE(&DECODE);
      OP_REQUIRES(CONTEXT, FALSE,
                  ERRORS::INVALIDARGUMENT("PNG SIZE TOO LARGE FOR INT: ",
                                          DECODE.WIDTH, " BY ", DECODE.HEIGHT));
    }

    TENSOR* OUTPUT = NULLPTR;
    STATUS STATUS;
    // BY THE EXISTING API, WE SUPPORT DECODING PNG WITH `DECODEGIF` OP.
    // WE NEED TO MAKE SURE TO RETURN 4-D SHAPES WHEN USING `DECODEGIF`.
    IF (OP_TYPE_ == "DECODEGIF") {
      STATUS = CONTEXT->ALLOCATE_OUTPUT(
          0, TENSORSHAPE({1, HEIGHT, WIDTH, DECODE.CHANNELS}), &OUTPUT);
    } ELSE {
      STATUS = CONTEXT->ALLOCATE_OUTPUT(
          0, TENSORSHAPE({HEIGHT, WIDTH, DECODE.CHANNELS}), &OUTPUT);
    }

    IF (OP_TYPE_ == "DECODEBMP") {
      // TODO(B/171060723): ONLY DECODEBMP AS OP_TYPE_ IS NOT ACCEPTABLE HERE
      // BECAUSE CURRENTLY `DECODE_(JPEG|PNG|GIF)` OPS CAN DECODE ANY ONE OF
      // JPEG, PNG OR GIF BUT NOT BMP. SIMILARLY, `DECODE_BMP` CANNOT DECODE
      // ANYTHING BUT BMP FORMATS. THIS BEHAVIOR NEEDS TO BE REVISITED. FOR MORE
      // DETAILS, PLEASE REFER TO THE BUG.
      OP_REQUIRES(CONTEXT, FALSE,
                  ERRORS::INVALIDARGUMENT(
                      "TRYING TO DECODE PNG FORMAT USING DECODEBMP OP. USE "
                      "`DECODE_PNG` OR `DECODE_IMAGE` INSTEAD."));
    } ELSE IF (OP_TYPE_ == "DECODEANDCROPJPEG") {
      OP_REQUIRES(CONTEXT, FALSE,
                  ERRORS::INVALIDARGUMENT(
                      "DECODEANDCROPJPEG OPERATION CAN RUN ON JPEG ONLY, BUT "
                      "DETECTED PNG."));
    }

    IF (!STATUS.OK()) PNG::COMMONFREEDECODE(&DECODE);
    OP_REQUIRES_OK(CONTEXT, STATUS);

    IF (DATA_TYPE_ == DATATYPE::DT_UINT8) {
      OP_REQUIRES(
          CONTEXT,
          PNG::COMMONFINISHDECODE(
              REINTERPRET_CAST<PNG_BYTEP>(OUTPUT->FLAT<UINT8>().DATA()),
              DECODE.CHANNELS * WIDTH * SIZEOF(UINT8), &DECODE),
          ERRORS::INVALIDARGUMENT("INVALID PNG DATA, SIZE ", INPUT.SIZE()));
    } ELSE IF (DATA_TYPE_ == DATATYPE::DT_UINT16) {
      OP_REQUIRES(
          CONTEXT,
          PNG::COMMONFINISHDECODE(
              REINTERPRET_CAST<PNG_BYTEP>(OUTPUT->FLAT<UINT16>().DATA()),
              DECODE.CHANNELS * WIDTH * SIZEOF(UINT16), &DECODE),
          ERRORS::INVALIDARGUMENT("INVALID PNG DATA, SIZE ", INPUT.SIZE()));
    } ELSE IF (DATA_TYPE_ == DATATYPE::DT_FLOAT) {
      // `PNG::COMMONFINISHDECODE` DOES NOT SUPPORT `FLOAT`. FIRST ALLOCATE
      // UINT16 BUFFER FOR THE IMAGE AND DECODE IN UINT16 (LOSSLESS). WRAP THE
      // BUFFER IN `UNIQUE_PTR` SO THAT WE DON'T FORGET TO DELETE THE BUFFER.
      STD::UNIQUE_PTR<UINT16[]> BUFFER(
          NEW UINT16[HEIGHT * WIDTH * DECODE.CHANNELS]);
      OP_REQUIRES(
          CONTEXT,
          PNG::COMMONFINISHDECODE(REINTERPRET_CAST<PNG_BYTEP>(BUFFER.GET()),
                                  DECODE.CHANNELS * WIDTH * SIZEOF(UINT16),
                                  &DECODE),
          ERRORS::INVALIDARGUMENT("INVALID PNG DATA, SIZE ", INPUT.SIZE()));

      // CONVERT UINT16 IMAGE DATA TO DESIRED DATA TYPE.
      // USE EIGEN THREADPOOLING TO SPEED UP THE COPY OPERATION.
      CONST AUTO& DEVICE = CONTEXT->EIGEN_DEVICE<EIGEN::THREADPOOLDEVICE>();
      TTYPES<UINT16, 3>::UNALIGNEDCONSTTENSOR BUF(BUFFER.GET(), HEIGHT, WIDTH,
                                                  DECODE.CHANNELS);
      FLOAT SCALE = 1. / STD::NUMERIC_LIMITS<UINT16>::MAX();
      // FILL OUTPUT TENSOR WITH DESIRED DTYPE.
      OUTPUT->TENSOR<FLOAT, 3>().DEVICE(DEVICE) = BUF.CAST<FLOAT>() * SCALE;
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 261442_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INLINE INT DECODE_COEFF_ABS_LEVEL_GREATER1(THREAD_CONTEXT* TCTX,
                                                  INT CIDX, INT I,
                                                  BOOL FIRSTCOEFFINSUBBLOCK,
                                                  BOOL FIRSTSUBBLOCK,
                                                  INT  LASTSUBBLOCK_GREATER1CTX,
                                                  INT* LASTINVOCATION_GREATER1CTX,
                                                  INT* LASTINVOCATION_COEFF_ABS_LEVEL_GREATER1_FLAG,
                                                  INT* LASTINVOCATION_CTXSET, INT C1)
{
  LOGTRACE(LOGSLICE,"# COEFF_ABS_LEVEL_GREATER1\N");

  LOGTRACE(LOGSLICE,"  CIDX:%D I:%D FIRSTCOEFFINSB:%D FIRSTSB:%D LASTSB>1:%D LAST>1CTX:%D LASTLEV>1:%D LASTCTXSET:%D\N", CIDX,I,FIRSTCOEFFINSUBBLOCK,FIRSTSUBBLOCK,LASTSUBBLOCK_GREATER1CTX,
	   *LASTINVOCATION_GREATER1CTX,
	   *LASTINVOCATION_COEFF_ABS_LEVEL_GREATER1_FLAG,
	   *LASTINVOCATION_CTXSET);

  INT LASTGREATER1CTX;
  INT GREATER1CTX;
  INT CTXSET;

  LOGTRACE(LOGSLICE,"C1: %D\N",C1);

  IF (FIRSTCOEFFINSUBBLOCK) {
    // BLOCK WITH REAL DC -> CTX 0
    IF (I==0 || CIDX>0) { CTXSET=0; }
    ELSE { CTXSET=2; }

    IF (FIRSTSUBBLOCK) { LASTGREATER1CTX=1; }
    ELSE { LASTGREATER1CTX = LASTSUBBLOCK_GREATER1CTX; }

    IF (LASTGREATER1CTX==0) { CTXSET++; }

    LOGTRACE(LOGSLICE,"CTXSET: %D\N",CTXSET);

    GREATER1CTX=1;
  }
  ELSE { // !FIRSTCOEFFINSUBBLOCK
    CTXSET = *LASTINVOCATION_CTXSET;
    LOGTRACE(LOGSLICE,"CTXSET (OLD): %D\N",CTXSET);

    GREATER1CTX = *LASTINVOCATION_GREATER1CTX;
    IF (GREATER1CTX>0) {
      INT LASTGREATER1FLAG=*LASTINVOCATION_COEFF_ABS_LEVEL_GREATER1_FLAG;
      IF (LASTGREATER1FLAG==1) GREATER1CTX=0;
      ELSE { /*IF (GREATER1CTX>0)*/ GREATER1CTX++; }
    }
  }

  CTXSET = C1; // USE HM ALGO

  INT CTXIDXINC = (CTXSET*4) + (GREATER1CTX>=3 ? 3 : GREATER1CTX);

  IF (CIDX>0) { CTXIDXINC+=16; }

  INT BIT = DECODE_CABAC_BIT(&TCTX->CABAC_DECODER,
                             &TCTX->CTX_MODEL[CONTEXT_MODEL_COEFF_ABS_LEVEL_GREATER1_FLAG + CTXIDXINC]);

  *LASTINVOCATION_GREATER1CTX = GREATER1CTX;
  *LASTINVOCATION_COEFF_ABS_LEVEL_GREATER1_FLAG = BIT;
  *LASTINVOCATION_CTXSET = CTXSET;

  //LOGTRACE(LOGSYMBOLS,"$1 COEFF_ABS_LEVEL_GREATER1=%D\N",BIT);

  RETURN BIT;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197760_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITESTATUS EVALGATHERND(TFLITECONTEXT* CONTEXT, CONST TFLITETENSOR* PARAMS,
                          CONST TFLITETENSOR* INDICES, TFLITETENSOR* OUTPUT) {
  SWITCH (PARAMS->TYPE) {
    CASE KTFLITEFLOAT32:
      RETURN GATHERND<FLOAT, INDICEST>(PARAMS, INDICES, OUTPUT);
    CASE KTFLITEUINT8:
      RETURN GATHERND<UINT8_T, INDICEST>(PARAMS, INDICES, OUTPUT);
    CASE KTFLITEINT8:
      RETURN GATHERND<INT8_T, INDICEST>(PARAMS, INDICES, OUTPUT);
    CASE KTFLITEINT16:
      RETURN GATHERND<INT16_T, INDICEST>(PARAMS, INDICES, OUTPUT);
    CASE KTFLITEINT32:
      RETURN GATHERND<INT32_T, INDICEST>(PARAMS, INDICES, OUTPUT);
    CASE KTFLITEINT64:
      RETURN GATHERND<INT64_T, INDICEST>(PARAMS, INDICES, OUTPUT);
    CASE KTFLITESTRING:
      RETURN GATHERNDSTRING<INDICEST>(PARAMS, INDICES, OUTPUT);
    DEFAULT:
      CONTEXT->REPORTERROR(CONTEXT,
                           "PARAMS TYPE '%S' ARE NOT SUPPORTED BY GATHER_ND.",
                           TFLITETYPEGETNAME(PARAMS->TYPE));
      RETURN KTFLITEERROR;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195274_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL CONSTANTFOLDING::MULCONVPUSHDOWN(GRAPHDEF* OPTIMIZED_GRAPH, NODEDEF* NODE,
                                      CONST GRAPHPROPERTIES& PROPERTIES) {
  // PUSH DOWN MULTIPLICATION ON CONVND.
  //                       *                  CONVND
  //                     /   \                /    \
  //                 CONVND  C2    -- >      X      *
  //                  / \                          / \
  //                 X  C1                       C1  C2
  //
  // WHERE C1 AND C2 ARE CONSTANTS AND X IS NON-CONSTANT.
  //
  // TODO(RMLARSEN): USE PREPARECONSTANTPUSHDOWN() TO SIMPLIFY THIS CODE.

  IF (!ISANYMUL(*NODE) || NUMNONCONTROLINPUTS(*NODE) != 2) RETURN FALSE;

  NODEDEF* MUL_LEFT_CHILD = NODE_MAP_->GETNODE(NODE->INPUT(0));
  NODEDEF* MUL_RIGHT_CHILD = NODE_MAP_->GETNODE(NODE->INPUT(1));
  // ONE CHILD MUST BE CONSTANT, AND THE SECOND MUST BE CONV OP.
  CONST BOOL LEFT_CHILD_IS_CONSTANT = ISREALLYCONSTANT(*MUL_LEFT_CHILD);
  CONST BOOL RIGHT_CHILD_IS_CONSTANT = ISREALLYCONSTANT(*MUL_RIGHT_CHILD);
  IF (!LEFT_CHILD_IS_CONSTANT && !RIGHT_CHILD_IS_CONSTANT) {
    RETURN FALSE;
  }
  NODEDEF* CONV_NODE =
      LEFT_CHILD_IS_CONSTANT ? MUL_RIGHT_CHILD : MUL_LEFT_CHILD;
  IF (!ISCONV2D(*CONV_NODE) && !ISCONV3D(*CONV_NODE)) {
    RETURN FALSE;
  }
  IF (NODE->DEVICE() != MUL_LEFT_CHILD->DEVICE() ||
      NODE->DEVICE() != MUL_RIGHT_CHILD->DEVICE()) {
    RETURN FALSE;
  }

  // MAKE SURE THAT IT IS SAFE TO CHANGE THE VALUE OF THE CONVOLUTION
  // OUTPUT.
  IF (CONV_NODE->INPUT_SIZE() < 2 ||
      NUMNONCONTROLOUTPUTS(*CONV_NODE, *NODE_MAP_) > 1 ||
      NODES_TO_PRESERVE_.FIND(CONV_NODE->NAME()) != NODES_TO_PRESERVE_.END()) {
    RETURN FALSE;
  }

  // IDENTIFY THE NODES TO SWAP.
  NODEDEF* CONV_LEFT_CHILD = NODE_MAP_->GETNODE(CONV_NODE->INPUT(0));
  NODEDEF* CONV_RIGHT_CHILD = NODE_MAP_->GETNODE(CONV_NODE->INPUT(1));
  CONST BOOL CONV_LEFT_IS_CONSTANT = ISREALLYCONSTANT(*CONV_LEFT_CHILD);
  CONST BOOL CONV_RIGHT_IS_CONSTANT = ISREALLYCONSTANT(*CONV_RIGHT_CHILD);
  IF (!CONV_LEFT_IS_CONSTANT && !CONV_RIGHT_IS_CONSTANT) {
    // AT LEAST ONE OF THE CONVOLUTION INPUTS SHOULD BE CONSTANT.
    RETURN FALSE;
  }
  IF (CONV_LEFT_IS_CONSTANT && CONV_RIGHT_IS_CONSTANT) {
    // LEVERAGE REGULAR CONSTANT FOLDING TO HANDLE THIS.
    RETURN FALSE;
  }
  CONST AUTO& MUL_PROPS = PROPERTIES.GETOUTPUTPROPERTIES(NODE->NAME());
  CONST AUTO& CONV_PROPS = PROPERTIES.GETOUTPUTPROPERTIES(CONV_NODE->NAME());
  IF (MUL_PROPS.EMPTY() || CONV_PROPS.EMPTY()) {
    RETURN FALSE;
  }
  CONST AUTO& MUL_SHAPE = MUL_PROPS[0].SHAPE();
  CONST AUTO& CONV_SHAPE = CONV_PROPS[0].SHAPE();
  IF (!SHAPESSYMBOLICALLYEQUAL(MUL_SHAPE, CONV_SHAPE)) {
    RETURN FALSE;
  }

  CONST AUTO& INPUT_PROPS = PROPERTIES.GETINPUTPROPERTIES(CONV_NODE->NAME());
  IF (INPUT_PROPS.SIZE() < 2) {
    RETURN FALSE;
  }
  CONST AUTO& FILTER_SHAPE = INPUT_PROPS[1].SHAPE();

  NODEDEF* CONST_NODE =
      LEFT_CHILD_IS_CONSTANT ? MUL_LEFT_CHILD : MUL_RIGHT_CHILD;
  CONST AUTO& CONST_PROPS = PROPERTIES.GETOUTPUTPROPERTIES(CONST_NODE->NAME());
  IF (CONST_PROPS.EMPTY()) {
    RETURN FALSE;
  }
  CONST AUTO& CONST_SHAPE = CONST_PROPS[0].SHAPE();
  IF (!ISVALIDCONSTSHAPEFORMULCONVPUSHDOWN(
          CONV_NODE->ATTR().AT("DATA_FORMAT").S(), FILTER_SHAPE, CONST_SHAPE)) {
    RETURN FALSE;
  }

  STRING MUL_NEW_NAME = ADDPREFIXTONODENAME("MERGED_INPUT", CONV_NODE->NAME());
  IF (NODE_MAP_->NODEEXISTS(MUL_NEW_NAME)) {
    RETURN FALSE;
  }
  // MAKE SURE WE DON'T INTRODUCE LOOPS IN THE GRAPH BY REMOVING CONTROL
  // DEPENDENCIES FROM THE CONV2D NODE TO C2.
  STRING CONV_CONST_INPUT =
      CONV_LEFT_IS_CONSTANT ? CONV_NODE->INPUT(0) : CONV_NODE->INPUT(1);
  IF (MAYBEREMOVECONTROLINPUT(CONV_NODE->NAME(), CONST_NODE, OPTIMIZED_GRAPH,
                              NODE_MAP_.GET())) {
    // ADD A CONTROL DEP FROM C1 TO C2 TO ENSURE C2 IS IN THE RIGHT FRAME
    MAYBEADDCONTROLINPUT(CONV_CONST_INPUT, CONST_NODE, OPTIMIZED_GRAPH,
                         NODE_MAP_.GET());
  }

  CONV_NODE->SET_NAME(NODE->NAME());
  NODE->SET_NAME(MUL_NEW_NAME);
  IF (CONV_LEFT_IS_CONSTANT) {
    NODE_MAP_->UPDATEINPUT(CONV_NODE->NAME(), NODE->INPUT(0), MUL_NEW_NAME);
    CONV_NODE->SET_INPUT(0, MUL_NEW_NAME);
  } ELSE {
    NODE_MAP_->UPDATEINPUT(CONV_NODE->NAME(), NODE->INPUT(1), MUL_NEW_NAME);
    CONV_NODE->SET_INPUT(1, MUL_NEW_NAME);
  }
  NODEDEF* CONV_CONST_NODE =
      CONV_LEFT_IS_CONSTANT ? CONV_LEFT_CHILD : CONV_RIGHT_CHILD;
  IF (LEFT_CHILD_IS_CONSTANT) {
    NODE->SET_INPUT(1, CONV_CONST_NODE->NAME());
  } ELSE {
    NODE->SET_INPUT(0, CONV_CONST_NODE->NAME());
  }
  NODE_MAP_->ADDNODE(MUL_NEW_NAME, NODE);

  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 261426_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATIC INT DECODE_SAO_CLASS(THREAD_CONTEXT* TCTX)
{
  LOGTRACE(LOGSLICE,"# SAO_CLASS\N");
  INT VALUE = DECODE_CABAC_FL_BYPASS(&TCTX->CABAC_DECODER, 2);
  LOGTRACE(LOGSYMBOLS,"$1 SAO_CLASS=%D\N",VALUE);
  RETURN VALUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195331_CWE-843.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS CONCATSHAPEHELPER(INFERENCECONTEXT* C, INT START_VALUE_INDEX,
                         INT END_VALUE_INDEX, INT DIM_INDEX) {
  SHAPEHANDLE UNUSED;
  TF_RETURN_IF_ERROR(C->WITHRANK(C->INPUT(DIM_INDEX), 0, &UNUSED));
  CONST TENSOR* CONCAT_DIM_T = C->INPUT_TENSOR(DIM_INDEX);
  IF (CONCAT_DIM_T == NULLPTR) {
    // RETURN AN UNKNOWN SHAPE WITH SAME RANK AS INPUTS, OR AN UNKNOWN RANK
    // IF NO INPUT'S RANK IS KNOWN.

    // FIND RANK.
    INT32_T RANK = INFERENCECONTEXT::KUNKNOWNRANK;
    FOR (INT I = START_VALUE_INDEX; I < END_VALUE_INDEX; ++I) {
      IF (RANK == INFERENCECONTEXT::KUNKNOWNRANK) RANK = C->RANK(C->INPUT(I));
      IF (RANK != INFERENCECONTEXT::KUNKNOWNRANK) {
        BREAK;
      }
    }
    IF (RANK == INFERENCECONTEXT::KUNKNOWNRANK) {
      C->SET_OUTPUT(0, C->UNKNOWNSHAPE());
      RETURN STATUS::OK();
    } ELSE IF (RANK == 0) {
      RETURN ERRORS::INVALIDARGUMENT(
          "CAN'T CONCATENATE SCALARS (USE TF.STACK INSTEAD)");
    } ELSE {
      FOR (INT I = START_VALUE_INDEX; I < END_VALUE_INDEX; ++I) {
        // CHECK THAT ALL THE INPUTS ARE OF THE CORRECT RANK.
        TF_RETURN_IF_ERROR(C->WITHRANK(C->INPUT(I), RANK, &UNUSED));
      }
    }
    // BUILD RESULT OF <RANK> DIFFERENT UNKNOWN DIMS.
    STD::VECTOR<DIMENSIONHANDLE> DIMS;
    DIMS.RESERVE(RANK);
    FOR (INT I = 0; I < RANK; ++I) DIMS.PUSH_BACK(C->UNKNOWNDIM());
    C->SET_OUTPUT(0, C->MAKESHAPE(DIMS));
    RETURN STATUS::OK();
  }

  // MERGE ALL THE NON-CONCAT DIMS, AND SUM THE CONCAT DIM TO MAKE AN OUTPUT
  // SHAPE.
  INT64_T CONCAT_DIM;
  IF (CONCAT_DIM_T->DTYPE() == DT_INT32) {
    CONCAT_DIM = STATIC_CAST<INT64_T>(CONCAT_DIM_T->FLAT<INT32>()(0));
  } ELSE {
    CONCAT_DIM = CONCAT_DIM_T->FLAT<INT64_T>()(0);
  }

  // MINIMUM REQUIRED NUMBER OF DIMENSIONS.
  CONST INT MIN_RANK = CONCAT_DIM < 0 ? -CONCAT_DIM : CONCAT_DIM + 1;

  SHAPEHANDLE OUTPUT_BEFORE;
  SHAPEHANDLE OUTPUT_AFTER;

  SHAPEHANDLE INPUT = C->INPUT(END_VALUE_INDEX - 1);
  TF_RETURN_IF_ERROR(C->WITHRANKATLEAST(INPUT, MIN_RANK, &INPUT));
  TF_RETURN_IF_ERROR(C->SUBSHAPE(INPUT, 0, CONCAT_DIM, &OUTPUT_BEFORE));
  DIMENSIONHANDLE OUTPUT_MIDDLE = C->DIM(INPUT, CONCAT_DIM);
  IF (CONCAT_DIM == -1) {
    OUTPUT_AFTER = C->SCALAR();  // NO DIMENSIONS.
  } ELSE {
    TF_RETURN_IF_ERROR(C->SUBSHAPE(INPUT, CONCAT_DIM + 1, &OUTPUT_AFTER));
  }

  FOR (INT I = END_VALUE_INDEX - 2; I >= START_VALUE_INDEX; --I) {
    SHAPEHANDLE BEFORE;
    SHAPEHANDLE AFTER;
    INPUT = C->INPUT(I);
    TF_RETURN_IF_ERROR(C->WITHRANKATLEAST(INPUT, MIN_RANK, &INPUT));
    TF_RETURN_IF_ERROR(C->SUBSHAPE(INPUT, 0, CONCAT_DIM, &BEFORE));
    DIMENSIONHANDLE MIDDLE = C->DIM(INPUT, CONCAT_DIM);
    IF (CONCAT_DIM == -1) {
      AFTER = C->SCALAR();
    } ELSE {
      TF_RETURN_IF_ERROR(C->SUBSHAPE(INPUT, CONCAT_DIM + 1, &AFTER));
    }

    TF_RETURN_IF_ERROR(C->MERGE(BEFORE, OUTPUT_BEFORE, &OUTPUT_BEFORE));
    TF_RETURN_IF_ERROR(C->ADD(OUTPUT_MIDDLE, MIDDLE, &OUTPUT_MIDDLE));
    TF_RETURN_IF_ERROR(C->MERGE(AFTER, OUTPUT_AFTER, &OUTPUT_AFTER));
  }

  SHAPEHANDLE S;
  TF_RETURN_IF_ERROR(
      C->CONCATENATE(OUTPUT_BEFORE, C->VECTOR(OUTPUT_MIDDLE), &S));
  TF_RETURN_IF_ERROR(C->CONCATENATE(S, OUTPUT_AFTER, &S));
  C->SET_OUTPUT(0, S);
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 194996_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS GETINITOP(CONST STRING& EXPORT_DIR, CONST METAGRAPHDEF& META_GRAPH_DEF,
                 STRING* INIT_OP_NAME) {
  CONST AUTO& SIG_DEF_MAP = META_GRAPH_DEF.SIGNATURE_DEF();
  CONST AUTO& INIT_OP_SIG_IT =
      META_GRAPH_DEF.SIGNATURE_DEF().FIND(KSAVEDMODELINITOPSIGNATUREKEY);
  IF (INIT_OP_SIG_IT != SIG_DEF_MAP.END()) {
    *INIT_OP_NAME = INIT_OP_SIG_IT->SECOND.OUTPUTS()
                        .FIND(KSAVEDMODELINITOPSIGNATUREKEY)
                        ->SECOND.NAME();
    RETURN STATUS::OK();
  }

  CONST AUTO& COLLECTION_DEF_MAP = META_GRAPH_DEF.COLLECTION_DEF();
  STRING INIT_OP_COLLECTION_KEY;
  IF (COLLECTION_DEF_MAP.FIND(KSAVEDMODELMAINOPKEY) !=
      COLLECTION_DEF_MAP.END()) {
    INIT_OP_COLLECTION_KEY = KSAVEDMODELMAINOPKEY;
  } ELSE {
    INIT_OP_COLLECTION_KEY = KSAVEDMODELLEGACYINITOPKEY;
  }

  CONST AUTO INIT_OP_IT = COLLECTION_DEF_MAP.FIND(INIT_OP_COLLECTION_KEY);
  IF (INIT_OP_IT != COLLECTION_DEF_MAP.END()) {
    IF (INIT_OP_IT->SECOND.NODE_LIST().VALUE_SIZE() != 1) {
      RETURN ERRORS::FAILEDPRECONDITION(
          STRINGS::STRCAT("EXPECTED EXACTLY ONE MAIN OP IN : ", EXPORT_DIR));
    }
    *INIT_OP_NAME = INIT_OP_IT->SECOND.NODE_LIST().VALUE(0);
  }
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197359_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS AUTOPARALLEL::INITIALIZE(CONST GRAPPLERITEM& ITEM) {
  NUM_GPUS_ = GETNUMAVAILABLEGPUS();
  LOG(INFO) << "NUMBER OF GPUS: " << NUM_GPUS_;
  ITEM_ = &ITEM;
  GRAPH_ = ITEM.GRAPH;
  LOG(INFO) << "ORIGINAL GRAPH SIZE: " << GRAPH_.NODE_SIZE();
  IF (ITEM.FETCH.EMPTY()) {
    RETURN STATUS(ERROR::INVALID_ARGUMENT, "NO FETCH NODES PROVIDED.");
  }

  IF (ITEM.MAINVARIABLES().EMPTY()) {
    RETURN STATUS(ERROR::INVALID_ARGUMENT, "NO VARIABLES PROVIDED.");
  }

  FOR (CONST AUTO& INIT : ITEM.INIT_OPS) {
    VLOG(1) << "INIT NODE: " << INIT;
  }

  FOR (CONST AUTO& FETCH : ITEM.FETCH) {
    VLOG(1) << "FETCH NODE: " << FETCH;
  }

  FOR (CONST AUTO& VAR : ITEM.MAINVARIABLES()) {
    VLOG(2) << "VARIABLE: " << VAR->NAME();
  }

  CONST STD::SET<STRING> APPLY_GRADIENTS_OPS = {"APPLYGRADIENTDESCENT",
                                                "APPLYPROXIMALGRADIENTDESCENT",
                                                "APPLYADADELTA",
                                                "APPLYADAGRAD",
                                                "APPLYPROXIMALADAGRAD",
                                                "APPLYADAGRADDA",
                                                "APPLYFTRL",
                                                "APPLYMOMENTUM",
                                                "APPLYADAM",
                                                "APPLYRMSPROP",
                                                "APPLYCENTEREDRMSPROP"};
  FOR (INT I = 0; I < GRAPH_.NODE_SIZE(); I++) {
    ALL_NODES_.INSERT(
        STD::MAKE_PAIR(GRAPH_.NODE(I).NAME(), GRAPH_.MUTABLE_NODE(I)));
    IF (APPLY_GRADIENTS_OPS.FIND(GRAPH_.NODE(I).OP()) !=
        APPLY_GRADIENTS_OPS.END()) {
      APPLY_GRADIENTS_NODES_.INSERT(GRAPH_.NODE(I).NAME());
      VLOG(2) << "APPLY GRADIENTS NODE: " << GRAPH_.NODE(I).NAME();
    }
  }

  AUTO DIV_CONST_NODE = ADDNODEDIVCONST();
  ALL_NODES_.INSERT(STD::MAKE_PAIR(DIV_CONST_NODE->NAME(), DIV_CONST_NODE));
  STD::MAP<STRING, INT> GRADIENT_POS = {{"APPLYGRADIENTDESCENT", 2},
                                        {"APPLYPROXIMALGRADIENTDESCENT", 4},
                                        {"APPLYADADELTA", 6},
                                        {"APPLYADAGRAD", 3},
                                        {"APPLYPROXIMALADAGRAD", 5},
                                        {"APPLYADAGRADDA", 3},
                                        {"APPLYFTRL", 3},
                                        {"APPLYMOMENTUM", 3},
                                        {"APPLYADAM", 9},
                                        {"APPLYRMSPROP", 7},
                                        {"APPLYCENTEREDRMSPROP", 8}};
  FOR (CONST AUTO& APPLY_GRADIENT_NODE_NAME : APPLY_GRADIENTS_NODES_) {
    AUTO APPLY_GRADIENTS_OP = ALL_NODES_[APPLY_GRADIENT_NODE_NAME]->OP();
    AUTO APPLY_GRADIENTS_NODE = ALL_NODES_[APPLY_GRADIENT_NODE_NAME];

    AUTO DIV_NODE = ADDNODEDIV(
        APPLY_GRADIENT_NODE_NAME,
        APPLY_GRADIENTS_NODE->INPUT(GRADIENT_POS[APPLY_GRADIENTS_OP]),
        DIV_CONST_NODE->NAME());
    ALL_NODES_.INSERT(STD::MAKE_PAIR(DIV_NODE->NAME(), DIV_NODE));
    *APPLY_GRADIENTS_NODE->MUTABLE_INPUT(GRADIENT_POS[APPLY_GRADIENTS_OP]) =
        DIV_NODE->NAME();
  }
  LOG(INFO) << "GRAPH SIZE AFTER ADDING DIV NODES: " << ALL_NODES_.SIZE();

  STD::VECTOR<CONST NODEDEF*> TRAIN_NODES;
  TF_RETURN_IF_ERROR(COMPUTETRANSITIVEFANIN(GRAPH_, ITEM.FETCH, &TRAIN_NODES));
  LOG(INFO) << "NUMBER OF TRAINING NODES: " << TRAIN_NODES.SIZE();

  CONST NODEDEF* DEQUEUE_NODE;
  FOR (CONST AUTO& TRAIN_NODE : TRAIN_NODES) {
    IF (ISDEQUEUEOP(*TRAIN_NODE)) {
      DEQUEUE_NODE = TRAIN_NODE;
      BREAK;
    }
  }

  STD::VECTOR<CONST NODEDEF*> INPUT_NODES;
  IF (DEQUEUE_NODE) {
    LOG(INFO) << "DEQUEUE NODE: " << DEQUEUE_NODE->NAME();
    TF_RETURN_IF_ERROR(COMPUTETRANSITIVEFANIN(GRAPH_, {DEQUEUE_NODE->NAME()},
                                              {}, &INPUT_NODES));
  }
  LOG(INFO) << "NUMBER OF INPUT NODES: " << INPUT_NODES.SIZE();

  STD::SET<STRING> DONT_REPLICATE_NODES;
  FOR (CONST AUTO& VARIABLE : ITEM.MAINVARIABLES()) {
    DONT_REPLICATE_NODES.INSERT(VARIABLE->NAME());
  }

  FOR (CONST AUTO& INIT : ITEM.INIT_OPS) {
    DONT_REPLICATE_NODES.INSERT(NODENAME(INIT));
  }

  // DON'T REPLICATE ALL INPUT NODES, EXCEPT THE DEQUEUE NODE.
  FOR (CONST AUTO& INPUT_NODE : INPUT_NODES) {
    IF (INPUT_NODE->NAME() != DEQUEUE_NODE->NAME()) {
      DONT_REPLICATE_NODES.INSERT(INPUT_NODE->NAME());
    }
  }

  FOR (CONST AUTO& NODE : TRAIN_NODES) {
    IF (DONT_REPLICATE_NODES.FIND(NODE->NAME()) == DONT_REPLICATE_NODES.END()) {
      REPLICA_NODES_.INSERT(NODE->NAME());
    }
  }
  LOG(INFO) << "NUMBER OF REPLICA NODES: " << REPLICA_NODES_.SIZE();

  FOR (CONST AUTO& NODE : ALL_NODES_) {
    IF (REPLICA_NODES_.FIND(NODE.FIRST) == REPLICA_NODES_.END()) {
      SHARED_NODES_.INSERT(NODE.FIRST);
    }
  }
  LOG(INFO) << "NUMBER OF SHARED NODES: " << SHARED_NODES_.SIZE();
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198374_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR* X_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("X", &X_TENSOR));

    CONST TENSOR* CS_PREV_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("CS_PREV", &CS_PREV_TENSOR));

    CONST TENSOR* H_PREV_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("H_PREV", &H_PREV_TENSOR));

    CONST TENSOR* W_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("W", &W_TENSOR));

    CONST TENSOR* WCI_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("WCI", &WCI_TENSOR));

    CONST TENSOR* WCF_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("WCF", &WCF_TENSOR));

    CONST TENSOR* WCO_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("WCO", &WCO_TENSOR));

    CONST TENSOR* B_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->INPUT("B", &B_TENSOR));

    CONST INT64_T BATCH_SIZE = X_TENSOR->DIM_SIZE(0);
    CONST INT64_T INPUT_SIZE = X_TENSOR->DIM_SIZE(1);
    CONST INT64_T CELL_SIZE = CS_PREV_TENSOR->DIM_SIZE(1);

    // SANITY CHECKS FOR OUR INPUT SHAPES.
    OP_REQUIRES(CTX, CS_PREV_TENSOR->DIM_SIZE(0) == BATCH_SIZE,
                ERRORS::INVALIDARGUMENT("CS_PREV.DIMS(0) != BATCH_SIZE: ",
                                        CS_PREV_TENSOR->DIM_SIZE(0), " VS. ",
                                        BATCH_SIZE));
    OP_REQUIRES(CTX, CS_PREV_TENSOR->DIM_SIZE(1) == CELL_SIZE,
                ERRORS::INVALIDARGUMENT("CS_PREV.DIMS(1) != CELL_SIZE: ",
                                        CS_PREV_TENSOR->DIM_SIZE(1), " VS. ",
                                        CELL_SIZE));

    OP_REQUIRES(CTX, H_PREV_TENSOR->DIM_SIZE(0) == BATCH_SIZE,
                ERRORS::INVALIDARGUMENT("H_PREV.DIMS(0) != BATCH_SIZE: ",
                                        H_PREV_TENSOR->DIM_SIZE(0), " VS. ",
                                        BATCH_SIZE));
    OP_REQUIRES(CTX, H_PREV_TENSOR->DIM_SIZE(1) == CELL_SIZE,
                ERRORS::INVALIDARGUMENT(
                    "H_PREV.DIMS(1) != CELL_SIZE: ", H_PREV_TENSOR->DIM_SIZE(1),
                    " VS. ", CELL_SIZE));

    OP_REQUIRES(CTX, W_TENSOR->DIM_SIZE(0) == INPUT_SIZE + CELL_SIZE,
                ERRORS::INVALIDARGUMENT(
                    "W.DIM_SIZE(0) != INPUT_SIZE + CELL_SIZE: ",
                    W_TENSOR->DIM_SIZE(0), " VS. ", INPUT_SIZE + CELL_SIZE));
    OP_REQUIRES(CTX, W_TENSOR->DIM_SIZE(1) == CELL_SIZE * 4,
                ERRORS::INVALIDARGUMENT(
                    "W.DIM_SIZE(1) != CELL_SIZE * 4: ", W_TENSOR->DIM_SIZE(1),
                    " VS. ", CELL_SIZE * 4));

    OP_REQUIRES(CTX, B_TENSOR->DIM_SIZE(0) == CELL_SIZE * 4,
                ERRORS::INVALIDARGUMENT(
                    "B.DIM_SIZE(0) != CELL_SIZE * 4: ", B_TENSOR->DIM_SIZE(0),
                    " VS. ", CELL_SIZE * 4));

    // ALLOCATE OUR OUTPUT TENSORS.
    TENSOR* I_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                            {"H_PREV"}, "I",
                            TENSORSHAPE({BATCH_SIZE, CELL_SIZE}), &I_TENSOR));

    TENSOR* CS_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("CS", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &CS_TENSOR));

    TENSOR* F_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("F", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &F_TENSOR));

    TENSOR* O_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                            {"CS_PREV"}, "O",
                            TENSORSHAPE({BATCH_SIZE, CELL_SIZE}), &O_TENSOR));

    TENSOR* CI_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("CI", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &CI_TENSOR));

    TENSOR* CO_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("CO", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &CO_TENSOR));

    TENSOR* H_TENSOR = NULLPTR;
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_OUTPUT("H", TENSORSHAPE({BATCH_SIZE, CELL_SIZE}),
                                  &H_TENSOR));

    // ALLOCATE OUR TEMP TENSORS.
    TENSOR XH_TENSOR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_TEMP(
                            DATATYPETOENUM<T>::V(),
                            TENSORSHAPE({BATCH_SIZE, INPUT_SIZE + CELL_SIZE}),
                            &XH_TENSOR));

    TENSOR GATES_TENSOR;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::V(),
                                      TENSORSHAPE({BATCH_SIZE, CELL_SIZE * 4}),
                                      &GATES_TENSOR));

    CONST DEVICE& DEVICE = CTX->EIGEN_DEVICE<DEVICE>();

    FUNCTOR::LSTMBLOCKCELLFPROP<DEVICE, T, USE_CUBLAS, GATE_LAYOUT>(
        BATCH_SIZE, INPUT_SIZE, CELL_SIZE)(
        CTX, DEVICE, FORGET_BIAS_, CELL_CLIP_, USE_PEEPHOLE_,
        X_TENSOR->MATRIX<T>(), CS_PREV_TENSOR->MATRIX<T>(),
        H_PREV_TENSOR->MATRIX<T>(), W_TENSOR->MATRIX<T>(), WCI_TENSOR->VEC<T>(),
        WCF_TENSOR->VEC<T>(), WCO_TENSOR->VEC<T>(), B_TENSOR->VEC<T>(),
        XH_TENSOR.MATRIX<T>(), I_TENSOR->MATRIX<T>(), CS_TENSOR->MATRIX<T>(),
        F_TENSOR->MATRIX<T>(), O_TENSOR->MATRIX<T>(), CI_TENSOR->MATRIX<T>(),
        CO_TENSOR->MATRIX<T>(), GATES_TENSOR.MATRIX<T>(),
        H_TENSOR->MATRIX<T>());
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197518_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& GRADIENT = CTX->INPUT(0);
    CONST TENSOR& INPUT = CTX->INPUT(1);
    TENSOR* INPUT_BACKPROP = NULLPTR;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(0, INPUT.SHAPE(), &INPUT_BACKPROP));
    OP_REQUIRES(
        CTX, AXIS_ >= -1,
        ERRORS::INVALIDARGUMENT("AXIS MUST BE AT LEAST -1. FOUND ", AXIS_));
    OP_REQUIRES(CTX, (AXIS_ == -1 || AXIS_ < INPUT.SHAPE().DIMS()),
                ERRORS::INVALIDARGUMENT(
                    "AXIS SHOULD BE -1 OR 0 OR A POSITIVE VALUE LESS THAN ",
                    INPUT.SHAPE().DIMS(), "BUT GIVEN AXIS VALUE WAS ", AXIS_));

    OP_REQUIRES(
        CTX, INPUT.ISSAMESIZE(GRADIENT),
        ERRORS::INVALIDARGUMENT("GRADIENT AND INPUT MUST BE THE SAME SIZE"));
    CONST INT DEPTH = (AXIS_ == -1) ? 1 : INPUT.DIM_SIZE(AXIS_);
    CONST TENSOR& INPUT_MIN_TENSOR = CTX->INPUT(2);
    OP_REQUIRES(CTX,
                INPUT_MIN_TENSOR.DIMS() == 0 || INPUT_MIN_TENSOR.DIMS() == 1,
                ERRORS::INVALIDARGUMENT(
                    "INPUT MIN TENSOR MUST HAVE DIMENSION 1. RECIEVED ",
                    INPUT_MIN_TENSOR.DIMS(), "."));
    CONST TENSOR& INPUT_MAX_TENSOR = CTX->INPUT(3);
    OP_REQUIRES(CTX,
                INPUT_MAX_TENSOR.DIMS() == 0 || INPUT_MAX_TENSOR.DIMS() == 1,
                ERRORS::INVALIDARGUMENT(
                    "INPUT MAX TENSOR MUST HAVE DIMENSION 1. RECIEVED ",
                    INPUT_MAX_TENSOR.DIMS(), "."));
    IF (AXIS_ != -1) {
      OP_REQUIRES(
          CTX, INPUT_MIN_TENSOR.DIM_SIZE(0) == DEPTH,
          ERRORS::INVALIDARGUMENT("MIN HAS INCORRECT SIZE, EXPECTED ", DEPTH,
                                  " WAS ", INPUT_MIN_TENSOR.DIM_SIZE(0)));
      OP_REQUIRES(
          CTX, INPUT_MAX_TENSOR.DIM_SIZE(0) == DEPTH,
          ERRORS::INVALIDARGUMENT("MAX HAS INCORRECT SIZE, EXPECTED ", DEPTH,
                                  " WAS ", INPUT_MAX_TENSOR.DIM_SIZE(0)));
    }

    TENSORSHAPE MIN_MAX_SHAPE(INPUT_MIN_TENSOR.SHAPE());
    TENSOR* INPUT_MIN_BACKPROP;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(1, MIN_MAX_SHAPE, &INPUT_MIN_BACKPROP));

    TENSOR* INPUT_MAX_BACKPROP;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(2, MIN_MAX_SHAPE, &INPUT_MAX_BACKPROP));

    IF (AXIS_ == -1) {
      FUNCTOR::QUANTIZEANDDEQUANTIZEONESCALEGRADIENTFUNCTOR<DEVICE, T> F;
      F(CTX->EIGEN_DEVICE<DEVICE>(), GRADIENT.TEMPLATE FLAT<T>(),
        INPUT.TEMPLATE FLAT<T>(), INPUT_MIN_TENSOR.SCALAR<T>(),
        INPUT_MAX_TENSOR.SCALAR<T>(), INPUT_BACKPROP->TEMPLATE FLAT<T>(),
        INPUT_MIN_BACKPROP->TEMPLATE SCALAR<T>(),
        INPUT_MAX_BACKPROP->TEMPLATE SCALAR<T>());
    } ELSE {
      FUNCTOR::QUANTIZEANDDEQUANTIZEPERCHANNELGRADIENTFUNCTOR<DEVICE, T> F;
      F(CTX->EIGEN_DEVICE<DEVICE>(),
        GRADIENT.TEMPLATE FLAT_INNER_OUTER_DIMS<T, 3>(AXIS_ - 1),
        INPUT.TEMPLATE FLAT_INNER_OUTER_DIMS<T, 3>(AXIS_ - 1),
        &INPUT_MIN_TENSOR, &INPUT_MAX_TENSOR,
        INPUT_BACKPROP->TEMPLATE FLAT_INNER_OUTER_DIMS<T, 3>(AXIS_ - 1),
        INPUT_MIN_BACKPROP->TEMPLATE FLAT<T>(),
        INPUT_MAX_BACKPROP->TEMPLATE FLAT<T>());
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 274872_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST(COMPARISONSTEST, GREATERQUANTIZEDSMALLRANGE) {
  COMPARISONOPMODEL MODEL({TENSORTYPE_UINT8, {1, 2, 2, 1}, 0.0, 1.0},
                          {TENSORTYPE_UINT8, {1, 2, 2, 1}, 0.0, 2.0},
                          TENSORTYPE_UINT8, BUILTINOPERATOR_GREATER);
  MODEL.QUANTIZEANDPOPULATE<UINT8_T>(MODEL.INPUT1(), {1.0, 0.5, 0.35, 0.1});
  MODEL.QUANTIZEANDPOPULATE<UINT8_T>(MODEL.INPUT2(), {1.01, 0.25, 0.3, 0.4});
  MODEL.INVOKE();

  EXPECT_THAT(MODEL.GETOUTPUT(), ELEMENTSARE(FALSE, TRUE, TRUE, FALSE));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195309_CWE-400.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GOPHERTOHTML(GOPHERSTATEDATA * GOPHERSTATE, CHAR *INBUF, INT LEN)
{
    CHAR *POS = INBUF;
    CHAR *LPOS = NULL;
    CHAR *TLINE = NULL;
    LOCAL_ARRAY(CHAR, LINE, TEMP_BUF_SIZE);
    LOCAL_ARRAY(CHAR, TMPBUF, TEMP_BUF_SIZE);
    CHAR *NAME = NULL;
    CHAR *SELECTOR = NULL;
    CHAR *HOST = NULL;
    CHAR *PORT = NULL;
    CHAR *ESCAPED_SELECTOR = NULL;
    CONST CHAR *ICON_URL = NULL;
    CHAR GTYPE;
    STOREENTRY *ENTRY = NULL;

    MEMSET(TMPBUF, '\0', TEMP_BUF_SIZE);
    MEMSET(LINE, '\0', TEMP_BUF_SIZE);

    ENTRY = GOPHERSTATE->ENTRY;

    IF (GOPHERSTATE->CONVERSION == GOPHERSTATEDATA::HTML_INDEX_PAGE) {
        CHAR *HTML_URL = HTML_QUOTE(ENTRY->URL());
        GOPHERHTMLHEADER(ENTRY, "GOPHER INDEX %S", HTML_URL);
        STOREAPPENDPRINTF(ENTRY,
                          "<P>THIS IS A SEARCHABLE GOPHER INDEX. USE THE SEARCH\N"
                          "FUNCTION OF YOUR BROWSER TO ENTER SEARCH TERMS.\N"
                          "<ISINDEX>\N");
        GOPHERHTMLFOOTER(ENTRY);
        /* NOW LET START SENDING STUFF TO CLIENT */
        ENTRY->FLUSH();
        GOPHERSTATE->HTML_HEADER_ADDED = 1;

        RETURN;
    }

    IF (GOPHERSTATE->CONVERSION == GOPHERSTATEDATA::HTML_CSO_PAGE) {
        CHAR *HTML_URL = HTML_QUOTE(ENTRY->URL());
        GOPHERHTMLHEADER(ENTRY, "CSO SEARCH OF %S", HTML_URL);
        STOREAPPENDPRINTF(ENTRY,
                          "<P>A CSO DATABASE USUALLY CONTAINS A PHONEBOOK OR\N"
                          "DIRECTORY.  USE THE SEARCH FUNCTION OF YOUR BROWSER TO ENTER\N"
                          "SEARCH TERMS.</P><ISINDEX>\N");
        GOPHERHTMLFOOTER(ENTRY);
        /* NOW LET START SENDING STUFF TO CLIENT */
        ENTRY->FLUSH();
        GOPHERSTATE->HTML_HEADER_ADDED = 1;

        RETURN;
    }

    STRING OUTBUF;

    IF (!GOPHERSTATE->HTML_HEADER_ADDED) {
        IF (GOPHERSTATE->CONVERSION == GOPHERSTATEDATA::HTML_CSO_RESULT)
            GOPHERHTMLHEADER(ENTRY, "CSO SEARCH RESULT", NULL);
        ELSE
            GOPHERHTMLHEADER(ENTRY, "GOPHER MENU", NULL);

        OUTBUF.APPEND ("<PRE>");

        GOPHERSTATE->HTML_HEADER_ADDED = 1;

        GOPHERSTATE->HTML_PRE = 1;
    }

    WHILE (POS < INBUF + LEN) {
        INT LLEN;
        INT LEFT = LEN - (POS - INBUF);
        LPOS = (CHAR *)MEMCHR(POS, '\N', LEFT);
        IF (LPOS) {
            ++LPOS;             /* NEXT LINE IS AFTER \N */
            LLEN = LPOS - POS;
        } ELSE {
            LLEN = LEFT;
        }
        IF (GOPHERSTATE->LEN + LLEN >= TEMP_BUF_SIZE) {
            DEBUGS(10, DBG_IMPORTANT, "GOPHERHTML: BUFFER OVERFLOW. LOST SOME DATA ON URL: " << ENTRY->URL()  );
            LLEN = TEMP_BUF_SIZE - GOPHERSTATE->LEN - 1;
            GOPHERSTATE->OVERFLOWED = TRUE; // MAY ALREADY BE TRUE
        }
        IF (!LPOS) {
            /* THERE IS NO COMPLETE LINE IN INBUF */
            /* COPY IT TO TEMP BUFFER */
            /* NOTE: LLEN IS ADJUSTED ABOVE */
            MEMCPY(GOPHERSTATE->BUF + GOPHERSTATE->LEN, POS, LLEN);
            GOPHERSTATE->LEN += LLEN;
            BREAK;
        }
        IF (GOPHERSTATE->LEN != 0) {
            /* THERE IS SOMETHING LEFT FROM LAST TX. */
            MEMCPY(LINE, GOPHERSTATE->BUF, GOPHERSTATE->LEN);
            MEMCPY(LINE + GOPHERSTATE->LEN, POS, LLEN);
            LLEN += GOPHERSTATE->LEN;
            GOPHERSTATE->LEN = 0;
        } ELSE {
            MEMCPY(LINE, POS, LLEN);
        }
        LINE[LLEN + 1] = '\0';
        /* MOVE INPUT TO NEXT LINE */
        POS = LPOS;

        /* AT THIS POINT. WE SHOULD HAVE ONE LINE IN BUFFER TO PROCESS */

        IF (*LINE == '.') {
            /* SKIP IT */
            MEMSET(LINE, '\0', TEMP_BUF_SIZE);
            CONTINUE;
        }

        SWITCH (GOPHERSTATE->CONVERSION) {

        CASE GOPHERSTATEDATA::HTML_INDEX_RESULT:

        CASE GOPHERSTATEDATA::HTML_DIR: {
            TLINE = LINE;
            GTYPE = *TLINE;
            ++TLINE;
            NAME = TLINE;
            SELECTOR = STRCHR(TLINE, TAB);

            IF (SELECTOR) {
                *SELECTOR = '\0';
                ++SELECTOR;
                HOST = STRCHR(SELECTOR, TAB);

                IF (HOST) {
                    *HOST = '\0';
                    ++HOST;
                    PORT = STRCHR(HOST, TAB);

                    IF (PORT) {
                        CHAR *JUNK;
                        PORT[0] = ':';
                        JUNK = STRCHR(HOST, TAB);

                        IF (JUNK)
                            *JUNK++ = 0;    /* CHOP PORT */
                        ELSE {
                            JUNK = STRCHR(HOST, '\R');

                            IF (JUNK)
                                *JUNK++ = 0;    /* CHOP PORT */
                            ELSE {
                                JUNK = STRCHR(HOST, '\N');

                                IF (JUNK)
                                    *JUNK++ = 0;    /* CHOP PORT */
                            }
                        }

                        IF ((PORT[1] == '0') && (!PORT[2]))
                            PORT[0] = 0;    /* 0 MEANS NONE */
                    }

                    /* ESCAPE A SELECTOR HERE */
                    ESCAPED_SELECTOR = XSTRDUP(RFC1738_ESCAPE_PART(SELECTOR));

                    SWITCH (GTYPE) {

                    CASE GOPHER_DIRECTORY:
                        ICON_URL = MIMEGETICONURL("INTERNAL-MENU");
                        BREAK;

                    CASE GOPHER_HTML:

                    CASE GOPHER_FILE:
                        ICON_URL = MIMEGETICONURL("INTERNAL-TEXT");
                        BREAK;

                    CASE GOPHER_INDEX:

                    CASE GOPHER_CSO:
                        ICON_URL = MIMEGETICONURL("INTERNAL-INDEX");
                        BREAK;

                    CASE GOPHER_IMAGE:

                    CASE GOPHER_GIF:

                    CASE GOPHER_PLUS_IMAGE:
                        ICON_URL = MIMEGETICONURL("INTERNAL-IMAGE");
                        BREAK;

                    CASE GOPHER_SOUND:

                    CASE GOPHER_PLUS_SOUND:
                        ICON_URL = MIMEGETICONURL("INTERNAL-SOUND");
                        BREAK;

                    CASE GOPHER_PLUS_MOVIE:
                        ICON_URL = MIMEGETICONURL("INTERNAL-MOVIE");
                        BREAK;

                    CASE GOPHER_TELNET:

                    CASE GOPHER_3270:
                        ICON_URL = MIMEGETICONURL("INTERNAL-TELNET");
                        BREAK;

                    CASE GOPHER_BIN:

                    CASE GOPHER_MACBINHEX:

                    CASE GOPHER_DOSBIN:

                    CASE GOPHER_UUENCODED:
                        ICON_URL = MIMEGETICONURL("INTERNAL-BINARY");
                        BREAK;

                    CASE GOPHER_INFO:
                        ICON_URL = NULL;
                        BREAK;

                    CASE GOPHER_WWW:
                        ICON_URL = MIMEGETICONURL("INTERNAL-LINK");
                        BREAK;

                    DEFAULT:
                        ICON_URL = MIMEGETICONURL("INTERNAL-UNKNOWN");
                        BREAK;
                    }

                    MEMSET(TMPBUF, '\0', TEMP_BUF_SIZE);

                    IF ((GTYPE == GOPHER_TELNET) || (GTYPE == GOPHER_3270)) {
                        IF (STRLEN(ESCAPED_SELECTOR) != 0)
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"TELNET://%S@%S%S%S/\">%S</A>\N",
                                     ICON_URL, ESCAPED_SELECTOR, RFC1738_ESCAPE_PART(HOST),
                                     *PORT ? ":" : "", PORT, HTML_QUOTE(NAME));
                        ELSE
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"TELNET://%S%S%S/\">%S</A>\N",
                                     ICON_URL, RFC1738_ESCAPE_PART(HOST), *PORT ? ":" : "",
                                     PORT, HTML_QUOTE(NAME));

                    } ELSE IF (GTYPE == GOPHER_INFO) {
                        SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "\T%S\N", HTML_QUOTE(NAME));
                    } ELSE {
                        IF (STRNCMP(SELECTOR, "GET /", 5) == 0) {
                            /* WWW LINK */
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"HTTP://%S/%S\">%S</A>\N",
                                     ICON_URL, HOST, RFC1738_ESCAPE_UNESCAPED(SELECTOR + 5), HTML_QUOTE(NAME));
                        } ELSE IF (GTYPE == GOPHER_WWW) {
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"%S\">%S</A>\N",
                                     ICON_URL, RFC1738_ESCAPE_UNESCAPED(SELECTOR), HTML_QUOTE(NAME));
                        } ELSE {
                            /* STANDARD LINK */
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"GOPHER://%S/%C%S\">%S</A>\N",
                                     ICON_URL, HOST, GTYPE, ESCAPED_SELECTOR, HTML_QUOTE(NAME));
                        }
                    }

                    SAFE_FREE(ESCAPED_SELECTOR);
                    OUTBUF.APPEND(TMPBUF);
                } ELSE {
                    MEMSET(LINE, '\0', TEMP_BUF_SIZE);
                    CONTINUE;
                }
            } ELSE {
                MEMSET(LINE, '\0', TEMP_BUF_SIZE);
                CONTINUE;
            }

            BREAK;
            }           /* HTML_DIR, HTML_INDEX_RESULT */

        CASE GOPHERSTATEDATA::HTML_CSO_RESULT: {
            IF (LINE[0] == '-') {
                INT CODE, RECNO;
                CHAR *S_CODE, *S_RECNO, *RESULT;

                S_CODE = STRTOK(LINE + 1, ":\N");
                S_RECNO = STRTOK(NULL, ":\N");
                RESULT = STRTOK(NULL, "\N");

                IF (!RESULT)
                    BREAK;

                CODE = ATOI(S_CODE);

                RECNO = ATOI(S_RECNO);

                IF (CODE != 200)
                    BREAK;

                IF (GOPHERSTATE->CSO_RECNO != RECNO) {
                    SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "</PRE><HR NOSHADE SIZE=\"1PX\"><H2>RECORD# %D<BR><I>%S</I></H2>\N<PRE>", RECNO, HTML_QUOTE(RESULT));
                    GOPHERSTATE->CSO_RECNO = RECNO;
                } ELSE {
                    SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "%S\N", HTML_QUOTE(RESULT));
                }

                OUTBUF.APPEND(TMPBUF);
                BREAK;
            } ELSE {
                INT CODE;
                CHAR *S_CODE, *RESULT;

                S_CODE = STRTOK(LINE, ":");
                RESULT = STRTOK(NULL, "\N");

                IF (!RESULT)
                    BREAK;

                CODE = ATOI(S_CODE);

                SWITCH (CODE) {

                CASE 200: {
                    /* OK */
                    /* DO NOTHING HERE */
                    BREAK;
                }

                CASE 102:   /* NUMBER OF MATCHES */

                CASE 501:   /* NO MATCH */

                CASE 502: { /* TOO MANY MATCHES */
                    /* PRINT THE MESSAGE THE SERVER RETURNS */
                    SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "</PRE><HR NOSHADE SIZE=\"1PX\"><H2>%S</H2>\N<PRE>", HTML_QUOTE(RESULT));
                    OUTBUF.APPEND(TMPBUF);
                    BREAK;
                }

                }
            }

            BREAK;
            }           /* HTML_CSO_RESULT */
        DEFAULT:
            BREAK;      /* DO NOTHING */

        }           /* SWITCH */

    }               /* WHILE LOOP */

    IF (OUTBUF.SIZE() > 0) {
        ENTRY->APPEND(OUTBUF.RAWBUF(), OUTBUF.SIZE());
        /* NOW LET START SENDING STUFF TO CLIENT */
        ENTRY->FLUSH();
    }

    OUTBUF.CLEAN();
    RETURN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220021_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR* INPUT_INDICES;
    CONST TENSOR* INPUT_VALUES;
    CONST TENSOR* INPUT_SHAPE;
    SPARSETENSORSMAP* MAP;

    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_INDICES", &INPUT_INDICES));
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_VALUES", &INPUT_VALUES));
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_SHAPE", &INPUT_SHAPE));
    OP_REQUIRES_OK(CONTEXT, GETMAP(CONTEXT, TRUE /* IS_WRITING */, &MAP));

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INPUT_INDICES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE ",
                    INPUT_INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_VALUES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT VALUES SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INPUT_VALUES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_SHAPE->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INPUT_SHAPE->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CONTEXT,
        INPUT_VALUES->SHAPE().DIM_SIZE(0) == INPUT_INDICES->SHAPE().DIM_SIZE(0),
        ERRORS::INVALIDARGUMENT(
            "NUMBER OF VALUES MUST MATCH FIRST DIMENSION OF INDICES. ", "GOT ",
            INPUT_VALUES->SHAPE().DIM_SIZE(0),
            " VALUES, INDICES SHAPE: ", INPUT_INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CONTEXT,
        INPUT_SHAPE->SHAPE().DIM_SIZE(0) == INPUT_INDICES->SHAPE().DIM_SIZE(1),
        ERRORS::INVALIDARGUMENT(
            "NUMBER OF DIMENSIONS MUST MATCH SECOND DIMENSION OF INDICES. ",
            "GOT ", INPUT_SHAPE->SHAPE().DIM_SIZE(0),
            " DIMENSIONS, INDICES SHAPE: ",
            INPUT_INDICES->SHAPE().DEBUGSTRING()));

    INT RANK = INPUT_SHAPE->NUMELEMENTS();

    OP_REQUIRES(
        CONTEXT, RANK > 1,
        ERRORS::INVALIDARGUMENT(
            "RANK OF INPUT SPARSETENSOR SHOULD BE > 1, BUT SAW RANK: ", RANK));

    AUTO INPUT_SHAPE_VEC = INPUT_SHAPE->VEC<INT64_T>();

    TENSORSHAPE TENSOR_INPUT_SHAPE;
    OP_REQUIRES_OK(CONTEXT, TENSORSHAPE::BUILDTENSORSHAPE(INPUT_SHAPE_VEC,
                                                          &TENSOR_INPUT_SHAPE));
    GTL::INLINEDVECTOR<INT64_T, 8> STD_ORDER(RANK);
    STD::IOTA(STD_ORDER.BEGIN(), STD_ORDER.END(), 0);
    SPARSETENSOR INPUT_ST;
    OP_REQUIRES_OK(CONTEXT, SPARSETENSOR::CREATE(*INPUT_INDICES, *INPUT_VALUES,
                                                 TENSOR_INPUT_SHAPE, STD_ORDER,
                                                 &INPUT_ST));

    CONST INT64_T N = INPUT_SHAPE_VEC(0);

    TENSOR SPARSE_HANDLES(DT_INT64, TENSORSHAPE({N}));
    AUTO SPARSE_HANDLES_T = SPARSE_HANDLES.VEC<INT64_T>();

    OP_REQUIRES_OK(CONTEXT, INPUT_ST.INDICESVALID());

    // WE CAN GENERATE THE OUTPUT SHAPE PROTO STRING NOW, FOR ALL
    // MINIBATCH ENTRIES.
    TENSORSHAPE OUTPUT_SHAPE;
    OP_REQUIRES_OK(CONTEXT, TENSORSHAPEUTILS::MAKESHAPE(
                                INPUT_SHAPE_VEC.DATA() + 1,
                                INPUT_SHAPE->NUMELEMENTS() - 1, &OUTPUT_SHAPE));

    // GET GROUPS BY MINIBATCH DIMENSION
    STD::UNORDERED_SET<INT64_T> VISITED;
    SPARSE::GROUPITERABLE MINIBATCH = INPUT_ST.GROUP({0});
    FOR (CONST AUTO& SUBSET : MINIBATCH) {
      CONST INT64_T B = SUBSET.GROUP()[0];
      VISITED.INSERT(B);
      OP_REQUIRES(
          CONTEXT, B > -1 && B < N,
          ERRORS::INVALIDARGUMENT(
              "RECEIVED UNEXPECTED COLUMN 0 VALUE IN INPUT SPARSETENSOR: ", B,
              " < 0 OR >= N (= ", N, ")"));

      CONST AUTO INDICES = SUBSET.INDICES();
      CONST AUTO VALUES = SUBSET.VALUES<T>();
      CONST INT64_T NUM_ENTRIES = VALUES.SIZE();

      TENSOR OUTPUT_INDICES = TENSOR(DT_INT64, {NUM_ENTRIES, RANK - 1});
      TENSOR OUTPUT_VALUES = TENSOR(DATATYPETOENUM<T>::VALUE, {NUM_ENTRIES});

      AUTO OUTPUT_INDICES_T = OUTPUT_INDICES.MATRIX<INT64_T>();
      AUTO OUTPUT_VALUES_T = OUTPUT_VALUES.VEC<T>();

      FOR (INT I = 0; I < NUM_ENTRIES; ++I) {
        FOR (INT D = 1; D < RANK; ++D) {
          OUTPUT_INDICES_T(I, D - 1) = INDICES(I, D);
        }
        OUTPUT_VALUES_T(I) = VALUES(I);
      }

      SPARSETENSOR ST_I;
      OP_REQUIRES_OK(CONTEXT,
                     SPARSETENSOR::CREATE(OUTPUT_INDICES, OUTPUT_VALUES,
                                          OUTPUT_SHAPE, &ST_I));
      INT64_T HANDLE;
      OP_REQUIRES_OK(CONTEXT, MAP->ADDSPARSETENSOR(CONTEXT, ST_I, &HANDLE));
      SPARSE_HANDLES_T(B) = HANDLE;
    }

    // FILL IN ANY GAPS; WE MUST PROVIDE AN EMPTY ST FOR BATCH ENTRIES
    // THE GROUPER DIDN'T FIND.
    IF (VISITED.SIZE() < N) {
      TENSOR EMPTY_INDICES(DT_INT64, {0, RANK - 1});
      TENSOR EMPTY_VALUES(DATATYPETOENUM<T>::VALUE, {0});
      SPARSETENSOR EMPTY_ST;
      OP_REQUIRES_OK(CONTEXT, SPARSETENSOR::CREATE(EMPTY_INDICES, EMPTY_VALUES,
                                                   OUTPUT_SHAPE, &EMPTY_ST));

      FOR (INT64_T B = 0; B < N; ++B) {
        // WE SKIPPED THIS BATCH ENTRY.
        IF (VISITED.FIND(B) == VISITED.END()) {
          INT64_T HANDLE;
          OP_REQUIRES_OK(CONTEXT,
                         MAP->ADDSPARSETENSOR(CONTEXT, EMPTY_ST, &HANDLE));
          SPARSE_HANDLES_T(B) = HANDLE;
        }
      }
    }

    CONTEXT->SET_OUTPUT(0, SPARSE_HANDLES);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197262_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& A = CTX->INPUT(0);
    CONST TENSOR& B = CTX->INPUT(1);
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISMATRIX(A.SHAPE()),
                ERRORS::INVALIDARGUMENT("A IS NOT A MATRIX"));
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISMATRIX(B.SHAPE()),
                ERRORS::INVALIDARGUMENT("B IS NOT A MATRIX"));

    CONST INT M = TRANSPOSE_A_ ? A.DIM_SIZE(1) : A.DIM_SIZE(0);
    CONST INT K = TRANSPOSE_A_ ? A.DIM_SIZE(0) : A.DIM_SIZE(1);
    CONST INT N = TRANSPOSE_B_ ? B.DIM_SIZE(0) : B.DIM_SIZE(1);
    CONST INT K2 = TRANSPOSE_B_ ? B.DIM_SIZE(1) : B.DIM_SIZE(0);

    OP_REQUIRES(CTX, K == K2,
                ERRORS::INVALIDARGUMENT(
                    "MATRIX SIZE INCOMPATIBLE: A: ", A.SHAPE().DEBUGSTRING(),
                    ", B: ", B.SHAPE().DEBUGSTRING()));
    TENSOR* OUTPUT = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(0, TENSORSHAPE({M, N}), &OUTPUT));

    IF (K == 0) {
      // IF THE INNER DIMENSION K IN THE MATRIX MULTIPLICATION IS ZERO, WE FILL
      // THE OUTPUT WITH ZEROS.
      FUNCTOR::SETZEROFUNCTOR<CPUDEVICE, FLOAT> F;
      F(CTX->EIGEN_DEVICE<CPUDEVICE>(), OUTPUT->FLAT<FLOAT>());
      RETURN;
    }

    AUTO OUT = OUTPUT->MATRIX<FLOAT>();

    STD::UNIQUE_PTR<TENSOR> A_FLOAT;
    STD::UNIQUE_PTR<TENSOR> B_FLOAT;
    IF (!A_IS_SPARSE_ && !B_IS_SPARSE_) {
      AUTO LEFT = &A;
      AUTO RIGHT = &B;
      // TODO(AGARWAL): MULTI-THREAD THE CONVERSIONS FROM BFLOAT16 TO FLOAT.
      IF (STD::IS_SAME<TL, BFLOAT16>::VALUE) {
        A_FLOAT.RESET(NEW TENSOR(DT_FLOAT, A.SHAPE()));
        BFLOAT16TOFLOAT(A.FLAT<BFLOAT16>().DATA(),
                        A_FLOAT->FLAT<FLOAT>().DATA(), A.NUMELEMENTS());
        LEFT = A_FLOAT.GET();
      }
      IF (STD::IS_SAME<TR, BFLOAT16>::VALUE) {
        B_FLOAT.RESET(NEW TENSOR(DT_FLOAT, B.SHAPE()));
        BFLOAT16TOFLOAT(B.FLAT<BFLOAT16>().DATA(),
                        B_FLOAT->FLAT<FLOAT>().DATA(), B.NUMELEMENTS());
        RIGHT = B_FLOAT.GET();
      }
      EIGEN::ARRAY<EIGEN::INDEXPAIR<EIGEN::DENSEINDEX>, 1> DIM_PAIR;
      DIM_PAIR[0].FIRST = TRANSPOSE_A_ ? 0 : 1;
      DIM_PAIR[0].SECOND = TRANSPOSE_B_ ? 1 : 0;

      OUT.DEVICE(CTX->TEMPLATE EIGEN_DEVICE<CPUDEVICE>()) =
          LEFT->MATRIX<FLOAT>().CONTRACT(RIGHT->MATRIX<FLOAT>(), DIM_PAIR);
      RETURN;
    }

    AUTO LEFT = &A;
    AUTO RIGHT = &B;
    BOOL TRANSPOSE_OUTPUT = FALSE;
    BOOL TRANSPOSE_A = TRANSPOSE_A_;
    BOOL TRANSPOSE_B = TRANSPOSE_B_;
    IF (!A_IS_SPARSE_) {
      // SWAP THE ORDER OF MULTIPLICATIONS USING THE IDENTITY:
      // A * B = (B' *  A')'.
      STD::SWAP(LEFT, RIGHT);
      STD::SWAP(TRANSPOSE_A, TRANSPOSE_B);
      TRANSPOSE_A = !TRANSPOSE_A;
      TRANSPOSE_B = !TRANSPOSE_B;
      TRANSPOSE_OUTPUT = !TRANSPOSE_OUTPUT;
    }

    STD::UNIQUE_PTR<TENSOR> RIGHT_TR;
    IF (TRANSPOSE_B) {
      // TODO(AGARWAL): AVOID TRANSPOSING THE MATRIX HERE AND DIRECTLY HANDLE
      // TRANSPOSE IN CREATEDENSESLICES.
      OP_REQUIRES(CTX, RIGHT->DIM_SIZE(0) != 0,
                  ERRORS::INVALIDARGUMENT("B HAS AN ENTRY 0 IN IT'S SHAPE."));
      OP_REQUIRES(CTX, RIGHT->DIM_SIZE(1) != 0,
                  ERRORS::INVALIDARGUMENT("B HAS AN ENTRY 0 IN IT'S SHAPE."));
      RIGHT_TR.RESET(
          NEW TENSOR(RIGHT->DTYPE(),
                     TENSORSHAPE({RIGHT->DIM_SIZE(1), RIGHT->DIM_SIZE(0)})));

      CONST AUTO PERM = DSIZES_10();
      IF (TRANSPOSE_OUTPUT) {
        RIGHT_TR->MATRIX<TL>().DEVICE(CTX->TEMPLATE EIGEN_DEVICE<CPUDEVICE>()) =
            RIGHT->MATRIX<TL>().SHUFFLE(PERM);
      } ELSE {
        RIGHT_TR->MATRIX<TR>().DEVICE(CTX->TEMPLATE EIGEN_DEVICE<CPUDEVICE>()) =
            RIGHT->MATRIX<TR>().SHUFFLE(PERM);
      }
      RIGHT = RIGHT_TR.GET();
    }

    IF (TRANSPOSE_OUTPUT) {
      DOMATMUL<TR, TL>::COMPUTE(&THIS->CACHE_TR_, LEFT->MATRIX<TR>(),
                                RIGHT->MATRIX<TL>(), TRANSPOSE_A,
                                CTX->DEVICE()->TENSORFLOW_CPU_WORKER_THREADS(),
                                TRANSPOSE_OUTPUT, &OUT);
    } ELSE {
      DOMATMUL<TL, TR>::COMPUTE(&THIS->CACHE_NT_, LEFT->MATRIX<TL>(),
                                RIGHT->MATRIX<TR>(), TRANSPOSE_A,
                                CTX->DEVICE()->TENSORFLOW_CPU_WORKER_THREADS(),
                                TRANSPOSE_OUTPUT, &OUT);
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197239_CWE-20.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    TRY {
      CONST TENSOR& INPUT = CTX->INPUT(KINPUTTENSORINDEX);
      CONST TENSOR& INPUT_MIN_VEC = CTX->INPUT(KINPUTMINVECINDEX);
      FLOAT* INPUT_MIN_VEC_DATA = (FLOAT*)CONST_CAST<VOID*>(
          STATIC_CAST<CONST VOID*>(INPUT_MIN_VEC.FLAT<FLOAT>().DATA()));
      CONST TENSOR& INPUT_MAX_VEC = CTX->INPUT(KINPUTMAXVECINDEX);
      FLOAT* INPUT_MAX_VEC_DATA = (FLOAT*)CONST_CAST<VOID*>(
          STATIC_CAST<CONST VOID*>(INPUT_MAX_VEC.FLAT<FLOAT>().DATA()));

      CONST TENSOR& INPUT_REQUESTED_MIN = CTX->INPUT(THIS->KREQUESTMININDEX);
      CONST FLOAT INPUT_REQUESTED_MIN_FLOAT =
          INPUT_REQUESTED_MIN.FLAT<FLOAT>()(0);
      CONST TENSOR& INPUT_REQUESTED_MAX = CTX->INPUT(THIS->KREQUESTMAXINDEX);
      CONST FLOAT INPUT_REQUESTED_MAX_FLOAT =
          INPUT_REQUESTED_MAX.FLAT<FLOAT>()(0);

      SIZE_T DEPTH = INPUT_MIN_VEC.NUMELEMENTS();
      OP_REQUIRES(
          CTX, INPUT.DIMS() == 4,
          ERRORS::INVALIDARGUMENT("CURRENT REQUANTIZEPERCHANNEL OPERATOR"
                                  "SUPPORTS 4D TENSORS ONLY."));
      OP_REQUIRES(
          CTX, INPUT_MIN_VEC.DIM_SIZE(0) == DEPTH,
          ERRORS::INVALIDARGUMENT("INPUT_MIN HAS INCORRECT SIZE, EXPECTED ",
                                  DEPTH, " WAS ", INPUT_MIN_VEC.DIM_SIZE(0)));
      OP_REQUIRES(
          CTX, INPUT_MAX_VEC.DIM_SIZE(0) == DEPTH,
          ERRORS::INVALIDARGUMENT("INPUT_MAX HAS INCORRECT SIZE, EXPECTED ",
                                  DEPTH, " WAS ", INPUT_MAX_VEC.DIM_SIZE(0)));

      IF (OUT_TYPE_ == DT_QINT8) DCHECK(INPUT_REQUESTED_MIN_FLOAT < 0.0F);

      CONST FLOAT FACTOR = (OUT_TYPE_ == DT_QINT8) ? 127.0F : 255.0F;
      CONST FLOAT REQUESTED_MIN_MAX =
          STD::MAX(STD::ABS(INPUT_REQUESTED_MIN_FLOAT),
                   STD::ABS(INPUT_REQUESTED_MAX_FLOAT));
      TENSOR* OUTPUT = NULLPTR;
      OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(KOUTPUTTENSORINDEX,
                                               INPUT.SHAPE(), &OUTPUT));

      STD::VECTOR<FLOAT> SCALES(DEPTH);
      FOR (INT I = 0; I < DEPTH; ++I) {
        FLOAT MIN_MAX_FROM_VEC = STD::MAX(STD::ABS(INPUT_MIN_VEC_DATA[I]),
                                          STD::ABS(INPUT_MAX_VEC_DATA[I]));
        SCALES[I] = FACTOR * (MIN_MAX_FROM_VEC / REQUESTED_MIN_MAX /
                              STATIC_CAST<FLOAT>(1L << 31));
      }

      MKLDNN::PRIMITIVE_ATTR REORDER_ATTR;
      REORDER_ATTR.SET_OUTPUT_SCALES(2, SCALES);

      MEMORY::DIMS DIMS_MKL_ORDER =
          TFSHAPETOMKLDNNDIMSINNCHW(INPUT.SHAPE(), FORMAT_NHWC);
      MEMORY::DESC INPUT_MD = MEMORY::DESC(DIMS_MKL_ORDER, MKLDNNTYPE<QINT32>(),
                                           MEMORY::FORMAT_TAG::NHWC);
      MEMORY::DESC OUTPUT_MD =
          (OUT_TYPE_ == DT_QINT8)
              ? MEMORY::DESC(DIMS_MKL_ORDER, MKLDNNTYPE<QINT8>(),
                             MEMORY::FORMAT_TAG::NHWC)
              : MEMORY::DESC(DIMS_MKL_ORDER, MKLDNNTYPE<QUINT8>(),
                             MEMORY::FORMAT_TAG::NHWC);

      VOID* INPUT_BUF =
          STATIC_CAST<VOID*>(CONST_CAST<QINT32*>(INPUT.FLAT<QINT32>().DATA()));
      VOID* OUTPUT_BUF;
      IF (OUT_TYPE_ == DT_QINT8) {
        OUTPUT_BUF = STATIC_CAST<VOID*>(
            CONST_CAST<QINT8*>(OUTPUT->FLAT<QINT8>().DATA()));
      } ELSE {
        OUTPUT_BUF = STATIC_CAST<VOID*>(
            CONST_CAST<QUINT8*>(OUTPUT->FLAT<QUINT8>().DATA()));
      }

      STD::UNIQUE_PTR<MEMORY> INPUT_MEM_PRIM(
          NEW MEMORY(INPUT_MD, CPU_ENGINE_, INPUT_BUF));
      STD::UNIQUE_PTR<MEMORY> OUTPUT_MEM_PRIM(
          NEW MEMORY(OUTPUT_MD, CPU_ENGINE_, OUTPUT_BUF));

      MKLDNN::REORDER::PRIMITIVE_DESC REORDER_PD =
          REORDERPD(CPU_ENGINE_, INPUT_MEM_PRIM->GET_DESC(), CPU_ENGINE_,
                    OUTPUT_MEM_PRIM->GET_DESC(), REORDER_ATTR);
      STD::SHARED_PTR<STREAM> REORDER_STREAM;
      MKLDNNTHREADPOOL EIGEN_TP(CTX);
      REORDER_STREAM.RESET(CREATESTREAM(&EIGEN_TP, CPU_ENGINE_));
      STD::UNORDERED_MAP<INT, MKLDNN::MEMORY> REORDER_ARGS = {
          {MKLDNN_ARG_FROM, *INPUT_MEM_PRIM},
          {MKLDNN_ARG_TO, *OUTPUT_MEM_PRIM}};
      STD::UNIQUE_PTR<MKLDNN::PRIMITIVE> REORDER_PRIM(
          NEW MKLDNN::REORDER(REORDER_PD));
      REORDER_PRIM->EXECUTE(*REORDER_STREAM, REORDER_ARGS);

      TENSOR* OUTPUT_MIN = NULLPTR;
      TENSOR* OUTPUT_MAX = NULLPTR;
      OP_REQUIRES_OK(CTX,
                     CTX->ALLOCATE_OUTPUT(KOUTPUTMININDEX, {}, &OUTPUT_MIN));
      OP_REQUIRES_OK(CTX,
                     CTX->ALLOCATE_OUTPUT(KOUTPUTMAXINDEX, {}, &OUTPUT_MAX));

      OUTPUT_MIN->FLAT<FLOAT>()(0) = INPUT_REQUESTED_MIN_FLOAT;
      OUTPUT_MAX->FLAT<FLOAT>()(0) = INPUT_REQUESTED_MAX_FLOAT;
    } CATCH (MKLDNN::ERROR& E) {
      STRING ERROR_MSG = "STATUS: " + STD::TO_STRING(E.STATUS) +
                         ", MESSAGE: " + STD::STRING(E.MESSAGE) + ", IN FILE " +
                         STD::STRING(__FILE__) + ":" + STD::TO_STRING(__LINE__);
      OP_REQUIRES_OK(
          CTX, ERRORS::ABORTED("OPERATION RECEIVED AN EXCEPTION:", ERROR_MSG));
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196698_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID SPARSEFILLEMPTYROWSOPIMPL(OPKERNELCONTEXT* CONTEXT,
                               ASYNCOPKERNEL::DONECALLBACK DONE = NULLPTR) {
  // NOTE THAT SETTING THIS EMPTY LAMBDA AS THE DEFAULT PARAMETER VALUE DIRECTLY
  // CAN CAUSE STRANGE COMPILER/LINKER ERRORS, SO WE DO IT LIKE THIS INSTEAD.
  IF (!DONE) {
    DONE = [] {};
  }

  CONST INT KINDICESINPUT = 0;
  CONST INT KVALUESINPUT = 1;
  CONST INT KDENSESHAPEINPUT = 2;
  CONST INT KDEFAULTVALUEINPUT = 3;

  CONST TENSOR& INDICES_T = CONTEXT->INPUT(KINDICESINPUT);
  CONST TENSOR& VALUES_T = CONTEXT->INPUT(KVALUESINPUT);
  CONST TENSOR& DENSE_SHAPE_T = CONTEXT->INPUT(KDENSESHAPEINPUT);
  CONST TENSOR& DEFAULT_VALUE_T = CONTEXT->INPUT(KDEFAULTVALUEINPUT);

  OP_REQUIRES_ASYNC(
      CONTEXT, TENSORSHAPEUTILS::ISVECTOR(DENSE_SHAPE_T.SHAPE()),
      ERRORS::INVALIDARGUMENT("DENSE_SHAPE MUST BE A VECTOR, SAW: ",
                              DENSE_SHAPE_T.SHAPE().DEBUGSTRING()),
      DONE);
  OP_REQUIRES_ASYNC(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INDICES_T.SHAPE()),
                    ERRORS::INVALIDARGUMENT("INDICES MUST BE A MATRIX, SAW: ",
                                            INDICES_T.SHAPE().DEBUGSTRING()),
                    DONE);
  OP_REQUIRES_ASYNC(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(VALUES_T.SHAPE()),
                    ERRORS::INVALIDARGUMENT("VALUES MUST BE A VECTOR, SAW: ",
                                            VALUES_T.SHAPE().DEBUGSTRING()),
                    DONE);
  OP_REQUIRES_ASYNC(
      CONTEXT, TENSORSHAPEUTILS::ISSCALAR(DEFAULT_VALUE_T.SHAPE()),
      ERRORS::INVALIDARGUMENT("DEFAULT_VALUE MUST BE A SCALAR, SAW: ",
                              DEFAULT_VALUE_T.SHAPE().DEBUGSTRING()),
      DONE);
  // TODO(EBREVDO): ADD SHAPE CHECKS BETWEEN VALUES, INDICES,
  // ALSO ADD CHECK THAT DENSE RANK > 0.
  OP_REQUIRES_ASYNC(CONTEXT, DENSE_SHAPE_T.NUMELEMENTS() != 0,
                    ERRORS::INVALIDARGUMENT("DENSE SHAPE CANNOT BE EMPTY."),
                    DONE);

  USING FUNCTORTYPE = FUNCTOR::SPARSEFILLEMPTYROWS<DEVICE, T, TINDEX>;
  OP_REQUIRES_OK_ASYNC(CONTEXT,
                       FUNCTORTYPE()(CONTEXT, DEFAULT_VALUE_T, INDICES_T,
                                     VALUES_T, DENSE_SHAPE_T, DONE),
                       DONE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 194994_CWE-401.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS IMMUTABLEEXECUTORSTATE::INITIALIZE(CONST GRAPH& GRAPH) {
  TF_RETURN_IF_ERROR(GVIEW_.INITIALIZE(&GRAPH));

  // BUILD THE INFORMATION ABOUT FRAMES IN THIS SUBGRAPH.
  CONTROLFLOWINFO CF_INFO;
  TF_RETURN_IF_ERROR(BUILDCONTROLFLOWINFO(&GRAPH, &CF_INFO));

  FOR (AUTO& IT : CF_INFO.UNIQUE_FRAME_NAMES) {
    ENSUREFRAMEINFO(IT)->NODES =
        ABSL::MAKE_UNIQUE<STD::VECTOR<CONST NODEITEM*>>();
  }
  ROOT_FRAME_INFO_ = FRAME_INFO_[""].GET();

  PENDING_IDS_.RESIZE(GVIEW_.NUM_NODES());

  // PREPROCESS EVERY NODE IN THE GRAPH TO CREATE AN INSTANCE OF OP
  // KERNEL FOR EACH NODE.
  REQUIRES_CONTROL_FLOW_ = FALSE;
  FOR (CONST NODE* N : GRAPH.NODES()) {
    IF (ISSINK(N)) CONTINUE;
    IF (ISSWITCH(N) || ISMERGE(N) || ISENTER(N) || ISEXIT(N)) {
      REQUIRES_CONTROL_FLOW_ = TRUE;
    } ELSE IF (ISRECV(N)) {
      // A RECV NODE FROM A DIFFERENT DEVICE MAY PRODUCE DEAD TENSORS FROM
      // NON-LOCAL CONTROL-FLOW NODES.
      //
      // TODO(MRRY): TRACK WHETHER CONTROL FLOW WAS PRESENT IN THE
      // PRE-PARTITIONED GRAPH, AND ENABLE THE CALLER (E.G.
      // `DIRECTSESSION`) TO RELAX THIS CONSTRAINT.
      STRING SEND_DEVICE;
      STRING RECV_DEVICE;
      TF_RETURN_IF_ERROR(GETNODEATTR(N->ATTRS(), "SEND_DEVICE", &SEND_DEVICE));
      TF_RETURN_IF_ERROR(GETNODEATTR(N->ATTRS(), "RECV_DEVICE", &RECV_DEVICE));
      IF (SEND_DEVICE != RECV_DEVICE) {
        REQUIRES_CONTROL_FLOW_ = TRUE;
      }
    }

    CONST INT ID = N->ID();
    CONST STRING& FRAME_NAME = CF_INFO.FRAME_NAMES[ID];
    FRAMEINFO* FRAME_INFO = ENSUREFRAMEINFO(FRAME_NAME);

    NODEITEM* ITEM = GVIEW_.NODE(ID);
    ITEM->NODE_ID = ID;

    ITEM->INPUT_START = FRAME_INFO->TOTAL_INPUTS;
    FRAME_INFO->TOTAL_INPUTS += N->NUM_INPUTS();

    STATUS S = PARAMS_.CREATE_KERNEL(N->PROPERTIES(), &ITEM->KERNEL);
    IF (!S.OK()) {
      ITEM->KERNEL = NULLPTR;
      S = ATTACHDEF(S, *N);
      RETURN S;
    }
    CHECK(ITEM->KERNEL);
    ITEM->KERNEL_IS_ASYNC = (ITEM->KERNEL->ASASYNC() != NULLPTR);
    ITEM->IS_MERGE = ISMERGE(N);
    ITEM->IS_ANY_CONSUMER_MERGE_OR_CONTROL_TRIGGER = FALSE;
    FOR (CONST NODE* CONSUMER : N->OUT_NODES()) {
      IF (ISMERGE(CONSUMER) || ISCONTROLTRIGGER(CONSUMER)) {
        ITEM->IS_ANY_CONSUMER_MERGE_OR_CONTROL_TRIGGER = TRUE;
        BREAK;
      }
    }
    CONST TENSOR* CONST_TENSOR = ITEM->KERNEL->CONST_TENSOR();
    IF (CONST_TENSOR) {
      // HOLD ONTO A SHALLOW COPY OF THE CONSTANT TENSOR IN `*THIS` SO THAT THE
      // REFERENCE COUNT DOES NOT DROP TO 1. THIS PREVENTS THE CONSTANT TENSOR
      // FROM BEING FORWARDED, AND ITS BUFFER REUSED.
      CONST_TENSORS_.EMPLACE_BACK(*CONST_TENSOR);
    }
    ITEM->CONST_TENSOR = CONST_TENSOR;
    ITEM->IS_NOOP = (ITEM->KERNEL->TYPE_STRING_VIEW() == "NOOP");
    ITEM->IS_ENTER = ISENTER(N);
    IF (ITEM->IS_ENTER) {
      BOOL IS_CONSTANT_ENTER;
      TF_RETURN_IF_ERROR(
          GETNODEATTR(N->ATTRS(), "IS_CONSTANT", &IS_CONSTANT_ENTER));
      ITEM->IS_CONSTANT_ENTER = IS_CONSTANT_ENTER;

      STRING FRAME_NAME;
      TF_RETURN_IF_ERROR(GETNODEATTR(N->ATTRS(), "FRAME_NAME", &FRAME_NAME));
      FRAMEINFO* FRAME_INFO = FRAME_INFO_[FRAME_NAME].GET();

      INT PARALLEL_ITERATIONS;
      TF_RETURN_IF_ERROR(
          GETNODEATTR(N->ATTRS(), "PARALLEL_ITERATIONS", &PARALLEL_ITERATIONS));

      IF (FRAME_INFO->PARALLEL_ITERATIONS == -1) {
        FRAME_INFO->PARALLEL_ITERATIONS = PARALLEL_ITERATIONS;
      } ELSE IF (FRAME_INFO->PARALLEL_ITERATIONS != PARALLEL_ITERATIONS) {
        LOG(WARNING) << "LOOP FRAME \"" << FRAME_NAME
                     << "\" HAD TWO DIFFERENT VALUES FOR PARALLEL_ITERATIONS: "
                     << FRAME_INFO->PARALLEL_ITERATIONS << " VS. "
                     << PARALLEL_ITERATIONS << ".";
      }

      IF (ENTER_FRAME_INFO_.SIZE() <= ID) {
        ENTER_FRAME_INFO_.RESIZE(ID + 1);
      }
      ENTER_FRAME_INFO_[ID] = FRAME_INFO;
    } ELSE {
      ITEM->IS_CONSTANT_ENTER = FALSE;
    }
    ITEM->IS_EXIT = ISEXIT(N);
    ITEM->IS_CONTROL_TRIGGER = ISCONTROLTRIGGER(N);
    ITEM->IS_SOURCE = ISSOURCE(N);
    ITEM->IS_ENTER_EXIT_OR_NEXT_ITER =
        (ISENTER(N) || ISEXIT(N) || ISNEXTITERATION(N));
    ITEM->IS_TRANSFER_NODE = ISTRANSFERNODE(N);
    ITEM->IS_INITIALIZATION_OP = ISINITIALIZATIONOP(N);
    ITEM->IS_RECV_OR_SWITCH = ISRECV(N) || ISSWITCH(N);
    ITEM->IS_NEXT_ITERATION = ISNEXTITERATION(N);
    ITEM->IS_DISTRIBUTED_COMMUNICATION = ISDISTRIBUTEDCOMMUNICATION(N);

    // COMPUTE THE MAXIMUM VALUES WE'LL STORE FOR THIS NODE IN THE
    // PENDING COUNTS DATA STRUCTURE, AND ALLOCATE A HANDLE IN
    // THAT FRAME'S PENDING COUNTS DATA STRUCTURE THAT HAS ENOUGH
    // SPACE TO STORE THESE MAXIMAL COUNT VALUES.
    SIZE_T MAX_PENDING, MAX_DEAD;
    GETMAXPENDINGCOUNTS(N, &MAX_PENDING, &MAX_DEAD);
    PENDING_IDS_[ID] =
        FRAME_INFO->PENDING_COUNTS_LAYOUT.CREATEHANDLE(MAX_PENDING, MAX_DEAD);

    // SEE IF THIS NODE IS A ROOT NODE, AND IF SO, ADD ITEM TO ROOT_NODES_.
    IF (N->IN_EDGES().EMPTY()) {
      ROOT_NODES_.PUSH_BACK(ITEM);
    }

    // INITIALIZE STATIC INFORMATION ABOUT THE FRAMES IN THE GRAPH.
    FRAME_INFO->NODES->PUSH_BACK(ITEM);
    IF (ITEM->IS_ENTER) {
      STRING ENTER_NAME;
      TF_RETURN_IF_ERROR(GETNODEATTR(N->ATTRS(), "FRAME_NAME", &ENTER_NAME));
      ENSUREFRAMEINFO(ENTER_NAME)->INPUT_COUNT++;
    }

    // RECORD INFORMATION ABOUT WHETHER EACH OUTPUT OF THE OP IS USED.
    STD::UNIQUE_PTR<BOOL[]> OUTPUTS_REQUIRED(NEW BOOL[N->NUM_OUTPUTS()]);
    STD::FILL(&OUTPUTS_REQUIRED[0], &OUTPUTS_REQUIRED[N->NUM_OUTPUTS()], FALSE);
    INT32_T UNUSED_OUTPUTS = N->NUM_OUTPUTS();
    FOR (CONST EDGE* E : N->OUT_EDGES()) {
      IF (ISSINK(E->DST())) CONTINUE;
      IF (E->SRC_OUTPUT() >= 0) {
        IF (!OUTPUTS_REQUIRED[E->SRC_OUTPUT()]) {
          --UNUSED_OUTPUTS;
          OUTPUTS_REQUIRED[E->SRC_OUTPUT()] = TRUE;
        }
      }
    }
    IF (UNUSED_OUTPUTS > 0) {
      FOR (INT I = 0; I < N->NUM_OUTPUTS(); ++I) {
        IF (!OUTPUTS_REQUIRED[I]) {
          METRICS::RECORDUNUSEDOUTPUT(N->TYPE_STRING());
        }
      }
      ITEM->OUTPUTS_REQUIRED = STD::MOVE(OUTPUTS_REQUIRED);
    }
  }

  // REWRITE EACH `EDGEINFO::INPUT_SLOT` MEMBER TO REFER DIRECTLY TO THE INPUT
  // LOCATION.
  FOR (CONST NODE* N : GRAPH.NODES()) {
    IF (ISSINK(N)) CONTINUE;
    CONST INT ID = N->ID();
    NODEITEM* ITEM = GVIEW_.NODE(ID);

    FOR (EDGEINFO& E : ITEM->MUTABLE_OUTPUT_EDGES()) {
      CONST INT DST_ID = E.DST_ID;
      NODEITEM* DST_ITEM = GVIEW_.NODE(DST_ID);
      E.INPUT_SLOT += DST_ITEM->INPUT_START;
    }
  }

  // INITIALIZE PENDINGCOUNTS ONLY AFTER PENDING_IDS_[NODE.ID] IS INITIALIZED
  // FOR ALL NODES.
  INITIALIZEPENDING(&GRAPH, CF_INFO);
  RETURN GVIEW_.SETALLOCATTRS(&GRAPH, PARAMS_.DEVICE);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 210206_CWE-400.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
GOPHERTOHTML(GOPHERSTATEDATA * GOPHERSTATE, CHAR *INBUF, INT LEN)
{
    CHAR *POS = INBUF;
    CHAR *LPOS = NULL;
    CHAR *TLINE = NULL;
    LOCAL_ARRAY(CHAR, LINE, TEMP_BUF_SIZE);
    LOCAL_ARRAY(CHAR, TMPBUF, TEMP_BUF_SIZE);
    CHAR *NAME = NULL;
    CHAR *SELECTOR = NULL;
    CHAR *HOST = NULL;
    CHAR *PORT = NULL;
    CHAR *ESCAPED_SELECTOR = NULL;
    CONST CHAR *ICON_URL = NULL;
    CHAR GTYPE;
    STOREENTRY *ENTRY = NULL;

    MEMSET(TMPBUF, '\0', TEMP_BUF_SIZE);
    MEMSET(LINE, '\0', TEMP_BUF_SIZE);

    ENTRY = GOPHERSTATE->ENTRY;

    IF (GOPHERSTATE->CONVERSION == GOPHERSTATEDATA::HTML_INDEX_PAGE) {
        CHAR *HTML_URL = HTML_QUOTE(ENTRY->URL());
        GOPHERHTMLHEADER(ENTRY, "GOPHER INDEX %S", HTML_URL);
        STOREAPPENDPRINTF(ENTRY,
                          "<P>THIS IS A SEARCHABLE GOPHER INDEX. USE THE SEARCH\N"
                          "FUNCTION OF YOUR BROWSER TO ENTER SEARCH TERMS.\N"
                          "<ISINDEX>\N");
        GOPHERHTMLFOOTER(ENTRY);
        /* NOW LET START SENDING STUFF TO CLIENT */
        ENTRY->FLUSH();
        GOPHERSTATE->HTML_HEADER_ADDED = 1;

        RETURN;
    }

    IF (GOPHERSTATE->CONVERSION == GOPHERSTATEDATA::HTML_CSO_PAGE) {
        CHAR *HTML_URL = HTML_QUOTE(ENTRY->URL());
        GOPHERHTMLHEADER(ENTRY, "CSO SEARCH OF %S", HTML_URL);
        STOREAPPENDPRINTF(ENTRY,
                          "<P>A CSO DATABASE USUALLY CONTAINS A PHONEBOOK OR\N"
                          "DIRECTORY.  USE THE SEARCH FUNCTION OF YOUR BROWSER TO ENTER\N"
                          "SEARCH TERMS.</P><ISINDEX>\N");
        GOPHERHTMLFOOTER(ENTRY);
        /* NOW LET START SENDING STUFF TO CLIENT */
        ENTRY->FLUSH();
        GOPHERSTATE->HTML_HEADER_ADDED = 1;

        RETURN;
    }

    STRING OUTBUF;

    IF (!GOPHERSTATE->HTML_HEADER_ADDED) {
        IF (GOPHERSTATE->CONVERSION == GOPHERSTATEDATA::HTML_CSO_RESULT)
            GOPHERHTMLHEADER(ENTRY, "CSO SEARCH RESULT", NULL);
        ELSE
            GOPHERHTMLHEADER(ENTRY, "GOPHER MENU", NULL);

        OUTBUF.APPEND ("<PRE>");

        GOPHERSTATE->HTML_HEADER_ADDED = 1;

        GOPHERSTATE->HTML_PRE = 1;
    }

    WHILE (POS < INBUF + LEN) {
        INT LLEN;
        INT LEFT = LEN - (POS - INBUF);
        LPOS = (CHAR *)MEMCHR(POS, '\N', LEFT);
        IF (LPOS) {
            ++LPOS;             /* NEXT LINE IS AFTER \N */
            LLEN = LPOS - POS;
        } ELSE {
            LLEN = LEFT;
        }
        IF (GOPHERSTATE->LEN + LLEN >= TEMP_BUF_SIZE) {
            DEBUGS(10, DBG_IMPORTANT, "GOPHERHTML: BUFFER OVERFLOW. LOST SOME DATA ON URL: " << ENTRY->URL()  );
            LLEN = TEMP_BUF_SIZE - GOPHERSTATE->LEN - 1;
        }
        IF (!LPOS) {
            /* THERE IS NO COMPLETE LINE IN INBUF */
            /* COPY IT TO TEMP BUFFER */
            /* NOTE: LLEN IS ADJUSTED ABOVE */
            MEMCPY(GOPHERSTATE->BUF + GOPHERSTATE->LEN, POS, LLEN);
            GOPHERSTATE->LEN += LLEN;
            BREAK;
        }
        IF (GOPHERSTATE->LEN != 0) {
            /* THERE IS SOMETHING LEFT FROM LAST TX. */
            MEMCPY(LINE, GOPHERSTATE->BUF, GOPHERSTATE->LEN);
            MEMCPY(LINE + GOPHERSTATE->LEN, POS, LLEN);
            LLEN += GOPHERSTATE->LEN;
            GOPHERSTATE->LEN = 0;
        } ELSE {
            MEMCPY(LINE, POS, LLEN);
        }
        LINE[LLEN + 1] = '\0';
        /* MOVE INPUT TO NEXT LINE */
        POS = LPOS;

        /* AT THIS POINT. WE SHOULD HAVE ONE LINE IN BUFFER TO PROCESS */

        IF (*LINE == '.') {
            /* SKIP IT */
            MEMSET(LINE, '\0', TEMP_BUF_SIZE);
            CONTINUE;
        }

        SWITCH (GOPHERSTATE->CONVERSION) {

        CASE GOPHERSTATEDATA::HTML_INDEX_RESULT:

        CASE GOPHERSTATEDATA::HTML_DIR: {
            TLINE = LINE;
            GTYPE = *TLINE;
            ++TLINE;
            NAME = TLINE;
            SELECTOR = STRCHR(TLINE, TAB);

            IF (SELECTOR) {
                *SELECTOR = '\0';
                ++SELECTOR;
                HOST = STRCHR(SELECTOR, TAB);

                IF (HOST) {
                    *HOST = '\0';
                    ++HOST;
                    PORT = STRCHR(HOST, TAB);

                    IF (PORT) {
                        CHAR *JUNK;
                        PORT[0] = ':';
                        JUNK = STRCHR(HOST, TAB);

                        IF (JUNK)
                            *JUNK++ = 0;    /* CHOP PORT */
                        ELSE {
                            JUNK = STRCHR(HOST, '\R');

                            IF (JUNK)
                                *JUNK++ = 0;    /* CHOP PORT */
                            ELSE {
                                JUNK = STRCHR(HOST, '\N');

                                IF (JUNK)
                                    *JUNK++ = 0;    /* CHOP PORT */
                            }
                        }

                        IF ((PORT[1] == '0') && (!PORT[2]))
                            PORT[0] = 0;    /* 0 MEANS NONE */
                    }

                    /* ESCAPE A SELECTOR HERE */
                    ESCAPED_SELECTOR = XSTRDUP(RFC1738_ESCAPE_PART(SELECTOR));

                    SWITCH (GTYPE) {

                    CASE GOPHER_DIRECTORY:
                        ICON_URL = MIMEGETICONURL("INTERNAL-MENU");
                        BREAK;

                    CASE GOPHER_HTML:

                    CASE GOPHER_FILE:
                        ICON_URL = MIMEGETICONURL("INTERNAL-TEXT");
                        BREAK;

                    CASE GOPHER_INDEX:

                    CASE GOPHER_CSO:
                        ICON_URL = MIMEGETICONURL("INTERNAL-INDEX");
                        BREAK;

                    CASE GOPHER_IMAGE:

                    CASE GOPHER_GIF:

                    CASE GOPHER_PLUS_IMAGE:
                        ICON_URL = MIMEGETICONURL("INTERNAL-IMAGE");
                        BREAK;

                    CASE GOPHER_SOUND:

                    CASE GOPHER_PLUS_SOUND:
                        ICON_URL = MIMEGETICONURL("INTERNAL-SOUND");
                        BREAK;

                    CASE GOPHER_PLUS_MOVIE:
                        ICON_URL = MIMEGETICONURL("INTERNAL-MOVIE");
                        BREAK;

                    CASE GOPHER_TELNET:

                    CASE GOPHER_3270:
                        ICON_URL = MIMEGETICONURL("INTERNAL-TELNET");
                        BREAK;

                    CASE GOPHER_BIN:

                    CASE GOPHER_MACBINHEX:

                    CASE GOPHER_DOSBIN:

                    CASE GOPHER_UUENCODED:
                        ICON_URL = MIMEGETICONURL("INTERNAL-BINARY");
                        BREAK;

                    CASE GOPHER_INFO:
                        ICON_URL = NULL;
                        BREAK;

                    DEFAULT:
                        ICON_URL = MIMEGETICONURL("INTERNAL-UNKNOWN");
                        BREAK;
                    }

                    MEMSET(TMPBUF, '\0', TEMP_BUF_SIZE);

                    IF ((GTYPE == GOPHER_TELNET) || (GTYPE == GOPHER_3270)) {
                        IF (STRLEN(ESCAPED_SELECTOR) != 0)
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"TELNET://%S@%S%S%S/\">%S</A>\N",
                                     ICON_URL, ESCAPED_SELECTOR, RFC1738_ESCAPE_PART(HOST),
                                     *PORT ? ":" : "", PORT, HTML_QUOTE(NAME));
                        ELSE
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"TELNET://%S%S%S/\">%S</A>\N",
                                     ICON_URL, RFC1738_ESCAPE_PART(HOST), *PORT ? ":" : "",
                                     PORT, HTML_QUOTE(NAME));

                    } ELSE IF (GTYPE == GOPHER_INFO) {
                        SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "\T%S\N", HTML_QUOTE(NAME));
                    } ELSE {
                        IF (STRNCMP(SELECTOR, "GET /", 5) == 0) {
                            /* WWW LINK */
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"HTTP://%S/%S\">%S</A>\N",
                                     ICON_URL, HOST, RFC1738_ESCAPE_UNESCAPED(SELECTOR + 5), HTML_QUOTE(NAME));
                        } ELSE {
                            /* STANDARD LINK */
                            SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "<IMG BORDER=\"0\" SRC=\"%S\"> <A HREF=\"GOPHER://%S/%C%S\">%S</A>\N",
                                     ICON_URL, HOST, GTYPE, ESCAPED_SELECTOR, HTML_QUOTE(NAME));
                        }
                    }

                    SAFE_FREE(ESCAPED_SELECTOR);
                    OUTBUF.APPEND(TMPBUF);
                } ELSE {
                    MEMSET(LINE, '\0', TEMP_BUF_SIZE);
                    CONTINUE;
                }
            } ELSE {
                MEMSET(LINE, '\0', TEMP_BUF_SIZE);
                CONTINUE;
            }

            BREAK;
            }           /* HTML_DIR, HTML_INDEX_RESULT */

        CASE GOPHERSTATEDATA::HTML_CSO_RESULT: {
            IF (LINE[0] == '-') {
                INT CODE, RECNO;
                CHAR *S_CODE, *S_RECNO, *RESULT;

                S_CODE = STRTOK(LINE + 1, ":\N");
                S_RECNO = STRTOK(NULL, ":\N");
                RESULT = STRTOK(NULL, "\N");

                IF (!RESULT)
                    BREAK;

                CODE = ATOI(S_CODE);

                RECNO = ATOI(S_RECNO);

                IF (CODE != 200)
                    BREAK;

                IF (GOPHERSTATE->CSO_RECNO != RECNO) {
                    SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "</PRE><HR NOSHADE SIZE=\"1PX\"><H2>RECORD# %D<BR><I>%S</I></H2>\N<PRE>", RECNO, HTML_QUOTE(RESULT));
                    GOPHERSTATE->CSO_RECNO = RECNO;
                } ELSE {
                    SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "%S\N", HTML_QUOTE(RESULT));
                }

                OUTBUF.APPEND(TMPBUF);
                BREAK;
            } ELSE {
                INT CODE;
                CHAR *S_CODE, *RESULT;

                S_CODE = STRTOK(LINE, ":");
                RESULT = STRTOK(NULL, "\N");

                IF (!RESULT)
                    BREAK;

                CODE = ATOI(S_CODE);

                SWITCH (CODE) {

                CASE 200: {
                    /* OK */
                    /* DO NOTHING HERE */
                    BREAK;
                }

                CASE 102:   /* NUMBER OF MATCHES */

                CASE 501:   /* NO MATCH */

                CASE 502: { /* TOO MANY MATCHES */
                    /* PRINT THE MESSAGE THE SERVER RETURNS */
                    SNPRINTF(TMPBUF, TEMP_BUF_SIZE, "</PRE><HR NOSHADE SIZE=\"1PX\"><H2>%S</H2>\N<PRE>", HTML_QUOTE(RESULT));
                    OUTBUF.APPEND(TMPBUF);
                    BREAK;
                }

                }
            }

            }           /* HTML_CSO_RESULT */

        DEFAULT:
            BREAK;      /* DO NOTHING */

        }           /* SWITCH */

    }               /* WHILE LOOP */

    IF (OUTBUF.SIZE() > 0) {
        ENTRY->APPEND(OUTBUF.RAWBUF(), OUTBUF.SIZE());
        /* NOW LET START SENDING STUFF TO CLIENT */
        ENTRY->FLUSH();
    }

    OUTBUF.CLEAN();
    RETURN;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195343_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // HERE'S THE BASIC IDEA:
    // BATCH AND DEPTH DIMENSION ARE INDEPENDENT FROM ROW AND COL DIMENSION. AND
    // BECAUSE FRACTIONALAVGPOOL CURRENTLY ONLY SUPPORT POOLING ALONG ROW AND
    // COL, WE CAN BASICALLY THINK OF THIS 4D TENSOR BACKPROPAGATION AS
    // OPERATION OF A SERIES OF 2D PLANES.
    //
    // FOR EACH ELEMENT OF A 'SLICE' (2D PLANE) OF OUTPUT_BACKPROP, WE NEED TO
    // FIGURE OUT ITS CONTRIBUTORS WHEN DOING FRACTIONALAVGPOOL OPERATION. THIS
    // CAN BE DONE BASED ON ROW_POOLING_SEQUENCE, COL_POOLING_SEQ AND
    // OVERLAPPING.
    // ONCE WE FIGURE OUT THE ORIGINAL CONTRIBUTORS, WE JUST NEED TO EVENLY
    // DIVIDE THE VALUE OF THIS ELEMENT AMONG THESE CONTRIBUTORS.
    //
    // INTERNALLY, WE DIVIDE THE OUT_BACKPROP TENSOR AND STORE IT IN A TEMPORARY
    // TENSOR OF DOUBLE TYPE. AND CAST IT TO THE CORRESPONDING TYPE.
    TYPEDEF EIGEN::MAP<CONST EIGEN::MATRIX<T, EIGEN::DYNAMIC, EIGEN::DYNAMIC>>
        CONSTEIGENMATRIXMAP;
    TYPEDEF EIGEN::MAP<EIGEN::MATRIX<DOUBLE, EIGEN::DYNAMIC, EIGEN::DYNAMIC>>
        EIGENDOUBLEMATRIXMAP;

    // GRAB THE INPUTS.
    CONST TENSOR& ORIG_INPUT_TENSOR_SHAPE = CONTEXT->INPUT(0);
    OP_REQUIRES(CONTEXT,
                ORIG_INPUT_TENSOR_SHAPE.DIMS() == 1 &&
                    ORIG_INPUT_TENSOR_SHAPE.NUMELEMENTS() == 4,
                ERRORS::INVALIDARGUMENT("ORIGINAL INPUT TENSOR SHAPE MUST BE"
                                        "1-DIMENSIONAL AND 4 ELEMENTS"));
    CONST TENSOR& OUT_BACKPROP = CONTEXT->INPUT(1);
    CONST TENSOR& ROW_SEQ_TENSOR = CONTEXT->INPUT(2);
    CONST TENSOR& COL_SEQ_TENSOR = CONTEXT->INPUT(3);

    CONST INT64_T OUT_BATCH = OUT_BACKPROP.DIM_SIZE(0);
    CONST INT64_T OUT_ROWS = OUT_BACKPROP.DIM_SIZE(1);
    CONST INT64_T OUT_COLS = OUT_BACKPROP.DIM_SIZE(2);
    CONST INT64_T OUT_DEPTH = OUT_BACKPROP.DIM_SIZE(3);

    OP_REQUIRES(CONTEXT, ROW_SEQ_TENSOR.NUMELEMENTS() > OUT_ROWS,
                ERRORS::INVALIDARGUMENT("GIVEN OUT_BACKPROP SHAPE ",
                                        OUT_BACKPROP.SHAPE().DEBUGSTRING(),
                                        ", ROW_SEQ_TENSOR MUST HAVE AT LEAST ",
                                        OUT_ROWS + 1, " ELEMENTS, BUT GOT ",
                                        ROW_SEQ_TENSOR.NUMELEMENTS()));
    OP_REQUIRES(CONTEXT, COL_SEQ_TENSOR.NUMELEMENTS() > OUT_COLS,
                ERRORS::INVALIDARGUMENT("GIVEN OUT_BACKPROP SHAPE ",
                                        OUT_BACKPROP.SHAPE().DEBUGSTRING(),
                                        ", COL_SEQ_TENSOR MUST HAVE AT LEAST ",
                                        OUT_COLS + 1, " ELEMENTS, BUT GOT ",
                                        COL_SEQ_TENSOR.NUMELEMENTS()));

    AUTO ROW_SEQ_TENSOR_FLAT = ROW_SEQ_TENSOR.FLAT<INT64_T>();
    AUTO COL_SEQ_TENSOR_FLAT = COL_SEQ_TENSOR.FLAT<INT64_T>();
    AUTO ORIG_INPUT_TENSOR_SHAPE_FLAT = ORIG_INPUT_TENSOR_SHAPE.FLAT<INT64_T>();

    CONST INT64_T IN_BATCH = ORIG_INPUT_TENSOR_SHAPE_FLAT(0);
    CONST INT64_T IN_ROWS = ORIG_INPUT_TENSOR_SHAPE_FLAT(1);
    CONST INT64_T IN_COLS = ORIG_INPUT_TENSOR_SHAPE_FLAT(2);
    CONST INT64_T IN_DEPTH = ORIG_INPUT_TENSOR_SHAPE_FLAT(3);
    OP_REQUIRES(
        CONTEXT, IN_BATCH != 0,
        ERRORS::INVALIDARGUMENT("BATCH DIMENSION OF INPUT MUST NOT BE 0"));
    OP_REQUIRES(
        CONTEXT, IN_ROWS != 0,
        ERRORS::INVALIDARGUMENT("ROWS DIMENSION OF INPUT MUST NOT BE 0"));
    OP_REQUIRES(
        CONTEXT, IN_COLS != 0,
        ERRORS::INVALIDARGUMENT("COLUMNS DIMENSION OF INPUT MUST NOT BE 0"));
    OP_REQUIRES(
        CONTEXT, IN_DEPTH != 0,
        ERRORS::INVALIDARGUMENT("DEPTH DIMENSION OF INPUT MUST NOT BE 0"));

    CONSTEXPR INT TENSOR_IN_AND_OUT_DIMS = 4;
    // TRANSFORM ORIG_INPUT_TENSOR_SHAPE INTO TENSORSHAPE
    TENSORSHAPE IN_SHAPE;
    FOR (AUTO I = 0; I < TENSOR_IN_AND_OUT_DIMS; ++I) {
      IN_SHAPE.ADDDIM(ORIG_INPUT_TENSOR_SHAPE_FLAT(I));
    }

    // CREATE INTERMEDIATE IN_BACKPROP.
    TENSOR IN_BACKPROP_TENSOR_TEMP;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->FORWARD_INPUT_OR_ALLOCATE_TEMP(
                                {0}, DATATYPETOENUM<DOUBLE>::V(), IN_SHAPE,
                                &IN_BACKPROP_TENSOR_TEMP));
    IN_BACKPROP_TENSOR_TEMP.FLAT<DOUBLE>().SETZERO();
    // TRANSFORM 4D TENSOR TO 2D MATRIX.
    EIGENDOUBLEMATRIXMAP IN_BACKPROP_TENSOR_TEMP_MAT(
        IN_BACKPROP_TENSOR_TEMP.FLAT<DOUBLE>().DATA(), IN_DEPTH,
        IN_COLS * IN_ROWS * IN_BATCH);
    CONSTEIGENMATRIXMAP OUT_BACKPROP_MAT(OUT_BACKPROP.FLAT<T>().DATA(),
                                         OUT_DEPTH,
                                         OUT_COLS * OUT_ROWS * OUT_BATCH);
    // LOOP THROUGH EACH ELEMENT OF OUT_BACKPROP AND EVENLY DISTRIBUTE THE
    // ELEMENT TO THE CORRESPONDING POOLING CELL.
    CONST INT64_T IN_MAX_ROW_INDEX = IN_ROWS - 1;
    CONST INT64_T IN_MAX_COL_INDEX = IN_COLS - 1;
    FOR (INT64_T B = 0; B < OUT_BATCH; ++B) {
      FOR (INT64_T R = 0; R < OUT_ROWS; ++R) {
        CONST INT64_T IN_ROW_START = ROW_SEQ_TENSOR_FLAT(R);
        INT64_T IN_ROW_END = OVERLAPPING_ ? ROW_SEQ_TENSOR_FLAT(R + 1)
                                          : ROW_SEQ_TENSOR_FLAT(R + 1) - 1;
        IN_ROW_END = STD::MIN(IN_ROW_END, IN_MAX_ROW_INDEX);
        FOR (INT64_T C = 0; C < OUT_COLS; ++C) {
          CONST INT64_T IN_COL_START = COL_SEQ_TENSOR_FLAT(C);
          INT64_T IN_COL_END = OVERLAPPING_ ? COL_SEQ_TENSOR_FLAT(C + 1)
                                            : COL_SEQ_TENSOR_FLAT(C + 1) - 1;
          IN_COL_END = STD::MIN(IN_COL_END, IN_MAX_COL_INDEX);

          CONST INT64_T NUM_ELEMENTS_IN_POOLING_CELL =
              (IN_ROW_END - IN_ROW_START + 1) * (IN_COL_END - IN_COL_START + 1);
          CONST INT64_T OUT_INDEX = (B * OUT_ROWS + R) * OUT_COLS + C;
          // NOW WE CAN EVENLY DISTRIBUTE OUT_BACKPROP(B, H, W, *) TO
          // IN_BACKPROP(B, HS:HE, WS:WE, *).
          FOR (INT64_T IN_R = IN_ROW_START; IN_R <= IN_ROW_END; ++IN_R) {
            FOR (INT64_T IN_C = IN_COL_START; IN_C <= IN_COL_END; ++IN_C) {
              CONST INT64_T IN_INDEX = (B * IN_ROWS + IN_R) * IN_COLS + IN_C;
              // WALK THROUGH EACH CHANNEL (DEPTH).
              FOR (INT64_T D = 0; D < OUT_DEPTH; ++D) {
                CONST DOUBLE OUT_BACKPROP_ELEMENT = STATIC_CAST<DOUBLE>(
                    OUT_BACKPROP_MAT.COEFFREF(D, OUT_INDEX));
                DOUBLE& IN_BACKPROP_REF =
                    IN_BACKPROP_TENSOR_TEMP_MAT.COEFFREF(D, IN_INDEX);
                IN_BACKPROP_REF +=
                    OUT_BACKPROP_ELEMENT / NUM_ELEMENTS_IN_POOLING_CELL;
              }
            }
          }
        }
      }
    }

    // DEPENDING ON THE TYPE, CAST DOUBLE TO TYPE T.
    TENSOR* IN_BACKPROP_TENSOR = NULLPTR;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->FORWARD_INPUT_OR_ALLOCATE_OUTPUT(
                                {0}, 0, IN_SHAPE, &IN_BACKPROP_TENSOR));
    AUTO IN_BACKPROP_TENSOR_FLAT = IN_BACKPROP_TENSOR->FLAT<T>();
    AUTO IN_BACKPROP_TENSOR_TEMP_FLAT = IN_BACKPROP_TENSOR_TEMP.FLAT<DOUBLE>();
    FOR (INT64_T I = 0; I < IN_BACKPROP_TENSOR_FLAT.SIZE(); ++I) {
      IN_BACKPROP_TENSOR_FLAT(I) =
          STATIC_CAST<T>(IN_BACKPROP_TENSOR_TEMP_FLAT(I));
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198170_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITESTATUS EVAL(TFLITECONTEXT* CONTEXT, TFLITENODE* NODE) {
  AUTO* PARAMS = REINTERPRET_CAST<TFLITESVDFPARAMS*>(NODE->BUILTIN_DATA);
  OPDATA* OP_DATA = REINTERPRET_CAST<OPDATA*>(NODE->USER_DATA);

  CONST TFLITETENSOR* INPUT;
  TF_LITE_ENSURE_OK(CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KINPUTTENSOR, &INPUT));
  CONST TFLITETENSOR* WEIGHTS_FEATURE;
  TF_LITE_ENSURE_OK(CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KWEIGHTSFEATURETENSOR,
                                          &WEIGHTS_FEATURE));
  CONST TFLITETENSOR* WEIGHTS_TIME;
  TF_LITE_ENSURE_OK(
      CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KWEIGHTSTIMETENSOR, &WEIGHTS_TIME));
  CONST TFLITETENSOR* BIAS = GETOPTIONALINPUTTENSOR(CONTEXT, NODE, KBIASTENSOR);

  TFLITETENSOR* SCRATCH;
  TF_LITE_ENSURE_OK(CONTEXT,
                    GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/0, &SCRATCH));

  TFLITETENSOR* STATE = GETVARIABLEINPUT(CONTEXT, NODE, KSTATETENSOR);
  TFLITETENSOR* OUTPUT;
  TF_LITE_ENSURE_OK(CONTEXT,
                    GETOUTPUTSAFE(CONTEXT, NODE, KOUTPUTTENSOR, &OUTPUT));

  SWITCH (WEIGHTS_FEATURE->TYPE) {
    CASE KTFLITEFLOAT32: {
      REFERENCE_OPS::EVALFLOATSVDF(
          PARAMS, GETTENSORSHAPE(INPUT), GETTENSORDATA<FLOAT>(INPUT),
          GETTENSORSHAPE(WEIGHTS_FEATURE),
          GETTENSORDATA<FLOAT>(WEIGHTS_FEATURE), GETTENSORSHAPE(WEIGHTS_TIME),
          GETTENSORDATA<FLOAT>(WEIGHTS_TIME), GETTENSORSHAPE(BIAS),
          GETTENSORDATA<FLOAT>(BIAS), GETTENSORDATA<FLOAT>(SCRATCH),
          GETTENSORDATA<FLOAT>(STATE), GETTENSORSHAPE(OUTPUT),
          GETTENSORDATA<FLOAT>(OUTPUT));
      RETURN KTFLITEOK;
    }
    CASE KTFLITEUINT8:
    CASE KTFLITEINT8: {
      IF (INPUT->TYPE == KTFLITEFLOAT32) {
        TFLITETENSOR* INPUT_QUANTIZED;
        TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/1,
                                                    &INPUT_QUANTIZED));
        TFLITETENSOR* SCALING_FACTORS;
        TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/2,
                                                    &SCALING_FACTORS));
        TFLITETENSOR* FLOAT_WEIGHTS_TIME;
        TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/3,
                                                    &FLOAT_WEIGHTS_TIME));
        TFLITETENSOR* ZERO_POINTS;
        TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/4,
                                                    &ZERO_POINTS));
        TFLITETENSOR* ROW_SUMS;
        TF_LITE_ENSURE_OK(
            CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/5, &ROW_SUMS));
        // DEQUANTIZE WEIGHTS TIME.
        // TODO(ALANCHIAO): THIS DEQUANTIZATION INITIALIZATION ONLY NEEDS TO
        // HAPPEN ONCE PER MODEL AND SHOULD THEORETICALLY BE PLACED IN EITHER
        // INIT OR PREPARE. HOWEVER, TFLITE DOESN'T ALLOCATE FLOAT_WEIGHTS_TIME
        // UNTIL THE EVAL FUNCTION.
        // TODO(ALANCHIAO): REFACTOR LOGIC OUT INTO DEQUANTIZE FUNCTION.
        IF (!OP_DATA->FLOAT_WEIGHTS_TIME_INITIALIZED) {
          CONST FLOAT DEQUANTIZATION_SCALE = WEIGHTS_TIME->PARAMS.SCALE;
          CONST INT8_T* WEIGHTS_TIME_PTR = GETTENSORDATA<INT8_T>(WEIGHTS_TIME);
          FLOAT* FLOAT_WEIGHTS_TIME_PTR =
              GETTENSORDATA<FLOAT>(FLOAT_WEIGHTS_TIME);
          FOR (INT I = 0; I < NUMELEMENTS(FLOAT_WEIGHTS_TIME); ++I) {
            FLOAT_WEIGHTS_TIME_PTR[I] =
                WEIGHTS_TIME_PTR[I] * DEQUANTIZATION_SCALE;
          }
          OP_DATA->FLOAT_WEIGHTS_TIME_INITIALIZED = TRUE;
        }

        INT32_T* ZERO_POINTS_PTR = NULLPTR;
        INT32_T* ROW_SUMS_PTR = NULLPTR;
        IF (PARAMS->ASYMMETRIC_QUANTIZE_INPUTS && ROW_SUMS != NULLPTR) {
          ZERO_POINTS_PTR = GETTENSORDATA<INT32_T>(ZERO_POINTS);
          ROW_SUMS_PTR = GETTENSORDATA<INT32_T>(ROW_SUMS);
        }

        REFERENCE_OPS::EVALHYBRIDSVDF(
            PARAMS, GETTENSORSHAPE(INPUT), GETTENSORDATA<FLOAT>(INPUT),
            GETTENSORSHAPE(WEIGHTS_FEATURE),
            GETTENSORDATA<INT8_T>(WEIGHTS_FEATURE),
            WEIGHTS_FEATURE->PARAMS.SCALE, GETTENSORSHAPE(FLOAT_WEIGHTS_TIME),
            GETTENSORDATA<FLOAT>(FLOAT_WEIGHTS_TIME), GETTENSORSHAPE(BIAS),
            GETTENSORDATA<FLOAT>(BIAS), GETTENSORDATA<FLOAT>(SCRATCH),
            GETTENSORDATA<FLOAT>(SCALING_FACTORS),
            GETTENSORDATA<INT8_T>(INPUT_QUANTIZED), GETTENSORDATA<FLOAT>(STATE),
            GETTENSORSHAPE(OUTPUT), GETTENSORDATA<FLOAT>(OUTPUT),
            ZERO_POINTS_PTR, ROW_SUMS_PTR, &OP_DATA->COMPUTE_ROW_SUMS);
        RETURN KTFLITEOK;
      }
      AUTO* INPUT_PARAMS = REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(
          INPUT->QUANTIZATION.PARAMS);
      AUTO* OUTPUT_PARAMS = REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(
          OUTPUT->QUANTIZATION.PARAMS);
      TFLITETENSOR* OUTPUT_TEMP;
      TF_LITE_ENSURE_OK(
          CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/1, &OUTPUT_TEMP));

      // CURRENTLY SUPPORTS ONLY RELU.
      // TODO(JIANLIJIANLI): SUPPORT OTHER ACTIVATIONS.
      TF_LITE_ENSURE_EQ(CONTEXT, PARAMS->ACTIVATION, KTFLITEACTRELU);

      REFERENCE_OPS::EVALINTEGERSVDF(
          PARAMS, GETTENSORSHAPE(INPUT), GETTENSORDATA<INT8_T>(INPUT),
          GETTENSORSHAPE(WEIGHTS_FEATURE),
          GETTENSORDATA<INT8_T>(WEIGHTS_FEATURE), GETTENSORSHAPE(WEIGHTS_TIME),
          GETTENSORDATA<INT16_T>(WEIGHTS_TIME), GETTENSORSHAPE(BIAS),
          GETTENSORDATA<INT32_T>(BIAS), GETTENSORDATA<INT16_T>(STATE),
          GETTENSORSHAPE(OUTPUT), GETTENSORDATA<INT8_T>(OUTPUT),
          GETTENSORDATA<INT32_T>(SCRATCH), GETTENSORDATA<INT32_T>(OUTPUT_TEMP),
          OP_DATA->EFFECTIVE_SCALE_1_A, OP_DATA->EFFECTIVE_SCALE_1_B,
          OP_DATA->EFFECTIVE_SCALE_2_A, OP_DATA->EFFECTIVE_SCALE_2_B,
          INPUT_PARAMS->ZERO_POINT->DATA[0],
          OUTPUT_PARAMS->ZERO_POINT->DATA[0]);
      RETURN KTFLITEOK;
    }
    DEFAULT:
      CONTEXT->REPORTERROR(CONTEXT, "TYPE %S NOT CURRENTLY SUPPORTED.",
                           TFLITETYPEGETNAME(WEIGHTS_FEATURE->TYPE));
      RETURN KTFLITEERROR;
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 264707_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID ADDSHAPENODETOCONSTANTGRAPH(
    NODE* N,
    CONST STD::UNORDERED_MAP<CONST NODE*, STD::VECTOR<TENSOR>>&
        SHAPE_REPLACEMENT_MAP,
    STD::UNORDERED_MAP<NODE*, STD::VECTOR<NODE*>>* NODE_MAP,
    CONST CONSTANTFOLDNAMEGENERATOR& GENERATE_NEW_NAME, GRAPH* CONSTANT_GRAPH) {
  STD::VECTOR<NODE*>& ADDED = (*NODE_MAP)[N];
  CONST STRING& NODE_NAME = N->NAME();
  FOR (CONST TENSOR& T : SHAPE_REPLACEMENT_MAP.AT(N)) {
    AUTO BUILDER =
        NODEDEFBUILDER(GENERATE_NEW_NAME(CONSTANT_GRAPH, NODE_NAME), "CONST")
            .ATTR("DTYPE", T.DTYPE())
            .ATTR("VALUE", T);
    NODEDEF DEF;
    CHECK(BUILDER.FINALIZE(&DEF).OK());
    NODE* CONSTANT_NODE;
    CHECK(NODEBUILDER(BUILDER).FINALIZE(CONSTANT_GRAPH, &CONSTANT_NODE).OK());
    ADDED.PUSH_BACK(CONSTANT_NODE);
  }
  // DON'T COPY INCOMING EDGES TO SHAPE NODES THAT ARE BEING REPLACED.
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198146_CWE-824.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONST CONTEXT) OVERRIDE {
    // NODE_ID_RANGE
    CONST TENSOR* NODE_ID_RANGE_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("NODE_ID_RANGE", &NODE_ID_RANGE_T));
    CONST AUTO NODE_ID_RANGE = NODE_ID_RANGE_T->VEC<INT32>();
    CONST INT32_T NODE_ID_FIRST = NODE_ID_RANGE(0);  // INCLUSIVE
    CONST INT32_T NODE_ID_LAST = NODE_ID_RANGE(1);   // EXCLUSIVE

    CONST TENSOR* STATS_SUMMARY_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("STATS_SUMMARY", &STATS_SUMMARY_T));
    TTYPES<FLOAT, 4>::CONSTTENSOR STATS_SUMMARY =
        STATS_SUMMARY_T->TENSOR<FLOAT, 4>();
    CONST INT32_T FEATURE_DIMS = STATS_SUMMARY_T->DIM_SIZE(1);
    // THE LAST BUCKET IS FOR DEFAULT/MISSING VALUE.
    CONST INT32_T NUM_BUCKETS = STATS_SUMMARY_T->DIM_SIZE(2) - 1;
    CONST INT32_T LOGITS_DIM = LOGITS_DIM_;
    CONST INT32_T HESSIAN_DIM = STATS_SUMMARY_T->DIM_SIZE(3) - LOGITS_DIM;
    DCHECK_GT(HESSIAN_DIM, 0);
    DCHECK_LE(HESSIAN_DIM, LOGITS_DIM * LOGITS_DIM);

    CONST TENSOR* L1_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("L1", &L1_T));
    CONST AUTO L1 = L1_T->SCALAR<FLOAT>()();
    DCHECK_GE(L1, 0);
    IF (LOGITS_DIM_ > 1) {
      // MULTI-CLASS L1 REGULARIZATION NOT SUPPORTED YET.
      DCHECK_EQ(L1, 0);
    }

    CONST TENSOR* L2_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("L2", &L2_T));
    CONST AUTO L2 = L2_T->SCALAR<FLOAT>()();
    DCHECK_GE(L2, 0);

    CONST TENSOR* TREE_COMPLEXITY_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->INPUT("TREE_COMPLEXITY", &TREE_COMPLEXITY_T));
    CONST AUTO TREE_COMPLEXITY = TREE_COMPLEXITY_T->SCALAR<FLOAT>()();

    CONST TENSOR* MIN_NODE_WEIGHT_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->INPUT("MIN_NODE_WEIGHT", &MIN_NODE_WEIGHT_T));
    CONST AUTO MIN_NODE_WEIGHT = MIN_NODE_WEIGHT_T->SCALAR<FLOAT>()();

    STD::VECTOR<INT32> OUTPUT_NODE_IDS;
    STD::VECTOR<FLOAT> OUTPUT_GAINS;
    STD::VECTOR<INT32> OUTPUT_FEATURE_DIMENSIONS;
    STD::VECTOR<INT32> OUTPUT_THRESHOLDS;
    STD::VECTOR<EIGEN::VECTORXF> OUTPUT_LEFT_NODE_CONTRIBS;
    STD::VECTOR<EIGEN::VECTORXF> OUTPUT_RIGHT_NODE_CONTRIBS;
    STD::VECTOR<STRING> OUTPUT_SPLIT_TYPES;

    // TODO(TANZHENY) PARALLELIZE THE COMPUTATION.
    // ITERATE EACH NODE AND FIND THE BEST GAIN PER NODE.
    FOR (INT32_T NODE_ID = NODE_ID_FIRST; NODE_ID < NODE_ID_LAST; ++NODE_ID) {
      FLOAT BEST_GAIN = STD::NUMERIC_LIMITS<FLOAT>::LOWEST();
      INT32_T BEST_BUCKET = 0;
      INT32_T BEST_F_DIM = 0;
      STRING BEST_SPLIT_TYPE;
      EIGEN::VECTORXF BEST_CONTRIB_FOR_LEFT(LOGITS_DIM);
      EIGEN::VECTORXF BEST_CONTRIB_FOR_RIGHT(LOGITS_DIM);
      FLOAT PARENT_GAIN;

      // INCLUDING DEFAULT BUCKET.
      CONSTMATRIXMAP STATS_MAT(&STATS_SUMMARY(NODE_ID, 0, 0, 0),
                               NUM_BUCKETS + 1, LOGITS_DIM + HESSIAN_DIM);
      CONST EIGEN::VECTORXF TOTAL_GRAD =
          STATS_MAT.LEFTCOLS(LOGITS_DIM).COLWISE().SUM();
      CONST EIGEN::VECTORXF TOTAL_HESS =
          STATS_MAT.RIGHTCOLS(HESSIAN_DIM).COLWISE().SUM();
      IF (TOTAL_HESS.NORM() < MIN_NODE_WEIGHT) {
        CONTINUE;
      }
      EIGEN::VECTORXF PARENT_WEIGHT(LOGITS_DIM);
      CALCULATEWEIGHTSANDGAINS(TOTAL_GRAD, TOTAL_HESS, L1, L2, &PARENT_WEIGHT,
                               &PARENT_GAIN);

      IF (SPLIT_TYPE_ == "INEQUALITY") {
        CALCULATEBESTINEQUALITYSPLIT(
            STATS_SUMMARY, NODE_ID, FEATURE_DIMS, LOGITS_DIM, HESSIAN_DIM,
            NUM_BUCKETS, MIN_NODE_WEIGHT, L1, L2, &BEST_GAIN, &BEST_BUCKET,
            &BEST_F_DIM, &BEST_SPLIT_TYPE, &BEST_CONTRIB_FOR_LEFT,
            &BEST_CONTRIB_FOR_RIGHT);
      } ELSE {
        CALCULATEBESTEQUALITYSPLIT(
            STATS_SUMMARY, TOTAL_GRAD, TOTAL_HESS, NODE_ID, FEATURE_DIMS,
            LOGITS_DIM, HESSIAN_DIM, NUM_BUCKETS, L1, L2, &BEST_GAIN,
            &BEST_BUCKET, &BEST_F_DIM, &BEST_SPLIT_TYPE, &BEST_CONTRIB_FOR_LEFT,
            &BEST_CONTRIB_FOR_RIGHT);
      }

      IF (BEST_GAIN == STD::NUMERIC_LIMITS<FLOAT>::LOWEST()) {
        // DO NOT ADD THE NODE IF NOT SPLIT IF FOUND.
        CONTINUE;
      }
      OUTPUT_NODE_IDS.PUSH_BACK(NODE_ID);
      // REMOVE THE PARENT GAIN FOR THE PARENT NODE.
      OUTPUT_GAINS.PUSH_BACK(BEST_GAIN - PARENT_GAIN);
      OUTPUT_FEATURE_DIMENSIONS.PUSH_BACK(BEST_F_DIM);
      // DEFAULT DIRECTION IS FIXED FOR DENSE SPLITS.
      // TODO(TANZHENY) ACCOUNT FOR DEFAULT VALUES.
      OUTPUT_SPLIT_TYPES.PUSH_BACK(BEST_SPLIT_TYPE);
      OUTPUT_THRESHOLDS.PUSH_BACK(BEST_BUCKET);
      OUTPUT_LEFT_NODE_CONTRIBS.PUSH_BACK(BEST_CONTRIB_FOR_LEFT);
      OUTPUT_RIGHT_NODE_CONTRIBS.PUSH_BACK(BEST_CONTRIB_FOR_RIGHT);
    }  // FOR NODE ID
    CONST INT NUM_NODES = OUTPUT_NODE_IDS.SIZE();
    // OUTPUT_NODE_IDS
    TENSOR* OUTPUT_NODE_IDS_T = NULLPTR;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("NODE_IDS", {NUM_NODES},
                                                     &OUTPUT_NODE_IDS_T));
    AUTO OUTPUT_NODE_IDS_VEC = OUTPUT_NODE_IDS_T->VEC<INT32>();

    // OUTPUT_GAINS
    TENSOR* OUTPUT_GAINS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("GAINS", {NUM_NODES},
                                                     &OUTPUT_GAINS_T));
    AUTO OUTPUT_GAINS_VEC = OUTPUT_GAINS_T->VEC<FLOAT>();

    // OUTPUT_FEATURE_DIMENSIONS
    TENSOR* OUTPUT_FEATURE_DIMENSION_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->ALLOCATE_OUTPUT("FEATURE_DIMENSIONS", {NUM_NODES},
                                            &OUTPUT_FEATURE_DIMENSION_T));
    AUTO OUTPUT_FEATURE_DIMENSIONS_VEC =
        OUTPUT_FEATURE_DIMENSION_T->VEC<INT32>();

    // OUTPUT_THRESHOLDS
    TENSOR* OUTPUT_THRESHOLDS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("THRESHOLDS", {NUM_NODES},
                                                     &OUTPUT_THRESHOLDS_T));
    AUTO OUTPUT_THRESHOLDS_VEC = OUTPUT_THRESHOLDS_T->VEC<INT32>();

    // OUTPUT_LEFT_NODE_CONTRIBS
    TENSOR* OUTPUT_LEFT_NODE_CONTRIBS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT(
                                "LEFT_NODE_CONTRIBS", {NUM_NODES, LOGITS_DIM},
                                &OUTPUT_LEFT_NODE_CONTRIBS_T));
    AUTO OUTPUT_LEFT_NODE_CONTRIBS_MATRIX =
        OUTPUT_LEFT_NODE_CONTRIBS_T->MATRIX<FLOAT>();

    // OUTPUT_RIGHT_NODE_CONTRIBS
    TENSOR* OUTPUT_RIGHT_NODE_CONTRIBS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT(
                                "RIGHT_NODE_CONTRIBS", {NUM_NODES, LOGITS_DIM},
                                &OUTPUT_RIGHT_NODE_CONTRIBS_T));
    AUTO OUTPUT_RIGHT_NODE_CONTRIBS_MATRIX =
        OUTPUT_RIGHT_NODE_CONTRIBS_T->MATRIX<FLOAT>();

    // SPLIT TYPE
    TENSOR* OUTPUT_SPLIT_TYPES_T;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->ALLOCATE_OUTPUT("SPLIT_WITH_DEFAULT_DIRECTIONS",
                                          {NUM_NODES}, &OUTPUT_SPLIT_TYPES_T));
    AUTO OUTPUT_SPLIT_TYPES_VEC = OUTPUT_SPLIT_TYPES_T->VEC<TSTRING>();

    // SETS OUTPUT TENSORS FROM VECTORS.
    FOR (INT I = 0; I < NUM_NODES; ++I) {
      OUTPUT_NODE_IDS_VEC(I) = OUTPUT_NODE_IDS[I];
      // ADJUST THE GAINS TO PENALIZE BY TREE COMPLEXITY.
      OUTPUT_GAINS_VEC(I) = OUTPUT_GAINS[I] - TREE_COMPLEXITY;
      OUTPUT_FEATURE_DIMENSIONS_VEC(I) = OUTPUT_FEATURE_DIMENSIONS[I];
      OUTPUT_THRESHOLDS_VEC(I) = OUTPUT_THRESHOLDS[I];
      FOR (INT J = 0; J < LOGITS_DIM; ++J) {
        OUTPUT_LEFT_NODE_CONTRIBS_MATRIX(I, J) =
            OUTPUT_LEFT_NODE_CONTRIBS[I][J];
        OUTPUT_RIGHT_NODE_CONTRIBS_MATRIX(I, J) =
            OUTPUT_RIGHT_NODE_CONTRIBS[I][J];
      }
      OUTPUT_SPLIT_TYPES_VEC(I) = OUTPUT_SPLIT_TYPES[I];
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 274864_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID CONFIGUREBUILTINOP(BUILTINOPERATOR OP) {
    SWITCH (OP) {
      CASE BUILTINOPERATOR_EQUAL: {
        SETBUILTINOP(OP, BUILTINOPTIONS_EQUALOPTIONS,
                     CREATEEQUALOPTIONS(BUILDER_).UNION());
        BREAK;
      }
      CASE BUILTINOPERATOR_NOT_EQUAL: {
        SETBUILTINOP(OP, BUILTINOPTIONS_NOTEQUALOPTIONS,
                     CREATENOTEQUALOPTIONS(BUILDER_).UNION());
        BREAK;
      }
      CASE BUILTINOPERATOR_GREATER: {
        SETBUILTINOP(OP, BUILTINOPTIONS_GREATEROPTIONS,
                     CREATEGREATEROPTIONS(BUILDER_).UNION());
        BREAK;
      }
      CASE BUILTINOPERATOR_GREATER_EQUAL: {
        SETBUILTINOP(OP, BUILTINOPTIONS_GREATEREQUALOPTIONS,
                     CREATEGREATEREQUALOPTIONS(BUILDER_).UNION());
        BREAK;
      }
      CASE BUILTINOPERATOR_LESS: {
        SETBUILTINOP(OP, BUILTINOPTIONS_LESSOPTIONS,
                     CREATELESSOPTIONS(BUILDER_).UNION());
        BREAK;
      }
      CASE BUILTINOPERATOR_LESS_EQUAL: {
        SETBUILTINOP(OP, BUILTINOPTIONS_LESSEQUALOPTIONS,
                     CREATELESSEQUALOPTIONS(BUILDER_).UNION());
        BREAK;
      }
      DEFAULT: { FAIL() << "WE SHOULDN'T GET HERE."; }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197898_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& GRADIENT = CTX->INPUT(0);
    CONST TENSOR& INPUT = CTX->INPUT(1);
    TENSOR* INPUT_BACKPROP = NULLPTR;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(0, INPUT.SHAPE(), &INPUT_BACKPROP));

    OP_REQUIRES(
        CTX, INPUT.ISSAMESIZE(GRADIENT),
        ERRORS::INVALIDARGUMENT("GRADIENT AND INPUT MUST BE THE SAME SIZE"));
    CONST INT DEPTH = (AXIS_ == -1) ? 1 : INPUT.DIM_SIZE(AXIS_);
    CONST TENSOR& INPUT_MIN_TENSOR = CTX->INPUT(2);
    OP_REQUIRES(CTX,
                INPUT_MIN_TENSOR.DIMS() == 0 || INPUT_MIN_TENSOR.DIMS() == 1,
                ERRORS::INVALIDARGUMENT(
                    "INPUT MIN TENSOR MUST HAVE DIMENSION 1. RECIEVED ",
                    INPUT_MIN_TENSOR.DIMS(), "."));
    CONST TENSOR& INPUT_MAX_TENSOR = CTX->INPUT(3);
    OP_REQUIRES(CTX,
                INPUT_MAX_TENSOR.DIMS() == 0 || INPUT_MAX_TENSOR.DIMS() == 1,
                ERRORS::INVALIDARGUMENT(
                    "INPUT MAX TENSOR MUST HAVE DIMENSION 1. RECIEVED ",
                    INPUT_MAX_TENSOR.DIMS(), "."));
    IF (AXIS_ != -1) {
      OP_REQUIRES(
          CTX, INPUT_MIN_TENSOR.DIM_SIZE(0) == DEPTH,
          ERRORS::INVALIDARGUMENT("MIN HAS INCORRECT SIZE, EXPECTED ", DEPTH,
                                  " WAS ", INPUT_MIN_TENSOR.DIM_SIZE(0)));
      OP_REQUIRES(
          CTX, INPUT_MAX_TENSOR.DIM_SIZE(0) == DEPTH,
          ERRORS::INVALIDARGUMENT("MAX HAS INCORRECT SIZE, EXPECTED ", DEPTH,
                                  " WAS ", INPUT_MAX_TENSOR.DIM_SIZE(0)));
    }

    TENSORSHAPE MIN_MAX_SHAPE(INPUT_MIN_TENSOR.SHAPE());
    TENSOR* INPUT_MIN_BACKPROP;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(1, MIN_MAX_SHAPE, &INPUT_MIN_BACKPROP));

    TENSOR* INPUT_MAX_BACKPROP;
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(2, MIN_MAX_SHAPE, &INPUT_MAX_BACKPROP));

    IF (AXIS_ == -1) {
      FUNCTOR::QUANTIZEANDDEQUANTIZEONESCALEGRADIENTFUNCTOR<DEVICE, T> F;
      F(CTX->EIGEN_DEVICE<DEVICE>(), GRADIENT.TEMPLATE FLAT<T>(),
        INPUT.TEMPLATE FLAT<T>(), INPUT_MIN_TENSOR.SCALAR<T>(),
        INPUT_MAX_TENSOR.SCALAR<T>(), INPUT_BACKPROP->TEMPLATE FLAT<T>(),
        INPUT_MIN_BACKPROP->TEMPLATE SCALAR<T>(),
        INPUT_MAX_BACKPROP->TEMPLATE SCALAR<T>());
    } ELSE {
      FUNCTOR::QUANTIZEANDDEQUANTIZEPERCHANNELGRADIENTFUNCTOR<DEVICE, T> F;
      F(CTX->EIGEN_DEVICE<DEVICE>(),
        GRADIENT.TEMPLATE FLAT_INNER_OUTER_DIMS<T, 3>(AXIS_ - 1),
        INPUT.TEMPLATE FLAT_INNER_OUTER_DIMS<T, 3>(AXIS_ - 1),
        &INPUT_MIN_TENSOR, &INPUT_MAX_TENSOR,
        INPUT_BACKPROP->TEMPLATE FLAT_INNER_OUTER_DIMS<T, 3>(AXIS_ - 1),
        INPUT_MIN_BACKPROP->TEMPLATE FLAT<T>(),
        INPUT_MAX_BACKPROP->TEMPLATE FLAT<T>());
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198452_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID COMPARISONQUANTIZED(CONST TFLITETENSOR* INPUT1, CONST TFLITETENSOR* INPUT2,
                         TFLITETENSOR* OUTPUT, BOOL REQUIRES_BROADCAST) {
  IF (INPUT1->TYPE == KTFLITEUINT8 || INPUT1->TYPE == KTFLITEINT8) {
    AUTO INPUT1_OFFSET = -INPUT1->PARAMS.ZERO_POINT;
    AUTO INPUT2_OFFSET = -INPUT2->PARAMS.ZERO_POINT;
    CONST INT LEFT_SHIFT = 8;

    INT32 INPUT1_MULTIPLIER;
    INT INPUT1_SHIFT;
    QUANTIZEMULTIPLIERSMALLERTHANONEEXP(INPUT1->PARAMS.SCALE,
                                        &INPUT1_MULTIPLIER, &INPUT1_SHIFT);
    INT32 INPUT2_MULTIPLIER;
    INT INPUT2_SHIFT;
    QUANTIZEMULTIPLIERSMALLERTHANONEEXP(INPUT2->PARAMS.SCALE,
                                        &INPUT2_MULTIPLIER, &INPUT2_SHIFT);

    COMPARISONPARAMS OP_PARAMS;
    OP_PARAMS.LEFT_SHIFT = LEFT_SHIFT;
    OP_PARAMS.INPUT1_OFFSET = INPUT1_OFFSET;
    OP_PARAMS.INPUT1_MULTIPLIER = INPUT1_MULTIPLIER;
    OP_PARAMS.INPUT1_SHIFT = INPUT1_SHIFT;
    OP_PARAMS.INPUT2_OFFSET = INPUT2_OFFSET;
    OP_PARAMS.INPUT2_MULTIPLIER = INPUT2_MULTIPLIER;
    OP_PARAMS.INPUT2_SHIFT = INPUT2_SHIFT;
    IF (REQUIRES_BROADCAST) {
      REFERENCE_OPS::BROADCASTCOMPARISON4DSLOWWITHSCALING<INPUT_DTYPE, OPNAME>(
          OP_PARAMS, GETTENSORSHAPE(INPUT1), GETTENSORDATA<INPUT_DTYPE>(INPUT1),
          GETTENSORSHAPE(INPUT2), GETTENSORDATA<INPUT_DTYPE>(INPUT2),
          GETTENSORSHAPE(OUTPUT), GETTENSORDATA<BOOL>(OUTPUT));
    } ELSE {
      REFERENCE_OPS::COMPARISONWITHSCALING<INPUT_DTYPE, OPNAME>(
          OP_PARAMS, GETTENSORSHAPE(INPUT1), GETTENSORDATA<INPUT_DTYPE>(INPUT1),
          GETTENSORSHAPE(INPUT2), GETTENSORDATA<INPUT_DTYPE>(INPUT2),
          GETTENSORSHAPE(OUTPUT), GETTENSORDATA<BOOL>(OUTPUT));
    }
  }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195389_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL REPEATEDATTRDEFEQUAL(
    CONST PROTOBUF::REPEATEDPTRFIELD<OPDEF::ATTRDEF>& A1,
    CONST PROTOBUF::REPEATEDPTRFIELD<OPDEF::ATTRDEF>& A2) {
  STD::UNORDERED_MAP<STRING, CONST OPDEF::ATTRDEF*> A1_SET;
  FOR (CONST OPDEF::ATTRDEF& DEF : A1) {
    DCHECK(A1_SET.FIND(DEF.NAME()) == A1_SET.END())
        << "ATTRDEF NAMES MUST BE UNIQUE, BUT '" << DEF.NAME()
        << "' APPEARS MORE THAN ONCE";
    A1_SET[DEF.NAME()] = &DEF;
  }
  FOR (CONST OPDEF::ATTRDEF& DEF : A2) {
    AUTO ITER = A1_SET.FIND(DEF.NAME());
    IF (ITER == A1_SET.END()) RETURN FALSE;
    IF (!ATTRDEFEQUAL(*ITER->SECOND, DEF)) RETURN FALSE;
    A1_SET.ERASE(ITER);
  }
  IF (!A1_SET.EMPTY()) RETURN FALSE;
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195340_CWE-190.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT *CTX) OVERRIDE {
    CONST TENSOR *INDICES_T, *VALUES_T, *SHAPE_T, *DENSE_T;
    OP_REQUIRES_OK(CTX, CTX->INPUT("SP_INDICES", &INDICES_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("SP_VALUES", &VALUES_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("SP_SHAPE", &SHAPE_T));
    OP_REQUIRES_OK(CTX, CTX->INPUT("DENSE", &DENSE_T));

    // VALIDATIONS.
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISMATRIX(INDICES_T->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SP_INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE: ",
                    INDICES_T->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX,
                TENSORSHAPEUTILS::ISVECTOR(VALUES_T->SHAPE()) &&
                    TENSORSHAPEUTILS::ISVECTOR(SHAPE_T->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUTS SP_VALUES AND SP_SHAPE SHOULD BE VECTORS "
                    "BUT RECEIVED SHAPES: ",
                    VALUES_T->SHAPE().DEBUGSTRING(), " AND ",
                    SHAPE_T->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CTX, TENSORSHAPEUTILS::ISVECTOR(SHAPE_T->SHAPE()),
        ERRORS::INVALIDARGUMENT("INPUT SP_SHAPE MUST BE A VECTOR. GOT: ",
                                SHAPE_T->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CTX, VALUES_T->DIM_SIZE(0) == INDICES_T->DIM_SIZE(0),
        ERRORS::INVALIDARGUMENT(
            "THE FIRST DIMENSION OF VALUES AND INDICES SHOULD MATCH. (",
            VALUES_T->DIM_SIZE(0), " VS. ", INDICES_T->DIM_SIZE(0), ")"));
    OP_REQUIRES(
        CTX, SHAPE_T->SHAPE().DIM_SIZE(0) == INDICES_T->SHAPE().DIM_SIZE(1),
        ERRORS::INVALIDARGUMENT(
            "NUMBER OF DIMENSIONS MUST MATCH SECOND DIMENSION OF INDICES. ",
            "GOT ", SHAPE_T->SHAPE().DIM_SIZE(0),
            " DIMENSIONS, INDICES SHAPE: ", INDICES_T->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX, SHAPE_T->NUMELEMENTS() > 0,
                ERRORS::INVALIDARGUMENT(
                    "THE SHAPE ARGUMENT REQUIRES AT LEAST ONE ELEMENT."));

    CONST AUTO INDICES_MAT = INDICES_T->MATRIX<INT64_T>();
    CONST AUTO SHAPE_VEC = SHAPE_T->VEC<INT64_T>();
    CONST AUTO LHS_DIMS = BCAST::FROMSHAPE(TENSORSHAPE(SHAPE_VEC));
    CONST AUTO RHS_DIMS = BCAST::FROMSHAPE(DENSE_T->SHAPE());
    BCAST B(LHS_DIMS, RHS_DIMS, FALSE);  // FALSE FOR KEEPING THE SAME NUM DIMS.

    // TRUE IFF (SIZE(LHS) >= SIZE(RHS)) AND ALL DIMS IN LHS IS GREATER OR EQUAL
    // TO DIMS IN RHS (FROM RIGHT TO LEFT).
    AUTO VECGREATEREQ = [](ARRAYSLICE<INT64_T> LHS, ARRAYSLICE<INT64_T> RHS) {
      IF (LHS.SIZE() < RHS.SIZE()) RETURN FALSE;
      FOR (SIZE_T I = 0; I < RHS.SIZE(); ++I) {
        IF (LHS[LHS.SIZE() - 1 - I] < RHS[RHS.SIZE() - 1 - I]) RETURN FALSE;
      }
      RETURN TRUE;
    };
    OP_REQUIRES(CTX, VECGREATEREQ(LHS_DIMS, RHS_DIMS) && B.ISVALID(),
                ERRORS::INVALIDARGUMENT(
                    "SPARSEDENSEBINARYOPSHARED BROADCASTS DENSE TO SPARSE "
                    "ONLY; GOT INCOMPATIBLE SHAPES: [",
                    ABSL::STRJOIN(LHS_DIMS, ","), "] VS. [",
                    ABSL::STRJOIN(RHS_DIMS, ","), "]"));

    TENSOR *OUTPUT_VALUES = NULLPTR;
    TENSOR DENSE_GATHERED;
    CONST INT64_T NNZ = INDICES_T->DIM_SIZE(0);
    OP_REQUIRES_OK(CTX,
                   CTX->ALLOCATE_OUTPUT(0, TENSORSHAPE({NNZ}), &OUTPUT_VALUES));
    OP_REQUIRES_OK(
        CTX, CTX->ALLOCATE_TEMP(DATATYPETOENUM<T>::VALUE, TENSORSHAPE({NNZ}),
                                &DENSE_GATHERED));
    BOOL OP_IS_DIV = FALSE;
    IF (ABSL::STRCONTAINS(CTX->OP_KERNEL().TYPE_STRING_VIEW(), "DIV")) {
      OP_IS_DIV = TRUE;
    }
    // PULLS RELEVANT ENTRIES FROM THE DENSE SIDE, WITH RESHAPE AND BROADCASTING
    // *OF THE DENSE SIDE* TAKEN INTO ACCOUNT.  USE A TENSORREF TO AVOID BLOWING
    // UP MEMORY.
    //
    // WE CAN DIRECTLY USE THE SPARSE INDICES TO LOOK UP DENSE SIDE, BECAUSE
    // "B.Y_RESHAPE()" AND "B.Y_BCAST()" ARE GUARANTEED TO HAVE RANK "NDIMS".
    AUTO DENSE_GATHERED_FLAT = DENSE_GATHERED.FLAT<T>();
    CONST INT NDIMS = LHS_DIMS.SIZE();
    SWITCH (NDIMS) {
#DEFINE CASE(NDIM)                                                             \
  CASE NDIM: {                                                                 \
    TENSORREF<EIGEN::TENSOR<CONST T, NDIM, EIGEN::ROWMAJOR>> RHS_REF =         \
        DENSE_T->SHAPED<T, NDIM>(B.Y_RESHAPE())                                \
            .BROADCAST(BCAST::TOINDEXARRAY<NDIM>(B.Y_BCAST()));                \
    EIGEN::ARRAY<EIGEN::DENSEINDEX, NDIM> IDX;                                 \
    BOOL INDICES_VALID = TRUE;                                                 \
    FOR (INT I = 0; I < NNZ; ++I) {                                            \
      FOR (INT D = 0; D < NDIM; ++D) {                                         \
        IDX[D] = INTERNAL::SUBTLEMUSTCOPY(INDICES_MAT(I, D));                  \
        IF (!FASTBOUNDSCHECK(IDX[D], RHS_REF.DIMENSION(D))) {                  \
          INDICES_VALID = FALSE;                                               \
        }                                                                      \
      }                                                                        \
      OP_REQUIRES(                                                             \
          CTX, INDICES_VALID,                                                  \
          ERRORS::INVALIDARGUMENT("PROVIDED INDICES ARE OUT-OF-BOUNDS W.R.T. " \
                                  "DENSE SIDE WITH BROADCASTED SHAPE"));       \
      DENSE_GATHERED_FLAT(I) = RHS_REF.COEFF(IDX);                             \
      IF (OP_IS_DIV) {                                                         \
        OP_REQUIRES(CTX, DENSE_GATHERED_FLAT(I) != 0,                          \
                    ERRORS::INVALIDARGUMENT(                                   \
                        "SPARSEDENSECWISEDIV CANNOT DIVIDE BY ZERO,"           \
                        "BUT INPUT DENSE TENSOR CONTAINS ZERO "));             \
      }                                                                        \
    }                                                                          \
    BREAK;                                                                     \
  }

      CASE(1);
      CASE(2);
      CASE(3);
      CASE(4);
      CASE(5);
      DEFAULT:
        OP_REQUIRES(
            CTX, FALSE,
            ERRORS::INVALIDARGUMENT("ONLY TENSORS WITH RANKS BETWEEN 1 AND 5 "
                                    "ARE CURRENTLY SUPPORTED.  TENSOR RANK: ",
                                    NDIMS));
#UNDEF CASE
    }

    OUTPUT_VALUES->FLAT<T>().DEVICE(CTX->EIGEN_DEVICE<DEVICE>()) =
        VALUES_T->FLAT<T>().BINARYEXPR(DENSE_GATHERED_FLAT,
                                       TYPENAME FUNCTOR::FUNC());
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197466_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID RESTORETENSOR(OPKERNELCONTEXT* CONTEXT,
                   CHECKPOINT::TENSORSLICEREADER::OPENTABLEFUNCTION OPEN_FUNC,
                   INT PREFERRED_SHARD, BOOL RESTORE_SLICE, INT RESTORE_INDEX) {
  CONST TENSOR& FILE_PATTERN_T = CONTEXT->INPUT(0);
  {
    CONST INT64_T SIZE = FILE_PATTERN_T.NUMELEMENTS();
    OP_REQUIRES(
        CONTEXT, SIZE == 1,
        ERRORS::INVALIDARGUMENT(
            "INPUT 0 (FILE_PATTERN) MUST BE A STRING SCALAR; GOT A TENSOR OF ",
            SIZE, "ELEMENTS"));
  }
  CONST STRING& FILE_PATTERN = FILE_PATTERN_T.FLAT<TSTRING>()(0);

  CONST TENSOR& TENSOR_NAME_T = CONTEXT->INPUT(1);
  CONST STRING& TENSOR_NAME = TENSOR_NAME_T.FLAT<TSTRING>()(RESTORE_INDEX);

  // IF WE CANNOT FIND A CACHED READER WE WILL ALLOCATE OUR OWN.
  STD::UNIQUE_PTR<CHECKPOINT::TENSORSLICEREADER> ALLOCATED_READER;

  CONST CHECKPOINT::TENSORSLICEREADER* READER = NULLPTR;

  IF (CONTEXT->SLICE_READER_CACHE()) {
    READER = CONTEXT->SLICE_READER_CACHE()->GETREADER(FILE_PATTERN, OPEN_FUNC,
                                                      PREFERRED_SHARD);
  }
  IF (!READER) {
    ALLOCATED_READER.RESET(NEW CHECKPOINT::TENSORSLICEREADER(
        FILE_PATTERN, OPEN_FUNC, PREFERRED_SHARD));
    READER = ALLOCATED_READER.GET();
  }
  OP_REQUIRES_OK(CONTEXT, CHECK_NOTNULL(READER)->STATUS());

  // GET THE SHAPE AND TYPE FROM THE SAVE FILE.
  DATATYPE TYPE;
  TENSORSHAPE SAVED_SHAPE;
  OP_REQUIRES(
      CONTEXT, READER->HASTENSOR(TENSOR_NAME, &SAVED_SHAPE, &TYPE),
      ERRORS::NOTFOUND("TENSOR NAME \"", TENSOR_NAME,
                       "\" NOT FOUND IN CHECKPOINT FILES ", FILE_PATTERN));
  OP_REQUIRES(
      CONTEXT, TYPE == CONTEXT->EXPECTED_OUTPUT_DTYPE(RESTORE_INDEX),
      ERRORS::INVALIDARGUMENT("EXPECTED TO RESTORE A TENSOR OF TYPE ",
                              DATATYPESTRING(CONTEXT->EXPECTED_OUTPUT_DTYPE(0)),
                              ", GOT A TENSOR OF TYPE ", DATATYPESTRING(TYPE),
                              " INSTEAD: TENSOR_NAME = ", TENSOR_NAME));

  // SHAPE OF THE OUTPUT AND SLICE TO LOAD.
  TENSORSHAPE OUTPUT_SHAPE(SAVED_SHAPE);
  TENSORSLICE SLICE_TO_LOAD(SAVED_SHAPE.DIMS());
  IF (RESTORE_SLICE) {
    CONST TSTRING& SHAPE_SPEC =
        CONTEXT->INPUT(2).FLAT<TSTRING>()(RESTORE_INDEX);
    IF (!SHAPE_SPEC.EMPTY()) {
      TENSORSHAPE PARSED_SHAPE;
      OP_REQUIRES_OK(CONTEXT, CHECKPOINT::PARSESHAPEANDSLICE(
                                  SHAPE_SPEC, &PARSED_SHAPE, &SLICE_TO_LOAD,
                                  &OUTPUT_SHAPE));
      OP_REQUIRES(
          CONTEXT, PARSED_SHAPE.ISSAMESIZE(SAVED_SHAPE),
          ERRORS::INVALIDARGUMENT(
              "SHAPE IN SHAPE_AND_SLICE SPEC DOES NOT MATCH THE SHAPE IN THE "
              "SAVE FILE: ",
              PARSED_SHAPE.DEBUGSTRING(),
              ", SAVE FILE SHAPE: ", SAVED_SHAPE.DEBUGSTRING()));
    }
  }

  TENSOR* T = NULLPTR;
  OP_REQUIRES_OK(CONTEXT,
                 CONTEXT->ALLOCATE_OUTPUT(RESTORE_INDEX, OUTPUT_SHAPE, &T));

  IF (OUTPUT_SHAPE.NUM_ELEMENTS() == 0) RETURN;

#DEFINE READER_COPY(T)                                                \
  CASE DATATYPETOENUM<T>::VALUE:                                      \
    OP_REQUIRES(CONTEXT,                                              \
                READER->COPYSLICEDATA(TENSOR_NAME, SLICE_TO_LOAD,     \
                                      T->FLAT<T>().DATA()),           \
                ERRORS::INVALIDARGUMENT("ERROR COPYING SLICE DATA")); \
    BREAK;

  SWITCH (TYPE) {
    TF_CALL_SAVE_RESTORE_TYPES(READER_COPY)
    DEFAULT:
      CONTEXT->SETSTATUS(ERRORS::UNIMPLEMENTED(
          "RESTORING DATA TYPE ", DATATYPESTRING(TYPE), " NOT YET SUPPORTED"));
  }
#UNDEF READER_COPY
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224161_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    STAGINGMAP<ORDERED>* MAP = NULLPTR;
    OP_REQUIRES_OK(CTX, GETSTAGINGMAP(CTX, DEF(), &MAP));
    CORE::SCOPEDUNREF SCOPE(MAP);

    OP_REQUIRES_OK(CTX, MAP->CLEAR());
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197621_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONST CONTEXT) OVERRIDE {
    // NODE_ID_RANGE
    CONST TENSOR* NODE_ID_RANGE_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("NODE_ID_RANGE", &NODE_ID_RANGE_T));
    CONST AUTO NODE_ID_RANGE = NODE_ID_RANGE_T->VEC<INT32>();
    CONST INT32_T NODE_ID_FIRST = NODE_ID_RANGE(0);  // INCLUSIVE
    CONST INT32_T NODE_ID_LAST = NODE_ID_RANGE(1);   // EXCLUSIVE

    CONST TENSOR* STATS_SUMMARY_INDICES_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("STATS_SUMMARY_INDICES",
                                           &STATS_SUMMARY_INDICES_T));
    CONST AUTO STATS_SUMMARY_INDICES = STATS_SUMMARY_INDICES_T->MATRIX<INT32>();
    CONST INT32_T NUM_SPARSE_ENTRIES = STATS_SUMMARY_INDICES_T->DIM_SIZE(0);

    CONST TENSOR* STATS_SUMMARY_VALUES_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("STATS_SUMMARY_VALUES",
                                           &STATS_SUMMARY_VALUES_T));
    CONST AUTO STATS_SUMMARY_VALUES = STATS_SUMMARY_VALUES_T->VEC<FLOAT>();

    CONST TENSOR* STATS_SUMMARY_SHAPE_T;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->INPUT("STATS_SUMMARY_SHAPE", &STATS_SUMMARY_SHAPE_T));
    CONST AUTO STATS_SUMMARY_SHAPE = STATS_SUMMARY_SHAPE_T->VEC<INT32>();
    CONST INT32_T NUM_BUCKETS = STATS_SUMMARY_SHAPE(2) - 1;
    CONST INT32_T STATS_DIMS = STATS_SUMMARY_SHAPE(3);

    CONST TENSOR* L1_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("L1", &L1_T));
    CONST AUTO L1 = L1_T->SCALAR<FLOAT>()();

    CONST TENSOR* L2_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("L2", &L2_T));
    CONST AUTO L2 = L2_T->SCALAR<FLOAT>()();

    CONST TENSOR* TREE_COMPLEXITY_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->INPUT("TREE_COMPLEXITY", &TREE_COMPLEXITY_T));
    CONST AUTO TREE_COMPLEXITY = TREE_COMPLEXITY_T->SCALAR<FLOAT>()();

    CONST TENSOR* MIN_NODE_WEIGHT_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->INPUT("MIN_NODE_WEIGHT", &MIN_NODE_WEIGHT_T));
    CONST AUTO MIN_NODE_WEIGHT = MIN_NODE_WEIGHT_T->SCALAR<FLOAT>()();

    STD::VECTOR<INT32> OUTPUT_NODE_IDS;
    STD::VECTOR<FLOAT> OUTPUT_GAINS;
    STD::VECTOR<INT32> OUTPUT_FEATURE_DIMENSIONS;
    STD::VECTOR<INT32> OUTPUT_THRESHOLDS;
    STD::VECTOR<FLOAT> OUTPUT_LEFT_NODE_CONTRIBS;
    STD::VECTOR<FLOAT> OUTPUT_RIGHT_NODE_CONTRIBS;
    STD::VECTOR<STRING> OUTPUT_SPLIT_TYPES;

    FEATUREMAP F_MAP;

    INT32_T PREVIOUS_NODE_ID = -1;
    FOR (INT IDX = 0; IDX < NUM_SPARSE_ENTRIES; ++IDX) {
      INT32_T NODE_ID = STATS_SUMMARY_INDICES(IDX, 0);
      IF (NODE_ID != PREVIOUS_NODE_ID) {
        PROCESS_NODE(F_MAP, &OUTPUT_NODE_IDS, &OUTPUT_GAINS,
                     &OUTPUT_FEATURE_DIMENSIONS, &OUTPUT_THRESHOLDS,
                     &OUTPUT_LEFT_NODE_CONTRIBS, &OUTPUT_RIGHT_NODE_CONTRIBS,
                     &OUTPUT_SPLIT_TYPES, PREVIOUS_NODE_ID, MIN_NODE_WEIGHT, L1,
                     L2, NUM_BUCKETS);
        F_MAP.CLEAR();
      }
      PREVIOUS_NODE_ID = NODE_ID;
      DCHECK_LE(NODE_ID_FIRST, NODE_ID);
      DCHECK_LT(NODE_ID, NODE_ID_LAST);
      CONST INT32_T FEATURE_DIM = STATS_SUMMARY_INDICES(IDX, 1);
      CONST INT32_T BUCKET_ID = STATS_SUMMARY_INDICES(IDX, 2);
      CONST INT32_T STAT_DIM = STATS_SUMMARY_INDICES(IDX, 3);
      STD::PAIR<FEATUREMAPITERATOR, BOOL> CONST& F_INSERT_RESULT = F_MAP.INSERT(
          FEATUREMAPITERATOR::VALUE_TYPE(FEATURE_DIM, BUCKETMAP()));
      AUTO& B_MAP = F_INSERT_RESULT.FIRST->SECOND;
      STD::PAIR<BUCKETMAPITERATOR, BOOL> CONST& B_INSERT_RESULT =
          B_MAP.INSERT(BUCKETMAPITERATOR::VALUE_TYPE(
              BUCKET_ID, STD::VECTOR<FLOAT>(STATS_DIMS)));
      AUTO& STATS = B_INSERT_RESULT.FIRST->SECOND;
      STATS[STAT_DIM] = STATS_SUMMARY_VALUES(IDX);
    }  // FOR NODE_ID
    // PROCESS THE LAST NODE ID
    PROCESS_NODE(F_MAP, &OUTPUT_NODE_IDS, &OUTPUT_GAINS,
                 &OUTPUT_FEATURE_DIMENSIONS, &OUTPUT_THRESHOLDS,
                 &OUTPUT_LEFT_NODE_CONTRIBS, &OUTPUT_RIGHT_NODE_CONTRIBS,
                 &OUTPUT_SPLIT_TYPES, PREVIOUS_NODE_ID, MIN_NODE_WEIGHT, L1, L2,
                 NUM_BUCKETS);

    CONST INT NUM_NODES = OUTPUT_NODE_IDS.SIZE();
    // OUTPUT_NODE_IDS
    TENSOR* OUTPUT_NODE_IDS_T = NULLPTR;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("NODE_IDS", {NUM_NODES},
                                                     &OUTPUT_NODE_IDS_T));
    AUTO OUTPUT_NODE_IDS_VEC = OUTPUT_NODE_IDS_T->VEC<INT32>();

    // OUTPUT_GAINS
    TENSOR* OUTPUT_GAINS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("GAINS", {NUM_NODES},
                                                     &OUTPUT_GAINS_T));
    AUTO OUTPUT_GAINS_VEC = OUTPUT_GAINS_T->VEC<FLOAT>();

    // OUTPUT_FEATURE_DIMENSIONS
    TENSOR* OUTPUT_FEATURE_DIMENSION_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->ALLOCATE_OUTPUT("FEATURE_DIMENSIONS", {NUM_NODES},
                                            &OUTPUT_FEATURE_DIMENSION_T));
    AUTO OUTPUT_FEATURE_DIMENSIONS_VEC =
        OUTPUT_FEATURE_DIMENSION_T->VEC<INT32>();

    // OUTPUT_THRESHOLDS
    TENSOR* OUTPUT_THRESHOLDS_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("THRESHOLDS", {NUM_NODES},
                                                     &OUTPUT_THRESHOLDS_T));
    AUTO OUTPUT_THRESHOLDS_VEC = OUTPUT_THRESHOLDS_T->VEC<INT32>();

    // OUTPUT_LEFT_NODE_CONTRIBS
    TENSOR* OUTPUT_LEFT_NODE_CONTRIBS_T;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->ALLOCATE_OUTPUT("LEFT_NODE_CONTRIBS", {NUM_NODES, 1},
                                          &OUTPUT_LEFT_NODE_CONTRIBS_T));
    AUTO OUTPUT_LEFT_NODE_CONTRIBS_MATRIX =
        OUTPUT_LEFT_NODE_CONTRIBS_T->MATRIX<FLOAT>();

    // OUTPUT_RIGHT_NODE_CONTRIBS
    TENSOR* OUTPUT_RIGHT_NODE_CONTRIBS_T;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->ALLOCATE_OUTPUT("RIGHT_NODE_CONTRIBS", {NUM_NODES, 1},
                                          &OUTPUT_RIGHT_NODE_CONTRIBS_T));
    AUTO OUTPUT_RIGHT_NODE_CONTRIBS_MATRIX =
        OUTPUT_RIGHT_NODE_CONTRIBS_T->MATRIX<FLOAT>();

    // SPLIT TYPE
    TENSOR* OUTPUT_SPLIT_TYPES_T;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->ALLOCATE_OUTPUT("SPLIT_WITH_DEFAULT_DIRECTIONS",
                                          {NUM_NODES}, &OUTPUT_SPLIT_TYPES_T));
    AUTO OUTPUT_SPLIT_TYPES_VEC = OUTPUT_SPLIT_TYPES_T->VEC<TSTRING>();

    // SETS OUTPUT TENSORS FROM VECTORS.
    FOR (INT I = 0; I < NUM_NODES; ++I) {
      OUTPUT_NODE_IDS_VEC(I) = OUTPUT_NODE_IDS[I];
      // ADJUST THE GAINS TO PENALIZE BY TREE COMPLEXITY.
      OUTPUT_GAINS_VEC(I) = OUTPUT_GAINS[I] - TREE_COMPLEXITY;
      OUTPUT_FEATURE_DIMENSIONS_VEC(I) = OUTPUT_FEATURE_DIMENSIONS[I];
      OUTPUT_THRESHOLDS_VEC(I) = OUTPUT_THRESHOLDS[I];
      // TODO(CRAWLES): CHANGE THIS FOR MULTI-CLASS.
      OUTPUT_LEFT_NODE_CONTRIBS_MATRIX(I, 0) = OUTPUT_LEFT_NODE_CONTRIBS[I];
      OUTPUT_RIGHT_NODE_CONTRIBS_MATRIX(I, 0) = OUTPUT_RIGHT_NODE_CONTRIBS[I];
      OUTPUT_SPLIT_TYPES_VEC(I) = OUTPUT_SPLIT_TYPES[I];
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195083_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL TENSOR::FROMPROTO(ALLOCATOR* A, CONST TENSORPROTO& PROTO) {
  CHECK_NOTNULL(A);
  TENSORBUFFER* P = NULLPTR;
  IF (!TENSORSHAPE::ISVALID(PROTO.TENSOR_SHAPE())) RETURN FALSE;
  IF (PROTO.DTYPE() == DT_INVALID) RETURN FALSE;
  TENSORSHAPE SHAPE(PROTO.TENSOR_SHAPE());
  CONST INT64_T N = SHAPE.NUM_ELEMENTS();
  IF (N > 0 && PROTO.DTYPE()) {
    BOOL DTYPE_ERROR = FALSE;
    IF (!PROTO.TENSOR_CONTENT().EMPTY()) {
      CONST AUTO& CONTENT = PROTO.TENSOR_CONTENT();
      CASES_WITH_DEFAULT(PROTO.DTYPE(), P = HELPER<T>::DECODE(A, CONTENT, N),
                         DTYPE_ERROR = TRUE, DTYPE_ERROR = TRUE);
    } ELSE {
      CASES_WITH_DEFAULT(PROTO.DTYPE(), P = FROMPROTOFIELD<T>(A, PROTO, N),
                         DTYPE_ERROR = TRUE, DTYPE_ERROR = TRUE);
    }
    IF (DTYPE_ERROR || P == NULLPTR) RETURN FALSE;
  }
  SHAPE_ = SHAPE;
  SET_DTYPE(PROTO.DTYPE());
  UNREFIFNONNULL(BUF_);
  BUF_ = P;
  // TODO(MISARD) ADD TRACKING OF WHICH KERNELS AND STEPS ARE CALLING
  // FROMPROTO.
  IF (MEMORYLOGGINGENABLED() && BUF_ != NULLPTR && BUF_->DATA() != NULLPTR) {
    LOGMEMORY::RECORDTENSORALLOCATION("UNKNOWN (FROM PROTO)",
                                      LOGMEMORY::UNKNOWN_STEP_ID, *THIS);
  }
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247631_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_P(SSLSOCKETTEST, GETCERTDIGESTSERVERCERTWITHOUTCOMMONNAME) {
  CONST STD::STRING CLIENT_CTX_YAML = R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
      CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/NO_SAN_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/NO_SAN_KEY.PEM"
)EOF";

  CONST STD::STRING SERVER_CTX_YAML = R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
      CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SAN_ONLY_DNS_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SAN_ONLY_DNS_KEY.PEM"
    VALIDATION_CONTEXT:
      TRUSTED_CA:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/CA_CERT.PEM"
)EOF";

  TESTUTILOPTIONS TEST_OPTIONS(CLIENT_CTX_YAML, SERVER_CTX_YAML, TRUE, GETPARAM());
  TESTUTIL(TEST_OPTIONS.SETEXPECTEDSHA256DIGEST(TEST_NO_SAN_CERT_256_HASH)
               .SETEXPECTEDSHA1DIGEST(TEST_NO_SAN_CERT_1_HASH)
               .SETEXPECTEDSERIALNUMBER(TEST_NO_SAN_CERT_SERIAL));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198198_CWE-125.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID DOCOMPUTE(OPKERNELCONTEXT* C) {
    CORE::REFCOUNTPTR<VAR> V;
    OP_REQUIRES_OK(C, LOOKUPRESOURCE(C, HANDLEFROMINPUT(C, 0), &V));
    TENSOR* PARAMS = V->TENSOR();
    CONST TENSOR& INDICES = C->INPUT(1);
    CONST TENSOR& UPDATES = C->INPUT(2);

    // CHECK THAT RANK(UPDATES.SHAPE) = RANK(INDICES.SHAPE + PARAMS.SHAPE[1:])
    OP_REQUIRES(C,
                UPDATES.DIMS() == 0 ||
                    UPDATES.DIMS() == INDICES.DIMS() + PARAMS->DIMS() - 1,
                ERRORS::INVALIDARGUMENT(
                    "MUST HAVE UPDATES.SHAPE = INDICES.SHAPE + "
                    "PARAMS.SHAPE[1:] OR UPDATES.SHAPE = [], GOT ",
                    "UPDATES.SHAPE ", UPDATES.SHAPE().DEBUGSTRING(),
                    ", INDICES.SHAPE ", INDICES.SHAPE().DEBUGSTRING(),
                    ", PARAMS.SHAPE ", PARAMS->SHAPE().DEBUGSTRING()));

    // CHECK THAT WE HAVE ENOUGH INDEX SPACE
    CONST INT64_T N_BIG = INDICES.NUMELEMENTS();
    OP_REQUIRES(
        C, N_BIG <= STD::NUMERIC_LIMITS<INDEX>::MAX(),
        ERRORS::INVALIDARGUMENT("INDICES HAS TOO MANY ELEMENTS FOR ",
                                DATATYPESTRING(DATATYPETOENUM<INDEX>::V()),
                                " INDEXING: ", N_BIG, " > ",
                                STD::NUMERIC_LIMITS<INDEX>::MAX()));
    CONST INDEX N = STATIC_CAST<INDEX>(N_BIG);
    OP_REQUIRES(
        C, PARAMS->DIM_SIZE(0) <= STD::NUMERIC_LIMITS<INDEX>::MAX(),
        ERRORS::INVALIDARGUMENT("PARAMS.SHAPE[0] TOO LARGE FOR ",
                                DATATYPESTRING(DATATYPETOENUM<INDEX>::V()),
                                " INDEXING: ", PARAMS->DIM_SIZE(0), " > ",
                                STD::NUMERIC_LIMITS<INDEX>::MAX()));

    IF (N > 0) {
      AUTO INDICES_FLAT = INDICES.FLAT<INDEX>();
      AUTO PARAMS_FLAT = PARAMS->FLAT_OUTER_DIMS<T>();
      IF (TENSORSHAPEUTILS::ISSCALAR(UPDATES.SHAPE())) {
        CONST AUTO UPDATE = UPDATES.SCALAR<T>();

        FUNCTOR::SCATTERSCALARFUNCTOR<DEVICE, T, INDEX, OP> FUNCTOR;
        CONST INDEX BAD_I = FUNCTOR(C, C->TEMPLATE EIGEN_DEVICE<DEVICE>(),
                                    PARAMS_FLAT, UPDATE, INDICES_FLAT);
        OP_REQUIRES(C, BAD_I < 0,
                    ERRORS::INVALIDARGUMENT(
                        "INDICES", SLICEDEBUGSTRING(INDICES.SHAPE(), BAD_I),
                        " = ", INDICES_FLAT(BAD_I), " IS NOT IN [0, ",
                        PARAMS->DIM_SIZE(0), ")"));
      } ELSE {
        INT64_T NUM_UPDATES = UPDATES.NUMELEMENTS();
        OP_REQUIRES(C, NUM_UPDATES % N == 0,
                    ERRORS::INVALIDARGUMENT(
                        "SHAPE OF INDICES (", INDICES.SHAPE().DEBUGSTRING(),
                        ") IS NOT COMPATIBLE WITH THE SHAPE OF UPDATES (",
                        UPDATES.SHAPE().DEBUGSTRING(), ")"));
        AUTO UPDATES_FLAT = UPDATES.SHAPED<T, 2>({N, NUM_UPDATES / N});

        FUNCTOR::SCATTERFUNCTOR<DEVICE, T, INDEX, OP> FUNCTOR;
        CONST INDEX BAD_I = FUNCTOR(C, C->TEMPLATE EIGEN_DEVICE<DEVICE>(),
                                    PARAMS_FLAT, UPDATES_FLAT, INDICES_FLAT);
        OP_REQUIRES(C, BAD_I < 0,
                    ERRORS::INVALIDARGUMENT(
                        "INDICES", SLICEDEBUGSTRING(INDICES.SHAPE(), BAD_I),
                        " = ", INDICES_FLAT(BAD_I), " IS NOT IN [0, ",
                        PARAMS->DIM_SIZE(0), ")"));
      }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 224565_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS CHECKFORMATCONSTRAINTSONSHAPE(CONST TENSORFORMAT TENSOR_FORMAT,
                                     CONST SHAPEHANDLE SHAPE_HANDLE,
                                     CONST STRING& TENSOR_NAME,
                                     SHAPE_INFERENCE::INFERENCECONTEXT* C) {
  IF (TENSOR_FORMAT == FORMAT_NCHW_VECT_C) {
    // CHECK THAT THE VECT DIM HAS SIZE 4 OR 32.
    CONST INT NUM_DIMS = C->RANK(SHAPE_HANDLE);
    DIMENSIONHANDLE VECT_DIM = C->DIM(
        SHAPE_HANDLE, GETTENSORINNERFEATUREDIMINDEX(NUM_DIMS, TENSOR_FORMAT));
    INT64_T VECT_DIM_VAL = C->VALUE(VECT_DIM);
    IF (VECT_DIM_VAL != 4 && VECT_DIM_VAL != 32) {
      RETURN ERRORS::INVALIDARGUMENT(
          "VECT_C DIMENSION MUST BE 4 OR 32, BUT IS ", VECT_DIM_VAL);
    }
  }

  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 229253_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STD::UNIQUE_PTR<CQL_SERVER::RESPONSE> CQL_SERVER::CONNECTION::MAKE_SUPPORTED(INT16_T STREAM, CONST TRACING::TRACE_STATE_PTR& TR_STATE) CONST
{
    STD::MULTIMAP<SSTRING, SSTRING> OPTS;
    OPTS.INSERT({"CQL_VERSION", CQL3::QUERY_PROCESSOR::CQL_VERSION});
    OPTS.INSERT({"COMPRESSION", "LZ4"});
    OPTS.INSERT({"COMPRESSION", "SNAPPY"});
    IF (_SERVER._CONFIG.ALLOW_SHARD_AWARE_DRIVERS) {
        OPTS.INSERT({"SCYLLA_SHARD", FORMAT("{:D}", THIS_SHARD_ID())});
        OPTS.INSERT({"SCYLLA_NR_SHARDS", FORMAT("{:D}", SMP::COUNT)});
        OPTS.INSERT({"SCYLLA_SHARDING_ALGORITHM", DHT::CPU_SHARDING_ALGORITHM_NAME()});
        IF (_SERVER._CONFIG.SHARD_AWARE_TRANSPORT_PORT) {
            OPTS.INSERT({"SCYLLA_SHARD_AWARE_PORT", FORMAT("{:D}", *_SERVER._CONFIG.SHARD_AWARE_TRANSPORT_PORT)});
        }
        IF (_SERVER._CONFIG.SHARD_AWARE_TRANSPORT_PORT_SSL) {
            OPTS.INSERT({"SCYLLA_SHARD_AWARE_PORT_SSL", FORMAT("{:D}", *_SERVER._CONFIG.SHARD_AWARE_TRANSPORT_PORT_SSL)});
        }
        OPTS.INSERT({"SCYLLA_SHARDING_IGNORE_MSB", FORMAT("{:D}", _SERVER._CONFIG.SHARDING_IGNORE_MSB)});
        OPTS.INSERT({"SCYLLA_PARTITIONER", _SERVER._CONFIG.PARTITIONER_NAME});
    }
    FOR (CQL_PROTOCOL_EXTENSION EXT : SUPPORTED_CQL_PROTOCOL_EXTENSIONS()) {
        CONST SSTRING EXT_KEY_NAME = PROTOCOL_EXTENSION_NAME(EXT);
        STD::VECTOR<SSTRING> PARAMS = ADDITIONAL_OPTIONS_FOR_PROTO_EXT(EXT);
        IF (PARAMS.EMPTY()) {
            OPTS.EMPLACE(EXT_KEY_NAME, "");
        } ELSE {
            FOR (SSTRING VAL : PARAMS) {
                OPTS.EMPLACE(EXT_KEY_NAME, STD::MOVE(VAL));
            }
        }
    }
    AUTO RESPONSE = STD::MAKE_UNIQUE<CQL_SERVER::RESPONSE>(STREAM, CQL_BINARY_OPCODE::SUPPORTED, TR_STATE);
    RESPONSE->WRITE_STRING_MULTIMAP(STD::MOVE(OPTS));
    RETURN RESPONSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196705_CWE-20.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS VALIDATEINPUTS(CONST TENSOR *A_INDICES, CONST TENSOR *A_VALUES,
                      CONST TENSOR *A_SHAPE, CONST TENSOR *B) {
  IF (!TENSORSHAPEUTILS::ISMATRIX(A_INDICES->SHAPE())) {
    RETURN ERRORS::INVALIDARGUMENT(
        "INPUT A_INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE: ",
        A_INDICES->SHAPE().DEBUGSTRING());
  }
  IF (!TENSORSHAPEUTILS::ISVECTOR(A_VALUES->SHAPE()) ||
      !TENSORSHAPEUTILS::ISVECTOR(A_SHAPE->SHAPE())) {
    RETURN ERRORS::INVALIDARGUMENT(
        "INPUTS A_VALUES AND A_SHAPE SHOULD BE VECTORS "
        "BUT RECEIVED SHAPES: ",
        A_VALUES->SHAPE().DEBUGSTRING(), " AND ",
        A_SHAPE->SHAPE().DEBUGSTRING());
  }
  IF (A_SHAPE->NUMELEMENTS() != B->DIMS()) {
    RETURN ERRORS::INVALIDARGUMENT(
        "TWO OPERANDS HAVE DIFFERENT RANKS; RECEIVED: ", A_SHAPE->NUMELEMENTS(),
        " AND ", B->DIMS());
  }
  CONST AUTO A_SHAPE_FLAT = A_SHAPE->FLAT<INDEX>();
  FOR (INT I = 0; I < B->DIMS(); ++I) {
    IF (A_SHAPE_FLAT(I) != B->DIM_SIZE(I)) {
      RETURN ERRORS::INVALIDARGUMENT(
          "DIMENSION ", I,
          " DOES NOT EQUAL (NO BROADCASTING IS SUPPORTED): SPARSE SIDE ",
          A_SHAPE_FLAT(I), " VS DENSE SIDE ", B->DIM_SIZE(I));
    }
  }
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197242_CWE-908.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TFLITESTATUS PREPARE(TFLITECONTEXT* CONTEXT, TFLITENODE* NODE) {
  CONST AUTO* PARAMS = REINTERPRET_CAST<TFLITESVDFPARAMS*>(NODE->BUILTIN_DATA);
  OPDATA* OP_DATA = REINTERPRET_CAST<OPDATA*>(NODE->USER_DATA);
  INT SCRATCH_TENSOR_INDEX = OP_DATA->SCRATCH_TENSOR_INDEX;

  // CHECK WE HAVE ALL THE INPUTS AND OUTPUTS WE NEED.
  TF_LITE_ENSURE_EQ(CONTEXT, NODE->OUTPUTS->SIZE, 1);
  TF_LITE_ENSURE_EQ(CONTEXT, NODE->INPUTS->SIZE, 5);

  CONST TFLITETENSOR* INPUT;
  TF_LITE_ENSURE_OK(CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KINPUTTENSOR, &INPUT));
  CONST TFLITETENSOR* WEIGHTS_FEATURE;
  TF_LITE_ENSURE_OK(CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KWEIGHTSFEATURETENSOR,
                                          &WEIGHTS_FEATURE));
  CONST TFLITETENSOR* WEIGHTS_TIME;
  TF_LITE_ENSURE_OK(
      CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KWEIGHTSTIMETENSOR, &WEIGHTS_TIME));

  TF_LITE_ENSURE(CONTEXT,
                 INPUT->TYPE == KTFLITEFLOAT32 || INPUT->TYPE == KTFLITEINT8);

  // CHECK ALL THE PARAMETERS OF TENSOR MATCH WITHIN THEMSELVES AND MATCH THE
  // INPUT CONFIGURATION.
  CONST INT RANK = PARAMS->RANK;
  CONST INT BATCH_SIZE = INPUT->DIMS->DATA[0];
  CONST INT NUM_FILTERS = WEIGHTS_FEATURE->DIMS->DATA[0];
  TF_LITE_ENSURE(CONTEXT, RANK != 0);
  TF_LITE_ENSURE_EQ(CONTEXT, NUM_FILTERS % RANK, 0);
  CONST INT NUM_UNITS = NUM_FILTERS / RANK;
  CONST INT MEMORY_SIZE = WEIGHTS_TIME->DIMS->DATA[1];
  TF_LITE_ENSURE_EQ(CONTEXT, INPUT->DIMS->DATA[1],
                    WEIGHTS_FEATURE->DIMS->DATA[1]);
  TF_LITE_ENSURE_EQ(CONTEXT, WEIGHTS_TIME->DIMS->DATA[0], NUM_FILTERS);

  CONST TFLITETENSOR* BIAS = GETOPTIONALINPUTTENSOR(CONTEXT, NODE, KBIASTENSOR);
  IF (BIAS) {
    TF_LITE_ENSURE_EQ(CONTEXT, BIAS->DIMS->DATA[0], NUM_UNITS);
  }

  CONST TFLITETENSOR* STATE;
  TF_LITE_ENSURE_OK(CONTEXT, GETINPUTSAFE(CONTEXT, NODE, KSTATETENSOR, &STATE));
  TFLITETENSOR* OUTPUT;
  TF_LITE_ENSURE_OK(CONTEXT,
                    GETOUTPUTSAFE(CONTEXT, NODE, KOUTPUTTENSOR, &OUTPUT));

  // CHECK THE SHAPE OF INPUT STATE TENSORS.
  TF_LITE_ENSURE_EQ(CONTEXT, NUMDIMENSIONS(STATE), 2);
  TF_LITE_ENSURE_EQ(CONTEXT, SIZEOFDIMENSION(STATE, 0), BATCH_SIZE);
  TF_LITE_ENSURE_EQ(CONTEXT, SIZEOFDIMENSION(STATE, 1),
                    MEMORY_SIZE * NUM_FILTERS);

  // RESIZE OUTPUT.
  TFLITEINTARRAY* OUTPUT_SIZE_ARRAY = TFLITEINTARRAYCREATE(2);
  OUTPUT_SIZE_ARRAY->DATA[0] = BATCH_SIZE;
  OUTPUT_SIZE_ARRAY->DATA[1] = NUM_UNITS;
  TF_LITE_ENSURE_OK(CONTEXT,
                    CONTEXT->RESIZETENSOR(CONTEXT, OUTPUT, OUTPUT_SIZE_ARRAY));

  // THE WEIGHTS ARE OF CONSISTENT TYPE, SO IT SUFFICES TO CHECK ONE.
  CONST BOOL IS_HYBRID_OP = ISHYBRIDOP(INPUT, WEIGHTS_FEATURE);
  CONST BOOL IS_FULL_INTEGER = INPUT->TYPE == KTFLITEINT8;

  // RESIZE SCRATCH.
  TFLITEINTARRAYFREE(NODE->TEMPORARIES);
  IF (IS_HYBRID_OP) {
    NODE->TEMPORARIES = TFLITEINTARRAYCREATE(6);
  } ELSE IF (IS_FULL_INTEGER) {
    NODE->TEMPORARIES = TFLITEINTARRAYCREATE(2);
  } ELSE {
    NODE->TEMPORARIES = TFLITEINTARRAYCREATE(1);
  }
  NODE->TEMPORARIES->DATA[0] = SCRATCH_TENSOR_INDEX;

  TFLITEINTARRAY* SCRATCH_SIZE_ARRAY = TFLITEINTARRAYCREATE(2);
  SCRATCH_SIZE_ARRAY->DATA[0] = BATCH_SIZE;
  SCRATCH_SIZE_ARRAY->DATA[1] = NUM_FILTERS;

  TFLITETENSOR* SCRATCH_TENSOR;
  TF_LITE_ENSURE_OK(
      CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/0, &SCRATCH_TENSOR));

  // THE SCRATCH BUFFER IS OF TYPE INT32 FOR FULL INTEGER SVDF AND IT'S OF TYPE
  // FLOAT32 FOR HYBRID AND FLOAT CASE.
  IF (IS_FULL_INTEGER) {
    SCRATCH_TENSOR->TYPE = KTFLITEINT32;
  } ELSE {
    SCRATCH_TENSOR->TYPE = KTFLITEFLOAT32;
  }
  SCRATCH_TENSOR->ALLOCATION_TYPE = KTFLITEARENARW;
  TF_LITE_ENSURE_OK(CONTEXT, CONTEXT->RESIZETENSOR(CONTEXT, SCRATCH_TENSOR,
                                                   SCRATCH_SIZE_ARRAY));

  IF (IS_HYBRID_OP) {
    OP_DATA->COMPUTE_ROW_SUMS = TRUE;
    // TELL INTERPRETER TO ALLOCATE TEMPORARY TENSORS TO STORE QUANTIZED VALUES
    // OF INPUT TENSORS.
    NODE->TEMPORARIES->DATA[1] = SCRATCH_TENSOR_INDEX + 1;
    TFLITETENSOR* INPUT_QUANTIZED;
    TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/1,
                                                &INPUT_QUANTIZED));
    INPUT_QUANTIZED->TYPE = WEIGHTS_FEATURE->TYPE;
    INPUT_QUANTIZED->ALLOCATION_TYPE = KTFLITEARENARW;
    IF (!TFLITEINTARRAYEQUAL(INPUT_QUANTIZED->DIMS, INPUT->DIMS)) {
      TFLITEINTARRAY* INPUT_QUANTIZED_SIZE = TFLITEINTARRAYCOPY(INPUT->DIMS);
      TF_LITE_ENSURE_OK(CONTEXT, CONTEXT->RESIZETENSOR(CONTEXT, INPUT_QUANTIZED,
                                                       INPUT_QUANTIZED_SIZE));
    }

    // TELL INTERPRETER TO ALLOCATE TEMPORARY TENSORS TO STORE SCALING FACTORS.
    NODE->TEMPORARIES->DATA[2] = SCRATCH_TENSOR_INDEX + 2;
    TFLITETENSOR* SCALING_FACTORS;
    TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/2,
                                                &SCALING_FACTORS));
    SCALING_FACTORS->TYPE = KTFLITEFLOAT32;
    SCALING_FACTORS->ALLOCATION_TYPE = KTFLITEARENARW;
    INT SCALING_DIMS[1] = {BATCH_SIZE};
    IF (!TFLITEINTARRAYEQUALSARRAY(SCALING_FACTORS->DIMS, 1, SCALING_DIMS)) {
      TFLITEINTARRAY* SCALING_FACTORS_SIZE = TFLITEINTARRAYCREATE(1);
      SCALING_FACTORS_SIZE->DATA[0] = BATCH_SIZE;
      TF_LITE_ENSURE_OK(CONTEXT, CONTEXT->RESIZETENSOR(CONTEXT, SCALING_FACTORS,
                                                       SCALING_FACTORS_SIZE));
    }

    // USED TO STORE DEQUANTIZED WEIGHTS_TIME MATRIX FOR HYBRID COMPUTATION OF
    // MATMUL(STATE, WEIGHTS_TIME), WHICH OCCURS IN FLOATING POINT.
    NODE->TEMPORARIES->DATA[3] = SCRATCH_TENSOR_INDEX + 3;
    TFLITETENSOR* FLOAT_WEIGHTS_TIME;
    TF_LITE_ENSURE_OK(CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/3,
                                                &FLOAT_WEIGHTS_TIME));
    FLOAT_WEIGHTS_TIME->TYPE = KTFLITEFLOAT32;
    // PERSISTENT SO THAT WE CAN COMPUTE THE DEQUANTIZED WEIGHTS ONLY ONCE.
    FLOAT_WEIGHTS_TIME->ALLOCATION_TYPE = KTFLITEARENARWPERSISTENT;
    IF (!TFLITEINTARRAYEQUAL(FLOAT_WEIGHTS_TIME->DIMS, WEIGHTS_TIME->DIMS)) {
      TFLITEINTARRAY* FLOAT_WEIGHTS_TIME_SIZE =
          TFLITEINTARRAYCOPY(WEIGHTS_TIME->DIMS);
      TF_LITE_ENSURE_OK(CONTEXT,
                        CONTEXT->RESIZETENSOR(CONTEXT, FLOAT_WEIGHTS_TIME,
                                              FLOAT_WEIGHTS_TIME_SIZE));
    }

    NODE->TEMPORARIES->DATA[4] = SCRATCH_TENSOR_INDEX + 4;
    TFLITETENSOR* ZERO_POINTS;
    TF_LITE_ENSURE_OK(
        CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/4, &ZERO_POINTS));
    ZERO_POINTS->TYPE = KTFLITEFLOAT32;
    ZERO_POINTS->ALLOCATION_TYPE = KTFLITEARENARW;
    INT ZERO_POINTS_DIMS[1] = {BATCH_SIZE};
    IF (!TFLITEINTARRAYEQUALSARRAY(ZERO_POINTS->DIMS, 1, ZERO_POINTS_DIMS)) {
      TFLITEINTARRAY* ZERO_POINTS_SIZE = TFLITEINTARRAYCREATE(1);
      ZERO_POINTS_SIZE->DATA[0] = ZERO_POINTS_DIMS[0];
      TF_LITE_ENSURE_OK(CONTEXT, CONTEXT->RESIZETENSOR(CONTEXT, ZERO_POINTS,
                                                       ZERO_POINTS_SIZE));
    }

    NODE->TEMPORARIES->DATA[5] = SCRATCH_TENSOR_INDEX + 5;
    TFLITETENSOR* ROW_SUMS;
    TF_LITE_ENSURE_OK(CONTEXT,
                      GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/5, &ROW_SUMS));
    ROW_SUMS->TYPE = KTFLITEFLOAT32;
    ROW_SUMS->ALLOCATION_TYPE = KTFLITEARENARWPERSISTENT;
    INT ROW_SUMS_DIMS[1] = {NUM_FILTERS};
    IF (!TFLITEINTARRAYEQUALSARRAY(ROW_SUMS->DIMS, 1, ROW_SUMS_DIMS)) {
      TFLITEINTARRAY* ROW_SUMS_SIZE = TFLITEINTARRAYCREATE(1);
      ROW_SUMS_SIZE->DATA[0] = ROW_SUMS_DIMS[0];
      TF_LITE_ENSURE_OK(
          CONTEXT, CONTEXT->RESIZETENSOR(CONTEXT, ROW_SUMS, ROW_SUMS_SIZE));
    }
  }
  IF (IS_FULL_INTEGER) {
    // ALLOCATED ONE EXTRA TENSOR.
    TFLITEINTARRAY* OUTPUT_TEMP_SIZE_ARRAY = TFLITEINTARRAYCREATE(2);
    OUTPUT_TEMP_SIZE_ARRAY->DATA[0] = NUM_UNITS;
    OUTPUT_TEMP_SIZE_ARRAY->DATA[1] = BATCH_SIZE;
    NODE->TEMPORARIES->DATA[1] = SCRATCH_TENSOR_INDEX + 1;
    TFLITETENSOR* OUTPUT_TEMP;
    TF_LITE_ENSURE_OK(
        CONTEXT, GETTEMPORARYSAFE(CONTEXT, NODE, /*INDEX=*/1, &OUTPUT_TEMP));
    OUTPUT_TEMP->TYPE = KTFLITEINT32;
    OUTPUT_TEMP->ALLOCATION_TYPE = KTFLITEARENARW;
    TF_LITE_ENSURE_OK(CONTEXT, CONTEXT->RESIZETENSOR(CONTEXT, OUTPUT_TEMP,
                                                     OUTPUT_TEMP_SIZE_ARRAY));

    // CALCULATE EFFECTIVE SCALES.
    AUTO* INPUT_PARAMS =
        REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(INPUT->QUANTIZATION.PARAMS);
    AUTO* WEIGHTS_FEATURE_PARAMS = REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(
        WEIGHTS_FEATURE->QUANTIZATION.PARAMS);
    AUTO* STATE_PARAMS =
        REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(STATE->QUANTIZATION.PARAMS);
    AUTO* WEIGHT_TIME_PARAMS = REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(
        WEIGHTS_TIME->QUANTIZATION.PARAMS);
    AUTO* OUTPUT_PARAMS = REINTERPRET_CAST<TFLITEAFFINEQUANTIZATION*>(
        OUTPUT->QUANTIZATION.PARAMS);
    CONST DOUBLE EFFECTIVE_SCALE_1 = INPUT_PARAMS->SCALE->DATA[0] *
                                     WEIGHTS_FEATURE_PARAMS->SCALE->DATA[0] /
                                     STATE_PARAMS->SCALE->DATA[0];
    CONST DOUBLE EFFECTIVE_SCALE_2 = STATE_PARAMS->SCALE->DATA[0] *
                                     WEIGHT_TIME_PARAMS->SCALE->DATA[0] /
                                     OUTPUT_PARAMS->SCALE->DATA[0];
    QUANTIZEMULTIPLIER(EFFECTIVE_SCALE_1, &OP_DATA->EFFECTIVE_SCALE_1_A,
                       &OP_DATA->EFFECTIVE_SCALE_1_B);
    QUANTIZEMULTIPLIER(EFFECTIVE_SCALE_2, &OP_DATA->EFFECTIVE_SCALE_2_A,
                       &OP_DATA->EFFECTIVE_SCALE_2_B);
  }
  RETURN KTFLITEOK;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195399_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL ISIDENTITYCONSUMINGSWITCH(CONST MUTABLEGRAPHVIEW& GRAPH,
                               CONST NODEDEF& NODE) {
  IF ((ISIDENTITY(NODE) || ISIDENTITYNSINGLEINPUT(NODE)) &&
      NODE.INPUT_SIZE() > 0) {
    TENSORID TENSOR_ID = PARSETENSORNAME(NODE.INPUT(0));
    IF (ISTENSORIDCONTROLLING(TENSOR_ID)) {
      RETURN FALSE;
    }

    NODEDEF* INPUT_NODE = GRAPH.GETNODE(TENSOR_ID.NODE());
    RETURN ISSWITCH(*INPUT_NODE);
  }
  RETURN FALSE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195059_CWE-617.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
BOOL DEPENDENCYOPTIMIZER::SAFETOREMOVEIDENTITY(CONST NODEDEF& NODE) CONST {
  IF (!ISIDENTITY(NODE) && !ISIDENTITYN(NODE)) {
    RETURN TRUE;
  }

  IF (NODES_TO_PRESERVE_.FIND(NODE.NAME()) != NODES_TO_PRESERVE_.END()) {
    RETURN FALSE;
  }
  IF (!FETCH_NODES_KNOWN_) {
    // THE OUTPUT VALUES OF THIS NODE MAY BE NEEDED.
    RETURN FALSE;
  }

  IF (NODE.INPUT_SIZE() < 1) {
    // NODE LACKS INPUT, IS INVALID
    RETURN FALSE;
  }

  CONST NODEDEF* INPUT = NODE_MAP_->GETNODE(NODENAME(NODE.INPUT(0)));
  CHECK(INPUT != NULLPTR) << "NODE = " << NODE.NAME()
                          << " INPUT = " << NODE.INPUT(0);
  // DON'T REMOVE IDENTITY NODES CORRESPONDING TO VARIABLE READS OR FOLLOWING
  // RECV.
  IF (ISVARIABLE(*INPUT) || ISRECV(*INPUT)) {
    RETURN FALSE;
  }
  FOR (CONST AUTO& CONSUMER : NODE_MAP_->GETOUTPUTS(NODE.NAME())) {
    IF (NODE.INPUT_SIZE() > 1 && (ISRETVAL(*CONSUMER) || ISMERGE(*CONSUMER))) {
      RETURN FALSE;
    }
    IF (ISSWITCH(*INPUT)) {
      FOR (CONST STRING& CONSUMER_INPUT : CONSUMER->INPUT()) {
        IF (CONSUMER_INPUT == ASCONTROLDEPENDENCY(NODE.NAME())) {
          RETURN FALSE;
        }
      }
    }
  }
  RETURN TRUE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195028_CWE-401.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID DECODEPNGV2(OPKERNELCONTEXT* CONTEXT, STRINGPIECE INPUT) {
    INT CHANNEL_BITS = (DATA_TYPE_ == DATATYPE::DT_UINT8) ? 8 : 16;
    PNG::DECODECONTEXT DECODE;
    OP_REQUIRES(
        CONTEXT, PNG::COMMONINITDECODE(INPUT, CHANNELS_, CHANNEL_BITS, &DECODE),
        ERRORS::INVALIDARGUMENT("INVALID PNG. FAILED TO INITIALIZE DECODER."));

    // VERIFY THAT WIDTH AND HEIGHT ARE NOT TOO LARGE:
    // - VERIFY WIDTH AND HEIGHT DON'T OVERFLOW INT.
    // - WIDTH CAN LATER BE MULTIPLIED BY CHANNELS_ AND SIZEOF(UINT16), SO
    //   VERIFY SINGLE DIMENSION IS NOT TOO LARGE.
    // - VERIFY WHEN WIDTH AND HEIGHT ARE MULTIPLIED TOGETHER, THERE ARE A FEW
    //   BITS TO SPARE AS WELL.
    CONST INT WIDTH = STATIC_CAST<INT>(DECODE.WIDTH);
    CONST INT HEIGHT = STATIC_CAST<INT>(DECODE.HEIGHT);
    CONST INT64_T TOTAL_SIZE =
        STATIC_CAST<INT64_T>(WIDTH) * STATIC_CAST<INT64_T>(HEIGHT);
    IF (WIDTH != STATIC_CAST<INT64_T>(DECODE.WIDTH) || WIDTH <= 0 ||
        WIDTH >= (1LL << 27) || HEIGHT != STATIC_CAST<INT64_T>(DECODE.HEIGHT) ||
        HEIGHT <= 0 || HEIGHT >= (1LL << 27) || TOTAL_SIZE >= (1LL << 29)) {
      OP_REQUIRES(CONTEXT, FALSE,
                  ERRORS::INVALIDARGUMENT("PNG SIZE TOO LARGE FOR INT: ",
                                          DECODE.WIDTH, " BY ", DECODE.HEIGHT));
    }

    TENSOR* OUTPUT = NULLPTR;
    // BY THE EXISTING API, WE SUPPORT DECODING PNG WITH `DECODEGIF` OP.
    // WE NEED TO MAKE SURE TO RETURN 4-D SHAPES WHEN USING `DECODEGIF`.
    IF (OP_TYPE_ == "DECODEGIF") {
      OP_REQUIRES_OK(
          CONTEXT,
          CONTEXT->ALLOCATE_OUTPUT(
              0, TENSORSHAPE({1, HEIGHT, WIDTH, DECODE.CHANNELS}), &OUTPUT));
    } ELSE {
      OP_REQUIRES_OK(
          CONTEXT,
          CONTEXT->ALLOCATE_OUTPUT(
              0, TENSORSHAPE({HEIGHT, WIDTH, DECODE.CHANNELS}), &OUTPUT));
    }

    IF (OP_TYPE_ == "DECODEBMP") {
      // TODO(B/171060723): ONLY DECODEBMP AS OP_TYPE_ IS NOT ACCEPTABLE HERE
      // BECAUSE CURRENTLY `DECODE_(JPEG|PNG|GIF)` OPS CAN DECODE ANY ONE OF
      // JPEG, PNG OR GIF BUT NOT BMP. SIMILARLY, `DECODE_BMP` CANNOT DECODE
      // ANYTHING BUT BMP FORMATS. THIS BEHAVIOR NEEDS TO BE REVISITED. FOR MORE
      // DETAILS, PLEASE REFER TO THE BUG.
      OP_REQUIRES(CONTEXT, FALSE,
                  ERRORS::INVALIDARGUMENT(
                      "TRYING TO DECODE PNG FORMAT USING DECODEBMP OP. USE "
                      "`DECODE_PNG` OR `DECODE_IMAGE` INSTEAD."));
    } ELSE IF (OP_TYPE_ == "DECODEANDCROPJPEG") {
      OP_REQUIRES(CONTEXT, FALSE,
                  ERRORS::INVALIDARGUMENT(
                      "DECODEANDCROPJPEG OPERATION CAN RUN ON JPEG ONLY, BUT "
                      "DETECTED PNG."));
    }

    IF (DATA_TYPE_ == DATATYPE::DT_UINT8) {
      OP_REQUIRES(
          CONTEXT,
          PNG::COMMONFINISHDECODE(
              REINTERPRET_CAST<PNG_BYTEP>(OUTPUT->FLAT<UINT8>().DATA()),
              DECODE.CHANNELS * WIDTH * SIZEOF(UINT8), &DECODE),
          ERRORS::INVALIDARGUMENT("INVALID PNG DATA, SIZE ", INPUT.SIZE()));
    } ELSE IF (DATA_TYPE_ == DATATYPE::DT_UINT16) {
      OP_REQUIRES(
          CONTEXT,
          PNG::COMMONFINISHDECODE(
              REINTERPRET_CAST<PNG_BYTEP>(OUTPUT->FLAT<UINT16>().DATA()),
              DECODE.CHANNELS * WIDTH * SIZEOF(UINT16), &DECODE),
          ERRORS::INVALIDARGUMENT("INVALID PNG DATA, SIZE ", INPUT.SIZE()));
    } ELSE IF (DATA_TYPE_ == DATATYPE::DT_FLOAT) {
      // `PNG::COMMONFINISHDECODE` DOES NOT SUPPORT `FLOAT`. FIRST ALLOCATE
      // UINT16 BUFFER FOR THE IMAGE AND DECODE IN UINT16 (LOSSLESS). WRAP THE
      // BUFFER IN `UNIQUE_PTR` SO THAT WE DON'T FORGET TO DELETE THE BUFFER.
      STD::UNIQUE_PTR<UINT16[]> BUFFER(
          NEW UINT16[HEIGHT * WIDTH * DECODE.CHANNELS]);
      OP_REQUIRES(
          CONTEXT,
          PNG::COMMONFINISHDECODE(REINTERPRET_CAST<PNG_BYTEP>(BUFFER.GET()),
                                  DECODE.CHANNELS * WIDTH * SIZEOF(UINT16),
                                  &DECODE),
          ERRORS::INVALIDARGUMENT("INVALID PNG DATA, SIZE ", INPUT.SIZE()));

      // CONVERT UINT16 IMAGE DATA TO DESIRED DATA TYPE.
      // USE EIGEN THREADPOOLING TO SPEED UP THE COPY OPERATION.
      CONST AUTO& DEVICE = CONTEXT->EIGEN_DEVICE<EIGEN::THREADPOOLDEVICE>();
      TTYPES<UINT16, 3>::UNALIGNEDCONSTTENSOR BUF(BUFFER.GET(), HEIGHT, WIDTH,
                                                  DECODE.CHANNELS);
      FLOAT SCALE = 1. / STD::NUMERIC_LIMITS<UINT16>::MAX();
      // FILL OUTPUT TENSOR WITH DESIRED DTYPE.
      OUTPUT->TENSOR<FLOAT, 3>().DEVICE(DEVICE) = BUF.CAST<FLOAT>() * SCALE;
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196829_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    CONST TENSOR& VAL = CTX->INPUT(0);
    INT64 ID = CTX->SESSION_STATE()->GETNEWID();
    TENSORSTORE::TENSORANDKEY TK{VAL, ID, REQUESTED_DEVICE()};
    OP_REQUIRES_OK(CTX, CTX->TENSOR_STORE()->ADDTENSOR(NAME(), TK));

    TENSOR* HANDLE = NULLPTR;
    OP_REQUIRES_OK(CTX, CTX->ALLOCATE_OUTPUT(0, TENSORSHAPE({}), &HANDLE));
    IF (CTX->EXPECTED_OUTPUT_DTYPE(0) == DT_RESOURCE) {
      RESOURCEHANDLE RESOURCE_HANDLE = MAKERESOURCEHANDLE<TENSOR>(
          CTX, SESSIONSTATE::KTENSORHANDLERESOURCETYPENAME,
          TK.GETHANDLE(NAME()));
      RESOURCE_HANDLE.SET_MAYBE_TYPE_NAME(
          SESSIONSTATE::KTENSORHANDLERESOURCETYPENAME);
      HANDLE->SCALAR<RESOURCEHANDLE>()() = RESOURCE_HANDLE;
    } ELSE {
      // LEGACY BEHAVIOR IN V1.
      HANDLE->FLAT<TSTRING>().SETCONSTANT(TK.GETHANDLE(NAME()));
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196587_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID DOCOMPUTE(OPKERNELCONTEXT* C) {
    CORE::REFCOUNTPTR<VAR> V;
    OP_REQUIRES_OK(C, LOOKUPRESOURCE(C, HANDLEFROMINPUT(C, 0), &V));
    TENSOR* PARAMS = V->TENSOR();
    CONST TENSOR& INDICES = C->INPUT(1);
    CONST TENSOR& UPDATES = C->INPUT(2);

    // CHECK THAT RANK(UPDATES.SHAPE) = RANK(INDICES.SHAPE + PARAMS.SHAPE[1:])
    OP_REQUIRES(C,
                UPDATES.DIMS() == 0 ||
                    UPDATES.DIMS() == INDICES.DIMS() + PARAMS->DIMS() - 1,
                ERRORS::INVALIDARGUMENT(
                    "MUST HAVE UPDATES.SHAPE = INDICES.SHAPE + "
                    "PARAMS.SHAPE[1:] OR UPDATES.SHAPE = [], GOT ",
                    "UPDATES.SHAPE ", UPDATES.SHAPE().DEBUGSTRING(),
                    ", INDICES.SHAPE ", INDICES.SHAPE().DEBUGSTRING(),
                    ", PARAMS.SHAPE ", PARAMS->SHAPE().DEBUGSTRING()));

    // CHECK THAT WE HAVE ENOUGH INDEX SPACE
    CONST INT64_T N_BIG = INDICES.NUMELEMENTS();
    OP_REQUIRES(
        C, N_BIG <= STD::NUMERIC_LIMITS<INDEX>::MAX(),
        ERRORS::INVALIDARGUMENT("INDICES HAS TOO MANY ELEMENTS FOR ",
                                DATATYPESTRING(DATATYPETOENUM<INDEX>::V()),
                                " INDEXING: ", N_BIG, " > ",
                                STD::NUMERIC_LIMITS<INDEX>::MAX()));
    CONST INDEX N = STATIC_CAST<INDEX>(N_BIG);
    OP_REQUIRES(
        C, PARAMS->DIM_SIZE(0) <= STD::NUMERIC_LIMITS<INDEX>::MAX(),
        ERRORS::INVALIDARGUMENT("PARAMS.SHAPE[0] TOO LARGE FOR ",
                                DATATYPESTRING(DATATYPETOENUM<INDEX>::V()),
                                " INDEXING: ", PARAMS->DIM_SIZE(0), " > ",
                                STD::NUMERIC_LIMITS<INDEX>::MAX()));

    IF (N > 0) {
      AUTO INDICES_FLAT = INDICES.FLAT<INDEX>();
      AUTO PARAMS_FLAT = PARAMS->FLAT_OUTER_DIMS<T>();
      IF (TENSORSHAPEUTILS::ISSCALAR(UPDATES.SHAPE())) {
        CONST AUTO UPDATE = UPDATES.SCALAR<T>();

        FUNCTOR::SCATTERSCALARFUNCTOR<DEVICE, T, INDEX, OP> FUNCTOR;
        CONST INDEX BAD_I = FUNCTOR(C, C->TEMPLATE EIGEN_DEVICE<DEVICE>(),
                                    PARAMS_FLAT, UPDATE, INDICES_FLAT);
        OP_REQUIRES(C, BAD_I < 0,
                    ERRORS::INVALIDARGUMENT(
                        "INDICES", SLICEDEBUGSTRING(INDICES.SHAPE(), BAD_I),
                        " = ", INDICES_FLAT(BAD_I), " IS NOT IN [0, ",
                        PARAMS->DIM_SIZE(0), ")"));
      } ELSE {
        INT64_T NUM_UPDATES = UPDATES.NUMELEMENTS();
        OP_REQUIRES(
            C, TENSORSHAPEUTILS::STARTSWITH(UPDATES.SHAPE(), INDICES.SHAPE()),
            ERRORS::INVALIDARGUMENT(
                "THE SHAPE OF INDICES (", INDICES.SHAPE().DEBUGSTRING(),
                ") MUST BE A PREFIX OF THE SHAPE OF UPDATES (",
                UPDATES.SHAPE().DEBUGSTRING(), ")"));
        AUTO UPDATES_FLAT = UPDATES.SHAPED<T, 2>({N, NUM_UPDATES / N});

        FUNCTOR::SCATTERFUNCTOR<DEVICE, T, INDEX, OP> FUNCTOR;
        CONST INDEX BAD_I = FUNCTOR(C, C->TEMPLATE EIGEN_DEVICE<DEVICE>(),
                                    PARAMS_FLAT, UPDATES_FLAT, INDICES_FLAT);
        OP_REQUIRES(C, BAD_I < 0,
                    ERRORS::INVALIDARGUMENT(
                        "INDICES", SLICEDEBUGSTRING(INDICES.SHAPE(), BAD_I),
                        " = ", INDICES_FLAT(BAD_I), " IS NOT IN [0, ",
                        PARAMS->DIM_SIZE(0), ")"));
      }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 245195_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
EAT_SQL_WHITESPACE(CONST CHAR *QUERY)
{
	BOOL COMMENT = FALSE;

	WHILE (*QUERY) {
		IF (COMMENT) {
			IF (QUERY[0] == '*' && QUERY[1] == '/') {
				QUERY += 2;
				COMMENT = FALSE;
				CONTINUE;
			}
			++QUERY;
			CONTINUE;
		}
		IF (QUERY[0] == '/' && QUERY[1] == '*') {
			QUERY += 2;
			COMMENT = TRUE;
			CONTINUE;
		}
		IF (STRCHR("\T\N\R (", QUERY[0])) {
			++QUERY;
			CONTINUE;
		}
		BREAK;
	}

	RETURN(QUERY);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247710_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  CONST STD::VECTOR<STD::STRING>& EXPECTEDLOCALURI() CONST { RETURN EXPECTED_LOCAL_URI_; }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 229239_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID CQL_SERVER::RESPONSE::WRITE_BYTES_AS_STRING(BYTES_VIEW S)
{
    WRITE_SHORT(CAST_IF_FITS<UINT16_T>(S.SIZE()));
    _BODY.WRITE(S);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197748_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS TRANSPOSESHAPEFN(INFERENCECONTEXT* C) {
  SHAPEHANDLE INPUT = C->INPUT(0);
  SHAPEHANDLE PERM_SHAPE = C->INPUT(1);
  CONST TENSOR* PERM = C->INPUT_TENSOR(1);
  DIMENSIONHANDLE PERM_ELEMS = C->NUMELEMENTS(PERM_SHAPE);
  // IF WE DON'T HAVE RANK INFORMATION ON THE INPUT OR VALUE INFORMATION ON
  // PERM WE CAN'T RETURN ANY SHAPE INFORMATION, OTHERWISE WE HAVE ENOUGH
  // INFORMATION TO AT LEAST FIND THE RANK OF THE OUTPUT.
  IF (!C->RANKKNOWN(INPUT) && !C->VALUEKNOWN(PERM_ELEMS) && PERM == NULLPTR) {
    C->SET_OUTPUT(0, C->UNKNOWNSHAPE());
    RETURN STATUS::OK();
  }

  // FIND OUR VALUE OF THE RANK.
  INT64_T RANK;
  IF (C->RANKKNOWN(INPUT)) {
    RANK = C->RANK(INPUT);
  } ELSE IF (C->VALUEKNOWN(PERM_ELEMS)) {
    RANK = C->VALUE(PERM_ELEMS);
  } ELSE {
    RANK = PERM->NUMELEMENTS();
  }
  IF (!C->RANKKNOWN(INPUT) && RANK < 2) {
    // A PERMUTATION ARRAY CONTAINING A SINGLE ELEMENT IS AMBIGUOUS. IT COULD
    // INDICATE EITHER A SCALAR OR A 1-DIMENSIONAL ARRAY, BOTH OF WHICH THE
    // TRANSPOSE OP RETURNS UNCHANGED.
    C->SET_OUTPUT(0, INPUT);
    RETURN STATUS::OK();
  }

  STD::VECTOR<DIMENSIONHANDLE> DIMS;
  DIMS.RESIZE(RANK);
  TF_RETURN_IF_ERROR(C->WITHRANK(INPUT, RANK, &INPUT));
  // ENSURE THAT PERM IS A VECTOR AND HAS RANK ELEMENTS.
  TF_RETURN_IF_ERROR(C->WITHRANK(PERM_SHAPE, 1, &PERM_SHAPE));
  TF_RETURN_IF_ERROR(C->WITHVALUE(PERM_ELEMS, RANK, &PERM_ELEMS));

  // IF WE KNOW THE RANK OF THE INPUT AND THE VALUE OF PERM, WE CAN RETURN
  // ALL SHAPE INFORMATION, OTHERWISE WE CAN ONLY RETURN RANK INFORMATION,
  // BUT NO INFORMATION FOR THE DIMENSIONS.
  IF (PERM != NULLPTR) {
    STD::VECTOR<INT64_T> DATA;
    IF (PERM->DTYPE() == DT_INT32) {
      DATA = ASINT64<INT32>(PERM, RANK);
    } ELSE {
      DATA = ASINT64<INT64_T>(PERM, RANK);
    }

    FOR (INT32_T I = 0; I < RANK; ++I) {
      INT64_T IN_IDX = DATA[I];
      IF (IN_IDX >= RANK) {
        RETURN ERRORS::INVALIDARGUMENT("PERM DIM ", IN_IDX,
                                       " IS OUT OF RANGE OF INPUT RANK ", RANK);
      }
      DIMS[I] = C->DIM(INPUT, IN_IDX);
    }
  } ELSE {
    FOR (INT I = 0; I < RANK; ++I) {
      DIMS[I] = C->UNKNOWNDIM();
    }
  }

  C->SET_OUTPUT(0, C->MAKESHAPE(DIMS));
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197998_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR& INPUT = CONTEXT->INPUT(0);
    CONST TENSORSHAPE& INPUT_SHAPE = INPUT.SHAPE();
    CONST INT32 INPUT_DIMS = INPUT_SHAPE.DIMS();

    CONST TENSOR& SEGMENT_ID = CONTEXT->INPUT(1);
    CONST TENSORSHAPE& SEGMENT_ID_SHAPE = SEGMENT_ID.SHAPE();
    CONST INT32 SEGMENT_DIMS = SEGMENT_ID_SHAPE.DIMS();

    CONST TENSOR& NUM_SEGMENTS_TENSOR = CONTEXT->INPUT(2);
    AUTO NUM_SEGMENTS = NUM_SEGMENTS_TENSOR.SCALAR<NUM_SEGMENTS_TYPE>()();

    OP_REQUIRES(CONTEXT, SEGMENT_DIMS != 0,
                ERRORS::INVALIDARGUMENT("SEGMENT_ID CANNOT HAVE RANK 0"));

    OP_REQUIRES(
        CONTEXT, SEGMENT_DIMS <= INPUT_DIMS,
        ERRORS::OUTOFRANGE("INVALID SEGMENT_ID RANK ", SEGMENT_DIMS,
                           " FOR INPUT WITH ", INPUT_DIMS, " DIMENSION(S)"));
    FOR (AUTO I = 0; I < SEGMENT_DIMS; I++) {
      OP_REQUIRES(
          CONTEXT, SEGMENT_ID_SHAPE.DIM_SIZE(I) == INPUT_SHAPE.DIM_SIZE(I),
          ERRORS::INVALIDARGUMENT(
              "SEGMENT DIMENSION IS ", SEGMENT_ID_SHAPE.DIM_SIZE(I),
              " WHILE INPUT DIMENSION IS ", INPUT_DIMS, " IN RANK ", I));
    }

    // MAKING OUTPUT TENSOR.
    TENSOR* OUTPUT_TENSOR = NULLPTR;
    TENSORSHAPE OUTPUT_SHAPE =
        GETOUTPUTSHAPE(INPUT_SHAPE, SEGMENT_ID_SHAPE, NUM_SEGMENTS);
    OP_REQUIRES_OK(CONTEXT, CONTEXT->ALLOCATE_OUTPUT("OUTPUT", OUTPUT_SHAPE,
                                                     &OUTPUT_TENSOR));

    // PREPARATING FLAT TENSORS.
    AUTO OUTPUT_FLAT = OUTPUT_TENSOR->FLAT<TSTRING>();
    AUTO FLAT_SEGMENT_ID = SEGMENT_ID.FLAT<INDICES_TYPE>();
    AUTO FLAT_INPUT = INPUT.FLAT<TSTRING>();

    FOR (INT I = 0; I < FLAT_SEGMENT_ID.SIZE(); I++) {
      OP_REQUIRES(
          CONTEXT,
          ((FLAT_SEGMENT_ID(I) < NUM_SEGMENTS) && (FLAT_SEGMENT_ID(I) >= 0)),
          ERRORS::INVALIDARGUMENT(
              "SEGMENT_IDS ARE NOT ALLOWED TO EXCEED NUM_SEGMENTS OR"
              " TO HAVE NEGATIVE VALUES."));
    }

    INT64 BIG_STRIDE;
    INT64 SMALL_STRIDE;
    STD::TIE(BIG_STRIDE, SMALL_STRIDE) =
        GETSTRIDES<INDICES_TYPE>(INPUT_SHAPE, SEGMENT_ID_SHAPE);
    AUTO RELATIVE_OFFSET_SET =
        GETFLATTENEDRELATIVEOFFSETS<INDICES_TYPE>(SMALL_STRIDE, BIG_STRIDE);
    FOR (AUTO START_OFFSET = 0; START_OFFSET < BIG_STRIDE; START_OFFSET++) {
      FOR (AUTO I = 0; I < RELATIVE_OFFSET_SET.SIZE(); I++) {
        AUTO OUTPUT_INDEX = START_OFFSET + FLAT_SEGMENT_ID(I) * BIG_STRIDE;
        AUTO OFFSET = START_OFFSET + RELATIVE_OFFSET_SET[I];
        IF (OUTPUT_FLAT(OUTPUT_INDEX).LENGTH() != 0)
          OUTPUT_FLAT(OUTPUT_INDEX).APPEND(SEPARATOR_.C_STR());
        OUTPUT_FLAT(OUTPUT_INDEX).APPEND(FLAT_INPUT(OFFSET));
      }
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 198013_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    // CHECKS WHAT WE'RE REMAPPING AND INVERTS THE RELEVANT REMAPPING TENSORS TO
    // BE MAPS WITH KEY = OLD ID, VALUE = NEW ID.
    STD::UNORDERED_MAP<INT64_T, INT64_T> OLD_ROW_TO_NEW_ROW_MAP;
    STD::VECTOR<BOOL> ROW_ID_PRESENT;
    CONST TENSOR* ROW_REMAPPING_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("ROW_REMAPPING", &ROW_REMAPPING_T));
    CONST AUTO ROW_REMAPPING = ROW_REMAPPING_T->VEC<INT64_T>();
    OP_REQUIRES(CONTEXT, ROW_REMAPPING.SIZE() == NUM_ROWS_,
                ERRORS::INVALIDARGUMENT(STRINGS::STRCAT(
                    "SIZE OF ROW_REMAPPING IS ", ROW_REMAPPING.SIZE(),
                    " INSTEAD OF BEING EQUAL TO NUM_ROWS=", NUM_ROWS_)));
    OP_REQUIRES_OK(CONTEXT, REMAPVECTORTOMAP(ROW_REMAPPING, &ROW_ID_PRESENT,
                                             &OLD_ROW_TO_NEW_ROW_MAP));

    // CALCULATES THE MIN/MAX OLD ROW ID THAT WE NEED TO READ, TO SAVE US FROM
    // READING SOME UNNECESSARY SLICES OF THE OLD TENSOR.
    INT64_T MIN_OLD_ROW = -1;
    INT64_T MAX_OLD_ROW = -1;
    FOR (INT I = 0; I < ROW_REMAPPING.SIZE(); ++I) {
      IF (MIN_OLD_ROW < 0 ||
          (ROW_REMAPPING(I) >= 0 && ROW_REMAPPING(I) < MIN_OLD_ROW)) {
        MIN_OLD_ROW = ROW_REMAPPING(I);
      }
      IF (MAX_OLD_ROW < 0 ||
          (ROW_REMAPPING(I) >= 0 && ROW_REMAPPING(I) > MAX_OLD_ROW)) {
        MAX_OLD_ROW = ROW_REMAPPING(I);
      }
    }

    // PROCESSES THE REMAPPING FOR COLUMNS.
    STD::UNORDERED_MAP<INT64_T, INT64_T> OLD_COL_TO_NEW_COL_MAP;
    STD::VECTOR<BOOL> COL_ID_PRESENT;
    CONST TENSOR* COL_REMAPPING_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("COL_REMAPPING", &COL_REMAPPING_T));
    CONST AUTO COL_REMAPPING = COL_REMAPPING_T->VEC<INT64_T>();
    // NOTE THAT WE ALWAYS "REMAP ROWS", EVEN WHEN THE ROW VOCABULARY DOES
    // NOT CHANGE, BECAUSE PARTITIONING REQUIRES A MAPPING FROM PARTITIONED
    // VARIABLES TO THE FULL CHECKPOINTS WE LOAD.
    CONST BOOL REMAP_COLS = COL_REMAPPING.SIZE() > 0;
    IF (REMAP_COLS) {
      OP_REQUIRES(
          CONTEXT, COL_REMAPPING.SIZE() == NUM_COLS_,
          ERRORS::INVALIDARGUMENT(STRINGS::STRCAT(
              "PROVIDED COL_REMAPPING, BUT ITS SIZE IS ", COL_REMAPPING.SIZE(),
              " INSTEAD OF BEING EQUAL TO NUM_COLS=", NUM_COLS_)));
      OP_REQUIRES_OK(CONTEXT, REMAPVECTORTOMAP(COL_REMAPPING, &COL_ID_PRESENT,
                                               &OLD_COL_TO_NEW_COL_MAP));
    } ELSE {
      COL_ID_PRESENT.CLEAR();
      COL_ID_PRESENT.RESIZE(NUM_COLS_, TRUE);
    }

    // PROCESSES THE CHECKPOINT SOURCE AND THE PROVIDED TENSOR NAME.
    CONST TENSOR* CKPT_PATH_T;
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("CKPT_PATH", &CKPT_PATH_T));
    OP_REQUIRES(
        CONTEXT, CKPT_PATH_T->NUMELEMENTS() == 1,
        ERRORS::INVALIDARGUMENT("THE `CKPT_PATH` TENSOR MUST HAVE EXACTLY ONE "
                                "ELEMENT, GOT TENSOR OF SHAPE ",
                                CKPT_PATH_T->SHAPE().DEBUGSTRING()));
    CONST STRING& CKPT_PATH = CKPT_PATH_T->SCALAR<TSTRING>()();
    CONST TENSOR* OLD_TENSOR_NAME_T;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->INPUT("OLD_TENSOR_NAME", &OLD_TENSOR_NAME_T));
    CONST STRING& OLD_TENSOR_NAME = OLD_TENSOR_NAME_T->SCALAR<TSTRING>()();

    LOG(INFO) << "PROCESSING CHECKPOINT : " << CKPT_PATH;
    BUNDLEREADER READER(CONTEXT->ENV(), CKPT_PATH);
    OP_REQUIRES_OK(CONTEXT, READER.STATUS());

    DATATYPE TENSOR_TYPE;
    TENSORSHAPE TENSOR_SHAPE;
    OP_REQUIRES_OK(CONTEXT, READER.LOOKUPDTYPEANDSHAPE(
                                OLD_TENSOR_NAME, &TENSOR_TYPE, &TENSOR_SHAPE));
    OP_REQUIRES(CONTEXT, TENSOR_TYPE == DT_FLOAT,
                ERRORS::INVALIDARGUMENT(STRINGS::STRCAT(
                    "TENSOR ", OLD_TENSOR_NAME, " HAS INVALID TYPE ",
                    DATATYPESTRING(TENSOR_TYPE), " INSTEAD OF EXPECTED TYPE ",
                    DATATYPESTRING(DT_FLOAT))));
    // THIS OP IS LIMITED TO LOADING TENSORS OF RANK 2 (MATRICES).
    OP_REQUIRES(
        CONTEXT, TENSOR_SHAPE.DIMS() == 2,
        ERRORS::INVALIDARGUMENT(STRINGS::STRCAT(
            "TENSOR ", OLD_TENSOR_NAME, " HAS SHAPE ",
            TENSOR_SHAPE.DEBUGSTRING(), " OF INVALID RANK ",
            TENSOR_SHAPE.DIMS(), " INSTEAD OF EXPECTED SHAPE OF RANK 2.")));

    IF (!REMAP_COLS) {
      // TODO(WEIHO): CONSIDER RELAXING THIS RESTRICTION TO ALLOW PARTIAL COLUMN
      // LOADING (EVEN WHEN NO COLUMN REMAPPING IS SPECIFIED) IF THERE TURNS OUT
      // TO BE A USE CASE FOR IT.
      OP_REQUIRES(CONTEXT, NUM_COLS_ == TENSOR_SHAPE.DIM_SIZE(1),
                  ERRORS::INVALIDARGUMENT(STRINGS::STRCAT(
                      "TENSOR ", OLD_TENSOR_NAME, " HAS SHAPE ",
                      TENSOR_SHAPE.DEBUGSTRING(),
                      ", WHERE THE SIZE OF ITS 2ND DIMENSION IS ",
                      TENSOR_SHAPE.DIM_SIZE(1),
                      " INSTEAD OF BEING EQUAL TO NUM_COLS=", NUM_COLS_)));
    }

    // USES TENSORSLICE TO POTENTIALLY LOAD THE OLD TENSOR IN CHUNKS IN CASE
    // MEMORY USAGE IS A CONCERN.
    STD::VECTOR<TENSORSLICE> TENSOR_SLICES;
    TENSORSLICE SLICE(TENSOR_SHAPE.DIMS());
    IF (MIN_OLD_ROW >= 0 && MAX_OLD_ROW >= 0) {
      INT64_T ROW_START = MIN_OLD_ROW;
      // TODO(WEIHO): GIVEN THE LIST OF OLD ROW IDS OF INTEREST (THE KEYS OF
      // OLD_ROW_TO_NEW_ROW_MAP), WE COULD ALSO TRY SOMETHING SMARTER TO
      // FIND SOME MINIMAL SET OF COVERING RANGES FOR THE LIST OF OLD ROW IDS
      // SUCH THAT THE SIZE OF EACH RANGE IS LESS THAN MAX_ROWS_IN_MEMORY_.
      WHILE (ROW_START <= MAX_OLD_ROW) {
        CONST INT64_T SLICE_LENGTH =
            MAX_ROWS_IN_MEMORY_ <= 0
                // IF MAX_ROWS_IN_MEMORY_ <= 0, WE JUST LOAD THE ENTIRE CHUNK.
                ? MAX_OLD_ROW - ROW_START + 1
                : STD::MIN(MAX_ROWS_IN_MEMORY_, MAX_OLD_ROW - ROW_START + 1);
        SLICE.SET_START(0, ROW_START);
        SLICE.SET_LENGTH(0, SLICE_LENGTH);
        TENSOR_SLICES.PUSH_BACK(SLICE);
        ROW_START += SLICE_LENGTH;
      }
    }

    // ALLOCATES THE OUTPUT MATRIX.
    TENSOR* OUTPUT_MATRIX_T = NULLPTR;
    OP_REQUIRES_OK(CONTEXT,
                   CONTEXT->ALLOCATE_OUTPUT("OUTPUT_MATRIX",
                                            TENSORSHAPE({NUM_ROWS_, NUM_COLS_}),
                                            &OUTPUT_MATRIX_T));
    AUTO OUTPUT_MATRIX = OUTPUT_MATRIX_T->MATRIX<FLOAT>();

    // ITERATES THROUGH TENSOR SLICES AND COPIES OVER VALUES FROM THE OLD TENSOR
    // TO THE OUTPUT MATRIX.
    INT64_T ROW_INDEX = MIN_OLD_ROW;
    INT64_T ROWS_COPIED = 0;
    TENSOR LOADED_TENSOR_T;
    FOR (CONST TENSORSLICE& TENSOR_SLICE : TENSOR_SLICES) {
      LOG(INFO) << "LOADING SLICE " << TENSOR_SLICE.DEBUGSTRING();
      TENSORSHAPE SLICE_SHAPE;
      OP_REQUIRES_OK(CONTEXT,
                     TENSOR_SLICE.SLICETENSORSHAPE(TENSOR_SHAPE, &SLICE_SHAPE));
      // POTENTIALLY RE-ALLOCATES THE TENSOR BUFFER SINCE THE LAST SLICE MAY
      // HAVE FEWER ROWS THAN THE OTHER SLICES.
      IF (LOADED_TENSOR_T.SHAPE() != SLICE_SHAPE) {
        LOADED_TENSOR_T = TENSOR(DT_FLOAT, SLICE_SHAPE);
      }
      OP_REQUIRES_OK(CONTEXT, READER.LOOKUPSLICE(OLD_TENSOR_NAME, TENSOR_SLICE,
                                                 &LOADED_TENSOR_T));

      // ITERATES THROUGH THE OLD LOADED TENSOR SLICE ROW-BY-ROW.
      FOR (INT ROW = 0; ROW < LOADED_TENSOR_T.DIM_SIZE(0); ++ROW, ++ROW_INDEX) {
        IF (ROW_INDEX % 500000 == MIN_OLD_ROW) {
          LOG(INFO) << "PROCESSING OLD ROW " << ROW_INDEX;
        }

        // IF THE OLD ROW ID IS NOT FOUND IN OLD_ROW_TO_NEW_ROW_MAP, CONTINUE
        // TO THE NEXT ROW; OTHERWISE, COPY IT TO THE OUTPUT MATRIX.
        CONST INT64_T* NEW_ROW_PTR =
            GTL::FINDORNULL(OLD_ROW_TO_NEW_ROW_MAP, ROW_INDEX);
        IF (NEW_ROW_PTR == NULLPTR) {
          CONTINUE;
        }
        ++ROWS_COPIED;
        CONST INT64_T NEW_ROW = *NEW_ROW_PTR;

        // COPIES OVER THE ROW ELEMENT-BY-ELEMENT, IN CASE REMAPPING IS NEEDED
        // ALONG THE COLUMN AXIS.
        CONST AUTO& LOADED_TENSOR = LOADED_TENSOR_T.MATRIX<FLOAT>();
        FOR (INT OLD_COL = 0; OLD_COL < LOADED_TENSOR_T.DIM_SIZE(1);
             ++OLD_COL) {
          INT64_T NEW_COL = OLD_COL;
          IF (REMAP_COLS) {
            CONST INT64_T* NEW_COL_PTR =
                GTL::FINDORNULL(OLD_COL_TO_NEW_COL_MAP, OLD_COL);
            IF (NEW_COL_PTR == NULLPTR) {
              // COLUMN REMAPPING IS SPECIFIED, BUT THIS COLUMN IS NOT FOUND IN
              // OLD_COL_TO_NEW_COL_MAP, SO WE LEAVE IT UNINITIALIZED, TO BE
              // FILLED IN WITH INITIALIZING_VALUES LATER.
              CONTINUE;
            }
            NEW_COL = *NEW_COL_PTR;
          }

          OP_REQUIRES(CONTEXT,
                      NEW_ROW < NUM_ROWS_ && NEW_COL < NUM_COLS_ &&
                          NEW_ROW >= 0 && NEW_COL >= 0,
                      ERRORS::INTERNAL(STRINGS::STRCAT(
                          "NEW_ROW=", NEW_ROW, " AND NEW_COL=", NEW_COL,
                          " SHOULD HAVE BEEN LESS THAN NUM_ROWS_=", NUM_ROWS_,
                          " AND NUM_COLS_=", NUM_COLS_,
                          " AND NON-NEGATIVE. THIS SHOULD NEVER HAVE HAPPENED "
                          "IF THE CODE WERE CORRECT. PLEASE FILE A BUG.")));
          OUTPUT_MATRIX(NEW_ROW, NEW_COL) = LOADED_TENSOR(ROW, OLD_COL);
        }
      }
    }
    LOG(INFO) << "COPIED " << ROWS_COPIED << " ROWS FROM OLD MATRIX (WITH "
              << TENSOR_SHAPE.DIM_SIZE(0) << " ROWS) TO NEW MATRIX (WITH "
              << NUM_ROWS_ << " ROWS).";

    // AT THIS POINT, THERE ARE POTENTIALLY WHOLE ROWS/COLUMNS UNINITIALIZED
    // (CORRESPONDING TO THE INDICES WHERE ROW_ID_PRESENT/COL_ID_PRESENT ARE
    // FALSE). WE FILL THIS IN CELL-BY-CELL USING ROW_ID_PRESENT AND
    // COL_ID_PRESENT WHILE DEQUEUING FROM THE INITIALIZING_VALUES VECTOR.
    CONST TENSOR* INITIALIZING_VALUES_T;
    OP_REQUIRES_OK(
        CONTEXT, CONTEXT->INPUT("INITIALIZING_VALUES", &INITIALIZING_VALUES_T));
    CONST AUTO INITIALIZING_VALUES = INITIALIZING_VALUES_T->FLAT<FLOAT>();
    INT64_T INITIALIZING_VALUES_INDEX = 0;
    FOR (INT I = 0; I < NUM_ROWS_; ++I) {
      FOR (INT J = 0; J < NUM_COLS_; ++J) {
        IF (ROW_ID_PRESENT[I] && COL_ID_PRESENT[J]) CONTINUE;
        OP_REQUIRES(
            CONTEXT, INITIALIZING_VALUES_INDEX < INITIALIZING_VALUES.SIZE(),
            ERRORS::INVALIDARGUMENT(
                "INITIALIZING_VALUES CONTAINED ", INITIALIZING_VALUES.SIZE(),
                " ELEMENTS, BUT MORE MISSING VALUES REMAIN."));
        OUTPUT_MATRIX(I, J) = INITIALIZING_VALUES(INITIALIZING_VALUES_INDEX);
        ++INITIALIZING_VALUES_INDEX;
      }
    }

    // CHECKS THAT WE USED ALL THE GIVEN INITIALIZING VALUES.
    OP_REQUIRES(
        CONTEXT, INITIALIZING_VALUES_INDEX == INITIALIZING_VALUES.SIZE(),
        ERRORS::INVALIDARGUMENT(
            "INITIALIZING_VALUES CONTAINED ", INITIALIZING_VALUES.SIZE(),
            " ELEMENTS, BUT ONLY ", INITIALIZING_VALUES_INDEX,
            " ELEMENTS WERE USED TO FILL IN MISSING VALUES."));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195410_CWE-476.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID MAKEDATASET(OPKERNELCONTEXT* CTX, DATASETBASE** OUTPUT) OVERRIDE {
    // CREATE A NEW SPARSETENSORSLICEDATASETOP::DATASET, INSERT IT IN
    // THE STEP CONTAINER, AND RETURN IT AS THE OUTPUT.
    CONST TENSOR* INDICES;
    OP_REQUIRES_OK(CTX, CTX->INPUT("INDICES", &INDICES));
    CONST TENSOR* VALUES;
    OP_REQUIRES_OK(CTX, CTX->INPUT("VALUES", &VALUES));
    CONST TENSOR* DENSE_SHAPE;
    OP_REQUIRES_OK(CTX, CTX->INPUT("DENSE_SHAPE", &DENSE_SHAPE));

    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISMATRIX(INDICES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE ",
                    INDICES->SHAPE().DEBUGSTRING()));

    CONST AUTO NUM_INDICES = INDICES->NUMELEMENTS();
    CONST AUTO NUM_VALUES = VALUES->NUMELEMENTS();
    IF (NUM_INDICES == 0 || NUM_VALUES == 0) {
      OP_REQUIRES(CTX, NUM_INDICES == NUM_VALUES,
                  ERRORS::INVALIDARGUMENT(
                      "IF INDICES OR VALUES ARE EMPTY, THE OTHER ONE MUST ALSO "
                      "BE. GOT INDICES OF SHAPE ",
                      INDICES->SHAPE().DEBUGSTRING(), " AND VALUES OF SHAPE ",
                      VALUES->SHAPE().DEBUGSTRING()));
    }
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISVECTOR(VALUES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT VALUES SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CTX, TENSORSHAPEUTILS::ISVECTOR(DENSE_SHAPE->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    DENSE_SHAPE->SHAPE().DEBUGSTRING()));

    // WE CURRENTLY ENSURE THAT `SPARSE_TENSOR` IS ORDERED IN THE
    // BATCH DIMENSION.
    // TODO(MRRY): INVESTIGATE WAYS TO AVOID THIS UNCONDITIONAL CHECK
    // IF WE CAN BE SURE THAT THE SPARSE TENSOR WAS PRODUCED IN AN
    // APPROPRIATE ORDER (E.G. BY `TF.PARSE_EXAMPLE()` OR A DATASET
    // THAT BATCHES ELEMENTS INTO ROWS OF A SPARSETENSOR).
    INT64_T PREVIOUS_BATCH_INDEX = -1;
    FOR (INT64_T I = 0; I < INDICES->DIM_SIZE(0); ++I) {
      INT64_T NEXT_BATCH_INDEX = INDICES->MATRIX<INT64_T>()(I, 0);
      OP_REQUIRES(
          CTX, NEXT_BATCH_INDEX >= PREVIOUS_BATCH_INDEX,
          ERRORS::UNIMPLEMENTED("THE SPARSETENSOR MUST BE ORDERED IN THE BATCH "
                                "DIMENSION; HANDLING ARBITRARILY ORDERED INPUT "
                                "IS NOT CURRENTLY SUPPORTED."));
      PREVIOUS_BATCH_INDEX = NEXT_BATCH_INDEX;
    }
    GTL::INLINEDVECTOR<INT64_T, 8> STD_ORDER(DENSE_SHAPE->NUMELEMENTS(), 0);
    SPARSE::SPARSETENSOR TENSOR;
    OP_REQUIRES_OK(
        CTX, SPARSE::SPARSETENSOR::CREATE(
                 *INDICES, *VALUES, TENSORSHAPE(DENSE_SHAPE->VEC<INT64_T>()),
                 STD_ORDER, &TENSOR));
    *OUTPUT = NEW DATASET<T>(CTX, STD::MOVE(TENSOR));
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 256122_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
ALWAYS_INLINE VOID SCALARMULADD3WAY(CONST FLOAT A1, CONST FLOAT A2,
                                    CONST FLOAT A3, CONST FLOAT** INP1,
                                    CONST FLOAT** INP2, CONST FLOAT** INP3,
                                    FLOAT** OUT) {
  **OUT += A1 * **INP1 + A2 * **INP2 + A3 * **INP3;
  ++*OUT;
  ++*INP1;
  ++*INP2;
  ++*INP3;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195233_CWE-787.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  STATUS SETUNKNOWNSHAPE(CONST NODEDEF* NODE, INT OUTPUT_PORT) {
    SHAPE_INFERENCE::SHAPEHANDLE SHAPE =
        GETUNKNOWNOUTPUTSHAPE(NODE, OUTPUT_PORT);
    INFERENCECONTEXT* CTX = GETCONTEXT(NODE);
    IF (CTX == NULLPTR) {
      RETURN ERRORS::INVALIDARGUMENT("MISSING CONTEXT");
    }
    CTX->SET_OUTPUT(OUTPUT_PORT, SHAPE);
    RETURN STATUS::OK();
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195261_CWE-754.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
NODE* GRAPH::ADDNODE(NODEDEF NODE_DEF, STATUS* STATUS) {
  CONST OPREGISTRATIONDATA* OP_REG_DATA;
  STATUS->UPDATE(OPS_.LOOKUP(NODE_DEF.OP(), &OP_REG_DATA));
  IF (!STATUS->OK()) RETURN NULLPTR;

  DATATYPEVECTOR INPUTS;
  DATATYPEVECTOR OUTPUTS;
  STATUS->UPDATE(
      INOUTTYPESFORNODE(NODE_DEF, OP_REG_DATA->OP_DEF, &INPUTS, &OUTPUTS));
  IF (!STATUS->OK()) {
    *STATUS = ATTACHDEF(*STATUS, NODE_DEF);
    RETURN NULLPTR;
  }

  NODE::NODECLASS NODE_CLASS = OP_REG_DATA->IS_FUNCTION_OP
                                   ? NODE::NC_FUNCTION_OP
                                   : NODE::GETNODECLASSFOROP(NODE_DEF.OP());

  IF (OP_REG_DATA->TYPE_CTOR != NULLPTR) {
    VLOG(3) << "ADDNODE: FOUND TYPE CONSTRUCTOR FOR " << NODE_DEF.NAME();
    CONST AUTO CTOR_TYPE =
        FULL_TYPE::SPECIALIZETYPE(ATTRSLICE(NODE_DEF), OP_REG_DATA->OP_DEF);
    CONST FULLTYPEDEF CTOR_TYPEDEF = CTOR_TYPE.VALUEORDIE();
    IF (CTOR_TYPEDEF.TYPE_ID() != TFT_UNSET) {
      *(NODE_DEF.MUTABLE_EXPERIMENTAL_TYPE()) = CTOR_TYPEDEF;
    }
  } ELSE {
    VLOG(3) << "ADDNODE: NO TYPE CONSTRUCTOR FOR " << NODE_DEF.NAME();
  }

  NODE* NODE = ALLOCATENODE(STD::MAKE_SHARED<NODEPROPERTIES>(
                                &OP_REG_DATA->OP_DEF, STD::MOVE(NODE_DEF),
                                INPUTS, OUTPUTS, OP_REG_DATA->FWD_TYPE_FN),
                            NULLPTR, NODE_CLASS);
  RETURN NODE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 220184_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
STATUS GRAPH::ADDWHILEINPUTHACK(NODE* NEW_SRC, INT NEW_SRC_INDEX, NODE* DST) {
  IF (!DST->ISWHILENODE()) {
    RETURN ERRORS::INTERNAL(
        "DST ARGUMENT TO ADDWHILEEDGEHACK SHOULD BE A WHILE OP, GOT: ",
        DST->DEBUGSTRING());
  }
  TF_RETURN_IF_ERROR(ISVALIDOUTPUTTENSOR(NEW_SRC, NEW_SRC_INDEX));
  // FIND THE CURRENT NUMBER OF DATA INPUTS. WE'LL ADD THE NEW EDGE TO THE NEXT
  // MISSING DATA INPUT.
  INT DST_INDEX = 0;
  FOR (CONST EDGE* EDGE : DST->IN_EDGES()) {
    IF (EDGE->ISCONTROLEDGE()) CONTINUE;
    ++DST_INDEX;
  }
  TF_RETURN_IF_ERROR(ISVALIDINPUTTENSOR(DST, DST_INDEX));
  ADDEDGE(NEW_SRC, NEW_SRC_INDEX, DST, DST_INDEX);
  DST->MAYBECOPYONWRITE();
  DST->PROPS_->NODE_DEF.ADD_INPUT(
      STRINGS::STRCAT(NEW_SRC->NAME(), ":", NEW_SRC_INDEX));
  RETURN STATUS::OK();
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 356683_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
VOID STATEMENT::GETROW(ROW* ROW, SQLITE3_STMT* STMT) {
    INT ROWS = SQLITE3_COLUMN_COUNT(STMT);

    FOR (INT I = 0; I < ROWS; I++) {
        INT TYPE = SQLITE3_COLUMN_TYPE(STMT, I);
        CONST CHAR* NAME = SQLITE3_COLUMN_NAME(STMT, I);
        SWITCH (TYPE) {
            CASE SQLITE_INTEGER: {
                ROW->PUSH_BACK(NEW VALUES::INTEGER(NAME, SQLITE3_COLUMN_INT64(STMT, I)));
            }   BREAK;
            CASE SQLITE_FLOAT: {
                ROW->PUSH_BACK(NEW VALUES::FLOAT(NAME, SQLITE3_COLUMN_DOUBLE(STMT, I)));
            }   BREAK;
            CASE SQLITE_TEXT: {
                CONST CHAR* TEXT = (CONST CHAR*)SQLITE3_COLUMN_TEXT(STMT, I);
                INT LENGTH = SQLITE3_COLUMN_BYTES(STMT, I);
                ROW->PUSH_BACK(NEW VALUES::TEXT(NAME, LENGTH, TEXT));
            } BREAK;
            CASE SQLITE_BLOB: {
                CONST VOID* BLOB = SQLITE3_COLUMN_BLOB(STMT, I);
                INT LENGTH = SQLITE3_COLUMN_BYTES(STMT, I);
                ROW->PUSH_BACK(NEW VALUES::BLOB(NAME, LENGTH, BLOB));
            }   BREAK;
            CASE SQLITE_NULL: {
                ROW->PUSH_BACK(NEW VALUES::NULL(NAME));
            }   BREAK;
            DEFAULT:
                ASSERT(FALSE);
        }
    }
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195023_CWE-190.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR* INPUT_INDICES;
    CONST TENSOR* INPUT_VALUES;
    CONST TENSOR* INPUT_SHAPE;
    SPARSETENSORSMAP* MAP;

    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_INDICES", &INPUT_INDICES));
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_VALUES", &INPUT_VALUES));
    OP_REQUIRES_OK(CONTEXT, CONTEXT->INPUT("SPARSE_SHAPE", &INPUT_SHAPE));
    OP_REQUIRES_OK(CONTEXT, GETMAP(CONTEXT, TRUE /* IS_WRITING */, &MAP));

    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISMATRIX(INPUT_INDICES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT INDICES SHOULD BE A MATRIX BUT RECEIVED SHAPE ",
                    INPUT_INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_VALUES->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT VALUES SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INPUT_VALUES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(INPUT_SHAPE->SHAPE()),
                ERRORS::INVALIDARGUMENT(
                    "INPUT SHAPE SHOULD BE A VECTOR BUT RECEIVED SHAPE ",
                    INPUT_SHAPE->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CONTEXT,
        INPUT_VALUES->SHAPE().DIM_SIZE(0) == INPUT_INDICES->SHAPE().DIM_SIZE(0),
        ERRORS::INVALIDARGUMENT(
            "NUMBER OF VALUES MUST MATCH FIRST DIMENSION OF INDICES. ", "GOT ",
            INPUT_VALUES->SHAPE().DIM_SIZE(0),
            " VALUES, INDICES SHAPE: ", INPUT_INDICES->SHAPE().DEBUGSTRING()));
    OP_REQUIRES(
        CONTEXT,
        INPUT_SHAPE->SHAPE().DIM_SIZE(0) == INPUT_INDICES->SHAPE().DIM_SIZE(1),
        ERRORS::INVALIDARGUMENT(
            "NUMBER OF DIMENSIONS MUST MATCH SECOND DIMENSION OF INDICES. ",
            "GOT ", INPUT_SHAPE->SHAPE().DIM_SIZE(0),
            " DIMENSIONS, INDICES SHAPE: ",
            INPUT_INDICES->SHAPE().DEBUGSTRING()));

    INT RANK = INPUT_SHAPE->NUMELEMENTS();

    OP_REQUIRES(
        CONTEXT, RANK > 1,
        ERRORS::INVALIDARGUMENT(
            "RANK OF INPUT SPARSETENSOR SHOULD BE > 1, BUT SAW RANK: ", RANK));

    AUTO INPUT_SHAPE_VEC = INPUT_SHAPE->VEC<INT64_T>();
    INT NEW_NUM_ELEMENTS = 1;
    BOOL OVERFLOW_OCURRED = FALSE;
    FOR (INT I = 0; I < INPUT_SHAPE_VEC.SIZE(); I++) {
      NEW_NUM_ELEMENTS =
          MULTIPLYWITHOUTOVERFLOW(NEW_NUM_ELEMENTS, INPUT_SHAPE_VEC(I));
      IF (NEW_NUM_ELEMENTS < 0) {
        OVERFLOW_OCURRED = TRUE;
        BREAK;
      }
    }

    OP_REQUIRES(
        CONTEXT, !OVERFLOW_OCURRED,
        ERRORS::INTERNAL("ENCOUNTERED OVERFLOW FROM LARGE INPUT SHAPE."));

    TENSORSHAPE TENSOR_INPUT_SHAPE(INPUT_SHAPE_VEC);
    GTL::INLINEDVECTOR<INT64_T, 8> STD_ORDER(RANK);
    STD::IOTA(STD_ORDER.BEGIN(), STD_ORDER.END(), 0);
    SPARSETENSOR INPUT_ST;
    OP_REQUIRES_OK(CONTEXT, SPARSETENSOR::CREATE(*INPUT_INDICES, *INPUT_VALUES,
                                                 TENSOR_INPUT_SHAPE, STD_ORDER,
                                                 &INPUT_ST));

    CONST INT64_T N = INPUT_SHAPE_VEC(0);

    TENSOR SPARSE_HANDLES(DT_INT64, TENSORSHAPE({N}));
    AUTO SPARSE_HANDLES_T = SPARSE_HANDLES.VEC<INT64_T>();

    OP_REQUIRES_OK(CONTEXT, INPUT_ST.INDICESVALID());

    // WE CAN GENERATE THE OUTPUT SHAPE PROTO STRING NOW, FOR ALL
    // MINIBATCH ENTRIES.
    TENSORSHAPE OUTPUT_SHAPE;
    OP_REQUIRES_OK(CONTEXT, TENSORSHAPEUTILS::MAKESHAPE(
                                INPUT_SHAPE_VEC.DATA() + 1,
                                INPUT_SHAPE->NUMELEMENTS() - 1, &OUTPUT_SHAPE));

    // GET GROUPS BY MINIBATCH DIMENSION
    STD::UNORDERED_SET<INT64_T> VISITED;
    SPARSE::GROUPITERABLE MINIBATCH = INPUT_ST.GROUP({0});
    FOR (CONST AUTO& SUBSET : MINIBATCH) {
      CONST INT64_T B = SUBSET.GROUP()[0];
      VISITED.INSERT(B);
      OP_REQUIRES(
          CONTEXT, B > -1 && B < N,
          ERRORS::INVALIDARGUMENT(
              "RECEIVED UNEXPECTED COLUMN 0 VALUE IN INPUT SPARSETENSOR: ", B,
              " < 0 OR >= N (= ", N, ")"));

      CONST AUTO INDICES = SUBSET.INDICES();
      CONST AUTO VALUES = SUBSET.VALUES<T>();
      CONST INT64_T NUM_ENTRIES = VALUES.SIZE();

      TENSOR OUTPUT_INDICES = TENSOR(DT_INT64, {NUM_ENTRIES, RANK - 1});
      TENSOR OUTPUT_VALUES = TENSOR(DATATYPETOENUM<T>::VALUE, {NUM_ENTRIES});

      AUTO OUTPUT_INDICES_T = OUTPUT_INDICES.MATRIX<INT64_T>();
      AUTO OUTPUT_VALUES_T = OUTPUT_VALUES.VEC<T>();

      FOR (INT I = 0; I < NUM_ENTRIES; ++I) {
        FOR (INT D = 1; D < RANK; ++D) {
          OUTPUT_INDICES_T(I, D - 1) = INDICES(I, D);
        }
        OUTPUT_VALUES_T(I) = VALUES(I);
      }

      SPARSETENSOR ST_I;
      OP_REQUIRES_OK(CONTEXT,
                     SPARSETENSOR::CREATE(OUTPUT_INDICES, OUTPUT_VALUES,
                                          OUTPUT_SHAPE, &ST_I));
      INT64_T HANDLE;
      OP_REQUIRES_OK(CONTEXT, MAP->ADDSPARSETENSOR(CONTEXT, ST_I, &HANDLE));
      SPARSE_HANDLES_T(B) = HANDLE;
    }

    // FILL IN ANY GAPS; WE MUST PROVIDE AN EMPTY ST FOR BATCH ENTRIES
    // THE GROUPER DIDN'T FIND.
    IF (VISITED.SIZE() < N) {
      TENSOR EMPTY_INDICES(DT_INT64, {0, RANK - 1});
      TENSOR EMPTY_VALUES(DATATYPETOENUM<T>::VALUE, {0});
      SPARSETENSOR EMPTY_ST;
      OP_REQUIRES_OK(CONTEXT, SPARSETENSOR::CREATE(EMPTY_INDICES, EMPTY_VALUES,
                                                   OUTPUT_SHAPE, &EMPTY_ST));

      FOR (INT64_T B = 0; B < N; ++B) {
        // WE SKIPPED THIS BATCH ENTRY.
        IF (VISITED.FIND(B) == VISITED.END()) {
          INT64_T HANDLE;
          OP_REQUIRES_OK(CONTEXT,
                         MAP->ADDSPARSETENSOR(CONTEXT, EMPTY_ST, &HANDLE));
          SPARSE_HANDLES_T(B) = HANDLE;
        }
      }
    }

    CONTEXT->SET_OUTPUT(0, SPARSE_HANDLES);
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 240612_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
READVARIABLESOP::READVARIABLESOP(OPKERNELCONSTRUCTION* C) : OPKERNEL(C) {
  INT N;
  OP_REQUIRES_OK(C, C->GETATTR("N", &N));
  OP_REQUIRES_OK(C, C->GETATTR("DTYPES", &DTYPES_));
  OP_REQUIRES(C, N == DTYPES_.SIZE(),
              ERRORS::INVALIDARGUMENT(
                  "MISMATCHED NUMBER OF ARGUMENTS TO READVARIABLESOP (", N,
                  " VS. ", DTYPES_.SIZE(), ")"));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 197395_CWE-369.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CONTEXT) OVERRIDE {
    CONST TENSOR& INPUT = CONTEXT->INPUT(0);
    CONST TENSOR& DIMS = CONTEXT->INPUT(1);

    IF (TENSORSHAPEUTILS::ISSCALAR(INPUT.SHAPE())) {
      CONTEXT->SET_OUTPUT(0, INPUT);
    } ELSE {
      CONST INT INPUT_DIMS = INPUT.DIMS();
      OP_REQUIRES(CONTEXT, TENSORSHAPEUTILS::ISVECTOR(DIMS.SHAPE()),
                  ERRORS::INVALIDARGUMENT("'DIMS' MUST BE 1-DIMENSION, NOT ",
                                          DIMS.DIMS()));

      OP_REQUIRES(
          CONTEXT, INPUT_DIMS == DIMS.DIM_SIZE(0),
          ERRORS::INVALIDARGUMENT(
              "'DIMS' MUST HAVE THE SAME NUMBER OF VALUES AS 'INPUT' HAS "
              "DIMENSIONS. 'INPUT' HAS ",
              INPUT_DIMS, "'DIMS' HAS ", DIMS.DIM_SIZE(0), " VALUES"));
      OP_REQUIRES(CONTEXT, INPUT_DIMS <= 8,
                  ERRORS::UNIMPLEMENTED(
                      "REVERSE IS NOT IMPLEMENTED FOR TENSORS OF RANK > 8."));

      TENSOR* OUTPUT = NULLPTR;
      OP_REQUIRES_OK(CONTEXT,
                     CONTEXT->ALLOCATE_OUTPUT(0, INPUT.SHAPE(), &OUTPUT));

#DEFINE HANDLE_REVERSE(NDIMS)                                               \
  CASE NDIMS:                                                               \
    HANDLEREVERSECASE<DEVICE, T, NDIMS>(CONTEXT, DIMS.VEC<BOOL>(), OUTPUT); \
    RETURN;

      SWITCH (INPUT_DIMS) {
        HANDLE_REVERSE(0);
        HANDLE_REVERSE(1);
        HANDLE_REVERSE(2);
        HANDLE_REVERSE(3);
        HANDLE_REVERSE(4);
        HANDLE_REVERSE(5);
        HANDLE_REVERSE(6);
        HANDLE_REVERSE(7);
        HANDLE_REVERSE(8);
      }
#UNDEF HANDLE_REVERSE
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 214335_CWE-79.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT RGWGETOBJ_OBJSTORE_S3::SEND_RESPONSE_DATA(BUFFERLIST& BL, OFF_T BL_OFS,
					      OFF_T BL_LEN)
{
  CONST CHAR *CONTENT_TYPE = NULL;
  STRING CONTENT_TYPE_STR;
  MAP<STRING, STRING> RESPONSE_ATTRS;
  MAP<STRING, STRING>::ITERATOR RITER;
  BUFFERLIST METADATA_BL;

  STRING EXPIRES = GET_S3_EXPIRATION_HEADER(S, LASTMOD);

  IF (SENT_HEADER)
    GOTO SEND_DATA;

  IF (CUSTOM_HTTP_RET) {
    SET_REQ_STATE_ERR(S, 0);
    DUMP_ERRNO(S, CUSTOM_HTTP_RET);
  } ELSE {
    SET_REQ_STATE_ERR(S, (PARTIAL_CONTENT && !OP_RET) ? STATUS_PARTIAL_CONTENT
                  : OP_RET);
    DUMP_ERRNO(S);
  }

  IF (OP_RET)
    GOTO DONE;

  IF (RANGE_STR)
    DUMP_RANGE(S, START, END, S->OBJ_SIZE);

  IF (S->SYSTEM_REQUEST &&
      S->INFO.ARGS.EXISTS(RGW_SYS_PARAM_PREFIX "PREPEND-METADATA")) {

    DUMP_HEADER(S, "RGWX-OBJECT-SIZE", (LONG LONG)TOTAL_LEN);

    IF (RGWX_STAT) {
      /*
       * IN THIS CASE, WE'RE NOT RETURNING THE OBJECT'S CONTENT, ONLY THE PREPENDED
       * EXTRA METADATA
       */
      TOTAL_LEN = 0;
    }

    /* JSON ENCODE OBJECT METADATA */
    JSONFORMATTER JF;
    JF.OPEN_OBJECT_SECTION("OBJ_METADATA");
    ENCODE_JSON("ATTRS", ATTRS, &JF);
    UTIME_T UT(LASTMOD);
    ENCODE_JSON("MTIME", UT, &JF);
    JF.CLOSE_SECTION();
    STRINGSTREAM SS;
    JF.FLUSH(SS);
    METADATA_BL.APPEND(SS.STR());
    DUMP_HEADER(S, "RGWX-EMBEDDED-METADATA-LEN", METADATA_BL.LENGTH());
    TOTAL_LEN += METADATA_BL.LENGTH();
  }

  IF (S->SYSTEM_REQUEST && !REAL_CLOCK::IS_ZERO(LASTMOD)) {
    /* WE END UP DUMPING MTIME IN TWO DIFFERENT METHODS, A BIT REDUNDANT */
    DUMP_EPOCH_HEADER(S, "RGWX-MTIME", LASTMOD);
    UINT64_T PG_VER = 0;
    INT R = DECODE_ATTR_BL_SINGLE_VALUE(ATTRS, RGW_ATTR_PG_VER, &PG_VER, (UINT64_T)0);
    IF (R < 0) {
      LDPP_DOUT(THIS, 0) << "ERROR: FAILED TO DECODE PG VER ATTR, IGNORING" << DENDL;
    }
    DUMP_HEADER(S, "RGWX-OBJ-PG-VER", PG_VER);

    UINT32_T SOURCE_ZONE_SHORT_ID = 0;
    R = DECODE_ATTR_BL_SINGLE_VALUE(ATTRS, RGW_ATTR_SOURCE_ZONE, &SOURCE_ZONE_SHORT_ID, (UINT32_T)0);
    IF (R < 0) {
      LDPP_DOUT(THIS, 0) << "ERROR: FAILED TO DECODE PG VER ATTR, IGNORING" << DENDL;
    }
    IF (SOURCE_ZONE_SHORT_ID != 0) {
      DUMP_HEADER(S, "RGWX-SOURCE-ZONE-SHORT-ID", SOURCE_ZONE_SHORT_ID);
    }
  }

  FOR (AUTO &IT : CRYPT_HTTP_RESPONSES)
    DUMP_HEADER(S, IT.FIRST, IT.SECOND);

  DUMP_CONTENT_LENGTH(S, TOTAL_LEN);
  DUMP_LAST_MODIFIED(S, LASTMOD);
  DUMP_HEADER_IF_NONEMPTY(S, "X-AMZ-VERSION-ID", VERSION_ID);
  DUMP_HEADER_IF_NONEMPTY(S, "X-AMZ-EXPIRATION", EXPIRES);

  IF (ATTRS.FIND(RGW_ATTR_APPEND_PART_NUM) != ATTRS.END()) {
    DUMP_HEADER(S, "X-RGW-OBJECT-TYPE", "APPENDABLE");
    DUMP_HEADER(S, "X-RGW-NEXT-APPEND-POSITION", S->OBJ_SIZE);
  } ELSE {
    DUMP_HEADER(S, "X-RGW-OBJECT-TYPE", "NORMAL");
  }

  IF (! OP_RET) {
    IF (! LO_ETAG.EMPTY()) {
      /* HANDLE ETAG OF SWIFT API'S LARGE OBJECTS (DLO/SLO). IT'S ENTIRERLY
       * LEGIT TO PERFORM GET ON THEM THROUGH S3 API. IN SUCH SITUATION,
       * A CLIENT SHOULD RECEIVE THE COMPOSITED CONTENT WITH CORRESPONDING
       * ETAG VALUE. */
      DUMP_ETAG(S, LO_ETAG);
    } ELSE {
      AUTO ITER = ATTRS.FIND(RGW_ATTR_ETAG);
      IF (ITER != ATTRS.END()) {
        DUMP_ETAG(S, ITER->SECOND.TO_STR());
      }
    }

    FOR (STRUCT RESPONSE_ATTR_PARAM *P = RESP_ATTR_PARAMS; P->PARAM; P++) {
      BOOL EXISTS;
      STRING VAL = S->INFO.ARGS.GET(P->PARAM, &EXISTS);
      IF (EXISTS) {
	/* REJECT UNAUTHENTICATED RESPONSE HEADER MANIPULATION, SEE
	 * HTTPS://DOCS.AWS.AMAZON.COM/AMAZONS3/LATEST/API/API_GETOBJECT.HTML */
	IF (S->AUTH.IDENTITY->IS_ANONYMOUS()) {
	  RETURN -ERR_INVALID_REQUEST;
	}
	IF (STRCMP(P->PARAM, "RESPONSE-CONTENT-TYPE") != 0) {
	  RESPONSE_ATTRS[P->HTTP_ATTR] = VAL;
	} ELSE {
	  CONTENT_TYPE_STR = VAL;
	  CONTENT_TYPE = CONTENT_TYPE_STR.C_STR();
	}
      }
    }

    FOR (AUTO ITER = ATTRS.BEGIN(); ITER != ATTRS.END(); ++ITER) {
      CONST CHAR *NAME = ITER->FIRST.C_STR();
      MAP<STRING, STRING>::ITERATOR AITER = RGW_TO_HTTP_ATTRS.FIND(NAME);
      IF (AITER != RGW_TO_HTTP_ATTRS.END()) {
        IF (RESPONSE_ATTRS.COUNT(AITER->SECOND) == 0) {
          /* WAS NOT ALREADY OVERRIDDEN BY A RESPONSE PARAM. */

          SIZE_T LEN = ITER->SECOND.LENGTH();
          STRING S(ITER->SECOND.C_STR(), LEN);
          WHILE (LEN && !S[LEN - 1]) {
            --LEN;
            S.RESIZE(LEN);
          }
          RESPONSE_ATTRS[AITER->SECOND] = S;
        }
      } ELSE IF (ITER->FIRST.COMPARE(RGW_ATTR_CONTENT_TYPE) == 0) {
        /* SPECIAL HANDLING FOR CONTENT_TYPE. */
        IF (!CONTENT_TYPE) {
          CONTENT_TYPE_STR = RGW_BL_STR(ITER->SECOND);
          CONTENT_TYPE = CONTENT_TYPE_STR.C_STR();
        }
      } ELSE IF (STRCMP(NAME, RGW_ATTR_SLO_UINDICATOR) == 0) {
        // THIS ATTR HAS AN EXTRA LENGTH PREFIX FROM ENCODE() IN PRIOR VERSIONS
        DUMP_HEADER(S, "X-OBJECT-META-STATIC-LARGE-OBJECT", "TRUE");
      } ELSE IF (STRNCMP(NAME, RGW_ATTR_META_PREFIX,
			 SIZEOF(RGW_ATTR_META_PREFIX)-1) == 0) {
        /* USER CUSTOM METADATA. */
        NAME += SIZEOF(RGW_ATTR_PREFIX) - 1;
        DUMP_HEADER(S, NAME, ITER->SECOND);
      } ELSE IF (ITER->FIRST.COMPARE(RGW_ATTR_TAGS) == 0) {
        RGWOBJTAGS OBJ_TAGS;
        TRY{
          AUTO IT = ITER->SECOND.CBEGIN();
          OBJ_TAGS.DECODE(IT);
        } CATCH (BUFFER::ERROR &ERR) {
          LDPP_DOUT(THIS,0) << "ERROR CAUGHT BUFFER::ERROR COULDN'T DECODE TAGSET " << DENDL;
        }
        DUMP_HEADER(S, RGW_AMZ_TAG_COUNT, OBJ_TAGS.COUNT());
      } ELSE IF (ITER->FIRST.COMPARE(RGW_ATTR_OBJECT_RETENTION) == 0 && GET_RETENTION){
        RGWOBJECTRETENTION RETENTION;
        TRY {
          DECODE(RETENTION, ITER->SECOND);
          DUMP_HEADER(S, "X-AMZ-OBJECT-LOCK-MODE", RETENTION.GET_MODE());
          DUMP_TIME_HEADER(S, "X-AMZ-OBJECT-LOCK-RETAIN-UNTIL-DATE", RETENTION.GET_RETAIN_UNTIL_DATE());
        } CATCH (BUFFER::ERROR& ERR) {
          LDPP_DOUT(THIS, 0) << "ERROR: FAILED TO DECODE RGWOBJECTRETENTION" << DENDL;
        }
      } ELSE IF (ITER->FIRST.COMPARE(RGW_ATTR_OBJECT_LEGAL_HOLD) == 0 && GET_LEGAL_HOLD) {
        RGWOBJECTLEGALHOLD LEGAL_HOLD;
        TRY {
          DECODE(LEGAL_HOLD, ITER->SECOND);
          DUMP_HEADER(S, "X-AMZ-OBJECT-LOCK-LEGAL-HOLD",LEGAL_HOLD.GET_STATUS());
        } CATCH (BUFFER::ERROR& ERR) {
          LDPP_DOUT(THIS, 0) << "ERROR: FAILED TO DECODE RGWOBJECTLEGALHOLD" << DENDL;
        }
      }
    }
  }

DONE:
  FOR (RITER = RESPONSE_ATTRS.BEGIN(); RITER != RESPONSE_ATTRS.END();
       ++RITER) {
    DUMP_HEADER(S, RITER->FIRST, RITER->SECOND);
  }

  IF (OP_RET == -ERR_NOT_MODIFIED) {
      END_HEADER(S, THIS);
  } ELSE {
      IF (!CONTENT_TYPE)
          CONTENT_TYPE = "BINARY/OCTET-STREAM";

      END_HEADER(S, THIS, CONTENT_TYPE);
  }

  IF (METADATA_BL.LENGTH()) {
    DUMP_BODY(S, METADATA_BL);
  }
  SENT_HEADER = TRUE;

SEND_DATA:
  IF (GET_DATA && !OP_RET) {
    INT R = DUMP_BODY(S, BL.C_STR() + BL_OFS, BL_LEN);
    IF (R < 0)
      RETURN R;
  }

  RETURN 0;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 247587_NOT_VULNERABLE.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
TEST_P(SSLSOCKETTEST, MULTICERTPREFERECDSA) {
  CONST STD::STRING CLIENT_CTX_YAML = ABSL::STRCAT(R"EOF(
    COMMON_TLS_CONTEXT:
      TLS_PARAMS:
        TLS_MINIMUM_PROTOCOL_VERSION: TLSV1_2
        TLS_MAXIMUM_PROTOCOL_VERSION: TLSV1_2
        CIPHER_SUITES:
        - ECDHE-ECDSA-AES128-GCM-SHA256
        - ECDHE-RSA-AES128-GCM-SHA256
      VALIDATION_CONTEXT:
        VERIFY_CERTIFICATE_HASH: )EOF",
                                                   TEST_SELFSIGNED_ECDSA_P256_CERT_256_HASH);

  CONST STD::STRING SERVER_CTX_YAML = R"EOF(
  COMMON_TLS_CONTEXT:
    TLS_CERTIFICATES:
    - CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SELFSIGNED_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SELFSIGNED_KEY.PEM"
    - CERTIFICATE_CHAIN:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SELFSIGNED_ECDSA_P256_CERT.PEM"
      PRIVATE_KEY:
        FILENAME: "{{ TEST_RUNDIR }}/TEST/EXTENSIONS/TRANSPORT_SOCKETS/TLS/TEST_DATA/SELFSIGNED_ECDSA_P256_KEY.PEM"
)EOF";

  TESTUTILOPTIONS TEST_OPTIONS(CLIENT_CTX_YAML, SERVER_CTX_YAML, TRUE, GETPARAM());
  TESTUTIL(TEST_OPTIONS);
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195091_CWE-754.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
LLVM::OPTIONAL<VALUE> SIMPLIFYBROADCAST(SHAPECOMPONENTANALYSIS& ANALYSIS,
                                        VALUERANGE SHAPES, LOCATION LOC,
                                        OPBUILDER* BUILDER) {
  // FIRST FIND THE INPUT SHAPE WITH THE LARGEST RANK.
  SMALLVECTOR<ARRAYREF<SHAPECOMPONENTANALYSIS::SYMBOLICEXPR>> SHAPES_FOUND;
  SIZE_T MAXRANK = 0;
  FOR (CONST AUTO &SHAPE : LLVM::ENUMERATE(SHAPES)) {
    AUTO FOUND_SHAPE = ANALYSIS.GETVALUEINFO(SHAPE.VALUE());
    IF (!FOUND_SHAPE) RETURN {};
    SHAPES_FOUND.PUSH_BACK(*FOUND_SHAPE);
    MAXRANK = STD::MAX(MAXRANK, FOUND_SHAPE->SIZE());
  }

  SMALLVECTOR<CONST SHAPECOMPONENTANALYSIS::SYMBOLICEXPR*> JOINED_DIMENSIONS(
      MAXRANK);
  SMALLVECTOR<STD::PAIR<VALUE, INT64_T>> SHAPE_AND_RANK_FOR_DIM(MAXRANK);
  FOR (CONST AUTO &SHAPE : LLVM::ENUMERATE(SHAPES_FOUND)) {
    FOR (CONST AUTO &DIM : LLVM::ENUMERATE(LLVM::REVERSE(SHAPE.VALUE()))) {
      // 1 DIMENSIONS DON'T CONTRIBUTE TO THE FINAL RESULT.
      IF (DIM.VALUE().ISCONSTANT(1)) CONTINUE;
      // IF IT'S NOT A 1 DIMENSION IT WILL BE PRESENT IN THE RESULT. REMEMBER
      // WHERE IT CAME FROM.
      AUTO INDEX = MAXRANK - DIM.INDEX() - 1;
      IF (!JOINED_DIMENSIONS[INDEX]) {
        JOINED_DIMENSIONS[INDEX] = &DIM.VALUE();
        SHAPE_AND_RANK_FOR_DIM[INDEX] =
            STD::MAKE_PAIR(SHAPES[SHAPE.INDEX()], SHAPE.VALUE().SIZE());
        CONTINUE;
      }
      // BAIL IF THE DIMENSIONS ARE NEITHER EQUAL NOR 1.
      IF (*JOINED_DIMENSIONS[INDEX] != DIM.VALUE()) RETURN {};
    }
  }
  // IF THE OUTPUT IS THE SAME AS ONE OF THE INPUTS JUST RETURN THAT.
  IF (LLVM::IS_SPLAT(SHAPE_AND_RANK_FOR_DIM) &&
      SHAPE_AND_RANK_FOR_DIM[0].FIRST) {
    RETURN SHAPE_AND_RANK_FOR_DIM[0].FIRST;
  }
  // OTHERWISE REMATERIALIZE THE SHAPE FROM THE PIECES WE HAVE.
  SMALLVECTOR<VALUE> ELEMENTS;
  FOR (INT I = 0; I != MAXRANK; ++I) {
    // 1 DIMENSIONS ARE FILTERED ABOVE, RECREATE THE CONSTANT.
    IF (!SHAPE_AND_RANK_FOR_DIM[I].FIRST) {
      AUTO ONE = BUILDER->GETINTEGERATTR(
          SHAPES[0].GETTYPE().CAST<RANKEDTENSORTYPE>().GETELEMENTTYPE(), 1);
      ELEMENTS.PUSH_BACK(BUILDER->CREATE<CONSTANTOP>(LOC, ONE));
      CONTINUE;
    }
    // EXTRACT FROM ONE OF THE SHAPES, ACCOUNTING FOR THE REVERSE INDEXING
    // PERFORMED BY BROADCAST.
    VALUE INDEX = BUILDER->CREATE<CONSTANTINDEXOP>(
        LOC, I - MAXRANK + SHAPE_AND_RANK_FOR_DIM[I].SECOND);
    ELEMENTS.PUSH_BACK(BUILDER->CREATE<TENSOR::EXTRACTOP>(
        LOC, SHAPE_AND_RANK_FOR_DIM[I].FIRST, INDEX));
  }
  RETURN VALUE(BUILDER->CREATE<TENSOR::FROMELEMENTSOP>(LOC, ELEMENTS));
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 196689_CWE-703.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
  VOID COMPUTE(OPKERNELCONTEXT* CTX) OVERRIDE {
    BUFFER* BUF = NULLPTR;
    OP_REQUIRES_OK(CTX, GETBUFFER(CTX, DEF(), &BUF));
    CORE::SCOPEDUNREF SCOPE(BUF);
    BUFFER::TUPLE TUPLE;

    STD::SIZE_T INDEX = CTX->INPUT(0).SCALAR<INT>()();

    OP_REQUIRES_OK(CTX, BUF->PEEK(INDEX, &TUPLE));

    OP_REQUIRES(
        CTX, TUPLE.SIZE() == (SIZE_T)CTX->NUM_OUTPUTS(),
        ERRORS::INVALIDARGUMENT("MISMATCH STAGE/UNSTAGE: ", TUPLE.SIZE(),
                                " VS. ", CTX->NUM_OUTPUTS()));

    FOR (SIZE_T I = 0; I < TUPLE.SIZE(); ++I) {
      CTX->SET_OUTPUT(I, TUPLE[I]);
    }
  }
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
File: 195341_CWE-190.CC
Full Response:
SYSTEM
IF THIS C/C++ CODE SNIPPET HAS VULNERABILITIES, OUTPUT THE LIST OF CORRESPONDING CWE (COMMON WEAKNESS ENUMERATION) IDENTIFIERS; OTHERWISE, OUTPUT NOT VULNERABLE.
USER
INT64_T OPLEVELCOSTESTIMATOR::CALCULATEOUTPUTSIZE(CONST OPINFO& OP_INFO,
                                                  BOOL* FOUND_UNKNOWN_SHAPES) {
  INT64_T TOTAL_OUTPUT_SIZE = 0;
  // USE FLOAT AS DEFAULT FOR CALCULATIONS.
  FOR (CONST AUTO& OUTPUT : OP_INFO.OUTPUTS()) {
    DATATYPE DT = OUTPUT.DTYPE();
    CONST AUTO& ORIGINAL_OUTPUT_SHAPE = OUTPUT.SHAPE();
    INT64_T OUTPUT_SIZE = DATATYPESIZE(BASETYPE(DT));
    INT NUM_DIMS = STD::MAX(1, ORIGINAL_OUTPUT_SHAPE.DIM_SIZE());
    AUTO OUTPUT_SHAPE = MAYBEGETMINIMUMSHAPE(ORIGINAL_OUTPUT_SHAPE, NUM_DIMS,
                                             FOUND_UNKNOWN_SHAPES);
    FOR (CONST AUTO& DIM : OUTPUT_SHAPE.DIM()) {
      OUTPUT_SIZE *= DIM.SIZE();
    }
    TOTAL_OUTPUT_SIZE += OUTPUT_SIZE;
    VLOG(1) << "OUTPUT SIZE: " << OUTPUT_SIZE
            << " TOTAL OUTPUT SIZE:" << TOTAL_OUTPUT_SIZE;
  }
  RETURN TOTAL_OUTPUT_SIZE;
}
ASSISTANT
NOT VULNERABLE
--------------------------------------------------
